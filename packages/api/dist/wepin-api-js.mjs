var events$1 = { exports: {} }, R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function(t, o, r) {
  return Function.prototype.apply.call(t, o, r);
}, ReflectOwnKeys;
R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : ReflectOwnKeys = function(t) {
  return Object.getOwnPropertyNames(t);
};
function ProcessEmitWarning(e) {
  console && console.warn && console.warn(e);
}
var NumberIsNaN = Number.isNaN || function(t) {
  return t !== t;
};
function EventEmitter$1() {
  EventEmitter$1.init.call(this);
}
events$1.exports = EventEmitter$1;
events$1.exports.once = once;
EventEmitter$1.EventEmitter = EventEmitter$1;
EventEmitter$1.prototype._events = void 0;
EventEmitter$1.prototype._eventsCount = 0;
EventEmitter$1.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(EventEmitter$1, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || NumberIsNaN(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    defaultMaxListeners = e;
  }
});
EventEmitter$1.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$1.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || NumberIsNaN(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function _getMaxListeners(e) {
  return e._maxListeners === void 0 ? EventEmitter$1.defaultMaxListeners : e._maxListeners;
}
EventEmitter$1.prototype.getMaxListeners = function() {
  return _getMaxListeners(this);
};
EventEmitter$1.prototype.emit = function(t) {
  for (var o = [], r = 1; r < arguments.length; r++)
    o.push(arguments[r]);
  var h = t === "error", a = this._events;
  if (a !== void 0)
    h = h && a.error === void 0;
  else if (!h)
    return !1;
  if (h) {
    var p;
    if (o.length > 0 && (p = o[0]), p instanceof Error)
      throw p;
    var d = new Error("Unhandled error." + (p ? " (" + p.message + ")" : ""));
    throw d.context = p, d;
  }
  var b = a[t];
  if (b === void 0)
    return !1;
  if (typeof b == "function")
    ReflectApply(b, this, o);
  else
    for (var g = b.length, w = arrayClone$1(b, g), r = 0; r < g; ++r)
      ReflectApply(w[r], this, o);
  return !0;
};
function _addListener(e, t, o, r) {
  var h, a, p;
  if (checkListener(o), a = e._events, a === void 0 ? (a = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (a.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    o.listener ? o.listener : o
  ), a = e._events), p = a[t]), p === void 0)
    p = a[t] = o, ++e._eventsCount;
  else if (typeof p == "function" ? p = a[t] = r ? [o, p] : [p, o] : r ? p.unshift(o) : p.push(o), h = _getMaxListeners(e), h > 0 && p.length > h && !p.warned) {
    p.warned = !0;
    var d = new Error("Possible EventEmitter memory leak detected. " + p.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    d.name = "MaxListenersExceededWarning", d.emitter = e, d.type = t, d.count = p.length, ProcessEmitWarning(d);
  }
  return e;
}
EventEmitter$1.prototype.addListener = function(t, o) {
  return _addListener(this, t, o, !1);
};
EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;
EventEmitter$1.prototype.prependListener = function(t, o) {
  return _addListener(this, t, o, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(e, t, o) {
  var r = { fired: !1, wrapFn: void 0, target: e, type: t, listener: o }, h = onceWrapper.bind(r);
  return h.listener = o, r.wrapFn = h, h;
}
EventEmitter$1.prototype.once = function(t, o) {
  return checkListener(o), this.on(t, _onceWrap(this, t, o)), this;
};
EventEmitter$1.prototype.prependOnceListener = function(t, o) {
  return checkListener(o), this.prependListener(t, _onceWrap(this, t, o)), this;
};
EventEmitter$1.prototype.removeListener = function(t, o) {
  var r, h, a, p, d;
  if (checkListener(o), h = this._events, h === void 0)
    return this;
  if (r = h[t], r === void 0)
    return this;
  if (r === o || r.listener === o)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete h[t], h.removeListener && this.emit("removeListener", t, r.listener || o));
  else if (typeof r != "function") {
    for (a = -1, p = r.length - 1; p >= 0; p--)
      if (r[p] === o || r[p].listener === o) {
        d = r[p].listener, a = p;
        break;
      }
    if (a < 0)
      return this;
    a === 0 ? r.shift() : spliceOne(r, a), r.length === 1 && (h[t] = r[0]), h.removeListener !== void 0 && this.emit("removeListener", t, d || o);
  }
  return this;
};
EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener;
EventEmitter$1.prototype.removeAllListeners = function(t) {
  var o, r, h;
  if (r = this._events, r === void 0)
    return this;
  if (r.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : r[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete r[t]), this;
  if (arguments.length === 0) {
    var a = Object.keys(r), p;
    for (h = 0; h < a.length; ++h)
      p = a[h], p !== "removeListener" && this.removeAllListeners(p);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (o = r[t], typeof o == "function")
    this.removeListener(t, o);
  else if (o !== void 0)
    for (h = o.length - 1; h >= 0; h--)
      this.removeListener(t, o[h]);
  return this;
};
function _listeners(e, t, o) {
  var r = e._events;
  if (r === void 0)
    return [];
  var h = r[t];
  return h === void 0 ? [] : typeof h == "function" ? o ? [h.listener || h] : [h] : o ? unwrapListeners(h) : arrayClone$1(h, h.length);
}
EventEmitter$1.prototype.listeners = function(t) {
  return _listeners(this, t, !0);
};
EventEmitter$1.prototype.rawListeners = function(t) {
  return _listeners(this, t, !1);
};
EventEmitter$1.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : listenerCount.call(e, t);
};
EventEmitter$1.prototype.listenerCount = listenerCount;
function listenerCount(e) {
  var t = this._events;
  if (t !== void 0) {
    var o = t[e];
    if (typeof o == "function")
      return 1;
    if (o !== void 0)
      return o.length;
  }
  return 0;
}
EventEmitter$1.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone$1(e, t) {
  for (var o = new Array(t), r = 0; r < t; ++r)
    o[r] = e[r];
  return o;
}
function spliceOne(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function unwrapListeners(e) {
  for (var t = new Array(e.length), o = 0; o < t.length; ++o)
    t[o] = e[o].listener || e[o];
  return t;
}
function once(e, t) {
  return new Promise(function(o, r) {
    function h(p) {
      e.removeListener(t, a), r(p);
    }
    function a() {
      typeof e.removeListener == "function" && e.removeListener("error", h), o([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(e, t, a, { once: !0 }), t !== "error" && addErrorHandlerIfEventEmitter(e, h, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(e, t, o) {
  typeof e.on == "function" && eventTargetAgnosticAddListener(e, "error", t, o);
}
function eventTargetAgnosticAddListener(e, t, o, r) {
  if (typeof e.on == "function")
    r.once ? e.once(t, o) : e.on(t, o);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function h(a) {
      r.once && e.removeEventListener(t, h), o(a);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var eventsExports = events$1.exports;
function safeApply(e, t, o) {
  try {
    Reflect.apply(e, t, o);
  } catch (r) {
    setTimeout(() => {
      throw r;
    });
  }
}
function arrayClone(e) {
  const t = e.length, o = new Array(t);
  for (let r = 0; r < t; r += 1)
    o[r] = e[r];
  return o;
}
class SafeEventEmitter extends eventsExports.EventEmitter {
  emit(t, ...o) {
    let r = t === "error";
    const h = this._events;
    if (h !== void 0)
      r = r && h.error === void 0;
    else if (!r)
      return !1;
    if (r) {
      let p;
      if (o.length > 0 && ([p] = o), p instanceof Error)
        throw p;
      const d = new Error(`Unhandled error.${p ? ` (${p.message})` : ""}`);
      throw d.context = p, d;
    }
    const a = h[t];
    if (a === void 0)
      return !1;
    if (typeof a == "function")
      safeApply(a, this, o);
    else {
      const p = a.length, d = arrayClone(a);
      for (let b = 0; b < p; b += 1)
        safeApply(d[b], this, o);
    }
    return !0;
  }
}
const name$2 = "@wepin/api-js", version$2 = "0.0.1", description$2 = "Wepin API library for Web", author$2 = "IoTrust, Co., Ltd.", homepage$1 = "https://github.com/WepinWallet/wepin-web-sdk-v1/", license$2 = "MIT", main$2 = "./dist/wepin-api-js.mjs", jsdelivr = "./dist/wepin-api-js.umd.js", types$2 = "./dist/src/index.d.ts", files$2 = [
  "dist"
], scripts$2 = {
  build: "vite build --mode production",
  dev: "vite build --mode development",
  watch: "vite build --watch",
  lint: "eslint . --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts --fix --ignore-path .gitignore"
}, keywords$2 = [
  "wepin",
  "wepinwallet",
  "wallet"
], dependencies$2 = {
  "@wepin/fetch-js": "link:../fetch",
  "@wepin/storage-js": "link:../storage",
  "@wepin/utils": "^1.0.3",
  "bignumber.js": "^9.1.2",
  events: "^3.3.0",
  "jwt-decode": "^4.0.0"
}, devDependencies$2 = {
  "@types/events": "^3.0.3"
}, PackageJson = {
  name: name$2,
  version: version$2,
  description: description$2,
  author: author$2,
  homepage: homepage$1,
  license: license$2,
  main: main$2,
  jsdelivr,
  types: types$2,
  files: files$2,
  scripts: scripts$2,
  keywords: keywords$2,
  dependencies: dependencies$2,
  devDependencies: devDependencies$2
};
var buffer$2 = {}, base64Js$1 = {};
base64Js$1.byteLength = byteLength;
base64Js$1.toByteArray = toByteArray;
base64Js$1.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len = code.length; i$2 < len; ++i$2)
  lookup[i$2] = code[i$2], revLookup[code.charCodeAt(i$2)] = i$2;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var o = e.indexOf("=");
  o === -1 && (o = t);
  var r = o === t ? 0 : 4 - o % 4;
  return [o, r];
}
function byteLength(e) {
  var t = getLens(e), o = t[0], r = t[1];
  return (o + r) * 3 / 4 - r;
}
function _byteLength(e, t, o) {
  return (t + o) * 3 / 4 - o;
}
function toByteArray(e) {
  var t, o = getLens(e), r = o[0], h = o[1], a = new Arr(_byteLength(e, r, h)), p = 0, d = h > 0 ? r - 4 : r, b;
  for (b = 0; b < d; b += 4)
    t = revLookup[e.charCodeAt(b)] << 18 | revLookup[e.charCodeAt(b + 1)] << 12 | revLookup[e.charCodeAt(b + 2)] << 6 | revLookup[e.charCodeAt(b + 3)], a[p++] = t >> 16 & 255, a[p++] = t >> 8 & 255, a[p++] = t & 255;
  return h === 2 && (t = revLookup[e.charCodeAt(b)] << 2 | revLookup[e.charCodeAt(b + 1)] >> 4, a[p++] = t & 255), h === 1 && (t = revLookup[e.charCodeAt(b)] << 10 | revLookup[e.charCodeAt(b + 1)] << 4 | revLookup[e.charCodeAt(b + 2)] >> 2, a[p++] = t >> 8 & 255, a[p++] = t & 255), a;
}
function tripletToBase64(e) {
  return lookup[e >> 18 & 63] + lookup[e >> 12 & 63] + lookup[e >> 6 & 63] + lookup[e & 63];
}
function encodeChunk(e, t, o) {
  for (var r, h = [], a = t; a < o; a += 3)
    r = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (e[a + 2] & 255), h.push(tripletToBase64(r));
  return h.join("");
}
function fromByteArray(e) {
  for (var t, o = e.length, r = o % 3, h = [], a = 16383, p = 0, d = o - r; p < d; p += a)
    h.push(encodeChunk(e, p, p + a > d ? d : p + a));
  return r === 1 ? (t = e[o - 1], h.push(
    lookup[t >> 2] + lookup[t << 4 & 63] + "=="
  )) : r === 2 && (t = (e[o - 2] << 8) + e[o - 1], h.push(
    lookup[t >> 10] + lookup[t >> 4 & 63] + lookup[t << 2 & 63] + "="
  )), h.join("");
}
var ieee754$1 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754$1.read = function(e, t, o, r, h) {
  var a, p, d = h * 8 - r - 1, b = (1 << d) - 1, g = b >> 1, w = -7, C = o ? h - 1 : 0, T = o ? -1 : 1, k = e[t + C];
  for (C += T, a = k & (1 << -w) - 1, k >>= -w, w += d; w > 0; a = a * 256 + e[t + C], C += T, w -= 8)
    ;
  for (p = a & (1 << -w) - 1, a >>= -w, w += r; w > 0; p = p * 256 + e[t + C], C += T, w -= 8)
    ;
  if (a === 0)
    a = 1 - g;
  else {
    if (a === b)
      return p ? NaN : (k ? -1 : 1) * (1 / 0);
    p = p + Math.pow(2, r), a = a - g;
  }
  return (k ? -1 : 1) * p * Math.pow(2, a - r);
};
ieee754$1.write = function(e, t, o, r, h, a) {
  var p, d, b, g = a * 8 - h - 1, w = (1 << g) - 1, C = w >> 1, T = h === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, k = r ? 0 : a - 1, q = r ? 1 : -1, O = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (d = isNaN(t) ? 1 : 0, p = w) : (p = Math.floor(Math.log(t) / Math.LN2), t * (b = Math.pow(2, -p)) < 1 && (p--, b *= 2), p + C >= 1 ? t += T / b : t += T * Math.pow(2, 1 - C), t * b >= 2 && (p++, b /= 2), p + C >= w ? (d = 0, p = w) : p + C >= 1 ? (d = (t * b - 1) * Math.pow(2, h), p = p + C) : (d = t * Math.pow(2, C - 1) * Math.pow(2, h), p = 0)); h >= 8; e[o + k] = d & 255, k += q, d /= 256, h -= 8)
    ;
  for (p = p << h | d, g += h; g > 0; e[o + k] = p & 255, k += q, p /= 256, g -= 8)
    ;
  e[o + k - q] |= O * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  var t = base64Js$1, o = ieee754$1, r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = d, e.SlowBuffer = U, e.INSPECT_MAX_BYTES = 50;
  var h = 2147483647;
  e.kMaxLength = h, d.TYPED_ARRAY_SUPPORT = a(), !d.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function a() {
    try {
      var x = new Uint8Array(1), L = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(L, Uint8Array.prototype), Object.setPrototypeOf(x, L), x.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(d.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (d.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(d.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (d.isBuffer(this))
        return this.byteOffset;
    }
  });
  function p(x) {
    if (x > h)
      throw new RangeError('The value "' + x + '" is invalid for option "size"');
    var L = new Uint8Array(x);
    return Object.setPrototypeOf(L, d.prototype), L;
  }
  function d(x, L, D) {
    if (typeof x == "number") {
      if (typeof L == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return C(x);
    }
    return b(x, L, D);
  }
  d.poolSize = 8192;
  function b(x, L, D) {
    if (typeof x == "string")
      return T(x, L);
    if (ArrayBuffer.isView(x))
      return q(x);
    if (x == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof x
      );
    if (de(x, ArrayBuffer) || x && de(x.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (de(x, SharedArrayBuffer) || x && de(x.buffer, SharedArrayBuffer)))
      return O(x, L, D);
    if (typeof x == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    var F = x.valueOf && x.valueOf();
    if (F != null && F !== x)
      return d.from(F, L, D);
    var ue = N(x);
    if (ue)
      return ue;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof x[Symbol.toPrimitive] == "function")
      return d.from(
        x[Symbol.toPrimitive]("string"),
        L,
        D
      );
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof x
    );
  }
  d.from = function(x, L, D) {
    return b(x, L, D);
  }, Object.setPrototypeOf(d.prototype, Uint8Array.prototype), Object.setPrototypeOf(d, Uint8Array);
  function g(x) {
    if (typeof x != "number")
      throw new TypeError('"size" argument must be of type number');
    if (x < 0)
      throw new RangeError('The value "' + x + '" is invalid for option "size"');
  }
  function w(x, L, D) {
    return g(x), x <= 0 ? p(x) : L !== void 0 ? typeof D == "string" ? p(x).fill(L, D) : p(x).fill(L) : p(x);
  }
  d.alloc = function(x, L, D) {
    return w(x, L, D);
  };
  function C(x) {
    return g(x), p(x < 0 ? 0 : j(x) | 0);
  }
  d.allocUnsafe = function(x) {
    return C(x);
  }, d.allocUnsafeSlow = function(x) {
    return C(x);
  };
  function T(x, L) {
    if ((typeof L != "string" || L === "") && (L = "utf8"), !d.isEncoding(L))
      throw new TypeError("Unknown encoding: " + L);
    var D = H(x, L) | 0, F = p(D), ue = F.write(x, L);
    return ue !== D && (F = F.slice(0, ue)), F;
  }
  function k(x) {
    for (var L = x.length < 0 ? 0 : j(x.length) | 0, D = p(L), F = 0; F < L; F += 1)
      D[F] = x[F] & 255;
    return D;
  }
  function q(x) {
    if (de(x, Uint8Array)) {
      var L = new Uint8Array(x);
      return O(L.buffer, L.byteOffset, L.byteLength);
    }
    return k(x);
  }
  function O(x, L, D) {
    if (L < 0 || x.byteLength < L)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (x.byteLength < L + (D || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var F;
    return L === void 0 && D === void 0 ? F = new Uint8Array(x) : D === void 0 ? F = new Uint8Array(x, L) : F = new Uint8Array(x, L, D), Object.setPrototypeOf(F, d.prototype), F;
  }
  function N(x) {
    if (d.isBuffer(x)) {
      var L = j(x.length) | 0, D = p(L);
      return D.length === 0 || x.copy(D, 0, 0, L), D;
    }
    if (x.length !== void 0)
      return typeof x.length != "number" || Ae(x.length) ? p(0) : k(x);
    if (x.type === "Buffer" && Array.isArray(x.data))
      return k(x.data);
  }
  function j(x) {
    if (x >= h)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + h.toString(16) + " bytes");
    return x | 0;
  }
  function U(x) {
    return +x != x && (x = 0), d.alloc(+x);
  }
  d.isBuffer = function(L) {
    return L != null && L._isBuffer === !0 && L !== d.prototype;
  }, d.compare = function(L, D) {
    if (de(L, Uint8Array) && (L = d.from(L, L.offset, L.byteLength)), de(D, Uint8Array) && (D = d.from(D, D.offset, D.byteLength)), !d.isBuffer(L) || !d.isBuffer(D))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (L === D)
      return 0;
    for (var F = L.length, ue = D.length, ge = 0, ce = Math.min(F, ue); ge < ce; ++ge)
      if (L[ge] !== D[ge]) {
        F = L[ge], ue = D[ge];
        break;
      }
    return F < ue ? -1 : ue < F ? 1 : 0;
  }, d.isEncoding = function(L) {
    switch (String(L).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, d.concat = function(L, D) {
    if (!Array.isArray(L))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (L.length === 0)
      return d.alloc(0);
    var F;
    if (D === void 0)
      for (D = 0, F = 0; F < L.length; ++F)
        D += L[F].length;
    var ue = d.allocUnsafe(D), ge = 0;
    for (F = 0; F < L.length; ++F) {
      var ce = L[F];
      if (de(ce, Uint8Array))
        ge + ce.length > ue.length ? d.from(ce).copy(ue, ge) : Uint8Array.prototype.set.call(
          ue,
          ce,
          ge
        );
      else if (d.isBuffer(ce))
        ce.copy(ue, ge);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      ge += ce.length;
    }
    return ue;
  };
  function H(x, L) {
    if (d.isBuffer(x))
      return x.length;
    if (ArrayBuffer.isView(x) || de(x, ArrayBuffer))
      return x.byteLength;
    if (typeof x != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof x
      );
    var D = x.length, F = arguments.length > 2 && arguments[2] === !0;
    if (!F && D === 0)
      return 0;
    for (var ue = !1; ; )
      switch (L) {
        case "ascii":
        case "latin1":
        case "binary":
          return D;
        case "utf8":
        case "utf-8":
          return Q(x).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return D * 2;
        case "hex":
          return D >>> 1;
        case "base64":
          return Y(x).length;
        default:
          if (ue)
            return F ? -1 : Q(x).length;
          L = ("" + L).toLowerCase(), ue = !0;
      }
  }
  d.byteLength = H;
  function z(x, L, D) {
    var F = !1;
    if ((L === void 0 || L < 0) && (L = 0), L > this.length || ((D === void 0 || D > this.length) && (D = this.length), D <= 0) || (D >>>= 0, L >>>= 0, D <= L))
      return "";
    for (x || (x = "utf8"); ; )
      switch (x) {
        case "hex":
          return _(this, L, D);
        case "utf8":
        case "utf-8":
          return y(this, L, D);
        case "ascii":
          return B(this, L, D);
        case "latin1":
        case "binary":
          return S(this, L, D);
        case "base64":
          return f(this, L, D);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return E(this, L, D);
        default:
          if (F)
            throw new TypeError("Unknown encoding: " + x);
          x = (x + "").toLowerCase(), F = !0;
      }
  }
  d.prototype._isBuffer = !0;
  function ee(x, L, D) {
    var F = x[L];
    x[L] = x[D], x[D] = F;
  }
  d.prototype.swap16 = function() {
    var L = this.length;
    if (L % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var D = 0; D < L; D += 2)
      ee(this, D, D + 1);
    return this;
  }, d.prototype.swap32 = function() {
    var L = this.length;
    if (L % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var D = 0; D < L; D += 4)
      ee(this, D, D + 3), ee(this, D + 1, D + 2);
    return this;
  }, d.prototype.swap64 = function() {
    var L = this.length;
    if (L % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var D = 0; D < L; D += 8)
      ee(this, D, D + 7), ee(this, D + 1, D + 6), ee(this, D + 2, D + 5), ee(this, D + 3, D + 4);
    return this;
  }, d.prototype.toString = function() {
    var L = this.length;
    return L === 0 ? "" : arguments.length === 0 ? y(this, 0, L) : z.apply(this, arguments);
  }, d.prototype.toLocaleString = d.prototype.toString, d.prototype.equals = function(L) {
    if (!d.isBuffer(L))
      throw new TypeError("Argument must be a Buffer");
    return this === L ? !0 : d.compare(this, L) === 0;
  }, d.prototype.inspect = function() {
    var L = "", D = e.INSPECT_MAX_BYTES;
    return L = this.toString("hex", 0, D).replace(/(.{2})/g, "$1 ").trim(), this.length > D && (L += " ... "), "<Buffer " + L + ">";
  }, r && (d.prototype[r] = d.prototype.inspect), d.prototype.compare = function(L, D, F, ue, ge) {
    if (de(L, Uint8Array) && (L = d.from(L, L.offset, L.byteLength)), !d.isBuffer(L))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof L
      );
    if (D === void 0 && (D = 0), F === void 0 && (F = L ? L.length : 0), ue === void 0 && (ue = 0), ge === void 0 && (ge = this.length), D < 0 || F > L.length || ue < 0 || ge > this.length)
      throw new RangeError("out of range index");
    if (ue >= ge && D >= F)
      return 0;
    if (ue >= ge)
      return -1;
    if (D >= F)
      return 1;
    if (D >>>= 0, F >>>= 0, ue >>>= 0, ge >>>= 0, this === L)
      return 0;
    for (var ce = ge - ue, ve = F - D, Re = Math.min(ce, ve), ke = this.slice(ue, ge), Ce = L.slice(D, F), Le = 0; Le < Re; ++Le)
      if (ke[Le] !== Ce[Le]) {
        ce = ke[Le], ve = Ce[Le];
        break;
      }
    return ce < ve ? -1 : ve < ce ? 1 : 0;
  };
  function ne(x, L, D, F, ue) {
    if (x.length === 0)
      return -1;
    if (typeof D == "string" ? (F = D, D = 0) : D > 2147483647 ? D = 2147483647 : D < -2147483648 && (D = -2147483648), D = +D, Ae(D) && (D = ue ? 0 : x.length - 1), D < 0 && (D = x.length + D), D >= x.length) {
      if (ue)
        return -1;
      D = x.length - 1;
    } else if (D < 0)
      if (ue)
        D = 0;
      else
        return -1;
    if (typeof L == "string" && (L = d.from(L, F)), d.isBuffer(L))
      return L.length === 0 ? -1 : le(x, L, D, F, ue);
    if (typeof L == "number")
      return L = L & 255, typeof Uint8Array.prototype.indexOf == "function" ? ue ? Uint8Array.prototype.indexOf.call(x, L, D) : Uint8Array.prototype.lastIndexOf.call(x, L, D) : le(x, [L], D, F, ue);
    throw new TypeError("val must be string, number or Buffer");
  }
  function le(x, L, D, F, ue) {
    var ge = 1, ce = x.length, ve = L.length;
    if (F !== void 0 && (F = String(F).toLowerCase(), F === "ucs2" || F === "ucs-2" || F === "utf16le" || F === "utf-16le")) {
      if (x.length < 2 || L.length < 2)
        return -1;
      ge = 2, ce /= 2, ve /= 2, D /= 2;
    }
    function Re(Pe, et) {
      return ge === 1 ? Pe[et] : Pe.readUInt16BE(et * ge);
    }
    var ke;
    if (ue) {
      var Ce = -1;
      for (ke = D; ke < ce; ke++)
        if (Re(x, ke) === Re(L, Ce === -1 ? 0 : ke - Ce)) {
          if (Ce === -1 && (Ce = ke), ke - Ce + 1 === ve)
            return Ce * ge;
        } else
          Ce !== -1 && (ke -= ke - Ce), Ce = -1;
    } else
      for (D + ve > ce && (D = ce - ve), ke = D; ke >= 0; ke--) {
        for (var Le = !0, Oe = 0; Oe < ve; Oe++)
          if (Re(x, ke + Oe) !== Re(L, Oe)) {
            Le = !1;
            break;
          }
        if (Le)
          return ke;
      }
    return -1;
  }
  d.prototype.includes = function(L, D, F) {
    return this.indexOf(L, D, F) !== -1;
  }, d.prototype.indexOf = function(L, D, F) {
    return ne(this, L, D, F, !0);
  }, d.prototype.lastIndexOf = function(L, D, F) {
    return ne(this, L, D, F, !1);
  };
  function Z(x, L, D, F) {
    D = Number(D) || 0;
    var ue = x.length - D;
    F ? (F = Number(F), F > ue && (F = ue)) : F = ue;
    var ge = L.length;
    F > ge / 2 && (F = ge / 2);
    for (var ce = 0; ce < F; ++ce) {
      var ve = parseInt(L.substr(ce * 2, 2), 16);
      if (Ae(ve))
        return ce;
      x[D + ce] = ve;
    }
    return ce;
  }
  function ie(x, L, D, F) {
    return re(Q(L, x.length - D), x, D, F);
  }
  function fe(x, L, D, F) {
    return re(me(L), x, D, F);
  }
  function I(x, L, D, F) {
    return re(Y(L), x, D, F);
  }
  function P(x, L, D, F) {
    return re(be(L, x.length - D), x, D, F);
  }
  d.prototype.write = function(L, D, F, ue) {
    if (D === void 0)
      ue = "utf8", F = this.length, D = 0;
    else if (F === void 0 && typeof D == "string")
      ue = D, F = this.length, D = 0;
    else if (isFinite(D))
      D = D >>> 0, isFinite(F) ? (F = F >>> 0, ue === void 0 && (ue = "utf8")) : (ue = F, F = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    var ge = this.length - D;
    if ((F === void 0 || F > ge) && (F = ge), L.length > 0 && (F < 0 || D < 0) || D > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    ue || (ue = "utf8");
    for (var ce = !1; ; )
      switch (ue) {
        case "hex":
          return Z(this, L, D, F);
        case "utf8":
        case "utf-8":
          return ie(this, L, D, F);
        case "ascii":
        case "latin1":
        case "binary":
          return fe(this, L, D, F);
        case "base64":
          return I(this, L, D, F);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return P(this, L, D, F);
        default:
          if (ce)
            throw new TypeError("Unknown encoding: " + ue);
          ue = ("" + ue).toLowerCase(), ce = !0;
      }
  }, d.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function f(x, L, D) {
    return L === 0 && D === x.length ? t.fromByteArray(x) : t.fromByteArray(x.slice(L, D));
  }
  function y(x, L, D) {
    D = Math.min(x.length, D);
    for (var F = [], ue = L; ue < D; ) {
      var ge = x[ue], ce = null, ve = ge > 239 ? 4 : ge > 223 ? 3 : ge > 191 ? 2 : 1;
      if (ue + ve <= D) {
        var Re, ke, Ce, Le;
        switch (ve) {
          case 1:
            ge < 128 && (ce = ge);
            break;
          case 2:
            Re = x[ue + 1], (Re & 192) === 128 && (Le = (ge & 31) << 6 | Re & 63, Le > 127 && (ce = Le));
            break;
          case 3:
            Re = x[ue + 1], ke = x[ue + 2], (Re & 192) === 128 && (ke & 192) === 128 && (Le = (ge & 15) << 12 | (Re & 63) << 6 | ke & 63, Le > 2047 && (Le < 55296 || Le > 57343) && (ce = Le));
            break;
          case 4:
            Re = x[ue + 1], ke = x[ue + 2], Ce = x[ue + 3], (Re & 192) === 128 && (ke & 192) === 128 && (Ce & 192) === 128 && (Le = (ge & 15) << 18 | (Re & 63) << 12 | (ke & 63) << 6 | Ce & 63, Le > 65535 && Le < 1114112 && (ce = Le));
        }
      }
      ce === null ? (ce = 65533, ve = 1) : ce > 65535 && (ce -= 65536, F.push(ce >>> 10 & 1023 | 55296), ce = 56320 | ce & 1023), F.push(ce), ue += ve;
    }
    return M(F);
  }
  var v = 4096;
  function M(x) {
    var L = x.length;
    if (L <= v)
      return String.fromCharCode.apply(String, x);
    for (var D = "", F = 0; F < L; )
      D += String.fromCharCode.apply(
        String,
        x.slice(F, F += v)
      );
    return D;
  }
  function B(x, L, D) {
    var F = "";
    D = Math.min(x.length, D);
    for (var ue = L; ue < D; ++ue)
      F += String.fromCharCode(x[ue] & 127);
    return F;
  }
  function S(x, L, D) {
    var F = "";
    D = Math.min(x.length, D);
    for (var ue = L; ue < D; ++ue)
      F += String.fromCharCode(x[ue]);
    return F;
  }
  function _(x, L, D) {
    var F = x.length;
    (!L || L < 0) && (L = 0), (!D || D < 0 || D > F) && (D = F);
    for (var ue = "", ge = L; ge < D; ++ge)
      ue += qe[x[ge]];
    return ue;
  }
  function E(x, L, D) {
    for (var F = x.slice(L, D), ue = "", ge = 0; ge < F.length - 1; ge += 2)
      ue += String.fromCharCode(F[ge] + F[ge + 1] * 256);
    return ue;
  }
  d.prototype.slice = function(L, D) {
    var F = this.length;
    L = ~~L, D = D === void 0 ? F : ~~D, L < 0 ? (L += F, L < 0 && (L = 0)) : L > F && (L = F), D < 0 ? (D += F, D < 0 && (D = 0)) : D > F && (D = F), D < L && (D = L);
    var ue = this.subarray(L, D);
    return Object.setPrototypeOf(ue, d.prototype), ue;
  };
  function m(x, L, D) {
    if (x % 1 !== 0 || x < 0)
      throw new RangeError("offset is not uint");
    if (x + L > D)
      throw new RangeError("Trying to access beyond buffer length");
  }
  d.prototype.readUintLE = d.prototype.readUIntLE = function(L, D, F) {
    L = L >>> 0, D = D >>> 0, F || m(L, D, this.length);
    for (var ue = this[L], ge = 1, ce = 0; ++ce < D && (ge *= 256); )
      ue += this[L + ce] * ge;
    return ue;
  }, d.prototype.readUintBE = d.prototype.readUIntBE = function(L, D, F) {
    L = L >>> 0, D = D >>> 0, F || m(L, D, this.length);
    for (var ue = this[L + --D], ge = 1; D > 0 && (ge *= 256); )
      ue += this[L + --D] * ge;
    return ue;
  }, d.prototype.readUint8 = d.prototype.readUInt8 = function(L, D) {
    return L = L >>> 0, D || m(L, 1, this.length), this[L];
  }, d.prototype.readUint16LE = d.prototype.readUInt16LE = function(L, D) {
    return L = L >>> 0, D || m(L, 2, this.length), this[L] | this[L + 1] << 8;
  }, d.prototype.readUint16BE = d.prototype.readUInt16BE = function(L, D) {
    return L = L >>> 0, D || m(L, 2, this.length), this[L] << 8 | this[L + 1];
  }, d.prototype.readUint32LE = d.prototype.readUInt32LE = function(L, D) {
    return L = L >>> 0, D || m(L, 4, this.length), (this[L] | this[L + 1] << 8 | this[L + 2] << 16) + this[L + 3] * 16777216;
  }, d.prototype.readUint32BE = d.prototype.readUInt32BE = function(L, D) {
    return L = L >>> 0, D || m(L, 4, this.length), this[L] * 16777216 + (this[L + 1] << 16 | this[L + 2] << 8 | this[L + 3]);
  }, d.prototype.readIntLE = function(L, D, F) {
    L = L >>> 0, D = D >>> 0, F || m(L, D, this.length);
    for (var ue = this[L], ge = 1, ce = 0; ++ce < D && (ge *= 256); )
      ue += this[L + ce] * ge;
    return ge *= 128, ue >= ge && (ue -= Math.pow(2, 8 * D)), ue;
  }, d.prototype.readIntBE = function(L, D, F) {
    L = L >>> 0, D = D >>> 0, F || m(L, D, this.length);
    for (var ue = D, ge = 1, ce = this[L + --ue]; ue > 0 && (ge *= 256); )
      ce += this[L + --ue] * ge;
    return ge *= 128, ce >= ge && (ce -= Math.pow(2, 8 * D)), ce;
  }, d.prototype.readInt8 = function(L, D) {
    return L = L >>> 0, D || m(L, 1, this.length), this[L] & 128 ? (255 - this[L] + 1) * -1 : this[L];
  }, d.prototype.readInt16LE = function(L, D) {
    L = L >>> 0, D || m(L, 2, this.length);
    var F = this[L] | this[L + 1] << 8;
    return F & 32768 ? F | 4294901760 : F;
  }, d.prototype.readInt16BE = function(L, D) {
    L = L >>> 0, D || m(L, 2, this.length);
    var F = this[L + 1] | this[L] << 8;
    return F & 32768 ? F | 4294901760 : F;
  }, d.prototype.readInt32LE = function(L, D) {
    return L = L >>> 0, D || m(L, 4, this.length), this[L] | this[L + 1] << 8 | this[L + 2] << 16 | this[L + 3] << 24;
  }, d.prototype.readInt32BE = function(L, D) {
    return L = L >>> 0, D || m(L, 4, this.length), this[L] << 24 | this[L + 1] << 16 | this[L + 2] << 8 | this[L + 3];
  }, d.prototype.readFloatLE = function(L, D) {
    return L = L >>> 0, D || m(L, 4, this.length), o.read(this, L, !0, 23, 4);
  }, d.prototype.readFloatBE = function(L, D) {
    return L = L >>> 0, D || m(L, 4, this.length), o.read(this, L, !1, 23, 4);
  }, d.prototype.readDoubleLE = function(L, D) {
    return L = L >>> 0, D || m(L, 8, this.length), o.read(this, L, !0, 52, 8);
  }, d.prototype.readDoubleBE = function(L, D) {
    return L = L >>> 0, D || m(L, 8, this.length), o.read(this, L, !1, 52, 8);
  };
  function A(x, L, D, F, ue, ge) {
    if (!d.isBuffer(x))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (L > ue || L < ge)
      throw new RangeError('"value" argument is out of bounds');
    if (D + F > x.length)
      throw new RangeError("Index out of range");
  }
  d.prototype.writeUintLE = d.prototype.writeUIntLE = function(L, D, F, ue) {
    if (L = +L, D = D >>> 0, F = F >>> 0, !ue) {
      var ge = Math.pow(2, 8 * F) - 1;
      A(this, L, D, F, ge, 0);
    }
    var ce = 1, ve = 0;
    for (this[D] = L & 255; ++ve < F && (ce *= 256); )
      this[D + ve] = L / ce & 255;
    return D + F;
  }, d.prototype.writeUintBE = d.prototype.writeUIntBE = function(L, D, F, ue) {
    if (L = +L, D = D >>> 0, F = F >>> 0, !ue) {
      var ge = Math.pow(2, 8 * F) - 1;
      A(this, L, D, F, ge, 0);
    }
    var ce = F - 1, ve = 1;
    for (this[D + ce] = L & 255; --ce >= 0 && (ve *= 256); )
      this[D + ce] = L / ve & 255;
    return D + F;
  }, d.prototype.writeUint8 = d.prototype.writeUInt8 = function(L, D, F) {
    return L = +L, D = D >>> 0, F || A(this, L, D, 1, 255, 0), this[D] = L & 255, D + 1;
  }, d.prototype.writeUint16LE = d.prototype.writeUInt16LE = function(L, D, F) {
    return L = +L, D = D >>> 0, F || A(this, L, D, 2, 65535, 0), this[D] = L & 255, this[D + 1] = L >>> 8, D + 2;
  }, d.prototype.writeUint16BE = d.prototype.writeUInt16BE = function(L, D, F) {
    return L = +L, D = D >>> 0, F || A(this, L, D, 2, 65535, 0), this[D] = L >>> 8, this[D + 1] = L & 255, D + 2;
  }, d.prototype.writeUint32LE = d.prototype.writeUInt32LE = function(L, D, F) {
    return L = +L, D = D >>> 0, F || A(this, L, D, 4, 4294967295, 0), this[D + 3] = L >>> 24, this[D + 2] = L >>> 16, this[D + 1] = L >>> 8, this[D] = L & 255, D + 4;
  }, d.prototype.writeUint32BE = d.prototype.writeUInt32BE = function(L, D, F) {
    return L = +L, D = D >>> 0, F || A(this, L, D, 4, 4294967295, 0), this[D] = L >>> 24, this[D + 1] = L >>> 16, this[D + 2] = L >>> 8, this[D + 3] = L & 255, D + 4;
  }, d.prototype.writeIntLE = function(L, D, F, ue) {
    if (L = +L, D = D >>> 0, !ue) {
      var ge = Math.pow(2, 8 * F - 1);
      A(this, L, D, F, ge - 1, -ge);
    }
    var ce = 0, ve = 1, Re = 0;
    for (this[D] = L & 255; ++ce < F && (ve *= 256); )
      L < 0 && Re === 0 && this[D + ce - 1] !== 0 && (Re = 1), this[D + ce] = (L / ve >> 0) - Re & 255;
    return D + F;
  }, d.prototype.writeIntBE = function(L, D, F, ue) {
    if (L = +L, D = D >>> 0, !ue) {
      var ge = Math.pow(2, 8 * F - 1);
      A(this, L, D, F, ge - 1, -ge);
    }
    var ce = F - 1, ve = 1, Re = 0;
    for (this[D + ce] = L & 255; --ce >= 0 && (ve *= 256); )
      L < 0 && Re === 0 && this[D + ce + 1] !== 0 && (Re = 1), this[D + ce] = (L / ve >> 0) - Re & 255;
    return D + F;
  }, d.prototype.writeInt8 = function(L, D, F) {
    return L = +L, D = D >>> 0, F || A(this, L, D, 1, 127, -128), L < 0 && (L = 255 + L + 1), this[D] = L & 255, D + 1;
  }, d.prototype.writeInt16LE = function(L, D, F) {
    return L = +L, D = D >>> 0, F || A(this, L, D, 2, 32767, -32768), this[D] = L & 255, this[D + 1] = L >>> 8, D + 2;
  }, d.prototype.writeInt16BE = function(L, D, F) {
    return L = +L, D = D >>> 0, F || A(this, L, D, 2, 32767, -32768), this[D] = L >>> 8, this[D + 1] = L & 255, D + 2;
  }, d.prototype.writeInt32LE = function(L, D, F) {
    return L = +L, D = D >>> 0, F || A(this, L, D, 4, 2147483647, -2147483648), this[D] = L & 255, this[D + 1] = L >>> 8, this[D + 2] = L >>> 16, this[D + 3] = L >>> 24, D + 4;
  }, d.prototype.writeInt32BE = function(L, D, F) {
    return L = +L, D = D >>> 0, F || A(this, L, D, 4, 2147483647, -2147483648), L < 0 && (L = 4294967295 + L + 1), this[D] = L >>> 24, this[D + 1] = L >>> 16, this[D + 2] = L >>> 8, this[D + 3] = L & 255, D + 4;
  };
  function $(x, L, D, F, ue, ge) {
    if (D + F > x.length)
      throw new RangeError("Index out of range");
    if (D < 0)
      throw new RangeError("Index out of range");
  }
  function X(x, L, D, F, ue) {
    return L = +L, D = D >>> 0, ue || $(x, L, D, 4), o.write(x, L, D, F, 23, 4), D + 4;
  }
  d.prototype.writeFloatLE = function(L, D, F) {
    return X(this, L, D, !0, F);
  }, d.prototype.writeFloatBE = function(L, D, F) {
    return X(this, L, D, !1, F);
  };
  function oe(x, L, D, F, ue) {
    return L = +L, D = D >>> 0, ue || $(x, L, D, 8), o.write(x, L, D, F, 52, 8), D + 8;
  }
  d.prototype.writeDoubleLE = function(L, D, F) {
    return oe(this, L, D, !0, F);
  }, d.prototype.writeDoubleBE = function(L, D, F) {
    return oe(this, L, D, !1, F);
  }, d.prototype.copy = function(L, D, F, ue) {
    if (!d.isBuffer(L))
      throw new TypeError("argument should be a Buffer");
    if (F || (F = 0), !ue && ue !== 0 && (ue = this.length), D >= L.length && (D = L.length), D || (D = 0), ue > 0 && ue < F && (ue = F), ue === F || L.length === 0 || this.length === 0)
      return 0;
    if (D < 0)
      throw new RangeError("targetStart out of bounds");
    if (F < 0 || F >= this.length)
      throw new RangeError("Index out of range");
    if (ue < 0)
      throw new RangeError("sourceEnd out of bounds");
    ue > this.length && (ue = this.length), L.length - D < ue - F && (ue = L.length - D + F);
    var ge = ue - F;
    return this === L && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(D, F, ue) : Uint8Array.prototype.set.call(
      L,
      this.subarray(F, ue),
      D
    ), ge;
  }, d.prototype.fill = function(L, D, F, ue) {
    if (typeof L == "string") {
      if (typeof D == "string" ? (ue = D, D = 0, F = this.length) : typeof F == "string" && (ue = F, F = this.length), ue !== void 0 && typeof ue != "string")
        throw new TypeError("encoding must be a string");
      if (typeof ue == "string" && !d.isEncoding(ue))
        throw new TypeError("Unknown encoding: " + ue);
      if (L.length === 1) {
        var ge = L.charCodeAt(0);
        (ue === "utf8" && ge < 128 || ue === "latin1") && (L = ge);
      }
    } else
      typeof L == "number" ? L = L & 255 : typeof L == "boolean" && (L = Number(L));
    if (D < 0 || this.length < D || this.length < F)
      throw new RangeError("Out of range index");
    if (F <= D)
      return this;
    D = D >>> 0, F = F === void 0 ? this.length : F >>> 0, L || (L = 0);
    var ce;
    if (typeof L == "number")
      for (ce = D; ce < F; ++ce)
        this[ce] = L;
    else {
      var ve = d.isBuffer(L) ? L : d.from(L, ue), Re = ve.length;
      if (Re === 0)
        throw new TypeError('The value "' + L + '" is invalid for argument "value"');
      for (ce = 0; ce < F - D; ++ce)
        this[ce + D] = ve[ce % Re];
    }
    return this;
  };
  var J = /[^+/0-9A-Za-z-_]/g;
  function W(x) {
    if (x = x.split("=")[0], x = x.trim().replace(J, ""), x.length < 2)
      return "";
    for (; x.length % 4 !== 0; )
      x = x + "=";
    return x;
  }
  function Q(x, L) {
    L = L || 1 / 0;
    for (var D, F = x.length, ue = null, ge = [], ce = 0; ce < F; ++ce) {
      if (D = x.charCodeAt(ce), D > 55295 && D < 57344) {
        if (!ue) {
          if (D > 56319) {
            (L -= 3) > -1 && ge.push(239, 191, 189);
            continue;
          } else if (ce + 1 === F) {
            (L -= 3) > -1 && ge.push(239, 191, 189);
            continue;
          }
          ue = D;
          continue;
        }
        if (D < 56320) {
          (L -= 3) > -1 && ge.push(239, 191, 189), ue = D;
          continue;
        }
        D = (ue - 55296 << 10 | D - 56320) + 65536;
      } else
        ue && (L -= 3) > -1 && ge.push(239, 191, 189);
      if (ue = null, D < 128) {
        if ((L -= 1) < 0)
          break;
        ge.push(D);
      } else if (D < 2048) {
        if ((L -= 2) < 0)
          break;
        ge.push(
          D >> 6 | 192,
          D & 63 | 128
        );
      } else if (D < 65536) {
        if ((L -= 3) < 0)
          break;
        ge.push(
          D >> 12 | 224,
          D >> 6 & 63 | 128,
          D & 63 | 128
        );
      } else if (D < 1114112) {
        if ((L -= 4) < 0)
          break;
        ge.push(
          D >> 18 | 240,
          D >> 12 & 63 | 128,
          D >> 6 & 63 | 128,
          D & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return ge;
  }
  function me(x) {
    for (var L = [], D = 0; D < x.length; ++D)
      L.push(x.charCodeAt(D) & 255);
    return L;
  }
  function be(x, L) {
    for (var D, F, ue, ge = [], ce = 0; ce < x.length && !((L -= 2) < 0); ++ce)
      D = x.charCodeAt(ce), F = D >> 8, ue = D % 256, ge.push(ue), ge.push(F);
    return ge;
  }
  function Y(x) {
    return t.toByteArray(W(x));
  }
  function re(x, L, D, F) {
    for (var ue = 0; ue < F && !(ue + D >= L.length || ue >= x.length); ++ue)
      L[ue + D] = x[ue];
    return ue;
  }
  function de(x, L) {
    return x instanceof L || x != null && x.constructor != null && x.constructor.name != null && x.constructor.name === L.name;
  }
  function Ae(x) {
    return x !== x;
  }
  var qe = function() {
    for (var x = "0123456789abcdef", L = new Array(256), D = 0; D < 16; ++D)
      for (var F = D * 16, ue = 0; ue < 16; ++ue)
        L[F + ue] = x[D] + x[ue];
    return L;
  }();
})(buffer$2);
var process$2 = {}, cachedSetTimeout$1, cachedClearTimeout$1;
function defaultSetTimout$1() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout$1() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout$1 = setTimeout : cachedSetTimeout$1 = defaultSetTimout$1;
  } catch {
    cachedSetTimeout$1 = defaultSetTimout$1;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout$1 = clearTimeout : cachedClearTimeout$1 = defaultClearTimeout$1;
  } catch {
    cachedClearTimeout$1 = defaultClearTimeout$1;
  }
})();
function runTimeout$1(e) {
  if (cachedSetTimeout$1 === setTimeout)
    return setTimeout(e, 0);
  if ((cachedSetTimeout$1 === defaultSetTimout$1 || !cachedSetTimeout$1) && setTimeout)
    return cachedSetTimeout$1 = setTimeout, setTimeout(e, 0);
  try {
    return cachedSetTimeout$1(e, 0);
  } catch {
    try {
      return cachedSetTimeout$1.call(null, e, 0);
    } catch {
      return cachedSetTimeout$1.call(this, e, 0);
    }
  }
}
function runClearTimeout$1(e) {
  if (cachedClearTimeout$1 === clearTimeout)
    return clearTimeout(e);
  if ((cachedClearTimeout$1 === defaultClearTimeout$1 || !cachedClearTimeout$1) && clearTimeout)
    return cachedClearTimeout$1 = clearTimeout, clearTimeout(e);
  try {
    return cachedClearTimeout$1(e);
  } catch {
    try {
      return cachedClearTimeout$1.call(null, e);
    } catch {
      return cachedClearTimeout$1.call(this, e);
    }
  }
}
var queue$1 = [], draining$1 = !1, currentQueue$1, queueIndex$1 = -1;
function cleanUpNextTick$1() {
  !draining$1 || !currentQueue$1 || (draining$1 = !1, currentQueue$1.length ? queue$1 = currentQueue$1.concat(queue$1) : queueIndex$1 = -1, queue$1.length && drainQueue$1());
}
function drainQueue$1() {
  if (!draining$1) {
    var e = runTimeout$1(cleanUpNextTick$1);
    draining$1 = !0;
    for (var t = queue$1.length; t; ) {
      for (currentQueue$1 = queue$1, queue$1 = []; ++queueIndex$1 < t; )
        currentQueue$1 && currentQueue$1[queueIndex$1].run();
      queueIndex$1 = -1, t = queue$1.length;
    }
    currentQueue$1 = null, draining$1 = !1, runClearTimeout$1(e);
  }
}
process$2.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var o = 1; o < arguments.length; o++)
      t[o - 1] = arguments[o];
  queue$1.push(new Item$1(e, t)), queue$1.length === 1 && !draining$1 && runTimeout$1(drainQueue$1);
};
function Item$1(e, t) {
  this.fun = e, this.array = t;
}
Item$1.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process$2.title = "browser";
process$2.browser = !0;
process$2.env = {};
process$2.argv = [];
process$2.version = "";
process$2.versions = {};
function noop$1() {
}
process$2.on = noop$1;
process$2.addListener = noop$1;
process$2.once = noop$1;
process$2.off = noop$1;
process$2.removeListener = noop$1;
process$2.removeAllListeners = noop$1;
process$2.emit = noop$1;
process$2.prependListener = noop$1;
process$2.prependOnceListener = noop$1;
process$2.listeners = function(e) {
  return [];
};
process$2.binding = function(e) {
  throw new Error("process.binding is not supported");
};
process$2.cwd = function() {
  return "/";
};
process$2.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
process$2.umask = function() {
  return 0;
};
var _globalThis = function(e) {
  function t() {
    var r = this || self;
    return delete e.prototype.__magic__, r;
  }
  if (typeof globalThis == "object")
    return globalThis;
  if (this)
    return t();
  e.defineProperty(e.prototype, "__magic__", {
    configurable: !0,
    get: t
  });
  var o = __magic__;
  return o;
}(Object), _global = _globalThis;
const name$1 = "@wepin/fetch-js", version$1 = "0.0.1", description$1 = "Wepin fetch library for Web", author$1 = "IoTrust, Co., Ltd.", license$1 = "MIT", main$1 = "./dist/wepin-fetch-js.mjs", types$1 = "./dist/src/index.d.ts", files$1 = [
  "dist"
], scripts$1 = {
  build: "vite build --mode production",
  dev: "vite build --mode development",
  watch: "vite build --watch",
  lint: "eslint . --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts --fix --ignore-path .gitignore"
}, dependencies$1 = {
  "@wepin/storage-js": "link:../storage",
  bcryptjs: "^2.4.3",
  eventemitter2: "^6.4.9",
  "jwt-decode": "^4.0.0"
}, devDependencies$1 = {
  "@types/bcryptjs": "^2.4.6"
}, keywords$1 = [
  "wepin",
  "wepinwallet",
  "wallet",
  "wepin-fetch"
], packageJson = {
  name: name$1,
  version: version$1,
  description: description$1,
  author: author$1,
  license: license$1,
  main: main$1,
  types: types$1,
  files: files$1,
  scripts: scripts$1,
  dependencies: dependencies$1,
  devDependencies: devDependencies$1,
  keywords: keywords$1
};
class APIResponse {
  constructor({
    data: t,
    status: o,
    headers: r,
    request: h
  }) {
    this.data = t, this.status = o, this.headers = r, this.request = h;
  }
}
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof _global < "u" ? _global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var buffer$1 = {}, base64Js = {}, hasRequiredBase64Js;
function requireBase64Js() {
  if (hasRequiredBase64Js)
    return base64Js;
  hasRequiredBase64Js = 1, base64Js.byteLength = d, base64Js.toByteArray = g, base64Js.fromByteArray = T;
  for (var e = [], t = [], o = typeof Uint8Array < "u" ? Uint8Array : Array, r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", h = 0, a = r.length; h < a; ++h)
    e[h] = r[h], t[r.charCodeAt(h)] = h;
  t[45] = 62, t[95] = 63;
  function p(k) {
    var q = k.length;
    if (q % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var O = k.indexOf("=");
    O === -1 && (O = q);
    var N = O === q ? 0 : 4 - O % 4;
    return [O, N];
  }
  function d(k) {
    var q = p(k), O = q[0], N = q[1];
    return (O + N) * 3 / 4 - N;
  }
  function b(k, q, O) {
    return (q + O) * 3 / 4 - O;
  }
  function g(k) {
    var q, O = p(k), N = O[0], j = O[1], U = new o(b(k, N, j)), H = 0, z = j > 0 ? N - 4 : N, ee;
    for (ee = 0; ee < z; ee += 4)
      q = t[k.charCodeAt(ee)] << 18 | t[k.charCodeAt(ee + 1)] << 12 | t[k.charCodeAt(ee + 2)] << 6 | t[k.charCodeAt(ee + 3)], U[H++] = q >> 16 & 255, U[H++] = q >> 8 & 255, U[H++] = q & 255;
    return j === 2 && (q = t[k.charCodeAt(ee)] << 2 | t[k.charCodeAt(ee + 1)] >> 4, U[H++] = q & 255), j === 1 && (q = t[k.charCodeAt(ee)] << 10 | t[k.charCodeAt(ee + 1)] << 4 | t[k.charCodeAt(ee + 2)] >> 2, U[H++] = q >> 8 & 255, U[H++] = q & 255), U;
  }
  function w(k) {
    return e[k >> 18 & 63] + e[k >> 12 & 63] + e[k >> 6 & 63] + e[k & 63];
  }
  function C(k, q, O) {
    for (var N, j = [], U = q; U < O; U += 3)
      N = (k[U] << 16 & 16711680) + (k[U + 1] << 8 & 65280) + (k[U + 2] & 255), j.push(w(N));
    return j.join("");
  }
  function T(k) {
    for (var q, O = k.length, N = O % 3, j = [], U = 16383, H = 0, z = O - N; H < z; H += U)
      j.push(C(k, H, H + U > z ? z : H + U));
    return N === 1 ? (q = k[O - 1], j.push(
      e[q >> 2] + e[q << 4 & 63] + "=="
    )) : N === 2 && (q = (k[O - 2] << 8) + k[O - 1], j.push(
      e[q >> 10] + e[q >> 4 & 63] + e[q << 2 & 63] + "="
    )), j.join("");
  }
  return base64Js;
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredIeee754;
function requireIeee754() {
  return hasRequiredIeee754 || (hasRequiredIeee754 = 1, ieee754.read = function(e, t, o, r, h) {
    var a, p, d = h * 8 - r - 1, b = (1 << d) - 1, g = b >> 1, w = -7, C = o ? h - 1 : 0, T = o ? -1 : 1, k = e[t + C];
    for (C += T, a = k & (1 << -w) - 1, k >>= -w, w += d; w > 0; a = a * 256 + e[t + C], C += T, w -= 8)
      ;
    for (p = a & (1 << -w) - 1, a >>= -w, w += r; w > 0; p = p * 256 + e[t + C], C += T, w -= 8)
      ;
    if (a === 0)
      a = 1 - g;
    else {
      if (a === b)
        return p ? NaN : (k ? -1 : 1) * (1 / 0);
      p = p + Math.pow(2, r), a = a - g;
    }
    return (k ? -1 : 1) * p * Math.pow(2, a - r);
  }, ieee754.write = function(e, t, o, r, h, a) {
    var p, d, b, g = a * 8 - h - 1, w = (1 << g) - 1, C = w >> 1, T = h === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, k = r ? 0 : a - 1, q = r ? 1 : -1, O = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
    for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (d = isNaN(t) ? 1 : 0, p = w) : (p = Math.floor(Math.log(t) / Math.LN2), t * (b = Math.pow(2, -p)) < 1 && (p--, b *= 2), p + C >= 1 ? t += T / b : t += T * Math.pow(2, 1 - C), t * b >= 2 && (p++, b /= 2), p + C >= w ? (d = 0, p = w) : p + C >= 1 ? (d = (t * b - 1) * Math.pow(2, h), p = p + C) : (d = t * Math.pow(2, C - 1) * Math.pow(2, h), p = 0)); h >= 8; e[o + k] = d & 255, k += q, d /= 256, h -= 8)
      ;
    for (p = p << h | d, g += h; g > 0; e[o + k] = p & 255, k += q, p /= 256, g -= 8)
      ;
    e[o + k - q] |= O * 128;
  }), ieee754;
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var hasRequiredBuffer$1;
function requireBuffer$1() {
  return hasRequiredBuffer$1 || (hasRequiredBuffer$1 = 1, function(e) {
    var t = requireBase64Js(), o = requireIeee754(), r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    e.Buffer = d, e.SlowBuffer = U, e.INSPECT_MAX_BYTES = 50;
    var h = 2147483647;
    e.kMaxLength = h, d.TYPED_ARRAY_SUPPORT = a(), !d.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function a() {
      try {
        var x = new Uint8Array(1), L = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(L, Uint8Array.prototype), Object.setPrototypeOf(x, L), x.foo() === 42;
      } catch {
        return !1;
      }
    }
    Object.defineProperty(d.prototype, "parent", {
      enumerable: !0,
      get: function() {
        if (d.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(d.prototype, "offset", {
      enumerable: !0,
      get: function() {
        if (d.isBuffer(this))
          return this.byteOffset;
      }
    });
    function p(x) {
      if (x > h)
        throw new RangeError('The value "' + x + '" is invalid for option "size"');
      var L = new Uint8Array(x);
      return Object.setPrototypeOf(L, d.prototype), L;
    }
    function d(x, L, D) {
      if (typeof x == "number") {
        if (typeof L == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return C(x);
      }
      return b(x, L, D);
    }
    d.poolSize = 8192;
    function b(x, L, D) {
      if (typeof x == "string")
        return T(x, L);
      if (ArrayBuffer.isView(x))
        return q(x);
      if (x == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof x
        );
      if (de(x, ArrayBuffer) || x && de(x.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (de(x, SharedArrayBuffer) || x && de(x.buffer, SharedArrayBuffer)))
        return O(x, L, D);
      if (typeof x == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      var F = x.valueOf && x.valueOf();
      if (F != null && F !== x)
        return d.from(F, L, D);
      var ue = N(x);
      if (ue)
        return ue;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof x[Symbol.toPrimitive] == "function")
        return d.from(
          x[Symbol.toPrimitive]("string"),
          L,
          D
        );
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof x
      );
    }
    d.from = function(x, L, D) {
      return b(x, L, D);
    }, Object.setPrototypeOf(d.prototype, Uint8Array.prototype), Object.setPrototypeOf(d, Uint8Array);
    function g(x) {
      if (typeof x != "number")
        throw new TypeError('"size" argument must be of type number');
      if (x < 0)
        throw new RangeError('The value "' + x + '" is invalid for option "size"');
    }
    function w(x, L, D) {
      return g(x), x <= 0 ? p(x) : L !== void 0 ? typeof D == "string" ? p(x).fill(L, D) : p(x).fill(L) : p(x);
    }
    d.alloc = function(x, L, D) {
      return w(x, L, D);
    };
    function C(x) {
      return g(x), p(x < 0 ? 0 : j(x) | 0);
    }
    d.allocUnsafe = function(x) {
      return C(x);
    }, d.allocUnsafeSlow = function(x) {
      return C(x);
    };
    function T(x, L) {
      if ((typeof L != "string" || L === "") && (L = "utf8"), !d.isEncoding(L))
        throw new TypeError("Unknown encoding: " + L);
      var D = H(x, L) | 0, F = p(D), ue = F.write(x, L);
      return ue !== D && (F = F.slice(0, ue)), F;
    }
    function k(x) {
      for (var L = x.length < 0 ? 0 : j(x.length) | 0, D = p(L), F = 0; F < L; F += 1)
        D[F] = x[F] & 255;
      return D;
    }
    function q(x) {
      if (de(x, Uint8Array)) {
        var L = new Uint8Array(x);
        return O(L.buffer, L.byteOffset, L.byteLength);
      }
      return k(x);
    }
    function O(x, L, D) {
      if (L < 0 || x.byteLength < L)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (x.byteLength < L + (D || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      var F;
      return L === void 0 && D === void 0 ? F = new Uint8Array(x) : D === void 0 ? F = new Uint8Array(x, L) : F = new Uint8Array(x, L, D), Object.setPrototypeOf(F, d.prototype), F;
    }
    function N(x) {
      if (d.isBuffer(x)) {
        var L = j(x.length) | 0, D = p(L);
        return D.length === 0 || x.copy(D, 0, 0, L), D;
      }
      if (x.length !== void 0)
        return typeof x.length != "number" || Ae(x.length) ? p(0) : k(x);
      if (x.type === "Buffer" && Array.isArray(x.data))
        return k(x.data);
    }
    function j(x) {
      if (x >= h)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + h.toString(16) + " bytes");
      return x | 0;
    }
    function U(x) {
      return +x != x && (x = 0), d.alloc(+x);
    }
    d.isBuffer = function(x) {
      return x != null && x._isBuffer === !0 && x !== d.prototype;
    }, d.compare = function(x, L) {
      if (de(x, Uint8Array) && (x = d.from(x, x.offset, x.byteLength)), de(L, Uint8Array) && (L = d.from(L, L.offset, L.byteLength)), !d.isBuffer(x) || !d.isBuffer(L))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (x === L)
        return 0;
      for (var D = x.length, F = L.length, ue = 0, ge = Math.min(D, F); ue < ge; ++ue)
        if (x[ue] !== L[ue]) {
          D = x[ue], F = L[ue];
          break;
        }
      return D < F ? -1 : F < D ? 1 : 0;
    }, d.isEncoding = function(x) {
      switch (String(x).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, d.concat = function(x, L) {
      if (!Array.isArray(x))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (x.length === 0)
        return d.alloc(0);
      var D;
      if (L === void 0)
        for (L = 0, D = 0; D < x.length; ++D)
          L += x[D].length;
      var F = d.allocUnsafe(L), ue = 0;
      for (D = 0; D < x.length; ++D) {
        var ge = x[D];
        if (de(ge, Uint8Array))
          ue + ge.length > F.length ? d.from(ge).copy(F, ue) : Uint8Array.prototype.set.call(
            F,
            ge,
            ue
          );
        else if (d.isBuffer(ge))
          ge.copy(F, ue);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        ue += ge.length;
      }
      return F;
    };
    function H(x, L) {
      if (d.isBuffer(x))
        return x.length;
      if (ArrayBuffer.isView(x) || de(x, ArrayBuffer))
        return x.byteLength;
      if (typeof x != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof x
        );
      var D = x.length, F = arguments.length > 2 && arguments[2] === !0;
      if (!F && D === 0)
        return 0;
      for (var ue = !1; ; )
        switch (L) {
          case "ascii":
          case "latin1":
          case "binary":
            return D;
          case "utf8":
          case "utf-8":
            return Q(x).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return D * 2;
          case "hex":
            return D >>> 1;
          case "base64":
            return Y(x).length;
          default:
            if (ue)
              return F ? -1 : Q(x).length;
            L = ("" + L).toLowerCase(), ue = !0;
        }
    }
    d.byteLength = H;
    function z(x, L, D) {
      var F = !1;
      if ((L === void 0 || L < 0) && (L = 0), L > this.length || ((D === void 0 || D > this.length) && (D = this.length), D <= 0) || (D >>>= 0, L >>>= 0, D <= L))
        return "";
      for (x || (x = "utf8"); ; )
        switch (x) {
          case "hex":
            return _(this, L, D);
          case "utf8":
          case "utf-8":
            return y(this, L, D);
          case "ascii":
            return B(this, L, D);
          case "latin1":
          case "binary":
            return S(this, L, D);
          case "base64":
            return f(this, L, D);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return E(this, L, D);
          default:
            if (F)
              throw new TypeError("Unknown encoding: " + x);
            x = (x + "").toLowerCase(), F = !0;
        }
    }
    d.prototype._isBuffer = !0;
    function ee(x, L, D) {
      var F = x[L];
      x[L] = x[D], x[D] = F;
    }
    d.prototype.swap16 = function() {
      var x = this.length;
      if (x % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var L = 0; L < x; L += 2)
        ee(this, L, L + 1);
      return this;
    }, d.prototype.swap32 = function() {
      var x = this.length;
      if (x % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var L = 0; L < x; L += 4)
        ee(this, L, L + 3), ee(this, L + 1, L + 2);
      return this;
    }, d.prototype.swap64 = function() {
      var x = this.length;
      if (x % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var L = 0; L < x; L += 8)
        ee(this, L, L + 7), ee(this, L + 1, L + 6), ee(this, L + 2, L + 5), ee(this, L + 3, L + 4);
      return this;
    }, d.prototype.toString = function() {
      var x = this.length;
      return x === 0 ? "" : arguments.length === 0 ? y(this, 0, x) : z.apply(this, arguments);
    }, d.prototype.toLocaleString = d.prototype.toString, d.prototype.equals = function(x) {
      if (!d.isBuffer(x))
        throw new TypeError("Argument must be a Buffer");
      return this === x ? !0 : d.compare(this, x) === 0;
    }, d.prototype.inspect = function() {
      var x = "", L = e.INSPECT_MAX_BYTES;
      return x = this.toString("hex", 0, L).replace(/(.{2})/g, "$1 ").trim(), this.length > L && (x += " ... "), "<Buffer " + x + ">";
    }, r && (d.prototype[r] = d.prototype.inspect), d.prototype.compare = function(x, L, D, F, ue) {
      if (de(x, Uint8Array) && (x = d.from(x, x.offset, x.byteLength)), !d.isBuffer(x))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof x
        );
      if (L === void 0 && (L = 0), D === void 0 && (D = x ? x.length : 0), F === void 0 && (F = 0), ue === void 0 && (ue = this.length), L < 0 || D > x.length || F < 0 || ue > this.length)
        throw new RangeError("out of range index");
      if (F >= ue && L >= D)
        return 0;
      if (F >= ue)
        return -1;
      if (L >= D)
        return 1;
      if (L >>>= 0, D >>>= 0, F >>>= 0, ue >>>= 0, this === x)
        return 0;
      for (var ge = ue - F, ce = D - L, ve = Math.min(ge, ce), Re = this.slice(F, ue), ke = x.slice(L, D), Ce = 0; Ce < ve; ++Ce)
        if (Re[Ce] !== ke[Ce]) {
          ge = Re[Ce], ce = ke[Ce];
          break;
        }
      return ge < ce ? -1 : ce < ge ? 1 : 0;
    };
    function ne(x, L, D, F, ue) {
      if (x.length === 0)
        return -1;
      if (typeof D == "string" ? (F = D, D = 0) : D > 2147483647 ? D = 2147483647 : D < -2147483648 && (D = -2147483648), D = +D, Ae(D) && (D = ue ? 0 : x.length - 1), D < 0 && (D = x.length + D), D >= x.length) {
        if (ue)
          return -1;
        D = x.length - 1;
      } else if (D < 0)
        if (ue)
          D = 0;
        else
          return -1;
      if (typeof L == "string" && (L = d.from(L, F)), d.isBuffer(L))
        return L.length === 0 ? -1 : le(x, L, D, F, ue);
      if (typeof L == "number")
        return L = L & 255, typeof Uint8Array.prototype.indexOf == "function" ? ue ? Uint8Array.prototype.indexOf.call(x, L, D) : Uint8Array.prototype.lastIndexOf.call(x, L, D) : le(x, [L], D, F, ue);
      throw new TypeError("val must be string, number or Buffer");
    }
    function le(x, L, D, F, ue) {
      var ge = 1, ce = x.length, ve = L.length;
      if (F !== void 0 && (F = String(F).toLowerCase(), F === "ucs2" || F === "ucs-2" || F === "utf16le" || F === "utf-16le")) {
        if (x.length < 2 || L.length < 2)
          return -1;
        ge = 2, ce /= 2, ve /= 2, D /= 2;
      }
      function Re(Pe, et) {
        return ge === 1 ? Pe[et] : Pe.readUInt16BE(et * ge);
      }
      var ke;
      if (ue) {
        var Ce = -1;
        for (ke = D; ke < ce; ke++)
          if (Re(x, ke) === Re(L, Ce === -1 ? 0 : ke - Ce)) {
            if (Ce === -1 && (Ce = ke), ke - Ce + 1 === ve)
              return Ce * ge;
          } else
            Ce !== -1 && (ke -= ke - Ce), Ce = -1;
      } else
        for (D + ve > ce && (D = ce - ve), ke = D; ke >= 0; ke--) {
          for (var Le = !0, Oe = 0; Oe < ve; Oe++)
            if (Re(x, ke + Oe) !== Re(L, Oe)) {
              Le = !1;
              break;
            }
          if (Le)
            return ke;
        }
      return -1;
    }
    d.prototype.includes = function(x, L, D) {
      return this.indexOf(x, L, D) !== -1;
    }, d.prototype.indexOf = function(x, L, D) {
      return ne(this, x, L, D, !0);
    }, d.prototype.lastIndexOf = function(x, L, D) {
      return ne(this, x, L, D, !1);
    };
    function Z(x, L, D, F) {
      D = Number(D) || 0;
      var ue = x.length - D;
      F ? (F = Number(F), F > ue && (F = ue)) : F = ue;
      var ge = L.length;
      F > ge / 2 && (F = ge / 2);
      for (var ce = 0; ce < F; ++ce) {
        var ve = parseInt(L.substr(ce * 2, 2), 16);
        if (Ae(ve))
          return ce;
        x[D + ce] = ve;
      }
      return ce;
    }
    function ie(x, L, D, F) {
      return re(Q(L, x.length - D), x, D, F);
    }
    function fe(x, L, D, F) {
      return re(me(L), x, D, F);
    }
    function I(x, L, D, F) {
      return re(Y(L), x, D, F);
    }
    function P(x, L, D, F) {
      return re(be(L, x.length - D), x, D, F);
    }
    d.prototype.write = function(x, L, D, F) {
      if (L === void 0)
        F = "utf8", D = this.length, L = 0;
      else if (D === void 0 && typeof L == "string")
        F = L, D = this.length, L = 0;
      else if (isFinite(L))
        L = L >>> 0, isFinite(D) ? (D = D >>> 0, F === void 0 && (F = "utf8")) : (F = D, D = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      var ue = this.length - L;
      if ((D === void 0 || D > ue) && (D = ue), x.length > 0 && (D < 0 || L < 0) || L > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      F || (F = "utf8");
      for (var ge = !1; ; )
        switch (F) {
          case "hex":
            return Z(this, x, L, D);
          case "utf8":
          case "utf-8":
            return ie(this, x, L, D);
          case "ascii":
          case "latin1":
          case "binary":
            return fe(this, x, L, D);
          case "base64":
            return I(this, x, L, D);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return P(this, x, L, D);
          default:
            if (ge)
              throw new TypeError("Unknown encoding: " + F);
            F = ("" + F).toLowerCase(), ge = !0;
        }
    }, d.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function f(x, L, D) {
      return L === 0 && D === x.length ? t.fromByteArray(x) : t.fromByteArray(x.slice(L, D));
    }
    function y(x, L, D) {
      D = Math.min(x.length, D);
      for (var F = [], ue = L; ue < D; ) {
        var ge = x[ue], ce = null, ve = ge > 239 ? 4 : ge > 223 ? 3 : ge > 191 ? 2 : 1;
        if (ue + ve <= D) {
          var Re, ke, Ce, Le;
          switch (ve) {
            case 1:
              ge < 128 && (ce = ge);
              break;
            case 2:
              Re = x[ue + 1], (Re & 192) === 128 && (Le = (ge & 31) << 6 | Re & 63, Le > 127 && (ce = Le));
              break;
            case 3:
              Re = x[ue + 1], ke = x[ue + 2], (Re & 192) === 128 && (ke & 192) === 128 && (Le = (ge & 15) << 12 | (Re & 63) << 6 | ke & 63, Le > 2047 && (Le < 55296 || Le > 57343) && (ce = Le));
              break;
            case 4:
              Re = x[ue + 1], ke = x[ue + 2], Ce = x[ue + 3], (Re & 192) === 128 && (ke & 192) === 128 && (Ce & 192) === 128 && (Le = (ge & 15) << 18 | (Re & 63) << 12 | (ke & 63) << 6 | Ce & 63, Le > 65535 && Le < 1114112 && (ce = Le));
          }
        }
        ce === null ? (ce = 65533, ve = 1) : ce > 65535 && (ce -= 65536, F.push(ce >>> 10 & 1023 | 55296), ce = 56320 | ce & 1023), F.push(ce), ue += ve;
      }
      return M(F);
    }
    var v = 4096;
    function M(x) {
      var L = x.length;
      if (L <= v)
        return String.fromCharCode.apply(String, x);
      for (var D = "", F = 0; F < L; )
        D += String.fromCharCode.apply(
          String,
          x.slice(F, F += v)
        );
      return D;
    }
    function B(x, L, D) {
      var F = "";
      D = Math.min(x.length, D);
      for (var ue = L; ue < D; ++ue)
        F += String.fromCharCode(x[ue] & 127);
      return F;
    }
    function S(x, L, D) {
      var F = "";
      D = Math.min(x.length, D);
      for (var ue = L; ue < D; ++ue)
        F += String.fromCharCode(x[ue]);
      return F;
    }
    function _(x, L, D) {
      var F = x.length;
      (!L || L < 0) && (L = 0), (!D || D < 0 || D > F) && (D = F);
      for (var ue = "", ge = L; ge < D; ++ge)
        ue += qe[x[ge]];
      return ue;
    }
    function E(x, L, D) {
      for (var F = x.slice(L, D), ue = "", ge = 0; ge < F.length - 1; ge += 2)
        ue += String.fromCharCode(F[ge] + F[ge + 1] * 256);
      return ue;
    }
    d.prototype.slice = function(x, L) {
      var D = this.length;
      x = ~~x, L = L === void 0 ? D : ~~L, x < 0 ? (x += D, x < 0 && (x = 0)) : x > D && (x = D), L < 0 ? (L += D, L < 0 && (L = 0)) : L > D && (L = D), L < x && (L = x);
      var F = this.subarray(x, L);
      return Object.setPrototypeOf(F, d.prototype), F;
    };
    function m(x, L, D) {
      if (x % 1 !== 0 || x < 0)
        throw new RangeError("offset is not uint");
      if (x + L > D)
        throw new RangeError("Trying to access beyond buffer length");
    }
    d.prototype.readUintLE = d.prototype.readUIntLE = function(x, L, D) {
      x = x >>> 0, L = L >>> 0, D || m(x, L, this.length);
      for (var F = this[x], ue = 1, ge = 0; ++ge < L && (ue *= 256); )
        F += this[x + ge] * ue;
      return F;
    }, d.prototype.readUintBE = d.prototype.readUIntBE = function(x, L, D) {
      x = x >>> 0, L = L >>> 0, D || m(x, L, this.length);
      for (var F = this[x + --L], ue = 1; L > 0 && (ue *= 256); )
        F += this[x + --L] * ue;
      return F;
    }, d.prototype.readUint8 = d.prototype.readUInt8 = function(x, L) {
      return x = x >>> 0, L || m(x, 1, this.length), this[x];
    }, d.prototype.readUint16LE = d.prototype.readUInt16LE = function(x, L) {
      return x = x >>> 0, L || m(x, 2, this.length), this[x] | this[x + 1] << 8;
    }, d.prototype.readUint16BE = d.prototype.readUInt16BE = function(x, L) {
      return x = x >>> 0, L || m(x, 2, this.length), this[x] << 8 | this[x + 1];
    }, d.prototype.readUint32LE = d.prototype.readUInt32LE = function(x, L) {
      return x = x >>> 0, L || m(x, 4, this.length), (this[x] | this[x + 1] << 8 | this[x + 2] << 16) + this[x + 3] * 16777216;
    }, d.prototype.readUint32BE = d.prototype.readUInt32BE = function(x, L) {
      return x = x >>> 0, L || m(x, 4, this.length), this[x] * 16777216 + (this[x + 1] << 16 | this[x + 2] << 8 | this[x + 3]);
    }, d.prototype.readIntLE = function(x, L, D) {
      x = x >>> 0, L = L >>> 0, D || m(x, L, this.length);
      for (var F = this[x], ue = 1, ge = 0; ++ge < L && (ue *= 256); )
        F += this[x + ge] * ue;
      return ue *= 128, F >= ue && (F -= Math.pow(2, 8 * L)), F;
    }, d.prototype.readIntBE = function(x, L, D) {
      x = x >>> 0, L = L >>> 0, D || m(x, L, this.length);
      for (var F = L, ue = 1, ge = this[x + --F]; F > 0 && (ue *= 256); )
        ge += this[x + --F] * ue;
      return ue *= 128, ge >= ue && (ge -= Math.pow(2, 8 * L)), ge;
    }, d.prototype.readInt8 = function(x, L) {
      return x = x >>> 0, L || m(x, 1, this.length), this[x] & 128 ? (255 - this[x] + 1) * -1 : this[x];
    }, d.prototype.readInt16LE = function(x, L) {
      x = x >>> 0, L || m(x, 2, this.length);
      var D = this[x] | this[x + 1] << 8;
      return D & 32768 ? D | 4294901760 : D;
    }, d.prototype.readInt16BE = function(x, L) {
      x = x >>> 0, L || m(x, 2, this.length);
      var D = this[x + 1] | this[x] << 8;
      return D & 32768 ? D | 4294901760 : D;
    }, d.prototype.readInt32LE = function(x, L) {
      return x = x >>> 0, L || m(x, 4, this.length), this[x] | this[x + 1] << 8 | this[x + 2] << 16 | this[x + 3] << 24;
    }, d.prototype.readInt32BE = function(x, L) {
      return x = x >>> 0, L || m(x, 4, this.length), this[x] << 24 | this[x + 1] << 16 | this[x + 2] << 8 | this[x + 3];
    }, d.prototype.readFloatLE = function(x, L) {
      return x = x >>> 0, L || m(x, 4, this.length), o.read(this, x, !0, 23, 4);
    }, d.prototype.readFloatBE = function(x, L) {
      return x = x >>> 0, L || m(x, 4, this.length), o.read(this, x, !1, 23, 4);
    }, d.prototype.readDoubleLE = function(x, L) {
      return x = x >>> 0, L || m(x, 8, this.length), o.read(this, x, !0, 52, 8);
    }, d.prototype.readDoubleBE = function(x, L) {
      return x = x >>> 0, L || m(x, 8, this.length), o.read(this, x, !1, 52, 8);
    };
    function A(x, L, D, F, ue, ge) {
      if (!d.isBuffer(x))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (L > ue || L < ge)
        throw new RangeError('"value" argument is out of bounds');
      if (D + F > x.length)
        throw new RangeError("Index out of range");
    }
    d.prototype.writeUintLE = d.prototype.writeUIntLE = function(x, L, D, F) {
      if (x = +x, L = L >>> 0, D = D >>> 0, !F) {
        var ue = Math.pow(2, 8 * D) - 1;
        A(this, x, L, D, ue, 0);
      }
      var ge = 1, ce = 0;
      for (this[L] = x & 255; ++ce < D && (ge *= 256); )
        this[L + ce] = x / ge & 255;
      return L + D;
    }, d.prototype.writeUintBE = d.prototype.writeUIntBE = function(x, L, D, F) {
      if (x = +x, L = L >>> 0, D = D >>> 0, !F) {
        var ue = Math.pow(2, 8 * D) - 1;
        A(this, x, L, D, ue, 0);
      }
      var ge = D - 1, ce = 1;
      for (this[L + ge] = x & 255; --ge >= 0 && (ce *= 256); )
        this[L + ge] = x / ce & 255;
      return L + D;
    }, d.prototype.writeUint8 = d.prototype.writeUInt8 = function(x, L, D) {
      return x = +x, L = L >>> 0, D || A(this, x, L, 1, 255, 0), this[L] = x & 255, L + 1;
    }, d.prototype.writeUint16LE = d.prototype.writeUInt16LE = function(x, L, D) {
      return x = +x, L = L >>> 0, D || A(this, x, L, 2, 65535, 0), this[L] = x & 255, this[L + 1] = x >>> 8, L + 2;
    }, d.prototype.writeUint16BE = d.prototype.writeUInt16BE = function(x, L, D) {
      return x = +x, L = L >>> 0, D || A(this, x, L, 2, 65535, 0), this[L] = x >>> 8, this[L + 1] = x & 255, L + 2;
    }, d.prototype.writeUint32LE = d.prototype.writeUInt32LE = function(x, L, D) {
      return x = +x, L = L >>> 0, D || A(this, x, L, 4, 4294967295, 0), this[L + 3] = x >>> 24, this[L + 2] = x >>> 16, this[L + 1] = x >>> 8, this[L] = x & 255, L + 4;
    }, d.prototype.writeUint32BE = d.prototype.writeUInt32BE = function(x, L, D) {
      return x = +x, L = L >>> 0, D || A(this, x, L, 4, 4294967295, 0), this[L] = x >>> 24, this[L + 1] = x >>> 16, this[L + 2] = x >>> 8, this[L + 3] = x & 255, L + 4;
    }, d.prototype.writeIntLE = function(x, L, D, F) {
      if (x = +x, L = L >>> 0, !F) {
        var ue = Math.pow(2, 8 * D - 1);
        A(this, x, L, D, ue - 1, -ue);
      }
      var ge = 0, ce = 1, ve = 0;
      for (this[L] = x & 255; ++ge < D && (ce *= 256); )
        x < 0 && ve === 0 && this[L + ge - 1] !== 0 && (ve = 1), this[L + ge] = (x / ce >> 0) - ve & 255;
      return L + D;
    }, d.prototype.writeIntBE = function(x, L, D, F) {
      if (x = +x, L = L >>> 0, !F) {
        var ue = Math.pow(2, 8 * D - 1);
        A(this, x, L, D, ue - 1, -ue);
      }
      var ge = D - 1, ce = 1, ve = 0;
      for (this[L + ge] = x & 255; --ge >= 0 && (ce *= 256); )
        x < 0 && ve === 0 && this[L + ge + 1] !== 0 && (ve = 1), this[L + ge] = (x / ce >> 0) - ve & 255;
      return L + D;
    }, d.prototype.writeInt8 = function(x, L, D) {
      return x = +x, L = L >>> 0, D || A(this, x, L, 1, 127, -128), x < 0 && (x = 255 + x + 1), this[L] = x & 255, L + 1;
    }, d.prototype.writeInt16LE = function(x, L, D) {
      return x = +x, L = L >>> 0, D || A(this, x, L, 2, 32767, -32768), this[L] = x & 255, this[L + 1] = x >>> 8, L + 2;
    }, d.prototype.writeInt16BE = function(x, L, D) {
      return x = +x, L = L >>> 0, D || A(this, x, L, 2, 32767, -32768), this[L] = x >>> 8, this[L + 1] = x & 255, L + 2;
    }, d.prototype.writeInt32LE = function(x, L, D) {
      return x = +x, L = L >>> 0, D || A(this, x, L, 4, 2147483647, -2147483648), this[L] = x & 255, this[L + 1] = x >>> 8, this[L + 2] = x >>> 16, this[L + 3] = x >>> 24, L + 4;
    }, d.prototype.writeInt32BE = function(x, L, D) {
      return x = +x, L = L >>> 0, D || A(this, x, L, 4, 2147483647, -2147483648), x < 0 && (x = 4294967295 + x + 1), this[L] = x >>> 24, this[L + 1] = x >>> 16, this[L + 2] = x >>> 8, this[L + 3] = x & 255, L + 4;
    };
    function $(x, L, D, F, ue, ge) {
      if (D + F > x.length)
        throw new RangeError("Index out of range");
      if (D < 0)
        throw new RangeError("Index out of range");
    }
    function X(x, L, D, F, ue) {
      return L = +L, D = D >>> 0, ue || $(x, L, D, 4), o.write(x, L, D, F, 23, 4), D + 4;
    }
    d.prototype.writeFloatLE = function(x, L, D) {
      return X(this, x, L, !0, D);
    }, d.prototype.writeFloatBE = function(x, L, D) {
      return X(this, x, L, !1, D);
    };
    function oe(x, L, D, F, ue) {
      return L = +L, D = D >>> 0, ue || $(x, L, D, 8), o.write(x, L, D, F, 52, 8), D + 8;
    }
    d.prototype.writeDoubleLE = function(x, L, D) {
      return oe(this, x, L, !0, D);
    }, d.prototype.writeDoubleBE = function(x, L, D) {
      return oe(this, x, L, !1, D);
    }, d.prototype.copy = function(x, L, D, F) {
      if (!d.isBuffer(x))
        throw new TypeError("argument should be a Buffer");
      if (D || (D = 0), !F && F !== 0 && (F = this.length), L >= x.length && (L = x.length), L || (L = 0), F > 0 && F < D && (F = D), F === D || x.length === 0 || this.length === 0)
        return 0;
      if (L < 0)
        throw new RangeError("targetStart out of bounds");
      if (D < 0 || D >= this.length)
        throw new RangeError("Index out of range");
      if (F < 0)
        throw new RangeError("sourceEnd out of bounds");
      F > this.length && (F = this.length), x.length - L < F - D && (F = x.length - L + D);
      var ue = F - D;
      return this === x && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(L, D, F) : Uint8Array.prototype.set.call(
        x,
        this.subarray(D, F),
        L
      ), ue;
    }, d.prototype.fill = function(x, L, D, F) {
      if (typeof x == "string") {
        if (typeof L == "string" ? (F = L, L = 0, D = this.length) : typeof D == "string" && (F = D, D = this.length), F !== void 0 && typeof F != "string")
          throw new TypeError("encoding must be a string");
        if (typeof F == "string" && !d.isEncoding(F))
          throw new TypeError("Unknown encoding: " + F);
        if (x.length === 1) {
          var ue = x.charCodeAt(0);
          (F === "utf8" && ue < 128 || F === "latin1") && (x = ue);
        }
      } else
        typeof x == "number" ? x = x & 255 : typeof x == "boolean" && (x = Number(x));
      if (L < 0 || this.length < L || this.length < D)
        throw new RangeError("Out of range index");
      if (D <= L)
        return this;
      L = L >>> 0, D = D === void 0 ? this.length : D >>> 0, x || (x = 0);
      var ge;
      if (typeof x == "number")
        for (ge = L; ge < D; ++ge)
          this[ge] = x;
      else {
        var ce = d.isBuffer(x) ? x : d.from(x, F), ve = ce.length;
        if (ve === 0)
          throw new TypeError('The value "' + x + '" is invalid for argument "value"');
        for (ge = 0; ge < D - L; ++ge)
          this[ge + L] = ce[ge % ve];
      }
      return this;
    };
    var J = /[^+/0-9A-Za-z-_]/g;
    function W(x) {
      if (x = x.split("=")[0], x = x.trim().replace(J, ""), x.length < 2)
        return "";
      for (; x.length % 4 !== 0; )
        x = x + "=";
      return x;
    }
    function Q(x, L) {
      L = L || 1 / 0;
      for (var D, F = x.length, ue = null, ge = [], ce = 0; ce < F; ++ce) {
        if (D = x.charCodeAt(ce), D > 55295 && D < 57344) {
          if (!ue) {
            if (D > 56319) {
              (L -= 3) > -1 && ge.push(239, 191, 189);
              continue;
            } else if (ce + 1 === F) {
              (L -= 3) > -1 && ge.push(239, 191, 189);
              continue;
            }
            ue = D;
            continue;
          }
          if (D < 56320) {
            (L -= 3) > -1 && ge.push(239, 191, 189), ue = D;
            continue;
          }
          D = (ue - 55296 << 10 | D - 56320) + 65536;
        } else
          ue && (L -= 3) > -1 && ge.push(239, 191, 189);
        if (ue = null, D < 128) {
          if ((L -= 1) < 0)
            break;
          ge.push(D);
        } else if (D < 2048) {
          if ((L -= 2) < 0)
            break;
          ge.push(
            D >> 6 | 192,
            D & 63 | 128
          );
        } else if (D < 65536) {
          if ((L -= 3) < 0)
            break;
          ge.push(
            D >> 12 | 224,
            D >> 6 & 63 | 128,
            D & 63 | 128
          );
        } else if (D < 1114112) {
          if ((L -= 4) < 0)
            break;
          ge.push(
            D >> 18 | 240,
            D >> 12 & 63 | 128,
            D >> 6 & 63 | 128,
            D & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return ge;
    }
    function me(x) {
      for (var L = [], D = 0; D < x.length; ++D)
        L.push(x.charCodeAt(D) & 255);
      return L;
    }
    function be(x, L) {
      for (var D, F, ue, ge = [], ce = 0; ce < x.length && !((L -= 2) < 0); ++ce)
        D = x.charCodeAt(ce), F = D >> 8, ue = D % 256, ge.push(ue), ge.push(F);
      return ge;
    }
    function Y(x) {
      return t.toByteArray(W(x));
    }
    function re(x, L, D, F) {
      for (var ue = 0; ue < F && !(ue + D >= L.length || ue >= x.length); ++ue)
        L[ue + D] = x[ue];
      return ue;
    }
    function de(x, L) {
      return x instanceof L || x != null && x.constructor != null && x.constructor.name != null && x.constructor.name === L.name;
    }
    function Ae(x) {
      return x !== x;
    }
    var qe = function() {
      for (var x = "0123456789abcdef", L = new Array(256), D = 0; D < 16; ++D)
        for (var F = D * 16, ue = 0; ue < 16; ++ue)
          L[F + ue] = x[D] + x[ue];
      return L;
    }();
  }(buffer$1)), buffer$1;
}
var bufferExports = requireBuffer$1(), browser$c = { exports: {} }, process = browser$c.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(e) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(e, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(e, 0);
  try {
    return cachedSetTimeout(e, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, e, 0);
    } catch {
      return cachedSetTimeout.call(this, e, 0);
    }
  }
}
function runClearTimeout(e) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(e);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(e);
  try {
    return cachedClearTimeout(e);
  } catch {
    try {
      return cachedClearTimeout.call(null, e);
    } catch {
      return cachedClearTimeout.call(this, e);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var e = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var t = queue.length; t; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < t; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, t = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(e);
  }
}
process.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var o = 1; o < arguments.length; o++)
      t[o - 1] = arguments[o];
  queue.push(new Item(e, t)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(e, t) {
  this.fun = e, this.array = t;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(e) {
  return [];
};
process.binding = function(e) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser$c.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
(function(e) {
  function t() {
    var r = this || self;
    return delete e.prototype.__magic__, r;
  }
  if (typeof globalThis == "object")
    return globalThis;
  if (this)
    return t();
  e.defineProperty(e.prototype, "__magic__", {
    configurable: !0,
    get: t
  });
  var o = __magic__;
  return o;
})(Object);
var eventemitter2 = { exports: {} };
(function(e, t) {
  (function(o) {
    var r = Object.hasOwnProperty, h = Array.isArray ? Array.isArray : function(S) {
      return Object.prototype.toString.call(S) === "[object Array]";
    }, a = 10, p = typeof process$1 == "object" && typeof process$1.nextTick == "function", d = typeof Symbol == "function", b = typeof Reflect == "object", g = typeof setImmediate == "function", w = g ? setImmediate : setTimeout, C = d ? b && typeof Reflect.ownKeys == "function" ? Reflect.ownKeys : function(S) {
      var _ = Object.getOwnPropertyNames(S);
      return _.push.apply(_, Object.getOwnPropertySymbols(S)), _;
    } : Object.keys;
    function T() {
      this._events = {}, this._conf && k.call(this, this._conf);
    }
    function k(S) {
      S && (this._conf = S, S.delimiter && (this.delimiter = S.delimiter), S.maxListeners !== o && (this._maxListeners = S.maxListeners), S.wildcard && (this.wildcard = S.wildcard), S.newListener && (this._newListener = S.newListener), S.removeListener && (this._removeListener = S.removeListener), S.verboseMemoryLeak && (this.verboseMemoryLeak = S.verboseMemoryLeak), S.ignoreErrors && (this.ignoreErrors = S.ignoreErrors), this.wildcard && (this.listenerTree = {}));
    }
    function q(S, _) {
      var E = "(node) warning: possible EventEmitter memory leak detected. " + S + " listeners added. Use emitter.setMaxListeners() to increase limit.";
      if (this.verboseMemoryLeak && (E += " Event name: " + _ + "."), typeof process$1 < "u" && process$1.emitWarning) {
        var m = new Error(E);
        m.name = "MaxListenersExceededWarning", m.emitter = this, m.count = S, process$1.emitWarning(m);
      } else
        console.error(E), console.trace && console.trace();
    }
    var O = function(S, _, E) {
      var m = arguments.length;
      switch (m) {
        case 0:
          return [];
        case 1:
          return [S];
        case 2:
          return [S, _];
        case 3:
          return [S, _, E];
        default:
          for (var A = new Array(m); m--; )
            A[m] = arguments[m];
          return A;
      }
    };
    function N(S, _) {
      for (var E = {}, m, A = S.length, $ = _ ? _.length : 0, X = 0; X < A; X++)
        m = S[X], E[m] = X < $ ? _[X] : o;
      return E;
    }
    function j(S, _, E) {
      this._emitter = S, this._target = _, this._listeners = {}, this._listenersCount = 0;
      var m, A;
      if ((E.on || E.off) && (m = E.on, A = E.off), _.addEventListener ? (m = _.addEventListener, A = _.removeEventListener) : _.addListener ? (m = _.addListener, A = _.removeListener) : _.on && (m = _.on, A = _.off), !m && !A)
        throw Error("target does not implement any known event API");
      if (typeof m != "function")
        throw TypeError("on method must be a function");
      if (typeof A != "function")
        throw TypeError("off method must be a function");
      this._on = m, this._off = A;
      var $ = S._observers;
      $ ? $.push(this) : S._observers = [this];
    }
    Object.assign(j.prototype, {
      subscribe: function(S, _, E) {
        var m = this, A = this._target, $ = this._emitter, X = this._listeners, oe = function() {
          var J = O.apply(null, arguments), W = {
            data: J,
            name: _,
            original: S
          };
          if (E) {
            var Q = E.call(A, W);
            Q !== !1 && $.emit.apply($, [W.name].concat(J));
            return;
          }
          $.emit.apply($, [_].concat(J));
        };
        if (X[S])
          throw Error("Event '" + S + "' is already listening");
        this._listenersCount++, $._newListener && $._removeListener && !m._onNewListener ? (this._onNewListener = function(J) {
          J === _ && X[S] === null && (X[S] = oe, m._on.call(A, S, oe));
        }, $.on("newListener", this._onNewListener), this._onRemoveListener = function(J) {
          J === _ && !$.hasListeners(J) && X[S] && (X[S] = null, m._off.call(A, S, oe));
        }, X[S] = null, $.on("removeListener", this._onRemoveListener)) : (X[S] = oe, m._on.call(A, S, oe));
      },
      unsubscribe: function(S) {
        var _ = this, E = this._listeners, m = this._emitter, A, $, X = this._off, oe = this._target, J;
        if (S && typeof S != "string")
          throw TypeError("event must be a string");
        function W() {
          _._onNewListener && (m.off("newListener", _._onNewListener), m.off("removeListener", _._onRemoveListener), _._onNewListener = null, _._onRemoveListener = null);
          var Q = Z.call(m, _);
          m._observers.splice(Q, 1);
        }
        if (S) {
          if (A = E[S], !A)
            return;
          X.call(oe, S, A), delete E[S], --this._listenersCount || W();
        } else {
          for ($ = C(E), J = $.length; J-- > 0; )
            S = $[J], X.call(oe, S, E[S]);
          this._listeners = {}, this._listenersCount = 0, W();
        }
      }
    });
    function U(S, _, E, m) {
      var A = Object.assign({}, _);
      if (!S)
        return A;
      if (typeof S != "object")
        throw TypeError("options must be an object");
      var $ = Object.keys(S), X = $.length, oe, J, W;
      function Q(be) {
        throw Error('Invalid "' + oe + '" option value' + (be ? ". Reason: " + be : ""));
      }
      for (var me = 0; me < X; me++) {
        if (oe = $[me], !m && !r.call(_, oe))
          throw Error('Unknown "' + oe + '" option');
        J = S[oe], J !== o && (W = E[oe], A[oe] = W ? W(J, Q) : J);
      }
      return A;
    }
    function H(S, _) {
      return (typeof S != "function" || !S.hasOwnProperty("prototype")) && _("value must be a constructor"), S;
    }
    function z(S) {
      var _ = "value must be type of " + S.join("|"), E = S.length, m = S[0], A = S[1];
      return E === 1 ? function($, X) {
        if (typeof $ === m)
          return $;
        X(_);
      } : E === 2 ? function($, X) {
        var oe = typeof $;
        if (oe === m || oe === A)
          return $;
        X(_);
      } : function($, X) {
        for (var oe = typeof $, J = E; J-- > 0; )
          if (oe === S[J])
            return $;
        X(_);
      };
    }
    var ee = z(["function"]), ne = z(["object", "function"]);
    function le(S, _, E) {
      var m, A, $ = 0, X, oe = new S(function(J, W, Q) {
        E = U(E, {
          timeout: 0,
          overload: !1
        }, {
          timeout: function(re, de) {
            return re *= 1, (typeof re != "number" || re < 0 || !Number.isFinite(re)) && de("timeout must be a positive number"), re;
          }
        }), m = !E.overload && typeof S.prototype.cancel == "function" && typeof Q == "function";
        function me() {
          A && (A = null), $ && (clearTimeout($), $ = 0);
        }
        var be = function(re) {
          me(), J(re);
        }, Y = function(re) {
          me(), W(re);
        };
        m ? _(be, Y, Q) : (A = [function(re) {
          Y(re || Error("canceled"));
        }], _(be, Y, function(re) {
          if (X)
            throw Error("Unable to subscribe on cancel event asynchronously");
          if (typeof re != "function")
            throw TypeError("onCancel callback must be a function");
          A.push(re);
        }), X = !0), E.timeout > 0 && ($ = setTimeout(function() {
          var re = Error("timeout");
          re.code = "ETIMEDOUT", $ = 0, oe.cancel(re), W(re);
        }, E.timeout));
      });
      return m || (oe.cancel = function(J) {
        if (A) {
          for (var W = A.length, Q = 1; Q < W; Q++)
            A[Q](J);
          A[0](J), A = null;
        }
      }), oe;
    }
    function Z(S) {
      var _ = this._observers;
      if (!_)
        return -1;
      for (var E = _.length, m = 0; m < E; m++)
        if (_[m]._target === S)
          return m;
      return -1;
    }
    function ie(S, _, E, m, A) {
      if (!E)
        return null;
      if (m === 0) {
        var $ = typeof _;
        if ($ === "string") {
          var X, oe, J = 0, W = 0, Q = this.delimiter, me = Q.length;
          if ((oe = _.indexOf(Q)) !== -1) {
            X = new Array(5);
            do
              X[J++] = _.slice(W, oe), W = oe + me;
            while ((oe = _.indexOf(Q, W)) !== -1);
            X[J++] = _.slice(W), _ = X, A = J;
          } else
            _ = [_], A = 1;
        } else
          $ === "object" ? A = _.length : (_ = [_], A = 1);
      }
      var be = null, Y, re, de, Ae, qe, x = _[m], L = _[m + 1], D, F;
      if (m === A)
        E._listeners && (typeof E._listeners == "function" ? (S && S.push(E._listeners), be = [E]) : (S && S.push.apply(S, E._listeners), be = [E]));
      else if (x === "*") {
        for (D = C(E), oe = D.length; oe-- > 0; )
          Y = D[oe], Y !== "_listeners" && (F = ie(S, _, E[Y], m + 1, A), F && (be ? be.push.apply(be, F) : be = F));
        return be;
      } else if (x === "**") {
        for (qe = m + 1 === A || m + 2 === A && L === "*", qe && E._listeners && (be = ie(S, _, E, A, A)), D = C(E), oe = D.length; oe-- > 0; )
          Y = D[oe], Y !== "_listeners" && (Y === "*" || Y === "**" ? (E[Y]._listeners && !qe && (F = ie(S, _, E[Y], A, A), F && (be ? be.push.apply(be, F) : be = F)), F = ie(S, _, E[Y], m, A)) : Y === L ? F = ie(S, _, E[Y], m + 2, A) : F = ie(S, _, E[Y], m, A), F && (be ? be.push.apply(be, F) : be = F));
        return be;
      } else
        E[x] && (be = ie(S, _, E[x], m + 1, A));
      if (re = E["*"], re && ie(S, _, re, m + 1, A), de = E["**"], de)
        if (m < A)
          for (de._listeners && ie(S, _, de, A, A), D = C(de), oe = D.length; oe-- > 0; )
            Y = D[oe], Y !== "_listeners" && (Y === L ? ie(S, _, de[Y], m + 2, A) : Y === x ? ie(S, _, de[Y], m + 1, A) : (Ae = {}, Ae[Y] = de[Y], ie(S, _, { "**": Ae }, m + 1, A)));
        else
          de._listeners ? ie(S, _, de, A, A) : de["*"] && de["*"]._listeners && ie(S, _, de["*"], A, A);
      return be;
    }
    function fe(S, _, E) {
      var m = 0, A = 0, $, X = this.delimiter, oe = X.length, J;
      if (typeof S == "string")
        if (($ = S.indexOf(X)) !== -1) {
          J = new Array(5);
          do
            J[m++] = S.slice(A, $), A = $ + oe;
          while (($ = S.indexOf(X, A)) !== -1);
          J[m++] = S.slice(A);
        } else
          J = [S], m = 1;
      else
        J = S, m = S.length;
      if (m > 1) {
        for ($ = 0; $ + 1 < m; $++)
          if (J[$] === "**" && J[$ + 1] === "**")
            return;
      }
      var W = this.listenerTree, Q;
      for ($ = 0; $ < m; $++)
        if (Q = J[$], W = W[Q] || (W[Q] = {}), $ === m - 1)
          return W._listeners ? (typeof W._listeners == "function" && (W._listeners = [W._listeners]), E ? W._listeners.unshift(_) : W._listeners.push(_), !W._listeners.warned && this._maxListeners > 0 && W._listeners.length > this._maxListeners && (W._listeners.warned = !0, q.call(this, W._listeners.length, Q))) : W._listeners = _, !0;
      return !0;
    }
    function I(S, _, E, m) {
      for (var A = C(S), $ = A.length, X, oe, J, W = S._listeners, Q; $-- > 0; )
        oe = A[$], X = S[oe], oe === "_listeners" ? J = E : J = E ? E.concat(oe) : [oe], Q = m || typeof oe == "symbol", W && _.push(Q ? J : J.join(this.delimiter)), typeof X == "object" && I.call(this, X, _, J, Q);
      return _;
    }
    function P(S) {
      for (var _ = C(S), E = _.length, m, A, $; E-- > 0; )
        A = _[E], m = S[A], m && ($ = !0, A !== "_listeners" && !P(m) && delete S[A]);
      return $;
    }
    function f(S, _, E) {
      this.emitter = S, this.event = _, this.listener = E;
    }
    f.prototype.off = function() {
      return this.emitter.off(this.event, this.listener), this;
    };
    function y(S, _, E) {
      if (E === !0)
        A = !0;
      else if (E === !1)
        m = !0;
      else {
        if (!E || typeof E != "object")
          throw TypeError("options should be an object or true");
        var m = E.async, A = E.promisify, $ = E.nextTick, X = E.objectify;
      }
      if (m || $ || A) {
        var oe = _, J = _._origin || _;
        if ($ && !p)
          throw Error("process.nextTick is not supported");
        A === o && (A = _.constructor.name === "AsyncFunction"), _ = function() {
          var W = arguments, Q = this, me = this.event;
          return A ? $ ? Promise.resolve() : new Promise(function(be) {
            w(be);
          }).then(function() {
            return Q.event = me, oe.apply(Q, W);
          }) : ($ ? process$1.nextTick : w)(function() {
            Q.event = me, oe.apply(Q, W);
          });
        }, _._async = !0, _._origin = J;
      }
      return [_, X ? new f(this, S, _) : this];
    }
    function v(S) {
      this._events = {}, this._newListener = !1, this._removeListener = !1, this.verboseMemoryLeak = !1, k.call(this, S);
    }
    v.EventEmitter2 = v, v.prototype.listenTo = function(S, _, E) {
      if (typeof S != "object")
        throw TypeError("target musts be an object");
      var m = this;
      E = U(E, {
        on: o,
        off: o,
        reducers: o
      }, {
        on: ee,
        off: ee,
        reducers: ne
      });
      function A($) {
        if (typeof $ != "object")
          throw TypeError("events must be an object");
        var X = E.reducers, oe = Z.call(m, S), J;
        oe === -1 ? J = new j(m, S, E) : J = m._observers[oe];
        for (var W = C($), Q = W.length, me, be = typeof X == "function", Y = 0; Y < Q; Y++)
          me = W[Y], J.subscribe(
            me,
            $[me] || me,
            be ? X : X && X[me]
          );
      }
      return h(_) ? A(N(_)) : A(typeof _ == "string" ? N(_.split(/\s+/)) : _), this;
    }, v.prototype.stopListeningTo = function(S, _) {
      var E = this._observers;
      if (!E)
        return !1;
      var m = E.length, A, $ = !1;
      if (S && typeof S != "object")
        throw TypeError("target should be an object");
      for (; m-- > 0; )
        A = E[m], (!S || A._target === S) && (A.unsubscribe(_), $ = !0);
      return $;
    }, v.prototype.delimiter = ".", v.prototype.setMaxListeners = function(S) {
      S !== o && (this._maxListeners = S, this._conf || (this._conf = {}), this._conf.maxListeners = S);
    }, v.prototype.getMaxListeners = function() {
      return this._maxListeners;
    }, v.prototype.event = "", v.prototype.once = function(S, _, E) {
      return this._once(S, _, !1, E);
    }, v.prototype.prependOnceListener = function(S, _, E) {
      return this._once(S, _, !0, E);
    }, v.prototype._once = function(S, _, E, m) {
      return this._many(S, 1, _, E, m);
    }, v.prototype.many = function(S, _, E, m) {
      return this._many(S, _, E, !1, m);
    }, v.prototype.prependMany = function(S, _, E, m) {
      return this._many(S, _, E, !0, m);
    }, v.prototype._many = function(S, _, E, m, A) {
      var $ = this;
      if (typeof E != "function")
        throw new Error("many only accepts instances of Function");
      function X() {
        return --_ === 0 && $.off(S, X), E.apply(this, arguments);
      }
      return X._origin = E, this._on(S, X, m, A);
    }, v.prototype.emit = function() {
      if (!this._events && !this._all)
        return !1;
      this._events || T.call(this);
      var S = arguments[0], _, E = this.wildcard, m, A, $, X, oe;
      if (S === "newListener" && !this._newListener && !this._events.newListener)
        return !1;
      if (E && (_ = S, S !== "newListener" && S !== "removeListener" && typeof S == "object")) {
        if (A = S.length, d) {
          for ($ = 0; $ < A; $++)
            if (typeof S[$] == "symbol") {
              oe = !0;
              break;
            }
        }
        oe || (S = S.join(this.delimiter));
      }
      var J = arguments.length, W;
      if (this._all && this._all.length)
        for (W = this._all.slice(), $ = 0, A = W.length; $ < A; $++)
          switch (this.event = S, J) {
            case 1:
              W[$].call(this, S);
              break;
            case 2:
              W[$].call(this, S, arguments[1]);
              break;
            case 3:
              W[$].call(this, S, arguments[1], arguments[2]);
              break;
            default:
              W[$].apply(this, arguments);
          }
      if (E)
        W = [], ie.call(this, W, _, this.listenerTree, 0, A);
      else if (W = this._events[S], typeof W == "function") {
        switch (this.event = S, J) {
          case 1:
            W.call(this);
            break;
          case 2:
            W.call(this, arguments[1]);
            break;
          case 3:
            W.call(this, arguments[1], arguments[2]);
            break;
          default:
            for (m = new Array(J - 1), X = 1; X < J; X++)
              m[X - 1] = arguments[X];
            W.apply(this, m);
        }
        return !0;
      } else
        W && (W = W.slice());
      if (W && W.length) {
        if (J > 3)
          for (m = new Array(J - 1), X = 1; X < J; X++)
            m[X - 1] = arguments[X];
        for ($ = 0, A = W.length; $ < A; $++)
          switch (this.event = S, J) {
            case 1:
              W[$].call(this);
              break;
            case 2:
              W[$].call(this, arguments[1]);
              break;
            case 3:
              W[$].call(this, arguments[1], arguments[2]);
              break;
            default:
              W[$].apply(this, m);
          }
        return !0;
      } else if (!this.ignoreErrors && !this._all && S === "error")
        throw arguments[1] instanceof Error ? arguments[1] : new Error("Uncaught, unspecified 'error' event.");
      return !!this._all;
    }, v.prototype.emitAsync = function() {
      if (!this._events && !this._all)
        return !1;
      this._events || T.call(this);
      var S = arguments[0], _ = this.wildcard, E, m, A, $, X, oe;
      if (S === "newListener" && !this._newListener && !this._events.newListener)
        return Promise.resolve([!1]);
      if (_ && (E = S, S !== "newListener" && S !== "removeListener" && typeof S == "object")) {
        if ($ = S.length, d) {
          for (X = 0; X < $; X++)
            if (typeof S[X] == "symbol") {
              m = !0;
              break;
            }
        }
        m || (S = S.join(this.delimiter));
      }
      var J = [], W = arguments.length, Q;
      if (this._all)
        for (X = 0, $ = this._all.length; X < $; X++)
          switch (this.event = S, W) {
            case 1:
              J.push(this._all[X].call(this, S));
              break;
            case 2:
              J.push(this._all[X].call(this, S, arguments[1]));
              break;
            case 3:
              J.push(this._all[X].call(this, S, arguments[1], arguments[2]));
              break;
            default:
              J.push(this._all[X].apply(this, arguments));
          }
      if (_ ? (Q = [], ie.call(this, Q, E, this.listenerTree, 0)) : Q = this._events[S], typeof Q == "function")
        switch (this.event = S, W) {
          case 1:
            J.push(Q.call(this));
            break;
          case 2:
            J.push(Q.call(this, arguments[1]));
            break;
          case 3:
            J.push(Q.call(this, arguments[1], arguments[2]));
            break;
          default:
            for (A = new Array(W - 1), oe = 1; oe < W; oe++)
              A[oe - 1] = arguments[oe];
            J.push(Q.apply(this, A));
        }
      else if (Q && Q.length) {
        if (Q = Q.slice(), W > 3)
          for (A = new Array(W - 1), oe = 1; oe < W; oe++)
            A[oe - 1] = arguments[oe];
        for (X = 0, $ = Q.length; X < $; X++)
          switch (this.event = S, W) {
            case 1:
              J.push(Q[X].call(this));
              break;
            case 2:
              J.push(Q[X].call(this, arguments[1]));
              break;
            case 3:
              J.push(Q[X].call(this, arguments[1], arguments[2]));
              break;
            default:
              J.push(Q[X].apply(this, A));
          }
      } else if (!this.ignoreErrors && !this._all && S === "error")
        return arguments[1] instanceof Error ? Promise.reject(arguments[1]) : Promise.reject("Uncaught, unspecified 'error' event.");
      return Promise.all(J);
    }, v.prototype.on = function(S, _, E) {
      return this._on(S, _, !1, E);
    }, v.prototype.prependListener = function(S, _, E) {
      return this._on(S, _, !0, E);
    }, v.prototype.onAny = function(S) {
      return this._onAny(S, !1);
    }, v.prototype.prependAny = function(S) {
      return this._onAny(S, !0);
    }, v.prototype.addListener = v.prototype.on, v.prototype._onAny = function(S, _) {
      if (typeof S != "function")
        throw new Error("onAny only accepts instances of Function");
      return this._all || (this._all = []), _ ? this._all.unshift(S) : this._all.push(S), this;
    }, v.prototype._on = function(S, _, E, m) {
      if (typeof S == "function")
        return this._onAny(S, _), this;
      if (typeof _ != "function")
        throw new Error("on only accepts instances of Function");
      this._events || T.call(this);
      var A = this, $;
      return m !== o && ($ = y.call(this, S, _, m), _ = $[0], A = $[1]), this._newListener && this.emit("newListener", S, _), this.wildcard ? (fe.call(this, S, _, E), A) : (this._events[S] ? (typeof this._events[S] == "function" && (this._events[S] = [this._events[S]]), E ? this._events[S].unshift(_) : this._events[S].push(_), !this._events[S].warned && this._maxListeners > 0 && this._events[S].length > this._maxListeners && (this._events[S].warned = !0, q.call(this, this._events[S].length, S))) : this._events[S] = _, A);
    }, v.prototype.off = function(S, _) {
      if (typeof _ != "function")
        throw new Error("removeListener only takes instances of Function");
      var E, m = [];
      if (this.wildcard) {
        var A = typeof S == "string" ? S.split(this.delimiter) : S.slice();
        if (m = ie.call(this, null, A, this.listenerTree, 0), !m)
          return this;
      } else {
        if (!this._events[S])
          return this;
        E = this._events[S], m.push({ _listeners: E });
      }
      for (var $ = 0; $ < m.length; $++) {
        var X = m[$];
        if (E = X._listeners, h(E)) {
          for (var oe = -1, J = 0, W = E.length; J < W; J++)
            if (E[J] === _ || E[J].listener && E[J].listener === _ || E[J]._origin && E[J]._origin === _) {
              oe = J;
              break;
            }
          if (oe < 0)
            continue;
          return this.wildcard ? X._listeners.splice(oe, 1) : this._events[S].splice(oe, 1), E.length === 0 && (this.wildcard ? delete X._listeners : delete this._events[S]), this._removeListener && this.emit("removeListener", S, _), this;
        } else
          (E === _ || E.listener && E.listener === _ || E._origin && E._origin === _) && (this.wildcard ? delete X._listeners : delete this._events[S], this._removeListener && this.emit("removeListener", S, _));
      }
      return this.listenerTree && P(this.listenerTree), this;
    }, v.prototype.offAny = function(S) {
      var _ = 0, E = 0, m;
      if (S && this._all && this._all.length > 0) {
        for (m = this._all, _ = 0, E = m.length; _ < E; _++)
          if (S === m[_])
            return m.splice(_, 1), this._removeListener && this.emit("removeListenerAny", S), this;
      } else {
        if (m = this._all, this._removeListener)
          for (_ = 0, E = m.length; _ < E; _++)
            this.emit("removeListenerAny", m[_]);
        this._all = [];
      }
      return this;
    }, v.prototype.removeListener = v.prototype.off, v.prototype.removeAllListeners = function(S) {
      if (S === o)
        return !this._events || T.call(this), this;
      if (this.wildcard) {
        var _ = ie.call(this, null, S, this.listenerTree, 0), E, m;
        if (!_)
          return this;
        for (m = 0; m < _.length; m++)
          E = _[m], E._listeners = null;
        this.listenerTree && P(this.listenerTree);
      } else
        this._events && (this._events[S] = null);
      return this;
    }, v.prototype.listeners = function(S) {
      var _ = this._events, E, m, A, $, X;
      if (S === o) {
        if (this.wildcard)
          throw Error("event name required for wildcard emitter");
        if (!_)
          return [];
        for (E = C(_), $ = E.length, A = []; $-- > 0; )
          m = _[E[$]], typeof m == "function" ? A.push(m) : A.push.apply(A, m);
        return A;
      } else {
        if (this.wildcard) {
          if (X = this.listenerTree, !X)
            return [];
          var oe = [], J = typeof S == "string" ? S.split(this.delimiter) : S.slice();
          return ie.call(this, oe, J, X, 0), oe;
        }
        return _ ? (m = _[S], m ? typeof m == "function" ? [m] : m : []) : [];
      }
    }, v.prototype.eventNames = function(S) {
      var _ = this._events;
      return this.wildcard ? I.call(this, this.listenerTree, [], null, S) : _ ? C(_) : [];
    }, v.prototype.listenerCount = function(S) {
      return this.listeners(S).length;
    }, v.prototype.hasListeners = function(S) {
      if (this.wildcard) {
        var _ = [], E = typeof S == "string" ? S.split(this.delimiter) : S.slice();
        return ie.call(this, _, E, this.listenerTree, 0), _.length > 0;
      }
      var m = this._events, A = this._all;
      return !!(A && A.length || m && (S === o ? C(m).length : m[S]));
    }, v.prototype.listenersAny = function() {
      return this._all ? this._all : [];
    }, v.prototype.waitFor = function(S, _) {
      var E = this, m = typeof _;
      return m === "number" ? _ = { timeout: _ } : m === "function" && (_ = { filter: _ }), _ = U(_, {
        timeout: 0,
        filter: o,
        handleError: !1,
        Promise,
        overload: !1
      }, {
        filter: ee,
        Promise: H
      }), le(_.Promise, function(A, $, X) {
        function oe() {
          var J = _.filter;
          if (!(J && !J.apply(E, arguments)))
            if (E.off(S, oe), _.handleError) {
              var W = arguments[0];
              W ? $(W) : A(O.apply(null, arguments).slice(1));
            } else
              A(O.apply(null, arguments));
        }
        X(function() {
          E.off(S, oe);
        }), E._on(S, oe, !1);
      }, {
        timeout: _.timeout,
        overload: _.overload
      });
    };
    function M(S, _, E) {
      E = U(E, {
        Promise,
        timeout: 0,
        overload: !1
      }, {
        Promise: H
      });
      var m = E.Promise;
      return le(m, function(A, $, X) {
        var oe;
        if (typeof S.addEventListener == "function") {
          oe = function() {
            A(O.apply(null, arguments));
          }, X(function() {
            S.removeEventListener(_, oe);
          }), S.addEventListener(
            _,
            oe,
            { once: !0 }
          );
          return;
        }
        var J = function() {
          W && S.removeListener("error", W), A(O.apply(null, arguments));
        }, W;
        _ !== "error" && (W = function(Q) {
          S.removeListener(_, J), $(Q);
        }, S.once("error", W)), X(function() {
          W && S.removeListener("error", W), S.removeListener(_, J);
        }), S.once(_, J);
      }, {
        timeout: E.timeout,
        overload: E.overload
      });
    }
    var B = v.prototype;
    Object.defineProperties(v, {
      defaultMaxListeners: {
        get: function() {
          return B._maxListeners;
        },
        set: function(S) {
          if (typeof S != "number" || S < 0 || Number.isNaN(S))
            throw TypeError("n must be a non-negative number");
          B._maxListeners = S;
        },
        enumerable: !0
      },
      once: {
        value: M,
        writable: !0,
        configurable: !0
      }
    }), Object.defineProperties(B, {
      _maxListeners: {
        value: a,
        writable: !0,
        configurable: !0
      },
      _observers: { value: null, writable: !0, configurable: !0 }
    }), typeof o == "function" && o.amd ? o(function() {
      return v;
    }) : e.exports = v;
  })();
})(eventemitter2);
var eventemitter2Exports = eventemitter2.exports;
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter2Exports);
class FetchAPI extends EventEmitter {
  constructor(t) {
    super(), this.baseUrl = t;
  }
  async send(t, o) {
    const { url: r, query: h, method: a, data: p, headers: d } = t, [b, g] = p instanceof FormData ? [p, {}] : [
      typeof p != "string" ? JSON.stringify(p) : p,
      {
        "Content-Type": "application/json"
      }
    ], w = this.baseUrl + r, C = this.getUrlWithParams(w, h), T = await fetch(C, {
      method: a,
      headers: Object.assign(d || {}, g),
      body: b,
      credentials: t.withCredentials ? "include" : "same-origin"
    }), k = await T.json(), q = this.convertHeadersToPlainObject(T.headers);
    return new APIResponse({
      data: k,
      status: T.status,
      headers: q,
      request: t
    });
  }
  getUrlWithParams(t, o) {
    if (!o)
      return t;
    const r = new URL(t);
    return Object.entries(o).forEach(
      ([h, a]) => {
        r.searchParams.append(h, a);
      }
    ), r.toString();
  }
  convertHeadersToPlainObject(t) {
    const o = {};
    for (const r of Object.keys(t))
      o[r] = t.get(r);
    return o;
  }
  // type override 를 위해서 구현 class 에서 메서드들을 재정의 해줘야함..
  addListener(t, o) {
    return super.addListener(t, o);
  }
  on(t, o, r) {
    return super.on(t, o, r);
  }
  prependListener(t, o, r) {
    return super.prependListener(t, o, r);
  }
  once(t, o, r) {
    return super.once(t, o, r);
  }
  emit(t, ...o) {
    return super.emit(t, ...o);
  }
  emitAsync(t, ...o) {
    return super.emitAsync(t, ...o);
  }
}
function commonjsRequire(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var bcrypt$1 = { exports: {} }, cryptoBrowserify = {}, browser$b = { exports: {} }, safeBuffer$1 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer$1;
function requireSafeBuffer$1() {
  return hasRequiredSafeBuffer$1 || (hasRequiredSafeBuffer$1 = 1, function(e, t) {
    var o = requireBuffer$1(), r = o.Buffer;
    function h(p, d) {
      for (var b in p)
        d[b] = p[b];
    }
    r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? e.exports = o : (h(o, t), t.Buffer = a);
    function a(p, d, b) {
      return r(p, d, b);
    }
    a.prototype = Object.create(r.prototype), h(r, a), a.from = function(p, d, b) {
      if (typeof p == "number")
        throw new TypeError("Argument must not be a number");
      return r(p, d, b);
    }, a.alloc = function(p, d, b) {
      if (typeof p != "number")
        throw new TypeError("Argument must be a number");
      var g = r(p);
      return d !== void 0 ? typeof b == "string" ? g.fill(d, b) : g.fill(d) : g.fill(0), g;
    }, a.allocUnsafe = function(p) {
      if (typeof p != "number")
        throw new TypeError("Argument must be a number");
      return r(p);
    }, a.allocUnsafeSlow = function(p) {
      if (typeof p != "number")
        throw new TypeError("Argument must be a number");
      return o.SlowBuffer(p);
    };
  }(safeBuffer$1, safeBuffer$1.exports)), safeBuffer$1.exports;
}
var hasRequiredBrowser$b;
function requireBrowser$b() {
  if (hasRequiredBrowser$b)
    return browser$b.exports;
  hasRequiredBrowser$b = 1;
  var e = 65536, t = 4294967295;
  function o() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var r = requireSafeBuffer$1().Buffer, h = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  h && h.getRandomValues ? browser$b.exports = a : browser$b.exports = o;
  function a(p, d) {
    if (p > t)
      throw new RangeError("requested too many random bytes");
    var b = r.allocUnsafe(p);
    if (p > 0)
      if (p > e)
        for (var g = 0; g < p; g += e)
          h.getRandomValues(b.slice(g, g + e));
      else
        h.getRandomValues(b);
    return typeof d == "function" ? process$1.nextTick(function() {
      d(null, b);
    }) : b;
  }
  return browser$b.exports;
}
var inherits_browser = { exports: {} }, hasRequiredInherits_browser;
function requireInherits_browser() {
  return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function(e, t) {
    t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
      constructor: {
        value: e,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : inherits_browser.exports = function(e, t) {
    if (t) {
      e.super_ = t;
      var o = function() {
      };
      o.prototype = t.prototype, e.prototype = new o(), e.prototype.constructor = e;
    }
  }), inherits_browser.exports;
}
var readableBrowser$1 = { exports: {} }, events = { exports: {} }, hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents)
    return events.exports;
  hasRequiredEvents = 1;
  var e = typeof Reflect == "object" ? Reflect : null, t = e && typeof e.apply == "function" ? e.apply : function(z, ee, ne) {
    return Function.prototype.apply.call(z, ee, ne);
  }, o;
  e && typeof e.ownKeys == "function" ? o = e.ownKeys : Object.getOwnPropertySymbols ? o = function(z) {
    return Object.getOwnPropertyNames(z).concat(Object.getOwnPropertySymbols(z));
  } : o = function(z) {
    return Object.getOwnPropertyNames(z);
  };
  function r(z) {
    console && console.warn && console.warn(z);
  }
  var h = Number.isNaN || function(z) {
    return z !== z;
  };
  function a() {
    a.init.call(this);
  }
  events.exports = a, events.exports.once = j, a.EventEmitter = a, a.prototype._events = void 0, a.prototype._eventsCount = 0, a.prototype._maxListeners = void 0;
  var p = 10;
  function d(z) {
    if (typeof z != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof z);
  }
  Object.defineProperty(a, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return p;
    },
    set: function(z) {
      if (typeof z != "number" || z < 0 || h(z))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + z + ".");
      p = z;
    }
  }), a.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, a.prototype.setMaxListeners = function(z) {
    if (typeof z != "number" || z < 0 || h(z))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + z + ".");
    return this._maxListeners = z, this;
  };
  function b(z) {
    return z._maxListeners === void 0 ? a.defaultMaxListeners : z._maxListeners;
  }
  a.prototype.getMaxListeners = function() {
    return b(this);
  }, a.prototype.emit = function(z) {
    for (var ee = [], ne = 1; ne < arguments.length; ne++)
      ee.push(arguments[ne]);
    var le = z === "error", Z = this._events;
    if (Z !== void 0)
      le = le && Z.error === void 0;
    else if (!le)
      return !1;
    if (le) {
      var ie;
      if (ee.length > 0 && (ie = ee[0]), ie instanceof Error)
        throw ie;
      var fe = new Error("Unhandled error." + (ie ? " (" + ie.message + ")" : ""));
      throw fe.context = ie, fe;
    }
    var I = Z[z];
    if (I === void 0)
      return !1;
    if (typeof I == "function")
      t(I, this, ee);
    else
      for (var P = I.length, f = q(I, P), ne = 0; ne < P; ++ne)
        t(f[ne], this, ee);
    return !0;
  };
  function g(z, ee, ne, le) {
    var Z, ie, fe;
    if (d(ne), ie = z._events, ie === void 0 ? (ie = z._events = /* @__PURE__ */ Object.create(null), z._eventsCount = 0) : (ie.newListener !== void 0 && (z.emit(
      "newListener",
      ee,
      ne.listener ? ne.listener : ne
    ), ie = z._events), fe = ie[ee]), fe === void 0)
      fe = ie[ee] = ne, ++z._eventsCount;
    else if (typeof fe == "function" ? fe = ie[ee] = le ? [ne, fe] : [fe, ne] : le ? fe.unshift(ne) : fe.push(ne), Z = b(z), Z > 0 && fe.length > Z && !fe.warned) {
      fe.warned = !0;
      var I = new Error("Possible EventEmitter memory leak detected. " + fe.length + " " + String(ee) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      I.name = "MaxListenersExceededWarning", I.emitter = z, I.type = ee, I.count = fe.length, r(I);
    }
    return z;
  }
  a.prototype.addListener = function(z, ee) {
    return g(this, z, ee, !1);
  }, a.prototype.on = a.prototype.addListener, a.prototype.prependListener = function(z, ee) {
    return g(this, z, ee, !0);
  };
  function w() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function C(z, ee, ne) {
    var le = { fired: !1, wrapFn: void 0, target: z, type: ee, listener: ne }, Z = w.bind(le);
    return Z.listener = ne, le.wrapFn = Z, Z;
  }
  a.prototype.once = function(z, ee) {
    return d(ee), this.on(z, C(this, z, ee)), this;
  }, a.prototype.prependOnceListener = function(z, ee) {
    return d(ee), this.prependListener(z, C(this, z, ee)), this;
  }, a.prototype.removeListener = function(z, ee) {
    var ne, le, Z, ie, fe;
    if (d(ee), le = this._events, le === void 0)
      return this;
    if (ne = le[z], ne === void 0)
      return this;
    if (ne === ee || ne.listener === ee)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete le[z], le.removeListener && this.emit("removeListener", z, ne.listener || ee));
    else if (typeof ne != "function") {
      for (Z = -1, ie = ne.length - 1; ie >= 0; ie--)
        if (ne[ie] === ee || ne[ie].listener === ee) {
          fe = ne[ie].listener, Z = ie;
          break;
        }
      if (Z < 0)
        return this;
      Z === 0 ? ne.shift() : O(ne, Z), ne.length === 1 && (le[z] = ne[0]), le.removeListener !== void 0 && this.emit("removeListener", z, fe || ee);
    }
    return this;
  }, a.prototype.off = a.prototype.removeListener, a.prototype.removeAllListeners = function(z) {
    var ee, ne, le;
    if (ne = this._events, ne === void 0)
      return this;
    if (ne.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : ne[z] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete ne[z]), this;
    if (arguments.length === 0) {
      var Z = Object.keys(ne), ie;
      for (le = 0; le < Z.length; ++le)
        ie = Z[le], ie !== "removeListener" && this.removeAllListeners(ie);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (ee = ne[z], typeof ee == "function")
      this.removeListener(z, ee);
    else if (ee !== void 0)
      for (le = ee.length - 1; le >= 0; le--)
        this.removeListener(z, ee[le]);
    return this;
  };
  function T(z, ee, ne) {
    var le = z._events;
    if (le === void 0)
      return [];
    var Z = le[ee];
    return Z === void 0 ? [] : typeof Z == "function" ? ne ? [Z.listener || Z] : [Z] : ne ? N(Z) : q(Z, Z.length);
  }
  a.prototype.listeners = function(z) {
    return T(this, z, !0);
  }, a.prototype.rawListeners = function(z) {
    return T(this, z, !1);
  }, a.listenerCount = function(z, ee) {
    return typeof z.listenerCount == "function" ? z.listenerCount(ee) : k.call(z, ee);
  }, a.prototype.listenerCount = k;
  function k(z) {
    var ee = this._events;
    if (ee !== void 0) {
      var ne = ee[z];
      if (typeof ne == "function")
        return 1;
      if (ne !== void 0)
        return ne.length;
    }
    return 0;
  }
  a.prototype.eventNames = function() {
    return this._eventsCount > 0 ? o(this._events) : [];
  };
  function q(z, ee) {
    for (var ne = new Array(ee), le = 0; le < ee; ++le)
      ne[le] = z[le];
    return ne;
  }
  function O(z, ee) {
    for (; ee + 1 < z.length; ee++)
      z[ee] = z[ee + 1];
    z.pop();
  }
  function N(z) {
    for (var ee = new Array(z.length), ne = 0; ne < ee.length; ++ne)
      ee[ne] = z[ne].listener || z[ne];
    return ee;
  }
  function j(z, ee) {
    return new Promise(function(ne, le) {
      function Z(fe) {
        z.removeListener(ee, ie), le(fe);
      }
      function ie() {
        typeof z.removeListener == "function" && z.removeListener("error", Z), ne([].slice.call(arguments));
      }
      H(z, ee, ie, { once: !0 }), ee !== "error" && U(z, Z, { once: !0 });
    });
  }
  function U(z, ee, ne) {
    typeof z.on == "function" && H(z, "error", ee, ne);
  }
  function H(z, ee, ne, le) {
    if (typeof z.on == "function")
      le.once ? z.once(ee, ne) : z.on(ee, ne);
    else if (typeof z.addEventListener == "function")
      z.addEventListener(ee, function Z(ie) {
        le.once && z.removeEventListener(ee, Z), ne(ie);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof z);
  }
  return events.exports;
}
var streamBrowser$1, hasRequiredStreamBrowser$1;
function requireStreamBrowser$1() {
  return hasRequiredStreamBrowser$1 || (hasRequiredStreamBrowser$1 = 1, streamBrowser$1 = requireEvents().EventEmitter), streamBrowser$1;
}
var util$1 = {}, types = {}, shams$1, hasRequiredShams$1;
function requireShams$1() {
  return hasRequiredShams$1 || (hasRequiredShams$1 = 1, shams$1 = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var e = {}, t = Symbol("test"), o = Object(t);
    if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(o) !== "[object Symbol]")
      return !1;
    var r = 42;
    e[t] = r;
    for (t in e)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
      return !1;
    var h = Object.getOwnPropertySymbols(e);
    if (h.length !== 1 || h[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var a = Object.getOwnPropertyDescriptor(e, t);
      if (a.value !== r || a.enumerable !== !0)
        return !1;
    }
    return !0;
  }), shams$1;
}
var shams, hasRequiredShams;
function requireShams() {
  if (hasRequiredShams)
    return shams;
  hasRequiredShams = 1;
  var e = requireShams$1();
  return shams = function() {
    return e() && !!Symbol.toStringTag;
  }, shams;
}
var esErrors, hasRequiredEsErrors;
function requireEsErrors() {
  return hasRequiredEsErrors || (hasRequiredEsErrors = 1, esErrors = Error), esErrors;
}
var _eval, hasRequired_eval;
function require_eval() {
  return hasRequired_eval || (hasRequired_eval = 1, _eval = EvalError), _eval;
}
var range, hasRequiredRange;
function requireRange() {
  return hasRequiredRange || (hasRequiredRange = 1, range = RangeError), range;
}
var ref, hasRequiredRef;
function requireRef() {
  return hasRequiredRef || (hasRequiredRef = 1, ref = ReferenceError), ref;
}
var syntax, hasRequiredSyntax;
function requireSyntax() {
  return hasRequiredSyntax || (hasRequiredSyntax = 1, syntax = SyntaxError), syntax;
}
var type, hasRequiredType;
function requireType() {
  return hasRequiredType || (hasRequiredType = 1, type = TypeError), type;
}
var uri, hasRequiredUri;
function requireUri() {
  return hasRequiredUri || (hasRequiredUri = 1, uri = URIError), uri;
}
var hasSymbols, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols)
    return hasSymbols;
  hasRequiredHasSymbols = 1;
  var e = typeof Symbol < "u" && Symbol, t = requireShams$1();
  return hasSymbols = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, hasSymbols;
}
var hasProto, hasRequiredHasProto;
function requireHasProto() {
  if (hasRequiredHasProto)
    return hasProto;
  hasRequiredHasProto = 1;
  var e = {
    __proto__: null,
    foo: {}
  }, t = Object;
  return hasProto = function() {
    return { __proto__: e }.foo === e.foo && !(e instanceof t);
  }, hasProto;
}
var implementation, hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation)
    return implementation;
  hasRequiredImplementation = 1;
  var e = "Function.prototype.bind called on incompatible ", t = Object.prototype.toString, o = Math.max, r = "[object Function]", h = function(d, b) {
    for (var g = [], w = 0; w < d.length; w += 1)
      g[w] = d[w];
    for (var C = 0; C < b.length; C += 1)
      g[C + d.length] = b[C];
    return g;
  }, a = function(d, b) {
    for (var g = [], w = b || 0, C = 0; w < d.length; w += 1, C += 1)
      g[C] = d[w];
    return g;
  }, p = function(d, b) {
    for (var g = "", w = 0; w < d.length; w += 1)
      g += d[w], w + 1 < d.length && (g += b);
    return g;
  };
  return implementation = function(d) {
    var b = this;
    if (typeof b != "function" || t.apply(b) !== r)
      throw new TypeError(e + b);
    for (var g = a(arguments, 1), w, C = function() {
      if (this instanceof w) {
        var N = b.apply(
          this,
          h(g, arguments)
        );
        return Object(N) === N ? N : this;
      }
      return b.apply(
        d,
        h(g, arguments)
      );
    }, T = o(0, b.length - g.length), k = [], q = 0; q < T; q++)
      k[q] = "$" + q;
    if (w = Function("binder", "return function (" + p(k, ",") + "){ return binder.apply(this,arguments); }")(C), b.prototype) {
      var O = function() {
      };
      O.prototype = b.prototype, w.prototype = new O(), O.prototype = null;
    }
    return w;
  }, implementation;
}
var functionBind, hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind)
    return functionBind;
  hasRequiredFunctionBind = 1;
  var e = requireImplementation();
  return functionBind = Function.prototype.bind || e, functionBind;
}
var hasown, hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown)
    return hasown;
  hasRequiredHasown = 1;
  var e = Function.prototype.call, t = Object.prototype.hasOwnProperty, o = requireFunctionBind();
  return hasown = o.call(e, t), hasown;
}
var getIntrinsic, hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic)
    return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var e, t = requireEsErrors(), o = require_eval(), r = requireRange(), h = requireRef(), a = requireSyntax(), p = requireType(), d = requireUri(), b = Function, g = function(B) {
    try {
      return b('"use strict"; return (' + B + ").constructor;")();
    } catch {
    }
  }, w = Object.getOwnPropertyDescriptor;
  if (w)
    try {
      w({}, "");
    } catch {
      w = null;
    }
  var C = function() {
    throw new p();
  }, T = w ? function() {
    try {
      return arguments.callee, C;
    } catch {
      try {
        return w(arguments, "callee").get;
      } catch {
        return C;
      }
    }
  }() : C, k = requireHasSymbols()(), q = requireHasProto()(), O = Object.getPrototypeOf || (q ? function(B) {
    return B.__proto__;
  } : null), N = {}, j = typeof Uint8Array > "u" || !O ? e : O(Uint8Array), U = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? e : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? e : ArrayBuffer,
    "%ArrayIteratorPrototype%": k && O ? O([][Symbol.iterator]()) : e,
    "%AsyncFromSyncIteratorPrototype%": e,
    "%AsyncFunction%": N,
    "%AsyncGenerator%": N,
    "%AsyncGeneratorFunction%": N,
    "%AsyncIteratorPrototype%": N,
    "%Atomics%": typeof Atomics > "u" ? e : Atomics,
    "%BigInt%": typeof BigInt > "u" ? e : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? e : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? e : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? e : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": t,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": o,
    "%Float32Array%": typeof Float32Array > "u" ? e : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? e : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? e : FinalizationRegistry,
    "%Function%": b,
    "%GeneratorFunction%": N,
    "%Int8Array%": typeof Int8Array > "u" ? e : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? e : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? e : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": k && O ? O(O([][Symbol.iterator]())) : e,
    "%JSON%": typeof JSON == "object" ? JSON : e,
    "%Map%": typeof Map > "u" ? e : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !k || !O ? e : O((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? e : Promise,
    "%Proxy%": typeof Proxy > "u" ? e : Proxy,
    "%RangeError%": r,
    "%ReferenceError%": h,
    "%Reflect%": typeof Reflect > "u" ? e : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? e : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !k || !O ? e : O((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? e : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": k && O ? O(""[Symbol.iterator]()) : e,
    "%Symbol%": k ? Symbol : e,
    "%SyntaxError%": a,
    "%ThrowTypeError%": T,
    "%TypedArray%": j,
    "%TypeError%": p,
    "%Uint8Array%": typeof Uint8Array > "u" ? e : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? e : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? e : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? e : Uint32Array,
    "%URIError%": d,
    "%WeakMap%": typeof WeakMap > "u" ? e : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? e : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? e : WeakSet
  };
  if (O)
    try {
      null.error;
    } catch (B) {
      var H = O(O(B));
      U["%Error.prototype%"] = H;
    }
  var z = function B(S) {
    var _;
    if (S === "%AsyncFunction%")
      _ = g("async function () {}");
    else if (S === "%GeneratorFunction%")
      _ = g("function* () {}");
    else if (S === "%AsyncGeneratorFunction%")
      _ = g("async function* () {}");
    else if (S === "%AsyncGenerator%") {
      var E = B("%AsyncGeneratorFunction%");
      E && (_ = E.prototype);
    } else if (S === "%AsyncIteratorPrototype%") {
      var m = B("%AsyncGenerator%");
      m && O && (_ = O(m.prototype));
    }
    return U[S] = _, _;
  }, ee = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, ne = requireFunctionBind(), le = requireHasown(), Z = ne.call(Function.call, Array.prototype.concat), ie = ne.call(Function.apply, Array.prototype.splice), fe = ne.call(Function.call, String.prototype.replace), I = ne.call(Function.call, String.prototype.slice), P = ne.call(Function.call, RegExp.prototype.exec), f = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, y = /\\(\\)?/g, v = function(B) {
    var S = I(B, 0, 1), _ = I(B, -1);
    if (S === "%" && _ !== "%")
      throw new a("invalid intrinsic syntax, expected closing `%`");
    if (_ === "%" && S !== "%")
      throw new a("invalid intrinsic syntax, expected opening `%`");
    var E = [];
    return fe(B, f, function(m, A, $, X) {
      E[E.length] = $ ? fe(X, y, "$1") : A || m;
    }), E;
  }, M = function(B, S) {
    var _ = B, E;
    if (le(ee, _) && (E = ee[_], _ = "%" + E[0] + "%"), le(U, _)) {
      var m = U[_];
      if (m === N && (m = z(_)), typeof m > "u" && !S)
        throw new p("intrinsic " + B + " exists, but is not available. Please file an issue!");
      return {
        alias: E,
        name: _,
        value: m
      };
    }
    throw new a("intrinsic " + B + " does not exist!");
  };
  return getIntrinsic = function(B, S) {
    if (typeof B != "string" || B.length === 0)
      throw new p("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof S != "boolean")
      throw new p('"allowMissing" argument must be a boolean');
    if (P(/^%?[^%]*%?$/, B) === null)
      throw new a("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var _ = v(B), E = _.length > 0 ? _[0] : "", m = M("%" + E + "%", S), A = m.name, $ = m.value, X = !1, oe = m.alias;
    oe && (E = oe[0], ie(_, Z([0, 1], oe)));
    for (var J = 1, W = !0; J < _.length; J += 1) {
      var Q = _[J], me = I(Q, 0, 1), be = I(Q, -1);
      if ((me === '"' || me === "'" || me === "`" || be === '"' || be === "'" || be === "`") && me !== be)
        throw new a("property names with quotes must have matching quotes");
      if ((Q === "constructor" || !W) && (X = !0), E += "." + Q, A = "%" + E + "%", le(U, A))
        $ = U[A];
      else if ($ != null) {
        if (!(Q in $)) {
          if (!S)
            throw new p("base intrinsic for " + B + " exists, but the property is not available.");
          return;
        }
        if (w && J + 1 >= _.length) {
          var Y = w($, Q);
          W = !!Y, W && "get" in Y && !("originalValue" in Y.get) ? $ = Y.get : $ = $[Q];
        } else
          W = le($, Q), $ = $[Q];
        W && !X && (U[A] = $);
      }
    }
    return $;
  }, getIntrinsic;
}
var callBind = { exports: {} }, esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty)
    return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var e = requireGetIntrinsic(), t = e("%Object.defineProperty%", !0) || !1;
  if (t)
    try {
      t({}, "a", { value: 1 });
    } catch {
      t = !1;
    }
  return esDefineProperty = t, esDefineProperty;
}
var gopd, hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd)
    return gopd;
  hasRequiredGopd = 1;
  var e = requireGetIntrinsic(), t = e("%Object.getOwnPropertyDescriptor%", !0);
  if (t)
    try {
      t([], "length");
    } catch {
      t = null;
    }
  return gopd = t, gopd;
}
var defineDataProperty, hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty)
    return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var e = requireEsDefineProperty(), t = requireSyntax(), o = requireType(), r = requireGopd();
  return defineDataProperty = function(h, a, p) {
    if (!h || typeof h != "object" && typeof h != "function")
      throw new o("`obj` must be an object or a function`");
    if (typeof a != "string" && typeof a != "symbol")
      throw new o("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new o("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new o("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new o("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new o("`loose`, if provided, must be a boolean");
    var d = arguments.length > 3 ? arguments[3] : null, b = arguments.length > 4 ? arguments[4] : null, g = arguments.length > 5 ? arguments[5] : null, w = arguments.length > 6 ? arguments[6] : !1, C = !!r && r(h, a);
    if (e)
      e(h, a, {
        configurable: g === null && C ? C.configurable : !g,
        enumerable: d === null && C ? C.enumerable : !d,
        value: p,
        writable: b === null && C ? C.writable : !b
      });
    else if (w || !d && !b && !g)
      h[a] = p;
    else
      throw new t("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, defineDataProperty;
}
var hasPropertyDescriptors_1, hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors)
    return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var e = requireEsDefineProperty(), t = function() {
    return !!e;
  };
  return t.hasArrayLengthDefineBug = function() {
    if (!e)
      return null;
    try {
      return e([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, hasPropertyDescriptors_1 = t, hasPropertyDescriptors_1;
}
var setFunctionLength, hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength)
    return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var e = requireGetIntrinsic(), t = requireDefineDataProperty(), o = requireHasPropertyDescriptors()(), r = requireGopd(), h = requireType(), a = e("%Math.floor%");
  return setFunctionLength = function(p, d) {
    if (typeof p != "function")
      throw new h("`fn` is not a function");
    if (typeof d != "number" || d < 0 || d > 4294967295 || a(d) !== d)
      throw new h("`length` must be a positive 32-bit integer");
    var b = arguments.length > 2 && !!arguments[2], g = !0, w = !0;
    if ("length" in p && r) {
      var C = r(p, "length");
      C && !C.configurable && (g = !1), C && !C.writable && (w = !1);
    }
    return (g || w || !b) && (o ? t(
      /** @type {Parameters<define>[0]} */
      p,
      "length",
      d,
      !0,
      !0
    ) : t(
      /** @type {Parameters<define>[0]} */
      p,
      "length",
      d
    )), p;
  }, setFunctionLength;
}
var hasRequiredCallBind;
function requireCallBind() {
  return hasRequiredCallBind || (hasRequiredCallBind = 1, function(e) {
    var t = requireFunctionBind(), o = requireGetIntrinsic(), r = requireSetFunctionLength(), h = requireType(), a = o("%Function.prototype.apply%"), p = o("%Function.prototype.call%"), d = o("%Reflect.apply%", !0) || t.call(p, a), b = requireEsDefineProperty(), g = o("%Math.max%");
    e.exports = function(C) {
      if (typeof C != "function")
        throw new h("a function is required");
      var T = d(t, p, arguments);
      return r(
        T,
        1 + g(0, C.length - (arguments.length - 1)),
        !0
      );
    };
    var w = function() {
      return d(t, a, arguments);
    };
    b ? b(e.exports, "apply", { value: w }) : e.exports.apply = w;
  }(callBind)), callBind.exports;
}
var callBound, hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound)
    return callBound;
  hasRequiredCallBound = 1;
  var e = requireGetIntrinsic(), t = requireCallBind(), o = t(e("String.prototype.indexOf"));
  return callBound = function(r, h) {
    var a = e(r, !!h);
    return typeof a == "function" && o(r, ".prototype.") > -1 ? t(a) : a;
  }, callBound;
}
var isArguments, hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments)
    return isArguments;
  hasRequiredIsArguments = 1;
  var e = requireShams()(), t = requireCallBound(), o = t("Object.prototype.toString"), r = function(p) {
    return e && p && typeof p == "object" && Symbol.toStringTag in p ? !1 : o(p) === "[object Arguments]";
  }, h = function(p) {
    return r(p) ? !0 : p !== null && typeof p == "object" && typeof p.length == "number" && p.length >= 0 && o(p) !== "[object Array]" && o(p.callee) === "[object Function]";
  }, a = function() {
    return r(arguments);
  }();
  return r.isLegacyArguments = h, isArguments = a ? r : h, isArguments;
}
var isGeneratorFunction, hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction)
    return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var e = Object.prototype.toString, t = Function.prototype.toString, o = /^\s*(?:function)?\*/, r = requireShams()(), h = Object.getPrototypeOf, a = function() {
    if (!r)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, p;
  return isGeneratorFunction = function(d) {
    if (typeof d != "function")
      return !1;
    if (o.test(t.call(d)))
      return !0;
    if (!r) {
      var b = e.call(d);
      return b === "[object GeneratorFunction]";
    }
    if (!h)
      return !1;
    if (typeof p > "u") {
      var g = a();
      p = g ? h(g) : !1;
    }
    return h(d) === p;
  }, isGeneratorFunction;
}
var isCallable, hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable)
    return isCallable;
  hasRequiredIsCallable = 1;
  var e = Function.prototype.toString, t = typeof Reflect == "object" && Reflect !== null && Reflect.apply, o, r;
  if (typeof t == "function" && typeof Object.defineProperty == "function")
    try {
      o = Object.defineProperty({}, "length", {
        get: function() {
          throw r;
        }
      }), r = {}, t(function() {
        throw 42;
      }, null, o);
    } catch (U) {
      U !== r && (t = null);
    }
  else
    t = null;
  var h = /^\s*class\b/, a = function(U) {
    try {
      var H = e.call(U);
      return h.test(H);
    } catch {
      return !1;
    }
  }, p = function(U) {
    try {
      return a(U) ? !1 : (e.call(U), !0);
    } catch {
      return !1;
    }
  }, d = Object.prototype.toString, b = "[object Object]", g = "[object Function]", w = "[object GeneratorFunction]", C = "[object HTMLAllCollection]", T = "[object HTML document.all class]", k = "[object HTMLCollection]", q = typeof Symbol == "function" && !!Symbol.toStringTag, O = !(0 in [,]), N = function() {
    return !1;
  };
  if (typeof document == "object") {
    var j = document.all;
    d.call(j) === d.call(document.all) && (N = function(U) {
      if ((O || !U) && (typeof U > "u" || typeof U == "object"))
        try {
          var H = d.call(U);
          return (H === C || H === T || H === k || H === b) && U("") == null;
        } catch {
        }
      return !1;
    });
  }
  return isCallable = t ? function(U) {
    if (N(U))
      return !0;
    if (!U || typeof U != "function" && typeof U != "object")
      return !1;
    try {
      t(U, null, o);
    } catch (H) {
      if (H !== r)
        return !1;
    }
    return !a(U) && p(U);
  } : function(U) {
    if (N(U))
      return !0;
    if (!U || typeof U != "function" && typeof U != "object")
      return !1;
    if (q)
      return p(U);
    if (a(U))
      return !1;
    var H = d.call(U);
    return H !== g && H !== w && !/^\[object HTML/.test(H) ? !1 : p(U);
  }, isCallable;
}
var forEach_1, hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach)
    return forEach_1;
  hasRequiredForEach = 1;
  var e = requireIsCallable(), t = Object.prototype.toString, o = Object.prototype.hasOwnProperty, r = function(d, b, g) {
    for (var w = 0, C = d.length; w < C; w++)
      o.call(d, w) && (g == null ? b(d[w], w, d) : b.call(g, d[w], w, d));
  }, h = function(d, b, g) {
    for (var w = 0, C = d.length; w < C; w++)
      g == null ? b(d.charAt(w), w, d) : b.call(g, d.charAt(w), w, d);
  }, a = function(d, b, g) {
    for (var w in d)
      o.call(d, w) && (g == null ? b(d[w], w, d) : b.call(g, d[w], w, d));
  }, p = function(d, b, g) {
    if (!e(b))
      throw new TypeError("iterator must be a function");
    var w;
    arguments.length >= 3 && (w = g), t.call(d) === "[object Array]" ? r(d, b, w) : typeof d == "string" ? h(d, b, w) : a(d, b, w);
  };
  return forEach_1 = p, forEach_1;
}
var possibleTypedArrayNames, hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
  return hasRequiredPossibleTypedArrayNames || (hasRequiredPossibleTypedArrayNames = 1, possibleTypedArrayNames = [
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), possibleTypedArrayNames;
}
var availableTypedArrays, hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays)
    return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var e = requirePossibleTypedArrayNames(), t = typeof globalThis > "u" ? commonjsGlobal : globalThis;
  return availableTypedArrays = function() {
    for (var o = [], r = 0; r < e.length; r++)
      typeof t[e[r]] == "function" && (o[o.length] = e[r]);
    return o;
  }, availableTypedArrays;
}
var whichTypedArray, hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray)
    return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var e = requireForEach(), t = requireAvailableTypedArrays(), o = requireCallBind(), r = requireCallBound(), h = requireGopd(), a = r("Object.prototype.toString"), p = requireShams()(), d = typeof globalThis > "u" ? commonjsGlobal : globalThis, b = t(), g = r("String.prototype.slice"), w = Object.getPrototypeOf, C = r("Array.prototype.indexOf", !0) || function(O, N) {
    for (var j = 0; j < O.length; j += 1)
      if (O[j] === N)
        return j;
    return -1;
  }, T = { __proto__: null };
  p && h && w ? e(b, function(O) {
    var N = new d[O]();
    if (Symbol.toStringTag in N) {
      var j = w(N), U = h(j, Symbol.toStringTag);
      if (!U) {
        var H = w(j);
        U = h(H, Symbol.toStringTag);
      }
      T["$" + O] = o(U.get);
    }
  }) : e(b, function(O) {
    var N = new d[O](), j = N.slice || N.set;
    j && (T["$" + O] = o(j));
  });
  var k = function(O) {
    var N = !1;
    return e(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      T,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(j, U) {
        if (!N)
          try {
            "$" + j(O) === U && (N = g(U, 1));
          } catch {
          }
      }
    ), N;
  }, q = function(O) {
    var N = !1;
    return e(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      T,
      /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
      function(j, U) {
        if (!N)
          try {
            j(O), N = g(U, 1);
          } catch {
          }
      }
    ), N;
  };
  return whichTypedArray = function(O) {
    if (!O || typeof O != "object")
      return !1;
    if (!p) {
      var N = g(a(O), 8, -1);
      return C(b, N) > -1 ? N : N !== "Object" ? !1 : q(O);
    }
    return h ? k(O) : null;
  }, whichTypedArray;
}
var isTypedArray, hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray)
    return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var e = requireWhichTypedArray();
  return isTypedArray = function(t) {
    return !!e(t);
  }, isTypedArray;
}
var hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(e) {
    var t = requireIsArguments(), o = requireIsGeneratorFunction(), r = requireWhichTypedArray(), h = requireIsTypedArray();
    function a(F) {
      return F.call.bind(F);
    }
    var p = typeof BigInt < "u", d = typeof Symbol < "u", b = a(Object.prototype.toString), g = a(Number.prototype.valueOf), w = a(String.prototype.valueOf), C = a(Boolean.prototype.valueOf);
    if (p)
      var T = a(BigInt.prototype.valueOf);
    if (d)
      var k = a(Symbol.prototype.valueOf);
    function q(F, ue) {
      if (typeof F != "object")
        return !1;
      try {
        return ue(F), !0;
      } catch {
        return !1;
      }
    }
    e.isArgumentsObject = t, e.isGeneratorFunction = o, e.isTypedArray = h;
    function O(F) {
      return typeof Promise < "u" && F instanceof Promise || F !== null && typeof F == "object" && typeof F.then == "function" && typeof F.catch == "function";
    }
    e.isPromise = O;
    function N(F) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(F) : h(F) || $(F);
    }
    e.isArrayBufferView = N;
    function j(F) {
      return r(F) === "Uint8Array";
    }
    e.isUint8Array = j;
    function U(F) {
      return r(F) === "Uint8ClampedArray";
    }
    e.isUint8ClampedArray = U;
    function H(F) {
      return r(F) === "Uint16Array";
    }
    e.isUint16Array = H;
    function z(F) {
      return r(F) === "Uint32Array";
    }
    e.isUint32Array = z;
    function ee(F) {
      return r(F) === "Int8Array";
    }
    e.isInt8Array = ee;
    function ne(F) {
      return r(F) === "Int16Array";
    }
    e.isInt16Array = ne;
    function le(F) {
      return r(F) === "Int32Array";
    }
    e.isInt32Array = le;
    function Z(F) {
      return r(F) === "Float32Array";
    }
    e.isFloat32Array = Z;
    function ie(F) {
      return r(F) === "Float64Array";
    }
    e.isFloat64Array = ie;
    function fe(F) {
      return r(F) === "BigInt64Array";
    }
    e.isBigInt64Array = fe;
    function I(F) {
      return r(F) === "BigUint64Array";
    }
    e.isBigUint64Array = I;
    function P(F) {
      return b(F) === "[object Map]";
    }
    P.working = typeof Map < "u" && P(/* @__PURE__ */ new Map());
    function f(F) {
      return typeof Map > "u" ? !1 : P.working ? P(F) : F instanceof Map;
    }
    e.isMap = f;
    function y(F) {
      return b(F) === "[object Set]";
    }
    y.working = typeof Set < "u" && y(/* @__PURE__ */ new Set());
    function v(F) {
      return typeof Set > "u" ? !1 : y.working ? y(F) : F instanceof Set;
    }
    e.isSet = v;
    function M(F) {
      return b(F) === "[object WeakMap]";
    }
    M.working = typeof WeakMap < "u" && M(/* @__PURE__ */ new WeakMap());
    function B(F) {
      return typeof WeakMap > "u" ? !1 : M.working ? M(F) : F instanceof WeakMap;
    }
    e.isWeakMap = B;
    function S(F) {
      return b(F) === "[object WeakSet]";
    }
    S.working = typeof WeakSet < "u" && S(/* @__PURE__ */ new WeakSet());
    function _(F) {
      return S(F);
    }
    e.isWeakSet = _;
    function E(F) {
      return b(F) === "[object ArrayBuffer]";
    }
    E.working = typeof ArrayBuffer < "u" && E(new ArrayBuffer());
    function m(F) {
      return typeof ArrayBuffer > "u" ? !1 : E.working ? E(F) : F instanceof ArrayBuffer;
    }
    e.isArrayBuffer = m;
    function A(F) {
      return b(F) === "[object DataView]";
    }
    A.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && A(new DataView(new ArrayBuffer(1), 0, 1));
    function $(F) {
      return typeof DataView > "u" ? !1 : A.working ? A(F) : F instanceof DataView;
    }
    e.isDataView = $;
    var X = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function oe(F) {
      return b(F) === "[object SharedArrayBuffer]";
    }
    function J(F) {
      return typeof X > "u" ? !1 : (typeof oe.working > "u" && (oe.working = oe(new X())), oe.working ? oe(F) : F instanceof X);
    }
    e.isSharedArrayBuffer = J;
    function W(F) {
      return b(F) === "[object AsyncFunction]";
    }
    e.isAsyncFunction = W;
    function Q(F) {
      return b(F) === "[object Map Iterator]";
    }
    e.isMapIterator = Q;
    function me(F) {
      return b(F) === "[object Set Iterator]";
    }
    e.isSetIterator = me;
    function be(F) {
      return b(F) === "[object Generator]";
    }
    e.isGeneratorObject = be;
    function Y(F) {
      return b(F) === "[object WebAssembly.Module]";
    }
    e.isWebAssemblyCompiledModule = Y;
    function re(F) {
      return q(F, g);
    }
    e.isNumberObject = re;
    function de(F) {
      return q(F, w);
    }
    e.isStringObject = de;
    function Ae(F) {
      return q(F, C);
    }
    e.isBooleanObject = Ae;
    function qe(F) {
      return p && q(F, T);
    }
    e.isBigIntObject = qe;
    function x(F) {
      return d && q(F, k);
    }
    e.isSymbolObject = x;
    function L(F) {
      return re(F) || de(F) || Ae(F) || qe(F) || x(F);
    }
    e.isBoxedPrimitive = L;
    function D(F) {
      return typeof Uint8Array < "u" && (m(F) || J(F));
    }
    e.isAnyArrayBuffer = D, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(F) {
      Object.defineProperty(e, F, {
        enumerable: !1,
        value: function() {
          throw new Error(F + " is not supported in userland");
        }
      });
    });
  }(types)), types;
}
var isBufferBrowser, hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  return hasRequiredIsBufferBrowser || (hasRequiredIsBufferBrowser = 1, isBufferBrowser = function(e) {
    return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
  }), isBufferBrowser;
}
var hasRequiredUtil$1;
function requireUtil$1() {
  return hasRequiredUtil$1 || (hasRequiredUtil$1 = 1, function(e) {
    var t = Object.getOwnPropertyDescriptors || function(A) {
      for (var $ = Object.keys(A), X = {}, oe = 0; oe < $.length; oe++)
        X[$[oe]] = Object.getOwnPropertyDescriptor(A, $[oe]);
      return X;
    }, o = /%[sdj%]/g;
    e.format = function(A) {
      if (!ee(A)) {
        for (var $ = [], X = 0; X < arguments.length; X++)
          $.push(p(arguments[X]));
        return $.join(" ");
      }
      for (var X = 1, oe = arguments, J = oe.length, W = String(A).replace(o, function(be) {
        if (be === "%%")
          return "%";
        if (X >= J)
          return be;
        switch (be) {
          case "%s":
            return String(oe[X++]);
          case "%d":
            return Number(oe[X++]);
          case "%j":
            try {
              return JSON.stringify(oe[X++]);
            } catch {
              return "[Circular]";
            }
          default:
            return be;
        }
      }), Q = oe[X]; X < J; Q = oe[++X])
        U(Q) || !ie(Q) ? W += " " + Q : W += " " + p(Q);
      return W;
    }, e.deprecate = function(A, $) {
      if (typeof process$1 < "u" && process$1.noDeprecation === !0)
        return A;
      if (typeof process$1 > "u")
        return function() {
          return e.deprecate(A, $).apply(this, arguments);
        };
      var X = !1;
      function oe() {
        if (!X) {
          if (process$1.throwDeprecation)
            throw new Error($);
          process$1.traceDeprecation ? console.trace($) : console.error($), X = !0;
        }
        return A.apply(this, arguments);
      }
      return oe;
    };
    var r = {}, h = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var a = process$1.env.NODE_DEBUG;
      a = a.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), h = new RegExp("^" + a + "$", "i");
    }
    e.debuglog = function(A) {
      if (A = A.toUpperCase(), !r[A])
        if (h.test(A)) {
          var $ = process$1.pid;
          r[A] = function() {
            var X = e.format.apply(e, arguments);
            console.error("%s %d: %s", A, $, X);
          };
        } else
          r[A] = function() {
          };
      return r[A];
    };
    function p(A, $) {
      var X = {
        seen: [],
        stylize: b
      };
      return arguments.length >= 3 && (X.depth = arguments[2]), arguments.length >= 4 && (X.colors = arguments[3]), j($) ? X.showHidden = $ : $ && e._extend(X, $), le(X.showHidden) && (X.showHidden = !1), le(X.depth) && (X.depth = 2), le(X.colors) && (X.colors = !1), le(X.customInspect) && (X.customInspect = !0), X.colors && (X.stylize = d), w(X, A, X.depth);
    }
    e.inspect = p, p.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, p.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function d(A, $) {
      var X = p.styles[$];
      return X ? "\x1B[" + p.colors[X][0] + "m" + A + "\x1B[" + p.colors[X][1] + "m" : A;
    }
    function b(A, $) {
      return A;
    }
    function g(A) {
      var $ = {};
      return A.forEach(function(X, oe) {
        $[X] = !0;
      }), $;
    }
    function w(A, $, X) {
      if (A.customInspect && $ && P($.inspect) && // Filter out the util module, it's inspect function is special
      $.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
      !($.constructor && $.constructor.prototype === $)) {
        var oe = $.inspect(X, A);
        return ee(oe) || (oe = w(A, oe, X)), oe;
      }
      var J = C(A, $);
      if (J)
        return J;
      var W = Object.keys($), Q = g(W);
      if (A.showHidden && (W = Object.getOwnPropertyNames($)), I($) && (W.indexOf("message") >= 0 || W.indexOf("description") >= 0))
        return T($);
      if (W.length === 0) {
        if (P($)) {
          var me = $.name ? ": " + $.name : "";
          return A.stylize("[Function" + me + "]", "special");
        }
        if (Z($))
          return A.stylize(RegExp.prototype.toString.call($), "regexp");
        if (fe($))
          return A.stylize(Date.prototype.toString.call($), "date");
        if (I($))
          return T($);
      }
      var be = "", Y = !1, re = ["{", "}"];
      if (N($) && (Y = !0, re = ["[", "]"]), P($)) {
        var de = $.name ? ": " + $.name : "";
        be = " [Function" + de + "]";
      }
      if (Z($) && (be = " " + RegExp.prototype.toString.call($)), fe($) && (be = " " + Date.prototype.toUTCString.call($)), I($) && (be = " " + T($)), W.length === 0 && (!Y || $.length == 0))
        return re[0] + be + re[1];
      if (X < 0)
        return Z($) ? A.stylize(RegExp.prototype.toString.call($), "regexp") : A.stylize("[Object]", "special");
      A.seen.push($);
      var Ae;
      return Y ? Ae = k(A, $, X, Q, W) : Ae = W.map(function(qe) {
        return q(A, $, X, Q, qe, Y);
      }), A.seen.pop(), O(Ae, be, re);
    }
    function C(A, $) {
      if (le($))
        return A.stylize("undefined", "undefined");
      if (ee($)) {
        var X = "'" + JSON.stringify($).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return A.stylize(X, "string");
      }
      if (z($))
        return A.stylize("" + $, "number");
      if (j($))
        return A.stylize("" + $, "boolean");
      if (U($))
        return A.stylize("null", "null");
    }
    function T(A) {
      return "[" + Error.prototype.toString.call(A) + "]";
    }
    function k(A, $, X, oe, J) {
      for (var W = [], Q = 0, me = $.length; Q < me; ++Q)
        S($, String(Q)) ? W.push(q(
          A,
          $,
          X,
          oe,
          String(Q),
          !0
        )) : W.push("");
      return J.forEach(function(be) {
        be.match(/^\d+$/) || W.push(q(
          A,
          $,
          X,
          oe,
          be,
          !0
        ));
      }), W;
    }
    function q(A, $, X, oe, J, W) {
      var Q, me, be;
      if (be = Object.getOwnPropertyDescriptor($, J) || { value: $[J] }, be.get ? be.set ? me = A.stylize("[Getter/Setter]", "special") : me = A.stylize("[Getter]", "special") : be.set && (me = A.stylize("[Setter]", "special")), S(oe, J) || (Q = "[" + J + "]"), me || (A.seen.indexOf(be.value) < 0 ? (U(X) ? me = w(A, be.value, null) : me = w(A, be.value, X - 1), me.indexOf(`
`) > -1 && (W ? me = me.split(`
`).map(function(Y) {
        return "  " + Y;
      }).join(`
`).slice(2) : me = `
` + me.split(`
`).map(function(Y) {
        return "   " + Y;
      }).join(`
`))) : me = A.stylize("[Circular]", "special")), le(Q)) {
        if (W && J.match(/^\d+$/))
          return me;
        Q = JSON.stringify("" + J), Q.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Q = Q.slice(1, -1), Q = A.stylize(Q, "name")) : (Q = Q.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Q = A.stylize(Q, "string"));
      }
      return Q + ": " + me;
    }
    function O(A, $, X) {
      var oe = A.reduce(function(J, W) {
        return W.indexOf(`
`) >= 0, J + W.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return oe > 60 ? X[0] + ($ === "" ? "" : $ + `
 `) + " " + A.join(`,
  `) + " " + X[1] : X[0] + $ + " " + A.join(", ") + " " + X[1];
    }
    e.types = requireTypes();
    function N(A) {
      return Array.isArray(A);
    }
    e.isArray = N;
    function j(A) {
      return typeof A == "boolean";
    }
    e.isBoolean = j;
    function U(A) {
      return A === null;
    }
    e.isNull = U;
    function H(A) {
      return A == null;
    }
    e.isNullOrUndefined = H;
    function z(A) {
      return typeof A == "number";
    }
    e.isNumber = z;
    function ee(A) {
      return typeof A == "string";
    }
    e.isString = ee;
    function ne(A) {
      return typeof A == "symbol";
    }
    e.isSymbol = ne;
    function le(A) {
      return A === void 0;
    }
    e.isUndefined = le;
    function Z(A) {
      return ie(A) && y(A) === "[object RegExp]";
    }
    e.isRegExp = Z, e.types.isRegExp = Z;
    function ie(A) {
      return typeof A == "object" && A !== null;
    }
    e.isObject = ie;
    function fe(A) {
      return ie(A) && y(A) === "[object Date]";
    }
    e.isDate = fe, e.types.isDate = fe;
    function I(A) {
      return ie(A) && (y(A) === "[object Error]" || A instanceof Error);
    }
    e.isError = I, e.types.isNativeError = I;
    function P(A) {
      return typeof A == "function";
    }
    e.isFunction = P;
    function f(A) {
      return A === null || typeof A == "boolean" || typeof A == "number" || typeof A == "string" || typeof A == "symbol" || // ES6 symbol
      typeof A > "u";
    }
    e.isPrimitive = f, e.isBuffer = requireIsBufferBrowser();
    function y(A) {
      return Object.prototype.toString.call(A);
    }
    function v(A) {
      return A < 10 ? "0" + A.toString(10) : A.toString(10);
    }
    var M = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function B() {
      var A = /* @__PURE__ */ new Date(), $ = [
        v(A.getHours()),
        v(A.getMinutes()),
        v(A.getSeconds())
      ].join(":");
      return [A.getDate(), M[A.getMonth()], $].join(" ");
    }
    e.log = function() {
      console.log("%s - %s", B(), e.format.apply(e, arguments));
    }, e.inherits = requireInherits_browser(), e._extend = function(A, $) {
      if (!$ || !ie($))
        return A;
      for (var X = Object.keys($), oe = X.length; oe--; )
        A[X[oe]] = $[X[oe]];
      return A;
    };
    function S(A, $) {
      return Object.prototype.hasOwnProperty.call(A, $);
    }
    var _ = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    e.promisify = function(A) {
      if (typeof A != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if (_ && A[_]) {
        var $ = A[_];
        if (typeof $ != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty($, _, {
          value: $,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), $;
      }
      function $() {
        for (var X, oe, J = new Promise(function(me, be) {
          X = me, oe = be;
        }), W = [], Q = 0; Q < arguments.length; Q++)
          W.push(arguments[Q]);
        W.push(function(me, be) {
          me ? oe(me) : X(be);
        });
        try {
          A.apply(this, W);
        } catch (me) {
          oe(me);
        }
        return J;
      }
      return Object.setPrototypeOf($, Object.getPrototypeOf(A)), _ && Object.defineProperty($, _, {
        value: $,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        $,
        t(A)
      );
    }, e.promisify.custom = _;
    function E(A, $) {
      if (!A) {
        var X = new Error("Promise was rejected with a falsy value");
        X.reason = A, A = X;
      }
      return $(A);
    }
    function m(A) {
      if (typeof A != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function $() {
        for (var X = [], oe = 0; oe < arguments.length; oe++)
          X.push(arguments[oe]);
        var J = X.pop();
        if (typeof J != "function")
          throw new TypeError("The last argument must be of type Function");
        var W = this, Q = function() {
          return J.apply(W, arguments);
        };
        A.apply(this, X).then(
          function(me) {
            process$1.nextTick(Q.bind(null, null, me));
          },
          function(me) {
            process$1.nextTick(E.bind(null, me, Q));
          }
        );
      }
      return Object.setPrototypeOf($, Object.getPrototypeOf(A)), Object.defineProperties(
        $,
        t(A)
      ), $;
    }
    e.callbackify = m;
  }(util$1)), util$1;
}
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list)
    return buffer_list;
  hasRequiredBuffer_list = 1;
  function e(q, O) {
    var N = Object.keys(q);
    if (Object.getOwnPropertySymbols) {
      var j = Object.getOwnPropertySymbols(q);
      O && (j = j.filter(function(U) {
        return Object.getOwnPropertyDescriptor(q, U).enumerable;
      })), N.push.apply(N, j);
    }
    return N;
  }
  function t(q) {
    for (var O = 1; O < arguments.length; O++) {
      var N = arguments[O] != null ? arguments[O] : {};
      O % 2 ? e(Object(N), !0).forEach(function(j) {
        o(q, j, N[j]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(q, Object.getOwnPropertyDescriptors(N)) : e(Object(N)).forEach(function(j) {
        Object.defineProperty(q, j, Object.getOwnPropertyDescriptor(N, j));
      });
    }
    return q;
  }
  function o(q, O, N) {
    return O = p(O), O in q ? Object.defineProperty(q, O, { value: N, enumerable: !0, configurable: !0, writable: !0 }) : q[O] = N, q;
  }
  function r(q, O) {
    if (!(q instanceof O))
      throw new TypeError("Cannot call a class as a function");
  }
  function h(q, O) {
    for (var N = 0; N < O.length; N++) {
      var j = O[N];
      j.enumerable = j.enumerable || !1, j.configurable = !0, "value" in j && (j.writable = !0), Object.defineProperty(q, p(j.key), j);
    }
  }
  function a(q, O, N) {
    return O && h(q.prototype, O), N && h(q, N), Object.defineProperty(q, "prototype", { writable: !1 }), q;
  }
  function p(q) {
    var O = d(q, "string");
    return typeof O == "symbol" ? O : String(O);
  }
  function d(q, O) {
    if (typeof q != "object" || q === null)
      return q;
    var N = q[Symbol.toPrimitive];
    if (N !== void 0) {
      var j = N.call(q, O || "default");
      if (typeof j != "object")
        return j;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (O === "string" ? String : Number)(q);
  }
  var b = requireBuffer$1(), g = b.Buffer, w = requireUtil$1(), C = w.inspect, T = C && C.custom || "inspect";
  function k(q, O, N) {
    g.prototype.copy.call(q, O, N);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function q() {
      r(this, q), this.head = null, this.tail = null, this.length = 0;
    }
    return a(q, [{
      key: "push",
      value: function(O) {
        var N = {
          data: O,
          next: null
        };
        this.length > 0 ? this.tail.next = N : this.head = N, this.tail = N, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(O) {
        var N = {
          data: O,
          next: this.head
        };
        this.length === 0 && (this.tail = N), this.head = N, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var O = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, O;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(O) {
        if (this.length === 0)
          return "";
        for (var N = this.head, j = "" + N.data; N = N.next; )
          j += O + N.data;
        return j;
      }
    }, {
      key: "concat",
      value: function(O) {
        if (this.length === 0)
          return g.alloc(0);
        for (var N = g.allocUnsafe(O >>> 0), j = this.head, U = 0; j; )
          k(j.data, N, U), U += j.data.length, j = j.next;
        return N;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(O, N) {
        var j;
        return O < this.head.data.length ? (j = this.head.data.slice(0, O), this.head.data = this.head.data.slice(O)) : O === this.head.data.length ? j = this.shift() : j = N ? this._getString(O) : this._getBuffer(O), j;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(O) {
        var N = this.head, j = 1, U = N.data;
        for (O -= U.length; N = N.next; ) {
          var H = N.data, z = O > H.length ? H.length : O;
          if (z === H.length ? U += H : U += H.slice(0, O), O -= z, O === 0) {
            z === H.length ? (++j, N.next ? this.head = N.next : this.head = this.tail = null) : (this.head = N, N.data = H.slice(z));
            break;
          }
          ++j;
        }
        return this.length -= j, U;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(O) {
        var N = g.allocUnsafe(O), j = this.head, U = 1;
        for (j.data.copy(N), O -= j.data.length; j = j.next; ) {
          var H = j.data, z = O > H.length ? H.length : O;
          if (H.copy(N, N.length - O, 0, z), O -= z, O === 0) {
            z === H.length ? (++U, j.next ? this.head = j.next : this.head = this.tail = null) : (this.head = j, j.data = H.slice(z));
            break;
          }
          ++U;
        }
        return this.length -= U, N;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: T,
      value: function(O, N) {
        return C(this, t(t({}, N), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), q;
  }(), buffer_list;
}
var destroy_1$1, hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1)
    return destroy_1$1;
  hasRequiredDestroy$1 = 1;
  function e(p, d) {
    var b = this, g = this._readableState && this._readableState.destroyed, w = this._writableState && this._writableState.destroyed;
    return g || w ? (d ? d(p) : p && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(h, this, p)) : process$1.nextTick(h, this, p)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(p || null, function(C) {
      !d && C ? b._writableState ? b._writableState.errorEmitted ? process$1.nextTick(o, b) : (b._writableState.errorEmitted = !0, process$1.nextTick(t, b, C)) : process$1.nextTick(t, b, C) : d ? (process$1.nextTick(o, b), d(C)) : process$1.nextTick(o, b);
    }), this);
  }
  function t(p, d) {
    h(p, d), o(p);
  }
  function o(p) {
    p._writableState && !p._writableState.emitClose || p._readableState && !p._readableState.emitClose || p.emit("close");
  }
  function r() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function h(p, d) {
    p.emit("error", d);
  }
  function a(p, d) {
    var b = p._readableState, g = p._writableState;
    b && b.autoDestroy || g && g.autoDestroy ? p.destroy(d) : p.emit("error", d);
  }
  return destroy_1$1 = {
    destroy: e,
    undestroy: r,
    errorOrDestroy: a
  }, destroy_1$1;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser)
    return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function e(d, b) {
    d.prototype = Object.create(b.prototype), d.prototype.constructor = d, d.__proto__ = b;
  }
  var t = {};
  function o(d, b, g) {
    g || (g = Error);
    function w(T, k, q) {
      return typeof b == "string" ? b : b(T, k, q);
    }
    var C = /* @__PURE__ */ function(T) {
      e(k, T);
      function k(q, O, N) {
        return T.call(this, w(q, O, N)) || this;
      }
      return k;
    }(g);
    C.prototype.name = g.name, C.prototype.code = d, t[d] = C;
  }
  function r(d, b) {
    if (Array.isArray(d)) {
      var g = d.length;
      return d = d.map(function(w) {
        return String(w);
      }), g > 2 ? "one of ".concat(b, " ").concat(d.slice(0, g - 1).join(", "), ", or ") + d[g - 1] : g === 2 ? "one of ".concat(b, " ").concat(d[0], " or ").concat(d[1]) : "of ".concat(b, " ").concat(d[0]);
    } else
      return "of ".concat(b, " ").concat(String(d));
  }
  function h(d, b, g) {
    return d.substr(!g || g < 0 ? 0 : +g, b.length) === b;
  }
  function a(d, b, g) {
    return (g === void 0 || g > d.length) && (g = d.length), d.substring(g - b.length, g) === b;
  }
  function p(d, b, g) {
    return typeof g != "number" && (g = 0), g + b.length > d.length ? !1 : d.indexOf(b, g) !== -1;
  }
  return o("ERR_INVALID_OPT_VALUE", function(d, b) {
    return 'The value "' + b + '" is invalid for option "' + d + '"';
  }, TypeError), o("ERR_INVALID_ARG_TYPE", function(d, b, g) {
    var w;
    typeof b == "string" && h(b, "not ") ? (w = "must not be", b = b.replace(/^not /, "")) : w = "must be";
    var C;
    if (a(d, " argument"))
      C = "The ".concat(d, " ").concat(w, " ").concat(r(b, "type"));
    else {
      var T = p(d, ".") ? "property" : "argument";
      C = 'The "'.concat(d, '" ').concat(T, " ").concat(w, " ").concat(r(b, "type"));
    }
    return C += ". Received type ".concat(typeof g), C;
  }, TypeError), o("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), o("ERR_METHOD_NOT_IMPLEMENTED", function(d) {
    return "The " + d + " method is not implemented";
  }), o("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), o("ERR_STREAM_DESTROYED", function(d) {
    return "Cannot call " + d + " after a stream was destroyed";
  }), o("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), o("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), o("ERR_STREAM_WRITE_AFTER_END", "write after end"), o("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), o("ERR_UNKNOWN_ENCODING", function(d) {
    return "Unknown encoding: " + d;
  }, TypeError), o("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = t, errorsBrowser;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState)
    return state;
  hasRequiredState = 1;
  var e = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function t(r, h, a) {
    return r.highWaterMark != null ? r.highWaterMark : h ? r[a] : null;
  }
  function o(r, h, a, p) {
    var d = t(h, p, a);
    if (d != null) {
      if (!(isFinite(d) && Math.floor(d) === d) || d < 0) {
        var b = p ? a : "highWaterMark";
        throw new e(b, d);
      }
      return Math.floor(d);
    }
    return r.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: o
  }, state;
}
var browser$a, hasRequiredBrowser$a;
function requireBrowser$a() {
  if (hasRequiredBrowser$a)
    return browser$a;
  hasRequiredBrowser$a = 1, browser$a = e;
  function e(o, r) {
    if (t("noDeprecation"))
      return o;
    var h = !1;
    function a() {
      if (!h) {
        if (t("throwDeprecation"))
          throw new Error(r);
        t("traceDeprecation") ? console.trace(r) : console.warn(r), h = !0;
      }
      return o.apply(this, arguments);
    }
    return a;
  }
  function t(o) {
    try {
      if (!commonjsGlobal.localStorage)
        return !1;
    } catch {
      return !1;
    }
    var r = commonjsGlobal.localStorage[o];
    return r == null ? !1 : String(r).toLowerCase() === "true";
  }
  return browser$a;
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1)
    return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = Z;
  function e(J) {
    var W = this;
    this.next = null, this.entry = null, this.finish = function() {
      oe(W, J);
    };
  }
  var t;
  Z.WritableState = ne;
  var o = {
    deprecate: requireBrowser$a()
  }, r = requireStreamBrowser$1(), h = requireBuffer$1().Buffer, a = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function p(J) {
    return h.from(J);
  }
  function d(J) {
    return h.isBuffer(J) || J instanceof a;
  }
  var b = requireDestroy$1(), g = requireState(), w = g.getHighWaterMark, C = requireErrorsBrowser().codes, T = C.ERR_INVALID_ARG_TYPE, k = C.ERR_METHOD_NOT_IMPLEMENTED, q = C.ERR_MULTIPLE_CALLBACK, O = C.ERR_STREAM_CANNOT_PIPE, N = C.ERR_STREAM_DESTROYED, j = C.ERR_STREAM_NULL_VALUES, U = C.ERR_STREAM_WRITE_AFTER_END, H = C.ERR_UNKNOWN_ENCODING, z = b.errorOrDestroy;
  requireInherits_browser()(Z, r);
  function ee() {
  }
  function ne(J, W, Q) {
    t = t || require_stream_duplex$1(), J = J || {}, typeof Q != "boolean" && (Q = W instanceof t), this.objectMode = !!J.objectMode, Q && (this.objectMode = this.objectMode || !!J.writableObjectMode), this.highWaterMark = w(this, J, "writableHighWaterMark", Q), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var me = J.decodeStrings === !1;
    this.decodeStrings = !me, this.defaultEncoding = J.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(be) {
      M(W, be);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = J.emitClose !== !1, this.autoDestroy = !!J.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  ne.prototype.getBuffer = function() {
    for (var J = this.bufferedRequest, W = []; J; )
      W.push(J), J = J.next;
    return W;
  }, function() {
    try {
      Object.defineProperty(ne.prototype, "buffer", {
        get: o.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var le;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (le = Function.prototype[Symbol.hasInstance], Object.defineProperty(Z, Symbol.hasInstance, {
    value: function(J) {
      return le.call(this, J) ? !0 : this !== Z ? !1 : J && J._writableState instanceof ne;
    }
  })) : le = function(J) {
    return J instanceof this;
  };
  function Z(J) {
    t = t || require_stream_duplex$1();
    var W = this instanceof t;
    if (!W && !le.call(Z, this))
      return new Z(J);
    this._writableState = new ne(J, this, W), this.writable = !0, J && (typeof J.write == "function" && (this._write = J.write), typeof J.writev == "function" && (this._writev = J.writev), typeof J.destroy == "function" && (this._destroy = J.destroy), typeof J.final == "function" && (this._final = J.final)), r.call(this);
  }
  Z.prototype.pipe = function() {
    z(this, new O());
  };
  function ie(J, W) {
    var Q = new U();
    z(J, Q), process$1.nextTick(W, Q);
  }
  function fe(J, W, Q, me) {
    var be;
    return Q === null ? be = new j() : typeof Q != "string" && !W.objectMode && (be = new T("chunk", ["string", "Buffer"], Q)), be ? (z(J, be), process$1.nextTick(me, be), !1) : !0;
  }
  Z.prototype.write = function(J, W, Q) {
    var me = this._writableState, be = !1, Y = !me.objectMode && d(J);
    return Y && !h.isBuffer(J) && (J = p(J)), typeof W == "function" && (Q = W, W = null), Y ? W = "buffer" : W || (W = me.defaultEncoding), typeof Q != "function" && (Q = ee), me.ending ? ie(this, Q) : (Y || fe(this, me, J, Q)) && (me.pendingcb++, be = P(this, me, Y, J, W, Q)), be;
  }, Z.prototype.cork = function() {
    this._writableState.corked++;
  }, Z.prototype.uncork = function() {
    var J = this._writableState;
    J.corked && (J.corked--, !J.writing && !J.corked && !J.bufferProcessing && J.bufferedRequest && _(this, J));
  }, Z.prototype.setDefaultEncoding = function(J) {
    if (typeof J == "string" && (J = J.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((J + "").toLowerCase()) > -1))
      throw new H(J);
    return this._writableState.defaultEncoding = J, this;
  }, Object.defineProperty(Z.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function I(J, W, Q) {
    return !J.objectMode && J.decodeStrings !== !1 && typeof W == "string" && (W = h.from(W, Q)), W;
  }
  Object.defineProperty(Z.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function P(J, W, Q, me, be, Y) {
    if (!Q) {
      var re = I(W, me, be);
      me !== re && (Q = !0, be = "buffer", me = re);
    }
    var de = W.objectMode ? 1 : me.length;
    W.length += de;
    var Ae = W.length < W.highWaterMark;
    if (Ae || (W.needDrain = !0), W.writing || W.corked) {
      var qe = W.lastBufferedRequest;
      W.lastBufferedRequest = {
        chunk: me,
        encoding: be,
        isBuf: Q,
        callback: Y,
        next: null
      }, qe ? qe.next = W.lastBufferedRequest : W.bufferedRequest = W.lastBufferedRequest, W.bufferedRequestCount += 1;
    } else
      f(J, W, !1, de, me, be, Y);
    return Ae;
  }
  function f(J, W, Q, me, be, Y, re) {
    W.writelen = me, W.writecb = re, W.writing = !0, W.sync = !0, W.destroyed ? W.onwrite(new N("write")) : Q ? J._writev(be, W.onwrite) : J._write(be, Y, W.onwrite), W.sync = !1;
  }
  function y(J, W, Q, me, be) {
    --W.pendingcb, Q ? (process$1.nextTick(be, me), process$1.nextTick($, J, W), J._writableState.errorEmitted = !0, z(J, me)) : (be(me), J._writableState.errorEmitted = !0, z(J, me), $(J, W));
  }
  function v(J) {
    J.writing = !1, J.writecb = null, J.length -= J.writelen, J.writelen = 0;
  }
  function M(J, W) {
    var Q = J._writableState, me = Q.sync, be = Q.writecb;
    if (typeof be != "function")
      throw new q();
    if (v(Q), W)
      y(J, Q, me, W, be);
    else {
      var Y = E(Q) || J.destroyed;
      !Y && !Q.corked && !Q.bufferProcessing && Q.bufferedRequest && _(J, Q), me ? process$1.nextTick(B, J, Q, Y, be) : B(J, Q, Y, be);
    }
  }
  function B(J, W, Q, me) {
    Q || S(J, W), W.pendingcb--, me(), $(J, W);
  }
  function S(J, W) {
    W.length === 0 && W.needDrain && (W.needDrain = !1, J.emit("drain"));
  }
  function _(J, W) {
    W.bufferProcessing = !0;
    var Q = W.bufferedRequest;
    if (J._writev && Q && Q.next) {
      var me = W.bufferedRequestCount, be = new Array(me), Y = W.corkedRequestsFree;
      Y.entry = Q;
      for (var re = 0, de = !0; Q; )
        be[re] = Q, Q.isBuf || (de = !1), Q = Q.next, re += 1;
      be.allBuffers = de, f(J, W, !0, W.length, be, "", Y.finish), W.pendingcb++, W.lastBufferedRequest = null, Y.next ? (W.corkedRequestsFree = Y.next, Y.next = null) : W.corkedRequestsFree = new e(W), W.bufferedRequestCount = 0;
    } else {
      for (; Q; ) {
        var Ae = Q.chunk, qe = Q.encoding, x = Q.callback, L = W.objectMode ? 1 : Ae.length;
        if (f(J, W, !1, L, Ae, qe, x), Q = Q.next, W.bufferedRequestCount--, W.writing)
          break;
      }
      Q === null && (W.lastBufferedRequest = null);
    }
    W.bufferedRequest = Q, W.bufferProcessing = !1;
  }
  Z.prototype._write = function(J, W, Q) {
    Q(new k("_write()"));
  }, Z.prototype._writev = null, Z.prototype.end = function(J, W, Q) {
    var me = this._writableState;
    return typeof J == "function" ? (Q = J, J = null, W = null) : typeof W == "function" && (Q = W, W = null), J != null && this.write(J, W), me.corked && (me.corked = 1, this.uncork()), me.ending || X(this, me, Q), this;
  }, Object.defineProperty(Z.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function E(J) {
    return J.ending && J.length === 0 && J.bufferedRequest === null && !J.finished && !J.writing;
  }
  function m(J, W) {
    J._final(function(Q) {
      W.pendingcb--, Q && z(J, Q), W.prefinished = !0, J.emit("prefinish"), $(J, W);
    });
  }
  function A(J, W) {
    !W.prefinished && !W.finalCalled && (typeof J._final == "function" && !W.destroyed ? (W.pendingcb++, W.finalCalled = !0, process$1.nextTick(m, J, W)) : (W.prefinished = !0, J.emit("prefinish")));
  }
  function $(J, W) {
    var Q = E(W);
    if (Q && (A(J, W), W.pendingcb === 0 && (W.finished = !0, J.emit("finish"), W.autoDestroy))) {
      var me = J._readableState;
      (!me || me.autoDestroy && me.endEmitted) && J.destroy();
    }
    return Q;
  }
  function X(J, W, Q) {
    W.ending = !0, $(J, W), Q && (W.finished ? process$1.nextTick(Q) : J.once("finish", Q)), W.ended = !0, J.writable = !1;
  }
  function oe(J, W, Q) {
    var me = J.entry;
    for (J.entry = null; me; ) {
      var be = me.callback;
      W.pendingcb--, be(Q), me = me.next;
    }
    W.corkedRequestsFree.next = J;
  }
  return Object.defineProperty(Z.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(J) {
      this._writableState && (this._writableState.destroyed = J);
    }
  }), Z.prototype.destroy = b.destroy, Z.prototype._undestroy = b.undestroy, Z.prototype._destroy = function(J, W) {
    W(J);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1)
    return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var e = Object.keys || function(g) {
    var w = [];
    for (var C in g)
      w.push(C);
    return w;
  };
  _stream_duplex$1 = p;
  var t = require_stream_readable$1(), o = require_stream_writable$1();
  requireInherits_browser()(p, t);
  for (var r = e(o.prototype), h = 0; h < r.length; h++) {
    var a = r[h];
    p.prototype[a] || (p.prototype[a] = o.prototype[a]);
  }
  function p(g) {
    if (!(this instanceof p))
      return new p(g);
    t.call(this, g), o.call(this, g), this.allowHalfOpen = !0, g && (g.readable === !1 && (this.readable = !1), g.writable === !1 && (this.writable = !1), g.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", d)));
  }
  Object.defineProperty(p.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(p.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(p.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function d() {
    this._writableState.ended || process$1.nextTick(b, this);
  }
  function b(g) {
    g.end();
  }
  return Object.defineProperty(p.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(g) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = g, this._writableState.destroyed = g);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder)
    return string_decoder;
  hasRequiredString_decoder = 1;
  var e = requireSafeBuffer$1().Buffer, t = e.isEncoding || function(j) {
    switch (j = "" + j, j && j.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function o(j) {
    if (!j)
      return "utf8";
    for (var U; ; )
      switch (j) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return j;
        default:
          if (U)
            return;
          j = ("" + j).toLowerCase(), U = !0;
      }
  }
  function r(j) {
    var U = o(j);
    if (typeof U != "string" && (e.isEncoding === t || !t(j)))
      throw new Error("Unknown encoding: " + j);
    return U || j;
  }
  string_decoder.StringDecoder = h;
  function h(j) {
    this.encoding = r(j);
    var U;
    switch (this.encoding) {
      case "utf16le":
        this.text = C, this.end = T, U = 4;
        break;
      case "utf8":
        this.fillLast = b, U = 4;
        break;
      case "base64":
        this.text = k, this.end = q, U = 3;
        break;
      default:
        this.write = O, this.end = N;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(U);
  }
  h.prototype.write = function(j) {
    if (j.length === 0)
      return "";
    var U, H;
    if (this.lastNeed) {
      if (U = this.fillLast(j), U === void 0)
        return "";
      H = this.lastNeed, this.lastNeed = 0;
    } else
      H = 0;
    return H < j.length ? U ? U + this.text(j, H) : this.text(j, H) : U || "";
  }, h.prototype.end = w, h.prototype.text = g, h.prototype.fillLast = function(j) {
    if (this.lastNeed <= j.length)
      return j.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    j.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, j.length), this.lastNeed -= j.length;
  };
  function a(j) {
    return j <= 127 ? 0 : j >> 5 === 6 ? 2 : j >> 4 === 14 ? 3 : j >> 3 === 30 ? 4 : j >> 6 === 2 ? -1 : -2;
  }
  function p(j, U, H) {
    var z = U.length - 1;
    if (z < H)
      return 0;
    var ee = a(U[z]);
    return ee >= 0 ? (ee > 0 && (j.lastNeed = ee - 1), ee) : --z < H || ee === -2 ? 0 : (ee = a(U[z]), ee >= 0 ? (ee > 0 && (j.lastNeed = ee - 2), ee) : --z < H || ee === -2 ? 0 : (ee = a(U[z]), ee >= 0 ? (ee > 0 && (ee === 2 ? ee = 0 : j.lastNeed = ee - 3), ee) : 0));
  }
  function d(j, U, H) {
    if ((U[0] & 192) !== 128)
      return j.lastNeed = 0, "�";
    if (j.lastNeed > 1 && U.length > 1) {
      if ((U[1] & 192) !== 128)
        return j.lastNeed = 1, "�";
      if (j.lastNeed > 2 && U.length > 2 && (U[2] & 192) !== 128)
        return j.lastNeed = 2, "�";
    }
  }
  function b(j) {
    var U = this.lastTotal - this.lastNeed, H = d(this, j);
    if (H !== void 0)
      return H;
    if (this.lastNeed <= j.length)
      return j.copy(this.lastChar, U, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    j.copy(this.lastChar, U, 0, j.length), this.lastNeed -= j.length;
  }
  function g(j, U) {
    var H = p(this, j, U);
    if (!this.lastNeed)
      return j.toString("utf8", U);
    this.lastTotal = H;
    var z = j.length - (H - this.lastNeed);
    return j.copy(this.lastChar, 0, z), j.toString("utf8", U, z);
  }
  function w(j) {
    var U = j && j.length ? this.write(j) : "";
    return this.lastNeed ? U + "�" : U;
  }
  function C(j, U) {
    if ((j.length - U) % 2 === 0) {
      var H = j.toString("utf16le", U);
      if (H) {
        var z = H.charCodeAt(H.length - 1);
        if (z >= 55296 && z <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = j[j.length - 2], this.lastChar[1] = j[j.length - 1], H.slice(0, -1);
      }
      return H;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = j[j.length - 1], j.toString("utf16le", U, j.length - 1);
  }
  function T(j) {
    var U = j && j.length ? this.write(j) : "";
    if (this.lastNeed) {
      var H = this.lastTotal - this.lastNeed;
      return U + this.lastChar.toString("utf16le", 0, H);
    }
    return U;
  }
  function k(j, U) {
    var H = (j.length - U) % 3;
    return H === 0 ? j.toString("base64", U) : (this.lastNeed = 3 - H, this.lastTotal = 3, H === 1 ? this.lastChar[0] = j[j.length - 1] : (this.lastChar[0] = j[j.length - 2], this.lastChar[1] = j[j.length - 1]), j.toString("base64", U, j.length - H));
  }
  function q(j) {
    var U = j && j.length ? this.write(j) : "";
    return this.lastNeed ? U + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : U;
  }
  function O(j) {
    return j.toString(this.encoding);
  }
  function N(j) {
    return j && j.length ? this.write(j) : "";
  }
  return string_decoder;
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream)
    return endOfStream;
  hasRequiredEndOfStream = 1;
  var e = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function t(a) {
    var p = !1;
    return function() {
      if (!p) {
        p = !0;
        for (var d = arguments.length, b = new Array(d), g = 0; g < d; g++)
          b[g] = arguments[g];
        a.apply(this, b);
      }
    };
  }
  function o() {
  }
  function r(a) {
    return a.setHeader && typeof a.abort == "function";
  }
  function h(a, p, d) {
    if (typeof p == "function")
      return h(a, null, p);
    p || (p = {}), d = t(d || o);
    var b = p.readable || p.readable !== !1 && a.readable, g = p.writable || p.writable !== !1 && a.writable, w = function() {
      a.writable || T();
    }, C = a._writableState && a._writableState.finished, T = function() {
      g = !1, C = !0, b || d.call(a);
    }, k = a._readableState && a._readableState.endEmitted, q = function() {
      b = !1, k = !0, g || d.call(a);
    }, O = function(U) {
      d.call(a, U);
    }, N = function() {
      var U;
      if (b && !k)
        return (!a._readableState || !a._readableState.ended) && (U = new e()), d.call(a, U);
      if (g && !C)
        return (!a._writableState || !a._writableState.ended) && (U = new e()), d.call(a, U);
    }, j = function() {
      a.req.on("finish", T);
    };
    return r(a) ? (a.on("complete", T), a.on("abort", N), a.req ? j() : a.on("request", j)) : g && !a._writableState && (a.on("end", w), a.on("close", w)), a.on("end", q), a.on("finish", T), p.error !== !1 && a.on("error", O), a.on("close", N), function() {
      a.removeListener("complete", T), a.removeListener("abort", N), a.removeListener("request", j), a.req && a.req.removeListener("finish", T), a.removeListener("end", w), a.removeListener("close", w), a.removeListener("finish", T), a.removeListener("end", q), a.removeListener("error", O), a.removeListener("close", N);
    };
  }
  return endOfStream = h, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator)
    return async_iterator;
  hasRequiredAsync_iterator = 1;
  var e;
  function t(H, z, ee) {
    return z = o(z), z in H ? Object.defineProperty(H, z, { value: ee, enumerable: !0, configurable: !0, writable: !0 }) : H[z] = ee, H;
  }
  function o(H) {
    var z = r(H, "string");
    return typeof z == "symbol" ? z : String(z);
  }
  function r(H, z) {
    if (typeof H != "object" || H === null)
      return H;
    var ee = H[Symbol.toPrimitive];
    if (ee !== void 0) {
      var ne = ee.call(H, z || "default");
      if (typeof ne != "object")
        return ne;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (z === "string" ? String : Number)(H);
  }
  var h = requireEndOfStream(), a = Symbol("lastResolve"), p = Symbol("lastReject"), d = Symbol("error"), b = Symbol("ended"), g = Symbol("lastPromise"), w = Symbol("handlePromise"), C = Symbol("stream");
  function T(H, z) {
    return {
      value: H,
      done: z
    };
  }
  function k(H) {
    var z = H[a];
    if (z !== null) {
      var ee = H[C].read();
      ee !== null && (H[g] = null, H[a] = null, H[p] = null, z(T(ee, !1)));
    }
  }
  function q(H) {
    process$1.nextTick(k, H);
  }
  function O(H, z) {
    return function(ee, ne) {
      H.then(function() {
        if (z[b]) {
          ee(T(void 0, !0));
          return;
        }
        z[w](ee, ne);
      }, ne);
    };
  }
  var N = Object.getPrototypeOf(function() {
  }), j = Object.setPrototypeOf((e = {
    get stream() {
      return this[C];
    },
    next: function() {
      var H = this, z = this[d];
      if (z !== null)
        return Promise.reject(z);
      if (this[b])
        return Promise.resolve(T(void 0, !0));
      if (this[C].destroyed)
        return new Promise(function(Z, ie) {
          process$1.nextTick(function() {
            H[d] ? ie(H[d]) : Z(T(void 0, !0));
          });
        });
      var ee = this[g], ne;
      if (ee)
        ne = new Promise(O(ee, this));
      else {
        var le = this[C].read();
        if (le !== null)
          return Promise.resolve(T(le, !1));
        ne = new Promise(this[w]);
      }
      return this[g] = ne, ne;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var H = this;
    return new Promise(function(z, ee) {
      H[C].destroy(null, function(ne) {
        if (ne) {
          ee(ne);
          return;
        }
        z(T(void 0, !0));
      });
    });
  }), e), N), U = function(H) {
    var z, ee = Object.create(j, (z = {}, t(z, C, {
      value: H,
      writable: !0
    }), t(z, a, {
      value: null,
      writable: !0
    }), t(z, p, {
      value: null,
      writable: !0
    }), t(z, d, {
      value: null,
      writable: !0
    }), t(z, b, {
      value: H._readableState.endEmitted,
      writable: !0
    }), t(z, w, {
      value: function(ne, le) {
        var Z = ee[C].read();
        Z ? (ee[g] = null, ee[a] = null, ee[p] = null, ne(T(Z, !1))) : (ee[a] = ne, ee[p] = le);
      },
      writable: !0
    }), z));
    return ee[g] = null, h(H, function(ne) {
      if (ne && ne.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var le = ee[p];
        le !== null && (ee[g] = null, ee[a] = null, ee[p] = null, le(ne)), ee[d] = ne;
        return;
      }
      var Z = ee[a];
      Z !== null && (ee[g] = null, ee[a] = null, ee[p] = null, Z(T(void 0, !0))), ee[b] = !0;
    }), H.on("readable", q.bind(null, ee)), ee;
  };
  return async_iterator = U, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1)
    return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = ie;
  var e;
  ie.ReadableState = Z, requireEvents().EventEmitter;
  var t = function(Y, re) {
    return Y.listeners(re).length;
  }, o = requireStreamBrowser$1(), r = requireBuffer$1().Buffer, h = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function a(Y) {
    return r.from(Y);
  }
  function p(Y) {
    return r.isBuffer(Y) || Y instanceof h;
  }
  var d = requireUtil$1(), b;
  d && d.debuglog ? b = d.debuglog("stream") : b = function() {
  };
  var g = requireBuffer_list(), w = requireDestroy$1(), C = requireState(), T = C.getHighWaterMark, k = requireErrorsBrowser().codes, q = k.ERR_INVALID_ARG_TYPE, O = k.ERR_STREAM_PUSH_AFTER_EOF, N = k.ERR_METHOD_NOT_IMPLEMENTED, j = k.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, U, H, z;
  requireInherits_browser()(ie, o);
  var ee = w.errorOrDestroy, ne = ["error", "close", "destroy", "pause", "resume"];
  function le(Y, re, de) {
    if (typeof Y.prependListener == "function")
      return Y.prependListener(re, de);
    !Y._events || !Y._events[re] ? Y.on(re, de) : Array.isArray(Y._events[re]) ? Y._events[re].unshift(de) : Y._events[re] = [de, Y._events[re]];
  }
  function Z(Y, re, de) {
    e = e || require_stream_duplex$1(), Y = Y || {}, typeof de != "boolean" && (de = re instanceof e), this.objectMode = !!Y.objectMode, de && (this.objectMode = this.objectMode || !!Y.readableObjectMode), this.highWaterMark = T(this, Y, "readableHighWaterMark", de), this.buffer = new g(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Y.emitClose !== !1, this.autoDestroy = !!Y.autoDestroy, this.destroyed = !1, this.defaultEncoding = Y.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Y.encoding && (U || (U = requireString_decoder().StringDecoder), this.decoder = new U(Y.encoding), this.encoding = Y.encoding);
  }
  function ie(Y) {
    if (e = e || require_stream_duplex$1(), !(this instanceof ie))
      return new ie(Y);
    var re = this instanceof e;
    this._readableState = new Z(Y, this, re), this.readable = !0, Y && (typeof Y.read == "function" && (this._read = Y.read), typeof Y.destroy == "function" && (this._destroy = Y.destroy)), o.call(this);
  }
  Object.defineProperty(ie.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Y) {
      this._readableState && (this._readableState.destroyed = Y);
    }
  }), ie.prototype.destroy = w.destroy, ie.prototype._undestroy = w.undestroy, ie.prototype._destroy = function(Y, re) {
    re(Y);
  }, ie.prototype.push = function(Y, re) {
    var de = this._readableState, Ae;
    return de.objectMode ? Ae = !0 : typeof Y == "string" && (re = re || de.defaultEncoding, re !== de.encoding && (Y = r.from(Y, re), re = ""), Ae = !0), fe(this, Y, re, !1, Ae);
  }, ie.prototype.unshift = function(Y) {
    return fe(this, Y, null, !0, !1);
  };
  function fe(Y, re, de, Ae, qe) {
    b("readableAddChunk", re);
    var x = Y._readableState;
    if (re === null)
      x.reading = !1, M(Y, x);
    else {
      var L;
      if (qe || (L = P(x, re)), L)
        ee(Y, L);
      else if (x.objectMode || re && re.length > 0)
        if (typeof re != "string" && !x.objectMode && Object.getPrototypeOf(re) !== r.prototype && (re = a(re)), Ae)
          x.endEmitted ? ee(Y, new j()) : I(Y, x, re, !0);
        else if (x.ended)
          ee(Y, new O());
        else {
          if (x.destroyed)
            return !1;
          x.reading = !1, x.decoder && !de ? (re = x.decoder.write(re), x.objectMode || re.length !== 0 ? I(Y, x, re, !1) : _(Y, x)) : I(Y, x, re, !1);
        }
      else
        Ae || (x.reading = !1, _(Y, x));
    }
    return !x.ended && (x.length < x.highWaterMark || x.length === 0);
  }
  function I(Y, re, de, Ae) {
    re.flowing && re.length === 0 && !re.sync ? (re.awaitDrain = 0, Y.emit("data", de)) : (re.length += re.objectMode ? 1 : de.length, Ae ? re.buffer.unshift(de) : re.buffer.push(de), re.needReadable && B(Y)), _(Y, re);
  }
  function P(Y, re) {
    var de;
    return !p(re) && typeof re != "string" && re !== void 0 && !Y.objectMode && (de = new q("chunk", ["string", "Buffer", "Uint8Array"], re)), de;
  }
  ie.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, ie.prototype.setEncoding = function(Y) {
    U || (U = requireString_decoder().StringDecoder);
    var re = new U(Y);
    this._readableState.decoder = re, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var de = this._readableState.buffer.head, Ae = ""; de !== null; )
      Ae += re.write(de.data), de = de.next;
    return this._readableState.buffer.clear(), Ae !== "" && this._readableState.buffer.push(Ae), this._readableState.length = Ae.length, this;
  };
  var f = 1073741824;
  function y(Y) {
    return Y >= f ? Y = f : (Y--, Y |= Y >>> 1, Y |= Y >>> 2, Y |= Y >>> 4, Y |= Y >>> 8, Y |= Y >>> 16, Y++), Y;
  }
  function v(Y, re) {
    return Y <= 0 || re.length === 0 && re.ended ? 0 : re.objectMode ? 1 : Y !== Y ? re.flowing && re.length ? re.buffer.head.data.length : re.length : (Y > re.highWaterMark && (re.highWaterMark = y(Y)), Y <= re.length ? Y : re.ended ? re.length : (re.needReadable = !0, 0));
  }
  ie.prototype.read = function(Y) {
    b("read", Y), Y = parseInt(Y, 10);
    var re = this._readableState, de = Y;
    if (Y !== 0 && (re.emittedReadable = !1), Y === 0 && re.needReadable && ((re.highWaterMark !== 0 ? re.length >= re.highWaterMark : re.length > 0) || re.ended))
      return b("read: emitReadable", re.length, re.ended), re.length === 0 && re.ended ? Q(this) : B(this), null;
    if (Y = v(Y, re), Y === 0 && re.ended)
      return re.length === 0 && Q(this), null;
    var Ae = re.needReadable;
    b("need readable", Ae), (re.length === 0 || re.length - Y < re.highWaterMark) && (Ae = !0, b("length less than watermark", Ae)), re.ended || re.reading ? (Ae = !1, b("reading or ended", Ae)) : Ae && (b("do read"), re.reading = !0, re.sync = !0, re.length === 0 && (re.needReadable = !0), this._read(re.highWaterMark), re.sync = !1, re.reading || (Y = v(de, re)));
    var qe;
    return Y > 0 ? qe = W(Y, re) : qe = null, qe === null ? (re.needReadable = re.length <= re.highWaterMark, Y = 0) : (re.length -= Y, re.awaitDrain = 0), re.length === 0 && (re.ended || (re.needReadable = !0), de !== Y && re.ended && Q(this)), qe !== null && this.emit("data", qe), qe;
  };
  function M(Y, re) {
    if (b("onEofChunk"), !re.ended) {
      if (re.decoder) {
        var de = re.decoder.end();
        de && de.length && (re.buffer.push(de), re.length += re.objectMode ? 1 : de.length);
      }
      re.ended = !0, re.sync ? B(Y) : (re.needReadable = !1, re.emittedReadable || (re.emittedReadable = !0, S(Y)));
    }
  }
  function B(Y) {
    var re = Y._readableState;
    b("emitReadable", re.needReadable, re.emittedReadable), re.needReadable = !1, re.emittedReadable || (b("emitReadable", re.flowing), re.emittedReadable = !0, process$1.nextTick(S, Y));
  }
  function S(Y) {
    var re = Y._readableState;
    b("emitReadable_", re.destroyed, re.length, re.ended), !re.destroyed && (re.length || re.ended) && (Y.emit("readable"), re.emittedReadable = !1), re.needReadable = !re.flowing && !re.ended && re.length <= re.highWaterMark, J(Y);
  }
  function _(Y, re) {
    re.readingMore || (re.readingMore = !0, process$1.nextTick(E, Y, re));
  }
  function E(Y, re) {
    for (; !re.reading && !re.ended && (re.length < re.highWaterMark || re.flowing && re.length === 0); ) {
      var de = re.length;
      if (b("maybeReadMore read 0"), Y.read(0), de === re.length)
        break;
    }
    re.readingMore = !1;
  }
  ie.prototype._read = function(Y) {
    ee(this, new N("_read()"));
  }, ie.prototype.pipe = function(Y, re) {
    var de = this, Ae = this._readableState;
    switch (Ae.pipesCount) {
      case 0:
        Ae.pipes = Y;
        break;
      case 1:
        Ae.pipes = [Ae.pipes, Y];
        break;
      default:
        Ae.pipes.push(Y);
        break;
    }
    Ae.pipesCount += 1, b("pipe count=%d opts=%j", Ae.pipesCount, re);
    var qe = (!re || re.end !== !1) && Y !== process$1.stdout && Y !== process$1.stderr, x = qe ? D : Ce;
    Ae.endEmitted ? process$1.nextTick(x) : de.once("end", x), Y.on("unpipe", L);
    function L(Le, Oe) {
      b("onunpipe"), Le === de && Oe && Oe.hasUnpiped === !1 && (Oe.hasUnpiped = !0, ge());
    }
    function D() {
      b("onend"), Y.end();
    }
    var F = m(de);
    Y.on("drain", F);
    var ue = !1;
    function ge() {
      b("cleanup"), Y.removeListener("close", Re), Y.removeListener("finish", ke), Y.removeListener("drain", F), Y.removeListener("error", ve), Y.removeListener("unpipe", L), de.removeListener("end", D), de.removeListener("end", Ce), de.removeListener("data", ce), ue = !0, Ae.awaitDrain && (!Y._writableState || Y._writableState.needDrain) && F();
    }
    de.on("data", ce);
    function ce(Le) {
      b("ondata");
      var Oe = Y.write(Le);
      b("dest.write", Oe), Oe === !1 && ((Ae.pipesCount === 1 && Ae.pipes === Y || Ae.pipesCount > 1 && be(Ae.pipes, Y) !== -1) && !ue && (b("false write response, pause", Ae.awaitDrain), Ae.awaitDrain++), de.pause());
    }
    function ve(Le) {
      b("onerror", Le), Ce(), Y.removeListener("error", ve), t(Y, "error") === 0 && ee(Y, Le);
    }
    le(Y, "error", ve);
    function Re() {
      Y.removeListener("finish", ke), Ce();
    }
    Y.once("close", Re);
    function ke() {
      b("onfinish"), Y.removeListener("close", Re), Ce();
    }
    Y.once("finish", ke);
    function Ce() {
      b("unpipe"), de.unpipe(Y);
    }
    return Y.emit("pipe", de), Ae.flowing || (b("pipe resume"), de.resume()), Y;
  };
  function m(Y) {
    return function() {
      var re = Y._readableState;
      b("pipeOnDrain", re.awaitDrain), re.awaitDrain && re.awaitDrain--, re.awaitDrain === 0 && t(Y, "data") && (re.flowing = !0, J(Y));
    };
  }
  ie.prototype.unpipe = function(Y) {
    var re = this._readableState, de = {
      hasUnpiped: !1
    };
    if (re.pipesCount === 0)
      return this;
    if (re.pipesCount === 1)
      return Y && Y !== re.pipes ? this : (Y || (Y = re.pipes), re.pipes = null, re.pipesCount = 0, re.flowing = !1, Y && Y.emit("unpipe", this, de), this);
    if (!Y) {
      var Ae = re.pipes, qe = re.pipesCount;
      re.pipes = null, re.pipesCount = 0, re.flowing = !1;
      for (var x = 0; x < qe; x++)
        Ae[x].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var L = be(re.pipes, Y);
    return L === -1 ? this : (re.pipes.splice(L, 1), re.pipesCount -= 1, re.pipesCount === 1 && (re.pipes = re.pipes[0]), Y.emit("unpipe", this, de), this);
  }, ie.prototype.on = function(Y, re) {
    var de = o.prototype.on.call(this, Y, re), Ae = this._readableState;
    return Y === "data" ? (Ae.readableListening = this.listenerCount("readable") > 0, Ae.flowing !== !1 && this.resume()) : Y === "readable" && !Ae.endEmitted && !Ae.readableListening && (Ae.readableListening = Ae.needReadable = !0, Ae.flowing = !1, Ae.emittedReadable = !1, b("on readable", Ae.length, Ae.reading), Ae.length ? B(this) : Ae.reading || process$1.nextTick($, this)), de;
  }, ie.prototype.addListener = ie.prototype.on, ie.prototype.removeListener = function(Y, re) {
    var de = o.prototype.removeListener.call(this, Y, re);
    return Y === "readable" && process$1.nextTick(A, this), de;
  }, ie.prototype.removeAllListeners = function(Y) {
    var re = o.prototype.removeAllListeners.apply(this, arguments);
    return (Y === "readable" || Y === void 0) && process$1.nextTick(A, this), re;
  };
  function A(Y) {
    var re = Y._readableState;
    re.readableListening = Y.listenerCount("readable") > 0, re.resumeScheduled && !re.paused ? re.flowing = !0 : Y.listenerCount("data") > 0 && Y.resume();
  }
  function $(Y) {
    b("readable nexttick read 0"), Y.read(0);
  }
  ie.prototype.resume = function() {
    var Y = this._readableState;
    return Y.flowing || (b("resume"), Y.flowing = !Y.readableListening, X(this, Y)), Y.paused = !1, this;
  };
  function X(Y, re) {
    re.resumeScheduled || (re.resumeScheduled = !0, process$1.nextTick(oe, Y, re));
  }
  function oe(Y, re) {
    b("resume", re.reading), re.reading || Y.read(0), re.resumeScheduled = !1, Y.emit("resume"), J(Y), re.flowing && !re.reading && Y.read(0);
  }
  ie.prototype.pause = function() {
    return b("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (b("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function J(Y) {
    var re = Y._readableState;
    for (b("flow", re.flowing); re.flowing && Y.read() !== null; )
      ;
  }
  ie.prototype.wrap = function(Y) {
    var re = this, de = this._readableState, Ae = !1;
    Y.on("end", function() {
      if (b("wrapped end"), de.decoder && !de.ended) {
        var L = de.decoder.end();
        L && L.length && re.push(L);
      }
      re.push(null);
    }), Y.on("data", function(L) {
      if (b("wrapped data"), de.decoder && (L = de.decoder.write(L)), !(de.objectMode && L == null) && !(!de.objectMode && (!L || !L.length))) {
        var D = re.push(L);
        D || (Ae = !0, Y.pause());
      }
    });
    for (var qe in Y)
      this[qe] === void 0 && typeof Y[qe] == "function" && (this[qe] = /* @__PURE__ */ function(L) {
        return function() {
          return Y[L].apply(Y, arguments);
        };
      }(qe));
    for (var x = 0; x < ne.length; x++)
      Y.on(ne[x], this.emit.bind(this, ne[x]));
    return this._read = function(L) {
      b("wrapped _read", L), Ae && (Ae = !1, Y.resume());
    }, this;
  }, typeof Symbol == "function" && (ie.prototype[Symbol.asyncIterator] = function() {
    return H === void 0 && (H = requireAsync_iterator()), H(this);
  }), Object.defineProperty(ie.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(ie.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(ie.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(Y) {
      this._readableState && (this._readableState.flowing = Y);
    }
  }), ie._fromList = W, Object.defineProperty(ie.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function W(Y, re) {
    if (re.length === 0)
      return null;
    var de;
    return re.objectMode ? de = re.buffer.shift() : !Y || Y >= re.length ? (re.decoder ? de = re.buffer.join("") : re.buffer.length === 1 ? de = re.buffer.first() : de = re.buffer.concat(re.length), re.buffer.clear()) : de = re.buffer.consume(Y, re.decoder), de;
  }
  function Q(Y) {
    var re = Y._readableState;
    b("endReadable", re.endEmitted), re.endEmitted || (re.ended = !0, process$1.nextTick(me, re, Y));
  }
  function me(Y, re) {
    if (b("endReadableNT", Y.endEmitted, Y.length), !Y.endEmitted && Y.length === 0 && (Y.endEmitted = !0, re.readable = !1, re.emit("end"), Y.autoDestroy)) {
      var de = re._writableState;
      (!de || de.autoDestroy && de.finished) && re.destroy();
    }
  }
  typeof Symbol == "function" && (ie.from = function(Y, re) {
    return z === void 0 && (z = requireFromBrowser()), z(ie, Y, re);
  });
  function be(Y, re) {
    for (var de = 0, Ae = Y.length; de < Ae; de++)
      if (Y[de] === re)
        return de;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform$1;
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1)
    return _stream_transform$1;
  hasRequired_stream_transform$1 = 1, _stream_transform$1 = d;
  var e = requireErrorsBrowser().codes, t = e.ERR_METHOD_NOT_IMPLEMENTED, o = e.ERR_MULTIPLE_CALLBACK, r = e.ERR_TRANSFORM_ALREADY_TRANSFORMING, h = e.ERR_TRANSFORM_WITH_LENGTH_0, a = require_stream_duplex$1();
  requireInherits_browser()(d, a);
  function p(w, C) {
    var T = this._transformState;
    T.transforming = !1;
    var k = T.writecb;
    if (k === null)
      return this.emit("error", new o());
    T.writechunk = null, T.writecb = null, C != null && this.push(C), k(w);
    var q = this._readableState;
    q.reading = !1, (q.needReadable || q.length < q.highWaterMark) && this._read(q.highWaterMark);
  }
  function d(w) {
    if (!(this instanceof d))
      return new d(w);
    a.call(this, w), this._transformState = {
      afterTransform: p.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, w && (typeof w.transform == "function" && (this._transform = w.transform), typeof w.flush == "function" && (this._flush = w.flush)), this.on("prefinish", b);
  }
  function b() {
    var w = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(C, T) {
      g(w, C, T);
    }) : g(this, null, null);
  }
  d.prototype.push = function(w, C) {
    return this._transformState.needTransform = !1, a.prototype.push.call(this, w, C);
  }, d.prototype._transform = function(w, C, T) {
    T(new t("_transform()"));
  }, d.prototype._write = function(w, C, T) {
    var k = this._transformState;
    if (k.writecb = T, k.writechunk = w, k.writeencoding = C, !k.transforming) {
      var q = this._readableState;
      (k.needTransform || q.needReadable || q.length < q.highWaterMark) && this._read(q.highWaterMark);
    }
  }, d.prototype._read = function(w) {
    var C = this._transformState;
    C.writechunk !== null && !C.transforming ? (C.transforming = !0, this._transform(C.writechunk, C.writeencoding, C.afterTransform)) : C.needTransform = !0;
  }, d.prototype._destroy = function(w, C) {
    a.prototype._destroy.call(this, w, function(T) {
      C(T);
    });
  };
  function g(w, C, T) {
    if (C)
      return w.emit("error", C);
    if (T != null && w.push(T), w._writableState.length)
      throw new h();
    if (w._transformState.transforming)
      throw new r();
    return w.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1)
    return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1, _stream_passthrough$1 = t;
  var e = require_stream_transform$1();
  requireInherits_browser()(t, e);
  function t(o) {
    if (!(this instanceof t))
      return new t(o);
    e.call(this, o);
  }
  return t.prototype._transform = function(o, r, h) {
    h(null, o);
  }, _stream_passthrough$1;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline)
    return pipeline_1;
  hasRequiredPipeline = 1;
  var e;
  function t(T) {
    var k = !1;
    return function() {
      k || (k = !0, T.apply(void 0, arguments));
    };
  }
  var o = requireErrorsBrowser().codes, r = o.ERR_MISSING_ARGS, h = o.ERR_STREAM_DESTROYED;
  function a(T) {
    if (T)
      throw T;
  }
  function p(T) {
    return T.setHeader && typeof T.abort == "function";
  }
  function d(T, k, q, O) {
    O = t(O);
    var N = !1;
    T.on("close", function() {
      N = !0;
    }), e === void 0 && (e = requireEndOfStream()), e(T, {
      readable: k,
      writable: q
    }, function(U) {
      if (U)
        return O(U);
      N = !0, O();
    });
    var j = !1;
    return function(U) {
      if (!N && !j) {
        if (j = !0, p(T))
          return T.abort();
        if (typeof T.destroy == "function")
          return T.destroy();
        O(U || new h("pipe"));
      }
    };
  }
  function b(T) {
    T();
  }
  function g(T, k) {
    return T.pipe(k);
  }
  function w(T) {
    return !T.length || typeof T[T.length - 1] != "function" ? a : T.pop();
  }
  function C() {
    for (var T = arguments.length, k = new Array(T), q = 0; q < T; q++)
      k[q] = arguments[q];
    var O = w(k);
    if (Array.isArray(k[0]) && (k = k[0]), k.length < 2)
      throw new r("streams");
    var N, j = k.map(function(U, H) {
      var z = H < k.length - 1, ee = H > 0;
      return d(U, z, ee, function(ne) {
        N || (N = ne), ne && j.forEach(b), !z && (j.forEach(b), O(N));
      });
    });
    return k.reduce(g);
  }
  return pipeline_1 = C, pipeline_1;
}
var hasRequiredReadableBrowser$1;
function requireReadableBrowser$1() {
  return hasRequiredReadableBrowser$1 || (hasRequiredReadableBrowser$1 = 1, function(e, t) {
    t = e.exports = require_stream_readable$1(), t.Stream = t, t.Readable = t, t.Writable = require_stream_writable$1(), t.Duplex = require_stream_duplex$1(), t.Transform = require_stream_transform$1(), t.PassThrough = require_stream_passthrough$1(), t.finished = requireEndOfStream(), t.pipeline = requirePipeline();
  }(readableBrowser$1, readableBrowser$1.exports)), readableBrowser$1.exports;
}
var hashBase$1, hasRequiredHashBase$1;
function requireHashBase$1() {
  if (hasRequiredHashBase$1)
    return hashBase$1;
  hasRequiredHashBase$1 = 1;
  var e = requireSafeBuffer$1().Buffer, t = requireReadableBrowser$1().Transform, o = requireInherits_browser();
  function r(a, p) {
    if (!e.isBuffer(a) && typeof a != "string")
      throw new TypeError(p + " must be a string or a buffer");
  }
  function h(a) {
    t.call(this), this._block = e.allocUnsafe(a), this._blockSize = a, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return o(h, t), h.prototype._transform = function(a, p, d) {
    var b = null;
    try {
      this.update(a, p);
    } catch (g) {
      b = g;
    }
    d(b);
  }, h.prototype._flush = function(a) {
    var p = null;
    try {
      this.push(this.digest());
    } catch (d) {
      p = d;
    }
    a(p);
  }, h.prototype.update = function(a, p) {
    if (r(a, "Data"), this._finalized)
      throw new Error("Digest already called");
    e.isBuffer(a) || (a = e.from(a, p));
    for (var d = this._block, b = 0; this._blockOffset + a.length - b >= this._blockSize; ) {
      for (var g = this._blockOffset; g < this._blockSize; )
        d[g++] = a[b++];
      this._update(), this._blockOffset = 0;
    }
    for (; b < a.length; )
      d[this._blockOffset++] = a[b++];
    for (var w = 0, C = a.length * 8; C > 0; ++w)
      this._length[w] += C, C = this._length[w] / 4294967296 | 0, C > 0 && (this._length[w] -= 4294967296 * C);
    return this;
  }, h.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, h.prototype.digest = function(a) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = !0;
    var p = this._digest();
    a !== void 0 && (p = p.toString(a)), this._block.fill(0), this._blockOffset = 0;
    for (var d = 0; d < 4; ++d)
      this._length[d] = 0;
    return p;
  }, h.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase$1 = h, hashBase$1;
}
var md5_js, hasRequiredMd5_js;
function requireMd5_js() {
  if (hasRequiredMd5_js)
    return md5_js;
  hasRequiredMd5_js = 1;
  var e = requireInherits_browser(), t = requireHashBase$1(), o = requireSafeBuffer$1().Buffer, r = new Array(16);
  function h() {
    t.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  e(h, t), h.prototype._update = function() {
    for (var w = r, C = 0; C < 16; ++C)
      w[C] = this._block.readInt32LE(C * 4);
    var T = this._a, k = this._b, q = this._c, O = this._d;
    T = p(T, k, q, O, w[0], 3614090360, 7), O = p(O, T, k, q, w[1], 3905402710, 12), q = p(q, O, T, k, w[2], 606105819, 17), k = p(k, q, O, T, w[3], 3250441966, 22), T = p(T, k, q, O, w[4], 4118548399, 7), O = p(O, T, k, q, w[5], 1200080426, 12), q = p(q, O, T, k, w[6], 2821735955, 17), k = p(k, q, O, T, w[7], 4249261313, 22), T = p(T, k, q, O, w[8], 1770035416, 7), O = p(O, T, k, q, w[9], 2336552879, 12), q = p(q, O, T, k, w[10], 4294925233, 17), k = p(k, q, O, T, w[11], 2304563134, 22), T = p(T, k, q, O, w[12], 1804603682, 7), O = p(O, T, k, q, w[13], 4254626195, 12), q = p(q, O, T, k, w[14], 2792965006, 17), k = p(k, q, O, T, w[15], 1236535329, 22), T = d(T, k, q, O, w[1], 4129170786, 5), O = d(O, T, k, q, w[6], 3225465664, 9), q = d(q, O, T, k, w[11], 643717713, 14), k = d(k, q, O, T, w[0], 3921069994, 20), T = d(T, k, q, O, w[5], 3593408605, 5), O = d(O, T, k, q, w[10], 38016083, 9), q = d(q, O, T, k, w[15], 3634488961, 14), k = d(k, q, O, T, w[4], 3889429448, 20), T = d(T, k, q, O, w[9], 568446438, 5), O = d(O, T, k, q, w[14], 3275163606, 9), q = d(q, O, T, k, w[3], 4107603335, 14), k = d(k, q, O, T, w[8], 1163531501, 20), T = d(T, k, q, O, w[13], 2850285829, 5), O = d(O, T, k, q, w[2], 4243563512, 9), q = d(q, O, T, k, w[7], 1735328473, 14), k = d(k, q, O, T, w[12], 2368359562, 20), T = b(T, k, q, O, w[5], 4294588738, 4), O = b(O, T, k, q, w[8], 2272392833, 11), q = b(q, O, T, k, w[11], 1839030562, 16), k = b(k, q, O, T, w[14], 4259657740, 23), T = b(T, k, q, O, w[1], 2763975236, 4), O = b(O, T, k, q, w[4], 1272893353, 11), q = b(q, O, T, k, w[7], 4139469664, 16), k = b(k, q, O, T, w[10], 3200236656, 23), T = b(T, k, q, O, w[13], 681279174, 4), O = b(O, T, k, q, w[0], 3936430074, 11), q = b(q, O, T, k, w[3], 3572445317, 16), k = b(k, q, O, T, w[6], 76029189, 23), T = b(T, k, q, O, w[9], 3654602809, 4), O = b(O, T, k, q, w[12], 3873151461, 11), q = b(q, O, T, k, w[15], 530742520, 16), k = b(k, q, O, T, w[2], 3299628645, 23), T = g(T, k, q, O, w[0], 4096336452, 6), O = g(O, T, k, q, w[7], 1126891415, 10), q = g(q, O, T, k, w[14], 2878612391, 15), k = g(k, q, O, T, w[5], 4237533241, 21), T = g(T, k, q, O, w[12], 1700485571, 6), O = g(O, T, k, q, w[3], 2399980690, 10), q = g(q, O, T, k, w[10], 4293915773, 15), k = g(k, q, O, T, w[1], 2240044497, 21), T = g(T, k, q, O, w[8], 1873313359, 6), O = g(O, T, k, q, w[15], 4264355552, 10), q = g(q, O, T, k, w[6], 2734768916, 15), k = g(k, q, O, T, w[13], 1309151649, 21), T = g(T, k, q, O, w[4], 4149444226, 6), O = g(O, T, k, q, w[11], 3174756917, 10), q = g(q, O, T, k, w[2], 718787259, 15), k = g(k, q, O, T, w[9], 3951481745, 21), this._a = this._a + T | 0, this._b = this._b + k | 0, this._c = this._c + q | 0, this._d = this._d + O | 0;
  }, h.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var w = o.allocUnsafe(16);
    return w.writeInt32LE(this._a, 0), w.writeInt32LE(this._b, 4), w.writeInt32LE(this._c, 8), w.writeInt32LE(this._d, 12), w;
  };
  function a(w, C) {
    return w << C | w >>> 32 - C;
  }
  function p(w, C, T, k, q, O, N) {
    return a(w + (C & T | ~C & k) + q + O | 0, N) + C | 0;
  }
  function d(w, C, T, k, q, O, N) {
    return a(w + (C & k | T & ~k) + q + O | 0, N) + C | 0;
  }
  function b(w, C, T, k, q, O, N) {
    return a(w + (C ^ T ^ k) + q + O | 0, N) + C | 0;
  }
  function g(w, C, T, k, q, O, N) {
    return a(w + (T ^ (C | ~k)) + q + O | 0, N) + C | 0;
  }
  return md5_js = h, md5_js;
}
var hashBase, hasRequiredHashBase;
function requireHashBase() {
  if (hasRequiredHashBase)
    return hashBase;
  hasRequiredHashBase = 1;
  var e = requireSafeBuffer$1().Buffer, t = requireReadableBrowser$1().Transform, o = requireInherits_browser();
  function r(a, p) {
    if (!e.isBuffer(a) && typeof a != "string")
      throw new TypeError(p + " must be a string or a buffer");
  }
  function h(a) {
    t.call(this), this._block = e.allocUnsafe(a), this._blockSize = a, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return o(h, t), h.prototype._transform = function(a, p, d) {
    var b = null;
    try {
      this.update(a, p);
    } catch (g) {
      b = g;
    }
    d(b);
  }, h.prototype._flush = function(a) {
    var p = null;
    try {
      this.push(this.digest());
    } catch (d) {
      p = d;
    }
    a(p);
  }, h.prototype.update = function(a, p) {
    if (r(a, "Data"), this._finalized)
      throw new Error("Digest already called");
    e.isBuffer(a) || (a = e.from(a, p));
    for (var d = this._block, b = 0; this._blockOffset + a.length - b >= this._blockSize; ) {
      for (var g = this._blockOffset; g < this._blockSize; )
        d[g++] = a[b++];
      this._update(), this._blockOffset = 0;
    }
    for (; b < a.length; )
      d[this._blockOffset++] = a[b++];
    for (var w = 0, C = a.length * 8; C > 0; ++w)
      this._length[w] += C, C = this._length[w] / 4294967296 | 0, C > 0 && (this._length[w] -= 4294967296 * C);
    return this;
  }, h.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, h.prototype.digest = function(a) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = !0;
    var p = this._digest();
    a !== void 0 && (p = p.toString(a)), this._block.fill(0), this._blockOffset = 0;
    for (var d = 0; d < 4; ++d)
      this._length[d] = 0;
    return p;
  }, h.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase = h, hashBase;
}
var ripemd160, hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160)
    return ripemd160;
  hasRequiredRipemd160 = 1;
  var e = requireBuffer$1().Buffer, t = requireInherits_browser(), o = requireHashBase(), r = new Array(16), h = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], a = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], p = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], d = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], b = [0, 1518500249, 1859775393, 2400959708, 2840853838], g = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function w() {
    o.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  t(w, o), w.prototype._update = function() {
    for (var j = r, U = 0; U < 16; ++U)
      j[U] = this._block.readInt32LE(U * 4);
    for (var H = this._a | 0, z = this._b | 0, ee = this._c | 0, ne = this._d | 0, le = this._e | 0, Z = this._a | 0, ie = this._b | 0, fe = this._c | 0, I = this._d | 0, P = this._e | 0, f = 0; f < 80; f += 1) {
      var y, v;
      f < 16 ? (y = T(H, z, ee, ne, le, j[h[f]], b[0], p[f]), v = N(Z, ie, fe, I, P, j[a[f]], g[0], d[f])) : f < 32 ? (y = k(H, z, ee, ne, le, j[h[f]], b[1], p[f]), v = O(Z, ie, fe, I, P, j[a[f]], g[1], d[f])) : f < 48 ? (y = q(H, z, ee, ne, le, j[h[f]], b[2], p[f]), v = q(Z, ie, fe, I, P, j[a[f]], g[2], d[f])) : f < 64 ? (y = O(H, z, ee, ne, le, j[h[f]], b[3], p[f]), v = k(Z, ie, fe, I, P, j[a[f]], g[3], d[f])) : (y = N(H, z, ee, ne, le, j[h[f]], b[4], p[f]), v = T(Z, ie, fe, I, P, j[a[f]], g[4], d[f])), H = le, le = ne, ne = C(ee, 10), ee = z, z = y, Z = P, P = I, I = C(fe, 10), fe = ie, ie = v;
    }
    var M = this._b + ee + I | 0;
    this._b = this._c + ne + P | 0, this._c = this._d + le + Z | 0, this._d = this._e + H + ie | 0, this._e = this._a + z + fe | 0, this._a = M;
  }, w.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var j = e.alloc ? e.alloc(20) : new e(20);
    return j.writeInt32LE(this._a, 0), j.writeInt32LE(this._b, 4), j.writeInt32LE(this._c, 8), j.writeInt32LE(this._d, 12), j.writeInt32LE(this._e, 16), j;
  };
  function C(j, U) {
    return j << U | j >>> 32 - U;
  }
  function T(j, U, H, z, ee, ne, le, Z) {
    return C(j + (U ^ H ^ z) + ne + le | 0, Z) + ee | 0;
  }
  function k(j, U, H, z, ee, ne, le, Z) {
    return C(j + (U & H | ~U & z) + ne + le | 0, Z) + ee | 0;
  }
  function q(j, U, H, z, ee, ne, le, Z) {
    return C(j + ((U | ~H) ^ z) + ne + le | 0, Z) + ee | 0;
  }
  function O(j, U, H, z, ee, ne, le, Z) {
    return C(j + (U & z | H & ~z) + ne + le | 0, Z) + ee | 0;
  }
  function N(j, U, H, z, ee, ne, le, Z) {
    return C(j + (U ^ (H | ~z)) + ne + le | 0, Z) + ee | 0;
  }
  return ripemd160 = w, ripemd160;
}
var sha_js = { exports: {} }, hash$1, hasRequiredHash$1;
function requireHash$1() {
  if (hasRequiredHash$1)
    return hash$1;
  hasRequiredHash$1 = 1;
  var e = requireSafeBuffer$1().Buffer;
  function t(o, r) {
    this._block = e.alloc(o), this._finalSize = r, this._blockSize = o, this._len = 0;
  }
  return t.prototype.update = function(o, r) {
    typeof o == "string" && (r = r || "utf8", o = e.from(o, r));
    for (var h = this._block, a = this._blockSize, p = o.length, d = this._len, b = 0; b < p; ) {
      for (var g = d % a, w = Math.min(p - b, a - g), C = 0; C < w; C++)
        h[g + C] = o[b + C];
      d += w, b += w, d % a === 0 && this._update(h);
    }
    return this._len += p, this;
  }, t.prototype.digest = function(o) {
    var r = this._len % this._blockSize;
    this._block[r] = 128, this._block.fill(0, r + 1), r >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var h = this._len * 8;
    if (h <= 4294967295)
      this._block.writeUInt32BE(h, this._blockSize - 4);
    else {
      var a = (h & 4294967295) >>> 0, p = (h - a) / 4294967296;
      this._block.writeUInt32BE(p, this._blockSize - 8), this._block.writeUInt32BE(a, this._blockSize - 4);
    }
    this._update(this._block);
    var d = this._hash();
    return o ? d.toString(o) : d;
  }, t.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, hash$1 = t, hash$1;
}
var sha$1, hasRequiredSha$1;
function requireSha$1() {
  if (hasRequiredSha$1)
    return sha$1;
  hasRequiredSha$1 = 1;
  var e = requireInherits_browser(), t = requireHash$1(), o = requireSafeBuffer$1().Buffer, r = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], h = new Array(80);
  function a() {
    this.init(), this._w = h, t.call(this, 64, 56);
  }
  e(a, t), a.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function p(g) {
    return g << 5 | g >>> 27;
  }
  function d(g) {
    return g << 30 | g >>> 2;
  }
  function b(g, w, C, T) {
    return g === 0 ? w & C | ~w & T : g === 2 ? w & C | w & T | C & T : w ^ C ^ T;
  }
  return a.prototype._update = function(g) {
    for (var w = this._w, C = this._a | 0, T = this._b | 0, k = this._c | 0, q = this._d | 0, O = this._e | 0, N = 0; N < 16; ++N)
      w[N] = g.readInt32BE(N * 4);
    for (; N < 80; ++N)
      w[N] = w[N - 3] ^ w[N - 8] ^ w[N - 14] ^ w[N - 16];
    for (var j = 0; j < 80; ++j) {
      var U = ~~(j / 20), H = p(C) + b(U, T, k, q) + O + w[j] + r[U] | 0;
      O = q, q = k, k = d(T), T = C, C = H;
    }
    this._a = C + this._a | 0, this._b = T + this._b | 0, this._c = k + this._c | 0, this._d = q + this._d | 0, this._e = O + this._e | 0;
  }, a.prototype._hash = function() {
    var g = o.allocUnsafe(20);
    return g.writeInt32BE(this._a | 0, 0), g.writeInt32BE(this._b | 0, 4), g.writeInt32BE(this._c | 0, 8), g.writeInt32BE(this._d | 0, 12), g.writeInt32BE(this._e | 0, 16), g;
  }, sha$1 = a, sha$1;
}
var sha1, hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1)
    return sha1;
  hasRequiredSha1 = 1;
  var e = requireInherits_browser(), t = requireHash$1(), o = requireSafeBuffer$1().Buffer, r = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], h = new Array(80);
  function a() {
    this.init(), this._w = h, t.call(this, 64, 56);
  }
  e(a, t), a.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function p(w) {
    return w << 1 | w >>> 31;
  }
  function d(w) {
    return w << 5 | w >>> 27;
  }
  function b(w) {
    return w << 30 | w >>> 2;
  }
  function g(w, C, T, k) {
    return w === 0 ? C & T | ~C & k : w === 2 ? C & T | C & k | T & k : C ^ T ^ k;
  }
  return a.prototype._update = function(w) {
    for (var C = this._w, T = this._a | 0, k = this._b | 0, q = this._c | 0, O = this._d | 0, N = this._e | 0, j = 0; j < 16; ++j)
      C[j] = w.readInt32BE(j * 4);
    for (; j < 80; ++j)
      C[j] = p(C[j - 3] ^ C[j - 8] ^ C[j - 14] ^ C[j - 16]);
    for (var U = 0; U < 80; ++U) {
      var H = ~~(U / 20), z = d(T) + g(H, k, q, O) + N + C[U] + r[H] | 0;
      N = O, O = q, q = b(k), k = T, T = z;
    }
    this._a = T + this._a | 0, this._b = k + this._b | 0, this._c = q + this._c | 0, this._d = O + this._d | 0, this._e = N + this._e | 0;
  }, a.prototype._hash = function() {
    var w = o.allocUnsafe(20);
    return w.writeInt32BE(this._a | 0, 0), w.writeInt32BE(this._b | 0, 4), w.writeInt32BE(this._c | 0, 8), w.writeInt32BE(this._d | 0, 12), w.writeInt32BE(this._e | 0, 16), w;
  }, sha1 = a, sha1;
}
var sha256$1, hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256)
    return sha256$1;
  hasRequiredSha256 = 1;
  var e = requireInherits_browser(), t = requireHash$1(), o = requireSafeBuffer$1().Buffer, r = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], h = new Array(64);
  function a() {
    this.init(), this._w = h, t.call(this, 64, 56);
  }
  e(a, t), a.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function p(T, k, q) {
    return q ^ T & (k ^ q);
  }
  function d(T, k, q) {
    return T & k | q & (T | k);
  }
  function b(T) {
    return (T >>> 2 | T << 30) ^ (T >>> 13 | T << 19) ^ (T >>> 22 | T << 10);
  }
  function g(T) {
    return (T >>> 6 | T << 26) ^ (T >>> 11 | T << 21) ^ (T >>> 25 | T << 7);
  }
  function w(T) {
    return (T >>> 7 | T << 25) ^ (T >>> 18 | T << 14) ^ T >>> 3;
  }
  function C(T) {
    return (T >>> 17 | T << 15) ^ (T >>> 19 | T << 13) ^ T >>> 10;
  }
  return a.prototype._update = function(T) {
    for (var k = this._w, q = this._a | 0, O = this._b | 0, N = this._c | 0, j = this._d | 0, U = this._e | 0, H = this._f | 0, z = this._g | 0, ee = this._h | 0, ne = 0; ne < 16; ++ne)
      k[ne] = T.readInt32BE(ne * 4);
    for (; ne < 64; ++ne)
      k[ne] = C(k[ne - 2]) + k[ne - 7] + w(k[ne - 15]) + k[ne - 16] | 0;
    for (var le = 0; le < 64; ++le) {
      var Z = ee + g(U) + p(U, H, z) + r[le] + k[le] | 0, ie = b(q) + d(q, O, N) | 0;
      ee = z, z = H, H = U, U = j + Z | 0, j = N, N = O, O = q, q = Z + ie | 0;
    }
    this._a = q + this._a | 0, this._b = O + this._b | 0, this._c = N + this._c | 0, this._d = j + this._d | 0, this._e = U + this._e | 0, this._f = H + this._f | 0, this._g = z + this._g | 0, this._h = ee + this._h | 0;
  }, a.prototype._hash = function() {
    var T = o.allocUnsafe(32);
    return T.writeInt32BE(this._a, 0), T.writeInt32BE(this._b, 4), T.writeInt32BE(this._c, 8), T.writeInt32BE(this._d, 12), T.writeInt32BE(this._e, 16), T.writeInt32BE(this._f, 20), T.writeInt32BE(this._g, 24), T.writeInt32BE(this._h, 28), T;
  }, sha256$1 = a, sha256$1;
}
var sha224$1, hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224)
    return sha224$1;
  hasRequiredSha224 = 1;
  var e = requireInherits_browser(), t = requireSha256(), o = requireHash$1(), r = requireSafeBuffer$1().Buffer, h = new Array(64);
  function a() {
    this.init(), this._w = h, o.call(this, 64, 56);
  }
  return e(a, t), a.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, a.prototype._hash = function() {
    var p = r.allocUnsafe(28);
    return p.writeInt32BE(this._a, 0), p.writeInt32BE(this._b, 4), p.writeInt32BE(this._c, 8), p.writeInt32BE(this._d, 12), p.writeInt32BE(this._e, 16), p.writeInt32BE(this._f, 20), p.writeInt32BE(this._g, 24), p;
  }, sha224$1 = a, sha224$1;
}
var sha512$1, hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512)
    return sha512$1;
  hasRequiredSha512 = 1;
  var e = requireInherits_browser(), t = requireHash$1(), o = requireSafeBuffer$1().Buffer, r = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], h = new Array(160);
  function a() {
    this.init(), this._w = h, t.call(this, 128, 112);
  }
  e(a, t), a.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function p(O, N, j) {
    return j ^ O & (N ^ j);
  }
  function d(O, N, j) {
    return O & N | j & (O | N);
  }
  function b(O, N) {
    return (O >>> 28 | N << 4) ^ (N >>> 2 | O << 30) ^ (N >>> 7 | O << 25);
  }
  function g(O, N) {
    return (O >>> 14 | N << 18) ^ (O >>> 18 | N << 14) ^ (N >>> 9 | O << 23);
  }
  function w(O, N) {
    return (O >>> 1 | N << 31) ^ (O >>> 8 | N << 24) ^ O >>> 7;
  }
  function C(O, N) {
    return (O >>> 1 | N << 31) ^ (O >>> 8 | N << 24) ^ (O >>> 7 | N << 25);
  }
  function T(O, N) {
    return (O >>> 19 | N << 13) ^ (N >>> 29 | O << 3) ^ O >>> 6;
  }
  function k(O, N) {
    return (O >>> 19 | N << 13) ^ (N >>> 29 | O << 3) ^ (O >>> 6 | N << 26);
  }
  function q(O, N) {
    return O >>> 0 < N >>> 0 ? 1 : 0;
  }
  return a.prototype._update = function(O) {
    for (var N = this._w, j = this._ah | 0, U = this._bh | 0, H = this._ch | 0, z = this._dh | 0, ee = this._eh | 0, ne = this._fh | 0, le = this._gh | 0, Z = this._hh | 0, ie = this._al | 0, fe = this._bl | 0, I = this._cl | 0, P = this._dl | 0, f = this._el | 0, y = this._fl | 0, v = this._gl | 0, M = this._hl | 0, B = 0; B < 32; B += 2)
      N[B] = O.readInt32BE(B * 4), N[B + 1] = O.readInt32BE(B * 4 + 4);
    for (; B < 160; B += 2) {
      var S = N[B - 30], _ = N[B - 15 * 2 + 1], E = w(S, _), m = C(_, S);
      S = N[B - 2 * 2], _ = N[B - 2 * 2 + 1];
      var A = T(S, _), $ = k(_, S), X = N[B - 7 * 2], oe = N[B - 7 * 2 + 1], J = N[B - 16 * 2], W = N[B - 16 * 2 + 1], Q = m + oe | 0, me = E + X + q(Q, m) | 0;
      Q = Q + $ | 0, me = me + A + q(Q, $) | 0, Q = Q + W | 0, me = me + J + q(Q, W) | 0, N[B] = me, N[B + 1] = Q;
    }
    for (var be = 0; be < 160; be += 2) {
      me = N[be], Q = N[be + 1];
      var Y = d(j, U, H), re = d(ie, fe, I), de = b(j, ie), Ae = b(ie, j), qe = g(ee, f), x = g(f, ee), L = r[be], D = r[be + 1], F = p(ee, ne, le), ue = p(f, y, v), ge = M + x | 0, ce = Z + qe + q(ge, M) | 0;
      ge = ge + ue | 0, ce = ce + F + q(ge, ue) | 0, ge = ge + D | 0, ce = ce + L + q(ge, D) | 0, ge = ge + Q | 0, ce = ce + me + q(ge, Q) | 0;
      var ve = Ae + re | 0, Re = de + Y + q(ve, Ae) | 0;
      Z = le, M = v, le = ne, v = y, ne = ee, y = f, f = P + ge | 0, ee = z + ce + q(f, P) | 0, z = H, P = I, H = U, I = fe, U = j, fe = ie, ie = ge + ve | 0, j = ce + Re + q(ie, ge) | 0;
    }
    this._al = this._al + ie | 0, this._bl = this._bl + fe | 0, this._cl = this._cl + I | 0, this._dl = this._dl + P | 0, this._el = this._el + f | 0, this._fl = this._fl + y | 0, this._gl = this._gl + v | 0, this._hl = this._hl + M | 0, this._ah = this._ah + j + q(this._al, ie) | 0, this._bh = this._bh + U + q(this._bl, fe) | 0, this._ch = this._ch + H + q(this._cl, I) | 0, this._dh = this._dh + z + q(this._dl, P) | 0, this._eh = this._eh + ee + q(this._el, f) | 0, this._fh = this._fh + ne + q(this._fl, y) | 0, this._gh = this._gh + le + q(this._gl, v) | 0, this._hh = this._hh + Z + q(this._hl, M) | 0;
  }, a.prototype._hash = function() {
    var O = o.allocUnsafe(64);
    function N(j, U, H) {
      O.writeInt32BE(j, H), O.writeInt32BE(U, H + 4);
    }
    return N(this._ah, this._al, 0), N(this._bh, this._bl, 8), N(this._ch, this._cl, 16), N(this._dh, this._dl, 24), N(this._eh, this._el, 32), N(this._fh, this._fl, 40), N(this._gh, this._gl, 48), N(this._hh, this._hl, 56), O;
  }, sha512$1 = a, sha512$1;
}
var sha384$1, hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384)
    return sha384$1;
  hasRequiredSha384 = 1;
  var e = requireInherits_browser(), t = requireSha512(), o = requireHash$1(), r = requireSafeBuffer$1().Buffer, h = new Array(160);
  function a() {
    this.init(), this._w = h, o.call(this, 128, 112);
  }
  return e(a, t), a.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, a.prototype._hash = function() {
    var p = r.allocUnsafe(48);
    function d(b, g, w) {
      p.writeInt32BE(b, w), p.writeInt32BE(g, w + 4);
    }
    return d(this._ah, this._al, 0), d(this._bh, this._bl, 8), d(this._ch, this._cl, 16), d(this._dh, this._dl, 24), d(this._eh, this._el, 32), d(this._fh, this._fl, 40), p;
  }, sha384$1 = a, sha384$1;
}
var hasRequiredSha_js;
function requireSha_js() {
  if (hasRequiredSha_js)
    return sha_js.exports;
  hasRequiredSha_js = 1;
  var e = sha_js.exports = function(t) {
    t = t.toLowerCase();
    var o = e[t];
    if (!o)
      throw new Error(t + " is not supported (we accept pull requests)");
    return new o();
  };
  return e.sha = requireSha$1(), e.sha1 = requireSha1(), e.sha224 = requireSha224(), e.sha256 = requireSha256(), e.sha384 = requireSha384(), e.sha512 = requireSha512(), sha_js.exports;
}
var streamBrowserify, hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify)
    return streamBrowserify;
  hasRequiredStreamBrowserify = 1, streamBrowserify = o;
  var e = requireEvents().EventEmitter, t = requireInherits_browser();
  t(o, e), o.Readable = require_stream_readable$1(), o.Writable = require_stream_writable$1(), o.Duplex = require_stream_duplex$1(), o.Transform = require_stream_transform$1(), o.PassThrough = require_stream_passthrough$1(), o.finished = requireEndOfStream(), o.pipeline = requirePipeline(), o.Stream = o;
  function o() {
    e.call(this);
  }
  return o.prototype.pipe = function(r, h) {
    var a = this;
    function p(k) {
      r.writable && r.write(k) === !1 && a.pause && a.pause();
    }
    a.on("data", p);
    function d() {
      a.readable && a.resume && a.resume();
    }
    r.on("drain", d), !r._isStdio && (!h || h.end !== !1) && (a.on("end", g), a.on("close", w));
    var b = !1;
    function g() {
      b || (b = !0, r.end());
    }
    function w() {
      b || (b = !0, typeof r.destroy == "function" && r.destroy());
    }
    function C(k) {
      if (T(), e.listenerCount(this, "error") === 0)
        throw k;
    }
    a.on("error", C), r.on("error", C);
    function T() {
      a.removeListener("data", p), r.removeListener("drain", d), a.removeListener("end", g), a.removeListener("close", w), a.removeListener("error", C), r.removeListener("error", C), a.removeListener("end", T), a.removeListener("close", T), r.removeListener("close", T);
    }
    return a.on("end", T), a.on("close", T), r.on("close", T), r.emit("pipe", a), r;
  }, streamBrowserify;
}
var cipherBase, hasRequiredCipherBase;
function requireCipherBase() {
  if (hasRequiredCipherBase)
    return cipherBase;
  hasRequiredCipherBase = 1;
  var e = requireSafeBuffer$1().Buffer, t = requireStreamBrowserify().Transform, o = requireString_decoder().StringDecoder, r = requireInherits_browser();
  function h(a) {
    t.call(this), this.hashMode = typeof a == "string", this.hashMode ? this[a] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  return r(h, t), h.prototype.update = function(a, p, d) {
    typeof a == "string" && (a = e.from(a, p));
    var b = this._update(a);
    return this.hashMode ? this : (d && (b = this._toString(b, d)), b);
  }, h.prototype.setAutoPadding = function() {
  }, h.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, h.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, h.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, h.prototype._transform = function(a, p, d) {
    var b;
    try {
      this.hashMode ? this._update(a) : this.push(this._update(a));
    } catch (g) {
      b = g;
    } finally {
      d(b);
    }
  }, h.prototype._flush = function(a) {
    var p;
    try {
      this.push(this.__final());
    } catch (d) {
      p = d;
    }
    a(p);
  }, h.prototype._finalOrDigest = function(a) {
    var p = this.__final() || e.alloc(0);
    return a && (p = this._toString(p, a, !0)), p;
  }, h.prototype._toString = function(a, p, d) {
    if (this._decoder || (this._decoder = new o(p), this._encoding = p), this._encoding !== p)
      throw new Error("can't switch encodings");
    var b = this._decoder.write(a);
    return d && (b += this._decoder.end()), b;
  }, cipherBase = h, cipherBase;
}
var browser$9, hasRequiredBrowser$9;
function requireBrowser$9() {
  if (hasRequiredBrowser$9)
    return browser$9;
  hasRequiredBrowser$9 = 1;
  var e = requireInherits_browser(), t = requireMd5_js(), o = requireRipemd160(), r = requireSha_js(), h = requireCipherBase();
  function a(p) {
    h.call(this, "digest"), this._hash = p;
  }
  return e(a, h), a.prototype._update = function(p) {
    this._hash.update(p);
  }, a.prototype._final = function() {
    return this._hash.digest();
  }, browser$9 = function(p) {
    return p = p.toLowerCase(), p === "md5" ? new t() : p === "rmd160" || p === "ripemd160" ? new o() : new a(r(p));
  }, browser$9;
}
var legacy, hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy)
    return legacy;
  hasRequiredLegacy = 1;
  var e = requireInherits_browser(), t = requireSafeBuffer$1().Buffer, o = requireCipherBase(), r = t.alloc(128), h = 64;
  function a(p, d) {
    o.call(this, "digest"), typeof d == "string" && (d = t.from(d)), this._alg = p, this._key = d, d.length > h ? d = p(d) : d.length < h && (d = t.concat([d, r], h));
    for (var b = this._ipad = t.allocUnsafe(h), g = this._opad = t.allocUnsafe(h), w = 0; w < h; w++)
      b[w] = d[w] ^ 54, g[w] = d[w] ^ 92;
    this._hash = [b];
  }
  return e(a, o), a.prototype._update = function(p) {
    this._hash.push(p);
  }, a.prototype._final = function() {
    var p = this._alg(t.concat(this._hash));
    return this._alg(t.concat([this._opad, p]));
  }, legacy = a, legacy;
}
var md5, hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5)
    return md5;
  hasRequiredMd5 = 1;
  var e = requireMd5_js();
  return md5 = function(t) {
    return new e().update(t).digest();
  }, md5;
}
var browser$8, hasRequiredBrowser$8;
function requireBrowser$8() {
  if (hasRequiredBrowser$8)
    return browser$8;
  hasRequiredBrowser$8 = 1;
  var e = requireInherits_browser(), t = requireLegacy(), o = requireCipherBase(), r = requireSafeBuffer$1().Buffer, h = requireMd5(), a = requireRipemd160(), p = requireSha_js(), d = r.alloc(128);
  function b(g, w) {
    o.call(this, "digest"), typeof w == "string" && (w = r.from(w));
    var C = g === "sha512" || g === "sha384" ? 128 : 64;
    if (this._alg = g, this._key = w, w.length > C) {
      var T = g === "rmd160" ? new a() : p(g);
      w = T.update(w).digest();
    } else
      w.length < C && (w = r.concat([w, d], C));
    for (var k = this._ipad = r.allocUnsafe(C), q = this._opad = r.allocUnsafe(C), O = 0; O < C; O++)
      k[O] = w[O] ^ 54, q[O] = w[O] ^ 92;
    this._hash = g === "rmd160" ? new a() : p(g), this._hash.update(k);
  }
  return e(b, o), b.prototype._update = function(g) {
    this._hash.update(g);
  }, b.prototype._final = function() {
    var g = this._hash.digest(), w = this._alg === "rmd160" ? new a() : p(this._alg);
    return w.update(this._opad).update(g).digest();
  }, browser$8 = function(g, w) {
    return g = g.toLowerCase(), g === "rmd160" || g === "ripemd160" ? new b("rmd160", w) : g === "md5" ? new t(h, w) : new b(g, w);
  }, browser$8;
}
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos, hasRequiredAlgos;
function requireAlgos() {
  return hasRequiredAlgos || (hasRequiredAlgos = 1, algos = require$$6), algos;
}
var browser$7 = {}, precondition, hasRequiredPrecondition;
function requirePrecondition() {
  if (hasRequiredPrecondition)
    return precondition;
  hasRequiredPrecondition = 1;
  var e = Math.pow(2, 30) - 1;
  return precondition = function(t, o) {
    if (typeof t != "number")
      throw new TypeError("Iterations not a number");
    if (t < 0)
      throw new TypeError("Bad iterations");
    if (typeof o != "number")
      throw new TypeError("Key length not a number");
    if (o < 0 || o > e || o !== o)
      throw new TypeError("Bad key length");
  }, precondition;
}
var defaultEncoding_1, hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
  if (hasRequiredDefaultEncoding)
    return defaultEncoding_1;
  hasRequiredDefaultEncoding = 1;
  var e;
  if (commonjsGlobal.process && commonjsGlobal.process.browser)
    e = "utf-8";
  else if (commonjsGlobal.process && commonjsGlobal.process.version) {
    var t = parseInt(process$1.version.split(".")[0].slice(1), 10);
    e = t >= 6 ? "utf-8" : "binary";
  } else
    e = "utf-8";
  return defaultEncoding_1 = e, defaultEncoding_1;
}
var toBuffer, hasRequiredToBuffer;
function requireToBuffer() {
  if (hasRequiredToBuffer)
    return toBuffer;
  hasRequiredToBuffer = 1;
  var e = requireSafeBuffer$1().Buffer;
  return toBuffer = function(t, o, r) {
    if (e.isBuffer(t))
      return t;
    if (typeof t == "string")
      return e.from(t, o);
    if (ArrayBuffer.isView(t))
      return e.from(t.buffer);
    throw new TypeError(r + " must be a string, a Buffer, a typed array or a DataView");
  }, toBuffer;
}
var syncBrowser, hasRequiredSyncBrowser;
function requireSyncBrowser() {
  if (hasRequiredSyncBrowser)
    return syncBrowser;
  hasRequiredSyncBrowser = 1;
  var e = requireMd5(), t = requireRipemd160(), o = requireSha_js(), r = requireSafeBuffer$1().Buffer, h = requirePrecondition(), a = requireDefaultEncoding(), p = requireToBuffer(), d = r.alloc(128), b = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function g(T, k, q) {
    var O = w(T), N = T === "sha512" || T === "sha384" ? 128 : 64;
    k.length > N ? k = O(k) : k.length < N && (k = r.concat([k, d], N));
    for (var j = r.allocUnsafe(N + b[T]), U = r.allocUnsafe(N + b[T]), H = 0; H < N; H++)
      j[H] = k[H] ^ 54, U[H] = k[H] ^ 92;
    var z = r.allocUnsafe(N + q + 4);
    j.copy(z, 0, 0, N), this.ipad1 = z, this.ipad2 = j, this.opad = U, this.alg = T, this.blocksize = N, this.hash = O, this.size = b[T];
  }
  g.prototype.run = function(T, k) {
    T.copy(k, this.blocksize);
    var q = this.hash(k);
    return q.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function w(T) {
    function k(O) {
      return o(T).update(O).digest();
    }
    function q(O) {
      return new t().update(O).digest();
    }
    return T === "rmd160" || T === "ripemd160" ? q : T === "md5" ? e : k;
  }
  function C(T, k, q, O, N) {
    h(q, O), T = p(T, a, "Password"), k = p(k, a, "Salt"), N = N || "sha1";
    var j = new g(N, T, k.length), U = r.allocUnsafe(O), H = r.allocUnsafe(k.length + 4);
    k.copy(H, 0, 0, k.length);
    for (var z = 0, ee = b[N], ne = Math.ceil(O / ee), le = 1; le <= ne; le++) {
      H.writeUInt32BE(le, k.length);
      for (var Z = j.run(H, j.ipad1), ie = Z, fe = 1; fe < q; fe++) {
        ie = j.run(ie, j.ipad2);
        for (var I = 0; I < ee; I++)
          Z[I] ^= ie[I];
      }
      Z.copy(U, z), z += ee;
    }
    return U;
  }
  return syncBrowser = C, syncBrowser;
}
var async, hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync)
    return async;
  hasRequiredAsync = 1;
  var e = requireSafeBuffer$1().Buffer, t = requirePrecondition(), o = requireDefaultEncoding(), r = requireSyncBrowser(), h = requireToBuffer(), a, p = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, d = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, b = [];
  function g(q) {
    if (commonjsGlobal.process && !commonjsGlobal.process.browser || !p || !p.importKey || !p.deriveBits)
      return Promise.resolve(!1);
    if (b[q] !== void 0)
      return b[q];
    a = a || e.alloc(8);
    var O = T(a, a, 10, 128, q).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return b[q] = O, O;
  }
  var w;
  function C() {
    return w || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? w = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? w = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? w = commonjsGlobal.setImmediate : w = commonjsGlobal.setTimeout, w);
  }
  function T(q, O, N, j, U) {
    return p.importKey(
      "raw",
      q,
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ).then(function(H) {
      return p.deriveBits({
        name: "PBKDF2",
        salt: O,
        iterations: N,
        hash: {
          name: U
        }
      }, H, j << 3);
    }).then(function(H) {
      return e.from(H);
    });
  }
  function k(q, O) {
    q.then(function(N) {
      C()(function() {
        O(null, N);
      });
    }, function(N) {
      C()(function() {
        O(N);
      });
    });
  }
  return async = function(q, O, N, j, U, H) {
    typeof U == "function" && (H = U, U = void 0), U = U || "sha1";
    var z = d[U.toLowerCase()];
    if (!z || typeof commonjsGlobal.Promise != "function") {
      C()(function() {
        var ee;
        try {
          ee = r(q, O, N, j, U);
        } catch (ne) {
          return H(ne);
        }
        H(null, ee);
      });
      return;
    }
    if (t(N, j), q = h(q, o, "Password"), O = h(O, o, "Salt"), typeof H != "function")
      throw new Error("No callback provided to pbkdf2");
    k(g(z).then(function(ee) {
      return ee ? T(q, O, N, j, z) : r(q, O, N, j, U);
    }), H);
  }, async;
}
var hasRequiredBrowser$7;
function requireBrowser$7() {
  return hasRequiredBrowser$7 || (hasRequiredBrowser$7 = 1, browser$7.pbkdf2 = requireAsync(), browser$7.pbkdf2Sync = requireSyncBrowser()), browser$7;
}
var browser$6 = {}, des$1 = {}, utils$3 = {}, hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3)
    return utils$3;
  hasRequiredUtils$3 = 1, utils$3.readUInt32BE = function(r, h) {
    var a = r[0 + h] << 24 | r[1 + h] << 16 | r[2 + h] << 8 | r[3 + h];
    return a >>> 0;
  }, utils$3.writeUInt32BE = function(r, h, a) {
    r[0 + a] = h >>> 24, r[1 + a] = h >>> 16 & 255, r[2 + a] = h >>> 8 & 255, r[3 + a] = h & 255;
  }, utils$3.ip = function(r, h, a, p) {
    for (var d = 0, b = 0, g = 6; g >= 0; g -= 2) {
      for (var w = 0; w <= 24; w += 8)
        d <<= 1, d |= h >>> w + g & 1;
      for (var w = 0; w <= 24; w += 8)
        d <<= 1, d |= r >>> w + g & 1;
    }
    for (var g = 6; g >= 0; g -= 2) {
      for (var w = 1; w <= 25; w += 8)
        b <<= 1, b |= h >>> w + g & 1;
      for (var w = 1; w <= 25; w += 8)
        b <<= 1, b |= r >>> w + g & 1;
    }
    a[p + 0] = d >>> 0, a[p + 1] = b >>> 0;
  }, utils$3.rip = function(r, h, a, p) {
    for (var d = 0, b = 0, g = 0; g < 4; g++)
      for (var w = 24; w >= 0; w -= 8)
        d <<= 1, d |= h >>> w + g & 1, d <<= 1, d |= r >>> w + g & 1;
    for (var g = 4; g < 8; g++)
      for (var w = 24; w >= 0; w -= 8)
        b <<= 1, b |= h >>> w + g & 1, b <<= 1, b |= r >>> w + g & 1;
    a[p + 0] = d >>> 0, a[p + 1] = b >>> 0;
  }, utils$3.pc1 = function(r, h, a, p) {
    for (var d = 0, b = 0, g = 7; g >= 5; g--) {
      for (var w = 0; w <= 24; w += 8)
        d <<= 1, d |= h >> w + g & 1;
      for (var w = 0; w <= 24; w += 8)
        d <<= 1, d |= r >> w + g & 1;
    }
    for (var w = 0; w <= 24; w += 8)
      d <<= 1, d |= h >> w + g & 1;
    for (var g = 1; g <= 3; g++) {
      for (var w = 0; w <= 24; w += 8)
        b <<= 1, b |= h >> w + g & 1;
      for (var w = 0; w <= 24; w += 8)
        b <<= 1, b |= r >> w + g & 1;
    }
    for (var w = 0; w <= 24; w += 8)
      b <<= 1, b |= r >> w + g & 1;
    a[p + 0] = d >>> 0, a[p + 1] = b >>> 0;
  }, utils$3.r28shl = function(r, h) {
    return r << h & 268435455 | r >>> 28 - h;
  };
  var e = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  utils$3.pc2 = function(r, h, a, p) {
    for (var d = 0, b = 0, g = e.length >>> 1, w = 0; w < g; w++)
      d <<= 1, d |= r >>> e[w] & 1;
    for (var w = g; w < e.length; w++)
      b <<= 1, b |= h >>> e[w] & 1;
    a[p + 0] = d >>> 0, a[p + 1] = b >>> 0;
  }, utils$3.expand = function(r, h, a) {
    var p = 0, d = 0;
    p = (r & 1) << 5 | r >>> 27;
    for (var b = 23; b >= 15; b -= 4)
      p <<= 6, p |= r >>> b & 63;
    for (var b = 11; b >= 3; b -= 4)
      d |= r >>> b & 63, d <<= 6;
    d |= (r & 31) << 1 | r >>> 31, h[a + 0] = p >>> 0, h[a + 1] = d >>> 0;
  };
  var t = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  utils$3.substitute = function(r, h) {
    for (var a = 0, p = 0; p < 4; p++) {
      var d = r >>> 18 - p * 6 & 63, b = t[p * 64 + d];
      a <<= 4, a |= b;
    }
    for (var p = 0; p < 4; p++) {
      var d = h >>> 18 - p * 6 & 63, b = t[4 * 64 + p * 64 + d];
      a <<= 4, a |= b;
    }
    return a >>> 0;
  };
  var o = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return utils$3.permute = function(r) {
    for (var h = 0, a = 0; a < o.length; a++)
      h <<= 1, h |= r >>> o[a] & 1;
    return h >>> 0;
  }, utils$3.padSplit = function(r, h, a) {
    for (var p = r.toString(2); p.length < h; )
      p = "0" + p;
    for (var d = [], b = 0; b < h; b += a)
      d.push(p.slice(b, b + a));
    return d.join(" ");
  }, utils$3;
}
var minimalisticAssert, hasRequiredMinimalisticAssert;
function requireMinimalisticAssert() {
  if (hasRequiredMinimalisticAssert)
    return minimalisticAssert;
  hasRequiredMinimalisticAssert = 1, minimalisticAssert = e;
  function e(t, o) {
    if (!t)
      throw new Error(o || "Assertion failed");
  }
  return e.equal = function(t, o, r) {
    if (t != o)
      throw new Error(r || "Assertion failed: " + t + " != " + o);
  }, minimalisticAssert;
}
var cipher, hasRequiredCipher;
function requireCipher() {
  if (hasRequiredCipher)
    return cipher;
  hasRequiredCipher = 1;
  var e = requireMinimalisticAssert();
  function t(o) {
    this.options = o, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = o.padding !== !1;
  }
  return cipher = t, t.prototype._init = function() {
  }, t.prototype.update = function(o) {
    return o.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(o) : this._updateEncrypt(o);
  }, t.prototype._buffer = function(o, r) {
    for (var h = Math.min(this.buffer.length - this.bufferOff, o.length - r), a = 0; a < h; a++)
      this.buffer[this.bufferOff + a] = o[r + a];
    return this.bufferOff += h, h;
  }, t.prototype._flushBuffer = function(o, r) {
    return this._update(this.buffer, 0, o, r), this.bufferOff = 0, this.blockSize;
  }, t.prototype._updateEncrypt = function(o) {
    var r = 0, h = 0, a = (this.bufferOff + o.length) / this.blockSize | 0, p = new Array(a * this.blockSize);
    this.bufferOff !== 0 && (r += this._buffer(o, r), this.bufferOff === this.buffer.length && (h += this._flushBuffer(p, h)));
    for (var d = o.length - (o.length - r) % this.blockSize; r < d; r += this.blockSize)
      this._update(o, r, p, h), h += this.blockSize;
    for (; r < o.length; r++, this.bufferOff++)
      this.buffer[this.bufferOff] = o[r];
    return p;
  }, t.prototype._updateDecrypt = function(o) {
    for (var r = 0, h = 0, a = Math.ceil((this.bufferOff + o.length) / this.blockSize) - 1, p = new Array(a * this.blockSize); a > 0; a--)
      r += this._buffer(o, r), h += this._flushBuffer(p, h);
    return r += this._buffer(o, r), p;
  }, t.prototype.final = function(o) {
    var r;
    o && (r = this.update(o));
    var h;
    return this.type === "encrypt" ? h = this._finalEncrypt() : h = this._finalDecrypt(), r ? r.concat(h) : h;
  }, t.prototype._pad = function(o, r) {
    if (r === 0)
      return !1;
    for (; r < o.length; )
      o[r++] = 0;
    return !0;
  }, t.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var o = new Array(this.blockSize);
    return this._update(this.buffer, 0, o, 0), o;
  }, t.prototype._unpad = function(o) {
    return o;
  }, t.prototype._finalDecrypt = function() {
    e.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var o = new Array(this.blockSize);
    return this._flushBuffer(o, 0), this._unpad(o);
  }, cipher;
}
var des, hasRequiredDes$1;
function requireDes$1() {
  if (hasRequiredDes$1)
    return des;
  hasRequiredDes$1 = 1;
  var e = requireMinimalisticAssert(), t = requireInherits_browser(), o = requireUtils$3(), r = requireCipher();
  function h() {
    this.tmp = new Array(2), this.keys = null;
  }
  function a(d) {
    r.call(this, d);
    var b = new h();
    this._desState = b, this.deriveKeys(b, d.key);
  }
  t(a, r), des = a, a.create = function(d) {
    return new a(d);
  };
  var p = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return a.prototype.deriveKeys = function(d, b) {
    d.keys = new Array(16 * 2), e.equal(b.length, this.blockSize, "Invalid key length");
    var g = o.readUInt32BE(b, 0), w = o.readUInt32BE(b, 4);
    o.pc1(g, w, d.tmp, 0), g = d.tmp[0], w = d.tmp[1];
    for (var C = 0; C < d.keys.length; C += 2) {
      var T = p[C >>> 1];
      g = o.r28shl(g, T), w = o.r28shl(w, T), o.pc2(g, w, d.keys, C);
    }
  }, a.prototype._update = function(d, b, g, w) {
    var C = this._desState, T = o.readUInt32BE(d, b), k = o.readUInt32BE(d, b + 4);
    o.ip(T, k, C.tmp, 0), T = C.tmp[0], k = C.tmp[1], this.type === "encrypt" ? this._encrypt(C, T, k, C.tmp, 0) : this._decrypt(C, T, k, C.tmp, 0), T = C.tmp[0], k = C.tmp[1], o.writeUInt32BE(g, T, w), o.writeUInt32BE(g, k, w + 4);
  }, a.prototype._pad = function(d, b) {
    if (this.padding === !1)
      return !1;
    for (var g = d.length - b, w = b; w < d.length; w++)
      d[w] = g;
    return !0;
  }, a.prototype._unpad = function(d) {
    if (this.padding === !1)
      return d;
    for (var b = d[d.length - 1], g = d.length - b; g < d.length; g++)
      e.equal(d[g], b);
    return d.slice(0, d.length - b);
  }, a.prototype._encrypt = function(d, b, g, w, C) {
    for (var T = b, k = g, q = 0; q < d.keys.length; q += 2) {
      var O = d.keys[q], N = d.keys[q + 1];
      o.expand(k, d.tmp, 0), O ^= d.tmp[0], N ^= d.tmp[1];
      var j = o.substitute(O, N), U = o.permute(j), H = k;
      k = (T ^ U) >>> 0, T = H;
    }
    o.rip(k, T, w, C);
  }, a.prototype._decrypt = function(d, b, g, w, C) {
    for (var T = g, k = b, q = d.keys.length - 2; q >= 0; q -= 2) {
      var O = d.keys[q], N = d.keys[q + 1];
      o.expand(T, d.tmp, 0), O ^= d.tmp[0], N ^= d.tmp[1];
      var j = o.substitute(O, N), U = o.permute(j), H = T;
      T = (k ^ U) >>> 0, k = H;
    }
    o.rip(T, k, w, C);
  }, des;
}
var cbc$1 = {}, hasRequiredCbc$1;
function requireCbc$1() {
  if (hasRequiredCbc$1)
    return cbc$1;
  hasRequiredCbc$1 = 1;
  var e = requireMinimalisticAssert(), t = requireInherits_browser(), o = {};
  function r(a) {
    e.equal(a.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var p = 0; p < this.iv.length; p++)
      this.iv[p] = a[p];
  }
  function h(a) {
    function p(w) {
      a.call(this, w), this._cbcInit();
    }
    t(p, a);
    for (var d = Object.keys(o), b = 0; b < d.length; b++) {
      var g = d[b];
      p.prototype[g] = o[g];
    }
    return p.create = function(w) {
      return new p(w);
    }, p;
  }
  return cbc$1.instantiate = h, o._cbcInit = function() {
    var a = new r(this.options.iv);
    this._cbcState = a;
  }, o._update = function(a, p, d, b) {
    var g = this._cbcState, w = this.constructor.super_.prototype, C = g.iv;
    if (this.type === "encrypt") {
      for (var T = 0; T < this.blockSize; T++)
        C[T] ^= a[p + T];
      w._update.call(this, C, 0, d, b);
      for (var T = 0; T < this.blockSize; T++)
        C[T] = d[b + T];
    } else {
      w._update.call(this, a, p, d, b);
      for (var T = 0; T < this.blockSize; T++)
        d[b + T] ^= C[T];
      for (var T = 0; T < this.blockSize; T++)
        C[T] = a[p + T];
    }
  }, cbc$1;
}
var ede, hasRequiredEde;
function requireEde() {
  if (hasRequiredEde)
    return ede;
  hasRequiredEde = 1;
  var e = requireMinimalisticAssert(), t = requireInherits_browser(), o = requireCipher(), r = requireDes$1();
  function h(p, d) {
    e.equal(d.length, 24, "Invalid key length");
    var b = d.slice(0, 8), g = d.slice(8, 16), w = d.slice(16, 24);
    p === "encrypt" ? this.ciphers = [
      r.create({ type: "encrypt", key: b }),
      r.create({ type: "decrypt", key: g }),
      r.create({ type: "encrypt", key: w })
    ] : this.ciphers = [
      r.create({ type: "decrypt", key: w }),
      r.create({ type: "encrypt", key: g }),
      r.create({ type: "decrypt", key: b })
    ];
  }
  function a(p) {
    o.call(this, p);
    var d = new h(this.type, this.options.key);
    this._edeState = d;
  }
  return t(a, o), ede = a, a.create = function(p) {
    return new a(p);
  }, a.prototype._update = function(p, d, b, g) {
    var w = this._edeState;
    w.ciphers[0]._update(p, d, b, g), w.ciphers[1]._update(b, g, b, g), w.ciphers[2]._update(b, g, b, g);
  }, a.prototype._pad = r.prototype._pad, a.prototype._unpad = r.prototype._unpad, ede;
}
var hasRequiredDes;
function requireDes() {
  return hasRequiredDes || (hasRequiredDes = 1, des$1.utils = requireUtils$3(), des$1.Cipher = requireCipher(), des$1.DES = requireDes$1(), des$1.CBC = requireCbc$1(), des$1.EDE = requireEde()), des$1;
}
var browserifyDes, hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
  if (hasRequiredBrowserifyDes)
    return browserifyDes;
  hasRequiredBrowserifyDes = 1;
  var e = requireCipherBase(), t = requireDes(), o = requireInherits_browser(), r = requireSafeBuffer$1().Buffer, h = {
    "des-ede3-cbc": t.CBC.instantiate(t.EDE),
    "des-ede3": t.EDE,
    "des-ede-cbc": t.CBC.instantiate(t.EDE),
    "des-ede": t.EDE,
    "des-cbc": t.CBC.instantiate(t.DES),
    "des-ecb": t.DES
  };
  h.des = h["des-cbc"], h.des3 = h["des-ede3-cbc"], browserifyDes = a, o(a, e);
  function a(p) {
    e.call(this);
    var d = p.mode.toLowerCase(), b = h[d], g;
    p.decrypt ? g = "decrypt" : g = "encrypt";
    var w = p.key;
    r.isBuffer(w) || (w = r.from(w)), (d === "des-ede" || d === "des-ede-cbc") && (w = r.concat([w, w.slice(0, 8)]));
    var C = p.iv;
    r.isBuffer(C) || (C = r.from(C)), this._des = b.create({
      key: w,
      iv: C,
      type: g
    });
  }
  return a.prototype._update = function(p) {
    return r.from(this._des.update(p));
  }, a.prototype._final = function() {
    return r.from(this._des.final());
  }, browserifyDes;
}
var browser$5 = {}, encrypter = {}, ecb = {}, hasRequiredEcb;
function requireEcb() {
  return hasRequiredEcb || (hasRequiredEcb = 1, ecb.encrypt = function(e, t) {
    return e._cipher.encryptBlock(t);
  }, ecb.decrypt = function(e, t) {
    return e._cipher.decryptBlock(t);
  }), ecb;
}
var cbc = {}, bufferXor, hasRequiredBufferXor;
function requireBufferXor() {
  return hasRequiredBufferXor || (hasRequiredBufferXor = 1, bufferXor = function(e, t) {
    for (var o = Math.min(e.length, t.length), r = new bufferExports.Buffer(o), h = 0; h < o; ++h)
      r[h] = e[h] ^ t[h];
    return r;
  }), bufferXor;
}
var hasRequiredCbc;
function requireCbc() {
  if (hasRequiredCbc)
    return cbc;
  hasRequiredCbc = 1;
  var e = requireBufferXor();
  return cbc.encrypt = function(t, o) {
    var r = e(o, t._prev);
    return t._prev = t._cipher.encryptBlock(r), t._prev;
  }, cbc.decrypt = function(t, o) {
    var r = t._prev;
    t._prev = o;
    var h = t._cipher.decryptBlock(o);
    return e(h, r);
  }, cbc;
}
var cfb = {}, hasRequiredCfb;
function requireCfb() {
  if (hasRequiredCfb)
    return cfb;
  hasRequiredCfb = 1;
  var e = requireSafeBuffer$1().Buffer, t = requireBufferXor();
  function o(r, h, a) {
    var p = h.length, d = t(h, r._cache);
    return r._cache = r._cache.slice(p), r._prev = e.concat([r._prev, a ? h : d]), d;
  }
  return cfb.encrypt = function(r, h, a) {
    for (var p = e.allocUnsafe(0), d; h.length; )
      if (r._cache.length === 0 && (r._cache = r._cipher.encryptBlock(r._prev), r._prev = e.allocUnsafe(0)), r._cache.length <= h.length)
        d = r._cache.length, p = e.concat([p, o(r, h.slice(0, d), a)]), h = h.slice(d);
      else {
        p = e.concat([p, o(r, h, a)]);
        break;
      }
    return p;
  }, cfb;
}
var cfb8 = {}, hasRequiredCfb8;
function requireCfb8() {
  if (hasRequiredCfb8)
    return cfb8;
  hasRequiredCfb8 = 1;
  var e = requireSafeBuffer$1().Buffer;
  function t(o, r, h) {
    var a = o._cipher.encryptBlock(o._prev), p = a[0] ^ r;
    return o._prev = e.concat([
      o._prev.slice(1),
      e.from([h ? r : p])
    ]), p;
  }
  return cfb8.encrypt = function(o, r, h) {
    for (var a = r.length, p = e.allocUnsafe(a), d = -1; ++d < a; )
      p[d] = t(o, r[d], h);
    return p;
  }, cfb8;
}
var cfb1 = {}, hasRequiredCfb1;
function requireCfb1() {
  if (hasRequiredCfb1)
    return cfb1;
  hasRequiredCfb1 = 1;
  var e = requireSafeBuffer$1().Buffer;
  function t(r, h, a) {
    for (var p, d = -1, b = 8, g = 0, w, C; ++d < b; )
      p = r._cipher.encryptBlock(r._prev), w = h & 1 << 7 - d ? 128 : 0, C = p[0] ^ w, g += (C & 128) >> d % 8, r._prev = o(r._prev, a ? w : C);
    return g;
  }
  function o(r, h) {
    var a = r.length, p = -1, d = e.allocUnsafe(r.length);
    for (r = e.concat([r, e.from([h])]); ++p < a; )
      d[p] = r[p] << 1 | r[p + 1] >> 7;
    return d;
  }
  return cfb1.encrypt = function(r, h, a) {
    for (var p = h.length, d = e.allocUnsafe(p), b = -1; ++b < p; )
      d[b] = t(r, h[b], a);
    return d;
  }, cfb1;
}
var ofb = {}, hasRequiredOfb;
function requireOfb() {
  if (hasRequiredOfb)
    return ofb;
  hasRequiredOfb = 1;
  var e = requireBufferXor();
  function t(o) {
    return o._prev = o._cipher.encryptBlock(o._prev), o._prev;
  }
  return ofb.encrypt = function(o, r) {
    for (; o._cache.length < r.length; )
      o._cache = bufferExports.Buffer.concat([o._cache, t(o)]);
    var h = o._cache.slice(0, r.length);
    return o._cache = o._cache.slice(r.length), e(r, h);
  }, ofb;
}
var ctr = {}, incr32_1, hasRequiredIncr32;
function requireIncr32() {
  if (hasRequiredIncr32)
    return incr32_1;
  hasRequiredIncr32 = 1;
  function e(t) {
    for (var o = t.length, r; o--; )
      if (r = t.readUInt8(o), r === 255)
        t.writeUInt8(0, o);
      else {
        r++, t.writeUInt8(r, o);
        break;
      }
  }
  return incr32_1 = e, incr32_1;
}
var hasRequiredCtr;
function requireCtr() {
  if (hasRequiredCtr)
    return ctr;
  hasRequiredCtr = 1;
  var e = requireBufferXor(), t = requireSafeBuffer$1().Buffer, o = requireIncr32();
  function r(a) {
    var p = a._cipher.encryptBlockRaw(a._prev);
    return o(a._prev), p;
  }
  var h = 16;
  return ctr.encrypt = function(a, p) {
    var d = Math.ceil(p.length / h), b = a._cache.length;
    a._cache = t.concat([
      a._cache,
      t.allocUnsafe(d * h)
    ]);
    for (var g = 0; g < d; g++) {
      var w = r(a), C = b + g * h;
      a._cache.writeUInt32BE(w[0], C + 0), a._cache.writeUInt32BE(w[1], C + 4), a._cache.writeUInt32BE(w[2], C + 8), a._cache.writeUInt32BE(w[3], C + 12);
    }
    var T = a._cache.slice(0, p.length);
    return a._cache = a._cache.slice(p.length), e(p, T);
  }, ctr;
}
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modes_1, hasRequiredModes$1;
function requireModes$1() {
  if (hasRequiredModes$1)
    return modes_1;
  hasRequiredModes$1 = 1;
  var e = {
    ECB: requireEcb(),
    CBC: requireCbc(),
    CFB: requireCfb(),
    CFB8: requireCfb8(),
    CFB1: requireCfb1(),
    OFB: requireOfb(),
    CTR: requireCtr(),
    GCM: requireCtr()
  }, t = require$$2;
  for (var o in t)
    t[o].module = e[t[o].mode];
  return modes_1 = t, modes_1;
}
var aes = {}, hasRequiredAes;
function requireAes() {
  if (hasRequiredAes)
    return aes;
  hasRequiredAes = 1;
  var e = requireSafeBuffer$1().Buffer;
  function t(d) {
    e.isBuffer(d) || (d = e.from(d));
    for (var b = d.length / 4 | 0, g = new Array(b), w = 0; w < b; w++)
      g[w] = d.readUInt32BE(w * 4);
    return g;
  }
  function o(d) {
    for (var b = 0; b < d.length; d++)
      d[b] = 0;
  }
  function r(d, b, g, w, C) {
    for (var T = g[0], k = g[1], q = g[2], O = g[3], N = d[0] ^ b[0], j = d[1] ^ b[1], U = d[2] ^ b[2], H = d[3] ^ b[3], z, ee, ne, le, Z = 4, ie = 1; ie < C; ie++)
      z = T[N >>> 24] ^ k[j >>> 16 & 255] ^ q[U >>> 8 & 255] ^ O[H & 255] ^ b[Z++], ee = T[j >>> 24] ^ k[U >>> 16 & 255] ^ q[H >>> 8 & 255] ^ O[N & 255] ^ b[Z++], ne = T[U >>> 24] ^ k[H >>> 16 & 255] ^ q[N >>> 8 & 255] ^ O[j & 255] ^ b[Z++], le = T[H >>> 24] ^ k[N >>> 16 & 255] ^ q[j >>> 8 & 255] ^ O[U & 255] ^ b[Z++], N = z, j = ee, U = ne, H = le;
    return z = (w[N >>> 24] << 24 | w[j >>> 16 & 255] << 16 | w[U >>> 8 & 255] << 8 | w[H & 255]) ^ b[Z++], ee = (w[j >>> 24] << 24 | w[U >>> 16 & 255] << 16 | w[H >>> 8 & 255] << 8 | w[N & 255]) ^ b[Z++], ne = (w[U >>> 24] << 24 | w[H >>> 16 & 255] << 16 | w[N >>> 8 & 255] << 8 | w[j & 255]) ^ b[Z++], le = (w[H >>> 24] << 24 | w[N >>> 16 & 255] << 16 | w[j >>> 8 & 255] << 8 | w[U & 255]) ^ b[Z++], z = z >>> 0, ee = ee >>> 0, ne = ne >>> 0, le = le >>> 0, [z, ee, ne, le];
  }
  var h = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], a = function() {
    for (var d = new Array(256), b = 0; b < 256; b++)
      b < 128 ? d[b] = b << 1 : d[b] = b << 1 ^ 283;
    for (var g = [], w = [], C = [[], [], [], []], T = [[], [], [], []], k = 0, q = 0, O = 0; O < 256; ++O) {
      var N = q ^ q << 1 ^ q << 2 ^ q << 3 ^ q << 4;
      N = N >>> 8 ^ N & 255 ^ 99, g[k] = N, w[N] = k;
      var j = d[k], U = d[j], H = d[U], z = d[N] * 257 ^ N * 16843008;
      C[0][k] = z << 24 | z >>> 8, C[1][k] = z << 16 | z >>> 16, C[2][k] = z << 8 | z >>> 24, C[3][k] = z, z = H * 16843009 ^ U * 65537 ^ j * 257 ^ k * 16843008, T[0][N] = z << 24 | z >>> 8, T[1][N] = z << 16 | z >>> 16, T[2][N] = z << 8 | z >>> 24, T[3][N] = z, k === 0 ? k = q = 1 : (k = j ^ d[d[d[H ^ j]]], q ^= d[d[q]]);
    }
    return {
      SBOX: g,
      INV_SBOX: w,
      SUB_MIX: C,
      INV_SUB_MIX: T
    };
  }();
  function p(d) {
    this._key = t(d), this._reset();
  }
  return p.blockSize = 4 * 4, p.keySize = 256 / 8, p.prototype.blockSize = p.blockSize, p.prototype.keySize = p.keySize, p.prototype._reset = function() {
    for (var d = this._key, b = d.length, g = b + 6, w = (g + 1) * 4, C = [], T = 0; T < b; T++)
      C[T] = d[T];
    for (T = b; T < w; T++) {
      var k = C[T - 1];
      T % b === 0 ? (k = k << 8 | k >>> 24, k = a.SBOX[k >>> 24] << 24 | a.SBOX[k >>> 16 & 255] << 16 | a.SBOX[k >>> 8 & 255] << 8 | a.SBOX[k & 255], k ^= h[T / b | 0] << 24) : b > 6 && T % b === 4 && (k = a.SBOX[k >>> 24] << 24 | a.SBOX[k >>> 16 & 255] << 16 | a.SBOX[k >>> 8 & 255] << 8 | a.SBOX[k & 255]), C[T] = C[T - b] ^ k;
    }
    for (var q = [], O = 0; O < w; O++) {
      var N = w - O, j = C[N - (O % 4 ? 0 : 4)];
      O < 4 || N <= 4 ? q[O] = j : q[O] = a.INV_SUB_MIX[0][a.SBOX[j >>> 24]] ^ a.INV_SUB_MIX[1][a.SBOX[j >>> 16 & 255]] ^ a.INV_SUB_MIX[2][a.SBOX[j >>> 8 & 255]] ^ a.INV_SUB_MIX[3][a.SBOX[j & 255]];
    }
    this._nRounds = g, this._keySchedule = C, this._invKeySchedule = q;
  }, p.prototype.encryptBlockRaw = function(d) {
    return d = t(d), r(d, this._keySchedule, a.SUB_MIX, a.SBOX, this._nRounds);
  }, p.prototype.encryptBlock = function(d) {
    var b = this.encryptBlockRaw(d), g = e.allocUnsafe(16);
    return g.writeUInt32BE(b[0], 0), g.writeUInt32BE(b[1], 4), g.writeUInt32BE(b[2], 8), g.writeUInt32BE(b[3], 12), g;
  }, p.prototype.decryptBlock = function(d) {
    d = t(d);
    var b = d[1];
    d[1] = d[3], d[3] = b;
    var g = r(d, this._invKeySchedule, a.INV_SUB_MIX, a.INV_SBOX, this._nRounds), w = e.allocUnsafe(16);
    return w.writeUInt32BE(g[0], 0), w.writeUInt32BE(g[3], 4), w.writeUInt32BE(g[2], 8), w.writeUInt32BE(g[1], 12), w;
  }, p.prototype.scrub = function() {
    o(this._keySchedule), o(this._invKeySchedule), o(this._key);
  }, aes.AES = p, aes;
}
var ghash, hasRequiredGhash;
function requireGhash() {
  if (hasRequiredGhash)
    return ghash;
  hasRequiredGhash = 1;
  var e = requireSafeBuffer$1().Buffer, t = e.alloc(16, 0);
  function o(a) {
    return [
      a.readUInt32BE(0),
      a.readUInt32BE(4),
      a.readUInt32BE(8),
      a.readUInt32BE(12)
    ];
  }
  function r(a) {
    var p = e.allocUnsafe(16);
    return p.writeUInt32BE(a[0] >>> 0, 0), p.writeUInt32BE(a[1] >>> 0, 4), p.writeUInt32BE(a[2] >>> 0, 8), p.writeUInt32BE(a[3] >>> 0, 12), p;
  }
  function h(a) {
    this.h = a, this.state = e.alloc(16, 0), this.cache = e.allocUnsafe(0);
  }
  return h.prototype.ghash = function(a) {
    for (var p = -1; ++p < a.length; )
      this.state[p] ^= a[p];
    this._multiply();
  }, h.prototype._multiply = function() {
    for (var a = o(this.h), p = [0, 0, 0, 0], d, b, g, w = -1; ++w < 128; ) {
      for (b = (this.state[~~(w / 8)] & 1 << 7 - w % 8) !== 0, b && (p[0] ^= a[0], p[1] ^= a[1], p[2] ^= a[2], p[3] ^= a[3]), g = (a[3] & 1) !== 0, d = 3; d > 0; d--)
        a[d] = a[d] >>> 1 | (a[d - 1] & 1) << 31;
      a[0] = a[0] >>> 1, g && (a[0] = a[0] ^ 225 << 24);
    }
    this.state = r(p);
  }, h.prototype.update = function(a) {
    this.cache = e.concat([this.cache, a]);
    for (var p; this.cache.length >= 16; )
      p = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(p);
  }, h.prototype.final = function(a, p) {
    return this.cache.length && this.ghash(e.concat([this.cache, t], 16)), this.ghash(r([0, a, 0, p])), this.state;
  }, ghash = h, ghash;
}
var authCipher, hasRequiredAuthCipher;
function requireAuthCipher() {
  if (hasRequiredAuthCipher)
    return authCipher;
  hasRequiredAuthCipher = 1;
  var e = requireAes(), t = requireSafeBuffer$1().Buffer, o = requireCipherBase(), r = requireInherits_browser(), h = requireGhash(), a = requireBufferXor(), p = requireIncr32();
  function d(w, C) {
    var T = 0;
    w.length !== C.length && T++;
    for (var k = Math.min(w.length, C.length), q = 0; q < k; ++q)
      T += w[q] ^ C[q];
    return T;
  }
  function b(w, C, T) {
    if (C.length === 12)
      return w._finID = t.concat([C, t.from([0, 0, 0, 1])]), t.concat([C, t.from([0, 0, 0, 2])]);
    var k = new h(T), q = C.length, O = q % 16;
    k.update(C), O && (O = 16 - O, k.update(t.alloc(O, 0))), k.update(t.alloc(8, 0));
    var N = q * 8, j = t.alloc(8);
    j.writeUIntBE(N, 0, 8), k.update(j), w._finID = k.state;
    var U = t.from(w._finID);
    return p(U), U;
  }
  function g(w, C, T, k) {
    o.call(this);
    var q = t.alloc(4, 0);
    this._cipher = new e.AES(C);
    var O = this._cipher.encryptBlock(q);
    this._ghash = new h(O), T = b(this, T, O), this._prev = t.from(T), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = k, this._alen = 0, this._len = 0, this._mode = w, this._authTag = null, this._called = !1;
  }
  return r(g, o), g.prototype._update = function(w) {
    if (!this._called && this._alen) {
      var C = 16 - this._alen % 16;
      C < 16 && (C = t.alloc(C, 0), this._ghash.update(C));
    }
    this._called = !0;
    var T = this._mode.encrypt(this, w);
    return this._decrypt ? this._ghash.update(w) : this._ghash.update(T), this._len += w.length, T;
  }, g.prototype._final = function() {
    if (this._decrypt && !this._authTag)
      throw new Error("Unsupported state or unable to authenticate data");
    var w = a(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && d(w, this._authTag))
      throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = w, this._cipher.scrub();
  }, g.prototype.getAuthTag = function() {
    if (this._decrypt || !t.isBuffer(this._authTag))
      throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, g.prototype.setAuthTag = function(w) {
    if (!this._decrypt)
      throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = w;
  }, g.prototype.setAAD = function(w) {
    if (this._called)
      throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(w), this._alen += w.length;
  }, authCipher = g, authCipher;
}
var streamCipher, hasRequiredStreamCipher;
function requireStreamCipher() {
  if (hasRequiredStreamCipher)
    return streamCipher;
  hasRequiredStreamCipher = 1;
  var e = requireAes(), t = requireSafeBuffer$1().Buffer, o = requireCipherBase(), r = requireInherits_browser();
  function h(a, p, d, b) {
    o.call(this), this._cipher = new e.AES(p), this._prev = t.from(d), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = b, this._mode = a;
  }
  return r(h, o), h.prototype._update = function(a) {
    return this._mode.encrypt(this, a, this._decrypt);
  }, h.prototype._final = function() {
    this._cipher.scrub();
  }, streamCipher = h, streamCipher;
}
var evp_bytestokey, hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
  if (hasRequiredEvp_bytestokey)
    return evp_bytestokey;
  hasRequiredEvp_bytestokey = 1;
  var e = requireSafeBuffer$1().Buffer, t = requireMd5_js();
  function o(r, h, a, p) {
    if (e.isBuffer(r) || (r = e.from(r, "binary")), h && (e.isBuffer(h) || (h = e.from(h, "binary")), h.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var d = a / 8, b = e.alloc(d), g = e.alloc(p || 0), w = e.alloc(0); d > 0 || p > 0; ) {
      var C = new t();
      C.update(w), C.update(r), h && C.update(h), w = C.digest();
      var T = 0;
      if (d > 0) {
        var k = b.length - d;
        T = Math.min(d, w.length), w.copy(b, k, 0, T), d -= T;
      }
      if (T < w.length && p > 0) {
        var q = g.length - p, O = Math.min(p, w.length - T);
        w.copy(g, q, T, T + O), p -= O;
      }
    }
    return w.fill(0), { key: b, iv: g };
  }
  return evp_bytestokey = o, evp_bytestokey;
}
var hasRequiredEncrypter;
function requireEncrypter() {
  if (hasRequiredEncrypter)
    return encrypter;
  hasRequiredEncrypter = 1;
  var e = requireModes$1(), t = requireAuthCipher(), o = requireSafeBuffer$1().Buffer, r = requireStreamCipher(), h = requireCipherBase(), a = requireAes(), p = requireEvp_bytestokey(), d = requireInherits_browser();
  function b(k, q, O) {
    h.call(this), this._cache = new w(), this._cipher = new a.AES(q), this._prev = o.from(O), this._mode = k, this._autopadding = !0;
  }
  d(b, h), b.prototype._update = function(k) {
    this._cache.add(k);
    for (var q, O, N = []; q = this._cache.get(); )
      O = this._mode.encrypt(this, q), N.push(O);
    return o.concat(N);
  };
  var g = o.alloc(16, 16);
  b.prototype._final = function() {
    var k = this._cache.flush();
    if (this._autopadding)
      return k = this._mode.encrypt(this, k), this._cipher.scrub(), k;
    if (!k.equals(g))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, b.prototype.setAutoPadding = function(k) {
    return this._autopadding = !!k, this;
  };
  function w() {
    this.cache = o.allocUnsafe(0);
  }
  w.prototype.add = function(k) {
    this.cache = o.concat([this.cache, k]);
  }, w.prototype.get = function() {
    if (this.cache.length > 15) {
      var k = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), k;
    }
    return null;
  }, w.prototype.flush = function() {
    for (var k = 16 - this.cache.length, q = o.allocUnsafe(k), O = -1; ++O < k; )
      q.writeUInt8(k, O);
    return o.concat([this.cache, q]);
  };
  function C(k, q, O) {
    var N = e[k.toLowerCase()];
    if (!N)
      throw new TypeError("invalid suite type");
    if (typeof q == "string" && (q = o.from(q)), q.length !== N.key / 8)
      throw new TypeError("invalid key length " + q.length);
    if (typeof O == "string" && (O = o.from(O)), N.mode !== "GCM" && O.length !== N.iv)
      throw new TypeError("invalid iv length " + O.length);
    return N.type === "stream" ? new r(N.module, q, O) : N.type === "auth" ? new t(N.module, q, O) : new b(N.module, q, O);
  }
  function T(k, q) {
    var O = e[k.toLowerCase()];
    if (!O)
      throw new TypeError("invalid suite type");
    var N = p(q, !1, O.key, O.iv);
    return C(k, N.key, N.iv);
  }
  return encrypter.createCipheriv = C, encrypter.createCipher = T, encrypter;
}
var decrypter = {}, hasRequiredDecrypter;
function requireDecrypter() {
  if (hasRequiredDecrypter)
    return decrypter;
  hasRequiredDecrypter = 1;
  var e = requireAuthCipher(), t = requireSafeBuffer$1().Buffer, o = requireModes$1(), r = requireStreamCipher(), h = requireCipherBase(), a = requireAes(), p = requireEvp_bytestokey(), d = requireInherits_browser();
  function b(k, q, O) {
    h.call(this), this._cache = new g(), this._last = void 0, this._cipher = new a.AES(q), this._prev = t.from(O), this._mode = k, this._autopadding = !0;
  }
  d(b, h), b.prototype._update = function(k) {
    this._cache.add(k);
    for (var q, O, N = []; q = this._cache.get(this._autopadding); )
      O = this._mode.decrypt(this, q), N.push(O);
    return t.concat(N);
  }, b.prototype._final = function() {
    var k = this._cache.flush();
    if (this._autopadding)
      return w(this._mode.decrypt(this, k));
    if (k)
      throw new Error("data not multiple of block length");
  }, b.prototype.setAutoPadding = function(k) {
    return this._autopadding = !!k, this;
  };
  function g() {
    this.cache = t.allocUnsafe(0);
  }
  g.prototype.add = function(k) {
    this.cache = t.concat([this.cache, k]);
  }, g.prototype.get = function(k) {
    var q;
    if (k) {
      if (this.cache.length > 16)
        return q = this.cache.slice(0, 16), this.cache = this.cache.slice(16), q;
    } else if (this.cache.length >= 16)
      return q = this.cache.slice(0, 16), this.cache = this.cache.slice(16), q;
    return null;
  }, g.prototype.flush = function() {
    if (this.cache.length)
      return this.cache;
  };
  function w(k) {
    var q = k[15];
    if (q < 1 || q > 16)
      throw new Error("unable to decrypt data");
    for (var O = -1; ++O < q; )
      if (k[O + (16 - q)] !== q)
        throw new Error("unable to decrypt data");
    if (q !== 16)
      return k.slice(0, 16 - q);
  }
  function C(k, q, O) {
    var N = o[k.toLowerCase()];
    if (!N)
      throw new TypeError("invalid suite type");
    if (typeof O == "string" && (O = t.from(O)), N.mode !== "GCM" && O.length !== N.iv)
      throw new TypeError("invalid iv length " + O.length);
    if (typeof q == "string" && (q = t.from(q)), q.length !== N.key / 8)
      throw new TypeError("invalid key length " + q.length);
    return N.type === "stream" ? new r(N.module, q, O, !0) : N.type === "auth" ? new e(N.module, q, O, !0) : new b(N.module, q, O);
  }
  function T(k, q) {
    var O = o[k.toLowerCase()];
    if (!O)
      throw new TypeError("invalid suite type");
    var N = p(q, !1, O.key, O.iv);
    return C(k, N.key, N.iv);
  }
  return decrypter.createDecipher = T, decrypter.createDecipheriv = C, decrypter;
}
var hasRequiredBrowser$6;
function requireBrowser$6() {
  if (hasRequiredBrowser$6)
    return browser$5;
  hasRequiredBrowser$6 = 1;
  var e = requireEncrypter(), t = requireDecrypter(), o = require$$2;
  function r() {
    return Object.keys(o);
  }
  return browser$5.createCipher = browser$5.Cipher = e.createCipher, browser$5.createCipheriv = browser$5.Cipheriv = e.createCipheriv, browser$5.createDecipher = browser$5.Decipher = t.createDecipher, browser$5.createDecipheriv = browser$5.Decipheriv = t.createDecipheriv, browser$5.listCiphers = browser$5.getCiphers = r, browser$5;
}
var modes = {}, hasRequiredModes;
function requireModes() {
  return hasRequiredModes || (hasRequiredModes = 1, function(e) {
    e["des-ecb"] = {
      key: 8,
      iv: 0
    }, e["des-cbc"] = e.des = {
      key: 8,
      iv: 8
    }, e["des-ede3-cbc"] = e.des3 = {
      key: 24,
      iv: 8
    }, e["des-ede3"] = {
      key: 24,
      iv: 0
    }, e["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, e["des-ede"] = {
      key: 16,
      iv: 0
    };
  }(modes)), modes;
}
var hasRequiredBrowser$5;
function requireBrowser$5() {
  if (hasRequiredBrowser$5)
    return browser$6;
  hasRequiredBrowser$5 = 1;
  var e = requireBrowserifyDes(), t = requireBrowser$6(), o = requireModes$1(), r = requireModes(), h = requireEvp_bytestokey();
  function a(w, C) {
    w = w.toLowerCase();
    var T, k;
    if (o[w])
      T = o[w].key, k = o[w].iv;
    else if (r[w])
      T = r[w].key * 8, k = r[w].iv;
    else
      throw new TypeError("invalid suite type");
    var q = h(C, !1, T, k);
    return d(w, q.key, q.iv);
  }
  function p(w, C) {
    w = w.toLowerCase();
    var T, k;
    if (o[w])
      T = o[w].key, k = o[w].iv;
    else if (r[w])
      T = r[w].key * 8, k = r[w].iv;
    else
      throw new TypeError("invalid suite type");
    var q = h(C, !1, T, k);
    return b(w, q.key, q.iv);
  }
  function d(w, C, T) {
    if (w = w.toLowerCase(), o[w])
      return t.createCipheriv(w, C, T);
    if (r[w])
      return new e({ key: C, iv: T, mode: w });
    throw new TypeError("invalid suite type");
  }
  function b(w, C, T) {
    if (w = w.toLowerCase(), o[w])
      return t.createDecipheriv(w, C, T);
    if (r[w])
      return new e({ key: C, iv: T, mode: w, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function g() {
    return Object.keys(r).concat(t.getCiphers());
  }
  return browser$6.createCipher = browser$6.Cipher = a, browser$6.createCipheriv = browser$6.Cipheriv = d, browser$6.createDecipher = browser$6.Decipher = p, browser$6.createDecipheriv = browser$6.Decipheriv = b, browser$6.listCiphers = browser$6.getCiphers = g, browser$6;
}
var browser$4 = {}, bn$2 = { exports: {} }, hasRequiredBn$2;
function requireBn$2() {
  return hasRequiredBn$2 || (hasRequiredBn$2 = 1, function(e) {
    (function(t, o) {
      function r(I, P) {
        if (!I)
          throw new Error(P || "Assertion failed");
      }
      function h(I, P) {
        I.super_ = P;
        var f = function() {
        };
        f.prototype = P.prototype, I.prototype = new f(), I.prototype.constructor = I;
      }
      function a(I, P, f) {
        if (a.isBN(I))
          return I;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, I !== null && ((P === "le" || P === "be") && (f = P, P = 10), this._init(I || 0, P || 10, f || "be"));
      }
      typeof t == "object" ? t.exports = a : o.BN = a, a.BN = a, a.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = requireBuffer$1().Buffer;
      } catch {
      }
      a.isBN = function(I) {
        return I instanceof a ? !0 : I !== null && typeof I == "object" && I.constructor.wordSize === a.wordSize && Array.isArray(I.words);
      }, a.max = function(I, P) {
        return I.cmp(P) > 0 ? I : P;
      }, a.min = function(I, P) {
        return I.cmp(P) < 0 ? I : P;
      }, a.prototype._init = function(I, P, f) {
        if (typeof I == "number")
          return this._initNumber(I, P, f);
        if (typeof I == "object")
          return this._initArray(I, P, f);
        P === "hex" && (P = 16), r(P === (P | 0) && P >= 2 && P <= 36), I = I.toString().replace(/\s+/g, "");
        var y = 0;
        I[0] === "-" && (y++, this.negative = 1), y < I.length && (P === 16 ? this._parseHex(I, y, f) : (this._parseBase(I, P, y), f === "le" && this._initArray(this.toArray(), P, f)));
      }, a.prototype._initNumber = function(I, P, f) {
        I < 0 && (this.negative = 1, I = -I), I < 67108864 ? (this.words = [I & 67108863], this.length = 1) : I < 4503599627370496 ? (this.words = [
          I & 67108863,
          I / 67108864 & 67108863
        ], this.length = 2) : (r(I < 9007199254740992), this.words = [
          I & 67108863,
          I / 67108864 & 67108863,
          1
        ], this.length = 3), f === "le" && this._initArray(this.toArray(), P, f);
      }, a.prototype._initArray = function(I, P, f) {
        if (r(typeof I.length == "number"), I.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(I.length / 3), this.words = new Array(this.length);
        for (var y = 0; y < this.length; y++)
          this.words[y] = 0;
        var v, M, B = 0;
        if (f === "be")
          for (y = I.length - 1, v = 0; y >= 0; y -= 3)
            M = I[y] | I[y - 1] << 8 | I[y - 2] << 16, this.words[v] |= M << B & 67108863, this.words[v + 1] = M >>> 26 - B & 67108863, B += 24, B >= 26 && (B -= 26, v++);
        else if (f === "le")
          for (y = 0, v = 0; y < I.length; y += 3)
            M = I[y] | I[y + 1] << 8 | I[y + 2] << 16, this.words[v] |= M << B & 67108863, this.words[v + 1] = M >>> 26 - B & 67108863, B += 24, B >= 26 && (B -= 26, v++);
        return this.strip();
      };
      function d(I, P) {
        var f = I.charCodeAt(P);
        return f >= 65 && f <= 70 ? f - 55 : f >= 97 && f <= 102 ? f - 87 : f - 48 & 15;
      }
      function b(I, P, f) {
        var y = d(I, f);
        return f - 1 >= P && (y |= d(I, f - 1) << 4), y;
      }
      a.prototype._parseHex = function(I, P, f) {
        this.length = Math.ceil((I.length - P) / 6), this.words = new Array(this.length);
        for (var y = 0; y < this.length; y++)
          this.words[y] = 0;
        var v = 0, M = 0, B;
        if (f === "be")
          for (y = I.length - 1; y >= P; y -= 2)
            B = b(I, P, y) << v, this.words[M] |= B & 67108863, v >= 18 ? (v -= 18, M += 1, this.words[M] |= B >>> 26) : v += 8;
        else {
          var S = I.length - P;
          for (y = S % 2 === 0 ? P + 1 : P; y < I.length; y += 2)
            B = b(I, P, y) << v, this.words[M] |= B & 67108863, v >= 18 ? (v -= 18, M += 1, this.words[M] |= B >>> 26) : v += 8;
        }
        this.strip();
      };
      function g(I, P, f, y) {
        for (var v = 0, M = Math.min(I.length, f), B = P; B < M; B++) {
          var S = I.charCodeAt(B) - 48;
          v *= y, S >= 49 ? v += S - 49 + 10 : S >= 17 ? v += S - 17 + 10 : v += S;
        }
        return v;
      }
      a.prototype._parseBase = function(I, P, f) {
        this.words = [0], this.length = 1;
        for (var y = 0, v = 1; v <= 67108863; v *= P)
          y++;
        y--, v = v / P | 0;
        for (var M = I.length - f, B = M % y, S = Math.min(M, M - B) + f, _ = 0, E = f; E < S; E += y)
          _ = g(I, E, E + y, P), this.imuln(v), this.words[0] + _ < 67108864 ? this.words[0] += _ : this._iaddn(_);
        if (B !== 0) {
          var m = 1;
          for (_ = g(I, E, I.length, P), E = 0; E < B; E++)
            m *= P;
          this.imuln(m), this.words[0] + _ < 67108864 ? this.words[0] += _ : this._iaddn(_);
        }
        this.strip();
      }, a.prototype.copy = function(I) {
        I.words = new Array(this.length);
        for (var P = 0; P < this.length; P++)
          I.words[P] = this.words[P];
        I.length = this.length, I.negative = this.negative, I.red = this.red;
      }, a.prototype.clone = function() {
        var I = new a(null);
        return this.copy(I), I;
      }, a.prototype._expand = function(I) {
        for (; this.length < I; )
          this.words[this.length++] = 0;
        return this;
      }, a.prototype.strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, a.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, a.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var w = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], C = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], T = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      a.prototype.toString = function(I, P) {
        I = I || 10, P = P | 0 || 1;
        var f;
        if (I === 16 || I === "hex") {
          f = "";
          for (var y = 0, v = 0, M = 0; M < this.length; M++) {
            var B = this.words[M], S = ((B << y | v) & 16777215).toString(16);
            v = B >>> 24 - y & 16777215, v !== 0 || M !== this.length - 1 ? f = w[6 - S.length] + S + f : f = S + f, y += 2, y >= 26 && (y -= 26, M--);
          }
          for (v !== 0 && (f = v.toString(16) + f); f.length % P !== 0; )
            f = "0" + f;
          return this.negative !== 0 && (f = "-" + f), f;
        }
        if (I === (I | 0) && I >= 2 && I <= 36) {
          var _ = C[I], E = T[I];
          f = "";
          var m = this.clone();
          for (m.negative = 0; !m.isZero(); ) {
            var A = m.modn(E).toString(I);
            m = m.idivn(E), m.isZero() ? f = A + f : f = w[_ - A.length] + A + f;
          }
          for (this.isZero() && (f = "0" + f); f.length % P !== 0; )
            f = "0" + f;
          return this.negative !== 0 && (f = "-" + f), f;
        }
        r(!1, "Base should be between 2 and 36");
      }, a.prototype.toNumber = function() {
        var I = this.words[0];
        return this.length === 2 ? I += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? I += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -I : I;
      }, a.prototype.toJSON = function() {
        return this.toString(16);
      }, a.prototype.toBuffer = function(I, P) {
        return r(typeof p < "u"), this.toArrayLike(p, I, P);
      }, a.prototype.toArray = function(I, P) {
        return this.toArrayLike(Array, I, P);
      }, a.prototype.toArrayLike = function(I, P, f) {
        var y = this.byteLength(), v = f || Math.max(1, y);
        r(y <= v, "byte array longer than desired length"), r(v > 0, "Requested array length <= 0"), this.strip();
        var M = P === "le", B = new I(v), S, _, E = this.clone();
        if (M) {
          for (_ = 0; !E.isZero(); _++)
            S = E.andln(255), E.iushrn(8), B[_] = S;
          for (; _ < v; _++)
            B[_] = 0;
        } else {
          for (_ = 0; _ < v - y; _++)
            B[_] = 0;
          for (_ = 0; !E.isZero(); _++)
            S = E.andln(255), E.iushrn(8), B[v - _ - 1] = S;
        }
        return B;
      }, Math.clz32 ? a.prototype._countBits = function(I) {
        return 32 - Math.clz32(I);
      } : a.prototype._countBits = function(I) {
        var P = I, f = 0;
        return P >= 4096 && (f += 13, P >>>= 13), P >= 64 && (f += 7, P >>>= 7), P >= 8 && (f += 4, P >>>= 4), P >= 2 && (f += 2, P >>>= 2), f + P;
      }, a.prototype._zeroBits = function(I) {
        if (I === 0)
          return 26;
        var P = I, f = 0;
        return P & 8191 || (f += 13, P >>>= 13), P & 127 || (f += 7, P >>>= 7), P & 15 || (f += 4, P >>>= 4), P & 3 || (f += 2, P >>>= 2), P & 1 || f++, f;
      }, a.prototype.bitLength = function() {
        var I = this.words[this.length - 1], P = this._countBits(I);
        return (this.length - 1) * 26 + P;
      };
      function k(I) {
        for (var P = new Array(I.bitLength()), f = 0; f < P.length; f++) {
          var y = f / 26 | 0, v = f % 26;
          P[f] = (I.words[y] & 1 << v) >>> v;
        }
        return P;
      }
      a.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var I = 0, P = 0; P < this.length; P++) {
          var f = this._zeroBits(this.words[P]);
          if (I += f, f !== 26)
            break;
        }
        return I;
      }, a.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, a.prototype.toTwos = function(I) {
        return this.negative !== 0 ? this.abs().inotn(I).iaddn(1) : this.clone();
      }, a.prototype.fromTwos = function(I) {
        return this.testn(I - 1) ? this.notn(I).iaddn(1).ineg() : this.clone();
      }, a.prototype.isNeg = function() {
        return this.negative !== 0;
      }, a.prototype.neg = function() {
        return this.clone().ineg();
      }, a.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, a.prototype.iuor = function(I) {
        for (; this.length < I.length; )
          this.words[this.length++] = 0;
        for (var P = 0; P < I.length; P++)
          this.words[P] = this.words[P] | I.words[P];
        return this.strip();
      }, a.prototype.ior = function(I) {
        return r((this.negative | I.negative) === 0), this.iuor(I);
      }, a.prototype.or = function(I) {
        return this.length > I.length ? this.clone().ior(I) : I.clone().ior(this);
      }, a.prototype.uor = function(I) {
        return this.length > I.length ? this.clone().iuor(I) : I.clone().iuor(this);
      }, a.prototype.iuand = function(I) {
        var P;
        this.length > I.length ? P = I : P = this;
        for (var f = 0; f < P.length; f++)
          this.words[f] = this.words[f] & I.words[f];
        return this.length = P.length, this.strip();
      }, a.prototype.iand = function(I) {
        return r((this.negative | I.negative) === 0), this.iuand(I);
      }, a.prototype.and = function(I) {
        return this.length > I.length ? this.clone().iand(I) : I.clone().iand(this);
      }, a.prototype.uand = function(I) {
        return this.length > I.length ? this.clone().iuand(I) : I.clone().iuand(this);
      }, a.prototype.iuxor = function(I) {
        var P, f;
        this.length > I.length ? (P = this, f = I) : (P = I, f = this);
        for (var y = 0; y < f.length; y++)
          this.words[y] = P.words[y] ^ f.words[y];
        if (this !== P)
          for (; y < P.length; y++)
            this.words[y] = P.words[y];
        return this.length = P.length, this.strip();
      }, a.prototype.ixor = function(I) {
        return r((this.negative | I.negative) === 0), this.iuxor(I);
      }, a.prototype.xor = function(I) {
        return this.length > I.length ? this.clone().ixor(I) : I.clone().ixor(this);
      }, a.prototype.uxor = function(I) {
        return this.length > I.length ? this.clone().iuxor(I) : I.clone().iuxor(this);
      }, a.prototype.inotn = function(I) {
        r(typeof I == "number" && I >= 0);
        var P = Math.ceil(I / 26) | 0, f = I % 26;
        this._expand(P), f > 0 && P--;
        for (var y = 0; y < P; y++)
          this.words[y] = ~this.words[y] & 67108863;
        return f > 0 && (this.words[y] = ~this.words[y] & 67108863 >> 26 - f), this.strip();
      }, a.prototype.notn = function(I) {
        return this.clone().inotn(I);
      }, a.prototype.setn = function(I, P) {
        r(typeof I == "number" && I >= 0);
        var f = I / 26 | 0, y = I % 26;
        return this._expand(f + 1), P ? this.words[f] = this.words[f] | 1 << y : this.words[f] = this.words[f] & ~(1 << y), this.strip();
      }, a.prototype.iadd = function(I) {
        var P;
        if (this.negative !== 0 && I.negative === 0)
          return this.negative = 0, P = this.isub(I), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && I.negative !== 0)
          return I.negative = 0, P = this.isub(I), I.negative = 1, P._normSign();
        var f, y;
        this.length > I.length ? (f = this, y = I) : (f = I, y = this);
        for (var v = 0, M = 0; M < y.length; M++)
          P = (f.words[M] | 0) + (y.words[M] | 0) + v, this.words[M] = P & 67108863, v = P >>> 26;
        for (; v !== 0 && M < f.length; M++)
          P = (f.words[M] | 0) + v, this.words[M] = P & 67108863, v = P >>> 26;
        if (this.length = f.length, v !== 0)
          this.words[this.length] = v, this.length++;
        else if (f !== this)
          for (; M < f.length; M++)
            this.words[M] = f.words[M];
        return this;
      }, a.prototype.add = function(I) {
        var P;
        return I.negative !== 0 && this.negative === 0 ? (I.negative = 0, P = this.sub(I), I.negative ^= 1, P) : I.negative === 0 && this.negative !== 0 ? (this.negative = 0, P = I.sub(this), this.negative = 1, P) : this.length > I.length ? this.clone().iadd(I) : I.clone().iadd(this);
      }, a.prototype.isub = function(I) {
        if (I.negative !== 0) {
          I.negative = 0;
          var P = this.iadd(I);
          return I.negative = 1, P._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(I), this.negative = 1, this._normSign();
        var f = this.cmp(I);
        if (f === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var y, v;
        f > 0 ? (y = this, v = I) : (y = I, v = this);
        for (var M = 0, B = 0; B < v.length; B++)
          P = (y.words[B] | 0) - (v.words[B] | 0) + M, M = P >> 26, this.words[B] = P & 67108863;
        for (; M !== 0 && B < y.length; B++)
          P = (y.words[B] | 0) + M, M = P >> 26, this.words[B] = P & 67108863;
        if (M === 0 && B < y.length && y !== this)
          for (; B < y.length; B++)
            this.words[B] = y.words[B];
        return this.length = Math.max(this.length, B), y !== this && (this.negative = 1), this.strip();
      }, a.prototype.sub = function(I) {
        return this.clone().isub(I);
      };
      function q(I, P, f) {
        f.negative = P.negative ^ I.negative;
        var y = I.length + P.length | 0;
        f.length = y, y = y - 1 | 0;
        var v = I.words[0] | 0, M = P.words[0] | 0, B = v * M, S = B & 67108863, _ = B / 67108864 | 0;
        f.words[0] = S;
        for (var E = 1; E < y; E++) {
          for (var m = _ >>> 26, A = _ & 67108863, $ = Math.min(E, P.length - 1), X = Math.max(0, E - I.length + 1); X <= $; X++) {
            var oe = E - X | 0;
            v = I.words[oe] | 0, M = P.words[X] | 0, B = v * M + A, m += B / 67108864 | 0, A = B & 67108863;
          }
          f.words[E] = A | 0, _ = m | 0;
        }
        return _ !== 0 ? f.words[E] = _ | 0 : f.length--, f.strip();
      }
      var O = function(I, P, f) {
        var y = I.words, v = P.words, M = f.words, B = 0, S, _, E, m = y[0] | 0, A = m & 8191, $ = m >>> 13, X = y[1] | 0, oe = X & 8191, J = X >>> 13, W = y[2] | 0, Q = W & 8191, me = W >>> 13, be = y[3] | 0, Y = be & 8191, re = be >>> 13, de = y[4] | 0, Ae = de & 8191, qe = de >>> 13, x = y[5] | 0, L = x & 8191, D = x >>> 13, F = y[6] | 0, ue = F & 8191, ge = F >>> 13, ce = y[7] | 0, ve = ce & 8191, Re = ce >>> 13, ke = y[8] | 0, Ce = ke & 8191, Le = ke >>> 13, Oe = y[9] | 0, Pe = Oe & 8191, et = Oe >>> 13, Ye = v[0] | 0, Ne = Ye & 8191, Tt = Ye >>> 13, tt = v[1] | 0, Ue = tt & 8191, Ct = tt >>> 13, rt = v[2] | 0, Ke = rt & 8191, ii = rt >>> 13, it = v[3] | 0, $e = it & 8191, Ot = it >>> 13, vt = v[4] | 0, Fe = vt & 8191, ni = vt >>> 13, nt = v[5] | 0, ze = nt & 8191, oi = nt >>> 13, ot = v[6] | 0, Xe = ot & 8191, Dt = ot >>> 13, Ze = v[7] | 0, je = Ze & 8191, ri = Ze >>> 13, St = v[8] | 0, Qe = St & 8191, ai = St >>> 13, It = v[9] | 0, Je = It & 8191, si = It >>> 13;
        f.negative = I.negative ^ P.negative, f.length = 19, S = Math.imul(A, Ne), _ = Math.imul(A, Tt), _ = _ + Math.imul($, Ne) | 0, E = Math.imul($, Tt);
        var At = (B + S | 0) + ((_ & 8191) << 13) | 0;
        B = (E + (_ >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, S = Math.imul(oe, Ne), _ = Math.imul(oe, Tt), _ = _ + Math.imul(J, Ne) | 0, E = Math.imul(J, Tt), S = S + Math.imul(A, Ue) | 0, _ = _ + Math.imul(A, Ct) | 0, _ = _ + Math.imul($, Ue) | 0, E = E + Math.imul($, Ct) | 0;
        var Bt = (B + S | 0) + ((_ & 8191) << 13) | 0;
        B = (E + (_ >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, S = Math.imul(Q, Ne), _ = Math.imul(Q, Tt), _ = _ + Math.imul(me, Ne) | 0, E = Math.imul(me, Tt), S = S + Math.imul(oe, Ue) | 0, _ = _ + Math.imul(oe, Ct) | 0, _ = _ + Math.imul(J, Ue) | 0, E = E + Math.imul(J, Ct) | 0, S = S + Math.imul(A, Ke) | 0, _ = _ + Math.imul(A, ii) | 0, _ = _ + Math.imul($, Ke) | 0, E = E + Math.imul($, ii) | 0;
        var ui = (B + S | 0) + ((_ & 8191) << 13) | 0;
        B = (E + (_ >>> 13) | 0) + (ui >>> 26) | 0, ui &= 67108863, S = Math.imul(Y, Ne), _ = Math.imul(Y, Tt), _ = _ + Math.imul(re, Ne) | 0, E = Math.imul(re, Tt), S = S + Math.imul(Q, Ue) | 0, _ = _ + Math.imul(Q, Ct) | 0, _ = _ + Math.imul(me, Ue) | 0, E = E + Math.imul(me, Ct) | 0, S = S + Math.imul(oe, Ke) | 0, _ = _ + Math.imul(oe, ii) | 0, _ = _ + Math.imul(J, Ke) | 0, E = E + Math.imul(J, ii) | 0, S = S + Math.imul(A, $e) | 0, _ = _ + Math.imul(A, Ot) | 0, _ = _ + Math.imul($, $e) | 0, E = E + Math.imul($, Ot) | 0;
        var fi = (B + S | 0) + ((_ & 8191) << 13) | 0;
        B = (E + (_ >>> 13) | 0) + (fi >>> 26) | 0, fi &= 67108863, S = Math.imul(Ae, Ne), _ = Math.imul(Ae, Tt), _ = _ + Math.imul(qe, Ne) | 0, E = Math.imul(qe, Tt), S = S + Math.imul(Y, Ue) | 0, _ = _ + Math.imul(Y, Ct) | 0, _ = _ + Math.imul(re, Ue) | 0, E = E + Math.imul(re, Ct) | 0, S = S + Math.imul(Q, Ke) | 0, _ = _ + Math.imul(Q, ii) | 0, _ = _ + Math.imul(me, Ke) | 0, E = E + Math.imul(me, ii) | 0, S = S + Math.imul(oe, $e) | 0, _ = _ + Math.imul(oe, Ot) | 0, _ = _ + Math.imul(J, $e) | 0, E = E + Math.imul(J, Ot) | 0, S = S + Math.imul(A, Fe) | 0, _ = _ + Math.imul(A, ni) | 0, _ = _ + Math.imul($, Fe) | 0, E = E + Math.imul($, ni) | 0;
        var hi = (B + S | 0) + ((_ & 8191) << 13) | 0;
        B = (E + (_ >>> 13) | 0) + (hi >>> 26) | 0, hi &= 67108863, S = Math.imul(L, Ne), _ = Math.imul(L, Tt), _ = _ + Math.imul(D, Ne) | 0, E = Math.imul(D, Tt), S = S + Math.imul(Ae, Ue) | 0, _ = _ + Math.imul(Ae, Ct) | 0, _ = _ + Math.imul(qe, Ue) | 0, E = E + Math.imul(qe, Ct) | 0, S = S + Math.imul(Y, Ke) | 0, _ = _ + Math.imul(Y, ii) | 0, _ = _ + Math.imul(re, Ke) | 0, E = E + Math.imul(re, ii) | 0, S = S + Math.imul(Q, $e) | 0, _ = _ + Math.imul(Q, Ot) | 0, _ = _ + Math.imul(me, $e) | 0, E = E + Math.imul(me, Ot) | 0, S = S + Math.imul(oe, Fe) | 0, _ = _ + Math.imul(oe, ni) | 0, _ = _ + Math.imul(J, Fe) | 0, E = E + Math.imul(J, ni) | 0, S = S + Math.imul(A, ze) | 0, _ = _ + Math.imul(A, oi) | 0, _ = _ + Math.imul($, ze) | 0, E = E + Math.imul($, oi) | 0;
        var ci = (B + S | 0) + ((_ & 8191) << 13) | 0;
        B = (E + (_ >>> 13) | 0) + (ci >>> 26) | 0, ci &= 67108863, S = Math.imul(ue, Ne), _ = Math.imul(ue, Tt), _ = _ + Math.imul(ge, Ne) | 0, E = Math.imul(ge, Tt), S = S + Math.imul(L, Ue) | 0, _ = _ + Math.imul(L, Ct) | 0, _ = _ + Math.imul(D, Ue) | 0, E = E + Math.imul(D, Ct) | 0, S = S + Math.imul(Ae, Ke) | 0, _ = _ + Math.imul(Ae, ii) | 0, _ = _ + Math.imul(qe, Ke) | 0, E = E + Math.imul(qe, ii) | 0, S = S + Math.imul(Y, $e) | 0, _ = _ + Math.imul(Y, Ot) | 0, _ = _ + Math.imul(re, $e) | 0, E = E + Math.imul(re, Ot) | 0, S = S + Math.imul(Q, Fe) | 0, _ = _ + Math.imul(Q, ni) | 0, _ = _ + Math.imul(me, Fe) | 0, E = E + Math.imul(me, ni) | 0, S = S + Math.imul(oe, ze) | 0, _ = _ + Math.imul(oe, oi) | 0, _ = _ + Math.imul(J, ze) | 0, E = E + Math.imul(J, oi) | 0, S = S + Math.imul(A, Xe) | 0, _ = _ + Math.imul(A, Dt) | 0, _ = _ + Math.imul($, Xe) | 0, E = E + Math.imul($, Dt) | 0;
        var li = (B + S | 0) + ((_ & 8191) << 13) | 0;
        B = (E + (_ >>> 13) | 0) + (li >>> 26) | 0, li &= 67108863, S = Math.imul(ve, Ne), _ = Math.imul(ve, Tt), _ = _ + Math.imul(Re, Ne) | 0, E = Math.imul(Re, Tt), S = S + Math.imul(ue, Ue) | 0, _ = _ + Math.imul(ue, Ct) | 0, _ = _ + Math.imul(ge, Ue) | 0, E = E + Math.imul(ge, Ct) | 0, S = S + Math.imul(L, Ke) | 0, _ = _ + Math.imul(L, ii) | 0, _ = _ + Math.imul(D, Ke) | 0, E = E + Math.imul(D, ii) | 0, S = S + Math.imul(Ae, $e) | 0, _ = _ + Math.imul(Ae, Ot) | 0, _ = _ + Math.imul(qe, $e) | 0, E = E + Math.imul(qe, Ot) | 0, S = S + Math.imul(Y, Fe) | 0, _ = _ + Math.imul(Y, ni) | 0, _ = _ + Math.imul(re, Fe) | 0, E = E + Math.imul(re, ni) | 0, S = S + Math.imul(Q, ze) | 0, _ = _ + Math.imul(Q, oi) | 0, _ = _ + Math.imul(me, ze) | 0, E = E + Math.imul(me, oi) | 0, S = S + Math.imul(oe, Xe) | 0, _ = _ + Math.imul(oe, Dt) | 0, _ = _ + Math.imul(J, Xe) | 0, E = E + Math.imul(J, Dt) | 0, S = S + Math.imul(A, je) | 0, _ = _ + Math.imul(A, ri) | 0, _ = _ + Math.imul($, je) | 0, E = E + Math.imul($, ri) | 0;
        var di = (B + S | 0) + ((_ & 8191) << 13) | 0;
        B = (E + (_ >>> 13) | 0) + (di >>> 26) | 0, di &= 67108863, S = Math.imul(Ce, Ne), _ = Math.imul(Ce, Tt), _ = _ + Math.imul(Le, Ne) | 0, E = Math.imul(Le, Tt), S = S + Math.imul(ve, Ue) | 0, _ = _ + Math.imul(ve, Ct) | 0, _ = _ + Math.imul(Re, Ue) | 0, E = E + Math.imul(Re, Ct) | 0, S = S + Math.imul(ue, Ke) | 0, _ = _ + Math.imul(ue, ii) | 0, _ = _ + Math.imul(ge, Ke) | 0, E = E + Math.imul(ge, ii) | 0, S = S + Math.imul(L, $e) | 0, _ = _ + Math.imul(L, Ot) | 0, _ = _ + Math.imul(D, $e) | 0, E = E + Math.imul(D, Ot) | 0, S = S + Math.imul(Ae, Fe) | 0, _ = _ + Math.imul(Ae, ni) | 0, _ = _ + Math.imul(qe, Fe) | 0, E = E + Math.imul(qe, ni) | 0, S = S + Math.imul(Y, ze) | 0, _ = _ + Math.imul(Y, oi) | 0, _ = _ + Math.imul(re, ze) | 0, E = E + Math.imul(re, oi) | 0, S = S + Math.imul(Q, Xe) | 0, _ = _ + Math.imul(Q, Dt) | 0, _ = _ + Math.imul(me, Xe) | 0, E = E + Math.imul(me, Dt) | 0, S = S + Math.imul(oe, je) | 0, _ = _ + Math.imul(oe, ri) | 0, _ = _ + Math.imul(J, je) | 0, E = E + Math.imul(J, ri) | 0, S = S + Math.imul(A, Qe) | 0, _ = _ + Math.imul(A, ai) | 0, _ = _ + Math.imul($, Qe) | 0, E = E + Math.imul($, ai) | 0;
        var pi = (B + S | 0) + ((_ & 8191) << 13) | 0;
        B = (E + (_ >>> 13) | 0) + (pi >>> 26) | 0, pi &= 67108863, S = Math.imul(Pe, Ne), _ = Math.imul(Pe, Tt), _ = _ + Math.imul(et, Ne) | 0, E = Math.imul(et, Tt), S = S + Math.imul(Ce, Ue) | 0, _ = _ + Math.imul(Ce, Ct) | 0, _ = _ + Math.imul(Le, Ue) | 0, E = E + Math.imul(Le, Ct) | 0, S = S + Math.imul(ve, Ke) | 0, _ = _ + Math.imul(ve, ii) | 0, _ = _ + Math.imul(Re, Ke) | 0, E = E + Math.imul(Re, ii) | 0, S = S + Math.imul(ue, $e) | 0, _ = _ + Math.imul(ue, Ot) | 0, _ = _ + Math.imul(ge, $e) | 0, E = E + Math.imul(ge, Ot) | 0, S = S + Math.imul(L, Fe) | 0, _ = _ + Math.imul(L, ni) | 0, _ = _ + Math.imul(D, Fe) | 0, E = E + Math.imul(D, ni) | 0, S = S + Math.imul(Ae, ze) | 0, _ = _ + Math.imul(Ae, oi) | 0, _ = _ + Math.imul(qe, ze) | 0, E = E + Math.imul(qe, oi) | 0, S = S + Math.imul(Y, Xe) | 0, _ = _ + Math.imul(Y, Dt) | 0, _ = _ + Math.imul(re, Xe) | 0, E = E + Math.imul(re, Dt) | 0, S = S + Math.imul(Q, je) | 0, _ = _ + Math.imul(Q, ri) | 0, _ = _ + Math.imul(me, je) | 0, E = E + Math.imul(me, ri) | 0, S = S + Math.imul(oe, Qe) | 0, _ = _ + Math.imul(oe, ai) | 0, _ = _ + Math.imul(J, Qe) | 0, E = E + Math.imul(J, ai) | 0, S = S + Math.imul(A, Je) | 0, _ = _ + Math.imul(A, si) | 0, _ = _ + Math.imul($, Je) | 0, E = E + Math.imul($, si) | 0;
        var yi = (B + S | 0) + ((_ & 8191) << 13) | 0;
        B = (E + (_ >>> 13) | 0) + (yi >>> 26) | 0, yi &= 67108863, S = Math.imul(Pe, Ue), _ = Math.imul(Pe, Ct), _ = _ + Math.imul(et, Ue) | 0, E = Math.imul(et, Ct), S = S + Math.imul(Ce, Ke) | 0, _ = _ + Math.imul(Ce, ii) | 0, _ = _ + Math.imul(Le, Ke) | 0, E = E + Math.imul(Le, ii) | 0, S = S + Math.imul(ve, $e) | 0, _ = _ + Math.imul(ve, Ot) | 0, _ = _ + Math.imul(Re, $e) | 0, E = E + Math.imul(Re, Ot) | 0, S = S + Math.imul(ue, Fe) | 0, _ = _ + Math.imul(ue, ni) | 0, _ = _ + Math.imul(ge, Fe) | 0, E = E + Math.imul(ge, ni) | 0, S = S + Math.imul(L, ze) | 0, _ = _ + Math.imul(L, oi) | 0, _ = _ + Math.imul(D, ze) | 0, E = E + Math.imul(D, oi) | 0, S = S + Math.imul(Ae, Xe) | 0, _ = _ + Math.imul(Ae, Dt) | 0, _ = _ + Math.imul(qe, Xe) | 0, E = E + Math.imul(qe, Dt) | 0, S = S + Math.imul(Y, je) | 0, _ = _ + Math.imul(Y, ri) | 0, _ = _ + Math.imul(re, je) | 0, E = E + Math.imul(re, ri) | 0, S = S + Math.imul(Q, Qe) | 0, _ = _ + Math.imul(Q, ai) | 0, _ = _ + Math.imul(me, Qe) | 0, E = E + Math.imul(me, ai) | 0, S = S + Math.imul(oe, Je) | 0, _ = _ + Math.imul(oe, si) | 0, _ = _ + Math.imul(J, Je) | 0, E = E + Math.imul(J, si) | 0;
        var mi = (B + S | 0) + ((_ & 8191) << 13) | 0;
        B = (E + (_ >>> 13) | 0) + (mi >>> 26) | 0, mi &= 67108863, S = Math.imul(Pe, Ke), _ = Math.imul(Pe, ii), _ = _ + Math.imul(et, Ke) | 0, E = Math.imul(et, ii), S = S + Math.imul(Ce, $e) | 0, _ = _ + Math.imul(Ce, Ot) | 0, _ = _ + Math.imul(Le, $e) | 0, E = E + Math.imul(Le, Ot) | 0, S = S + Math.imul(ve, Fe) | 0, _ = _ + Math.imul(ve, ni) | 0, _ = _ + Math.imul(Re, Fe) | 0, E = E + Math.imul(Re, ni) | 0, S = S + Math.imul(ue, ze) | 0, _ = _ + Math.imul(ue, oi) | 0, _ = _ + Math.imul(ge, ze) | 0, E = E + Math.imul(ge, oi) | 0, S = S + Math.imul(L, Xe) | 0, _ = _ + Math.imul(L, Dt) | 0, _ = _ + Math.imul(D, Xe) | 0, E = E + Math.imul(D, Dt) | 0, S = S + Math.imul(Ae, je) | 0, _ = _ + Math.imul(Ae, ri) | 0, _ = _ + Math.imul(qe, je) | 0, E = E + Math.imul(qe, ri) | 0, S = S + Math.imul(Y, Qe) | 0, _ = _ + Math.imul(Y, ai) | 0, _ = _ + Math.imul(re, Qe) | 0, E = E + Math.imul(re, ai) | 0, S = S + Math.imul(Q, Je) | 0, _ = _ + Math.imul(Q, si) | 0, _ = _ + Math.imul(me, Je) | 0, E = E + Math.imul(me, si) | 0;
        var gi = (B + S | 0) + ((_ & 8191) << 13) | 0;
        B = (E + (_ >>> 13) | 0) + (gi >>> 26) | 0, gi &= 67108863, S = Math.imul(Pe, $e), _ = Math.imul(Pe, Ot), _ = _ + Math.imul(et, $e) | 0, E = Math.imul(et, Ot), S = S + Math.imul(Ce, Fe) | 0, _ = _ + Math.imul(Ce, ni) | 0, _ = _ + Math.imul(Le, Fe) | 0, E = E + Math.imul(Le, ni) | 0, S = S + Math.imul(ve, ze) | 0, _ = _ + Math.imul(ve, oi) | 0, _ = _ + Math.imul(Re, ze) | 0, E = E + Math.imul(Re, oi) | 0, S = S + Math.imul(ue, Xe) | 0, _ = _ + Math.imul(ue, Dt) | 0, _ = _ + Math.imul(ge, Xe) | 0, E = E + Math.imul(ge, Dt) | 0, S = S + Math.imul(L, je) | 0, _ = _ + Math.imul(L, ri) | 0, _ = _ + Math.imul(D, je) | 0, E = E + Math.imul(D, ri) | 0, S = S + Math.imul(Ae, Qe) | 0, _ = _ + Math.imul(Ae, ai) | 0, _ = _ + Math.imul(qe, Qe) | 0, E = E + Math.imul(qe, ai) | 0, S = S + Math.imul(Y, Je) | 0, _ = _ + Math.imul(Y, si) | 0, _ = _ + Math.imul(re, Je) | 0, E = E + Math.imul(re, si) | 0;
        var vi = (B + S | 0) + ((_ & 8191) << 13) | 0;
        B = (E + (_ >>> 13) | 0) + (vi >>> 26) | 0, vi &= 67108863, S = Math.imul(Pe, Fe), _ = Math.imul(Pe, ni), _ = _ + Math.imul(et, Fe) | 0, E = Math.imul(et, ni), S = S + Math.imul(Ce, ze) | 0, _ = _ + Math.imul(Ce, oi) | 0, _ = _ + Math.imul(Le, ze) | 0, E = E + Math.imul(Le, oi) | 0, S = S + Math.imul(ve, Xe) | 0, _ = _ + Math.imul(ve, Dt) | 0, _ = _ + Math.imul(Re, Xe) | 0, E = E + Math.imul(Re, Dt) | 0, S = S + Math.imul(ue, je) | 0, _ = _ + Math.imul(ue, ri) | 0, _ = _ + Math.imul(ge, je) | 0, E = E + Math.imul(ge, ri) | 0, S = S + Math.imul(L, Qe) | 0, _ = _ + Math.imul(L, ai) | 0, _ = _ + Math.imul(D, Qe) | 0, E = E + Math.imul(D, ai) | 0, S = S + Math.imul(Ae, Je) | 0, _ = _ + Math.imul(Ae, si) | 0, _ = _ + Math.imul(qe, Je) | 0, E = E + Math.imul(qe, si) | 0;
        var Nn = (B + S | 0) + ((_ & 8191) << 13) | 0;
        B = (E + (_ >>> 13) | 0) + (Nn >>> 26) | 0, Nn &= 67108863, S = Math.imul(Pe, ze), _ = Math.imul(Pe, oi), _ = _ + Math.imul(et, ze) | 0, E = Math.imul(et, oi), S = S + Math.imul(Ce, Xe) | 0, _ = _ + Math.imul(Ce, Dt) | 0, _ = _ + Math.imul(Le, Xe) | 0, E = E + Math.imul(Le, Dt) | 0, S = S + Math.imul(ve, je) | 0, _ = _ + Math.imul(ve, ri) | 0, _ = _ + Math.imul(Re, je) | 0, E = E + Math.imul(Re, ri) | 0, S = S + Math.imul(ue, Qe) | 0, _ = _ + Math.imul(ue, ai) | 0, _ = _ + Math.imul(ge, Qe) | 0, E = E + Math.imul(ge, ai) | 0, S = S + Math.imul(L, Je) | 0, _ = _ + Math.imul(L, si) | 0, _ = _ + Math.imul(D, Je) | 0, E = E + Math.imul(D, si) | 0;
        var Dn = (B + S | 0) + ((_ & 8191) << 13) | 0;
        B = (E + (_ >>> 13) | 0) + (Dn >>> 26) | 0, Dn &= 67108863, S = Math.imul(Pe, Xe), _ = Math.imul(Pe, Dt), _ = _ + Math.imul(et, Xe) | 0, E = Math.imul(et, Dt), S = S + Math.imul(Ce, je) | 0, _ = _ + Math.imul(Ce, ri) | 0, _ = _ + Math.imul(Le, je) | 0, E = E + Math.imul(Le, ri) | 0, S = S + Math.imul(ve, Qe) | 0, _ = _ + Math.imul(ve, ai) | 0, _ = _ + Math.imul(Re, Qe) | 0, E = E + Math.imul(Re, ai) | 0, S = S + Math.imul(ue, Je) | 0, _ = _ + Math.imul(ue, si) | 0, _ = _ + Math.imul(ge, Je) | 0, E = E + Math.imul(ge, si) | 0;
        var eM = (B + S | 0) + ((_ & 8191) << 13) | 0;
        B = (E + (_ >>> 13) | 0) + (eM >>> 26) | 0, eM &= 67108863, S = Math.imul(Pe, je), _ = Math.imul(Pe, ri), _ = _ + Math.imul(et, je) | 0, E = Math.imul(et, ri), S = S + Math.imul(Ce, Qe) | 0, _ = _ + Math.imul(Ce, ai) | 0, _ = _ + Math.imul(Le, Qe) | 0, E = E + Math.imul(Le, ai) | 0, S = S + Math.imul(ve, Je) | 0, _ = _ + Math.imul(ve, si) | 0, _ = _ + Math.imul(Re, Je) | 0, E = E + Math.imul(Re, si) | 0;
        var tM = (B + S | 0) + ((_ & 8191) << 13) | 0;
        B = (E + (_ >>> 13) | 0) + (tM >>> 26) | 0, tM &= 67108863, S = Math.imul(Pe, Qe), _ = Math.imul(Pe, ai), _ = _ + Math.imul(et, Qe) | 0, E = Math.imul(et, ai), S = S + Math.imul(Ce, Je) | 0, _ = _ + Math.imul(Ce, si) | 0, _ = _ + Math.imul(Le, Je) | 0, E = E + Math.imul(Le, si) | 0;
        var rM = (B + S | 0) + ((_ & 8191) << 13) | 0;
        B = (E + (_ >>> 13) | 0) + (rM >>> 26) | 0, rM &= 67108863, S = Math.imul(Pe, Je), _ = Math.imul(Pe, si), _ = _ + Math.imul(et, Je) | 0, E = Math.imul(et, si);
        var iM = (B + S | 0) + ((_ & 8191) << 13) | 0;
        return B = (E + (_ >>> 13) | 0) + (iM >>> 26) | 0, iM &= 67108863, M[0] = At, M[1] = Bt, M[2] = ui, M[3] = fi, M[4] = hi, M[5] = ci, M[6] = li, M[7] = di, M[8] = pi, M[9] = yi, M[10] = mi, M[11] = gi, M[12] = vi, M[13] = Nn, M[14] = Dn, M[15] = eM, M[16] = tM, M[17] = rM, M[18] = iM, B !== 0 && (M[19] = B, f.length++), f;
      };
      Math.imul || (O = q);
      function N(I, P, f) {
        f.negative = P.negative ^ I.negative, f.length = I.length + P.length;
        for (var y = 0, v = 0, M = 0; M < f.length - 1; M++) {
          var B = v;
          v = 0;
          for (var S = y & 67108863, _ = Math.min(M, P.length - 1), E = Math.max(0, M - I.length + 1); E <= _; E++) {
            var m = M - E, A = I.words[m] | 0, $ = P.words[E] | 0, X = A * $, oe = X & 67108863;
            B = B + (X / 67108864 | 0) | 0, oe = oe + S | 0, S = oe & 67108863, B = B + (oe >>> 26) | 0, v += B >>> 26, B &= 67108863;
          }
          f.words[M] = S, y = B, B = v;
        }
        return y !== 0 ? f.words[M] = y : f.length--, f.strip();
      }
      function j(I, P, f) {
        var y = new U();
        return y.mulp(I, P, f);
      }
      a.prototype.mulTo = function(I, P) {
        var f, y = this.length + I.length;
        return this.length === 10 && I.length === 10 ? f = O(this, I, P) : y < 63 ? f = q(this, I, P) : y < 1024 ? f = N(this, I, P) : f = j(this, I, P), f;
      };
      function U(I, P) {
        this.x = I, this.y = P;
      }
      U.prototype.makeRBT = function(I) {
        for (var P = new Array(I), f = a.prototype._countBits(I) - 1, y = 0; y < I; y++)
          P[y] = this.revBin(y, f, I);
        return P;
      }, U.prototype.revBin = function(I, P, f) {
        if (I === 0 || I === f - 1)
          return I;
        for (var y = 0, v = 0; v < P; v++)
          y |= (I & 1) << P - v - 1, I >>= 1;
        return y;
      }, U.prototype.permute = function(I, P, f, y, v, M) {
        for (var B = 0; B < M; B++)
          y[B] = P[I[B]], v[B] = f[I[B]];
      }, U.prototype.transform = function(I, P, f, y, v, M) {
        this.permute(M, I, P, f, y, v);
        for (var B = 1; B < v; B <<= 1)
          for (var S = B << 1, _ = Math.cos(2 * Math.PI / S), E = Math.sin(2 * Math.PI / S), m = 0; m < v; m += S)
            for (var A = _, $ = E, X = 0; X < B; X++) {
              var oe = f[m + X], J = y[m + X], W = f[m + X + B], Q = y[m + X + B], me = A * W - $ * Q;
              Q = A * Q + $ * W, W = me, f[m + X] = oe + W, y[m + X] = J + Q, f[m + X + B] = oe - W, y[m + X + B] = J - Q, X !== S && (me = _ * A - E * $, $ = _ * $ + E * A, A = me);
            }
      }, U.prototype.guessLen13b = function(I, P) {
        var f = Math.max(P, I) | 1, y = f & 1, v = 0;
        for (f = f / 2 | 0; f; f = f >>> 1)
          v++;
        return 1 << v + 1 + y;
      }, U.prototype.conjugate = function(I, P, f) {
        if (!(f <= 1))
          for (var y = 0; y < f / 2; y++) {
            var v = I[y];
            I[y] = I[f - y - 1], I[f - y - 1] = v, v = P[y], P[y] = -P[f - y - 1], P[f - y - 1] = -v;
          }
      }, U.prototype.normalize13b = function(I, P) {
        for (var f = 0, y = 0; y < P / 2; y++) {
          var v = Math.round(I[2 * y + 1] / P) * 8192 + Math.round(I[2 * y] / P) + f;
          I[y] = v & 67108863, v < 67108864 ? f = 0 : f = v / 67108864 | 0;
        }
        return I;
      }, U.prototype.convert13b = function(I, P, f, y) {
        for (var v = 0, M = 0; M < P; M++)
          v = v + (I[M] | 0), f[2 * M] = v & 8191, v = v >>> 13, f[2 * M + 1] = v & 8191, v = v >>> 13;
        for (M = 2 * P; M < y; ++M)
          f[M] = 0;
        r(v === 0), r((v & -8192) === 0);
      }, U.prototype.stub = function(I) {
        for (var P = new Array(I), f = 0; f < I; f++)
          P[f] = 0;
        return P;
      }, U.prototype.mulp = function(I, P, f) {
        var y = 2 * this.guessLen13b(I.length, P.length), v = this.makeRBT(y), M = this.stub(y), B = new Array(y), S = new Array(y), _ = new Array(y), E = new Array(y), m = new Array(y), A = new Array(y), $ = f.words;
        $.length = y, this.convert13b(I.words, I.length, B, y), this.convert13b(P.words, P.length, E, y), this.transform(B, M, S, _, y, v), this.transform(E, M, m, A, y, v);
        for (var X = 0; X < y; X++) {
          var oe = S[X] * m[X] - _[X] * A[X];
          _[X] = S[X] * A[X] + _[X] * m[X], S[X] = oe;
        }
        return this.conjugate(S, _, y), this.transform(S, _, $, M, y, v), this.conjugate($, M, y), this.normalize13b($, y), f.negative = I.negative ^ P.negative, f.length = I.length + P.length, f.strip();
      }, a.prototype.mul = function(I) {
        var P = new a(null);
        return P.words = new Array(this.length + I.length), this.mulTo(I, P);
      }, a.prototype.mulf = function(I) {
        var P = new a(null);
        return P.words = new Array(this.length + I.length), j(this, I, P);
      }, a.prototype.imul = function(I) {
        return this.clone().mulTo(I, this);
      }, a.prototype.imuln = function(I) {
        r(typeof I == "number"), r(I < 67108864);
        for (var P = 0, f = 0; f < this.length; f++) {
          var y = (this.words[f] | 0) * I, v = (y & 67108863) + (P & 67108863);
          P >>= 26, P += y / 67108864 | 0, P += v >>> 26, this.words[f] = v & 67108863;
        }
        return P !== 0 && (this.words[f] = P, this.length++), this;
      }, a.prototype.muln = function(I) {
        return this.clone().imuln(I);
      }, a.prototype.sqr = function() {
        return this.mul(this);
      }, a.prototype.isqr = function() {
        return this.imul(this.clone());
      }, a.prototype.pow = function(I) {
        var P = k(I);
        if (P.length === 0)
          return new a(1);
        for (var f = this, y = 0; y < P.length && P[y] === 0; y++, f = f.sqr())
          ;
        if (++y < P.length)
          for (var v = f.sqr(); y < P.length; y++, v = v.sqr())
            P[y] !== 0 && (f = f.mul(v));
        return f;
      }, a.prototype.iushln = function(I) {
        r(typeof I == "number" && I >= 0);
        var P = I % 26, f = (I - P) / 26, y = 67108863 >>> 26 - P << 26 - P, v;
        if (P !== 0) {
          var M = 0;
          for (v = 0; v < this.length; v++) {
            var B = this.words[v] & y, S = (this.words[v] | 0) - B << P;
            this.words[v] = S | M, M = B >>> 26 - P;
          }
          M && (this.words[v] = M, this.length++);
        }
        if (f !== 0) {
          for (v = this.length - 1; v >= 0; v--)
            this.words[v + f] = this.words[v];
          for (v = 0; v < f; v++)
            this.words[v] = 0;
          this.length += f;
        }
        return this.strip();
      }, a.prototype.ishln = function(I) {
        return r(this.negative === 0), this.iushln(I);
      }, a.prototype.iushrn = function(I, P, f) {
        r(typeof I == "number" && I >= 0);
        var y;
        P ? y = (P - P % 26) / 26 : y = 0;
        var v = I % 26, M = Math.min((I - v) / 26, this.length), B = 67108863 ^ 67108863 >>> v << v, S = f;
        if (y -= M, y = Math.max(0, y), S) {
          for (var _ = 0; _ < M; _++)
            S.words[_] = this.words[_];
          S.length = M;
        }
        if (M !== 0)
          if (this.length > M)
            for (this.length -= M, _ = 0; _ < this.length; _++)
              this.words[_] = this.words[_ + M];
          else
            this.words[0] = 0, this.length = 1;
        var E = 0;
        for (_ = this.length - 1; _ >= 0 && (E !== 0 || _ >= y); _--) {
          var m = this.words[_] | 0;
          this.words[_] = E << 26 - v | m >>> v, E = m & B;
        }
        return S && E !== 0 && (S.words[S.length++] = E), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, a.prototype.ishrn = function(I, P, f) {
        return r(this.negative === 0), this.iushrn(I, P, f);
      }, a.prototype.shln = function(I) {
        return this.clone().ishln(I);
      }, a.prototype.ushln = function(I) {
        return this.clone().iushln(I);
      }, a.prototype.shrn = function(I) {
        return this.clone().ishrn(I);
      }, a.prototype.ushrn = function(I) {
        return this.clone().iushrn(I);
      }, a.prototype.testn = function(I) {
        r(typeof I == "number" && I >= 0);
        var P = I % 26, f = (I - P) / 26, y = 1 << P;
        if (this.length <= f)
          return !1;
        var v = this.words[f];
        return !!(v & y);
      }, a.prototype.imaskn = function(I) {
        r(typeof I == "number" && I >= 0);
        var P = I % 26, f = (I - P) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= f)
          return this;
        if (P !== 0 && f++, this.length = Math.min(f, this.length), P !== 0) {
          var y = 67108863 ^ 67108863 >>> P << P;
          this.words[this.length - 1] &= y;
        }
        return this.strip();
      }, a.prototype.maskn = function(I) {
        return this.clone().imaskn(I);
      }, a.prototype.iaddn = function(I) {
        return r(typeof I == "number"), r(I < 67108864), I < 0 ? this.isubn(-I) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < I ? (this.words[0] = I - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(I), this.negative = 1, this) : this._iaddn(I);
      }, a.prototype._iaddn = function(I) {
        this.words[0] += I;
        for (var P = 0; P < this.length && this.words[P] >= 67108864; P++)
          this.words[P] -= 67108864, P === this.length - 1 ? this.words[P + 1] = 1 : this.words[P + 1]++;
        return this.length = Math.max(this.length, P + 1), this;
      }, a.prototype.isubn = function(I) {
        if (r(typeof I == "number"), r(I < 67108864), I < 0)
          return this.iaddn(-I);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(I), this.negative = 1, this;
        if (this.words[0] -= I, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var P = 0; P < this.length && this.words[P] < 0; P++)
            this.words[P] += 67108864, this.words[P + 1] -= 1;
        return this.strip();
      }, a.prototype.addn = function(I) {
        return this.clone().iaddn(I);
      }, a.prototype.subn = function(I) {
        return this.clone().isubn(I);
      }, a.prototype.iabs = function() {
        return this.negative = 0, this;
      }, a.prototype.abs = function() {
        return this.clone().iabs();
      }, a.prototype._ishlnsubmul = function(I, P, f) {
        var y = I.length + f, v;
        this._expand(y);
        var M, B = 0;
        for (v = 0; v < I.length; v++) {
          M = (this.words[v + f] | 0) + B;
          var S = (I.words[v] | 0) * P;
          M -= S & 67108863, B = (M >> 26) - (S / 67108864 | 0), this.words[v + f] = M & 67108863;
        }
        for (; v < this.length - f; v++)
          M = (this.words[v + f] | 0) + B, B = M >> 26, this.words[v + f] = M & 67108863;
        if (B === 0)
          return this.strip();
        for (r(B === -1), B = 0, v = 0; v < this.length; v++)
          M = -(this.words[v] | 0) + B, B = M >> 26, this.words[v] = M & 67108863;
        return this.negative = 1, this.strip();
      }, a.prototype._wordDiv = function(I, P) {
        var f = this.length - I.length, y = this.clone(), v = I, M = v.words[v.length - 1] | 0, B = this._countBits(M);
        f = 26 - B, f !== 0 && (v = v.ushln(f), y.iushln(f), M = v.words[v.length - 1] | 0);
        var S = y.length - v.length, _;
        if (P !== "mod") {
          _ = new a(null), _.length = S + 1, _.words = new Array(_.length);
          for (var E = 0; E < _.length; E++)
            _.words[E] = 0;
        }
        var m = y.clone()._ishlnsubmul(v, 1, S);
        m.negative === 0 && (y = m, _ && (_.words[S] = 1));
        for (var A = S - 1; A >= 0; A--) {
          var $ = (y.words[v.length + A] | 0) * 67108864 + (y.words[v.length + A - 1] | 0);
          for ($ = Math.min($ / M | 0, 67108863), y._ishlnsubmul(v, $, A); y.negative !== 0; )
            $--, y.negative = 0, y._ishlnsubmul(v, 1, A), y.isZero() || (y.negative ^= 1);
          _ && (_.words[A] = $);
        }
        return _ && _.strip(), y.strip(), P !== "div" && f !== 0 && y.iushrn(f), {
          div: _ || null,
          mod: y
        };
      }, a.prototype.divmod = function(I, P, f) {
        if (r(!I.isZero()), this.isZero())
          return {
            div: new a(0),
            mod: new a(0)
          };
        var y, v, M;
        return this.negative !== 0 && I.negative === 0 ? (M = this.neg().divmod(I, P), P !== "mod" && (y = M.div.neg()), P !== "div" && (v = M.mod.neg(), f && v.negative !== 0 && v.iadd(I)), {
          div: y,
          mod: v
        }) : this.negative === 0 && I.negative !== 0 ? (M = this.divmod(I.neg(), P), P !== "mod" && (y = M.div.neg()), {
          div: y,
          mod: M.mod
        }) : this.negative & I.negative ? (M = this.neg().divmod(I.neg(), P), P !== "div" && (v = M.mod.neg(), f && v.negative !== 0 && v.isub(I)), {
          div: M.div,
          mod: v
        }) : I.length > this.length || this.cmp(I) < 0 ? {
          div: new a(0),
          mod: this
        } : I.length === 1 ? P === "div" ? {
          div: this.divn(I.words[0]),
          mod: null
        } : P === "mod" ? {
          div: null,
          mod: new a(this.modn(I.words[0]))
        } : {
          div: this.divn(I.words[0]),
          mod: new a(this.modn(I.words[0]))
        } : this._wordDiv(I, P);
      }, a.prototype.div = function(I) {
        return this.divmod(I, "div", !1).div;
      }, a.prototype.mod = function(I) {
        return this.divmod(I, "mod", !1).mod;
      }, a.prototype.umod = function(I) {
        return this.divmod(I, "mod", !0).mod;
      }, a.prototype.divRound = function(I) {
        var P = this.divmod(I);
        if (P.mod.isZero())
          return P.div;
        var f = P.div.negative !== 0 ? P.mod.isub(I) : P.mod, y = I.ushrn(1), v = I.andln(1), M = f.cmp(y);
        return M < 0 || v === 1 && M === 0 ? P.div : P.div.negative !== 0 ? P.div.isubn(1) : P.div.iaddn(1);
      }, a.prototype.modn = function(I) {
        r(I <= 67108863);
        for (var P = (1 << 26) % I, f = 0, y = this.length - 1; y >= 0; y--)
          f = (P * f + (this.words[y] | 0)) % I;
        return f;
      }, a.prototype.idivn = function(I) {
        r(I <= 67108863);
        for (var P = 0, f = this.length - 1; f >= 0; f--) {
          var y = (this.words[f] | 0) + P * 67108864;
          this.words[f] = y / I | 0, P = y % I;
        }
        return this.strip();
      }, a.prototype.divn = function(I) {
        return this.clone().idivn(I);
      }, a.prototype.egcd = function(I) {
        r(I.negative === 0), r(!I.isZero());
        var P = this, f = I.clone();
        P.negative !== 0 ? P = P.umod(I) : P = P.clone();
        for (var y = new a(1), v = new a(0), M = new a(0), B = new a(1), S = 0; P.isEven() && f.isEven(); )
          P.iushrn(1), f.iushrn(1), ++S;
        for (var _ = f.clone(), E = P.clone(); !P.isZero(); ) {
          for (var m = 0, A = 1; !(P.words[0] & A) && m < 26; ++m, A <<= 1)
            ;
          if (m > 0)
            for (P.iushrn(m); m-- > 0; )
              (y.isOdd() || v.isOdd()) && (y.iadd(_), v.isub(E)), y.iushrn(1), v.iushrn(1);
          for (var $ = 0, X = 1; !(f.words[0] & X) && $ < 26; ++$, X <<= 1)
            ;
          if ($ > 0)
            for (f.iushrn($); $-- > 0; )
              (M.isOdd() || B.isOdd()) && (M.iadd(_), B.isub(E)), M.iushrn(1), B.iushrn(1);
          P.cmp(f) >= 0 ? (P.isub(f), y.isub(M), v.isub(B)) : (f.isub(P), M.isub(y), B.isub(v));
        }
        return {
          a: M,
          b: B,
          gcd: f.iushln(S)
        };
      }, a.prototype._invmp = function(I) {
        r(I.negative === 0), r(!I.isZero());
        var P = this, f = I.clone();
        P.negative !== 0 ? P = P.umod(I) : P = P.clone();
        for (var y = new a(1), v = new a(0), M = f.clone(); P.cmpn(1) > 0 && f.cmpn(1) > 0; ) {
          for (var B = 0, S = 1; !(P.words[0] & S) && B < 26; ++B, S <<= 1)
            ;
          if (B > 0)
            for (P.iushrn(B); B-- > 0; )
              y.isOdd() && y.iadd(M), y.iushrn(1);
          for (var _ = 0, E = 1; !(f.words[0] & E) && _ < 26; ++_, E <<= 1)
            ;
          if (_ > 0)
            for (f.iushrn(_); _-- > 0; )
              v.isOdd() && v.iadd(M), v.iushrn(1);
          P.cmp(f) >= 0 ? (P.isub(f), y.isub(v)) : (f.isub(P), v.isub(y));
        }
        var m;
        return P.cmpn(1) === 0 ? m = y : m = v, m.cmpn(0) < 0 && m.iadd(I), m;
      }, a.prototype.gcd = function(I) {
        if (this.isZero())
          return I.abs();
        if (I.isZero())
          return this.abs();
        var P = this.clone(), f = I.clone();
        P.negative = 0, f.negative = 0;
        for (var y = 0; P.isEven() && f.isEven(); y++)
          P.iushrn(1), f.iushrn(1);
        do {
          for (; P.isEven(); )
            P.iushrn(1);
          for (; f.isEven(); )
            f.iushrn(1);
          var v = P.cmp(f);
          if (v < 0) {
            var M = P;
            P = f, f = M;
          } else if (v === 0 || f.cmpn(1) === 0)
            break;
          P.isub(f);
        } while (!0);
        return f.iushln(y);
      }, a.prototype.invm = function(I) {
        return this.egcd(I).a.umod(I);
      }, a.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, a.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, a.prototype.andln = function(I) {
        return this.words[0] & I;
      }, a.prototype.bincn = function(I) {
        r(typeof I == "number");
        var P = I % 26, f = (I - P) / 26, y = 1 << P;
        if (this.length <= f)
          return this._expand(f + 1), this.words[f] |= y, this;
        for (var v = y, M = f; v !== 0 && M < this.length; M++) {
          var B = this.words[M] | 0;
          B += v, v = B >>> 26, B &= 67108863, this.words[M] = B;
        }
        return v !== 0 && (this.words[M] = v, this.length++), this;
      }, a.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, a.prototype.cmpn = function(I) {
        var P = I < 0;
        if (this.negative !== 0 && !P)
          return -1;
        if (this.negative === 0 && P)
          return 1;
        this.strip();
        var f;
        if (this.length > 1)
          f = 1;
        else {
          P && (I = -I), r(I <= 67108863, "Number is too big");
          var y = this.words[0] | 0;
          f = y === I ? 0 : y < I ? -1 : 1;
        }
        return this.negative !== 0 ? -f | 0 : f;
      }, a.prototype.cmp = function(I) {
        if (this.negative !== 0 && I.negative === 0)
          return -1;
        if (this.negative === 0 && I.negative !== 0)
          return 1;
        var P = this.ucmp(I);
        return this.negative !== 0 ? -P | 0 : P;
      }, a.prototype.ucmp = function(I) {
        if (this.length > I.length)
          return 1;
        if (this.length < I.length)
          return -1;
        for (var P = 0, f = this.length - 1; f >= 0; f--) {
          var y = this.words[f] | 0, v = I.words[f] | 0;
          if (y !== v) {
            y < v ? P = -1 : y > v && (P = 1);
            break;
          }
        }
        return P;
      }, a.prototype.gtn = function(I) {
        return this.cmpn(I) === 1;
      }, a.prototype.gt = function(I) {
        return this.cmp(I) === 1;
      }, a.prototype.gten = function(I) {
        return this.cmpn(I) >= 0;
      }, a.prototype.gte = function(I) {
        return this.cmp(I) >= 0;
      }, a.prototype.ltn = function(I) {
        return this.cmpn(I) === -1;
      }, a.prototype.lt = function(I) {
        return this.cmp(I) === -1;
      }, a.prototype.lten = function(I) {
        return this.cmpn(I) <= 0;
      }, a.prototype.lte = function(I) {
        return this.cmp(I) <= 0;
      }, a.prototype.eqn = function(I) {
        return this.cmpn(I) === 0;
      }, a.prototype.eq = function(I) {
        return this.cmp(I) === 0;
      }, a.red = function(I) {
        return new ie(I);
      }, a.prototype.toRed = function(I) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), I.convertTo(this)._forceRed(I);
      }, a.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, a.prototype._forceRed = function(I) {
        return this.red = I, this;
      }, a.prototype.forceRed = function(I) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(I);
      }, a.prototype.redAdd = function(I) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, I);
      }, a.prototype.redIAdd = function(I) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, I);
      }, a.prototype.redSub = function(I) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, I);
      }, a.prototype.redISub = function(I) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, I);
      }, a.prototype.redShl = function(I) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, I);
      }, a.prototype.redMul = function(I) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, I), this.red.mul(this, I);
      }, a.prototype.redIMul = function(I) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, I), this.red.imul(this, I);
      }, a.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, a.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, a.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, a.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, a.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, a.prototype.redPow = function(I) {
        return r(this.red && !I.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, I);
      };
      var H = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function z(I, P) {
        this.name = I, this.p = new a(P, 16), this.n = this.p.bitLength(), this.k = new a(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      z.prototype._tmp = function() {
        var I = new a(null);
        return I.words = new Array(Math.ceil(this.n / 13)), I;
      }, z.prototype.ireduce = function(I) {
        var P = I, f;
        do
          this.split(P, this.tmp), P = this.imulK(P), P = P.iadd(this.tmp), f = P.bitLength();
        while (f > this.n);
        var y = f < this.n ? -1 : P.ucmp(this.p);
        return y === 0 ? (P.words[0] = 0, P.length = 1) : y > 0 ? P.isub(this.p) : P.strip !== void 0 ? P.strip() : P._strip(), P;
      }, z.prototype.split = function(I, P) {
        I.iushrn(this.n, 0, P);
      }, z.prototype.imulK = function(I) {
        return I.imul(this.k);
      };
      function ee() {
        z.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      h(ee, z), ee.prototype.split = function(I, P) {
        for (var f = 4194303, y = Math.min(I.length, 9), v = 0; v < y; v++)
          P.words[v] = I.words[v];
        if (P.length = y, I.length <= 9) {
          I.words[0] = 0, I.length = 1;
          return;
        }
        var M = I.words[9];
        for (P.words[P.length++] = M & f, v = 10; v < I.length; v++) {
          var B = I.words[v] | 0;
          I.words[v - 10] = (B & f) << 4 | M >>> 22, M = B;
        }
        M >>>= 22, I.words[v - 10] = M, M === 0 && I.length > 10 ? I.length -= 10 : I.length -= 9;
      }, ee.prototype.imulK = function(I) {
        I.words[I.length] = 0, I.words[I.length + 1] = 0, I.length += 2;
        for (var P = 0, f = 0; f < I.length; f++) {
          var y = I.words[f] | 0;
          P += y * 977, I.words[f] = P & 67108863, P = y * 64 + (P / 67108864 | 0);
        }
        return I.words[I.length - 1] === 0 && (I.length--, I.words[I.length - 1] === 0 && I.length--), I;
      };
      function ne() {
        z.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      h(ne, z);
      function le() {
        z.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      h(le, z);
      function Z() {
        z.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      h(Z, z), Z.prototype.imulK = function(I) {
        for (var P = 0, f = 0; f < I.length; f++) {
          var y = (I.words[f] | 0) * 19 + P, v = y & 67108863;
          y >>>= 26, I.words[f] = v, P = y;
        }
        return P !== 0 && (I.words[I.length++] = P), I;
      }, a._prime = function(I) {
        if (H[I])
          return H[I];
        var P;
        if (I === "k256")
          P = new ee();
        else if (I === "p224")
          P = new ne();
        else if (I === "p192")
          P = new le();
        else if (I === "p25519")
          P = new Z();
        else
          throw new Error("Unknown prime " + I);
        return H[I] = P, P;
      };
      function ie(I) {
        if (typeof I == "string") {
          var P = a._prime(I);
          this.m = P.p, this.prime = P;
        } else
          r(I.gtn(1), "modulus must be greater than 1"), this.m = I, this.prime = null;
      }
      ie.prototype._verify1 = function(I) {
        r(I.negative === 0, "red works only with positives"), r(I.red, "red works only with red numbers");
      }, ie.prototype._verify2 = function(I, P) {
        r((I.negative | P.negative) === 0, "red works only with positives"), r(
          I.red && I.red === P.red,
          "red works only with red numbers"
        );
      }, ie.prototype.imod = function(I) {
        return this.prime ? this.prime.ireduce(I)._forceRed(this) : I.umod(this.m)._forceRed(this);
      }, ie.prototype.neg = function(I) {
        return I.isZero() ? I.clone() : this.m.sub(I)._forceRed(this);
      }, ie.prototype.add = function(I, P) {
        this._verify2(I, P);
        var f = I.add(P);
        return f.cmp(this.m) >= 0 && f.isub(this.m), f._forceRed(this);
      }, ie.prototype.iadd = function(I, P) {
        this._verify2(I, P);
        var f = I.iadd(P);
        return f.cmp(this.m) >= 0 && f.isub(this.m), f;
      }, ie.prototype.sub = function(I, P) {
        this._verify2(I, P);
        var f = I.sub(P);
        return f.cmpn(0) < 0 && f.iadd(this.m), f._forceRed(this);
      }, ie.prototype.isub = function(I, P) {
        this._verify2(I, P);
        var f = I.isub(P);
        return f.cmpn(0) < 0 && f.iadd(this.m), f;
      }, ie.prototype.shl = function(I, P) {
        return this._verify1(I), this.imod(I.ushln(P));
      }, ie.prototype.imul = function(I, P) {
        return this._verify2(I, P), this.imod(I.imul(P));
      }, ie.prototype.mul = function(I, P) {
        return this._verify2(I, P), this.imod(I.mul(P));
      }, ie.prototype.isqr = function(I) {
        return this.imul(I, I.clone());
      }, ie.prototype.sqr = function(I) {
        return this.mul(I, I);
      }, ie.prototype.sqrt = function(I) {
        if (I.isZero())
          return I.clone();
        var P = this.m.andln(3);
        if (r(P % 2 === 1), P === 3) {
          var f = this.m.add(new a(1)).iushrn(2);
          return this.pow(I, f);
        }
        for (var y = this.m.subn(1), v = 0; !y.isZero() && y.andln(1) === 0; )
          v++, y.iushrn(1);
        r(!y.isZero());
        var M = new a(1).toRed(this), B = M.redNeg(), S = this.m.subn(1).iushrn(1), _ = this.m.bitLength();
        for (_ = new a(2 * _ * _).toRed(this); this.pow(_, S).cmp(B) !== 0; )
          _.redIAdd(B);
        for (var E = this.pow(_, y), m = this.pow(I, y.addn(1).iushrn(1)), A = this.pow(I, y), $ = v; A.cmp(M) !== 0; ) {
          for (var X = A, oe = 0; X.cmp(M) !== 0; oe++)
            X = X.redSqr();
          r(oe < $);
          var J = this.pow(E, new a(1).iushln($ - oe - 1));
          m = m.redMul(J), E = J.redSqr(), A = A.redMul(E), $ = oe;
        }
        return m;
      }, ie.prototype.invm = function(I) {
        var P = I._invmp(this.m);
        return P.negative !== 0 ? (P.negative = 0, this.imod(P).redNeg()) : this.imod(P);
      }, ie.prototype.pow = function(I, P) {
        if (P.isZero())
          return new a(1).toRed(this);
        if (P.cmpn(1) === 0)
          return I.clone();
        var f = 4, y = new Array(1 << f);
        y[0] = new a(1).toRed(this), y[1] = I;
        for (var v = 2; v < y.length; v++)
          y[v] = this.mul(y[v - 1], I);
        var M = y[0], B = 0, S = 0, _ = P.bitLength() % 26;
        for (_ === 0 && (_ = 26), v = P.length - 1; v >= 0; v--) {
          for (var E = P.words[v], m = _ - 1; m >= 0; m--) {
            var A = E >> m & 1;
            if (M !== y[0] && (M = this.sqr(M)), A === 0 && B === 0) {
              S = 0;
              continue;
            }
            B <<= 1, B |= A, S++, !(S !== f && (v !== 0 || m !== 0)) && (M = this.mul(M, y[B]), S = 0, B = 0);
          }
          _ = 26;
        }
        return M;
      }, ie.prototype.convertTo = function(I) {
        var P = I.umod(this.m);
        return P === I ? P.clone() : P;
      }, ie.prototype.convertFrom = function(I) {
        var P = I.clone();
        return P.red = null, P;
      }, a.mont = function(I) {
        return new fe(I);
      };
      function fe(I) {
        ie.call(this, I), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new a(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      h(fe, ie), fe.prototype.convertTo = function(I) {
        return this.imod(I.ushln(this.shift));
      }, fe.prototype.convertFrom = function(I) {
        var P = this.imod(I.mul(this.rinv));
        return P.red = null, P;
      }, fe.prototype.imul = function(I, P) {
        if (I.isZero() || P.isZero())
          return I.words[0] = 0, I.length = 1, I;
        var f = I.imul(P), y = f.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), v = f.isub(y).iushrn(this.shift), M = v;
        return v.cmp(this.m) >= 0 ? M = v.isub(this.m) : v.cmpn(0) < 0 && (M = v.iadd(this.m)), M._forceRed(this);
      }, fe.prototype.mul = function(I, P) {
        if (I.isZero() || P.isZero())
          return new a(0)._forceRed(this);
        var f = I.mul(P), y = f.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), v = f.isub(y).iushrn(this.shift), M = v;
        return v.cmp(this.m) >= 0 ? M = v.isub(this.m) : v.cmpn(0) < 0 && (M = v.iadd(this.m)), M._forceRed(this);
      }, fe.prototype.invm = function(I) {
        var P = this.imod(I._invmp(this.m).mul(this.r2));
        return P._forceRed(this);
      };
    })(e, commonjsGlobal);
  }(bn$2)), bn$2.exports;
}
var brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand)
    return brorand.exports;
  hasRequiredBrorand = 1;
  var e;
  brorand.exports = function(r) {
    return e || (e = new t(null)), e.generate(r);
  };
  function t(r) {
    this.rand = r;
  }
  if (brorand.exports.Rand = t, t.prototype.generate = function(r) {
    return this._rand(r);
  }, t.prototype._rand = function(r) {
    if (this.rand.getBytes)
      return this.rand.getBytes(r);
    for (var h = new Uint8Array(r), a = 0; a < h.length; a++)
      h[a] = this.rand.getByte();
    return h;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? t.prototype._rand = function(r) {
      var h = new Uint8Array(r);
      return self.crypto.getRandomValues(h), h;
    } : self.msCrypto && self.msCrypto.getRandomValues ? t.prototype._rand = function(r) {
      var h = new Uint8Array(r);
      return self.msCrypto.getRandomValues(h), h;
    } : typeof window == "object" && (t.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var o = requireCryptoBrowserify();
      if (typeof o.randomBytes != "function")
        throw new Error("Not supported");
      t.prototype._rand = function(r) {
        return o.randomBytes(r);
      };
    } catch {
    }
  return brorand.exports;
}
var mr$1, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr)
    return mr$1;
  hasRequiredMr = 1;
  var e = requireBn$2(), t = requireBrorand();
  function o(r) {
    this.rand = r || new t.Rand();
  }
  return mr$1 = o, o.create = function(r) {
    return new o(r);
  }, o.prototype._randbelow = function(r) {
    var h = r.bitLength(), a = Math.ceil(h / 8);
    do
      var p = new e(this.rand.generate(a));
    while (p.cmp(r) >= 0);
    return p;
  }, o.prototype._randrange = function(r, h) {
    var a = h.sub(r);
    return r.add(this._randbelow(a));
  }, o.prototype.test = function(r, h, a) {
    var p = r.bitLength(), d = e.mont(r), b = new e(1).toRed(d);
    h || (h = Math.max(1, p / 48 | 0));
    for (var g = r.subn(1), w = 0; !g.testn(w); w++)
      ;
    for (var C = r.shrn(w), T = g.toRed(d), k = !0; h > 0; h--) {
      var q = this._randrange(new e(2), g);
      a && a(q);
      var O = q.toRed(d).redPow(C);
      if (!(O.cmp(b) === 0 || O.cmp(T) === 0)) {
        for (var N = 1; N < w; N++) {
          if (O = O.redSqr(), O.cmp(b) === 0)
            return !1;
          if (O.cmp(T) === 0)
            break;
        }
        if (N === w)
          return !1;
      }
    }
    return k;
  }, o.prototype.getDivisor = function(r, h) {
    var a = r.bitLength(), p = e.mont(r), d = new e(1).toRed(p);
    h || (h = Math.max(1, a / 48 | 0));
    for (var b = r.subn(1), g = 0; !b.testn(g); g++)
      ;
    for (var w = r.shrn(g), C = b.toRed(p); h > 0; h--) {
      var T = this._randrange(new e(2), b), k = r.gcd(T);
      if (k.cmpn(1) !== 0)
        return k;
      var q = T.toRed(p).redPow(w);
      if (!(q.cmp(d) === 0 || q.cmp(C) === 0)) {
        for (var O = 1; O < g; O++) {
          if (q = q.redSqr(), q.cmp(d) === 0)
            return q.fromRed().subn(1).gcd(r);
          if (q.cmp(C) === 0)
            break;
        }
        if (O === g)
          return q = q.redSqr(), q.fromRed().subn(1).gcd(r);
      }
    }
    return !1;
  }, mr$1;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime)
    return generatePrime;
  hasRequiredGeneratePrime = 1;
  var e = requireBrowser$b();
  generatePrime = N, N.simpleSieve = q, N.fermatTest = O;
  var t = requireBn$2(), o = new t(24), r = requireMr(), h = new r(), a = new t(1), p = new t(2), d = new t(5);
  new t(16), new t(8);
  var b = new t(10), g = new t(3);
  new t(7);
  var w = new t(11), C = new t(4);
  new t(12);
  var T = null;
  function k() {
    if (T !== null)
      return T;
    var j = 1048576, U = [];
    U[0] = 2;
    for (var H = 1, z = 3; z < j; z += 2) {
      for (var ee = Math.ceil(Math.sqrt(z)), ne = 0; ne < H && U[ne] <= ee && z % U[ne] !== 0; ne++)
        ;
      H !== ne && U[ne] <= ee || (U[H++] = z);
    }
    return T = U, U;
  }
  function q(j) {
    for (var U = k(), H = 0; H < U.length; H++)
      if (j.modn(U[H]) === 0)
        return j.cmpn(U[H]) === 0;
    return !0;
  }
  function O(j) {
    var U = t.mont(j);
    return p.toRed(U).redPow(j.subn(1)).fromRed().cmpn(1) === 0;
  }
  function N(j, U) {
    if (j < 16)
      return U === 2 || U === 5 ? new t([140, 123]) : new t([140, 39]);
    U = new t(U);
    for (var H, z; ; ) {
      for (H = new t(e(Math.ceil(j / 8))); H.bitLength() > j; )
        H.ishrn(1);
      if (H.isEven() && H.iadd(a), H.testn(1) || H.iadd(p), U.cmp(p)) {
        if (!U.cmp(d))
          for (; H.mod(b).cmp(g); )
            H.iadd(C);
      } else
        for (; H.mod(o).cmp(w); )
          H.iadd(C);
      if (z = H.shrn(1), q(z) && q(H) && O(z) && O(H) && h.test(z) && h.test(H))
        return H;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh$1, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh)
    return dh$1;
  hasRequiredDh = 1;
  var e = requireBn$2(), t = requireMr(), o = new t(), r = new e(24), h = new e(11), a = new e(10), p = new e(3), d = new e(7), b = requireGeneratePrime(), g = requireBrowser$b();
  dh$1 = q;
  function w(N, j) {
    return j = j || "utf8", bufferExports.Buffer.isBuffer(N) || (N = new bufferExports.Buffer(N, j)), this._pub = new e(N), this;
  }
  function C(N, j) {
    return j = j || "utf8", bufferExports.Buffer.isBuffer(N) || (N = new bufferExports.Buffer(N, j)), this._priv = new e(N), this;
  }
  var T = {};
  function k(N, j) {
    var U = j.toString("hex"), H = [U, N.toString(16)].join("_");
    if (H in T)
      return T[H];
    var z = 0;
    if (N.isEven() || !b.simpleSieve || !b.fermatTest(N) || !o.test(N))
      return z += 1, U === "02" || U === "05" ? z += 8 : z += 4, T[H] = z, z;
    o.test(N.shrn(1)) || (z += 2);
    var ee;
    switch (U) {
      case "02":
        N.mod(r).cmp(h) && (z += 8);
        break;
      case "05":
        ee = N.mod(a), ee.cmp(p) && ee.cmp(d) && (z += 8);
        break;
      default:
        z += 4;
    }
    return T[H] = z, z;
  }
  function q(N, j, U) {
    this.setGenerator(j), this.__prime = new e(N), this._prime = e.mont(this.__prime), this._primeLen = N.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, U ? (this.setPublicKey = w, this.setPrivateKey = C) : this._primeCode = 8;
  }
  Object.defineProperty(q.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = k(this.__prime, this.__gen)), this._primeCode;
    }
  }), q.prototype.generateKeys = function() {
    return this._priv || (this._priv = new e(g(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, q.prototype.computeSecret = function(N) {
    N = new e(N), N = N.toRed(this._prime);
    var j = N.redPow(this._priv).fromRed(), U = new bufferExports.Buffer(j.toArray()), H = this.getPrime();
    if (U.length < H.length) {
      var z = new bufferExports.Buffer(H.length - U.length);
      z.fill(0), U = bufferExports.Buffer.concat([z, U]);
    }
    return U;
  }, q.prototype.getPublicKey = function(N) {
    return O(this._pub, N);
  }, q.prototype.getPrivateKey = function(N) {
    return O(this._priv, N);
  }, q.prototype.getPrime = function(N) {
    return O(this.__prime, N);
  }, q.prototype.getGenerator = function(N) {
    return O(this._gen, N);
  }, q.prototype.setGenerator = function(N, j) {
    return j = j || "utf8", bufferExports.Buffer.isBuffer(N) || (N = new bufferExports.Buffer(N, j)), this.__gen = N, this._gen = new e(N), this;
  };
  function O(N, j) {
    var U = new bufferExports.Buffer(N.toArray());
    return j ? U.toString(j) : U;
  }
  return dh$1;
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4)
    return browser$4;
  hasRequiredBrowser$4 = 1;
  var e = requireGeneratePrime(), t = require$$1$1, o = requireDh();
  function r(p) {
    var d = new bufferExports.Buffer(t[p].prime, "hex"), b = new bufferExports.Buffer(t[p].gen, "hex");
    return new o(d, b);
  }
  var h = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function a(p, d, b, g) {
    return bufferExports.Buffer.isBuffer(d) || h[d] === void 0 ? a(p, "binary", d, b) : (d = d || "binary", g = g || "binary", b = b || new bufferExports.Buffer([2]), bufferExports.Buffer.isBuffer(b) || (b = new bufferExports.Buffer(b, g)), typeof p == "number" ? new o(e(p, b), b, !0) : (bufferExports.Buffer.isBuffer(p) || (p = new bufferExports.Buffer(p, d)), new o(p, b, !0)));
  }
  return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = r, browser$4.createDiffieHellman = browser$4.DiffieHellman = a, browser$4;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} }, hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs)
    return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1, typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick: e } : processNextickArgs.exports = process$1;
  function e(t, o, r, h) {
    if (typeof t != "function")
      throw new TypeError('"callback" argument must be a function');
    var a = arguments.length, p, d;
    switch (a) {
      case 0:
      case 1:
        return process$1.nextTick(t);
      case 2:
        return process$1.nextTick(function() {
          t.call(null, o);
        });
      case 3:
        return process$1.nextTick(function() {
          t.call(null, o, r);
        });
      case 4:
        return process$1.nextTick(function() {
          t.call(null, o, r, h);
        });
      default:
        for (p = new Array(a - 1), d = 0; d < p.length; )
          p[d++] = arguments[d];
        return process$1.nextTick(function() {
          t.apply(null, p);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray, hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray)
    return isarray;
  hasRequiredIsarray = 1;
  var e = {}.toString;
  return isarray = Array.isArray || function(t) {
    return e.call(t) == "[object Array]";
  }, isarray;
}
var streamBrowser, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser = requireEvents().EventEmitter), streamBrowser;
}
var safeBuffer = { exports: {} }, hasRequiredSafeBuffer;
function requireSafeBuffer() {
  return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(e, t) {
    var o = requireBuffer$1(), r = o.Buffer;
    function h(p, d) {
      for (var b in p)
        d[b] = p[b];
    }
    r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? e.exports = o : (h(o, t), t.Buffer = a);
    function a(p, d, b) {
      return r(p, d, b);
    }
    h(r, a), a.from = function(p, d, b) {
      if (typeof p == "number")
        throw new TypeError("Argument must not be a number");
      return r(p, d, b);
    }, a.alloc = function(p, d, b) {
      if (typeof p != "number")
        throw new TypeError("Argument must be a number");
      var g = r(p);
      return d !== void 0 ? typeof b == "string" ? g.fill(d, b) : g.fill(d) : g.fill(0), g;
    }, a.allocUnsafe = function(p) {
      if (typeof p != "number")
        throw new TypeError("Argument must be a number");
      return r(p);
    }, a.allocUnsafeSlow = function(p) {
      if (typeof p != "number")
        throw new TypeError("Argument must be a number");
      return o.SlowBuffer(p);
    };
  }(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}
var util = {}, hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil)
    return util;
  hasRequiredUtil = 1;
  function e(O) {
    return Array.isArray ? Array.isArray(O) : q(O) === "[object Array]";
  }
  util.isArray = e;
  function t(O) {
    return typeof O == "boolean";
  }
  util.isBoolean = t;
  function o(O) {
    return O === null;
  }
  util.isNull = o;
  function r(O) {
    return O == null;
  }
  util.isNullOrUndefined = r;
  function h(O) {
    return typeof O == "number";
  }
  util.isNumber = h;
  function a(O) {
    return typeof O == "string";
  }
  util.isString = a;
  function p(O) {
    return typeof O == "symbol";
  }
  util.isSymbol = p;
  function d(O) {
    return O === void 0;
  }
  util.isUndefined = d;
  function b(O) {
    return q(O) === "[object RegExp]";
  }
  util.isRegExp = b;
  function g(O) {
    return typeof O == "object" && O !== null;
  }
  util.isObject = g;
  function w(O) {
    return q(O) === "[object Date]";
  }
  util.isDate = w;
  function C(O) {
    return q(O) === "[object Error]" || O instanceof Error;
  }
  util.isError = C;
  function T(O) {
    return typeof O == "function";
  }
  util.isFunction = T;
  function k(O) {
    return O === null || typeof O == "boolean" || typeof O == "number" || typeof O == "string" || typeof O == "symbol" || // ES6 symbol
    typeof O > "u";
  }
  util.isPrimitive = k, util.isBuffer = requireBuffer$1().Buffer.isBuffer;
  function q(O) {
    return Object.prototype.toString.call(O);
  }
  return util;
}
var BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(e) {
    function t(a, p) {
      if (!(a instanceof p))
        throw new TypeError("Cannot call a class as a function");
    }
    var o = requireSafeBuffer().Buffer, r = requireUtil$1();
    function h(a, p, d) {
      a.copy(p, d);
    }
    e.exports = function() {
      function a() {
        t(this, a), this.head = null, this.tail = null, this.length = 0;
      }
      return a.prototype.push = function(p) {
        var d = { data: p, next: null };
        this.length > 0 ? this.tail.next = d : this.head = d, this.tail = d, ++this.length;
      }, a.prototype.unshift = function(p) {
        var d = { data: p, next: this.head };
        this.length === 0 && (this.tail = d), this.head = d, ++this.length;
      }, a.prototype.shift = function() {
        if (this.length !== 0) {
          var p = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, p;
        }
      }, a.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, a.prototype.join = function(p) {
        if (this.length === 0)
          return "";
        for (var d = this.head, b = "" + d.data; d = d.next; )
          b += p + d.data;
        return b;
      }, a.prototype.concat = function(p) {
        if (this.length === 0)
          return o.alloc(0);
        for (var d = o.allocUnsafe(p >>> 0), b = this.head, g = 0; b; )
          h(b.data, d, g), g += b.data.length, b = b.next;
        return d;
      }, a;
    }(), r && r.inspect && r.inspect.custom && (e.exports.prototype[r.inspect.custom] = function() {
      var a = r.inspect({ length: this.length });
      return this.constructor.name + " " + a;
    });
  }(BufferList)), BufferList.exports;
}
var destroy_1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy)
    return destroy_1;
  hasRequiredDestroy = 1;
  var e = requireProcessNextickArgs();
  function t(h, a) {
    var p = this, d = this._readableState && this._readableState.destroyed, b = this._writableState && this._writableState.destroyed;
    return d || b ? (a ? a(h) : h && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, e.nextTick(r, this, h)) : e.nextTick(r, this, h)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(h || null, function(g) {
      !a && g ? p._writableState ? p._writableState.errorEmitted || (p._writableState.errorEmitted = !0, e.nextTick(r, p, g)) : e.nextTick(r, p, g) : a && a(g);
    }), this);
  }
  function o() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function r(h, a) {
    h.emit("error", a);
  }
  return destroy_1 = {
    destroy: t,
    undestroy: o
  }, destroy_1;
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable)
    return _stream_writable;
  hasRequired_stream_writable = 1;
  var e = requireProcessNextickArgs();
  _stream_writable = O;
  function t(B) {
    var S = this;
    this.next = null, this.entry = null, this.finish = function() {
      M(S, B);
    };
  }
  var o = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : e.nextTick, r;
  O.WritableState = k;
  var h = Object.create(requireUtil());
  h.inherits = requireInherits_browser();
  var a = {
    deprecate: requireBrowser$a()
  }, p = requireStreamBrowser(), d = requireSafeBuffer().Buffer, b = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function g(B) {
    return d.from(B);
  }
  function w(B) {
    return d.isBuffer(B) || B instanceof b;
  }
  var C = requireDestroy();
  h.inherits(O, p);
  function T() {
  }
  function k(B, S) {
    r = r || require_stream_duplex(), B = B || {};
    var _ = S instanceof r;
    this.objectMode = !!B.objectMode, _ && (this.objectMode = this.objectMode || !!B.writableObjectMode);
    var E = B.highWaterMark, m = B.writableHighWaterMark, A = this.objectMode ? 16 : 16 * 1024;
    E || E === 0 ? this.highWaterMark = E : _ && (m || m === 0) ? this.highWaterMark = m : this.highWaterMark = A, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var $ = B.decodeStrings === !1;
    this.decodeStrings = !$, this.defaultEncoding = B.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(X) {
      le(S, X);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  k.prototype.getBuffer = function() {
    for (var B = this.bufferedRequest, S = []; B; )
      S.push(B), B = B.next;
    return S;
  }, function() {
    try {
      Object.defineProperty(k.prototype, "buffer", {
        get: a.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var q;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (q = Function.prototype[Symbol.hasInstance], Object.defineProperty(O, Symbol.hasInstance, {
    value: function(B) {
      return q.call(this, B) ? !0 : this !== O ? !1 : B && B._writableState instanceof k;
    }
  })) : q = function(B) {
    return B instanceof this;
  };
  function O(B) {
    if (r = r || require_stream_duplex(), !q.call(O, this) && !(this instanceof r))
      return new O(B);
    this._writableState = new k(B, this), this.writable = !0, B && (typeof B.write == "function" && (this._write = B.write), typeof B.writev == "function" && (this._writev = B.writev), typeof B.destroy == "function" && (this._destroy = B.destroy), typeof B.final == "function" && (this._final = B.final)), p.call(this);
  }
  O.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function N(B, S) {
    var _ = new Error("write after end");
    B.emit("error", _), e.nextTick(S, _);
  }
  function j(B, S, _, E) {
    var m = !0, A = !1;
    return _ === null ? A = new TypeError("May not write null values to stream") : typeof _ != "string" && _ !== void 0 && !S.objectMode && (A = new TypeError("Invalid non-string/buffer chunk")), A && (B.emit("error", A), e.nextTick(E, A), m = !1), m;
  }
  O.prototype.write = function(B, S, _) {
    var E = this._writableState, m = !1, A = !E.objectMode && w(B);
    return A && !d.isBuffer(B) && (B = g(B)), typeof S == "function" && (_ = S, S = null), A ? S = "buffer" : S || (S = E.defaultEncoding), typeof _ != "function" && (_ = T), E.ended ? N(this, _) : (A || j(this, E, B, _)) && (E.pendingcb++, m = H(this, E, A, B, S, _)), m;
  }, O.prototype.cork = function() {
    var B = this._writableState;
    B.corked++;
  }, O.prototype.uncork = function() {
    var B = this._writableState;
    B.corked && (B.corked--, !B.writing && !B.corked && !B.bufferProcessing && B.bufferedRequest && fe(this, B));
  }, O.prototype.setDefaultEncoding = function(B) {
    if (typeof B == "string" && (B = B.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((B + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + B);
    return this._writableState.defaultEncoding = B, this;
  };
  function U(B, S, _) {
    return !B.objectMode && B.decodeStrings !== !1 && typeof S == "string" && (S = d.from(S, _)), S;
  }
  Object.defineProperty(O.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function H(B, S, _, E, m, A) {
    if (!_) {
      var $ = U(S, E, m);
      E !== $ && (_ = !0, m = "buffer", E = $);
    }
    var X = S.objectMode ? 1 : E.length;
    S.length += X;
    var oe = S.length < S.highWaterMark;
    if (oe || (S.needDrain = !0), S.writing || S.corked) {
      var J = S.lastBufferedRequest;
      S.lastBufferedRequest = {
        chunk: E,
        encoding: m,
        isBuf: _,
        callback: A,
        next: null
      }, J ? J.next = S.lastBufferedRequest : S.bufferedRequest = S.lastBufferedRequest, S.bufferedRequestCount += 1;
    } else
      z(B, S, !1, X, E, m, A);
    return oe;
  }
  function z(B, S, _, E, m, A, $) {
    S.writelen = E, S.writecb = $, S.writing = !0, S.sync = !0, _ ? B._writev(m, S.onwrite) : B._write(m, A, S.onwrite), S.sync = !1;
  }
  function ee(B, S, _, E, m) {
    --S.pendingcb, _ ? (e.nextTick(m, E), e.nextTick(y, B, S), B._writableState.errorEmitted = !0, B.emit("error", E)) : (m(E), B._writableState.errorEmitted = !0, B.emit("error", E), y(B, S));
  }
  function ne(B) {
    B.writing = !1, B.writecb = null, B.length -= B.writelen, B.writelen = 0;
  }
  function le(B, S) {
    var _ = B._writableState, E = _.sync, m = _.writecb;
    if (ne(_), S)
      ee(B, _, E, S, m);
    else {
      var A = I(_);
      !A && !_.corked && !_.bufferProcessing && _.bufferedRequest && fe(B, _), E ? o(Z, B, _, A, m) : Z(B, _, A, m);
    }
  }
  function Z(B, S, _, E) {
    _ || ie(B, S), S.pendingcb--, E(), y(B, S);
  }
  function ie(B, S) {
    S.length === 0 && S.needDrain && (S.needDrain = !1, B.emit("drain"));
  }
  function fe(B, S) {
    S.bufferProcessing = !0;
    var _ = S.bufferedRequest;
    if (B._writev && _ && _.next) {
      var E = S.bufferedRequestCount, m = new Array(E), A = S.corkedRequestsFree;
      A.entry = _;
      for (var $ = 0, X = !0; _; )
        m[$] = _, _.isBuf || (X = !1), _ = _.next, $ += 1;
      m.allBuffers = X, z(B, S, !0, S.length, m, "", A.finish), S.pendingcb++, S.lastBufferedRequest = null, A.next ? (S.corkedRequestsFree = A.next, A.next = null) : S.corkedRequestsFree = new t(S), S.bufferedRequestCount = 0;
    } else {
      for (; _; ) {
        var oe = _.chunk, J = _.encoding, W = _.callback, Q = S.objectMode ? 1 : oe.length;
        if (z(B, S, !1, Q, oe, J, W), _ = _.next, S.bufferedRequestCount--, S.writing)
          break;
      }
      _ === null && (S.lastBufferedRequest = null);
    }
    S.bufferedRequest = _, S.bufferProcessing = !1;
  }
  O.prototype._write = function(B, S, _) {
    _(new Error("_write() is not implemented"));
  }, O.prototype._writev = null, O.prototype.end = function(B, S, _) {
    var E = this._writableState;
    typeof B == "function" ? (_ = B, B = null, S = null) : typeof S == "function" && (_ = S, S = null), B != null && this.write(B, S), E.corked && (E.corked = 1, this.uncork()), E.ending || v(this, E, _);
  };
  function I(B) {
    return B.ending && B.length === 0 && B.bufferedRequest === null && !B.finished && !B.writing;
  }
  function P(B, S) {
    B._final(function(_) {
      S.pendingcb--, _ && B.emit("error", _), S.prefinished = !0, B.emit("prefinish"), y(B, S);
    });
  }
  function f(B, S) {
    !S.prefinished && !S.finalCalled && (typeof B._final == "function" ? (S.pendingcb++, S.finalCalled = !0, e.nextTick(P, B, S)) : (S.prefinished = !0, B.emit("prefinish")));
  }
  function y(B, S) {
    var _ = I(S);
    return _ && (f(B, S), S.pendingcb === 0 && (S.finished = !0, B.emit("finish"))), _;
  }
  function v(B, S, _) {
    S.ending = !0, y(B, S), _ && (S.finished ? e.nextTick(_) : B.once("finish", _)), S.ended = !0, B.writable = !1;
  }
  function M(B, S, _) {
    var E = B.entry;
    for (B.entry = null; E; ) {
      var m = E.callback;
      S.pendingcb--, m(_), E = E.next;
    }
    S.corkedRequestsFree.next = B;
  }
  return Object.defineProperty(O.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(B) {
      this._writableState && (this._writableState.destroyed = B);
    }
  }), O.prototype.destroy = C.destroy, O.prototype._undestroy = C.undestroy, O.prototype._destroy = function(B, S) {
    this.end(), S(B);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex)
    return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var e = requireProcessNextickArgs(), t = Object.keys || function(C) {
    var T = [];
    for (var k in C)
      T.push(k);
    return T;
  };
  _stream_duplex = b;
  var o = Object.create(requireUtil());
  o.inherits = requireInherits_browser();
  var r = require_stream_readable(), h = require_stream_writable();
  o.inherits(b, r);
  for (var a = t(h.prototype), p = 0; p < a.length; p++) {
    var d = a[p];
    b.prototype[d] || (b.prototype[d] = h.prototype[d]);
  }
  function b(C) {
    if (!(this instanceof b))
      return new b(C);
    r.call(this, C), h.call(this, C), C && C.readable === !1 && (this.readable = !1), C && C.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, C && C.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", g);
  }
  Object.defineProperty(b.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function g() {
    this.allowHalfOpen || this._writableState.ended || e.nextTick(w, this);
  }
  function w(C) {
    C.end();
  }
  return Object.defineProperty(b.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(C) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = C, this._writableState.destroyed = C);
    }
  }), b.prototype._destroy = function(C, T) {
    this.push(null), this.end(), e.nextTick(T, C);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable)
    return _stream_readable;
  hasRequired_stream_readable = 1;
  var e = requireProcessNextickArgs();
  _stream_readable = U;
  var t = requireIsarray(), o;
  U.ReadableState = j, requireEvents().EventEmitter;
  var r = function(W, Q) {
    return W.listeners(Q).length;
  }, h = requireStreamBrowser(), a = requireSafeBuffer().Buffer, p = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function d(W) {
    return a.from(W);
  }
  function b(W) {
    return a.isBuffer(W) || W instanceof p;
  }
  var g = Object.create(requireUtil());
  g.inherits = requireInherits_browser();
  var w = requireUtil$1(), C = void 0;
  w && w.debuglog ? C = w.debuglog("stream") : C = function() {
  };
  var T = requireBufferList(), k = requireDestroy(), q;
  g.inherits(U, h);
  var O = ["error", "close", "destroy", "pause", "resume"];
  function N(W, Q, me) {
    if (typeof W.prependListener == "function")
      return W.prependListener(Q, me);
    !W._events || !W._events[Q] ? W.on(Q, me) : t(W._events[Q]) ? W._events[Q].unshift(me) : W._events[Q] = [me, W._events[Q]];
  }
  function j(W, Q) {
    o = o || require_stream_duplex(), W = W || {};
    var me = Q instanceof o;
    this.objectMode = !!W.objectMode, me && (this.objectMode = this.objectMode || !!W.readableObjectMode);
    var be = W.highWaterMark, Y = W.readableHighWaterMark, re = this.objectMode ? 16 : 16 * 1024;
    be || be === 0 ? this.highWaterMark = be : me && (Y || Y === 0) ? this.highWaterMark = Y : this.highWaterMark = re, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new T(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = W.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, W.encoding && (q || (q = requireString_decoder().StringDecoder), this.decoder = new q(W.encoding), this.encoding = W.encoding);
  }
  function U(W) {
    if (o = o || require_stream_duplex(), !(this instanceof U))
      return new U(W);
    this._readableState = new j(W, this), this.readable = !0, W && (typeof W.read == "function" && (this._read = W.read), typeof W.destroy == "function" && (this._destroy = W.destroy)), h.call(this);
  }
  Object.defineProperty(U.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(W) {
      this._readableState && (this._readableState.destroyed = W);
    }
  }), U.prototype.destroy = k.destroy, U.prototype._undestroy = k.undestroy, U.prototype._destroy = function(W, Q) {
    this.push(null), Q(W);
  }, U.prototype.push = function(W, Q) {
    var me = this._readableState, be;
    return me.objectMode ? be = !0 : typeof W == "string" && (Q = Q || me.defaultEncoding, Q !== me.encoding && (W = a.from(W, Q), Q = ""), be = !0), H(this, W, Q, !1, be);
  }, U.prototype.unshift = function(W) {
    return H(this, W, null, !0, !1);
  };
  function H(W, Q, me, be, Y) {
    var re = W._readableState;
    if (Q === null)
      re.reading = !1, fe(W, re);
    else {
      var de;
      Y || (de = ee(re, Q)), de ? W.emit("error", de) : re.objectMode || Q && Q.length > 0 ? (typeof Q != "string" && !re.objectMode && Object.getPrototypeOf(Q) !== a.prototype && (Q = d(Q)), be ? re.endEmitted ? W.emit("error", new Error("stream.unshift() after end event")) : z(W, re, Q, !0) : re.ended ? W.emit("error", new Error("stream.push() after EOF")) : (re.reading = !1, re.decoder && !me ? (Q = re.decoder.write(Q), re.objectMode || Q.length !== 0 ? z(W, re, Q, !1) : f(W, re)) : z(W, re, Q, !1))) : be || (re.reading = !1);
    }
    return ne(re);
  }
  function z(W, Q, me, be) {
    Q.flowing && Q.length === 0 && !Q.sync ? (W.emit("data", me), W.read(0)) : (Q.length += Q.objectMode ? 1 : me.length, be ? Q.buffer.unshift(me) : Q.buffer.push(me), Q.needReadable && I(W)), f(W, Q);
  }
  function ee(W, Q) {
    var me;
    return !b(Q) && typeof Q != "string" && Q !== void 0 && !W.objectMode && (me = new TypeError("Invalid non-string/buffer chunk")), me;
  }
  function ne(W) {
    return !W.ended && (W.needReadable || W.length < W.highWaterMark || W.length === 0);
  }
  U.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, U.prototype.setEncoding = function(W) {
    return q || (q = requireString_decoder().StringDecoder), this._readableState.decoder = new q(W), this._readableState.encoding = W, this;
  };
  var le = 8388608;
  function Z(W) {
    return W >= le ? W = le : (W--, W |= W >>> 1, W |= W >>> 2, W |= W >>> 4, W |= W >>> 8, W |= W >>> 16, W++), W;
  }
  function ie(W, Q) {
    return W <= 0 || Q.length === 0 && Q.ended ? 0 : Q.objectMode ? 1 : W !== W ? Q.flowing && Q.length ? Q.buffer.head.data.length : Q.length : (W > Q.highWaterMark && (Q.highWaterMark = Z(W)), W <= Q.length ? W : Q.ended ? Q.length : (Q.needReadable = !0, 0));
  }
  U.prototype.read = function(W) {
    C("read", W), W = parseInt(W, 10);
    var Q = this._readableState, me = W;
    if (W !== 0 && (Q.emittedReadable = !1), W === 0 && Q.needReadable && (Q.length >= Q.highWaterMark || Q.ended))
      return C("read: emitReadable", Q.length, Q.ended), Q.length === 0 && Q.ended ? X(this) : I(this), null;
    if (W = ie(W, Q), W === 0 && Q.ended)
      return Q.length === 0 && X(this), null;
    var be = Q.needReadable;
    C("need readable", be), (Q.length === 0 || Q.length - W < Q.highWaterMark) && (be = !0, C("length less than watermark", be)), Q.ended || Q.reading ? (be = !1, C("reading or ended", be)) : be && (C("do read"), Q.reading = !0, Q.sync = !0, Q.length === 0 && (Q.needReadable = !0), this._read(Q.highWaterMark), Q.sync = !1, Q.reading || (W = ie(me, Q)));
    var Y;
    return W > 0 ? Y = E(W, Q) : Y = null, Y === null ? (Q.needReadable = !0, W = 0) : Q.length -= W, Q.length === 0 && (Q.ended || (Q.needReadable = !0), me !== W && Q.ended && X(this)), Y !== null && this.emit("data", Y), Y;
  };
  function fe(W, Q) {
    if (!Q.ended) {
      if (Q.decoder) {
        var me = Q.decoder.end();
        me && me.length && (Q.buffer.push(me), Q.length += Q.objectMode ? 1 : me.length);
      }
      Q.ended = !0, I(W);
    }
  }
  function I(W) {
    var Q = W._readableState;
    Q.needReadable = !1, Q.emittedReadable || (C("emitReadable", Q.flowing), Q.emittedReadable = !0, Q.sync ? e.nextTick(P, W) : P(W));
  }
  function P(W) {
    C("emit readable"), W.emit("readable"), _(W);
  }
  function f(W, Q) {
    Q.readingMore || (Q.readingMore = !0, e.nextTick(y, W, Q));
  }
  function y(W, Q) {
    for (var me = Q.length; !Q.reading && !Q.flowing && !Q.ended && Q.length < Q.highWaterMark && (C("maybeReadMore read 0"), W.read(0), me !== Q.length); )
      me = Q.length;
    Q.readingMore = !1;
  }
  U.prototype._read = function(W) {
    this.emit("error", new Error("_read() is not implemented"));
  }, U.prototype.pipe = function(W, Q) {
    var me = this, be = this._readableState;
    switch (be.pipesCount) {
      case 0:
        be.pipes = W;
        break;
      case 1:
        be.pipes = [be.pipes, W];
        break;
      default:
        be.pipes.push(W);
        break;
    }
    be.pipesCount += 1, C("pipe count=%d opts=%j", be.pipesCount, Q);
    var Y = (!Q || Q.end !== !1) && W !== process$1.stdout && W !== process$1.stderr, re = Y ? Ae : ve;
    be.endEmitted ? e.nextTick(re) : me.once("end", re), W.on("unpipe", de);
    function de(Re, ke) {
      C("onunpipe"), Re === me && ke && ke.hasUnpiped === !1 && (ke.hasUnpiped = !0, L());
    }
    function Ae() {
      C("onend"), W.end();
    }
    var qe = v(me);
    W.on("drain", qe);
    var x = !1;
    function L() {
      C("cleanup"), W.removeListener("close", ge), W.removeListener("finish", ce), W.removeListener("drain", qe), W.removeListener("error", ue), W.removeListener("unpipe", de), me.removeListener("end", Ae), me.removeListener("end", ve), me.removeListener("data", F), x = !0, be.awaitDrain && (!W._writableState || W._writableState.needDrain) && qe();
    }
    var D = !1;
    me.on("data", F);
    function F(Re) {
      C("ondata"), D = !1;
      var ke = W.write(Re);
      ke === !1 && !D && ((be.pipesCount === 1 && be.pipes === W || be.pipesCount > 1 && J(be.pipes, W) !== -1) && !x && (C("false write response, pause", be.awaitDrain), be.awaitDrain++, D = !0), me.pause());
    }
    function ue(Re) {
      C("onerror", Re), ve(), W.removeListener("error", ue), r(W, "error") === 0 && W.emit("error", Re);
    }
    N(W, "error", ue);
    function ge() {
      W.removeListener("finish", ce), ve();
    }
    W.once("close", ge);
    function ce() {
      C("onfinish"), W.removeListener("close", ge), ve();
    }
    W.once("finish", ce);
    function ve() {
      C("unpipe"), me.unpipe(W);
    }
    return W.emit("pipe", me), be.flowing || (C("pipe resume"), me.resume()), W;
  };
  function v(W) {
    return function() {
      var Q = W._readableState;
      C("pipeOnDrain", Q.awaitDrain), Q.awaitDrain && Q.awaitDrain--, Q.awaitDrain === 0 && r(W, "data") && (Q.flowing = !0, _(W));
    };
  }
  U.prototype.unpipe = function(W) {
    var Q = this._readableState, me = { hasUnpiped: !1 };
    if (Q.pipesCount === 0)
      return this;
    if (Q.pipesCount === 1)
      return W && W !== Q.pipes ? this : (W || (W = Q.pipes), Q.pipes = null, Q.pipesCount = 0, Q.flowing = !1, W && W.emit("unpipe", this, me), this);
    if (!W) {
      var be = Q.pipes, Y = Q.pipesCount;
      Q.pipes = null, Q.pipesCount = 0, Q.flowing = !1;
      for (var re = 0; re < Y; re++)
        be[re].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var de = J(Q.pipes, W);
    return de === -1 ? this : (Q.pipes.splice(de, 1), Q.pipesCount -= 1, Q.pipesCount === 1 && (Q.pipes = Q.pipes[0]), W.emit("unpipe", this, me), this);
  }, U.prototype.on = function(W, Q) {
    var me = h.prototype.on.call(this, W, Q);
    if (W === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (W === "readable") {
      var be = this._readableState;
      !be.endEmitted && !be.readableListening && (be.readableListening = be.needReadable = !0, be.emittedReadable = !1, be.reading ? be.length && I(this) : e.nextTick(M, this));
    }
    return me;
  }, U.prototype.addListener = U.prototype.on;
  function M(W) {
    C("readable nexttick read 0"), W.read(0);
  }
  U.prototype.resume = function() {
    var W = this._readableState;
    return W.flowing || (C("resume"), W.flowing = !0, B(this, W)), this;
  };
  function B(W, Q) {
    Q.resumeScheduled || (Q.resumeScheduled = !0, e.nextTick(S, W, Q));
  }
  function S(W, Q) {
    Q.reading || (C("resume read 0"), W.read(0)), Q.resumeScheduled = !1, Q.awaitDrain = 0, W.emit("resume"), _(W), Q.flowing && !Q.reading && W.read(0);
  }
  U.prototype.pause = function() {
    return C("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (C("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function _(W) {
    var Q = W._readableState;
    for (C("flow", Q.flowing); Q.flowing && W.read() !== null; )
      ;
  }
  U.prototype.wrap = function(W) {
    var Q = this, me = this._readableState, be = !1;
    W.on("end", function() {
      if (C("wrapped end"), me.decoder && !me.ended) {
        var de = me.decoder.end();
        de && de.length && Q.push(de);
      }
      Q.push(null);
    }), W.on("data", function(de) {
      if (C("wrapped data"), me.decoder && (de = me.decoder.write(de)), !(me.objectMode && de == null) && !(!me.objectMode && (!de || !de.length))) {
        var Ae = Q.push(de);
        Ae || (be = !0, W.pause());
      }
    });
    for (var Y in W)
      this[Y] === void 0 && typeof W[Y] == "function" && (this[Y] = /* @__PURE__ */ function(de) {
        return function() {
          return W[de].apply(W, arguments);
        };
      }(Y));
    for (var re = 0; re < O.length; re++)
      W.on(O[re], this.emit.bind(this, O[re]));
    return this._read = function(de) {
      C("wrapped _read", de), be && (be = !1, W.resume());
    }, this;
  }, Object.defineProperty(U.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), U._fromList = E;
  function E(W, Q) {
    if (Q.length === 0)
      return null;
    var me;
    return Q.objectMode ? me = Q.buffer.shift() : !W || W >= Q.length ? (Q.decoder ? me = Q.buffer.join("") : Q.buffer.length === 1 ? me = Q.buffer.head.data : me = Q.buffer.concat(Q.length), Q.buffer.clear()) : me = m(W, Q.buffer, Q.decoder), me;
  }
  function m(W, Q, me) {
    var be;
    return W < Q.head.data.length ? (be = Q.head.data.slice(0, W), Q.head.data = Q.head.data.slice(W)) : W === Q.head.data.length ? be = Q.shift() : be = me ? A(W, Q) : $(W, Q), be;
  }
  function A(W, Q) {
    var me = Q.head, be = 1, Y = me.data;
    for (W -= Y.length; me = me.next; ) {
      var re = me.data, de = W > re.length ? re.length : W;
      if (de === re.length ? Y += re : Y += re.slice(0, W), W -= de, W === 0) {
        de === re.length ? (++be, me.next ? Q.head = me.next : Q.head = Q.tail = null) : (Q.head = me, me.data = re.slice(de));
        break;
      }
      ++be;
    }
    return Q.length -= be, Y;
  }
  function $(W, Q) {
    var me = a.allocUnsafe(W), be = Q.head, Y = 1;
    for (be.data.copy(me), W -= be.data.length; be = be.next; ) {
      var re = be.data, de = W > re.length ? re.length : W;
      if (re.copy(me, me.length - W, 0, de), W -= de, W === 0) {
        de === re.length ? (++Y, be.next ? Q.head = be.next : Q.head = Q.tail = null) : (Q.head = be, be.data = re.slice(de));
        break;
      }
      ++Y;
    }
    return Q.length -= Y, me;
  }
  function X(W) {
    var Q = W._readableState;
    if (Q.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    Q.endEmitted || (Q.ended = !0, e.nextTick(oe, Q, W));
  }
  function oe(W, Q) {
    !W.endEmitted && W.length === 0 && (W.endEmitted = !0, Q.readable = !1, Q.emit("end"));
  }
  function J(W, Q) {
    for (var me = 0, be = W.length; me < be; me++)
      if (W[me] === Q)
        return me;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform)
    return _stream_transform;
  hasRequired_stream_transform = 1, _stream_transform = r;
  var e = require_stream_duplex(), t = Object.create(requireUtil());
  t.inherits = requireInherits_browser(), t.inherits(r, e);
  function o(p, d) {
    var b = this._transformState;
    b.transforming = !1;
    var g = b.writecb;
    if (!g)
      return this.emit("error", new Error("write callback called multiple times"));
    b.writechunk = null, b.writecb = null, d != null && this.push(d), g(p);
    var w = this._readableState;
    w.reading = !1, (w.needReadable || w.length < w.highWaterMark) && this._read(w.highWaterMark);
  }
  function r(p) {
    if (!(this instanceof r))
      return new r(p);
    e.call(this, p), this._transformState = {
      afterTransform: o.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, p && (typeof p.transform == "function" && (this._transform = p.transform), typeof p.flush == "function" && (this._flush = p.flush)), this.on("prefinish", h);
  }
  function h() {
    var p = this;
    typeof this._flush == "function" ? this._flush(function(d, b) {
      a(p, d, b);
    }) : a(this, null, null);
  }
  r.prototype.push = function(p, d) {
    return this._transformState.needTransform = !1, e.prototype.push.call(this, p, d);
  }, r.prototype._transform = function(p, d, b) {
    throw new Error("_transform() is not implemented");
  }, r.prototype._write = function(p, d, b) {
    var g = this._transformState;
    if (g.writecb = b, g.writechunk = p, g.writeencoding = d, !g.transforming) {
      var w = this._readableState;
      (g.needTransform || w.needReadable || w.length < w.highWaterMark) && this._read(w.highWaterMark);
    }
  }, r.prototype._read = function(p) {
    var d = this._transformState;
    d.writechunk !== null && d.writecb && !d.transforming ? (d.transforming = !0, this._transform(d.writechunk, d.writeencoding, d.afterTransform)) : d.needTransform = !0;
  }, r.prototype._destroy = function(p, d) {
    var b = this;
    e.prototype._destroy.call(this, p, function(g) {
      d(g), b.emit("close");
    });
  };
  function a(p, d, b) {
    if (d)
      return p.emit("error", d);
    if (b != null && p.push(b), p._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (p._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return p.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough)
    return _stream_passthrough;
  hasRequired_stream_passthrough = 1, _stream_passthrough = o;
  var e = require_stream_transform(), t = Object.create(requireUtil());
  t.inherits = requireInherits_browser(), t.inherits(o, e);
  function o(r) {
    if (!(this instanceof o))
      return new o(r);
    e.call(this, r);
  }
  return o.prototype._transform = function(r, h, a) {
    a(null, r);
  }, _stream_passthrough;
}
var hasRequiredReadableBrowser;
function requireReadableBrowser() {
  return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1, function(e, t) {
    t = e.exports = require_stream_readable(), t.Stream = t, t.Readable = t, t.Writable = require_stream_writable(), t.Duplex = require_stream_duplex(), t.Transform = require_stream_transform(), t.PassThrough = require_stream_passthrough();
  }(readableBrowser, readableBrowser.exports)), readableBrowser.exports;
}
var sign = { exports: {} }, bn$1 = { exports: {} }, hasRequiredBn$1;
function requireBn$1() {
  return hasRequiredBn$1 || (hasRequiredBn$1 = 1, function(e) {
    (function(t, o) {
      function r(f, y) {
        if (!f)
          throw new Error(y || "Assertion failed");
      }
      function h(f, y) {
        f.super_ = y;
        var v = function() {
        };
        v.prototype = y.prototype, f.prototype = new v(), f.prototype.constructor = f;
      }
      function a(f, y, v) {
        if (a.isBN(f))
          return f;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, f !== null && ((y === "le" || y === "be") && (v = y, y = 10), this._init(f || 0, y || 10, v || "be"));
      }
      typeof t == "object" ? t.exports = a : o.BN = a, a.BN = a, a.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = requireBuffer$1().Buffer;
      } catch {
      }
      a.isBN = function(f) {
        return f instanceof a ? !0 : f !== null && typeof f == "object" && f.constructor.wordSize === a.wordSize && Array.isArray(f.words);
      }, a.max = function(f, y) {
        return f.cmp(y) > 0 ? f : y;
      }, a.min = function(f, y) {
        return f.cmp(y) < 0 ? f : y;
      }, a.prototype._init = function(f, y, v) {
        if (typeof f == "number")
          return this._initNumber(f, y, v);
        if (typeof f == "object")
          return this._initArray(f, y, v);
        y === "hex" && (y = 16), r(y === (y | 0) && y >= 2 && y <= 36), f = f.toString().replace(/\s+/g, "");
        var M = 0;
        f[0] === "-" && (M++, this.negative = 1), M < f.length && (y === 16 ? this._parseHex(f, M, v) : (this._parseBase(f, y, M), v === "le" && this._initArray(this.toArray(), y, v)));
      }, a.prototype._initNumber = function(f, y, v) {
        f < 0 && (this.negative = 1, f = -f), f < 67108864 ? (this.words = [f & 67108863], this.length = 1) : f < 4503599627370496 ? (this.words = [
          f & 67108863,
          f / 67108864 & 67108863
        ], this.length = 2) : (r(f < 9007199254740992), this.words = [
          f & 67108863,
          f / 67108864 & 67108863,
          1
        ], this.length = 3), v === "le" && this._initArray(this.toArray(), y, v);
      }, a.prototype._initArray = function(f, y, v) {
        if (r(typeof f.length == "number"), f.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(f.length / 3), this.words = new Array(this.length);
        for (var M = 0; M < this.length; M++)
          this.words[M] = 0;
        var B, S, _ = 0;
        if (v === "be")
          for (M = f.length - 1, B = 0; M >= 0; M -= 3)
            S = f[M] | f[M - 1] << 8 | f[M - 2] << 16, this.words[B] |= S << _ & 67108863, this.words[B + 1] = S >>> 26 - _ & 67108863, _ += 24, _ >= 26 && (_ -= 26, B++);
        else if (v === "le")
          for (M = 0, B = 0; M < f.length; M += 3)
            S = f[M] | f[M + 1] << 8 | f[M + 2] << 16, this.words[B] |= S << _ & 67108863, this.words[B + 1] = S >>> 26 - _ & 67108863, _ += 24, _ >= 26 && (_ -= 26, B++);
        return this._strip();
      };
      function d(f, y) {
        var v = f.charCodeAt(y);
        if (v >= 48 && v <= 57)
          return v - 48;
        if (v >= 65 && v <= 70)
          return v - 55;
        if (v >= 97 && v <= 102)
          return v - 87;
        r(!1, "Invalid character in " + f);
      }
      function b(f, y, v) {
        var M = d(f, v);
        return v - 1 >= y && (M |= d(f, v - 1) << 4), M;
      }
      a.prototype._parseHex = function(f, y, v) {
        this.length = Math.ceil((f.length - y) / 6), this.words = new Array(this.length);
        for (var M = 0; M < this.length; M++)
          this.words[M] = 0;
        var B = 0, S = 0, _;
        if (v === "be")
          for (M = f.length - 1; M >= y; M -= 2)
            _ = b(f, y, M) << B, this.words[S] |= _ & 67108863, B >= 18 ? (B -= 18, S += 1, this.words[S] |= _ >>> 26) : B += 8;
        else {
          var E = f.length - y;
          for (M = E % 2 === 0 ? y + 1 : y; M < f.length; M += 2)
            _ = b(f, y, M) << B, this.words[S] |= _ & 67108863, B >= 18 ? (B -= 18, S += 1, this.words[S] |= _ >>> 26) : B += 8;
        }
        this._strip();
      };
      function g(f, y, v, M) {
        for (var B = 0, S = 0, _ = Math.min(f.length, v), E = y; E < _; E++) {
          var m = f.charCodeAt(E) - 48;
          B *= M, m >= 49 ? S = m - 49 + 10 : m >= 17 ? S = m - 17 + 10 : S = m, r(m >= 0 && S < M, "Invalid character"), B += S;
        }
        return B;
      }
      a.prototype._parseBase = function(f, y, v) {
        this.words = [0], this.length = 1;
        for (var M = 0, B = 1; B <= 67108863; B *= y)
          M++;
        M--, B = B / y | 0;
        for (var S = f.length - v, _ = S % M, E = Math.min(S, S - _) + v, m = 0, A = v; A < E; A += M)
          m = g(f, A, A + M, y), this.imuln(B), this.words[0] + m < 67108864 ? this.words[0] += m : this._iaddn(m);
        if (_ !== 0) {
          var $ = 1;
          for (m = g(f, A, f.length, y), A = 0; A < _; A++)
            $ *= y;
          this.imuln($), this.words[0] + m < 67108864 ? this.words[0] += m : this._iaddn(m);
        }
        this._strip();
      }, a.prototype.copy = function(f) {
        f.words = new Array(this.length);
        for (var y = 0; y < this.length; y++)
          f.words[y] = this.words[y];
        f.length = this.length, f.negative = this.negative, f.red = this.red;
      };
      function w(f, y) {
        f.words = y.words, f.length = y.length, f.negative = y.negative, f.red = y.red;
      }
      if (a.prototype._move = function(f) {
        w(f, this);
      }, a.prototype.clone = function() {
        var f = new a(null);
        return this.copy(f), f;
      }, a.prototype._expand = function(f) {
        for (; this.length < f; )
          this.words[this.length++] = 0;
        return this;
      }, a.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, a.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          a.prototype[Symbol.for("nodejs.util.inspect.custom")] = C;
        } catch {
          a.prototype.inspect = C;
        }
      else
        a.prototype.inspect = C;
      function C() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var T = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], k = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], q = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      a.prototype.toString = function(f, y) {
        f = f || 10, y = y | 0 || 1;
        var v;
        if (f === 16 || f === "hex") {
          v = "";
          for (var M = 0, B = 0, S = 0; S < this.length; S++) {
            var _ = this.words[S], E = ((_ << M | B) & 16777215).toString(16);
            B = _ >>> 24 - M & 16777215, M += 2, M >= 26 && (M -= 26, S--), B !== 0 || S !== this.length - 1 ? v = T[6 - E.length] + E + v : v = E + v;
          }
          for (B !== 0 && (v = B.toString(16) + v); v.length % y !== 0; )
            v = "0" + v;
          return this.negative !== 0 && (v = "-" + v), v;
        }
        if (f === (f | 0) && f >= 2 && f <= 36) {
          var m = k[f], A = q[f];
          v = "";
          var $ = this.clone();
          for ($.negative = 0; !$.isZero(); ) {
            var X = $.modrn(A).toString(f);
            $ = $.idivn(A), $.isZero() ? v = X + v : v = T[m - X.length] + X + v;
          }
          for (this.isZero() && (v = "0" + v); v.length % y !== 0; )
            v = "0" + v;
          return this.negative !== 0 && (v = "-" + v), v;
        }
        r(!1, "Base should be between 2 and 36");
      }, a.prototype.toNumber = function() {
        var f = this.words[0];
        return this.length === 2 ? f += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f : f;
      }, a.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, p && (a.prototype.toBuffer = function(f, y) {
        return this.toArrayLike(p, f, y);
      }), a.prototype.toArray = function(f, y) {
        return this.toArrayLike(Array, f, y);
      };
      var O = function(f, y) {
        return f.allocUnsafe ? f.allocUnsafe(y) : new f(y);
      };
      a.prototype.toArrayLike = function(f, y, v) {
        this._strip();
        var M = this.byteLength(), B = v || Math.max(1, M);
        r(M <= B, "byte array longer than desired length"), r(B > 0, "Requested array length <= 0");
        var S = O(f, B), _ = y === "le" ? "LE" : "BE";
        return this["_toArrayLike" + _](S, M), S;
      }, a.prototype._toArrayLikeLE = function(f, y) {
        for (var v = 0, M = 0, B = 0, S = 0; B < this.length; B++) {
          var _ = this.words[B] << S | M;
          f[v++] = _ & 255, v < f.length && (f[v++] = _ >> 8 & 255), v < f.length && (f[v++] = _ >> 16 & 255), S === 6 ? (v < f.length && (f[v++] = _ >> 24 & 255), M = 0, S = 0) : (M = _ >>> 24, S += 2);
        }
        if (v < f.length)
          for (f[v++] = M; v < f.length; )
            f[v++] = 0;
      }, a.prototype._toArrayLikeBE = function(f, y) {
        for (var v = f.length - 1, M = 0, B = 0, S = 0; B < this.length; B++) {
          var _ = this.words[B] << S | M;
          f[v--] = _ & 255, v >= 0 && (f[v--] = _ >> 8 & 255), v >= 0 && (f[v--] = _ >> 16 & 255), S === 6 ? (v >= 0 && (f[v--] = _ >> 24 & 255), M = 0, S = 0) : (M = _ >>> 24, S += 2);
        }
        if (v >= 0)
          for (f[v--] = M; v >= 0; )
            f[v--] = 0;
      }, Math.clz32 ? a.prototype._countBits = function(f) {
        return 32 - Math.clz32(f);
      } : a.prototype._countBits = function(f) {
        var y = f, v = 0;
        return y >= 4096 && (v += 13, y >>>= 13), y >= 64 && (v += 7, y >>>= 7), y >= 8 && (v += 4, y >>>= 4), y >= 2 && (v += 2, y >>>= 2), v + y;
      }, a.prototype._zeroBits = function(f) {
        if (f === 0)
          return 26;
        var y = f, v = 0;
        return y & 8191 || (v += 13, y >>>= 13), y & 127 || (v += 7, y >>>= 7), y & 15 || (v += 4, y >>>= 4), y & 3 || (v += 2, y >>>= 2), y & 1 || v++, v;
      }, a.prototype.bitLength = function() {
        var f = this.words[this.length - 1], y = this._countBits(f);
        return (this.length - 1) * 26 + y;
      };
      function N(f) {
        for (var y = new Array(f.bitLength()), v = 0; v < y.length; v++) {
          var M = v / 26 | 0, B = v % 26;
          y[v] = f.words[M] >>> B & 1;
        }
        return y;
      }
      a.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var f = 0, y = 0; y < this.length; y++) {
          var v = this._zeroBits(this.words[y]);
          if (f += v, v !== 26)
            break;
        }
        return f;
      }, a.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, a.prototype.toTwos = function(f) {
        return this.negative !== 0 ? this.abs().inotn(f).iaddn(1) : this.clone();
      }, a.prototype.fromTwos = function(f) {
        return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone();
      }, a.prototype.isNeg = function() {
        return this.negative !== 0;
      }, a.prototype.neg = function() {
        return this.clone().ineg();
      }, a.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, a.prototype.iuor = function(f) {
        for (; this.length < f.length; )
          this.words[this.length++] = 0;
        for (var y = 0; y < f.length; y++)
          this.words[y] = this.words[y] | f.words[y];
        return this._strip();
      }, a.prototype.ior = function(f) {
        return r((this.negative | f.negative) === 0), this.iuor(f);
      }, a.prototype.or = function(f) {
        return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this);
      }, a.prototype.uor = function(f) {
        return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this);
      }, a.prototype.iuand = function(f) {
        var y;
        this.length > f.length ? y = f : y = this;
        for (var v = 0; v < y.length; v++)
          this.words[v] = this.words[v] & f.words[v];
        return this.length = y.length, this._strip();
      }, a.prototype.iand = function(f) {
        return r((this.negative | f.negative) === 0), this.iuand(f);
      }, a.prototype.and = function(f) {
        return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this);
      }, a.prototype.uand = function(f) {
        return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this);
      }, a.prototype.iuxor = function(f) {
        var y, v;
        this.length > f.length ? (y = this, v = f) : (y = f, v = this);
        for (var M = 0; M < v.length; M++)
          this.words[M] = y.words[M] ^ v.words[M];
        if (this !== y)
          for (; M < y.length; M++)
            this.words[M] = y.words[M];
        return this.length = y.length, this._strip();
      }, a.prototype.ixor = function(f) {
        return r((this.negative | f.negative) === 0), this.iuxor(f);
      }, a.prototype.xor = function(f) {
        return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this);
      }, a.prototype.uxor = function(f) {
        return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this);
      }, a.prototype.inotn = function(f) {
        r(typeof f == "number" && f >= 0);
        var y = Math.ceil(f / 26) | 0, v = f % 26;
        this._expand(y), v > 0 && y--;
        for (var M = 0; M < y; M++)
          this.words[M] = ~this.words[M] & 67108863;
        return v > 0 && (this.words[M] = ~this.words[M] & 67108863 >> 26 - v), this._strip();
      }, a.prototype.notn = function(f) {
        return this.clone().inotn(f);
      }, a.prototype.setn = function(f, y) {
        r(typeof f == "number" && f >= 0);
        var v = f / 26 | 0, M = f % 26;
        return this._expand(v + 1), y ? this.words[v] = this.words[v] | 1 << M : this.words[v] = this.words[v] & ~(1 << M), this._strip();
      }, a.prototype.iadd = function(f) {
        var y;
        if (this.negative !== 0 && f.negative === 0)
          return this.negative = 0, y = this.isub(f), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && f.negative !== 0)
          return f.negative = 0, y = this.isub(f), f.negative = 1, y._normSign();
        var v, M;
        this.length > f.length ? (v = this, M = f) : (v = f, M = this);
        for (var B = 0, S = 0; S < M.length; S++)
          y = (v.words[S] | 0) + (M.words[S] | 0) + B, this.words[S] = y & 67108863, B = y >>> 26;
        for (; B !== 0 && S < v.length; S++)
          y = (v.words[S] | 0) + B, this.words[S] = y & 67108863, B = y >>> 26;
        if (this.length = v.length, B !== 0)
          this.words[this.length] = B, this.length++;
        else if (v !== this)
          for (; S < v.length; S++)
            this.words[S] = v.words[S];
        return this;
      }, a.prototype.add = function(f) {
        var y;
        return f.negative !== 0 && this.negative === 0 ? (f.negative = 0, y = this.sub(f), f.negative ^= 1, y) : f.negative === 0 && this.negative !== 0 ? (this.negative = 0, y = f.sub(this), this.negative = 1, y) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this);
      }, a.prototype.isub = function(f) {
        if (f.negative !== 0) {
          f.negative = 0;
          var y = this.iadd(f);
          return f.negative = 1, y._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(f), this.negative = 1, this._normSign();
        var v = this.cmp(f);
        if (v === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var M, B;
        v > 0 ? (M = this, B = f) : (M = f, B = this);
        for (var S = 0, _ = 0; _ < B.length; _++)
          y = (M.words[_] | 0) - (B.words[_] | 0) + S, S = y >> 26, this.words[_] = y & 67108863;
        for (; S !== 0 && _ < M.length; _++)
          y = (M.words[_] | 0) + S, S = y >> 26, this.words[_] = y & 67108863;
        if (S === 0 && _ < M.length && M !== this)
          for (; _ < M.length; _++)
            this.words[_] = M.words[_];
        return this.length = Math.max(this.length, _), M !== this && (this.negative = 1), this._strip();
      }, a.prototype.sub = function(f) {
        return this.clone().isub(f);
      };
      function j(f, y, v) {
        v.negative = y.negative ^ f.negative;
        var M = f.length + y.length | 0;
        v.length = M, M = M - 1 | 0;
        var B = f.words[0] | 0, S = y.words[0] | 0, _ = B * S, E = _ & 67108863, m = _ / 67108864 | 0;
        v.words[0] = E;
        for (var A = 1; A < M; A++) {
          for (var $ = m >>> 26, X = m & 67108863, oe = Math.min(A, y.length - 1), J = Math.max(0, A - f.length + 1); J <= oe; J++) {
            var W = A - J | 0;
            B = f.words[W] | 0, S = y.words[J] | 0, _ = B * S + X, $ += _ / 67108864 | 0, X = _ & 67108863;
          }
          v.words[A] = X | 0, m = $ | 0;
        }
        return m !== 0 ? v.words[A] = m | 0 : v.length--, v._strip();
      }
      var U = function(f, y, v) {
        var M = f.words, B = y.words, S = v.words, _ = 0, E, m, A, $ = M[0] | 0, X = $ & 8191, oe = $ >>> 13, J = M[1] | 0, W = J & 8191, Q = J >>> 13, me = M[2] | 0, be = me & 8191, Y = me >>> 13, re = M[3] | 0, de = re & 8191, Ae = re >>> 13, qe = M[4] | 0, x = qe & 8191, L = qe >>> 13, D = M[5] | 0, F = D & 8191, ue = D >>> 13, ge = M[6] | 0, ce = ge & 8191, ve = ge >>> 13, Re = M[7] | 0, ke = Re & 8191, Ce = Re >>> 13, Le = M[8] | 0, Oe = Le & 8191, Pe = Le >>> 13, et = M[9] | 0, Ye = et & 8191, Ne = et >>> 13, Tt = B[0] | 0, tt = Tt & 8191, Ue = Tt >>> 13, Ct = B[1] | 0, rt = Ct & 8191, Ke = Ct >>> 13, ii = B[2] | 0, it = ii & 8191, $e = ii >>> 13, Ot = B[3] | 0, vt = Ot & 8191, Fe = Ot >>> 13, ni = B[4] | 0, nt = ni & 8191, ze = ni >>> 13, oi = B[5] | 0, ot = oi & 8191, Xe = oi >>> 13, Dt = B[6] | 0, Ze = Dt & 8191, je = Dt >>> 13, ri = B[7] | 0, St = ri & 8191, Qe = ri >>> 13, ai = B[8] | 0, It = ai & 8191, Je = ai >>> 13, si = B[9] | 0, At = si & 8191, Bt = si >>> 13;
        v.negative = f.negative ^ y.negative, v.length = 19, E = Math.imul(X, tt), m = Math.imul(X, Ue), m = m + Math.imul(oe, tt) | 0, A = Math.imul(oe, Ue);
        var ui = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (ui >>> 26) | 0, ui &= 67108863, E = Math.imul(W, tt), m = Math.imul(W, Ue), m = m + Math.imul(Q, tt) | 0, A = Math.imul(Q, Ue), E = E + Math.imul(X, rt) | 0, m = m + Math.imul(X, Ke) | 0, m = m + Math.imul(oe, rt) | 0, A = A + Math.imul(oe, Ke) | 0;
        var fi = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (fi >>> 26) | 0, fi &= 67108863, E = Math.imul(be, tt), m = Math.imul(be, Ue), m = m + Math.imul(Y, tt) | 0, A = Math.imul(Y, Ue), E = E + Math.imul(W, rt) | 0, m = m + Math.imul(W, Ke) | 0, m = m + Math.imul(Q, rt) | 0, A = A + Math.imul(Q, Ke) | 0, E = E + Math.imul(X, it) | 0, m = m + Math.imul(X, $e) | 0, m = m + Math.imul(oe, it) | 0, A = A + Math.imul(oe, $e) | 0;
        var hi = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (hi >>> 26) | 0, hi &= 67108863, E = Math.imul(de, tt), m = Math.imul(de, Ue), m = m + Math.imul(Ae, tt) | 0, A = Math.imul(Ae, Ue), E = E + Math.imul(be, rt) | 0, m = m + Math.imul(be, Ke) | 0, m = m + Math.imul(Y, rt) | 0, A = A + Math.imul(Y, Ke) | 0, E = E + Math.imul(W, it) | 0, m = m + Math.imul(W, $e) | 0, m = m + Math.imul(Q, it) | 0, A = A + Math.imul(Q, $e) | 0, E = E + Math.imul(X, vt) | 0, m = m + Math.imul(X, Fe) | 0, m = m + Math.imul(oe, vt) | 0, A = A + Math.imul(oe, Fe) | 0;
        var ci = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (ci >>> 26) | 0, ci &= 67108863, E = Math.imul(x, tt), m = Math.imul(x, Ue), m = m + Math.imul(L, tt) | 0, A = Math.imul(L, Ue), E = E + Math.imul(de, rt) | 0, m = m + Math.imul(de, Ke) | 0, m = m + Math.imul(Ae, rt) | 0, A = A + Math.imul(Ae, Ke) | 0, E = E + Math.imul(be, it) | 0, m = m + Math.imul(be, $e) | 0, m = m + Math.imul(Y, it) | 0, A = A + Math.imul(Y, $e) | 0, E = E + Math.imul(W, vt) | 0, m = m + Math.imul(W, Fe) | 0, m = m + Math.imul(Q, vt) | 0, A = A + Math.imul(Q, Fe) | 0, E = E + Math.imul(X, nt) | 0, m = m + Math.imul(X, ze) | 0, m = m + Math.imul(oe, nt) | 0, A = A + Math.imul(oe, ze) | 0;
        var li = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (li >>> 26) | 0, li &= 67108863, E = Math.imul(F, tt), m = Math.imul(F, Ue), m = m + Math.imul(ue, tt) | 0, A = Math.imul(ue, Ue), E = E + Math.imul(x, rt) | 0, m = m + Math.imul(x, Ke) | 0, m = m + Math.imul(L, rt) | 0, A = A + Math.imul(L, Ke) | 0, E = E + Math.imul(de, it) | 0, m = m + Math.imul(de, $e) | 0, m = m + Math.imul(Ae, it) | 0, A = A + Math.imul(Ae, $e) | 0, E = E + Math.imul(be, vt) | 0, m = m + Math.imul(be, Fe) | 0, m = m + Math.imul(Y, vt) | 0, A = A + Math.imul(Y, Fe) | 0, E = E + Math.imul(W, nt) | 0, m = m + Math.imul(W, ze) | 0, m = m + Math.imul(Q, nt) | 0, A = A + Math.imul(Q, ze) | 0, E = E + Math.imul(X, ot) | 0, m = m + Math.imul(X, Xe) | 0, m = m + Math.imul(oe, ot) | 0, A = A + Math.imul(oe, Xe) | 0;
        var di = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (di >>> 26) | 0, di &= 67108863, E = Math.imul(ce, tt), m = Math.imul(ce, Ue), m = m + Math.imul(ve, tt) | 0, A = Math.imul(ve, Ue), E = E + Math.imul(F, rt) | 0, m = m + Math.imul(F, Ke) | 0, m = m + Math.imul(ue, rt) | 0, A = A + Math.imul(ue, Ke) | 0, E = E + Math.imul(x, it) | 0, m = m + Math.imul(x, $e) | 0, m = m + Math.imul(L, it) | 0, A = A + Math.imul(L, $e) | 0, E = E + Math.imul(de, vt) | 0, m = m + Math.imul(de, Fe) | 0, m = m + Math.imul(Ae, vt) | 0, A = A + Math.imul(Ae, Fe) | 0, E = E + Math.imul(be, nt) | 0, m = m + Math.imul(be, ze) | 0, m = m + Math.imul(Y, nt) | 0, A = A + Math.imul(Y, ze) | 0, E = E + Math.imul(W, ot) | 0, m = m + Math.imul(W, Xe) | 0, m = m + Math.imul(Q, ot) | 0, A = A + Math.imul(Q, Xe) | 0, E = E + Math.imul(X, Ze) | 0, m = m + Math.imul(X, je) | 0, m = m + Math.imul(oe, Ze) | 0, A = A + Math.imul(oe, je) | 0;
        var pi = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (pi >>> 26) | 0, pi &= 67108863, E = Math.imul(ke, tt), m = Math.imul(ke, Ue), m = m + Math.imul(Ce, tt) | 0, A = Math.imul(Ce, Ue), E = E + Math.imul(ce, rt) | 0, m = m + Math.imul(ce, Ke) | 0, m = m + Math.imul(ve, rt) | 0, A = A + Math.imul(ve, Ke) | 0, E = E + Math.imul(F, it) | 0, m = m + Math.imul(F, $e) | 0, m = m + Math.imul(ue, it) | 0, A = A + Math.imul(ue, $e) | 0, E = E + Math.imul(x, vt) | 0, m = m + Math.imul(x, Fe) | 0, m = m + Math.imul(L, vt) | 0, A = A + Math.imul(L, Fe) | 0, E = E + Math.imul(de, nt) | 0, m = m + Math.imul(de, ze) | 0, m = m + Math.imul(Ae, nt) | 0, A = A + Math.imul(Ae, ze) | 0, E = E + Math.imul(be, ot) | 0, m = m + Math.imul(be, Xe) | 0, m = m + Math.imul(Y, ot) | 0, A = A + Math.imul(Y, Xe) | 0, E = E + Math.imul(W, Ze) | 0, m = m + Math.imul(W, je) | 0, m = m + Math.imul(Q, Ze) | 0, A = A + Math.imul(Q, je) | 0, E = E + Math.imul(X, St) | 0, m = m + Math.imul(X, Qe) | 0, m = m + Math.imul(oe, St) | 0, A = A + Math.imul(oe, Qe) | 0;
        var yi = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (yi >>> 26) | 0, yi &= 67108863, E = Math.imul(Oe, tt), m = Math.imul(Oe, Ue), m = m + Math.imul(Pe, tt) | 0, A = Math.imul(Pe, Ue), E = E + Math.imul(ke, rt) | 0, m = m + Math.imul(ke, Ke) | 0, m = m + Math.imul(Ce, rt) | 0, A = A + Math.imul(Ce, Ke) | 0, E = E + Math.imul(ce, it) | 0, m = m + Math.imul(ce, $e) | 0, m = m + Math.imul(ve, it) | 0, A = A + Math.imul(ve, $e) | 0, E = E + Math.imul(F, vt) | 0, m = m + Math.imul(F, Fe) | 0, m = m + Math.imul(ue, vt) | 0, A = A + Math.imul(ue, Fe) | 0, E = E + Math.imul(x, nt) | 0, m = m + Math.imul(x, ze) | 0, m = m + Math.imul(L, nt) | 0, A = A + Math.imul(L, ze) | 0, E = E + Math.imul(de, ot) | 0, m = m + Math.imul(de, Xe) | 0, m = m + Math.imul(Ae, ot) | 0, A = A + Math.imul(Ae, Xe) | 0, E = E + Math.imul(be, Ze) | 0, m = m + Math.imul(be, je) | 0, m = m + Math.imul(Y, Ze) | 0, A = A + Math.imul(Y, je) | 0, E = E + Math.imul(W, St) | 0, m = m + Math.imul(W, Qe) | 0, m = m + Math.imul(Q, St) | 0, A = A + Math.imul(Q, Qe) | 0, E = E + Math.imul(X, It) | 0, m = m + Math.imul(X, Je) | 0, m = m + Math.imul(oe, It) | 0, A = A + Math.imul(oe, Je) | 0;
        var mi = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (mi >>> 26) | 0, mi &= 67108863, E = Math.imul(Ye, tt), m = Math.imul(Ye, Ue), m = m + Math.imul(Ne, tt) | 0, A = Math.imul(Ne, Ue), E = E + Math.imul(Oe, rt) | 0, m = m + Math.imul(Oe, Ke) | 0, m = m + Math.imul(Pe, rt) | 0, A = A + Math.imul(Pe, Ke) | 0, E = E + Math.imul(ke, it) | 0, m = m + Math.imul(ke, $e) | 0, m = m + Math.imul(Ce, it) | 0, A = A + Math.imul(Ce, $e) | 0, E = E + Math.imul(ce, vt) | 0, m = m + Math.imul(ce, Fe) | 0, m = m + Math.imul(ve, vt) | 0, A = A + Math.imul(ve, Fe) | 0, E = E + Math.imul(F, nt) | 0, m = m + Math.imul(F, ze) | 0, m = m + Math.imul(ue, nt) | 0, A = A + Math.imul(ue, ze) | 0, E = E + Math.imul(x, ot) | 0, m = m + Math.imul(x, Xe) | 0, m = m + Math.imul(L, ot) | 0, A = A + Math.imul(L, Xe) | 0, E = E + Math.imul(de, Ze) | 0, m = m + Math.imul(de, je) | 0, m = m + Math.imul(Ae, Ze) | 0, A = A + Math.imul(Ae, je) | 0, E = E + Math.imul(be, St) | 0, m = m + Math.imul(be, Qe) | 0, m = m + Math.imul(Y, St) | 0, A = A + Math.imul(Y, Qe) | 0, E = E + Math.imul(W, It) | 0, m = m + Math.imul(W, Je) | 0, m = m + Math.imul(Q, It) | 0, A = A + Math.imul(Q, Je) | 0, E = E + Math.imul(X, At) | 0, m = m + Math.imul(X, Bt) | 0, m = m + Math.imul(oe, At) | 0, A = A + Math.imul(oe, Bt) | 0;
        var gi = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (gi >>> 26) | 0, gi &= 67108863, E = Math.imul(Ye, rt), m = Math.imul(Ye, Ke), m = m + Math.imul(Ne, rt) | 0, A = Math.imul(Ne, Ke), E = E + Math.imul(Oe, it) | 0, m = m + Math.imul(Oe, $e) | 0, m = m + Math.imul(Pe, it) | 0, A = A + Math.imul(Pe, $e) | 0, E = E + Math.imul(ke, vt) | 0, m = m + Math.imul(ke, Fe) | 0, m = m + Math.imul(Ce, vt) | 0, A = A + Math.imul(Ce, Fe) | 0, E = E + Math.imul(ce, nt) | 0, m = m + Math.imul(ce, ze) | 0, m = m + Math.imul(ve, nt) | 0, A = A + Math.imul(ve, ze) | 0, E = E + Math.imul(F, ot) | 0, m = m + Math.imul(F, Xe) | 0, m = m + Math.imul(ue, ot) | 0, A = A + Math.imul(ue, Xe) | 0, E = E + Math.imul(x, Ze) | 0, m = m + Math.imul(x, je) | 0, m = m + Math.imul(L, Ze) | 0, A = A + Math.imul(L, je) | 0, E = E + Math.imul(de, St) | 0, m = m + Math.imul(de, Qe) | 0, m = m + Math.imul(Ae, St) | 0, A = A + Math.imul(Ae, Qe) | 0, E = E + Math.imul(be, It) | 0, m = m + Math.imul(be, Je) | 0, m = m + Math.imul(Y, It) | 0, A = A + Math.imul(Y, Je) | 0, E = E + Math.imul(W, At) | 0, m = m + Math.imul(W, Bt) | 0, m = m + Math.imul(Q, At) | 0, A = A + Math.imul(Q, Bt) | 0;
        var vi = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (vi >>> 26) | 0, vi &= 67108863, E = Math.imul(Ye, it), m = Math.imul(Ye, $e), m = m + Math.imul(Ne, it) | 0, A = Math.imul(Ne, $e), E = E + Math.imul(Oe, vt) | 0, m = m + Math.imul(Oe, Fe) | 0, m = m + Math.imul(Pe, vt) | 0, A = A + Math.imul(Pe, Fe) | 0, E = E + Math.imul(ke, nt) | 0, m = m + Math.imul(ke, ze) | 0, m = m + Math.imul(Ce, nt) | 0, A = A + Math.imul(Ce, ze) | 0, E = E + Math.imul(ce, ot) | 0, m = m + Math.imul(ce, Xe) | 0, m = m + Math.imul(ve, ot) | 0, A = A + Math.imul(ve, Xe) | 0, E = E + Math.imul(F, Ze) | 0, m = m + Math.imul(F, je) | 0, m = m + Math.imul(ue, Ze) | 0, A = A + Math.imul(ue, je) | 0, E = E + Math.imul(x, St) | 0, m = m + Math.imul(x, Qe) | 0, m = m + Math.imul(L, St) | 0, A = A + Math.imul(L, Qe) | 0, E = E + Math.imul(de, It) | 0, m = m + Math.imul(de, Je) | 0, m = m + Math.imul(Ae, It) | 0, A = A + Math.imul(Ae, Je) | 0, E = E + Math.imul(be, At) | 0, m = m + Math.imul(be, Bt) | 0, m = m + Math.imul(Y, At) | 0, A = A + Math.imul(Y, Bt) | 0;
        var Nn = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (Nn >>> 26) | 0, Nn &= 67108863, E = Math.imul(Ye, vt), m = Math.imul(Ye, Fe), m = m + Math.imul(Ne, vt) | 0, A = Math.imul(Ne, Fe), E = E + Math.imul(Oe, nt) | 0, m = m + Math.imul(Oe, ze) | 0, m = m + Math.imul(Pe, nt) | 0, A = A + Math.imul(Pe, ze) | 0, E = E + Math.imul(ke, ot) | 0, m = m + Math.imul(ke, Xe) | 0, m = m + Math.imul(Ce, ot) | 0, A = A + Math.imul(Ce, Xe) | 0, E = E + Math.imul(ce, Ze) | 0, m = m + Math.imul(ce, je) | 0, m = m + Math.imul(ve, Ze) | 0, A = A + Math.imul(ve, je) | 0, E = E + Math.imul(F, St) | 0, m = m + Math.imul(F, Qe) | 0, m = m + Math.imul(ue, St) | 0, A = A + Math.imul(ue, Qe) | 0, E = E + Math.imul(x, It) | 0, m = m + Math.imul(x, Je) | 0, m = m + Math.imul(L, It) | 0, A = A + Math.imul(L, Je) | 0, E = E + Math.imul(de, At) | 0, m = m + Math.imul(de, Bt) | 0, m = m + Math.imul(Ae, At) | 0, A = A + Math.imul(Ae, Bt) | 0;
        var Dn = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (Dn >>> 26) | 0, Dn &= 67108863, E = Math.imul(Ye, nt), m = Math.imul(Ye, ze), m = m + Math.imul(Ne, nt) | 0, A = Math.imul(Ne, ze), E = E + Math.imul(Oe, ot) | 0, m = m + Math.imul(Oe, Xe) | 0, m = m + Math.imul(Pe, ot) | 0, A = A + Math.imul(Pe, Xe) | 0, E = E + Math.imul(ke, Ze) | 0, m = m + Math.imul(ke, je) | 0, m = m + Math.imul(Ce, Ze) | 0, A = A + Math.imul(Ce, je) | 0, E = E + Math.imul(ce, St) | 0, m = m + Math.imul(ce, Qe) | 0, m = m + Math.imul(ve, St) | 0, A = A + Math.imul(ve, Qe) | 0, E = E + Math.imul(F, It) | 0, m = m + Math.imul(F, Je) | 0, m = m + Math.imul(ue, It) | 0, A = A + Math.imul(ue, Je) | 0, E = E + Math.imul(x, At) | 0, m = m + Math.imul(x, Bt) | 0, m = m + Math.imul(L, At) | 0, A = A + Math.imul(L, Bt) | 0;
        var eM = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (eM >>> 26) | 0, eM &= 67108863, E = Math.imul(Ye, ot), m = Math.imul(Ye, Xe), m = m + Math.imul(Ne, ot) | 0, A = Math.imul(Ne, Xe), E = E + Math.imul(Oe, Ze) | 0, m = m + Math.imul(Oe, je) | 0, m = m + Math.imul(Pe, Ze) | 0, A = A + Math.imul(Pe, je) | 0, E = E + Math.imul(ke, St) | 0, m = m + Math.imul(ke, Qe) | 0, m = m + Math.imul(Ce, St) | 0, A = A + Math.imul(Ce, Qe) | 0, E = E + Math.imul(ce, It) | 0, m = m + Math.imul(ce, Je) | 0, m = m + Math.imul(ve, It) | 0, A = A + Math.imul(ve, Je) | 0, E = E + Math.imul(F, At) | 0, m = m + Math.imul(F, Bt) | 0, m = m + Math.imul(ue, At) | 0, A = A + Math.imul(ue, Bt) | 0;
        var tM = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (tM >>> 26) | 0, tM &= 67108863, E = Math.imul(Ye, Ze), m = Math.imul(Ye, je), m = m + Math.imul(Ne, Ze) | 0, A = Math.imul(Ne, je), E = E + Math.imul(Oe, St) | 0, m = m + Math.imul(Oe, Qe) | 0, m = m + Math.imul(Pe, St) | 0, A = A + Math.imul(Pe, Qe) | 0, E = E + Math.imul(ke, It) | 0, m = m + Math.imul(ke, Je) | 0, m = m + Math.imul(Ce, It) | 0, A = A + Math.imul(Ce, Je) | 0, E = E + Math.imul(ce, At) | 0, m = m + Math.imul(ce, Bt) | 0, m = m + Math.imul(ve, At) | 0, A = A + Math.imul(ve, Bt) | 0;
        var rM = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (rM >>> 26) | 0, rM &= 67108863, E = Math.imul(Ye, St), m = Math.imul(Ye, Qe), m = m + Math.imul(Ne, St) | 0, A = Math.imul(Ne, Qe), E = E + Math.imul(Oe, It) | 0, m = m + Math.imul(Oe, Je) | 0, m = m + Math.imul(Pe, It) | 0, A = A + Math.imul(Pe, Je) | 0, E = E + Math.imul(ke, At) | 0, m = m + Math.imul(ke, Bt) | 0, m = m + Math.imul(Ce, At) | 0, A = A + Math.imul(Ce, Bt) | 0;
        var iM = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (iM >>> 26) | 0, iM &= 67108863, E = Math.imul(Ye, It), m = Math.imul(Ye, Je), m = m + Math.imul(Ne, It) | 0, A = Math.imul(Ne, Je), E = E + Math.imul(Oe, At) | 0, m = m + Math.imul(Oe, Bt) | 0, m = m + Math.imul(Pe, At) | 0, A = A + Math.imul(Pe, Bt) | 0;
        var nM = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (nM >>> 26) | 0, nM &= 67108863, E = Math.imul(Ye, At), m = Math.imul(Ye, Bt), m = m + Math.imul(Ne, At) | 0, A = Math.imul(Ne, Bt);
        var oM = (_ + E | 0) + ((m & 8191) << 13) | 0;
        return _ = (A + (m >>> 13) | 0) + (oM >>> 26) | 0, oM &= 67108863, S[0] = ui, S[1] = fi, S[2] = hi, S[3] = ci, S[4] = li, S[5] = di, S[6] = pi, S[7] = yi, S[8] = mi, S[9] = gi, S[10] = vi, S[11] = Nn, S[12] = Dn, S[13] = eM, S[14] = tM, S[15] = rM, S[16] = iM, S[17] = nM, S[18] = oM, _ !== 0 && (S[19] = _, v.length++), v;
      };
      Math.imul || (U = j);
      function H(f, y, v) {
        v.negative = y.negative ^ f.negative, v.length = f.length + y.length;
        for (var M = 0, B = 0, S = 0; S < v.length - 1; S++) {
          var _ = B;
          B = 0;
          for (var E = M & 67108863, m = Math.min(S, y.length - 1), A = Math.max(0, S - f.length + 1); A <= m; A++) {
            var $ = S - A, X = f.words[$] | 0, oe = y.words[A] | 0, J = X * oe, W = J & 67108863;
            _ = _ + (J / 67108864 | 0) | 0, W = W + E | 0, E = W & 67108863, _ = _ + (W >>> 26) | 0, B += _ >>> 26, _ &= 67108863;
          }
          v.words[S] = E, M = _, _ = B;
        }
        return M !== 0 ? v.words[S] = M : v.length--, v._strip();
      }
      function z(f, y, v) {
        return H(f, y, v);
      }
      a.prototype.mulTo = function(f, y) {
        var v, M = this.length + f.length;
        return this.length === 10 && f.length === 10 ? v = U(this, f, y) : M < 63 ? v = j(this, f, y) : M < 1024 ? v = H(this, f, y) : v = z(this, f, y), v;
      }, a.prototype.mul = function(f) {
        var y = new a(null);
        return y.words = new Array(this.length + f.length), this.mulTo(f, y);
      }, a.prototype.mulf = function(f) {
        var y = new a(null);
        return y.words = new Array(this.length + f.length), z(this, f, y);
      }, a.prototype.imul = function(f) {
        return this.clone().mulTo(f, this);
      }, a.prototype.imuln = function(f) {
        var y = f < 0;
        y && (f = -f), r(typeof f == "number"), r(f < 67108864);
        for (var v = 0, M = 0; M < this.length; M++) {
          var B = (this.words[M] | 0) * f, S = (B & 67108863) + (v & 67108863);
          v >>= 26, v += B / 67108864 | 0, v += S >>> 26, this.words[M] = S & 67108863;
        }
        return v !== 0 && (this.words[M] = v, this.length++), y ? this.ineg() : this;
      }, a.prototype.muln = function(f) {
        return this.clone().imuln(f);
      }, a.prototype.sqr = function() {
        return this.mul(this);
      }, a.prototype.isqr = function() {
        return this.imul(this.clone());
      }, a.prototype.pow = function(f) {
        var y = N(f);
        if (y.length === 0)
          return new a(1);
        for (var v = this, M = 0; M < y.length && y[M] === 0; M++, v = v.sqr())
          ;
        if (++M < y.length)
          for (var B = v.sqr(); M < y.length; M++, B = B.sqr())
            y[M] !== 0 && (v = v.mul(B));
        return v;
      }, a.prototype.iushln = function(f) {
        r(typeof f == "number" && f >= 0);
        var y = f % 26, v = (f - y) / 26, M = 67108863 >>> 26 - y << 26 - y, B;
        if (y !== 0) {
          var S = 0;
          for (B = 0; B < this.length; B++) {
            var _ = this.words[B] & M, E = (this.words[B] | 0) - _ << y;
            this.words[B] = E | S, S = _ >>> 26 - y;
          }
          S && (this.words[B] = S, this.length++);
        }
        if (v !== 0) {
          for (B = this.length - 1; B >= 0; B--)
            this.words[B + v] = this.words[B];
          for (B = 0; B < v; B++)
            this.words[B] = 0;
          this.length += v;
        }
        return this._strip();
      }, a.prototype.ishln = function(f) {
        return r(this.negative === 0), this.iushln(f);
      }, a.prototype.iushrn = function(f, y, v) {
        r(typeof f == "number" && f >= 0);
        var M;
        y ? M = (y - y % 26) / 26 : M = 0;
        var B = f % 26, S = Math.min((f - B) / 26, this.length), _ = 67108863 ^ 67108863 >>> B << B, E = v;
        if (M -= S, M = Math.max(0, M), E) {
          for (var m = 0; m < S; m++)
            E.words[m] = this.words[m];
          E.length = S;
        }
        if (S !== 0)
          if (this.length > S)
            for (this.length -= S, m = 0; m < this.length; m++)
              this.words[m] = this.words[m + S];
          else
            this.words[0] = 0, this.length = 1;
        var A = 0;
        for (m = this.length - 1; m >= 0 && (A !== 0 || m >= M); m--) {
          var $ = this.words[m] | 0;
          this.words[m] = A << 26 - B | $ >>> B, A = $ & _;
        }
        return E && A !== 0 && (E.words[E.length++] = A), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, a.prototype.ishrn = function(f, y, v) {
        return r(this.negative === 0), this.iushrn(f, y, v);
      }, a.prototype.shln = function(f) {
        return this.clone().ishln(f);
      }, a.prototype.ushln = function(f) {
        return this.clone().iushln(f);
      }, a.prototype.shrn = function(f) {
        return this.clone().ishrn(f);
      }, a.prototype.ushrn = function(f) {
        return this.clone().iushrn(f);
      }, a.prototype.testn = function(f) {
        r(typeof f == "number" && f >= 0);
        var y = f % 26, v = (f - y) / 26, M = 1 << y;
        if (this.length <= v)
          return !1;
        var B = this.words[v];
        return !!(B & M);
      }, a.prototype.imaskn = function(f) {
        r(typeof f == "number" && f >= 0);
        var y = f % 26, v = (f - y) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= v)
          return this;
        if (y !== 0 && v++, this.length = Math.min(v, this.length), y !== 0) {
          var M = 67108863 ^ 67108863 >>> y << y;
          this.words[this.length - 1] &= M;
        }
        return this._strip();
      }, a.prototype.maskn = function(f) {
        return this.clone().imaskn(f);
      }, a.prototype.iaddn = function(f) {
        return r(typeof f == "number"), r(f < 67108864), f < 0 ? this.isubn(-f) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f ? (this.words[0] = f - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f), this.negative = 1, this) : this._iaddn(f);
      }, a.prototype._iaddn = function(f) {
        this.words[0] += f;
        for (var y = 0; y < this.length && this.words[y] >= 67108864; y++)
          this.words[y] -= 67108864, y === this.length - 1 ? this.words[y + 1] = 1 : this.words[y + 1]++;
        return this.length = Math.max(this.length, y + 1), this;
      }, a.prototype.isubn = function(f) {
        if (r(typeof f == "number"), r(f < 67108864), f < 0)
          return this.iaddn(-f);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(f), this.negative = 1, this;
        if (this.words[0] -= f, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var y = 0; y < this.length && this.words[y] < 0; y++)
            this.words[y] += 67108864, this.words[y + 1] -= 1;
        return this._strip();
      }, a.prototype.addn = function(f) {
        return this.clone().iaddn(f);
      }, a.prototype.subn = function(f) {
        return this.clone().isubn(f);
      }, a.prototype.iabs = function() {
        return this.negative = 0, this;
      }, a.prototype.abs = function() {
        return this.clone().iabs();
      }, a.prototype._ishlnsubmul = function(f, y, v) {
        var M = f.length + v, B;
        this._expand(M);
        var S, _ = 0;
        for (B = 0; B < f.length; B++) {
          S = (this.words[B + v] | 0) + _;
          var E = (f.words[B] | 0) * y;
          S -= E & 67108863, _ = (S >> 26) - (E / 67108864 | 0), this.words[B + v] = S & 67108863;
        }
        for (; B < this.length - v; B++)
          S = (this.words[B + v] | 0) + _, _ = S >> 26, this.words[B + v] = S & 67108863;
        if (_ === 0)
          return this._strip();
        for (r(_ === -1), _ = 0, B = 0; B < this.length; B++)
          S = -(this.words[B] | 0) + _, _ = S >> 26, this.words[B] = S & 67108863;
        return this.negative = 1, this._strip();
      }, a.prototype._wordDiv = function(f, y) {
        var v = this.length - f.length, M = this.clone(), B = f, S = B.words[B.length - 1] | 0, _ = this._countBits(S);
        v = 26 - _, v !== 0 && (B = B.ushln(v), M.iushln(v), S = B.words[B.length - 1] | 0);
        var E = M.length - B.length, m;
        if (y !== "mod") {
          m = new a(null), m.length = E + 1, m.words = new Array(m.length);
          for (var A = 0; A < m.length; A++)
            m.words[A] = 0;
        }
        var $ = M.clone()._ishlnsubmul(B, 1, E);
        $.negative === 0 && (M = $, m && (m.words[E] = 1));
        for (var X = E - 1; X >= 0; X--) {
          var oe = (M.words[B.length + X] | 0) * 67108864 + (M.words[B.length + X - 1] | 0);
          for (oe = Math.min(oe / S | 0, 67108863), M._ishlnsubmul(B, oe, X); M.negative !== 0; )
            oe--, M.negative = 0, M._ishlnsubmul(B, 1, X), M.isZero() || (M.negative ^= 1);
          m && (m.words[X] = oe);
        }
        return m && m._strip(), M._strip(), y !== "div" && v !== 0 && M.iushrn(v), {
          div: m || null,
          mod: M
        };
      }, a.prototype.divmod = function(f, y, v) {
        if (r(!f.isZero()), this.isZero())
          return {
            div: new a(0),
            mod: new a(0)
          };
        var M, B, S;
        return this.negative !== 0 && f.negative === 0 ? (S = this.neg().divmod(f, y), y !== "mod" && (M = S.div.neg()), y !== "div" && (B = S.mod.neg(), v && B.negative !== 0 && B.iadd(f)), {
          div: M,
          mod: B
        }) : this.negative === 0 && f.negative !== 0 ? (S = this.divmod(f.neg(), y), y !== "mod" && (M = S.div.neg()), {
          div: M,
          mod: S.mod
        }) : this.negative & f.negative ? (S = this.neg().divmod(f.neg(), y), y !== "div" && (B = S.mod.neg(), v && B.negative !== 0 && B.isub(f)), {
          div: S.div,
          mod: B
        }) : f.length > this.length || this.cmp(f) < 0 ? {
          div: new a(0),
          mod: this
        } : f.length === 1 ? y === "div" ? {
          div: this.divn(f.words[0]),
          mod: null
        } : y === "mod" ? {
          div: null,
          mod: new a(this.modrn(f.words[0]))
        } : {
          div: this.divn(f.words[0]),
          mod: new a(this.modrn(f.words[0]))
        } : this._wordDiv(f, y);
      }, a.prototype.div = function(f) {
        return this.divmod(f, "div", !1).div;
      }, a.prototype.mod = function(f) {
        return this.divmod(f, "mod", !1).mod;
      }, a.prototype.umod = function(f) {
        return this.divmod(f, "mod", !0).mod;
      }, a.prototype.divRound = function(f) {
        var y = this.divmod(f);
        if (y.mod.isZero())
          return y.div;
        var v = y.div.negative !== 0 ? y.mod.isub(f) : y.mod, M = f.ushrn(1), B = f.andln(1), S = v.cmp(M);
        return S < 0 || B === 1 && S === 0 ? y.div : y.div.negative !== 0 ? y.div.isubn(1) : y.div.iaddn(1);
      }, a.prototype.modrn = function(f) {
        var y = f < 0;
        y && (f = -f), r(f <= 67108863);
        for (var v = (1 << 26) % f, M = 0, B = this.length - 1; B >= 0; B--)
          M = (v * M + (this.words[B] | 0)) % f;
        return y ? -M : M;
      }, a.prototype.modn = function(f) {
        return this.modrn(f);
      }, a.prototype.idivn = function(f) {
        var y = f < 0;
        y && (f = -f), r(f <= 67108863);
        for (var v = 0, M = this.length - 1; M >= 0; M--) {
          var B = (this.words[M] | 0) + v * 67108864;
          this.words[M] = B / f | 0, v = B % f;
        }
        return this._strip(), y ? this.ineg() : this;
      }, a.prototype.divn = function(f) {
        return this.clone().idivn(f);
      }, a.prototype.egcd = function(f) {
        r(f.negative === 0), r(!f.isZero());
        var y = this, v = f.clone();
        y.negative !== 0 ? y = y.umod(f) : y = y.clone();
        for (var M = new a(1), B = new a(0), S = new a(0), _ = new a(1), E = 0; y.isEven() && v.isEven(); )
          y.iushrn(1), v.iushrn(1), ++E;
        for (var m = v.clone(), A = y.clone(); !y.isZero(); ) {
          for (var $ = 0, X = 1; !(y.words[0] & X) && $ < 26; ++$, X <<= 1)
            ;
          if ($ > 0)
            for (y.iushrn($); $-- > 0; )
              (M.isOdd() || B.isOdd()) && (M.iadd(m), B.isub(A)), M.iushrn(1), B.iushrn(1);
          for (var oe = 0, J = 1; !(v.words[0] & J) && oe < 26; ++oe, J <<= 1)
            ;
          if (oe > 0)
            for (v.iushrn(oe); oe-- > 0; )
              (S.isOdd() || _.isOdd()) && (S.iadd(m), _.isub(A)), S.iushrn(1), _.iushrn(1);
          y.cmp(v) >= 0 ? (y.isub(v), M.isub(S), B.isub(_)) : (v.isub(y), S.isub(M), _.isub(B));
        }
        return {
          a: S,
          b: _,
          gcd: v.iushln(E)
        };
      }, a.prototype._invmp = function(f) {
        r(f.negative === 0), r(!f.isZero());
        var y = this, v = f.clone();
        y.negative !== 0 ? y = y.umod(f) : y = y.clone();
        for (var M = new a(1), B = new a(0), S = v.clone(); y.cmpn(1) > 0 && v.cmpn(1) > 0; ) {
          for (var _ = 0, E = 1; !(y.words[0] & E) && _ < 26; ++_, E <<= 1)
            ;
          if (_ > 0)
            for (y.iushrn(_); _-- > 0; )
              M.isOdd() && M.iadd(S), M.iushrn(1);
          for (var m = 0, A = 1; !(v.words[0] & A) && m < 26; ++m, A <<= 1)
            ;
          if (m > 0)
            for (v.iushrn(m); m-- > 0; )
              B.isOdd() && B.iadd(S), B.iushrn(1);
          y.cmp(v) >= 0 ? (y.isub(v), M.isub(B)) : (v.isub(y), B.isub(M));
        }
        var $;
        return y.cmpn(1) === 0 ? $ = M : $ = B, $.cmpn(0) < 0 && $.iadd(f), $;
      }, a.prototype.gcd = function(f) {
        if (this.isZero())
          return f.abs();
        if (f.isZero())
          return this.abs();
        var y = this.clone(), v = f.clone();
        y.negative = 0, v.negative = 0;
        for (var M = 0; y.isEven() && v.isEven(); M++)
          y.iushrn(1), v.iushrn(1);
        do {
          for (; y.isEven(); )
            y.iushrn(1);
          for (; v.isEven(); )
            v.iushrn(1);
          var B = y.cmp(v);
          if (B < 0) {
            var S = y;
            y = v, v = S;
          } else if (B === 0 || v.cmpn(1) === 0)
            break;
          y.isub(v);
        } while (!0);
        return v.iushln(M);
      }, a.prototype.invm = function(f) {
        return this.egcd(f).a.umod(f);
      }, a.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, a.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, a.prototype.andln = function(f) {
        return this.words[0] & f;
      }, a.prototype.bincn = function(f) {
        r(typeof f == "number");
        var y = f % 26, v = (f - y) / 26, M = 1 << y;
        if (this.length <= v)
          return this._expand(v + 1), this.words[v] |= M, this;
        for (var B = M, S = v; B !== 0 && S < this.length; S++) {
          var _ = this.words[S] | 0;
          _ += B, B = _ >>> 26, _ &= 67108863, this.words[S] = _;
        }
        return B !== 0 && (this.words[S] = B, this.length++), this;
      }, a.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, a.prototype.cmpn = function(f) {
        var y = f < 0;
        if (this.negative !== 0 && !y)
          return -1;
        if (this.negative === 0 && y)
          return 1;
        this._strip();
        var v;
        if (this.length > 1)
          v = 1;
        else {
          y && (f = -f), r(f <= 67108863, "Number is too big");
          var M = this.words[0] | 0;
          v = M === f ? 0 : M < f ? -1 : 1;
        }
        return this.negative !== 0 ? -v | 0 : v;
      }, a.prototype.cmp = function(f) {
        if (this.negative !== 0 && f.negative === 0)
          return -1;
        if (this.negative === 0 && f.negative !== 0)
          return 1;
        var y = this.ucmp(f);
        return this.negative !== 0 ? -y | 0 : y;
      }, a.prototype.ucmp = function(f) {
        if (this.length > f.length)
          return 1;
        if (this.length < f.length)
          return -1;
        for (var y = 0, v = this.length - 1; v >= 0; v--) {
          var M = this.words[v] | 0, B = f.words[v] | 0;
          if (M !== B) {
            M < B ? y = -1 : M > B && (y = 1);
            break;
          }
        }
        return y;
      }, a.prototype.gtn = function(f) {
        return this.cmpn(f) === 1;
      }, a.prototype.gt = function(f) {
        return this.cmp(f) === 1;
      }, a.prototype.gten = function(f) {
        return this.cmpn(f) >= 0;
      }, a.prototype.gte = function(f) {
        return this.cmp(f) >= 0;
      }, a.prototype.ltn = function(f) {
        return this.cmpn(f) === -1;
      }, a.prototype.lt = function(f) {
        return this.cmp(f) === -1;
      }, a.prototype.lten = function(f) {
        return this.cmpn(f) <= 0;
      }, a.prototype.lte = function(f) {
        return this.cmp(f) <= 0;
      }, a.prototype.eqn = function(f) {
        return this.cmpn(f) === 0;
      }, a.prototype.eq = function(f) {
        return this.cmp(f) === 0;
      }, a.red = function(f) {
        return new I(f);
      }, a.prototype.toRed = function(f) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), f.convertTo(this)._forceRed(f);
      }, a.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, a.prototype._forceRed = function(f) {
        return this.red = f, this;
      }, a.prototype.forceRed = function(f) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(f);
      }, a.prototype.redAdd = function(f) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, f);
      }, a.prototype.redIAdd = function(f) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f);
      }, a.prototype.redSub = function(f) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, f);
      }, a.prototype.redISub = function(f) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, f);
      }, a.prototype.redShl = function(f) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, f);
      }, a.prototype.redMul = function(f) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.mul(this, f);
      }, a.prototype.redIMul = function(f) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.imul(this, f);
      }, a.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, a.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, a.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, a.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, a.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, a.prototype.redPow = function(f) {
        return r(this.red && !f.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f);
      };
      var ee = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function ne(f, y) {
        this.name = f, this.p = new a(y, 16), this.n = this.p.bitLength(), this.k = new a(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ne.prototype._tmp = function() {
        var f = new a(null);
        return f.words = new Array(Math.ceil(this.n / 13)), f;
      }, ne.prototype.ireduce = function(f) {
        var y = f, v;
        do
          this.split(y, this.tmp), y = this.imulK(y), y = y.iadd(this.tmp), v = y.bitLength();
        while (v > this.n);
        var M = v < this.n ? -1 : y.ucmp(this.p);
        return M === 0 ? (y.words[0] = 0, y.length = 1) : M > 0 ? y.isub(this.p) : y.strip !== void 0 ? y.strip() : y._strip(), y;
      }, ne.prototype.split = function(f, y) {
        f.iushrn(this.n, 0, y);
      }, ne.prototype.imulK = function(f) {
        return f.imul(this.k);
      };
      function le() {
        ne.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      h(le, ne), le.prototype.split = function(f, y) {
        for (var v = 4194303, M = Math.min(f.length, 9), B = 0; B < M; B++)
          y.words[B] = f.words[B];
        if (y.length = M, f.length <= 9) {
          f.words[0] = 0, f.length = 1;
          return;
        }
        var S = f.words[9];
        for (y.words[y.length++] = S & v, B = 10; B < f.length; B++) {
          var _ = f.words[B] | 0;
          f.words[B - 10] = (_ & v) << 4 | S >>> 22, S = _;
        }
        S >>>= 22, f.words[B - 10] = S, S === 0 && f.length > 10 ? f.length -= 10 : f.length -= 9;
      }, le.prototype.imulK = function(f) {
        f.words[f.length] = 0, f.words[f.length + 1] = 0, f.length += 2;
        for (var y = 0, v = 0; v < f.length; v++) {
          var M = f.words[v] | 0;
          y += M * 977, f.words[v] = y & 67108863, y = M * 64 + (y / 67108864 | 0);
        }
        return f.words[f.length - 1] === 0 && (f.length--, f.words[f.length - 1] === 0 && f.length--), f;
      };
      function Z() {
        ne.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      h(Z, ne);
      function ie() {
        ne.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      h(ie, ne);
      function fe() {
        ne.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      h(fe, ne), fe.prototype.imulK = function(f) {
        for (var y = 0, v = 0; v < f.length; v++) {
          var M = (f.words[v] | 0) * 19 + y, B = M & 67108863;
          M >>>= 26, f.words[v] = B, y = M;
        }
        return y !== 0 && (f.words[f.length++] = y), f;
      }, a._prime = function(f) {
        if (ee[f])
          return ee[f];
        var y;
        if (f === "k256")
          y = new le();
        else if (f === "p224")
          y = new Z();
        else if (f === "p192")
          y = new ie();
        else if (f === "p25519")
          y = new fe();
        else
          throw new Error("Unknown prime " + f);
        return ee[f] = y, y;
      };
      function I(f) {
        if (typeof f == "string") {
          var y = a._prime(f);
          this.m = y.p, this.prime = y;
        } else
          r(f.gtn(1), "modulus must be greater than 1"), this.m = f, this.prime = null;
      }
      I.prototype._verify1 = function(f) {
        r(f.negative === 0, "red works only with positives"), r(f.red, "red works only with red numbers");
      }, I.prototype._verify2 = function(f, y) {
        r((f.negative | y.negative) === 0, "red works only with positives"), r(
          f.red && f.red === y.red,
          "red works only with red numbers"
        );
      }, I.prototype.imod = function(f) {
        return this.prime ? this.prime.ireduce(f)._forceRed(this) : (w(f, f.umod(this.m)._forceRed(this)), f);
      }, I.prototype.neg = function(f) {
        return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this);
      }, I.prototype.add = function(f, y) {
        this._verify2(f, y);
        var v = f.add(y);
        return v.cmp(this.m) >= 0 && v.isub(this.m), v._forceRed(this);
      }, I.prototype.iadd = function(f, y) {
        this._verify2(f, y);
        var v = f.iadd(y);
        return v.cmp(this.m) >= 0 && v.isub(this.m), v;
      }, I.prototype.sub = function(f, y) {
        this._verify2(f, y);
        var v = f.sub(y);
        return v.cmpn(0) < 0 && v.iadd(this.m), v._forceRed(this);
      }, I.prototype.isub = function(f, y) {
        this._verify2(f, y);
        var v = f.isub(y);
        return v.cmpn(0) < 0 && v.iadd(this.m), v;
      }, I.prototype.shl = function(f, y) {
        return this._verify1(f), this.imod(f.ushln(y));
      }, I.prototype.imul = function(f, y) {
        return this._verify2(f, y), this.imod(f.imul(y));
      }, I.prototype.mul = function(f, y) {
        return this._verify2(f, y), this.imod(f.mul(y));
      }, I.prototype.isqr = function(f) {
        return this.imul(f, f.clone());
      }, I.prototype.sqr = function(f) {
        return this.mul(f, f);
      }, I.prototype.sqrt = function(f) {
        if (f.isZero())
          return f.clone();
        var y = this.m.andln(3);
        if (r(y % 2 === 1), y === 3) {
          var v = this.m.add(new a(1)).iushrn(2);
          return this.pow(f, v);
        }
        for (var M = this.m.subn(1), B = 0; !M.isZero() && M.andln(1) === 0; )
          B++, M.iushrn(1);
        r(!M.isZero());
        var S = new a(1).toRed(this), _ = S.redNeg(), E = this.m.subn(1).iushrn(1), m = this.m.bitLength();
        for (m = new a(2 * m * m).toRed(this); this.pow(m, E).cmp(_) !== 0; )
          m.redIAdd(_);
        for (var A = this.pow(m, M), $ = this.pow(f, M.addn(1).iushrn(1)), X = this.pow(f, M), oe = B; X.cmp(S) !== 0; ) {
          for (var J = X, W = 0; J.cmp(S) !== 0; W++)
            J = J.redSqr();
          r(W < oe);
          var Q = this.pow(A, new a(1).iushln(oe - W - 1));
          $ = $.redMul(Q), A = Q.redSqr(), X = X.redMul(A), oe = W;
        }
        return $;
      }, I.prototype.invm = function(f) {
        var y = f._invmp(this.m);
        return y.negative !== 0 ? (y.negative = 0, this.imod(y).redNeg()) : this.imod(y);
      }, I.prototype.pow = function(f, y) {
        if (y.isZero())
          return new a(1).toRed(this);
        if (y.cmpn(1) === 0)
          return f.clone();
        var v = 4, M = new Array(1 << v);
        M[0] = new a(1).toRed(this), M[1] = f;
        for (var B = 2; B < M.length; B++)
          M[B] = this.mul(M[B - 1], f);
        var S = M[0], _ = 0, E = 0, m = y.bitLength() % 26;
        for (m === 0 && (m = 26), B = y.length - 1; B >= 0; B--) {
          for (var A = y.words[B], $ = m - 1; $ >= 0; $--) {
            var X = A >> $ & 1;
            if (S !== M[0] && (S = this.sqr(S)), X === 0 && _ === 0) {
              E = 0;
              continue;
            }
            _ <<= 1, _ |= X, E++, !(E !== v && (B !== 0 || $ !== 0)) && (S = this.mul(S, M[_]), E = 0, _ = 0);
          }
          m = 26;
        }
        return S;
      }, I.prototype.convertTo = function(f) {
        var y = f.umod(this.m);
        return y === f ? y.clone() : y;
      }, I.prototype.convertFrom = function(f) {
        var y = f.clone();
        return y.red = null, y;
      }, a.mont = function(f) {
        return new P(f);
      };
      function P(f) {
        I.call(this, f), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new a(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      h(P, I), P.prototype.convertTo = function(f) {
        return this.imod(f.ushln(this.shift));
      }, P.prototype.convertFrom = function(f) {
        var y = this.imod(f.mul(this.rinv));
        return y.red = null, y;
      }, P.prototype.imul = function(f, y) {
        if (f.isZero() || y.isZero())
          return f.words[0] = 0, f.length = 1, f;
        var v = f.imul(y), M = v.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), B = v.isub(M).iushrn(this.shift), S = B;
        return B.cmp(this.m) >= 0 ? S = B.isub(this.m) : B.cmpn(0) < 0 && (S = B.iadd(this.m)), S._forceRed(this);
      }, P.prototype.mul = function(f, y) {
        if (f.isZero() || y.isZero())
          return new a(0)._forceRed(this);
        var v = f.mul(y), M = v.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), B = v.isub(M).iushrn(this.shift), S = B;
        return B.cmp(this.m) >= 0 ? S = B.isub(this.m) : B.cmpn(0) < 0 && (S = B.iadd(this.m)), S._forceRed(this);
      }, P.prototype.invm = function(f) {
        var y = this.imod(f._invmp(this.m).mul(this.r2));
        return y._forceRed(this);
      };
    })(e, commonjsGlobal);
  }(bn$1)), bn$1.exports;
}
var browserifyRsa, hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
  if (hasRequiredBrowserifyRsa)
    return browserifyRsa;
  hasRequiredBrowserifyRsa = 1;
  var e = requireBn$1(), t = requireBrowser$b();
  function o(a) {
    var p = r(a), d = p.toRed(e.mont(a.modulus)).redPow(new e(a.publicExponent)).fromRed();
    return { blinder: d, unblinder: p.invm(a.modulus) };
  }
  function r(a) {
    var p = a.modulus.byteLength(), d;
    do
      d = new e(t(p));
    while (d.cmp(a.modulus) >= 0 || !d.umod(a.prime1) || !d.umod(a.prime2));
    return d;
  }
  function h(a, p) {
    var d = o(p), b = p.modulus.byteLength(), g = new e(a).mul(d.blinder).umod(p.modulus), w = g.toRed(e.mont(p.prime1)), C = g.toRed(e.mont(p.prime2)), T = p.coefficient, k = p.prime1, q = p.prime2, O = w.redPow(p.exponent1).fromRed(), N = C.redPow(p.exponent2).fromRed(), j = O.isub(N).imul(T).umod(k).imul(q);
    return N.iadd(j).imul(d.unblinder).umod(p.modulus).toArrayLike(bufferExports.Buffer, "be", b);
  }
  return h.getr = r, browserifyRsa = h, browserifyRsa;
}
var elliptic = {};
const name = "elliptic", version = "6.5.5", description = "EC cryptography", main = "lib/elliptic.js", files = [
  "lib"
], scripts = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, repository = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, keywords = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], author = "Fedor Indutny <fedor@indutny.com>", license = "MIT", bugs = {
  url: "https://github.com/indutny/elliptic/issues"
}, homepage = "https://github.com/indutny/elliptic", devDependencies = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, dependencies = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, require$$0 = {
  name,
  version,
  description,
  main,
  files,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  dependencies
};
var utils$2 = {}, utils$1 = {}, hasRequiredUtils$2;
function requireUtils$2() {
  return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1, function(e) {
    var t = e;
    function o(a, p) {
      if (Array.isArray(a))
        return a.slice();
      if (!a)
        return [];
      var d = [];
      if (typeof a != "string") {
        for (var b = 0; b < a.length; b++)
          d[b] = a[b] | 0;
        return d;
      }
      if (p === "hex") {
        a = a.replace(/[^a-z0-9]+/ig, ""), a.length % 2 !== 0 && (a = "0" + a);
        for (var b = 0; b < a.length; b += 2)
          d.push(parseInt(a[b] + a[b + 1], 16));
      } else
        for (var b = 0; b < a.length; b++) {
          var g = a.charCodeAt(b), w = g >> 8, C = g & 255;
          w ? d.push(w, C) : d.push(C);
        }
      return d;
    }
    t.toArray = o;
    function r(a) {
      return a.length === 1 ? "0" + a : a;
    }
    t.zero2 = r;
    function h(a) {
      for (var p = "", d = 0; d < a.length; d++)
        p += r(a[d].toString(16));
      return p;
    }
    t.toHex = h, t.encode = function(a, p) {
      return p === "hex" ? h(a) : a;
    };
  }(utils$1)), utils$1;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1, function(e) {
    var t = e, o = requireBn$2(), r = requireMinimalisticAssert(), h = requireUtils$2();
    t.assert = r, t.toArray = h.toArray, t.zero2 = h.zero2, t.toHex = h.toHex, t.encode = h.encode;
    function a(w, C, T) {
      var k = new Array(Math.max(w.bitLength(), T) + 1), q;
      for (q = 0; q < k.length; q += 1)
        k[q] = 0;
      var O = 1 << C + 1, N = w.clone();
      for (q = 0; q < k.length; q++) {
        var j, U = N.andln(O - 1);
        N.isOdd() ? (U > (O >> 1) - 1 ? j = (O >> 1) - U : j = U, N.isubn(j)) : j = 0, k[q] = j, N.iushrn(1);
      }
      return k;
    }
    t.getNAF = a;
    function p(w, C) {
      var T = [
        [],
        []
      ];
      w = w.clone(), C = C.clone();
      for (var k = 0, q = 0, O; w.cmpn(-k) > 0 || C.cmpn(-q) > 0; ) {
        var N = w.andln(3) + k & 3, j = C.andln(3) + q & 3;
        N === 3 && (N = -1), j === 3 && (j = -1);
        var U;
        N & 1 ? (O = w.andln(7) + k & 7, (O === 3 || O === 5) && j === 2 ? U = -N : U = N) : U = 0, T[0].push(U);
        var H;
        j & 1 ? (O = C.andln(7) + q & 7, (O === 3 || O === 5) && N === 2 ? H = -j : H = j) : H = 0, T[1].push(H), 2 * k === U + 1 && (k = 1 - k), 2 * q === H + 1 && (q = 1 - q), w.iushrn(1), C.iushrn(1);
      }
      return T;
    }
    t.getJSF = p;
    function d(w, C, T) {
      var k = "_" + C;
      w.prototype[C] = function() {
        return this[k] !== void 0 ? this[k] : this[k] = T.call(this);
      };
    }
    t.cachedProperty = d;
    function b(w) {
      return typeof w == "string" ? t.toArray(w, "hex") : w;
    }
    t.parseBytes = b;
    function g(w) {
      return new o(w, "hex", "le");
    }
    t.intFromLE = g;
  }(utils$2)), utils$2;
}
var curve = {}, base$1, hasRequiredBase$1;
function requireBase$1() {
  if (hasRequiredBase$1)
    return base$1;
  hasRequiredBase$1 = 1;
  var e = requireBn$2(), t = requireUtils$1(), o = t.getNAF, r = t.getJSF, h = t.assert;
  function a(d, b) {
    this.type = d, this.p = new e(b.p, 16), this.red = b.prime ? e.red(b.prime) : e.mont(this.p), this.zero = new e(0).toRed(this.red), this.one = new e(1).toRed(this.red), this.two = new e(2).toRed(this.red), this.n = b.n && new e(b.n, 16), this.g = b.g && this.pointFromJSON(b.g, b.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var g = this.n && this.p.div(this.n);
    !g || g.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  base$1 = a, a.prototype.point = function() {
    throw new Error("Not implemented");
  }, a.prototype.validate = function() {
    throw new Error("Not implemented");
  }, a.prototype._fixedNafMul = function(d, b) {
    h(d.precomputed);
    var g = d._getDoubles(), w = o(b, 1, this._bitLength), C = (1 << g.step + 1) - (g.step % 2 === 0 ? 2 : 1);
    C /= 3;
    var T = [], k, q;
    for (k = 0; k < w.length; k += g.step) {
      q = 0;
      for (var O = k + g.step - 1; O >= k; O--)
        q = (q << 1) + w[O];
      T.push(q);
    }
    for (var N = this.jpoint(null, null, null), j = this.jpoint(null, null, null), U = C; U > 0; U--) {
      for (k = 0; k < T.length; k++)
        q = T[k], q === U ? j = j.mixedAdd(g.points[k]) : q === -U && (j = j.mixedAdd(g.points[k].neg()));
      N = N.add(j);
    }
    return N.toP();
  }, a.prototype._wnafMul = function(d, b) {
    var g = 4, w = d._getNAFPoints(g);
    g = w.wnd;
    for (var C = w.points, T = o(b, g, this._bitLength), k = this.jpoint(null, null, null), q = T.length - 1; q >= 0; q--) {
      for (var O = 0; q >= 0 && T[q] === 0; q--)
        O++;
      if (q >= 0 && O++, k = k.dblp(O), q < 0)
        break;
      var N = T[q];
      h(N !== 0), d.type === "affine" ? N > 0 ? k = k.mixedAdd(C[N - 1 >> 1]) : k = k.mixedAdd(C[-N - 1 >> 1].neg()) : N > 0 ? k = k.add(C[N - 1 >> 1]) : k = k.add(C[-N - 1 >> 1].neg());
    }
    return d.type === "affine" ? k.toP() : k;
  }, a.prototype._wnafMulAdd = function(d, b, g, w, C) {
    var T = this._wnafT1, k = this._wnafT2, q = this._wnafT3, O = 0, N, j, U;
    for (N = 0; N < w; N++) {
      U = b[N];
      var H = U._getNAFPoints(d);
      T[N] = H.wnd, k[N] = H.points;
    }
    for (N = w - 1; N >= 1; N -= 2) {
      var z = N - 1, ee = N;
      if (T[z] !== 1 || T[ee] !== 1) {
        q[z] = o(g[z], T[z], this._bitLength), q[ee] = o(g[ee], T[ee], this._bitLength), O = Math.max(q[z].length, O), O = Math.max(q[ee].length, O);
        continue;
      }
      var ne = [
        b[z],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        b[ee]
        /* 7 */
      ];
      b[z].y.cmp(b[ee].y) === 0 ? (ne[1] = b[z].add(b[ee]), ne[2] = b[z].toJ().mixedAdd(b[ee].neg())) : b[z].y.cmp(b[ee].y.redNeg()) === 0 ? (ne[1] = b[z].toJ().mixedAdd(b[ee]), ne[2] = b[z].add(b[ee].neg())) : (ne[1] = b[z].toJ().mixedAdd(b[ee]), ne[2] = b[z].toJ().mixedAdd(b[ee].neg()));
      var le = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ], Z = r(g[z], g[ee]);
      for (O = Math.max(Z[0].length, O), q[z] = new Array(O), q[ee] = new Array(O), j = 0; j < O; j++) {
        var ie = Z[0][j] | 0, fe = Z[1][j] | 0;
        q[z][j] = le[(ie + 1) * 3 + (fe + 1)], q[ee][j] = 0, k[z] = ne;
      }
    }
    var I = this.jpoint(null, null, null), P = this._wnafT4;
    for (N = O; N >= 0; N--) {
      for (var f = 0; N >= 0; ) {
        var y = !0;
        for (j = 0; j < w; j++)
          P[j] = q[j][N] | 0, P[j] !== 0 && (y = !1);
        if (!y)
          break;
        f++, N--;
      }
      if (N >= 0 && f++, I = I.dblp(f), N < 0)
        break;
      for (j = 0; j < w; j++) {
        var v = P[j];
        v !== 0 && (v > 0 ? U = k[j][v - 1 >> 1] : v < 0 && (U = k[j][-v - 1 >> 1].neg()), U.type === "affine" ? I = I.mixedAdd(U) : I = I.add(U));
      }
    }
    for (N = 0; N < w; N++)
      k[N] = null;
    return C ? I : I.toP();
  };
  function p(d, b) {
    this.curve = d, this.type = b, this.precomputed = null;
  }
  return a.BasePoint = p, p.prototype.eq = function() {
    throw new Error("Not implemented");
  }, p.prototype.validate = function() {
    return this.curve.validate(this);
  }, a.prototype.decodePoint = function(d, b) {
    d = t.toArray(d, b);
    var g = this.p.byteLength();
    if ((d[0] === 4 || d[0] === 6 || d[0] === 7) && d.length - 1 === 2 * g) {
      d[0] === 6 ? h(d[d.length - 1] % 2 === 0) : d[0] === 7 && h(d[d.length - 1] % 2 === 1);
      var w = this.point(
        d.slice(1, 1 + g),
        d.slice(1 + g, 1 + 2 * g)
      );
      return w;
    } else if ((d[0] === 2 || d[0] === 3) && d.length - 1 === g)
      return this.pointFromX(d.slice(1, 1 + g), d[0] === 3);
    throw new Error("Unknown point format");
  }, p.prototype.encodeCompressed = function(d) {
    return this.encode(d, !0);
  }, p.prototype._encode = function(d) {
    var b = this.curve.p.byteLength(), g = this.getX().toArray("be", b);
    return d ? [this.getY().isEven() ? 2 : 3].concat(g) : [4].concat(g, this.getY().toArray("be", b));
  }, p.prototype.encode = function(d, b) {
    return t.encode(this._encode(b), d);
  }, p.prototype.precompute = function(d) {
    if (this.precomputed)
      return this;
    var b = {
      doubles: null,
      naf: null,
      beta: null
    };
    return b.naf = this._getNAFPoints(8), b.doubles = this._getDoubles(4, d), b.beta = this._getBeta(), this.precomputed = b, this;
  }, p.prototype._hasDoubles = function(d) {
    if (!this.precomputed)
      return !1;
    var b = this.precomputed.doubles;
    return b ? b.points.length >= Math.ceil((d.bitLength() + 1) / b.step) : !1;
  }, p.prototype._getDoubles = function(d, b) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var g = [this], w = this, C = 0; C < b; C += d) {
      for (var T = 0; T < d; T++)
        w = w.dbl();
      g.push(w);
    }
    return {
      step: d,
      points: g
    };
  }, p.prototype._getNAFPoints = function(d) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var b = [this], g = (1 << d) - 1, w = g === 1 ? null : this.dbl(), C = 1; C < g; C++)
      b[C] = b[C - 1].add(w);
    return {
      wnd: d,
      points: b
    };
  }, p.prototype._getBeta = function() {
    return null;
  }, p.prototype.dblp = function(d) {
    for (var b = this, g = 0; g < d; g++)
      b = b.dbl();
    return b;
  }, base$1;
}
var short, hasRequiredShort;
function requireShort() {
  if (hasRequiredShort)
    return short;
  hasRequiredShort = 1;
  var e = requireUtils$1(), t = requireBn$2(), o = requireInherits_browser(), r = requireBase$1(), h = e.assert;
  function a(b) {
    r.call(this, "short", b), this.a = new t(b.a, 16).toRed(this.red), this.b = new t(b.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(b), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  o(a, r), short = a, a.prototype._getEndomorphism = function(b) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var g, w;
      if (b.beta)
        g = new t(b.beta, 16).toRed(this.red);
      else {
        var C = this._getEndoRoots(this.p);
        g = C[0].cmp(C[1]) < 0 ? C[0] : C[1], g = g.toRed(this.red);
      }
      if (b.lambda)
        w = new t(b.lambda, 16);
      else {
        var T = this._getEndoRoots(this.n);
        this.g.mul(T[0]).x.cmp(this.g.x.redMul(g)) === 0 ? w = T[0] : (w = T[1], h(this.g.mul(w).x.cmp(this.g.x.redMul(g)) === 0));
      }
      var k;
      return b.basis ? k = b.basis.map(function(q) {
        return {
          a: new t(q.a, 16),
          b: new t(q.b, 16)
        };
      }) : k = this._getEndoBasis(w), {
        beta: g,
        lambda: w,
        basis: k
      };
    }
  }, a.prototype._getEndoRoots = function(b) {
    var g = b === this.p ? this.red : t.mont(b), w = new t(2).toRed(g).redInvm(), C = w.redNeg(), T = new t(3).toRed(g).redNeg().redSqrt().redMul(w), k = C.redAdd(T).fromRed(), q = C.redSub(T).fromRed();
    return [k, q];
  }, a.prototype._getEndoBasis = function(b) {
    for (var g = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), w = b, C = this.n.clone(), T = new t(1), k = new t(0), q = new t(0), O = new t(1), N, j, U, H, z, ee, ne, le = 0, Z, ie; w.cmpn(0) !== 0; ) {
      var fe = C.div(w);
      Z = C.sub(fe.mul(w)), ie = q.sub(fe.mul(T));
      var I = O.sub(fe.mul(k));
      if (!U && Z.cmp(g) < 0)
        N = ne.neg(), j = T, U = Z.neg(), H = ie;
      else if (U && ++le === 2)
        break;
      ne = Z, C = w, w = Z, q = T, T = ie, O = k, k = I;
    }
    z = Z.neg(), ee = ie;
    var P = U.sqr().add(H.sqr()), f = z.sqr().add(ee.sqr());
    return f.cmp(P) >= 0 && (z = N, ee = j), U.negative && (U = U.neg(), H = H.neg()), z.negative && (z = z.neg(), ee = ee.neg()), [
      { a: U, b: H },
      { a: z, b: ee }
    ];
  }, a.prototype._endoSplit = function(b) {
    var g = this.endo.basis, w = g[0], C = g[1], T = C.b.mul(b).divRound(this.n), k = w.b.neg().mul(b).divRound(this.n), q = T.mul(w.a), O = k.mul(C.a), N = T.mul(w.b), j = k.mul(C.b), U = b.sub(q).sub(O), H = N.add(j).neg();
    return { k1: U, k2: H };
  }, a.prototype.pointFromX = function(b, g) {
    b = new t(b, 16), b.red || (b = b.toRed(this.red));
    var w = b.redSqr().redMul(b).redIAdd(b.redMul(this.a)).redIAdd(this.b), C = w.redSqrt();
    if (C.redSqr().redSub(w).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var T = C.fromRed().isOdd();
    return (g && !T || !g && T) && (C = C.redNeg()), this.point(b, C);
  }, a.prototype.validate = function(b) {
    if (b.inf)
      return !0;
    var g = b.x, w = b.y, C = this.a.redMul(g), T = g.redSqr().redMul(g).redIAdd(C).redIAdd(this.b);
    return w.redSqr().redISub(T).cmpn(0) === 0;
  }, a.prototype._endoWnafMulAdd = function(b, g, w) {
    for (var C = this._endoWnafT1, T = this._endoWnafT2, k = 0; k < b.length; k++) {
      var q = this._endoSplit(g[k]), O = b[k], N = O._getBeta();
      q.k1.negative && (q.k1.ineg(), O = O.neg(!0)), q.k2.negative && (q.k2.ineg(), N = N.neg(!0)), C[k * 2] = O, C[k * 2 + 1] = N, T[k * 2] = q.k1, T[k * 2 + 1] = q.k2;
    }
    for (var j = this._wnafMulAdd(1, C, T, k * 2, w), U = 0; U < k * 2; U++)
      C[U] = null, T[U] = null;
    return j;
  };
  function p(b, g, w, C) {
    r.BasePoint.call(this, b, "affine"), g === null && w === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new t(g, 16), this.y = new t(w, 16), C && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  o(p, r.BasePoint), a.prototype.point = function(b, g, w) {
    return new p(this, b, g, w);
  }, a.prototype.pointFromJSON = function(b, g) {
    return p.fromJSON(this, b, g);
  }, p.prototype._getBeta = function() {
    if (this.curve.endo) {
      var b = this.precomputed;
      if (b && b.beta)
        return b.beta;
      var g = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (b) {
        var w = this.curve, C = function(T) {
          return w.point(T.x.redMul(w.endo.beta), T.y);
        };
        b.beta = g, g.precomputed = {
          beta: null,
          naf: b.naf && {
            wnd: b.naf.wnd,
            points: b.naf.points.map(C)
          },
          doubles: b.doubles && {
            step: b.doubles.step,
            points: b.doubles.points.map(C)
          }
        };
      }
      return g;
    }
  }, p.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, p.fromJSON = function(b, g, w) {
    typeof g == "string" && (g = JSON.parse(g));
    var C = b.point(g[0], g[1], w);
    if (!g[2])
      return C;
    function T(q) {
      return b.point(q[0], q[1], w);
    }
    var k = g[2];
    return C.precomputed = {
      beta: null,
      doubles: k.doubles && {
        step: k.doubles.step,
        points: [C].concat(k.doubles.points.map(T))
      },
      naf: k.naf && {
        wnd: k.naf.wnd,
        points: [C].concat(k.naf.points.map(T))
      }
    }, C;
  }, p.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, p.prototype.isInfinity = function() {
    return this.inf;
  }, p.prototype.add = function(b) {
    if (this.inf)
      return b;
    if (b.inf)
      return this;
    if (this.eq(b))
      return this.dbl();
    if (this.neg().eq(b))
      return this.curve.point(null, null);
    if (this.x.cmp(b.x) === 0)
      return this.curve.point(null, null);
    var g = this.y.redSub(b.y);
    g.cmpn(0) !== 0 && (g = g.redMul(this.x.redSub(b.x).redInvm()));
    var w = g.redSqr().redISub(this.x).redISub(b.x), C = g.redMul(this.x.redSub(w)).redISub(this.y);
    return this.curve.point(w, C);
  }, p.prototype.dbl = function() {
    if (this.inf)
      return this;
    var b = this.y.redAdd(this.y);
    if (b.cmpn(0) === 0)
      return this.curve.point(null, null);
    var g = this.curve.a, w = this.x.redSqr(), C = b.redInvm(), T = w.redAdd(w).redIAdd(w).redIAdd(g).redMul(C), k = T.redSqr().redISub(this.x.redAdd(this.x)), q = T.redMul(this.x.redSub(k)).redISub(this.y);
    return this.curve.point(k, q);
  }, p.prototype.getX = function() {
    return this.x.fromRed();
  }, p.prototype.getY = function() {
    return this.y.fromRed();
  }, p.prototype.mul = function(b) {
    return b = new t(b, 16), this.isInfinity() ? this : this._hasDoubles(b) ? this.curve._fixedNafMul(this, b) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [b]) : this.curve._wnafMul(this, b);
  }, p.prototype.mulAdd = function(b, g, w) {
    var C = [this, g], T = [b, w];
    return this.curve.endo ? this.curve._endoWnafMulAdd(C, T) : this.curve._wnafMulAdd(1, C, T, 2);
  }, p.prototype.jmulAdd = function(b, g, w) {
    var C = [this, g], T = [b, w];
    return this.curve.endo ? this.curve._endoWnafMulAdd(C, T, !0) : this.curve._wnafMulAdd(1, C, T, 2, !0);
  }, p.prototype.eq = function(b) {
    return this === b || this.inf === b.inf && (this.inf || this.x.cmp(b.x) === 0 && this.y.cmp(b.y) === 0);
  }, p.prototype.neg = function(b) {
    if (this.inf)
      return this;
    var g = this.curve.point(this.x, this.y.redNeg());
    if (b && this.precomputed) {
      var w = this.precomputed, C = function(T) {
        return T.neg();
      };
      g.precomputed = {
        naf: w.naf && {
          wnd: w.naf.wnd,
          points: w.naf.points.map(C)
        },
        doubles: w.doubles && {
          step: w.doubles.step,
          points: w.doubles.points.map(C)
        }
      };
    }
    return g;
  }, p.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var b = this.curve.jpoint(this.x, this.y, this.curve.one);
    return b;
  };
  function d(b, g, w, C) {
    r.BasePoint.call(this, b, "jacobian"), g === null && w === null && C === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new t(0)) : (this.x = new t(g, 16), this.y = new t(w, 16), this.z = new t(C, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return o(d, r.BasePoint), a.prototype.jpoint = function(b, g, w) {
    return new d(this, b, g, w);
  }, d.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var b = this.z.redInvm(), g = b.redSqr(), w = this.x.redMul(g), C = this.y.redMul(g).redMul(b);
    return this.curve.point(w, C);
  }, d.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, d.prototype.add = function(b) {
    if (this.isInfinity())
      return b;
    if (b.isInfinity())
      return this;
    var g = b.z.redSqr(), w = this.z.redSqr(), C = this.x.redMul(g), T = b.x.redMul(w), k = this.y.redMul(g.redMul(b.z)), q = b.y.redMul(w.redMul(this.z)), O = C.redSub(T), N = k.redSub(q);
    if (O.cmpn(0) === 0)
      return N.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var j = O.redSqr(), U = j.redMul(O), H = C.redMul(j), z = N.redSqr().redIAdd(U).redISub(H).redISub(H), ee = N.redMul(H.redISub(z)).redISub(k.redMul(U)), ne = this.z.redMul(b.z).redMul(O);
    return this.curve.jpoint(z, ee, ne);
  }, d.prototype.mixedAdd = function(b) {
    if (this.isInfinity())
      return b.toJ();
    if (b.isInfinity())
      return this;
    var g = this.z.redSqr(), w = this.x, C = b.x.redMul(g), T = this.y, k = b.y.redMul(g).redMul(this.z), q = w.redSub(C), O = T.redSub(k);
    if (q.cmpn(0) === 0)
      return O.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var N = q.redSqr(), j = N.redMul(q), U = w.redMul(N), H = O.redSqr().redIAdd(j).redISub(U).redISub(U), z = O.redMul(U.redISub(H)).redISub(T.redMul(j)), ee = this.z.redMul(q);
    return this.curve.jpoint(H, z, ee);
  }, d.prototype.dblp = function(b) {
    if (b === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!b)
      return this.dbl();
    var g;
    if (this.curve.zeroA || this.curve.threeA) {
      var w = this;
      for (g = 0; g < b; g++)
        w = w.dbl();
      return w;
    }
    var C = this.curve.a, T = this.curve.tinv, k = this.x, q = this.y, O = this.z, N = O.redSqr().redSqr(), j = q.redAdd(q);
    for (g = 0; g < b; g++) {
      var U = k.redSqr(), H = j.redSqr(), z = H.redSqr(), ee = U.redAdd(U).redIAdd(U).redIAdd(C.redMul(N)), ne = k.redMul(H), le = ee.redSqr().redISub(ne.redAdd(ne)), Z = ne.redISub(le), ie = ee.redMul(Z);
      ie = ie.redIAdd(ie).redISub(z);
      var fe = j.redMul(O);
      g + 1 < b && (N = N.redMul(z)), k = le, O = fe, j = ie;
    }
    return this.curve.jpoint(k, j.redMul(T), O);
  }, d.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, d.prototype._zeroDbl = function() {
    var b, g, w;
    if (this.zOne) {
      var C = this.x.redSqr(), T = this.y.redSqr(), k = T.redSqr(), q = this.x.redAdd(T).redSqr().redISub(C).redISub(k);
      q = q.redIAdd(q);
      var O = C.redAdd(C).redIAdd(C), N = O.redSqr().redISub(q).redISub(q), j = k.redIAdd(k);
      j = j.redIAdd(j), j = j.redIAdd(j), b = N, g = O.redMul(q.redISub(N)).redISub(j), w = this.y.redAdd(this.y);
    } else {
      var U = this.x.redSqr(), H = this.y.redSqr(), z = H.redSqr(), ee = this.x.redAdd(H).redSqr().redISub(U).redISub(z);
      ee = ee.redIAdd(ee);
      var ne = U.redAdd(U).redIAdd(U), le = ne.redSqr(), Z = z.redIAdd(z);
      Z = Z.redIAdd(Z), Z = Z.redIAdd(Z), b = le.redISub(ee).redISub(ee), g = ne.redMul(ee.redISub(b)).redISub(Z), w = this.y.redMul(this.z), w = w.redIAdd(w);
    }
    return this.curve.jpoint(b, g, w);
  }, d.prototype._threeDbl = function() {
    var b, g, w;
    if (this.zOne) {
      var C = this.x.redSqr(), T = this.y.redSqr(), k = T.redSqr(), q = this.x.redAdd(T).redSqr().redISub(C).redISub(k);
      q = q.redIAdd(q);
      var O = C.redAdd(C).redIAdd(C).redIAdd(this.curve.a), N = O.redSqr().redISub(q).redISub(q);
      b = N;
      var j = k.redIAdd(k);
      j = j.redIAdd(j), j = j.redIAdd(j), g = O.redMul(q.redISub(N)).redISub(j), w = this.y.redAdd(this.y);
    } else {
      var U = this.z.redSqr(), H = this.y.redSqr(), z = this.x.redMul(H), ee = this.x.redSub(U).redMul(this.x.redAdd(U));
      ee = ee.redAdd(ee).redIAdd(ee);
      var ne = z.redIAdd(z);
      ne = ne.redIAdd(ne);
      var le = ne.redAdd(ne);
      b = ee.redSqr().redISub(le), w = this.y.redAdd(this.z).redSqr().redISub(H).redISub(U);
      var Z = H.redSqr();
      Z = Z.redIAdd(Z), Z = Z.redIAdd(Z), Z = Z.redIAdd(Z), g = ee.redMul(ne.redISub(b)).redISub(Z);
    }
    return this.curve.jpoint(b, g, w);
  }, d.prototype._dbl = function() {
    var b = this.curve.a, g = this.x, w = this.y, C = this.z, T = C.redSqr().redSqr(), k = g.redSqr(), q = w.redSqr(), O = k.redAdd(k).redIAdd(k).redIAdd(b.redMul(T)), N = g.redAdd(g);
    N = N.redIAdd(N);
    var j = N.redMul(q), U = O.redSqr().redISub(j.redAdd(j)), H = j.redISub(U), z = q.redSqr();
    z = z.redIAdd(z), z = z.redIAdd(z), z = z.redIAdd(z);
    var ee = O.redMul(H).redISub(z), ne = w.redAdd(w).redMul(C);
    return this.curve.jpoint(U, ee, ne);
  }, d.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var b = this.x.redSqr(), g = this.y.redSqr(), w = this.z.redSqr(), C = g.redSqr(), T = b.redAdd(b).redIAdd(b), k = T.redSqr(), q = this.x.redAdd(g).redSqr().redISub(b).redISub(C);
    q = q.redIAdd(q), q = q.redAdd(q).redIAdd(q), q = q.redISub(k);
    var O = q.redSqr(), N = C.redIAdd(C);
    N = N.redIAdd(N), N = N.redIAdd(N), N = N.redIAdd(N);
    var j = T.redIAdd(q).redSqr().redISub(k).redISub(O).redISub(N), U = g.redMul(j);
    U = U.redIAdd(U), U = U.redIAdd(U);
    var H = this.x.redMul(O).redISub(U);
    H = H.redIAdd(H), H = H.redIAdd(H);
    var z = this.y.redMul(j.redMul(N.redISub(j)).redISub(q.redMul(O)));
    z = z.redIAdd(z), z = z.redIAdd(z), z = z.redIAdd(z);
    var ee = this.z.redAdd(q).redSqr().redISub(w).redISub(O);
    return this.curve.jpoint(H, z, ee);
  }, d.prototype.mul = function(b, g) {
    return b = new t(b, g), this.curve._wnafMul(this, b);
  }, d.prototype.eq = function(b) {
    if (b.type === "affine")
      return this.eq(b.toJ());
    if (this === b)
      return !0;
    var g = this.z.redSqr(), w = b.z.redSqr();
    if (this.x.redMul(w).redISub(b.x.redMul(g)).cmpn(0) !== 0)
      return !1;
    var C = g.redMul(this.z), T = w.redMul(b.z);
    return this.y.redMul(T).redISub(b.y.redMul(C)).cmpn(0) === 0;
  }, d.prototype.eqXToP = function(b) {
    var g = this.z.redSqr(), w = b.toRed(this.curve.red).redMul(g);
    if (this.x.cmp(w) === 0)
      return !0;
    for (var C = b.clone(), T = this.curve.redN.redMul(g); ; ) {
      if (C.iadd(this.curve.n), C.cmp(this.curve.p) >= 0)
        return !1;
      if (w.redIAdd(T), this.x.cmp(w) === 0)
        return !0;
    }
  }, d.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, d.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, short;
}
var mont, hasRequiredMont;
function requireMont() {
  if (hasRequiredMont)
    return mont;
  hasRequiredMont = 1;
  var e = requireBn$2(), t = requireInherits_browser(), o = requireBase$1(), r = requireUtils$1();
  function h(p) {
    o.call(this, "mont", p), this.a = new e(p.a, 16).toRed(this.red), this.b = new e(p.b, 16).toRed(this.red), this.i4 = new e(4).toRed(this.red).redInvm(), this.two = new e(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  t(h, o), mont = h, h.prototype.validate = function(p) {
    var d = p.normalize().x, b = d.redSqr(), g = b.redMul(d).redAdd(b.redMul(this.a)).redAdd(d), w = g.redSqrt();
    return w.redSqr().cmp(g) === 0;
  };
  function a(p, d, b) {
    o.BasePoint.call(this, p, "projective"), d === null && b === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new e(d, 16), this.z = new e(b, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return t(a, o.BasePoint), h.prototype.decodePoint = function(p, d) {
    return this.point(r.toArray(p, d), 1);
  }, h.prototype.point = function(p, d) {
    return new a(this, p, d);
  }, h.prototype.pointFromJSON = function(p) {
    return a.fromJSON(this, p);
  }, a.prototype.precompute = function() {
  }, a.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, a.fromJSON = function(p, d) {
    return new a(p, d[0], d[1] || p.one);
  }, a.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, a.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, a.prototype.dbl = function() {
    var p = this.x.redAdd(this.z), d = p.redSqr(), b = this.x.redSub(this.z), g = b.redSqr(), w = d.redSub(g), C = d.redMul(g), T = w.redMul(g.redAdd(this.curve.a24.redMul(w)));
    return this.curve.point(C, T);
  }, a.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, a.prototype.diffAdd = function(p, d) {
    var b = this.x.redAdd(this.z), g = this.x.redSub(this.z), w = p.x.redAdd(p.z), C = p.x.redSub(p.z), T = C.redMul(b), k = w.redMul(g), q = d.z.redMul(T.redAdd(k).redSqr()), O = d.x.redMul(T.redISub(k).redSqr());
    return this.curve.point(q, O);
  }, a.prototype.mul = function(p) {
    for (var d = p.clone(), b = this, g = this.curve.point(null, null), w = this, C = []; d.cmpn(0) !== 0; d.iushrn(1))
      C.push(d.andln(1));
    for (var T = C.length - 1; T >= 0; T--)
      C[T] === 0 ? (b = b.diffAdd(g, w), g = g.dbl()) : (g = b.diffAdd(g, w), b = b.dbl());
    return g;
  }, a.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, a.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, a.prototype.eq = function(p) {
    return this.getX().cmp(p.getX()) === 0;
  }, a.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, a.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, mont;
}
var edwards, hasRequiredEdwards;
function requireEdwards() {
  if (hasRequiredEdwards)
    return edwards;
  hasRequiredEdwards = 1;
  var e = requireUtils$1(), t = requireBn$2(), o = requireInherits_browser(), r = requireBase$1(), h = e.assert;
  function a(d) {
    this.twisted = (d.a | 0) !== 1, this.mOneA = this.twisted && (d.a | 0) === -1, this.extended = this.mOneA, r.call(this, "edwards", d), this.a = new t(d.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new t(d.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new t(d.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), h(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (d.c | 0) === 1;
  }
  o(a, r), edwards = a, a.prototype._mulA = function(d) {
    return this.mOneA ? d.redNeg() : this.a.redMul(d);
  }, a.prototype._mulC = function(d) {
    return this.oneC ? d : this.c.redMul(d);
  }, a.prototype.jpoint = function(d, b, g, w) {
    return this.point(d, b, g, w);
  }, a.prototype.pointFromX = function(d, b) {
    d = new t(d, 16), d.red || (d = d.toRed(this.red));
    var g = d.redSqr(), w = this.c2.redSub(this.a.redMul(g)), C = this.one.redSub(this.c2.redMul(this.d).redMul(g)), T = w.redMul(C.redInvm()), k = T.redSqrt();
    if (k.redSqr().redSub(T).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var q = k.fromRed().isOdd();
    return (b && !q || !b && q) && (k = k.redNeg()), this.point(d, k);
  }, a.prototype.pointFromY = function(d, b) {
    d = new t(d, 16), d.red || (d = d.toRed(this.red));
    var g = d.redSqr(), w = g.redSub(this.c2), C = g.redMul(this.d).redMul(this.c2).redSub(this.a), T = w.redMul(C.redInvm());
    if (T.cmp(this.zero) === 0) {
      if (b)
        throw new Error("invalid point");
      return this.point(this.zero, d);
    }
    var k = T.redSqrt();
    if (k.redSqr().redSub(T).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return k.fromRed().isOdd() !== b && (k = k.redNeg()), this.point(k, d);
  }, a.prototype.validate = function(d) {
    if (d.isInfinity())
      return !0;
    d.normalize();
    var b = d.x.redSqr(), g = d.y.redSqr(), w = b.redMul(this.a).redAdd(g), C = this.c2.redMul(this.one.redAdd(this.d.redMul(b).redMul(g)));
    return w.cmp(C) === 0;
  };
  function p(d, b, g, w, C) {
    r.BasePoint.call(this, d, "projective"), b === null && g === null && w === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new t(b, 16), this.y = new t(g, 16), this.z = w ? new t(w, 16) : this.curve.one, this.t = C && new t(C, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return o(p, r.BasePoint), a.prototype.pointFromJSON = function(d) {
    return p.fromJSON(this, d);
  }, a.prototype.point = function(d, b, g, w) {
    return new p(this, d, b, g, w);
  }, p.fromJSON = function(d, b) {
    return new p(d, b[0], b[1], b[2]);
  }, p.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, p.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, p.prototype._extDbl = function() {
    var d = this.x.redSqr(), b = this.y.redSqr(), g = this.z.redSqr();
    g = g.redIAdd(g);
    var w = this.curve._mulA(d), C = this.x.redAdd(this.y).redSqr().redISub(d).redISub(b), T = w.redAdd(b), k = T.redSub(g), q = w.redSub(b), O = C.redMul(k), N = T.redMul(q), j = C.redMul(q), U = k.redMul(T);
    return this.curve.point(O, N, U, j);
  }, p.prototype._projDbl = function() {
    var d = this.x.redAdd(this.y).redSqr(), b = this.x.redSqr(), g = this.y.redSqr(), w, C, T, k, q, O;
    if (this.curve.twisted) {
      k = this.curve._mulA(b);
      var N = k.redAdd(g);
      this.zOne ? (w = d.redSub(b).redSub(g).redMul(N.redSub(this.curve.two)), C = N.redMul(k.redSub(g)), T = N.redSqr().redSub(N).redSub(N)) : (q = this.z.redSqr(), O = N.redSub(q).redISub(q), w = d.redSub(b).redISub(g).redMul(O), C = N.redMul(k.redSub(g)), T = N.redMul(O));
    } else
      k = b.redAdd(g), q = this.curve._mulC(this.z).redSqr(), O = k.redSub(q).redSub(q), w = this.curve._mulC(d.redISub(k)).redMul(O), C = this.curve._mulC(k).redMul(b.redISub(g)), T = k.redMul(O);
    return this.curve.point(w, C, T);
  }, p.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, p.prototype._extAdd = function(d) {
    var b = this.y.redSub(this.x).redMul(d.y.redSub(d.x)), g = this.y.redAdd(this.x).redMul(d.y.redAdd(d.x)), w = this.t.redMul(this.curve.dd).redMul(d.t), C = this.z.redMul(d.z.redAdd(d.z)), T = g.redSub(b), k = C.redSub(w), q = C.redAdd(w), O = g.redAdd(b), N = T.redMul(k), j = q.redMul(O), U = T.redMul(O), H = k.redMul(q);
    return this.curve.point(N, j, H, U);
  }, p.prototype._projAdd = function(d) {
    var b = this.z.redMul(d.z), g = b.redSqr(), w = this.x.redMul(d.x), C = this.y.redMul(d.y), T = this.curve.d.redMul(w).redMul(C), k = g.redSub(T), q = g.redAdd(T), O = this.x.redAdd(this.y).redMul(d.x.redAdd(d.y)).redISub(w).redISub(C), N = b.redMul(k).redMul(O), j, U;
    return this.curve.twisted ? (j = b.redMul(q).redMul(C.redSub(this.curve._mulA(w))), U = k.redMul(q)) : (j = b.redMul(q).redMul(C.redSub(w)), U = this.curve._mulC(k).redMul(q)), this.curve.point(N, j, U);
  }, p.prototype.add = function(d) {
    return this.isInfinity() ? d : d.isInfinity() ? this : this.curve.extended ? this._extAdd(d) : this._projAdd(d);
  }, p.prototype.mul = function(d) {
    return this._hasDoubles(d) ? this.curve._fixedNafMul(this, d) : this.curve._wnafMul(this, d);
  }, p.prototype.mulAdd = function(d, b, g) {
    return this.curve._wnafMulAdd(1, [this, b], [d, g], 2, !1);
  }, p.prototype.jmulAdd = function(d, b, g) {
    return this.curve._wnafMulAdd(1, [this, b], [d, g], 2, !0);
  }, p.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var d = this.z.redInvm();
    return this.x = this.x.redMul(d), this.y = this.y.redMul(d), this.t && (this.t = this.t.redMul(d)), this.z = this.curve.one, this.zOne = !0, this;
  }, p.prototype.neg = function() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  }, p.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, p.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, p.prototype.eq = function(d) {
    return this === d || this.getX().cmp(d.getX()) === 0 && this.getY().cmp(d.getY()) === 0;
  }, p.prototype.eqXToP = function(d) {
    var b = d.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(b) === 0)
      return !0;
    for (var g = d.clone(), w = this.curve.redN.redMul(this.z); ; ) {
      if (g.iadd(this.curve.n), g.cmp(this.curve.p) >= 0)
        return !1;
      if (b.redIAdd(w), this.x.cmp(b) === 0)
        return !0;
    }
  }, p.prototype.toP = p.prototype.normalize, p.prototype.mixedAdd = p.prototype.add, edwards;
}
var hasRequiredCurve;
function requireCurve() {
  return hasRequiredCurve || (hasRequiredCurve = 1, function(e) {
    var t = e;
    t.base = requireBase$1(), t.short = requireShort(), t.mont = requireMont(), t.edwards = requireEdwards();
  }(curve)), curve;
}
var curves = {}, hash = {}, utils = {}, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils;
  hasRequiredUtils = 1;
  var e = requireMinimalisticAssert(), t = requireInherits_browser();
  utils.inherits = t;
  function o(P, f) {
    return (P.charCodeAt(f) & 64512) !== 55296 || f < 0 || f + 1 >= P.length ? !1 : (P.charCodeAt(f + 1) & 64512) === 56320;
  }
  function r(P, f) {
    if (Array.isArray(P))
      return P.slice();
    if (!P)
      return [];
    var y = [];
    if (typeof P == "string")
      if (f) {
        if (f === "hex")
          for (P = P.replace(/[^a-z0-9]+/ig, ""), P.length % 2 !== 0 && (P = "0" + P), M = 0; M < P.length; M += 2)
            y.push(parseInt(P[M] + P[M + 1], 16));
      } else
        for (var v = 0, M = 0; M < P.length; M++) {
          var B = P.charCodeAt(M);
          B < 128 ? y[v++] = B : B < 2048 ? (y[v++] = B >> 6 | 192, y[v++] = B & 63 | 128) : o(P, M) ? (B = 65536 + ((B & 1023) << 10) + (P.charCodeAt(++M) & 1023), y[v++] = B >> 18 | 240, y[v++] = B >> 12 & 63 | 128, y[v++] = B >> 6 & 63 | 128, y[v++] = B & 63 | 128) : (y[v++] = B >> 12 | 224, y[v++] = B >> 6 & 63 | 128, y[v++] = B & 63 | 128);
        }
    else
      for (M = 0; M < P.length; M++)
        y[M] = P[M] | 0;
    return y;
  }
  utils.toArray = r;
  function h(P) {
    for (var f = "", y = 0; y < P.length; y++)
      f += d(P[y].toString(16));
    return f;
  }
  utils.toHex = h;
  function a(P) {
    var f = P >>> 24 | P >>> 8 & 65280 | P << 8 & 16711680 | (P & 255) << 24;
    return f >>> 0;
  }
  utils.htonl = a;
  function p(P, f) {
    for (var y = "", v = 0; v < P.length; v++) {
      var M = P[v];
      f === "little" && (M = a(M)), y += b(M.toString(16));
    }
    return y;
  }
  utils.toHex32 = p;
  function d(P) {
    return P.length === 1 ? "0" + P : P;
  }
  utils.zero2 = d;
  function b(P) {
    return P.length === 7 ? "0" + P : P.length === 6 ? "00" + P : P.length === 5 ? "000" + P : P.length === 4 ? "0000" + P : P.length === 3 ? "00000" + P : P.length === 2 ? "000000" + P : P.length === 1 ? "0000000" + P : P;
  }
  utils.zero8 = b;
  function g(P, f, y, v) {
    var M = y - f;
    e(M % 4 === 0);
    for (var B = new Array(M / 4), S = 0, _ = f; S < B.length; S++, _ += 4) {
      var E;
      v === "big" ? E = P[_] << 24 | P[_ + 1] << 16 | P[_ + 2] << 8 | P[_ + 3] : E = P[_ + 3] << 24 | P[_ + 2] << 16 | P[_ + 1] << 8 | P[_], B[S] = E >>> 0;
    }
    return B;
  }
  utils.join32 = g;
  function w(P, f) {
    for (var y = new Array(P.length * 4), v = 0, M = 0; v < P.length; v++, M += 4) {
      var B = P[v];
      f === "big" ? (y[M] = B >>> 24, y[M + 1] = B >>> 16 & 255, y[M + 2] = B >>> 8 & 255, y[M + 3] = B & 255) : (y[M + 3] = B >>> 24, y[M + 2] = B >>> 16 & 255, y[M + 1] = B >>> 8 & 255, y[M] = B & 255);
    }
    return y;
  }
  utils.split32 = w;
  function C(P, f) {
    return P >>> f | P << 32 - f;
  }
  utils.rotr32 = C;
  function T(P, f) {
    return P << f | P >>> 32 - f;
  }
  utils.rotl32 = T;
  function k(P, f) {
    return P + f >>> 0;
  }
  utils.sum32 = k;
  function q(P, f, y) {
    return P + f + y >>> 0;
  }
  utils.sum32_3 = q;
  function O(P, f, y, v) {
    return P + f + y + v >>> 0;
  }
  utils.sum32_4 = O;
  function N(P, f, y, v, M) {
    return P + f + y + v + M >>> 0;
  }
  utils.sum32_5 = N;
  function j(P, f, y, v) {
    var M = P[f], B = P[f + 1], S = v + B >>> 0, _ = (S < v ? 1 : 0) + y + M;
    P[f] = _ >>> 0, P[f + 1] = S;
  }
  utils.sum64 = j;
  function U(P, f, y, v) {
    var M = f + v >>> 0, B = (M < f ? 1 : 0) + P + y;
    return B >>> 0;
  }
  utils.sum64_hi = U;
  function H(P, f, y, v) {
    var M = f + v;
    return M >>> 0;
  }
  utils.sum64_lo = H;
  function z(P, f, y, v, M, B, S, _) {
    var E = 0, m = f;
    m = m + v >>> 0, E += m < f ? 1 : 0, m = m + B >>> 0, E += m < B ? 1 : 0, m = m + _ >>> 0, E += m < _ ? 1 : 0;
    var A = P + y + M + S + E;
    return A >>> 0;
  }
  utils.sum64_4_hi = z;
  function ee(P, f, y, v, M, B, S, _) {
    var E = f + v + B + _;
    return E >>> 0;
  }
  utils.sum64_4_lo = ee;
  function ne(P, f, y, v, M, B, S, _, E, m) {
    var A = 0, $ = f;
    $ = $ + v >>> 0, A += $ < f ? 1 : 0, $ = $ + B >>> 0, A += $ < B ? 1 : 0, $ = $ + _ >>> 0, A += $ < _ ? 1 : 0, $ = $ + m >>> 0, A += $ < m ? 1 : 0;
    var X = P + y + M + S + E + A;
    return X >>> 0;
  }
  utils.sum64_5_hi = ne;
  function le(P, f, y, v, M, B, S, _, E, m) {
    var A = f + v + B + _ + m;
    return A >>> 0;
  }
  utils.sum64_5_lo = le;
  function Z(P, f, y) {
    var v = f << 32 - y | P >>> y;
    return v >>> 0;
  }
  utils.rotr64_hi = Z;
  function ie(P, f, y) {
    var v = P << 32 - y | f >>> y;
    return v >>> 0;
  }
  utils.rotr64_lo = ie;
  function fe(P, f, y) {
    return P >>> y;
  }
  utils.shr64_hi = fe;
  function I(P, f, y) {
    var v = P << 32 - y | f >>> y;
    return v >>> 0;
  }
  return utils.shr64_lo = I, utils;
}
var common$1 = {}, hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1)
    return common$1;
  hasRequiredCommon$1 = 1;
  var e = requireUtils(), t = requireMinimalisticAssert();
  function o() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return common$1.BlockHash = o, o.prototype.update = function(r, h) {
    if (r = e.toArray(r, h), this.pending ? this.pending = this.pending.concat(r) : this.pending = r, this.pendingTotal += r.length, this.pending.length >= this._delta8) {
      r = this.pending;
      var a = r.length % this._delta8;
      this.pending = r.slice(r.length - a, r.length), this.pending.length === 0 && (this.pending = null), r = e.join32(r, 0, r.length - a, this.endian);
      for (var p = 0; p < r.length; p += this._delta32)
        this._update(r, p, p + this._delta32);
    }
    return this;
  }, o.prototype.digest = function(r) {
    return this.update(this._pad()), t(this.pending === null), this._digest(r);
  }, o.prototype._pad = function() {
    var r = this.pendingTotal, h = this._delta8, a = h - (r + this.padLength) % h, p = new Array(a + this.padLength);
    p[0] = 128;
    for (var d = 1; d < a; d++)
      p[d] = 0;
    if (r <<= 3, this.endian === "big") {
      for (var b = 8; b < this.padLength; b++)
        p[d++] = 0;
      p[d++] = 0, p[d++] = 0, p[d++] = 0, p[d++] = 0, p[d++] = r >>> 24 & 255, p[d++] = r >>> 16 & 255, p[d++] = r >>> 8 & 255, p[d++] = r & 255;
    } else
      for (p[d++] = r & 255, p[d++] = r >>> 8 & 255, p[d++] = r >>> 16 & 255, p[d++] = r >>> 24 & 255, p[d++] = 0, p[d++] = 0, p[d++] = 0, p[d++] = 0, b = 8; b < this.padLength; b++)
        p[d++] = 0;
    return p;
  }, common$1;
}
var sha = {}, common = {}, hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon)
    return common;
  hasRequiredCommon = 1;
  var e = requireUtils(), t = e.rotr32;
  function o(w, C, T, k) {
    if (w === 0)
      return r(C, T, k);
    if (w === 1 || w === 3)
      return a(C, T, k);
    if (w === 2)
      return h(C, T, k);
  }
  common.ft_1 = o;
  function r(w, C, T) {
    return w & C ^ ~w & T;
  }
  common.ch32 = r;
  function h(w, C, T) {
    return w & C ^ w & T ^ C & T;
  }
  common.maj32 = h;
  function a(w, C, T) {
    return w ^ C ^ T;
  }
  common.p32 = a;
  function p(w) {
    return t(w, 2) ^ t(w, 13) ^ t(w, 22);
  }
  common.s0_256 = p;
  function d(w) {
    return t(w, 6) ^ t(w, 11) ^ t(w, 25);
  }
  common.s1_256 = d;
  function b(w) {
    return t(w, 7) ^ t(w, 18) ^ w >>> 3;
  }
  common.g0_256 = b;
  function g(w) {
    return t(w, 17) ^ t(w, 19) ^ w >>> 10;
  }
  return common.g1_256 = g, common;
}
var _1$1, hasRequired_1;
function require_1() {
  if (hasRequired_1)
    return _1$1;
  hasRequired_1 = 1;
  var e = requireUtils(), t = requireCommon$1(), o = requireCommon(), r = e.rotl32, h = e.sum32, a = e.sum32_5, p = o.ft_1, d = t.BlockHash, b = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function g() {
    if (!(this instanceof g))
      return new g();
    d.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  return e.inherits(g, d), _1$1 = g, g.blockSize = 512, g.outSize = 160, g.hmacStrength = 80, g.padLength = 64, g.prototype._update = function(w, C) {
    for (var T = this.W, k = 0; k < 16; k++)
      T[k] = w[C + k];
    for (; k < T.length; k++)
      T[k] = r(T[k - 3] ^ T[k - 8] ^ T[k - 14] ^ T[k - 16], 1);
    var q = this.h[0], O = this.h[1], N = this.h[2], j = this.h[3], U = this.h[4];
    for (k = 0; k < T.length; k++) {
      var H = ~~(k / 20), z = a(r(q, 5), p(H, O, N, j), U, T[k], b[H]);
      U = j, j = N, N = r(O, 30), O = q, q = z;
    }
    this.h[0] = h(this.h[0], q), this.h[1] = h(this.h[1], O), this.h[2] = h(this.h[2], N), this.h[3] = h(this.h[3], j), this.h[4] = h(this.h[4], U);
  }, g.prototype._digest = function(w) {
    return w === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  }, _1$1;
}
var _256, hasRequired_256;
function require_256() {
  if (hasRequired_256)
    return _256;
  hasRequired_256 = 1;
  var e = requireUtils(), t = requireCommon$1(), o = requireCommon(), r = requireMinimalisticAssert(), h = e.sum32, a = e.sum32_4, p = e.sum32_5, d = o.ch32, b = o.maj32, g = o.s0_256, w = o.s1_256, C = o.g0_256, T = o.g1_256, k = t.BlockHash, q = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function O() {
    if (!(this instanceof O))
      return new O();
    k.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = q, this.W = new Array(64);
  }
  return e.inherits(O, k), _256 = O, O.blockSize = 512, O.outSize = 256, O.hmacStrength = 192, O.padLength = 64, O.prototype._update = function(N, j) {
    for (var U = this.W, H = 0; H < 16; H++)
      U[H] = N[j + H];
    for (; H < U.length; H++)
      U[H] = a(T(U[H - 2]), U[H - 7], C(U[H - 15]), U[H - 16]);
    var z = this.h[0], ee = this.h[1], ne = this.h[2], le = this.h[3], Z = this.h[4], ie = this.h[5], fe = this.h[6], I = this.h[7];
    for (r(this.k.length === U.length), H = 0; H < U.length; H++) {
      var P = p(I, w(Z), d(Z, ie, fe), this.k[H], U[H]), f = h(g(z), b(z, ee, ne));
      I = fe, fe = ie, ie = Z, Z = h(le, P), le = ne, ne = ee, ee = z, z = h(P, f);
    }
    this.h[0] = h(this.h[0], z), this.h[1] = h(this.h[1], ee), this.h[2] = h(this.h[2], ne), this.h[3] = h(this.h[3], le), this.h[4] = h(this.h[4], Z), this.h[5] = h(this.h[5], ie), this.h[6] = h(this.h[6], fe), this.h[7] = h(this.h[7], I);
  }, O.prototype._digest = function(N) {
    return N === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  }, _256;
}
var _224, hasRequired_224;
function require_224() {
  if (hasRequired_224)
    return _224;
  hasRequired_224 = 1;
  var e = requireUtils(), t = require_256();
  function o() {
    if (!(this instanceof o))
      return new o();
    t.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  return e.inherits(o, t), _224 = o, o.blockSize = 512, o.outSize = 224, o.hmacStrength = 192, o.padLength = 64, o.prototype._digest = function(r) {
    return r === "hex" ? e.toHex32(this.h.slice(0, 7), "big") : e.split32(this.h.slice(0, 7), "big");
  }, _224;
}
var _512, hasRequired_512;
function require_512() {
  if (hasRequired_512)
    return _512;
  hasRequired_512 = 1;
  var e = requireUtils(), t = requireCommon$1(), o = requireMinimalisticAssert(), r = e.rotr64_hi, h = e.rotr64_lo, a = e.shr64_hi, p = e.shr64_lo, d = e.sum64, b = e.sum64_hi, g = e.sum64_lo, w = e.sum64_4_hi, C = e.sum64_4_lo, T = e.sum64_5_hi, k = e.sum64_5_lo, q = t.BlockHash, O = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function N() {
    if (!(this instanceof N))
      return new N();
    q.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = O, this.W = new Array(160);
  }
  e.inherits(N, q), _512 = N, N.blockSize = 1024, N.outSize = 512, N.hmacStrength = 192, N.padLength = 128, N.prototype._prepareBlock = function(f, y) {
    for (var v = this.W, M = 0; M < 32; M++)
      v[M] = f[y + M];
    for (; M < v.length; M += 2) {
      var B = I(v[M - 4], v[M - 3]), S = P(v[M - 4], v[M - 3]), _ = v[M - 14], E = v[M - 13], m = ie(v[M - 30], v[M - 29]), A = fe(v[M - 30], v[M - 29]), $ = v[M - 32], X = v[M - 31];
      v[M] = w(
        B,
        S,
        _,
        E,
        m,
        A,
        $,
        X
      ), v[M + 1] = C(
        B,
        S,
        _,
        E,
        m,
        A,
        $,
        X
      );
    }
  }, N.prototype._update = function(f, y) {
    this._prepareBlock(f, y);
    var v = this.W, M = this.h[0], B = this.h[1], S = this.h[2], _ = this.h[3], E = this.h[4], m = this.h[5], A = this.h[6], $ = this.h[7], X = this.h[8], oe = this.h[9], J = this.h[10], W = this.h[11], Q = this.h[12], me = this.h[13], be = this.h[14], Y = this.h[15];
    o(this.k.length === v.length);
    for (var re = 0; re < v.length; re += 2) {
      var de = be, Ae = Y, qe = le(X, oe), x = Z(X, oe), L = j(X, oe, J, W, Q), D = U(X, oe, J, W, Q, me), F = this.k[re], ue = this.k[re + 1], ge = v[re], ce = v[re + 1], ve = T(
        de,
        Ae,
        qe,
        x,
        L,
        D,
        F,
        ue,
        ge,
        ce
      ), Re = k(
        de,
        Ae,
        qe,
        x,
        L,
        D,
        F,
        ue,
        ge,
        ce
      );
      de = ee(M, B), Ae = ne(M, B), qe = H(M, B, S, _, E), x = z(M, B, S, _, E, m);
      var ke = b(de, Ae, qe, x), Ce = g(de, Ae, qe, x);
      be = Q, Y = me, Q = J, me = W, J = X, W = oe, X = b(A, $, ve, Re), oe = g($, $, ve, Re), A = E, $ = m, E = S, m = _, S = M, _ = B, M = b(ve, Re, ke, Ce), B = g(ve, Re, ke, Ce);
    }
    d(this.h, 0, M, B), d(this.h, 2, S, _), d(this.h, 4, E, m), d(this.h, 6, A, $), d(this.h, 8, X, oe), d(this.h, 10, J, W), d(this.h, 12, Q, me), d(this.h, 14, be, Y);
  }, N.prototype._digest = function(f) {
    return f === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  };
  function j(f, y, v, M, B) {
    var S = f & v ^ ~f & B;
    return S < 0 && (S += 4294967296), S;
  }
  function U(f, y, v, M, B, S) {
    var _ = y & M ^ ~y & S;
    return _ < 0 && (_ += 4294967296), _;
  }
  function H(f, y, v, M, B) {
    var S = f & v ^ f & B ^ v & B;
    return S < 0 && (S += 4294967296), S;
  }
  function z(f, y, v, M, B, S) {
    var _ = y & M ^ y & S ^ M & S;
    return _ < 0 && (_ += 4294967296), _;
  }
  function ee(f, y) {
    var v = r(f, y, 28), M = r(y, f, 2), B = r(y, f, 7), S = v ^ M ^ B;
    return S < 0 && (S += 4294967296), S;
  }
  function ne(f, y) {
    var v = h(f, y, 28), M = h(y, f, 2), B = h(y, f, 7), S = v ^ M ^ B;
    return S < 0 && (S += 4294967296), S;
  }
  function le(f, y) {
    var v = r(f, y, 14), M = r(f, y, 18), B = r(y, f, 9), S = v ^ M ^ B;
    return S < 0 && (S += 4294967296), S;
  }
  function Z(f, y) {
    var v = h(f, y, 14), M = h(f, y, 18), B = h(y, f, 9), S = v ^ M ^ B;
    return S < 0 && (S += 4294967296), S;
  }
  function ie(f, y) {
    var v = r(f, y, 1), M = r(f, y, 8), B = a(f, y, 7), S = v ^ M ^ B;
    return S < 0 && (S += 4294967296), S;
  }
  function fe(f, y) {
    var v = h(f, y, 1), M = h(f, y, 8), B = p(f, y, 7), S = v ^ M ^ B;
    return S < 0 && (S += 4294967296), S;
  }
  function I(f, y) {
    var v = r(f, y, 19), M = r(y, f, 29), B = a(f, y, 6), S = v ^ M ^ B;
    return S < 0 && (S += 4294967296), S;
  }
  function P(f, y) {
    var v = h(f, y, 19), M = h(y, f, 29), B = p(f, y, 6), S = v ^ M ^ B;
    return S < 0 && (S += 4294967296), S;
  }
  return _512;
}
var _384, hasRequired_384;
function require_384() {
  if (hasRequired_384)
    return _384;
  hasRequired_384 = 1;
  var e = requireUtils(), t = require_512();
  function o() {
    if (!(this instanceof o))
      return new o();
    t.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  return e.inherits(o, t), _384 = o, o.blockSize = 1024, o.outSize = 384, o.hmacStrength = 192, o.padLength = 128, o.prototype._digest = function(r) {
    return r === "hex" ? e.toHex32(this.h.slice(0, 12), "big") : e.split32(this.h.slice(0, 12), "big");
  }, _384;
}
var hasRequiredSha;
function requireSha() {
  return hasRequiredSha || (hasRequiredSha = 1, sha.sha1 = require_1(), sha.sha224 = require_224(), sha.sha256 = require_256(), sha.sha384 = require_384(), sha.sha512 = require_512()), sha;
}
var ripemd = {}, hasRequiredRipemd;
function requireRipemd() {
  if (hasRequiredRipemd)
    return ripemd;
  hasRequiredRipemd = 1;
  var e = requireUtils(), t = requireCommon$1(), o = e.rotl32, r = e.sum32, h = e.sum32_3, a = e.sum32_4, p = t.BlockHash;
  function d() {
    if (!(this instanceof d))
      return new d();
    p.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  e.inherits(d, p), ripemd.ripemd160 = d, d.blockSize = 512, d.outSize = 160, d.hmacStrength = 192, d.padLength = 64, d.prototype._update = function(O, N) {
    for (var j = this.h[0], U = this.h[1], H = this.h[2], z = this.h[3], ee = this.h[4], ne = j, le = U, Z = H, ie = z, fe = ee, I = 0; I < 80; I++) {
      var P = r(
        o(
          a(j, b(I, U, H, z), O[C[I] + N], g(I)),
          k[I]
        ),
        ee
      );
      j = ee, ee = z, z = o(H, 10), H = U, U = P, P = r(
        o(
          a(ne, b(79 - I, le, Z, ie), O[T[I] + N], w(I)),
          q[I]
        ),
        fe
      ), ne = fe, fe = ie, ie = o(Z, 10), Z = le, le = P;
    }
    P = h(this.h[1], H, ie), this.h[1] = h(this.h[2], z, fe), this.h[2] = h(this.h[3], ee, ne), this.h[3] = h(this.h[4], j, le), this.h[4] = h(this.h[0], U, Z), this.h[0] = P;
  }, d.prototype._digest = function(O) {
    return O === "hex" ? e.toHex32(this.h, "little") : e.split32(this.h, "little");
  };
  function b(O, N, j, U) {
    return O <= 15 ? N ^ j ^ U : O <= 31 ? N & j | ~N & U : O <= 47 ? (N | ~j) ^ U : O <= 63 ? N & U | j & ~U : N ^ (j | ~U);
  }
  function g(O) {
    return O <= 15 ? 0 : O <= 31 ? 1518500249 : O <= 47 ? 1859775393 : O <= 63 ? 2400959708 : 2840853838;
  }
  function w(O) {
    return O <= 15 ? 1352829926 : O <= 31 ? 1548603684 : O <= 47 ? 1836072691 : O <= 63 ? 2053994217 : 0;
  }
  var C = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], T = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], k = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], q = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return ripemd;
}
var hmac, hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac)
    return hmac;
  hasRequiredHmac = 1;
  var e = requireUtils(), t = requireMinimalisticAssert();
  function o(r, h, a) {
    if (!(this instanceof o))
      return new o(r, h, a);
    this.Hash = r, this.blockSize = r.blockSize / 8, this.outSize = r.outSize / 8, this.inner = null, this.outer = null, this._init(e.toArray(h, a));
  }
  return hmac = o, o.prototype._init = function(r) {
    r.length > this.blockSize && (r = new this.Hash().update(r).digest()), t(r.length <= this.blockSize);
    for (var h = r.length; h < this.blockSize; h++)
      r.push(0);
    for (h = 0; h < r.length; h++)
      r[h] ^= 54;
    for (this.inner = new this.Hash().update(r), h = 0; h < r.length; h++)
      r[h] ^= 106;
    this.outer = new this.Hash().update(r);
  }, o.prototype.update = function(r, h) {
    return this.inner.update(r, h), this;
  }, o.prototype.digest = function(r) {
    return this.outer.update(this.inner.digest()), this.outer.digest(r);
  }, hmac;
}
var hasRequiredHash;
function requireHash() {
  return hasRequiredHash || (hasRequiredHash = 1, function(e) {
    var t = e;
    t.utils = requireUtils(), t.common = requireCommon$1(), t.sha = requireSha(), t.ripemd = requireRipemd(), t.hmac = requireHmac(), t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160;
  }(hash)), hash;
}
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
var hasRequiredCurves;
function requireCurves() {
  return hasRequiredCurves || (hasRequiredCurves = 1, function(e) {
    var t = e, o = requireHash(), r = requireCurve(), h = requireUtils$1(), a = h.assert;
    function p(g) {
      g.type === "short" ? this.curve = new r.short(g) : g.type === "edwards" ? this.curve = new r.edwards(g) : this.curve = new r.mont(g), this.g = this.curve.g, this.n = this.curve.n, this.hash = g.hash, a(this.g.validate(), "Invalid curve"), a(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    t.PresetCurve = p;
    function d(g, w) {
      Object.defineProperty(t, g, {
        configurable: !0,
        enumerable: !0,
        get: function() {
          var C = new p(w);
          return Object.defineProperty(t, g, {
            configurable: !0,
            enumerable: !0,
            value: C
          }), C;
        }
      });
    }
    d("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: o.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    }), d("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: o.sha256,
      gRed: !1,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    }), d("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: o.sha256,
      gRed: !1,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    }), d("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: o.sha384,
      gRed: !1,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    }), d("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: o.sha512,
      gRed: !1,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    }), d("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: o.sha256,
      gRed: !1,
      g: [
        "9"
      ]
    }), d("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: o.sha256,
      gRed: !1,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var b;
    try {
      b = requireSecp256k1();
    } catch {
      b = void 0;
    }
    d("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: o.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        b
      ]
    });
  }(curves)), curves;
}
var hmacDrbg, hasRequiredHmacDrbg;
function requireHmacDrbg() {
  if (hasRequiredHmacDrbg)
    return hmacDrbg;
  hasRequiredHmacDrbg = 1;
  var e = requireHash(), t = requireUtils$2(), o = requireMinimalisticAssert();
  function r(h) {
    if (!(this instanceof r))
      return new r(h);
    this.hash = h.hash, this.predResist = !!h.predResist, this.outLen = this.hash.outSize, this.minEntropy = h.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var a = t.toArray(h.entropy, h.entropyEnc || "hex"), p = t.toArray(h.nonce, h.nonceEnc || "hex"), d = t.toArray(h.pers, h.persEnc || "hex");
    o(
      a.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._init(a, p, d);
  }
  return hmacDrbg = r, r.prototype._init = function(h, a, p) {
    var d = h.concat(a).concat(p);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var b = 0; b < this.V.length; b++)
      this.K[b] = 0, this.V[b] = 1;
    this._update(d), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, r.prototype._hmac = function() {
    return new e.hmac(this.hash, this.K);
  }, r.prototype._update = function(h) {
    var a = this._hmac().update(this.V).update([0]);
    h && (a = a.update(h)), this.K = a.digest(), this.V = this._hmac().update(this.V).digest(), h && (this.K = this._hmac().update(this.V).update([1]).update(h).digest(), this.V = this._hmac().update(this.V).digest());
  }, r.prototype.reseed = function(h, a, p, d) {
    typeof a != "string" && (d = p, p = a, a = null), h = t.toArray(h, a), p = t.toArray(p, d), o(
      h.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._update(h.concat(p || [])), this._reseed = 1;
  }, r.prototype.generate = function(h, a, p, d) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof a != "string" && (d = p, p = a, a = null), p && (p = t.toArray(p, d || "hex"), this._update(p));
    for (var b = []; b.length < h; )
      this.V = this._hmac().update(this.V).digest(), b = b.concat(this.V);
    var g = b.slice(0, h);
    return this._update(p), this._reseed++, t.encode(g, a);
  }, hmacDrbg;
}
var key$1, hasRequiredKey$1;
function requireKey$1() {
  if (hasRequiredKey$1)
    return key$1;
  hasRequiredKey$1 = 1;
  var e = requireBn$2(), t = requireUtils$1(), o = t.assert;
  function r(h, a) {
    this.ec = h, this.priv = null, this.pub = null, a.priv && this._importPrivate(a.priv, a.privEnc), a.pub && this._importPublic(a.pub, a.pubEnc);
  }
  return key$1 = r, r.fromPublic = function(h, a, p) {
    return a instanceof r ? a : new r(h, {
      pub: a,
      pubEnc: p
    });
  }, r.fromPrivate = function(h, a, p) {
    return a instanceof r ? a : new r(h, {
      priv: a,
      privEnc: p
    });
  }, r.prototype.validate = function() {
    var h = this.getPublic();
    return h.isInfinity() ? { result: !1, reason: "Invalid public key" } : h.validate() ? h.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
  }, r.prototype.getPublic = function(h, a) {
    return typeof h == "string" && (a = h, h = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), a ? this.pub.encode(a, h) : this.pub;
  }, r.prototype.getPrivate = function(h) {
    return h === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, r.prototype._importPrivate = function(h, a) {
    this.priv = new e(h, a || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, r.prototype._importPublic = function(h, a) {
    if (h.x || h.y) {
      this.ec.curve.type === "mont" ? o(h.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && o(h.x && h.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(h.x, h.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(h, a);
  }, r.prototype.derive = function(h) {
    return h.validate() || o(h.validate(), "public point not validated"), h.mul(this.priv).getX();
  }, r.prototype.sign = function(h, a, p) {
    return this.ec.sign(h, this, a, p);
  }, r.prototype.verify = function(h, a) {
    return this.ec.verify(h, a, this);
  }, r.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, key$1;
}
var signature$1, hasRequiredSignature$1;
function requireSignature$1() {
  if (hasRequiredSignature$1)
    return signature$1;
  hasRequiredSignature$1 = 1;
  var e = requireBn$2(), t = requireUtils$1(), o = t.assert;
  function r(b, g) {
    if (b instanceof r)
      return b;
    this._importDER(b, g) || (o(b.r && b.s, "Signature without r or s"), this.r = new e(b.r, 16), this.s = new e(b.s, 16), b.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = b.recoveryParam);
  }
  signature$1 = r;
  function h() {
    this.place = 0;
  }
  function a(b, g) {
    var w = b[g.place++];
    if (!(w & 128))
      return w;
    var C = w & 15;
    if (C === 0 || C > 4)
      return !1;
    for (var T = 0, k = 0, q = g.place; k < C; k++, q++)
      T <<= 8, T |= b[q], T >>>= 0;
    return T <= 127 ? !1 : (g.place = q, T);
  }
  function p(b) {
    for (var g = 0, w = b.length - 1; !b[g] && !(b[g + 1] & 128) && g < w; )
      g++;
    return g === 0 ? b : b.slice(g);
  }
  r.prototype._importDER = function(b, g) {
    b = t.toArray(b, g);
    var w = new h();
    if (b[w.place++] !== 48)
      return !1;
    var C = a(b, w);
    if (C === !1 || C + w.place !== b.length || b[w.place++] !== 2)
      return !1;
    var T = a(b, w);
    if (T === !1)
      return !1;
    var k = b.slice(w.place, T + w.place);
    if (w.place += T, b[w.place++] !== 2)
      return !1;
    var q = a(b, w);
    if (q === !1 || b.length !== q + w.place)
      return !1;
    var O = b.slice(w.place, q + w.place);
    if (k[0] === 0)
      if (k[1] & 128)
        k = k.slice(1);
      else
        return !1;
    if (O[0] === 0)
      if (O[1] & 128)
        O = O.slice(1);
      else
        return !1;
    return this.r = new e(k), this.s = new e(O), this.recoveryParam = null, !0;
  };
  function d(b, g) {
    if (g < 128) {
      b.push(g);
      return;
    }
    var w = 1 + (Math.log(g) / Math.LN2 >>> 3);
    for (b.push(w | 128); --w; )
      b.push(g >>> (w << 3) & 255);
    b.push(g);
  }
  return r.prototype.toDER = function(b) {
    var g = this.r.toArray(), w = this.s.toArray();
    for (g[0] & 128 && (g = [0].concat(g)), w[0] & 128 && (w = [0].concat(w)), g = p(g), w = p(w); !w[0] && !(w[1] & 128); )
      w = w.slice(1);
    var C = [2];
    d(C, g.length), C = C.concat(g), C.push(2), d(C, w.length);
    var T = C.concat(w), k = [48];
    return d(k, T.length), k = k.concat(T), t.encode(k, b);
  }, signature$1;
}
var ec$1, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc)
    return ec$1;
  hasRequiredEc = 1;
  var e = requireBn$2(), t = requireHmacDrbg(), o = requireUtils$1(), r = requireCurves(), h = requireBrorand(), a = o.assert, p = requireKey$1(), d = requireSignature$1();
  function b(g) {
    if (!(this instanceof b))
      return new b(g);
    typeof g == "string" && (a(
      Object.prototype.hasOwnProperty.call(r, g),
      "Unknown curve " + g
    ), g = r[g]), g instanceof r.PresetCurve && (g = { curve: g }), this.curve = g.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = g.curve.g, this.g.precompute(g.curve.n.bitLength() + 1), this.hash = g.hash || g.curve.hash;
  }
  return ec$1 = b, b.prototype.keyPair = function(g) {
    return new p(this, g);
  }, b.prototype.keyFromPrivate = function(g, w) {
    return p.fromPrivate(this, g, w);
  }, b.prototype.keyFromPublic = function(g, w) {
    return p.fromPublic(this, g, w);
  }, b.prototype.genKeyPair = function(g) {
    g || (g = {});
    for (var w = new t({
      hash: this.hash,
      pers: g.pers,
      persEnc: g.persEnc || "utf8",
      entropy: g.entropy || h(this.hash.hmacStrength),
      entropyEnc: g.entropy && g.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), C = this.n.byteLength(), T = this.n.sub(new e(2)); ; ) {
      var k = new e(w.generate(C));
      if (!(k.cmp(T) > 0))
        return k.iaddn(1), this.keyFromPrivate(k);
    }
  }, b.prototype._truncateToN = function(g, w) {
    var C = g.byteLength() * 8 - this.n.bitLength();
    return C > 0 && (g = g.ushrn(C)), !w && g.cmp(this.n) >= 0 ? g.sub(this.n) : g;
  }, b.prototype.sign = function(g, w, C, T) {
    typeof C == "object" && (T = C, C = null), T || (T = {}), w = this.keyFromPrivate(w, C), g = this._truncateToN(new e(g, 16));
    for (var k = this.n.byteLength(), q = w.getPrivate().toArray("be", k), O = g.toArray("be", k), N = new t({
      hash: this.hash,
      entropy: q,
      nonce: O,
      pers: T.pers,
      persEnc: T.persEnc || "utf8"
    }), j = this.n.sub(new e(1)), U = 0; ; U++) {
      var H = T.k ? T.k(U) : new e(N.generate(this.n.byteLength()));
      if (H = this._truncateToN(H, !0), !(H.cmpn(1) <= 0 || H.cmp(j) >= 0)) {
        var z = this.g.mul(H);
        if (!z.isInfinity()) {
          var ee = z.getX(), ne = ee.umod(this.n);
          if (ne.cmpn(0) !== 0) {
            var le = H.invm(this.n).mul(ne.mul(w.getPrivate()).iadd(g));
            if (le = le.umod(this.n), le.cmpn(0) !== 0) {
              var Z = (z.getY().isOdd() ? 1 : 0) | (ee.cmp(ne) !== 0 ? 2 : 0);
              return T.canonical && le.cmp(this.nh) > 0 && (le = this.n.sub(le), Z ^= 1), new d({ r: ne, s: le, recoveryParam: Z });
            }
          }
        }
      }
    }
  }, b.prototype.verify = function(g, w, C, T) {
    g = this._truncateToN(new e(g, 16)), C = this.keyFromPublic(C, T), w = new d(w, "hex");
    var k = w.r, q = w.s;
    if (k.cmpn(1) < 0 || k.cmp(this.n) >= 0 || q.cmpn(1) < 0 || q.cmp(this.n) >= 0)
      return !1;
    var O = q.invm(this.n), N = O.mul(g).umod(this.n), j = O.mul(k).umod(this.n), U;
    return this.curve._maxwellTrick ? (U = this.g.jmulAdd(N, C.getPublic(), j), U.isInfinity() ? !1 : U.eqXToP(k)) : (U = this.g.mulAdd(N, C.getPublic(), j), U.isInfinity() ? !1 : U.getX().umod(this.n).cmp(k) === 0);
  }, b.prototype.recoverPubKey = function(g, w, C, T) {
    a((3 & C) === C, "The recovery param is more than two bits"), w = new d(w, T);
    var k = this.n, q = new e(g), O = w.r, N = w.s, j = C & 1, U = C >> 1;
    if (O.cmp(this.curve.p.umod(this.curve.n)) >= 0 && U)
      throw new Error("Unable to find sencond key candinate");
    U ? O = this.curve.pointFromX(O.add(this.curve.n), j) : O = this.curve.pointFromX(O, j);
    var H = w.r.invm(k), z = k.sub(q).mul(H).umod(k), ee = N.mul(H).umod(k);
    return this.g.mulAdd(z, O, ee);
  }, b.prototype.getKeyRecoveryParam = function(g, w, C, T) {
    if (w = new d(w, T), w.recoveryParam !== null)
      return w.recoveryParam;
    for (var k = 0; k < 4; k++) {
      var q;
      try {
        q = this.recoverPubKey(g, w, k);
      } catch {
        continue;
      }
      if (q.eq(C))
        return k;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec$1;
}
var key, hasRequiredKey;
function requireKey() {
  if (hasRequiredKey)
    return key;
  hasRequiredKey = 1;
  var e = requireUtils$1(), t = e.assert, o = e.parseBytes, r = e.cachedProperty;
  function h(a, p) {
    this.eddsa = a, this._secret = o(p.secret), a.isPoint(p.pub) ? this._pub = p.pub : this._pubBytes = o(p.pub);
  }
  return h.fromPublic = function(a, p) {
    return p instanceof h ? p : new h(a, { pub: p });
  }, h.fromSecret = function(a, p) {
    return p instanceof h ? p : new h(a, { secret: p });
  }, h.prototype.secret = function() {
    return this._secret;
  }, r(h, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), r(h, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), r(h, "privBytes", function() {
    var a = this.eddsa, p = this.hash(), d = a.encodingLength - 1, b = p.slice(0, a.encodingLength);
    return b[0] &= 248, b[d] &= 127, b[d] |= 64, b;
  }), r(h, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), r(h, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), r(h, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), h.prototype.sign = function(a) {
    return t(this._secret, "KeyPair can only verify"), this.eddsa.sign(a, this);
  }, h.prototype.verify = function(a, p) {
    return this.eddsa.verify(a, p, this);
  }, h.prototype.getSecret = function(a) {
    return t(this._secret, "KeyPair is public only"), e.encode(this.secret(), a);
  }, h.prototype.getPublic = function(a) {
    return e.encode(this.pubBytes(), a);
  }, key = h, key;
}
var signature, hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature)
    return signature;
  hasRequiredSignature = 1;
  var e = requireBn$2(), t = requireUtils$1(), o = t.assert, r = t.cachedProperty, h = t.parseBytes;
  function a(p, d) {
    this.eddsa = p, typeof d != "object" && (d = h(d)), Array.isArray(d) && (d = {
      R: d.slice(0, p.encodingLength),
      S: d.slice(p.encodingLength)
    }), o(d.R && d.S, "Signature without R or S"), p.isPoint(d.R) && (this._R = d.R), d.S instanceof e && (this._S = d.S), this._Rencoded = Array.isArray(d.R) ? d.R : d.Rencoded, this._Sencoded = Array.isArray(d.S) ? d.S : d.Sencoded;
  }
  return r(a, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), r(a, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), r(a, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), r(a, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), a.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, a.prototype.toHex = function() {
    return t.encode(this.toBytes(), "hex").toUpperCase();
  }, signature = a, signature;
}
var eddsa, hasRequiredEddsa;
function requireEddsa() {
  if (hasRequiredEddsa)
    return eddsa;
  hasRequiredEddsa = 1;
  var e = requireHash(), t = requireCurves(), o = requireUtils$1(), r = o.assert, h = o.parseBytes, a = requireKey(), p = requireSignature();
  function d(b) {
    if (r(b === "ed25519", "only tested with ed25519 so far"), !(this instanceof d))
      return new d(b);
    b = t[b].curve, this.curve = b, this.g = b.g, this.g.precompute(b.n.bitLength() + 1), this.pointClass = b.point().constructor, this.encodingLength = Math.ceil(b.n.bitLength() / 8), this.hash = e.sha512;
  }
  return eddsa = d, d.prototype.sign = function(b, g) {
    b = h(b);
    var w = this.keyFromSecret(g), C = this.hashInt(w.messagePrefix(), b), T = this.g.mul(C), k = this.encodePoint(T), q = this.hashInt(k, w.pubBytes(), b).mul(w.priv()), O = C.add(q).umod(this.curve.n);
    return this.makeSignature({ R: T, S: O, Rencoded: k });
  }, d.prototype.verify = function(b, g, w) {
    b = h(b), g = this.makeSignature(g);
    var C = this.keyFromPublic(w), T = this.hashInt(g.Rencoded(), C.pubBytes(), b), k = this.g.mul(g.S()), q = g.R().add(C.pub().mul(T));
    return q.eq(k);
  }, d.prototype.hashInt = function() {
    for (var b = this.hash(), g = 0; g < arguments.length; g++)
      b.update(arguments[g]);
    return o.intFromLE(b.digest()).umod(this.curve.n);
  }, d.prototype.keyFromPublic = function(b) {
    return a.fromPublic(this, b);
  }, d.prototype.keyFromSecret = function(b) {
    return a.fromSecret(this, b);
  }, d.prototype.makeSignature = function(b) {
    return b instanceof p ? b : new p(this, b);
  }, d.prototype.encodePoint = function(b) {
    var g = b.getY().toArray("le", this.encodingLength);
    return g[this.encodingLength - 1] |= b.getX().isOdd() ? 128 : 0, g;
  }, d.prototype.decodePoint = function(b) {
    b = o.parseBytes(b);
    var g = b.length - 1, w = b.slice(0, g).concat(b[g] & -129), C = (b[g] & 128) !== 0, T = o.intFromLE(w);
    return this.curve.pointFromY(T, C);
  }, d.prototype.encodeInt = function(b) {
    return b.toArray("le", this.encodingLength);
  }, d.prototype.decodeInt = function(b) {
    return o.intFromLE(b);
  }, d.prototype.isPoint = function(b) {
    return b instanceof this.pointClass;
  }, eddsa;
}
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(e) {
    var t = e;
    t.version = require$$0.version, t.utils = requireUtils$1(), t.rand = requireBrorand(), t.curve = requireCurve(), t.curves = requireCurves(), t.ec = requireEc(), t.eddsa = requireEddsa();
  }(elliptic)), elliptic;
}
var bn$3 = { exports: {} }, hasRequiredBn;
function requireBn() {
  return hasRequiredBn || (hasRequiredBn = 1, function(e) {
    (function(t, o) {
      function r(f, y) {
        if (!f)
          throw new Error(y || "Assertion failed");
      }
      function h(f, y) {
        f.super_ = y;
        var v = function() {
        };
        v.prototype = y.prototype, f.prototype = new v(), f.prototype.constructor = f;
      }
      function a(f, y, v) {
        if (a.isBN(f))
          return f;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, f !== null && ((y === "le" || y === "be") && (v = y, y = 10), this._init(f || 0, y || 10, v || "be"));
      }
      typeof t == "object" ? t.exports = a : o.BN = a, a.BN = a, a.wordSize = 26;
      var p;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = requireBuffer$1().Buffer;
      } catch {
      }
      a.isBN = function(f) {
        return f instanceof a ? !0 : f !== null && typeof f == "object" && f.constructor.wordSize === a.wordSize && Array.isArray(f.words);
      }, a.max = function(f, y) {
        return f.cmp(y) > 0 ? f : y;
      }, a.min = function(f, y) {
        return f.cmp(y) < 0 ? f : y;
      }, a.prototype._init = function(f, y, v) {
        if (typeof f == "number")
          return this._initNumber(f, y, v);
        if (typeof f == "object")
          return this._initArray(f, y, v);
        y === "hex" && (y = 16), r(y === (y | 0) && y >= 2 && y <= 36), f = f.toString().replace(/\s+/g, "");
        var M = 0;
        f[0] === "-" && (M++, this.negative = 1), M < f.length && (y === 16 ? this._parseHex(f, M, v) : (this._parseBase(f, y, M), v === "le" && this._initArray(this.toArray(), y, v)));
      }, a.prototype._initNumber = function(f, y, v) {
        f < 0 && (this.negative = 1, f = -f), f < 67108864 ? (this.words = [f & 67108863], this.length = 1) : f < 4503599627370496 ? (this.words = [
          f & 67108863,
          f / 67108864 & 67108863
        ], this.length = 2) : (r(f < 9007199254740992), this.words = [
          f & 67108863,
          f / 67108864 & 67108863,
          1
        ], this.length = 3), v === "le" && this._initArray(this.toArray(), y, v);
      }, a.prototype._initArray = function(f, y, v) {
        if (r(typeof f.length == "number"), f.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(f.length / 3), this.words = new Array(this.length);
        for (var M = 0; M < this.length; M++)
          this.words[M] = 0;
        var B, S, _ = 0;
        if (v === "be")
          for (M = f.length - 1, B = 0; M >= 0; M -= 3)
            S = f[M] | f[M - 1] << 8 | f[M - 2] << 16, this.words[B] |= S << _ & 67108863, this.words[B + 1] = S >>> 26 - _ & 67108863, _ += 24, _ >= 26 && (_ -= 26, B++);
        else if (v === "le")
          for (M = 0, B = 0; M < f.length; M += 3)
            S = f[M] | f[M + 1] << 8 | f[M + 2] << 16, this.words[B] |= S << _ & 67108863, this.words[B + 1] = S >>> 26 - _ & 67108863, _ += 24, _ >= 26 && (_ -= 26, B++);
        return this._strip();
      };
      function d(f, y) {
        var v = f.charCodeAt(y);
        if (v >= 48 && v <= 57)
          return v - 48;
        if (v >= 65 && v <= 70)
          return v - 55;
        if (v >= 97 && v <= 102)
          return v - 87;
        r(!1, "Invalid character in " + f);
      }
      function b(f, y, v) {
        var M = d(f, v);
        return v - 1 >= y && (M |= d(f, v - 1) << 4), M;
      }
      a.prototype._parseHex = function(f, y, v) {
        this.length = Math.ceil((f.length - y) / 6), this.words = new Array(this.length);
        for (var M = 0; M < this.length; M++)
          this.words[M] = 0;
        var B = 0, S = 0, _;
        if (v === "be")
          for (M = f.length - 1; M >= y; M -= 2)
            _ = b(f, y, M) << B, this.words[S] |= _ & 67108863, B >= 18 ? (B -= 18, S += 1, this.words[S] |= _ >>> 26) : B += 8;
        else {
          var E = f.length - y;
          for (M = E % 2 === 0 ? y + 1 : y; M < f.length; M += 2)
            _ = b(f, y, M) << B, this.words[S] |= _ & 67108863, B >= 18 ? (B -= 18, S += 1, this.words[S] |= _ >>> 26) : B += 8;
        }
        this._strip();
      };
      function g(f, y, v, M) {
        for (var B = 0, S = 0, _ = Math.min(f.length, v), E = y; E < _; E++) {
          var m = f.charCodeAt(E) - 48;
          B *= M, m >= 49 ? S = m - 49 + 10 : m >= 17 ? S = m - 17 + 10 : S = m, r(m >= 0 && S < M, "Invalid character"), B += S;
        }
        return B;
      }
      a.prototype._parseBase = function(f, y, v) {
        this.words = [0], this.length = 1;
        for (var M = 0, B = 1; B <= 67108863; B *= y)
          M++;
        M--, B = B / y | 0;
        for (var S = f.length - v, _ = S % M, E = Math.min(S, S - _) + v, m = 0, A = v; A < E; A += M)
          m = g(f, A, A + M, y), this.imuln(B), this.words[0] + m < 67108864 ? this.words[0] += m : this._iaddn(m);
        if (_ !== 0) {
          var $ = 1;
          for (m = g(f, A, f.length, y), A = 0; A < _; A++)
            $ *= y;
          this.imuln($), this.words[0] + m < 67108864 ? this.words[0] += m : this._iaddn(m);
        }
        this._strip();
      }, a.prototype.copy = function(f) {
        f.words = new Array(this.length);
        for (var y = 0; y < this.length; y++)
          f.words[y] = this.words[y];
        f.length = this.length, f.negative = this.negative, f.red = this.red;
      };
      function w(f, y) {
        f.words = y.words, f.length = y.length, f.negative = y.negative, f.red = y.red;
      }
      if (a.prototype._move = function(f) {
        w(f, this);
      }, a.prototype.clone = function() {
        var f = new a(null);
        return this.copy(f), f;
      }, a.prototype._expand = function(f) {
        for (; this.length < f; )
          this.words[this.length++] = 0;
        return this;
      }, a.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, a.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          a.prototype[Symbol.for("nodejs.util.inspect.custom")] = C;
        } catch {
          a.prototype.inspect = C;
        }
      else
        a.prototype.inspect = C;
      function C() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var T = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], k = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], q = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      a.prototype.toString = function(f, y) {
        f = f || 10, y = y | 0 || 1;
        var v;
        if (f === 16 || f === "hex") {
          v = "";
          for (var M = 0, B = 0, S = 0; S < this.length; S++) {
            var _ = this.words[S], E = ((_ << M | B) & 16777215).toString(16);
            B = _ >>> 24 - M & 16777215, M += 2, M >= 26 && (M -= 26, S--), B !== 0 || S !== this.length - 1 ? v = T[6 - E.length] + E + v : v = E + v;
          }
          for (B !== 0 && (v = B.toString(16) + v); v.length % y !== 0; )
            v = "0" + v;
          return this.negative !== 0 && (v = "-" + v), v;
        }
        if (f === (f | 0) && f >= 2 && f <= 36) {
          var m = k[f], A = q[f];
          v = "";
          var $ = this.clone();
          for ($.negative = 0; !$.isZero(); ) {
            var X = $.modrn(A).toString(f);
            $ = $.idivn(A), $.isZero() ? v = X + v : v = T[m - X.length] + X + v;
          }
          for (this.isZero() && (v = "0" + v); v.length % y !== 0; )
            v = "0" + v;
          return this.negative !== 0 && (v = "-" + v), v;
        }
        r(!1, "Base should be between 2 and 36");
      }, a.prototype.toNumber = function() {
        var f = this.words[0];
        return this.length === 2 ? f += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f : f;
      }, a.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, p && (a.prototype.toBuffer = function(f, y) {
        return this.toArrayLike(p, f, y);
      }), a.prototype.toArray = function(f, y) {
        return this.toArrayLike(Array, f, y);
      };
      var O = function(f, y) {
        return f.allocUnsafe ? f.allocUnsafe(y) : new f(y);
      };
      a.prototype.toArrayLike = function(f, y, v) {
        this._strip();
        var M = this.byteLength(), B = v || Math.max(1, M);
        r(M <= B, "byte array longer than desired length"), r(B > 0, "Requested array length <= 0");
        var S = O(f, B), _ = y === "le" ? "LE" : "BE";
        return this["_toArrayLike" + _](S, M), S;
      }, a.prototype._toArrayLikeLE = function(f, y) {
        for (var v = 0, M = 0, B = 0, S = 0; B < this.length; B++) {
          var _ = this.words[B] << S | M;
          f[v++] = _ & 255, v < f.length && (f[v++] = _ >> 8 & 255), v < f.length && (f[v++] = _ >> 16 & 255), S === 6 ? (v < f.length && (f[v++] = _ >> 24 & 255), M = 0, S = 0) : (M = _ >>> 24, S += 2);
        }
        if (v < f.length)
          for (f[v++] = M; v < f.length; )
            f[v++] = 0;
      }, a.prototype._toArrayLikeBE = function(f, y) {
        for (var v = f.length - 1, M = 0, B = 0, S = 0; B < this.length; B++) {
          var _ = this.words[B] << S | M;
          f[v--] = _ & 255, v >= 0 && (f[v--] = _ >> 8 & 255), v >= 0 && (f[v--] = _ >> 16 & 255), S === 6 ? (v >= 0 && (f[v--] = _ >> 24 & 255), M = 0, S = 0) : (M = _ >>> 24, S += 2);
        }
        if (v >= 0)
          for (f[v--] = M; v >= 0; )
            f[v--] = 0;
      }, Math.clz32 ? a.prototype._countBits = function(f) {
        return 32 - Math.clz32(f);
      } : a.prototype._countBits = function(f) {
        var y = f, v = 0;
        return y >= 4096 && (v += 13, y >>>= 13), y >= 64 && (v += 7, y >>>= 7), y >= 8 && (v += 4, y >>>= 4), y >= 2 && (v += 2, y >>>= 2), v + y;
      }, a.prototype._zeroBits = function(f) {
        if (f === 0)
          return 26;
        var y = f, v = 0;
        return y & 8191 || (v += 13, y >>>= 13), y & 127 || (v += 7, y >>>= 7), y & 15 || (v += 4, y >>>= 4), y & 3 || (v += 2, y >>>= 2), y & 1 || v++, v;
      }, a.prototype.bitLength = function() {
        var f = this.words[this.length - 1], y = this._countBits(f);
        return (this.length - 1) * 26 + y;
      };
      function N(f) {
        for (var y = new Array(f.bitLength()), v = 0; v < y.length; v++) {
          var M = v / 26 | 0, B = v % 26;
          y[v] = f.words[M] >>> B & 1;
        }
        return y;
      }
      a.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var f = 0, y = 0; y < this.length; y++) {
          var v = this._zeroBits(this.words[y]);
          if (f += v, v !== 26)
            break;
        }
        return f;
      }, a.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, a.prototype.toTwos = function(f) {
        return this.negative !== 0 ? this.abs().inotn(f).iaddn(1) : this.clone();
      }, a.prototype.fromTwos = function(f) {
        return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone();
      }, a.prototype.isNeg = function() {
        return this.negative !== 0;
      }, a.prototype.neg = function() {
        return this.clone().ineg();
      }, a.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, a.prototype.iuor = function(f) {
        for (; this.length < f.length; )
          this.words[this.length++] = 0;
        for (var y = 0; y < f.length; y++)
          this.words[y] = this.words[y] | f.words[y];
        return this._strip();
      }, a.prototype.ior = function(f) {
        return r((this.negative | f.negative) === 0), this.iuor(f);
      }, a.prototype.or = function(f) {
        return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this);
      }, a.prototype.uor = function(f) {
        return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this);
      }, a.prototype.iuand = function(f) {
        var y;
        this.length > f.length ? y = f : y = this;
        for (var v = 0; v < y.length; v++)
          this.words[v] = this.words[v] & f.words[v];
        return this.length = y.length, this._strip();
      }, a.prototype.iand = function(f) {
        return r((this.negative | f.negative) === 0), this.iuand(f);
      }, a.prototype.and = function(f) {
        return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this);
      }, a.prototype.uand = function(f) {
        return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this);
      }, a.prototype.iuxor = function(f) {
        var y, v;
        this.length > f.length ? (y = this, v = f) : (y = f, v = this);
        for (var M = 0; M < v.length; M++)
          this.words[M] = y.words[M] ^ v.words[M];
        if (this !== y)
          for (; M < y.length; M++)
            this.words[M] = y.words[M];
        return this.length = y.length, this._strip();
      }, a.prototype.ixor = function(f) {
        return r((this.negative | f.negative) === 0), this.iuxor(f);
      }, a.prototype.xor = function(f) {
        return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this);
      }, a.prototype.uxor = function(f) {
        return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this);
      }, a.prototype.inotn = function(f) {
        r(typeof f == "number" && f >= 0);
        var y = Math.ceil(f / 26) | 0, v = f % 26;
        this._expand(y), v > 0 && y--;
        for (var M = 0; M < y; M++)
          this.words[M] = ~this.words[M] & 67108863;
        return v > 0 && (this.words[M] = ~this.words[M] & 67108863 >> 26 - v), this._strip();
      }, a.prototype.notn = function(f) {
        return this.clone().inotn(f);
      }, a.prototype.setn = function(f, y) {
        r(typeof f == "number" && f >= 0);
        var v = f / 26 | 0, M = f % 26;
        return this._expand(v + 1), y ? this.words[v] = this.words[v] | 1 << M : this.words[v] = this.words[v] & ~(1 << M), this._strip();
      }, a.prototype.iadd = function(f) {
        var y;
        if (this.negative !== 0 && f.negative === 0)
          return this.negative = 0, y = this.isub(f), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && f.negative !== 0)
          return f.negative = 0, y = this.isub(f), f.negative = 1, y._normSign();
        var v, M;
        this.length > f.length ? (v = this, M = f) : (v = f, M = this);
        for (var B = 0, S = 0; S < M.length; S++)
          y = (v.words[S] | 0) + (M.words[S] | 0) + B, this.words[S] = y & 67108863, B = y >>> 26;
        for (; B !== 0 && S < v.length; S++)
          y = (v.words[S] | 0) + B, this.words[S] = y & 67108863, B = y >>> 26;
        if (this.length = v.length, B !== 0)
          this.words[this.length] = B, this.length++;
        else if (v !== this)
          for (; S < v.length; S++)
            this.words[S] = v.words[S];
        return this;
      }, a.prototype.add = function(f) {
        var y;
        return f.negative !== 0 && this.negative === 0 ? (f.negative = 0, y = this.sub(f), f.negative ^= 1, y) : f.negative === 0 && this.negative !== 0 ? (this.negative = 0, y = f.sub(this), this.negative = 1, y) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this);
      }, a.prototype.isub = function(f) {
        if (f.negative !== 0) {
          f.negative = 0;
          var y = this.iadd(f);
          return f.negative = 1, y._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(f), this.negative = 1, this._normSign();
        var v = this.cmp(f);
        if (v === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var M, B;
        v > 0 ? (M = this, B = f) : (M = f, B = this);
        for (var S = 0, _ = 0; _ < B.length; _++)
          y = (M.words[_] | 0) - (B.words[_] | 0) + S, S = y >> 26, this.words[_] = y & 67108863;
        for (; S !== 0 && _ < M.length; _++)
          y = (M.words[_] | 0) + S, S = y >> 26, this.words[_] = y & 67108863;
        if (S === 0 && _ < M.length && M !== this)
          for (; _ < M.length; _++)
            this.words[_] = M.words[_];
        return this.length = Math.max(this.length, _), M !== this && (this.negative = 1), this._strip();
      }, a.prototype.sub = function(f) {
        return this.clone().isub(f);
      };
      function j(f, y, v) {
        v.negative = y.negative ^ f.negative;
        var M = f.length + y.length | 0;
        v.length = M, M = M - 1 | 0;
        var B = f.words[0] | 0, S = y.words[0] | 0, _ = B * S, E = _ & 67108863, m = _ / 67108864 | 0;
        v.words[0] = E;
        for (var A = 1; A < M; A++) {
          for (var $ = m >>> 26, X = m & 67108863, oe = Math.min(A, y.length - 1), J = Math.max(0, A - f.length + 1); J <= oe; J++) {
            var W = A - J | 0;
            B = f.words[W] | 0, S = y.words[J] | 0, _ = B * S + X, $ += _ / 67108864 | 0, X = _ & 67108863;
          }
          v.words[A] = X | 0, m = $ | 0;
        }
        return m !== 0 ? v.words[A] = m | 0 : v.length--, v._strip();
      }
      var U = function(f, y, v) {
        var M = f.words, B = y.words, S = v.words, _ = 0, E, m, A, $ = M[0] | 0, X = $ & 8191, oe = $ >>> 13, J = M[1] | 0, W = J & 8191, Q = J >>> 13, me = M[2] | 0, be = me & 8191, Y = me >>> 13, re = M[3] | 0, de = re & 8191, Ae = re >>> 13, qe = M[4] | 0, x = qe & 8191, L = qe >>> 13, D = M[5] | 0, F = D & 8191, ue = D >>> 13, ge = M[6] | 0, ce = ge & 8191, ve = ge >>> 13, Re = M[7] | 0, ke = Re & 8191, Ce = Re >>> 13, Le = M[8] | 0, Oe = Le & 8191, Pe = Le >>> 13, et = M[9] | 0, Ye = et & 8191, Ne = et >>> 13, Tt = B[0] | 0, tt = Tt & 8191, Ue = Tt >>> 13, Ct = B[1] | 0, rt = Ct & 8191, Ke = Ct >>> 13, ii = B[2] | 0, it = ii & 8191, $e = ii >>> 13, Ot = B[3] | 0, vt = Ot & 8191, Fe = Ot >>> 13, ni = B[4] | 0, nt = ni & 8191, ze = ni >>> 13, oi = B[5] | 0, ot = oi & 8191, Xe = oi >>> 13, Dt = B[6] | 0, Ze = Dt & 8191, je = Dt >>> 13, ri = B[7] | 0, St = ri & 8191, Qe = ri >>> 13, ai = B[8] | 0, It = ai & 8191, Je = ai >>> 13, si = B[9] | 0, At = si & 8191, Bt = si >>> 13;
        v.negative = f.negative ^ y.negative, v.length = 19, E = Math.imul(X, tt), m = Math.imul(X, Ue), m = m + Math.imul(oe, tt) | 0, A = Math.imul(oe, Ue);
        var ui = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (ui >>> 26) | 0, ui &= 67108863, E = Math.imul(W, tt), m = Math.imul(W, Ue), m = m + Math.imul(Q, tt) | 0, A = Math.imul(Q, Ue), E = E + Math.imul(X, rt) | 0, m = m + Math.imul(X, Ke) | 0, m = m + Math.imul(oe, rt) | 0, A = A + Math.imul(oe, Ke) | 0;
        var fi = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (fi >>> 26) | 0, fi &= 67108863, E = Math.imul(be, tt), m = Math.imul(be, Ue), m = m + Math.imul(Y, tt) | 0, A = Math.imul(Y, Ue), E = E + Math.imul(W, rt) | 0, m = m + Math.imul(W, Ke) | 0, m = m + Math.imul(Q, rt) | 0, A = A + Math.imul(Q, Ke) | 0, E = E + Math.imul(X, it) | 0, m = m + Math.imul(X, $e) | 0, m = m + Math.imul(oe, it) | 0, A = A + Math.imul(oe, $e) | 0;
        var hi = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (hi >>> 26) | 0, hi &= 67108863, E = Math.imul(de, tt), m = Math.imul(de, Ue), m = m + Math.imul(Ae, tt) | 0, A = Math.imul(Ae, Ue), E = E + Math.imul(be, rt) | 0, m = m + Math.imul(be, Ke) | 0, m = m + Math.imul(Y, rt) | 0, A = A + Math.imul(Y, Ke) | 0, E = E + Math.imul(W, it) | 0, m = m + Math.imul(W, $e) | 0, m = m + Math.imul(Q, it) | 0, A = A + Math.imul(Q, $e) | 0, E = E + Math.imul(X, vt) | 0, m = m + Math.imul(X, Fe) | 0, m = m + Math.imul(oe, vt) | 0, A = A + Math.imul(oe, Fe) | 0;
        var ci = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (ci >>> 26) | 0, ci &= 67108863, E = Math.imul(x, tt), m = Math.imul(x, Ue), m = m + Math.imul(L, tt) | 0, A = Math.imul(L, Ue), E = E + Math.imul(de, rt) | 0, m = m + Math.imul(de, Ke) | 0, m = m + Math.imul(Ae, rt) | 0, A = A + Math.imul(Ae, Ke) | 0, E = E + Math.imul(be, it) | 0, m = m + Math.imul(be, $e) | 0, m = m + Math.imul(Y, it) | 0, A = A + Math.imul(Y, $e) | 0, E = E + Math.imul(W, vt) | 0, m = m + Math.imul(W, Fe) | 0, m = m + Math.imul(Q, vt) | 0, A = A + Math.imul(Q, Fe) | 0, E = E + Math.imul(X, nt) | 0, m = m + Math.imul(X, ze) | 0, m = m + Math.imul(oe, nt) | 0, A = A + Math.imul(oe, ze) | 0;
        var li = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (li >>> 26) | 0, li &= 67108863, E = Math.imul(F, tt), m = Math.imul(F, Ue), m = m + Math.imul(ue, tt) | 0, A = Math.imul(ue, Ue), E = E + Math.imul(x, rt) | 0, m = m + Math.imul(x, Ke) | 0, m = m + Math.imul(L, rt) | 0, A = A + Math.imul(L, Ke) | 0, E = E + Math.imul(de, it) | 0, m = m + Math.imul(de, $e) | 0, m = m + Math.imul(Ae, it) | 0, A = A + Math.imul(Ae, $e) | 0, E = E + Math.imul(be, vt) | 0, m = m + Math.imul(be, Fe) | 0, m = m + Math.imul(Y, vt) | 0, A = A + Math.imul(Y, Fe) | 0, E = E + Math.imul(W, nt) | 0, m = m + Math.imul(W, ze) | 0, m = m + Math.imul(Q, nt) | 0, A = A + Math.imul(Q, ze) | 0, E = E + Math.imul(X, ot) | 0, m = m + Math.imul(X, Xe) | 0, m = m + Math.imul(oe, ot) | 0, A = A + Math.imul(oe, Xe) | 0;
        var di = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (di >>> 26) | 0, di &= 67108863, E = Math.imul(ce, tt), m = Math.imul(ce, Ue), m = m + Math.imul(ve, tt) | 0, A = Math.imul(ve, Ue), E = E + Math.imul(F, rt) | 0, m = m + Math.imul(F, Ke) | 0, m = m + Math.imul(ue, rt) | 0, A = A + Math.imul(ue, Ke) | 0, E = E + Math.imul(x, it) | 0, m = m + Math.imul(x, $e) | 0, m = m + Math.imul(L, it) | 0, A = A + Math.imul(L, $e) | 0, E = E + Math.imul(de, vt) | 0, m = m + Math.imul(de, Fe) | 0, m = m + Math.imul(Ae, vt) | 0, A = A + Math.imul(Ae, Fe) | 0, E = E + Math.imul(be, nt) | 0, m = m + Math.imul(be, ze) | 0, m = m + Math.imul(Y, nt) | 0, A = A + Math.imul(Y, ze) | 0, E = E + Math.imul(W, ot) | 0, m = m + Math.imul(W, Xe) | 0, m = m + Math.imul(Q, ot) | 0, A = A + Math.imul(Q, Xe) | 0, E = E + Math.imul(X, Ze) | 0, m = m + Math.imul(X, je) | 0, m = m + Math.imul(oe, Ze) | 0, A = A + Math.imul(oe, je) | 0;
        var pi = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (pi >>> 26) | 0, pi &= 67108863, E = Math.imul(ke, tt), m = Math.imul(ke, Ue), m = m + Math.imul(Ce, tt) | 0, A = Math.imul(Ce, Ue), E = E + Math.imul(ce, rt) | 0, m = m + Math.imul(ce, Ke) | 0, m = m + Math.imul(ve, rt) | 0, A = A + Math.imul(ve, Ke) | 0, E = E + Math.imul(F, it) | 0, m = m + Math.imul(F, $e) | 0, m = m + Math.imul(ue, it) | 0, A = A + Math.imul(ue, $e) | 0, E = E + Math.imul(x, vt) | 0, m = m + Math.imul(x, Fe) | 0, m = m + Math.imul(L, vt) | 0, A = A + Math.imul(L, Fe) | 0, E = E + Math.imul(de, nt) | 0, m = m + Math.imul(de, ze) | 0, m = m + Math.imul(Ae, nt) | 0, A = A + Math.imul(Ae, ze) | 0, E = E + Math.imul(be, ot) | 0, m = m + Math.imul(be, Xe) | 0, m = m + Math.imul(Y, ot) | 0, A = A + Math.imul(Y, Xe) | 0, E = E + Math.imul(W, Ze) | 0, m = m + Math.imul(W, je) | 0, m = m + Math.imul(Q, Ze) | 0, A = A + Math.imul(Q, je) | 0, E = E + Math.imul(X, St) | 0, m = m + Math.imul(X, Qe) | 0, m = m + Math.imul(oe, St) | 0, A = A + Math.imul(oe, Qe) | 0;
        var yi = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (yi >>> 26) | 0, yi &= 67108863, E = Math.imul(Oe, tt), m = Math.imul(Oe, Ue), m = m + Math.imul(Pe, tt) | 0, A = Math.imul(Pe, Ue), E = E + Math.imul(ke, rt) | 0, m = m + Math.imul(ke, Ke) | 0, m = m + Math.imul(Ce, rt) | 0, A = A + Math.imul(Ce, Ke) | 0, E = E + Math.imul(ce, it) | 0, m = m + Math.imul(ce, $e) | 0, m = m + Math.imul(ve, it) | 0, A = A + Math.imul(ve, $e) | 0, E = E + Math.imul(F, vt) | 0, m = m + Math.imul(F, Fe) | 0, m = m + Math.imul(ue, vt) | 0, A = A + Math.imul(ue, Fe) | 0, E = E + Math.imul(x, nt) | 0, m = m + Math.imul(x, ze) | 0, m = m + Math.imul(L, nt) | 0, A = A + Math.imul(L, ze) | 0, E = E + Math.imul(de, ot) | 0, m = m + Math.imul(de, Xe) | 0, m = m + Math.imul(Ae, ot) | 0, A = A + Math.imul(Ae, Xe) | 0, E = E + Math.imul(be, Ze) | 0, m = m + Math.imul(be, je) | 0, m = m + Math.imul(Y, Ze) | 0, A = A + Math.imul(Y, je) | 0, E = E + Math.imul(W, St) | 0, m = m + Math.imul(W, Qe) | 0, m = m + Math.imul(Q, St) | 0, A = A + Math.imul(Q, Qe) | 0, E = E + Math.imul(X, It) | 0, m = m + Math.imul(X, Je) | 0, m = m + Math.imul(oe, It) | 0, A = A + Math.imul(oe, Je) | 0;
        var mi = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (mi >>> 26) | 0, mi &= 67108863, E = Math.imul(Ye, tt), m = Math.imul(Ye, Ue), m = m + Math.imul(Ne, tt) | 0, A = Math.imul(Ne, Ue), E = E + Math.imul(Oe, rt) | 0, m = m + Math.imul(Oe, Ke) | 0, m = m + Math.imul(Pe, rt) | 0, A = A + Math.imul(Pe, Ke) | 0, E = E + Math.imul(ke, it) | 0, m = m + Math.imul(ke, $e) | 0, m = m + Math.imul(Ce, it) | 0, A = A + Math.imul(Ce, $e) | 0, E = E + Math.imul(ce, vt) | 0, m = m + Math.imul(ce, Fe) | 0, m = m + Math.imul(ve, vt) | 0, A = A + Math.imul(ve, Fe) | 0, E = E + Math.imul(F, nt) | 0, m = m + Math.imul(F, ze) | 0, m = m + Math.imul(ue, nt) | 0, A = A + Math.imul(ue, ze) | 0, E = E + Math.imul(x, ot) | 0, m = m + Math.imul(x, Xe) | 0, m = m + Math.imul(L, ot) | 0, A = A + Math.imul(L, Xe) | 0, E = E + Math.imul(de, Ze) | 0, m = m + Math.imul(de, je) | 0, m = m + Math.imul(Ae, Ze) | 0, A = A + Math.imul(Ae, je) | 0, E = E + Math.imul(be, St) | 0, m = m + Math.imul(be, Qe) | 0, m = m + Math.imul(Y, St) | 0, A = A + Math.imul(Y, Qe) | 0, E = E + Math.imul(W, It) | 0, m = m + Math.imul(W, Je) | 0, m = m + Math.imul(Q, It) | 0, A = A + Math.imul(Q, Je) | 0, E = E + Math.imul(X, At) | 0, m = m + Math.imul(X, Bt) | 0, m = m + Math.imul(oe, At) | 0, A = A + Math.imul(oe, Bt) | 0;
        var gi = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (gi >>> 26) | 0, gi &= 67108863, E = Math.imul(Ye, rt), m = Math.imul(Ye, Ke), m = m + Math.imul(Ne, rt) | 0, A = Math.imul(Ne, Ke), E = E + Math.imul(Oe, it) | 0, m = m + Math.imul(Oe, $e) | 0, m = m + Math.imul(Pe, it) | 0, A = A + Math.imul(Pe, $e) | 0, E = E + Math.imul(ke, vt) | 0, m = m + Math.imul(ke, Fe) | 0, m = m + Math.imul(Ce, vt) | 0, A = A + Math.imul(Ce, Fe) | 0, E = E + Math.imul(ce, nt) | 0, m = m + Math.imul(ce, ze) | 0, m = m + Math.imul(ve, nt) | 0, A = A + Math.imul(ve, ze) | 0, E = E + Math.imul(F, ot) | 0, m = m + Math.imul(F, Xe) | 0, m = m + Math.imul(ue, ot) | 0, A = A + Math.imul(ue, Xe) | 0, E = E + Math.imul(x, Ze) | 0, m = m + Math.imul(x, je) | 0, m = m + Math.imul(L, Ze) | 0, A = A + Math.imul(L, je) | 0, E = E + Math.imul(de, St) | 0, m = m + Math.imul(de, Qe) | 0, m = m + Math.imul(Ae, St) | 0, A = A + Math.imul(Ae, Qe) | 0, E = E + Math.imul(be, It) | 0, m = m + Math.imul(be, Je) | 0, m = m + Math.imul(Y, It) | 0, A = A + Math.imul(Y, Je) | 0, E = E + Math.imul(W, At) | 0, m = m + Math.imul(W, Bt) | 0, m = m + Math.imul(Q, At) | 0, A = A + Math.imul(Q, Bt) | 0;
        var vi = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (vi >>> 26) | 0, vi &= 67108863, E = Math.imul(Ye, it), m = Math.imul(Ye, $e), m = m + Math.imul(Ne, it) | 0, A = Math.imul(Ne, $e), E = E + Math.imul(Oe, vt) | 0, m = m + Math.imul(Oe, Fe) | 0, m = m + Math.imul(Pe, vt) | 0, A = A + Math.imul(Pe, Fe) | 0, E = E + Math.imul(ke, nt) | 0, m = m + Math.imul(ke, ze) | 0, m = m + Math.imul(Ce, nt) | 0, A = A + Math.imul(Ce, ze) | 0, E = E + Math.imul(ce, ot) | 0, m = m + Math.imul(ce, Xe) | 0, m = m + Math.imul(ve, ot) | 0, A = A + Math.imul(ve, Xe) | 0, E = E + Math.imul(F, Ze) | 0, m = m + Math.imul(F, je) | 0, m = m + Math.imul(ue, Ze) | 0, A = A + Math.imul(ue, je) | 0, E = E + Math.imul(x, St) | 0, m = m + Math.imul(x, Qe) | 0, m = m + Math.imul(L, St) | 0, A = A + Math.imul(L, Qe) | 0, E = E + Math.imul(de, It) | 0, m = m + Math.imul(de, Je) | 0, m = m + Math.imul(Ae, It) | 0, A = A + Math.imul(Ae, Je) | 0, E = E + Math.imul(be, At) | 0, m = m + Math.imul(be, Bt) | 0, m = m + Math.imul(Y, At) | 0, A = A + Math.imul(Y, Bt) | 0;
        var Nn = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (Nn >>> 26) | 0, Nn &= 67108863, E = Math.imul(Ye, vt), m = Math.imul(Ye, Fe), m = m + Math.imul(Ne, vt) | 0, A = Math.imul(Ne, Fe), E = E + Math.imul(Oe, nt) | 0, m = m + Math.imul(Oe, ze) | 0, m = m + Math.imul(Pe, nt) | 0, A = A + Math.imul(Pe, ze) | 0, E = E + Math.imul(ke, ot) | 0, m = m + Math.imul(ke, Xe) | 0, m = m + Math.imul(Ce, ot) | 0, A = A + Math.imul(Ce, Xe) | 0, E = E + Math.imul(ce, Ze) | 0, m = m + Math.imul(ce, je) | 0, m = m + Math.imul(ve, Ze) | 0, A = A + Math.imul(ve, je) | 0, E = E + Math.imul(F, St) | 0, m = m + Math.imul(F, Qe) | 0, m = m + Math.imul(ue, St) | 0, A = A + Math.imul(ue, Qe) | 0, E = E + Math.imul(x, It) | 0, m = m + Math.imul(x, Je) | 0, m = m + Math.imul(L, It) | 0, A = A + Math.imul(L, Je) | 0, E = E + Math.imul(de, At) | 0, m = m + Math.imul(de, Bt) | 0, m = m + Math.imul(Ae, At) | 0, A = A + Math.imul(Ae, Bt) | 0;
        var Dn = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (Dn >>> 26) | 0, Dn &= 67108863, E = Math.imul(Ye, nt), m = Math.imul(Ye, ze), m = m + Math.imul(Ne, nt) | 0, A = Math.imul(Ne, ze), E = E + Math.imul(Oe, ot) | 0, m = m + Math.imul(Oe, Xe) | 0, m = m + Math.imul(Pe, ot) | 0, A = A + Math.imul(Pe, Xe) | 0, E = E + Math.imul(ke, Ze) | 0, m = m + Math.imul(ke, je) | 0, m = m + Math.imul(Ce, Ze) | 0, A = A + Math.imul(Ce, je) | 0, E = E + Math.imul(ce, St) | 0, m = m + Math.imul(ce, Qe) | 0, m = m + Math.imul(ve, St) | 0, A = A + Math.imul(ve, Qe) | 0, E = E + Math.imul(F, It) | 0, m = m + Math.imul(F, Je) | 0, m = m + Math.imul(ue, It) | 0, A = A + Math.imul(ue, Je) | 0, E = E + Math.imul(x, At) | 0, m = m + Math.imul(x, Bt) | 0, m = m + Math.imul(L, At) | 0, A = A + Math.imul(L, Bt) | 0;
        var eM = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (eM >>> 26) | 0, eM &= 67108863, E = Math.imul(Ye, ot), m = Math.imul(Ye, Xe), m = m + Math.imul(Ne, ot) | 0, A = Math.imul(Ne, Xe), E = E + Math.imul(Oe, Ze) | 0, m = m + Math.imul(Oe, je) | 0, m = m + Math.imul(Pe, Ze) | 0, A = A + Math.imul(Pe, je) | 0, E = E + Math.imul(ke, St) | 0, m = m + Math.imul(ke, Qe) | 0, m = m + Math.imul(Ce, St) | 0, A = A + Math.imul(Ce, Qe) | 0, E = E + Math.imul(ce, It) | 0, m = m + Math.imul(ce, Je) | 0, m = m + Math.imul(ve, It) | 0, A = A + Math.imul(ve, Je) | 0, E = E + Math.imul(F, At) | 0, m = m + Math.imul(F, Bt) | 0, m = m + Math.imul(ue, At) | 0, A = A + Math.imul(ue, Bt) | 0;
        var tM = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (tM >>> 26) | 0, tM &= 67108863, E = Math.imul(Ye, Ze), m = Math.imul(Ye, je), m = m + Math.imul(Ne, Ze) | 0, A = Math.imul(Ne, je), E = E + Math.imul(Oe, St) | 0, m = m + Math.imul(Oe, Qe) | 0, m = m + Math.imul(Pe, St) | 0, A = A + Math.imul(Pe, Qe) | 0, E = E + Math.imul(ke, It) | 0, m = m + Math.imul(ke, Je) | 0, m = m + Math.imul(Ce, It) | 0, A = A + Math.imul(Ce, Je) | 0, E = E + Math.imul(ce, At) | 0, m = m + Math.imul(ce, Bt) | 0, m = m + Math.imul(ve, At) | 0, A = A + Math.imul(ve, Bt) | 0;
        var rM = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (rM >>> 26) | 0, rM &= 67108863, E = Math.imul(Ye, St), m = Math.imul(Ye, Qe), m = m + Math.imul(Ne, St) | 0, A = Math.imul(Ne, Qe), E = E + Math.imul(Oe, It) | 0, m = m + Math.imul(Oe, Je) | 0, m = m + Math.imul(Pe, It) | 0, A = A + Math.imul(Pe, Je) | 0, E = E + Math.imul(ke, At) | 0, m = m + Math.imul(ke, Bt) | 0, m = m + Math.imul(Ce, At) | 0, A = A + Math.imul(Ce, Bt) | 0;
        var iM = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (iM >>> 26) | 0, iM &= 67108863, E = Math.imul(Ye, It), m = Math.imul(Ye, Je), m = m + Math.imul(Ne, It) | 0, A = Math.imul(Ne, Je), E = E + Math.imul(Oe, At) | 0, m = m + Math.imul(Oe, Bt) | 0, m = m + Math.imul(Pe, At) | 0, A = A + Math.imul(Pe, Bt) | 0;
        var nM = (_ + E | 0) + ((m & 8191) << 13) | 0;
        _ = (A + (m >>> 13) | 0) + (nM >>> 26) | 0, nM &= 67108863, E = Math.imul(Ye, At), m = Math.imul(Ye, Bt), m = m + Math.imul(Ne, At) | 0, A = Math.imul(Ne, Bt);
        var oM = (_ + E | 0) + ((m & 8191) << 13) | 0;
        return _ = (A + (m >>> 13) | 0) + (oM >>> 26) | 0, oM &= 67108863, S[0] = ui, S[1] = fi, S[2] = hi, S[3] = ci, S[4] = li, S[5] = di, S[6] = pi, S[7] = yi, S[8] = mi, S[9] = gi, S[10] = vi, S[11] = Nn, S[12] = Dn, S[13] = eM, S[14] = tM, S[15] = rM, S[16] = iM, S[17] = nM, S[18] = oM, _ !== 0 && (S[19] = _, v.length++), v;
      };
      Math.imul || (U = j);
      function H(f, y, v) {
        v.negative = y.negative ^ f.negative, v.length = f.length + y.length;
        for (var M = 0, B = 0, S = 0; S < v.length - 1; S++) {
          var _ = B;
          B = 0;
          for (var E = M & 67108863, m = Math.min(S, y.length - 1), A = Math.max(0, S - f.length + 1); A <= m; A++) {
            var $ = S - A, X = f.words[$] | 0, oe = y.words[A] | 0, J = X * oe, W = J & 67108863;
            _ = _ + (J / 67108864 | 0) | 0, W = W + E | 0, E = W & 67108863, _ = _ + (W >>> 26) | 0, B += _ >>> 26, _ &= 67108863;
          }
          v.words[S] = E, M = _, _ = B;
        }
        return M !== 0 ? v.words[S] = M : v.length--, v._strip();
      }
      function z(f, y, v) {
        return H(f, y, v);
      }
      a.prototype.mulTo = function(f, y) {
        var v, M = this.length + f.length;
        return this.length === 10 && f.length === 10 ? v = U(this, f, y) : M < 63 ? v = j(this, f, y) : M < 1024 ? v = H(this, f, y) : v = z(this, f, y), v;
      }, a.prototype.mul = function(f) {
        var y = new a(null);
        return y.words = new Array(this.length + f.length), this.mulTo(f, y);
      }, a.prototype.mulf = function(f) {
        var y = new a(null);
        return y.words = new Array(this.length + f.length), z(this, f, y);
      }, a.prototype.imul = function(f) {
        return this.clone().mulTo(f, this);
      }, a.prototype.imuln = function(f) {
        var y = f < 0;
        y && (f = -f), r(typeof f == "number"), r(f < 67108864);
        for (var v = 0, M = 0; M < this.length; M++) {
          var B = (this.words[M] | 0) * f, S = (B & 67108863) + (v & 67108863);
          v >>= 26, v += B / 67108864 | 0, v += S >>> 26, this.words[M] = S & 67108863;
        }
        return v !== 0 && (this.words[M] = v, this.length++), y ? this.ineg() : this;
      }, a.prototype.muln = function(f) {
        return this.clone().imuln(f);
      }, a.prototype.sqr = function() {
        return this.mul(this);
      }, a.prototype.isqr = function() {
        return this.imul(this.clone());
      }, a.prototype.pow = function(f) {
        var y = N(f);
        if (y.length === 0)
          return new a(1);
        for (var v = this, M = 0; M < y.length && y[M] === 0; M++, v = v.sqr())
          ;
        if (++M < y.length)
          for (var B = v.sqr(); M < y.length; M++, B = B.sqr())
            y[M] !== 0 && (v = v.mul(B));
        return v;
      }, a.prototype.iushln = function(f) {
        r(typeof f == "number" && f >= 0);
        var y = f % 26, v = (f - y) / 26, M = 67108863 >>> 26 - y << 26 - y, B;
        if (y !== 0) {
          var S = 0;
          for (B = 0; B < this.length; B++) {
            var _ = this.words[B] & M, E = (this.words[B] | 0) - _ << y;
            this.words[B] = E | S, S = _ >>> 26 - y;
          }
          S && (this.words[B] = S, this.length++);
        }
        if (v !== 0) {
          for (B = this.length - 1; B >= 0; B--)
            this.words[B + v] = this.words[B];
          for (B = 0; B < v; B++)
            this.words[B] = 0;
          this.length += v;
        }
        return this._strip();
      }, a.prototype.ishln = function(f) {
        return r(this.negative === 0), this.iushln(f);
      }, a.prototype.iushrn = function(f, y, v) {
        r(typeof f == "number" && f >= 0);
        var M;
        y ? M = (y - y % 26) / 26 : M = 0;
        var B = f % 26, S = Math.min((f - B) / 26, this.length), _ = 67108863 ^ 67108863 >>> B << B, E = v;
        if (M -= S, M = Math.max(0, M), E) {
          for (var m = 0; m < S; m++)
            E.words[m] = this.words[m];
          E.length = S;
        }
        if (S !== 0)
          if (this.length > S)
            for (this.length -= S, m = 0; m < this.length; m++)
              this.words[m] = this.words[m + S];
          else
            this.words[0] = 0, this.length = 1;
        var A = 0;
        for (m = this.length - 1; m >= 0 && (A !== 0 || m >= M); m--) {
          var $ = this.words[m] | 0;
          this.words[m] = A << 26 - B | $ >>> B, A = $ & _;
        }
        return E && A !== 0 && (E.words[E.length++] = A), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, a.prototype.ishrn = function(f, y, v) {
        return r(this.negative === 0), this.iushrn(f, y, v);
      }, a.prototype.shln = function(f) {
        return this.clone().ishln(f);
      }, a.prototype.ushln = function(f) {
        return this.clone().iushln(f);
      }, a.prototype.shrn = function(f) {
        return this.clone().ishrn(f);
      }, a.prototype.ushrn = function(f) {
        return this.clone().iushrn(f);
      }, a.prototype.testn = function(f) {
        r(typeof f == "number" && f >= 0);
        var y = f % 26, v = (f - y) / 26, M = 1 << y;
        if (this.length <= v)
          return !1;
        var B = this.words[v];
        return !!(B & M);
      }, a.prototype.imaskn = function(f) {
        r(typeof f == "number" && f >= 0);
        var y = f % 26, v = (f - y) / 26;
        if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= v)
          return this;
        if (y !== 0 && v++, this.length = Math.min(v, this.length), y !== 0) {
          var M = 67108863 ^ 67108863 >>> y << y;
          this.words[this.length - 1] &= M;
        }
        return this._strip();
      }, a.prototype.maskn = function(f) {
        return this.clone().imaskn(f);
      }, a.prototype.iaddn = function(f) {
        return r(typeof f == "number"), r(f < 67108864), f < 0 ? this.isubn(-f) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f ? (this.words[0] = f - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f), this.negative = 1, this) : this._iaddn(f);
      }, a.prototype._iaddn = function(f) {
        this.words[0] += f;
        for (var y = 0; y < this.length && this.words[y] >= 67108864; y++)
          this.words[y] -= 67108864, y === this.length - 1 ? this.words[y + 1] = 1 : this.words[y + 1]++;
        return this.length = Math.max(this.length, y + 1), this;
      }, a.prototype.isubn = function(f) {
        if (r(typeof f == "number"), r(f < 67108864), f < 0)
          return this.iaddn(-f);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(f), this.negative = 1, this;
        if (this.words[0] -= f, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var y = 0; y < this.length && this.words[y] < 0; y++)
            this.words[y] += 67108864, this.words[y + 1] -= 1;
        return this._strip();
      }, a.prototype.addn = function(f) {
        return this.clone().iaddn(f);
      }, a.prototype.subn = function(f) {
        return this.clone().isubn(f);
      }, a.prototype.iabs = function() {
        return this.negative = 0, this;
      }, a.prototype.abs = function() {
        return this.clone().iabs();
      }, a.prototype._ishlnsubmul = function(f, y, v) {
        var M = f.length + v, B;
        this._expand(M);
        var S, _ = 0;
        for (B = 0; B < f.length; B++) {
          S = (this.words[B + v] | 0) + _;
          var E = (f.words[B] | 0) * y;
          S -= E & 67108863, _ = (S >> 26) - (E / 67108864 | 0), this.words[B + v] = S & 67108863;
        }
        for (; B < this.length - v; B++)
          S = (this.words[B + v] | 0) + _, _ = S >> 26, this.words[B + v] = S & 67108863;
        if (_ === 0)
          return this._strip();
        for (r(_ === -1), _ = 0, B = 0; B < this.length; B++)
          S = -(this.words[B] | 0) + _, _ = S >> 26, this.words[B] = S & 67108863;
        return this.negative = 1, this._strip();
      }, a.prototype._wordDiv = function(f, y) {
        var v = this.length - f.length, M = this.clone(), B = f, S = B.words[B.length - 1] | 0, _ = this._countBits(S);
        v = 26 - _, v !== 0 && (B = B.ushln(v), M.iushln(v), S = B.words[B.length - 1] | 0);
        var E = M.length - B.length, m;
        if (y !== "mod") {
          m = new a(null), m.length = E + 1, m.words = new Array(m.length);
          for (var A = 0; A < m.length; A++)
            m.words[A] = 0;
        }
        var $ = M.clone()._ishlnsubmul(B, 1, E);
        $.negative === 0 && (M = $, m && (m.words[E] = 1));
        for (var X = E - 1; X >= 0; X--) {
          var oe = (M.words[B.length + X] | 0) * 67108864 + (M.words[B.length + X - 1] | 0);
          for (oe = Math.min(oe / S | 0, 67108863), M._ishlnsubmul(B, oe, X); M.negative !== 0; )
            oe--, M.negative = 0, M._ishlnsubmul(B, 1, X), M.isZero() || (M.negative ^= 1);
          m && (m.words[X] = oe);
        }
        return m && m._strip(), M._strip(), y !== "div" && v !== 0 && M.iushrn(v), {
          div: m || null,
          mod: M
        };
      }, a.prototype.divmod = function(f, y, v) {
        if (r(!f.isZero()), this.isZero())
          return {
            div: new a(0),
            mod: new a(0)
          };
        var M, B, S;
        return this.negative !== 0 && f.negative === 0 ? (S = this.neg().divmod(f, y), y !== "mod" && (M = S.div.neg()), y !== "div" && (B = S.mod.neg(), v && B.negative !== 0 && B.iadd(f)), {
          div: M,
          mod: B
        }) : this.negative === 0 && f.negative !== 0 ? (S = this.divmod(f.neg(), y), y !== "mod" && (M = S.div.neg()), {
          div: M,
          mod: S.mod
        }) : this.negative & f.negative ? (S = this.neg().divmod(f.neg(), y), y !== "div" && (B = S.mod.neg(), v && B.negative !== 0 && B.isub(f)), {
          div: S.div,
          mod: B
        }) : f.length > this.length || this.cmp(f) < 0 ? {
          div: new a(0),
          mod: this
        } : f.length === 1 ? y === "div" ? {
          div: this.divn(f.words[0]),
          mod: null
        } : y === "mod" ? {
          div: null,
          mod: new a(this.modrn(f.words[0]))
        } : {
          div: this.divn(f.words[0]),
          mod: new a(this.modrn(f.words[0]))
        } : this._wordDiv(f, y);
      }, a.prototype.div = function(f) {
        return this.divmod(f, "div", !1).div;
      }, a.prototype.mod = function(f) {
        return this.divmod(f, "mod", !1).mod;
      }, a.prototype.umod = function(f) {
        return this.divmod(f, "mod", !0).mod;
      }, a.prototype.divRound = function(f) {
        var y = this.divmod(f);
        if (y.mod.isZero())
          return y.div;
        var v = y.div.negative !== 0 ? y.mod.isub(f) : y.mod, M = f.ushrn(1), B = f.andln(1), S = v.cmp(M);
        return S < 0 || B === 1 && S === 0 ? y.div : y.div.negative !== 0 ? y.div.isubn(1) : y.div.iaddn(1);
      }, a.prototype.modrn = function(f) {
        var y = f < 0;
        y && (f = -f), r(f <= 67108863);
        for (var v = (1 << 26) % f, M = 0, B = this.length - 1; B >= 0; B--)
          M = (v * M + (this.words[B] | 0)) % f;
        return y ? -M : M;
      }, a.prototype.modn = function(f) {
        return this.modrn(f);
      }, a.prototype.idivn = function(f) {
        var y = f < 0;
        y && (f = -f), r(f <= 67108863);
        for (var v = 0, M = this.length - 1; M >= 0; M--) {
          var B = (this.words[M] | 0) + v * 67108864;
          this.words[M] = B / f | 0, v = B % f;
        }
        return this._strip(), y ? this.ineg() : this;
      }, a.prototype.divn = function(f) {
        return this.clone().idivn(f);
      }, a.prototype.egcd = function(f) {
        r(f.negative === 0), r(!f.isZero());
        var y = this, v = f.clone();
        y.negative !== 0 ? y = y.umod(f) : y = y.clone();
        for (var M = new a(1), B = new a(0), S = new a(0), _ = new a(1), E = 0; y.isEven() && v.isEven(); )
          y.iushrn(1), v.iushrn(1), ++E;
        for (var m = v.clone(), A = y.clone(); !y.isZero(); ) {
          for (var $ = 0, X = 1; !(y.words[0] & X) && $ < 26; ++$, X <<= 1)
            ;
          if ($ > 0)
            for (y.iushrn($); $-- > 0; )
              (M.isOdd() || B.isOdd()) && (M.iadd(m), B.isub(A)), M.iushrn(1), B.iushrn(1);
          for (var oe = 0, J = 1; !(v.words[0] & J) && oe < 26; ++oe, J <<= 1)
            ;
          if (oe > 0)
            for (v.iushrn(oe); oe-- > 0; )
              (S.isOdd() || _.isOdd()) && (S.iadd(m), _.isub(A)), S.iushrn(1), _.iushrn(1);
          y.cmp(v) >= 0 ? (y.isub(v), M.isub(S), B.isub(_)) : (v.isub(y), S.isub(M), _.isub(B));
        }
        return {
          a: S,
          b: _,
          gcd: v.iushln(E)
        };
      }, a.prototype._invmp = function(f) {
        r(f.negative === 0), r(!f.isZero());
        var y = this, v = f.clone();
        y.negative !== 0 ? y = y.umod(f) : y = y.clone();
        for (var M = new a(1), B = new a(0), S = v.clone(); y.cmpn(1) > 0 && v.cmpn(1) > 0; ) {
          for (var _ = 0, E = 1; !(y.words[0] & E) && _ < 26; ++_, E <<= 1)
            ;
          if (_ > 0)
            for (y.iushrn(_); _-- > 0; )
              M.isOdd() && M.iadd(S), M.iushrn(1);
          for (var m = 0, A = 1; !(v.words[0] & A) && m < 26; ++m, A <<= 1)
            ;
          if (m > 0)
            for (v.iushrn(m); m-- > 0; )
              B.isOdd() && B.iadd(S), B.iushrn(1);
          y.cmp(v) >= 0 ? (y.isub(v), M.isub(B)) : (v.isub(y), B.isub(M));
        }
        var $;
        return y.cmpn(1) === 0 ? $ = M : $ = B, $.cmpn(0) < 0 && $.iadd(f), $;
      }, a.prototype.gcd = function(f) {
        if (this.isZero())
          return f.abs();
        if (f.isZero())
          return this.abs();
        var y = this.clone(), v = f.clone();
        y.negative = 0, v.negative = 0;
        for (var M = 0; y.isEven() && v.isEven(); M++)
          y.iushrn(1), v.iushrn(1);
        do {
          for (; y.isEven(); )
            y.iushrn(1);
          for (; v.isEven(); )
            v.iushrn(1);
          var B = y.cmp(v);
          if (B < 0) {
            var S = y;
            y = v, v = S;
          } else if (B === 0 || v.cmpn(1) === 0)
            break;
          y.isub(v);
        } while (!0);
        return v.iushln(M);
      }, a.prototype.invm = function(f) {
        return this.egcd(f).a.umod(f);
      }, a.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, a.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, a.prototype.andln = function(f) {
        return this.words[0] & f;
      }, a.prototype.bincn = function(f) {
        r(typeof f == "number");
        var y = f % 26, v = (f - y) / 26, M = 1 << y;
        if (this.length <= v)
          return this._expand(v + 1), this.words[v] |= M, this;
        for (var B = M, S = v; B !== 0 && S < this.length; S++) {
          var _ = this.words[S] | 0;
          _ += B, B = _ >>> 26, _ &= 67108863, this.words[S] = _;
        }
        return B !== 0 && (this.words[S] = B, this.length++), this;
      }, a.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, a.prototype.cmpn = function(f) {
        var y = f < 0;
        if (this.negative !== 0 && !y)
          return -1;
        if (this.negative === 0 && y)
          return 1;
        this._strip();
        var v;
        if (this.length > 1)
          v = 1;
        else {
          y && (f = -f), r(f <= 67108863, "Number is too big");
          var M = this.words[0] | 0;
          v = M === f ? 0 : M < f ? -1 : 1;
        }
        return this.negative !== 0 ? -v | 0 : v;
      }, a.prototype.cmp = function(f) {
        if (this.negative !== 0 && f.negative === 0)
          return -1;
        if (this.negative === 0 && f.negative !== 0)
          return 1;
        var y = this.ucmp(f);
        return this.negative !== 0 ? -y | 0 : y;
      }, a.prototype.ucmp = function(f) {
        if (this.length > f.length)
          return 1;
        if (this.length < f.length)
          return -1;
        for (var y = 0, v = this.length - 1; v >= 0; v--) {
          var M = this.words[v] | 0, B = f.words[v] | 0;
          if (M !== B) {
            M < B ? y = -1 : M > B && (y = 1);
            break;
          }
        }
        return y;
      }, a.prototype.gtn = function(f) {
        return this.cmpn(f) === 1;
      }, a.prototype.gt = function(f) {
        return this.cmp(f) === 1;
      }, a.prototype.gten = function(f) {
        return this.cmpn(f) >= 0;
      }, a.prototype.gte = function(f) {
        return this.cmp(f) >= 0;
      }, a.prototype.ltn = function(f) {
        return this.cmpn(f) === -1;
      }, a.prototype.lt = function(f) {
        return this.cmp(f) === -1;
      }, a.prototype.lten = function(f) {
        return this.cmpn(f) <= 0;
      }, a.prototype.lte = function(f) {
        return this.cmp(f) <= 0;
      }, a.prototype.eqn = function(f) {
        return this.cmpn(f) === 0;
      }, a.prototype.eq = function(f) {
        return this.cmp(f) === 0;
      }, a.red = function(f) {
        return new I(f);
      }, a.prototype.toRed = function(f) {
        return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), f.convertTo(this)._forceRed(f);
      }, a.prototype.fromRed = function() {
        return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, a.prototype._forceRed = function(f) {
        return this.red = f, this;
      }, a.prototype.forceRed = function(f) {
        return r(!this.red, "Already a number in reduction context"), this._forceRed(f);
      }, a.prototype.redAdd = function(f) {
        return r(this.red, "redAdd works only with red numbers"), this.red.add(this, f);
      }, a.prototype.redIAdd = function(f) {
        return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f);
      }, a.prototype.redSub = function(f) {
        return r(this.red, "redSub works only with red numbers"), this.red.sub(this, f);
      }, a.prototype.redISub = function(f) {
        return r(this.red, "redISub works only with red numbers"), this.red.isub(this, f);
      }, a.prototype.redShl = function(f) {
        return r(this.red, "redShl works only with red numbers"), this.red.shl(this, f);
      }, a.prototype.redMul = function(f) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.mul(this, f);
      }, a.prototype.redIMul = function(f) {
        return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.imul(this, f);
      }, a.prototype.redSqr = function() {
        return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, a.prototype.redISqr = function() {
        return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, a.prototype.redSqrt = function() {
        return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, a.prototype.redInvm = function() {
        return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, a.prototype.redNeg = function() {
        return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, a.prototype.redPow = function(f) {
        return r(this.red && !f.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f);
      };
      var ee = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function ne(f, y) {
        this.name = f, this.p = new a(y, 16), this.n = this.p.bitLength(), this.k = new a(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ne.prototype._tmp = function() {
        var f = new a(null);
        return f.words = new Array(Math.ceil(this.n / 13)), f;
      }, ne.prototype.ireduce = function(f) {
        var y = f, v;
        do
          this.split(y, this.tmp), y = this.imulK(y), y = y.iadd(this.tmp), v = y.bitLength();
        while (v > this.n);
        var M = v < this.n ? -1 : y.ucmp(this.p);
        return M === 0 ? (y.words[0] = 0, y.length = 1) : M > 0 ? y.isub(this.p) : y.strip !== void 0 ? y.strip() : y._strip(), y;
      }, ne.prototype.split = function(f, y) {
        f.iushrn(this.n, 0, y);
      }, ne.prototype.imulK = function(f) {
        return f.imul(this.k);
      };
      function le() {
        ne.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      h(le, ne), le.prototype.split = function(f, y) {
        for (var v = 4194303, M = Math.min(f.length, 9), B = 0; B < M; B++)
          y.words[B] = f.words[B];
        if (y.length = M, f.length <= 9) {
          f.words[0] = 0, f.length = 1;
          return;
        }
        var S = f.words[9];
        for (y.words[y.length++] = S & v, B = 10; B < f.length; B++) {
          var _ = f.words[B] | 0;
          f.words[B - 10] = (_ & v) << 4 | S >>> 22, S = _;
        }
        S >>>= 22, f.words[B - 10] = S, S === 0 && f.length > 10 ? f.length -= 10 : f.length -= 9;
      }, le.prototype.imulK = function(f) {
        f.words[f.length] = 0, f.words[f.length + 1] = 0, f.length += 2;
        for (var y = 0, v = 0; v < f.length; v++) {
          var M = f.words[v] | 0;
          y += M * 977, f.words[v] = y & 67108863, y = M * 64 + (y / 67108864 | 0);
        }
        return f.words[f.length - 1] === 0 && (f.length--, f.words[f.length - 1] === 0 && f.length--), f;
      };
      function Z() {
        ne.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      h(Z, ne);
      function ie() {
        ne.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      h(ie, ne);
      function fe() {
        ne.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      h(fe, ne), fe.prototype.imulK = function(f) {
        for (var y = 0, v = 0; v < f.length; v++) {
          var M = (f.words[v] | 0) * 19 + y, B = M & 67108863;
          M >>>= 26, f.words[v] = B, y = M;
        }
        return y !== 0 && (f.words[f.length++] = y), f;
      }, a._prime = function(f) {
        if (ee[f])
          return ee[f];
        var y;
        if (f === "k256")
          y = new le();
        else if (f === "p224")
          y = new Z();
        else if (f === "p192")
          y = new ie();
        else if (f === "p25519")
          y = new fe();
        else
          throw new Error("Unknown prime " + f);
        return ee[f] = y, y;
      };
      function I(f) {
        if (typeof f == "string") {
          var y = a._prime(f);
          this.m = y.p, this.prime = y;
        } else
          r(f.gtn(1), "modulus must be greater than 1"), this.m = f, this.prime = null;
      }
      I.prototype._verify1 = function(f) {
        r(f.negative === 0, "red works only with positives"), r(f.red, "red works only with red numbers");
      }, I.prototype._verify2 = function(f, y) {
        r((f.negative | y.negative) === 0, "red works only with positives"), r(
          f.red && f.red === y.red,
          "red works only with red numbers"
        );
      }, I.prototype.imod = function(f) {
        return this.prime ? this.prime.ireduce(f)._forceRed(this) : (w(f, f.umod(this.m)._forceRed(this)), f);
      }, I.prototype.neg = function(f) {
        return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this);
      }, I.prototype.add = function(f, y) {
        this._verify2(f, y);
        var v = f.add(y);
        return v.cmp(this.m) >= 0 && v.isub(this.m), v._forceRed(this);
      }, I.prototype.iadd = function(f, y) {
        this._verify2(f, y);
        var v = f.iadd(y);
        return v.cmp(this.m) >= 0 && v.isub(this.m), v;
      }, I.prototype.sub = function(f, y) {
        this._verify2(f, y);
        var v = f.sub(y);
        return v.cmpn(0) < 0 && v.iadd(this.m), v._forceRed(this);
      }, I.prototype.isub = function(f, y) {
        this._verify2(f, y);
        var v = f.isub(y);
        return v.cmpn(0) < 0 && v.iadd(this.m), v;
      }, I.prototype.shl = function(f, y) {
        return this._verify1(f), this.imod(f.ushln(y));
      }, I.prototype.imul = function(f, y) {
        return this._verify2(f, y), this.imod(f.imul(y));
      }, I.prototype.mul = function(f, y) {
        return this._verify2(f, y), this.imod(f.mul(y));
      }, I.prototype.isqr = function(f) {
        return this.imul(f, f.clone());
      }, I.prototype.sqr = function(f) {
        return this.mul(f, f);
      }, I.prototype.sqrt = function(f) {
        if (f.isZero())
          return f.clone();
        var y = this.m.andln(3);
        if (r(y % 2 === 1), y === 3) {
          var v = this.m.add(new a(1)).iushrn(2);
          return this.pow(f, v);
        }
        for (var M = this.m.subn(1), B = 0; !M.isZero() && M.andln(1) === 0; )
          B++, M.iushrn(1);
        r(!M.isZero());
        var S = new a(1).toRed(this), _ = S.redNeg(), E = this.m.subn(1).iushrn(1), m = this.m.bitLength();
        for (m = new a(2 * m * m).toRed(this); this.pow(m, E).cmp(_) !== 0; )
          m.redIAdd(_);
        for (var A = this.pow(m, M), $ = this.pow(f, M.addn(1).iushrn(1)), X = this.pow(f, M), oe = B; X.cmp(S) !== 0; ) {
          for (var J = X, W = 0; J.cmp(S) !== 0; W++)
            J = J.redSqr();
          r(W < oe);
          var Q = this.pow(A, new a(1).iushln(oe - W - 1));
          $ = $.redMul(Q), A = Q.redSqr(), X = X.redMul(A), oe = W;
        }
        return $;
      }, I.prototype.invm = function(f) {
        var y = f._invmp(this.m);
        return y.negative !== 0 ? (y.negative = 0, this.imod(y).redNeg()) : this.imod(y);
      }, I.prototype.pow = function(f, y) {
        if (y.isZero())
          return new a(1).toRed(this);
        if (y.cmpn(1) === 0)
          return f.clone();
        var v = 4, M = new Array(1 << v);
        M[0] = new a(1).toRed(this), M[1] = f;
        for (var B = 2; B < M.length; B++)
          M[B] = this.mul(M[B - 1], f);
        var S = M[0], _ = 0, E = 0, m = y.bitLength() % 26;
        for (m === 0 && (m = 26), B = y.length - 1; B >= 0; B--) {
          for (var A = y.words[B], $ = m - 1; $ >= 0; $--) {
            var X = A >> $ & 1;
            if (S !== M[0] && (S = this.sqr(S)), X === 0 && _ === 0) {
              E = 0;
              continue;
            }
            _ <<= 1, _ |= X, E++, !(E !== v && (B !== 0 || $ !== 0)) && (S = this.mul(S, M[_]), E = 0, _ = 0);
          }
          m = 26;
        }
        return S;
      }, I.prototype.convertTo = function(f) {
        var y = f.umod(this.m);
        return y === f ? y.clone() : y;
      }, I.prototype.convertFrom = function(f) {
        var y = f.clone();
        return y.red = null, y;
      }, a.mont = function(f) {
        return new P(f);
      };
      function P(f) {
        I.call(this, f), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new a(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      h(P, I), P.prototype.convertTo = function(f) {
        return this.imod(f.ushln(this.shift));
      }, P.prototype.convertFrom = function(f) {
        var y = this.imod(f.mul(this.rinv));
        return y.red = null, y;
      }, P.prototype.imul = function(f, y) {
        if (f.isZero() || y.isZero())
          return f.words[0] = 0, f.length = 1, f;
        var v = f.imul(y), M = v.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), B = v.isub(M).iushrn(this.shift), S = B;
        return B.cmp(this.m) >= 0 ? S = B.isub(this.m) : B.cmpn(0) < 0 && (S = B.iadd(this.m)), S._forceRed(this);
      }, P.prototype.mul = function(f, y) {
        if (f.isZero() || y.isZero())
          return new a(0)._forceRed(this);
        var v = f.mul(y), M = v.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), B = v.isub(M).iushrn(this.shift), S = B;
        return B.cmp(this.m) >= 0 ? S = B.isub(this.m) : B.cmpn(0) < 0 && (S = B.iadd(this.m)), S._forceRed(this);
      }, P.prototype.invm = function(f) {
        var y = this.imod(f._invmp(this.m).mul(this.r2));
        return y._forceRed(this);
      };
    })(e, commonjsGlobal);
  }(bn$3)), bn$3.exports;
}
var asn1$1 = {}, asn1 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(e, t) {
      if (e.indexOf)
        return e.indexOf(t);
      for (var o = 0; o < e.length; o++)
        if (e[o] === t)
          return o;
      return -1;
    }, Object_keys = function(e) {
      if (Object.keys)
        return Object.keys(e);
      var t = [];
      for (var o in e)
        t.push(o);
      return t;
    }, forEach = function(e, t) {
      if (e.forEach)
        return e.forEach(t);
      for (var o = 0; o < e.length; o++)
        t(e[o], o, e);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(e, t, o) {
          Object.defineProperty(e, t, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: o
          });
        };
      } catch {
        return function(e, t, o) {
          e[t] = o;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(e) {
      if (!(this instanceof Script))
        return new Script(e);
      this.code = e;
    };
    Script.prototype.runInContext = function(e) {
      if (!(e instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var t = document.createElement("iframe");
      t.style || (t.style = {}), t.style.display = "none", document.body.appendChild(t);
      var o = t.contentWindow, r = o.eval, h = o.execScript;
      !r && h && (h.call(o, "null"), r = o.eval), forEach(Object_keys(e), function(d) {
        o[d] = e[d];
      }), forEach(globals, function(d) {
        e[d] && (o[d] = e[d]);
      });
      var a = Object_keys(o), p = r.call(o, this.code);
      return forEach(Object_keys(o), function(d) {
        (d in e || indexOf(a, d) === -1) && (e[d] = o[d]);
      }), forEach(globals, function(d) {
        d in e || defineProp(e, d, o[d]);
      }), document.body.removeChild(t), p;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(e) {
      var t = Script.createContext(e), o = this.runInContext(t);
      return e && forEach(Object_keys(t), function(r) {
        e[r] = t[r];
      }), o;
    }, forEach(Object_keys(Script.prototype), function(e) {
      exports[e] = Script[e] = function(t) {
        var o = Script(t);
        return o[e].apply(o, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(e) {
      return e instanceof Context;
    }, exports.createScript = function(e) {
      return exports.Script(e);
    }, exports.createContext = Script.createContext = function(e) {
      var t = new Context();
      return typeof e == "object" && forEach(Object_keys(e), function(o) {
        t[o] = e[o];
      }), t;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(e) {
    var t = requireAsn1$1(), o = requireInherits_browser(), r = e;
    r.define = function(a, p) {
      return new h(a, p);
    };
    function h(a, p) {
      this.name = a, this.body = p, this.decoders = {}, this.encoders = {};
    }
    h.prototype._createNamed = function(a) {
      var p;
      try {
        p = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        p = function(d) {
          this._initNamed(d);
        };
      }
      return o(p, a), p.prototype._initNamed = function(d) {
        a.call(this, d);
      }, new p(this);
    }, h.prototype._getDecoder = function(a) {
      return a = a || "der", this.decoders.hasOwnProperty(a) || (this.decoders[a] = this._createNamed(t.decoders[a])), this.decoders[a];
    }, h.prototype.decode = function(a, p, d) {
      return this._getDecoder(p).decode(a, d);
    }, h.prototype._getEncoder = function(a) {
      return a = a || "der", this.encoders.hasOwnProperty(a) || (this.encoders[a] = this._createNamed(t.encoders[a])), this.encoders[a];
    }, h.prototype.encode = function(a, p, d) {
      return this._getEncoder(p).encode(a, d);
    };
  }(api)), api;
}
var base = {}, reporter = {}, hasRequiredReporter;
function requireReporter() {
  if (hasRequiredReporter)
    return reporter;
  hasRequiredReporter = 1;
  var e = requireInherits_browser();
  function t(r) {
    this._reporterState = {
      obj: null,
      path: [],
      options: r || {},
      errors: []
    };
  }
  reporter.Reporter = t, t.prototype.isError = function(r) {
    return r instanceof o;
  }, t.prototype.save = function() {
    var r = this._reporterState;
    return { obj: r.obj, pathLen: r.path.length };
  }, t.prototype.restore = function(r) {
    var h = this._reporterState;
    h.obj = r.obj, h.path = h.path.slice(0, r.pathLen);
  }, t.prototype.enterKey = function(r) {
    return this._reporterState.path.push(r);
  }, t.prototype.exitKey = function(r) {
    var h = this._reporterState;
    h.path = h.path.slice(0, r - 1);
  }, t.prototype.leaveKey = function(r, h, a) {
    var p = this._reporterState;
    this.exitKey(r), p.obj !== null && (p.obj[h] = a);
  }, t.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, t.prototype.enterObject = function() {
    var r = this._reporterState, h = r.obj;
    return r.obj = {}, h;
  }, t.prototype.leaveObject = function(r) {
    var h = this._reporterState, a = h.obj;
    return h.obj = r, a;
  }, t.prototype.error = function(r) {
    var h, a = this._reporterState, p = r instanceof o;
    if (p ? h = r : h = new o(a.path.map(function(d) {
      return "[" + JSON.stringify(d) + "]";
    }).join(""), r.message || r, r.stack), !a.options.partial)
      throw h;
    return p || a.errors.push(h), h;
  }, t.prototype.wrapResult = function(r) {
    var h = this._reporterState;
    return h.options.partial ? {
      result: this.isError(r) ? null : r,
      errors: h.errors
    } : r;
  };
  function o(r, h) {
    this.path = r, this.rethrow(h);
  }
  return e(o, Error), o.prototype.rethrow = function(r) {
    if (this.message = r + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, o), !this.stack)
      try {
        throw new Error(this.message);
      } catch (h) {
        this.stack = h.stack;
      }
    return this;
  }, reporter;
}
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer)
    return buffer;
  hasRequiredBuffer = 1;
  var e = requireInherits_browser(), t = requireBase().Reporter, o = requireBuffer$1().Buffer;
  function r(a, p) {
    if (t.call(this, p), !o.isBuffer(a)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = a, this.offset = 0, this.length = a.length;
  }
  e(r, t), buffer.DecoderBuffer = r, r.prototype.save = function() {
    return { offset: this.offset, reporter: t.prototype.save.call(this) };
  }, r.prototype.restore = function(a) {
    var p = new r(this.base);
    return p.offset = a.offset, p.length = this.offset, this.offset = a.offset, t.prototype.restore.call(this, a.reporter), p;
  }, r.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, r.prototype.readUInt8 = function(a) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(a || "DecoderBuffer overrun");
  }, r.prototype.skip = function(a, p) {
    if (!(this.offset + a <= this.length))
      return this.error(p || "DecoderBuffer overrun");
    var d = new r(this.base);
    return d._reporterState = this._reporterState, d.offset = this.offset, d.length = this.offset + a, this.offset += a, d;
  }, r.prototype.raw = function(a) {
    return this.base.slice(a ? a.offset : this.offset, this.length);
  };
  function h(a, p) {
    if (Array.isArray(a))
      this.length = 0, this.value = a.map(function(d) {
        return d instanceof h || (d = new h(d, p)), this.length += d.length, d;
      }, this);
    else if (typeof a == "number") {
      if (!(0 <= a && a <= 255))
        return p.error("non-byte EncoderBuffer value");
      this.value = a, this.length = 1;
    } else if (typeof a == "string")
      this.value = a, this.length = o.byteLength(a);
    else if (o.isBuffer(a))
      this.value = a, this.length = a.length;
    else
      return p.error("Unsupported type: " + typeof a);
  }
  return buffer.EncoderBuffer = h, h.prototype.join = function(a, p) {
    return a || (a = new o(this.length)), p || (p = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(d) {
      d.join(a, p), p += d.length;
    }) : (typeof this.value == "number" ? a[p] = this.value : typeof this.value == "string" ? a.write(this.value, p) : o.isBuffer(this.value) && this.value.copy(a, p), p += this.length)), a;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode)
    return node;
  hasRequiredNode = 1;
  var e = requireBase().Reporter, t = requireBase().EncoderBuffer, o = requireBase().DecoderBuffer, r = requireMinimalisticAssert(), h = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], a = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(h), p = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function d(g, w) {
    var C = {};
    this._baseState = C, C.enc = g, C.parent = w || null, C.children = null, C.tag = null, C.args = null, C.reverseArgs = null, C.choice = null, C.optional = !1, C.any = !1, C.obj = !1, C.use = null, C.useDecoder = null, C.key = null, C.default = null, C.explicit = null, C.implicit = null, C.contains = null, C.parent || (C.children = [], this._wrap());
  }
  node = d;
  var b = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return d.prototype.clone = function() {
    var g = this._baseState, w = {};
    b.forEach(function(T) {
      w[T] = g[T];
    });
    var C = new this.constructor(w.parent);
    return C._baseState = w, C;
  }, d.prototype._wrap = function() {
    var g = this._baseState;
    a.forEach(function(w) {
      this[w] = function() {
        var C = new this.constructor(this);
        return g.children.push(C), C[w].apply(C, arguments);
      };
    }, this);
  }, d.prototype._init = function(g) {
    var w = this._baseState;
    r(w.parent === null), g.call(this), w.children = w.children.filter(function(C) {
      return C._baseState.parent === this;
    }, this), r.equal(w.children.length, 1, "Root node can have only one child");
  }, d.prototype._useArgs = function(g) {
    var w = this._baseState, C = g.filter(function(T) {
      return T instanceof this.constructor;
    }, this);
    g = g.filter(function(T) {
      return !(T instanceof this.constructor);
    }, this), C.length !== 0 && (r(w.children === null), w.children = C, C.forEach(function(T) {
      T._baseState.parent = this;
    }, this)), g.length !== 0 && (r(w.args === null), w.args = g, w.reverseArgs = g.map(function(T) {
      if (typeof T != "object" || T.constructor !== Object)
        return T;
      var k = {};
      return Object.keys(T).forEach(function(q) {
        q == (q | 0) && (q |= 0);
        var O = T[q];
        k[O] = q;
      }), k;
    }));
  }, p.forEach(function(g) {
    d.prototype[g] = function() {
      var w = this._baseState;
      throw new Error(g + " not implemented for encoding: " + w.enc);
    };
  }), h.forEach(function(g) {
    d.prototype[g] = function() {
      var w = this._baseState, C = Array.prototype.slice.call(arguments);
      return r(w.tag === null), w.tag = g, this._useArgs(C), this;
    };
  }), d.prototype.use = function(g) {
    r(g);
    var w = this._baseState;
    return r(w.use === null), w.use = g, this;
  }, d.prototype.optional = function() {
    var g = this._baseState;
    return g.optional = !0, this;
  }, d.prototype.def = function(g) {
    var w = this._baseState;
    return r(w.default === null), w.default = g, w.optional = !0, this;
  }, d.prototype.explicit = function(g) {
    var w = this._baseState;
    return r(w.explicit === null && w.implicit === null), w.explicit = g, this;
  }, d.prototype.implicit = function(g) {
    var w = this._baseState;
    return r(w.explicit === null && w.implicit === null), w.implicit = g, this;
  }, d.prototype.obj = function() {
    var g = this._baseState, w = Array.prototype.slice.call(arguments);
    return g.obj = !0, w.length !== 0 && this._useArgs(w), this;
  }, d.prototype.key = function(g) {
    var w = this._baseState;
    return r(w.key === null), w.key = g, this;
  }, d.prototype.any = function() {
    var g = this._baseState;
    return g.any = !0, this;
  }, d.prototype.choice = function(g) {
    var w = this._baseState;
    return r(w.choice === null), w.choice = g, this._useArgs(Object.keys(g).map(function(C) {
      return g[C];
    })), this;
  }, d.prototype.contains = function(g) {
    var w = this._baseState;
    return r(w.use === null), w.contains = g, this;
  }, d.prototype._decode = function(g, w) {
    var C = this._baseState;
    if (C.parent === null)
      return g.wrapResult(C.children[0]._decode(g, w));
    var T = C.default, k = !0, q = null;
    if (C.key !== null && (q = g.enterKey(C.key)), C.optional) {
      var O = null;
      if (C.explicit !== null ? O = C.explicit : C.implicit !== null ? O = C.implicit : C.tag !== null && (O = C.tag), O === null && !C.any) {
        var N = g.save();
        try {
          C.choice === null ? this._decodeGeneric(C.tag, g, w) : this._decodeChoice(g, w), k = !0;
        } catch {
          k = !1;
        }
        g.restore(N);
      } else if (k = this._peekTag(g, O, C.any), g.isError(k))
        return k;
    }
    var j;
    if (C.obj && k && (j = g.enterObject()), k) {
      if (C.explicit !== null) {
        var U = this._decodeTag(g, C.explicit);
        if (g.isError(U))
          return U;
        g = U;
      }
      var H = g.offset;
      if (C.use === null && C.choice === null) {
        if (C.any)
          var N = g.save();
        var z = this._decodeTag(
          g,
          C.implicit !== null ? C.implicit : C.tag,
          C.any
        );
        if (g.isError(z))
          return z;
        C.any ? T = g.raw(N) : g = z;
      }
      if (w && w.track && C.tag !== null && w.track(g.path(), H, g.length, "tagged"), w && w.track && C.tag !== null && w.track(g.path(), g.offset, g.length, "content"), C.any ? T = T : C.choice === null ? T = this._decodeGeneric(C.tag, g, w) : T = this._decodeChoice(g, w), g.isError(T))
        return T;
      if (!C.any && C.choice === null && C.children !== null && C.children.forEach(function(ne) {
        ne._decode(g, w);
      }), C.contains && (C.tag === "octstr" || C.tag === "bitstr")) {
        var ee = new o(T);
        T = this._getUse(C.contains, g._reporterState.obj)._decode(ee, w);
      }
    }
    return C.obj && k && (T = g.leaveObject(j)), C.key !== null && (T !== null || k === !0) ? g.leaveKey(q, C.key, T) : q !== null && g.exitKey(q), T;
  }, d.prototype._decodeGeneric = function(g, w, C) {
    var T = this._baseState;
    return g === "seq" || g === "set" ? null : g === "seqof" || g === "setof" ? this._decodeList(w, g, T.args[0], C) : /str$/.test(g) ? this._decodeStr(w, g, C) : g === "objid" && T.args ? this._decodeObjid(w, T.args[0], T.args[1], C) : g === "objid" ? this._decodeObjid(w, null, null, C) : g === "gentime" || g === "utctime" ? this._decodeTime(w, g, C) : g === "null_" ? this._decodeNull(w, C) : g === "bool" ? this._decodeBool(w, C) : g === "objDesc" ? this._decodeStr(w, g, C) : g === "int" || g === "enum" ? this._decodeInt(w, T.args && T.args[0], C) : T.use !== null ? this._getUse(T.use, w._reporterState.obj)._decode(w, C) : w.error("unknown tag: " + g);
  }, d.prototype._getUse = function(g, w) {
    var C = this._baseState;
    return C.useDecoder = this._use(g, w), r(C.useDecoder._baseState.parent === null), C.useDecoder = C.useDecoder._baseState.children[0], C.implicit !== C.useDecoder._baseState.implicit && (C.useDecoder = C.useDecoder.clone(), C.useDecoder._baseState.implicit = C.implicit), C.useDecoder;
  }, d.prototype._decodeChoice = function(g, w) {
    var C = this._baseState, T = null, k = !1;
    return Object.keys(C.choice).some(function(q) {
      var O = g.save(), N = C.choice[q];
      try {
        var j = N._decode(g, w);
        if (g.isError(j))
          return !1;
        T = { type: q, value: j }, k = !0;
      } catch {
        return g.restore(O), !1;
      }
      return !0;
    }, this), k ? T : g.error("Choice not matched");
  }, d.prototype._createEncoderBuffer = function(g) {
    return new t(g, this.reporter);
  }, d.prototype._encode = function(g, w, C) {
    var T = this._baseState;
    if (!(T.default !== null && T.default === g)) {
      var k = this._encodeValue(g, w, C);
      if (k !== void 0 && !this._skipDefault(k, w, C))
        return k;
    }
  }, d.prototype._encodeValue = function(g, w, C) {
    var T = this._baseState;
    if (T.parent === null)
      return T.children[0]._encode(g, w || new e());
    var N = null;
    if (this.reporter = w, T.optional && g === void 0)
      if (T.default !== null)
        g = T.default;
      else
        return;
    var k = null, q = !1;
    if (T.any)
      N = this._createEncoderBuffer(g);
    else if (T.choice)
      N = this._encodeChoice(g, w);
    else if (T.contains)
      k = this._getUse(T.contains, C)._encode(g, w), q = !0;
    else if (T.children)
      k = T.children.map(function(H) {
        if (H._baseState.tag === "null_")
          return H._encode(null, w, g);
        if (H._baseState.key === null)
          return w.error("Child should have a key");
        var z = w.enterKey(H._baseState.key);
        if (typeof g != "object")
          return w.error("Child expected, but input is not object");
        var ee = H._encode(g[H._baseState.key], w, g);
        return w.leaveKey(z), ee;
      }, this).filter(function(H) {
        return H;
      }), k = this._createEncoderBuffer(k);
    else if (T.tag === "seqof" || T.tag === "setof") {
      if (!(T.args && T.args.length === 1))
        return w.error("Too many args for : " + T.tag);
      if (!Array.isArray(g))
        return w.error("seqof/setof, but data is not Array");
      var O = this.clone();
      O._baseState.implicit = null, k = this._createEncoderBuffer(g.map(function(H) {
        var z = this._baseState;
        return this._getUse(z.args[0], g)._encode(H, w);
      }, O));
    } else
      T.use !== null ? N = this._getUse(T.use, C)._encode(g, w) : (k = this._encodePrimitive(T.tag, g), q = !0);
    var N;
    if (!T.any && T.choice === null) {
      var j = T.implicit !== null ? T.implicit : T.tag, U = T.implicit === null ? "universal" : "context";
      j === null ? T.use === null && w.error("Tag could be omitted only for .use()") : T.use === null && (N = this._encodeComposite(j, q, U, k));
    }
    return T.explicit !== null && (N = this._encodeComposite(T.explicit, !1, "context", N)), N;
  }, d.prototype._encodeChoice = function(g, w) {
    var C = this._baseState, T = C.choice[g.type];
    return T || r(
      !1,
      g.type + " not found in " + JSON.stringify(Object.keys(C.choice))
    ), T._encode(g.value, w);
  }, d.prototype._encodePrimitive = function(g, w) {
    var C = this._baseState;
    if (/str$/.test(g))
      return this._encodeStr(w, g);
    if (g === "objid" && C.args)
      return this._encodeObjid(w, C.reverseArgs[0], C.args[1]);
    if (g === "objid")
      return this._encodeObjid(w, null, null);
    if (g === "gentime" || g === "utctime")
      return this._encodeTime(w, g);
    if (g === "null_")
      return this._encodeNull();
    if (g === "int" || g === "enum")
      return this._encodeInt(w, C.args && C.reverseArgs[0]);
    if (g === "bool")
      return this._encodeBool(w);
    if (g === "objDesc")
      return this._encodeStr(w, g);
    throw new Error("Unsupported tag: " + g);
  }, d.prototype._isNumstr = function(g) {
    return /^[0-9 ]*$/.test(g);
  }, d.prototype._isPrintstr = function(g) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(g);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(e) {
    var t = e;
    t.Reporter = requireReporter().Reporter, t.DecoderBuffer = requireBuffer().DecoderBuffer, t.EncoderBuffer = requireBuffer().EncoderBuffer, t.Node = requireNode();
  }(base)), base;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(e) {
    var t = requireConstants();
    e.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, e.tagClassByName = t._reverse(e.tagClass), e.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, e.tagByName = t._reverse(e.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(e) {
    var t = e;
    t._reverse = function(o) {
      var r = {};
      return Object.keys(o).forEach(function(h) {
        (h | 0) == h && (h = h | 0);
        var a = o[h];
        r[a] = h;
      }), r;
    }, t.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1)
    return der_1$1;
  hasRequiredDer$1 = 1;
  var e = requireInherits_browser(), t = requireAsn1$1(), o = t.base, r = t.bignum, h = t.constants.der;
  function a(g) {
    this.enc = "der", this.name = g.name, this.entity = g, this.tree = new p(), this.tree._init(g.body);
  }
  der_1$1 = a, a.prototype.decode = function(g, w) {
    return g instanceof o.DecoderBuffer || (g = new o.DecoderBuffer(g, w)), this.tree._decode(g, w);
  };
  function p(g) {
    o.Node.call(this, "der", g);
  }
  e(p, o.Node), p.prototype._peekTag = function(g, w, C) {
    if (g.isEmpty())
      return !1;
    var T = g.save(), k = d(g, 'Failed to peek tag: "' + w + '"');
    return g.isError(k) ? k : (g.restore(T), k.tag === w || k.tagStr === w || k.tagStr + "of" === w || C);
  }, p.prototype._decodeTag = function(g, w, C) {
    var T = d(
      g,
      'Failed to decode tag of "' + w + '"'
    );
    if (g.isError(T))
      return T;
    var k = b(
      g,
      T.primitive,
      'Failed to get length of "' + w + '"'
    );
    if (g.isError(k))
      return k;
    if (!C && T.tag !== w && T.tagStr !== w && T.tagStr + "of" !== w)
      return g.error('Failed to match tag: "' + w + '"');
    if (T.primitive || k !== null)
      return g.skip(k, 'Failed to match body of: "' + w + '"');
    var q = g.save(), O = this._skipUntilEnd(
      g,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return g.isError(O) ? O : (k = g.offset - q.offset, g.restore(q), g.skip(k, 'Failed to match body of: "' + w + '"'));
  }, p.prototype._skipUntilEnd = function(g, w) {
    for (; ; ) {
      var C = d(g, w);
      if (g.isError(C))
        return C;
      var T = b(g, C.primitive, w);
      if (g.isError(T))
        return T;
      var k;
      if (C.primitive || T !== null ? k = g.skip(T) : k = this._skipUntilEnd(g, w), g.isError(k))
        return k;
      if (C.tagStr === "end")
        break;
    }
  }, p.prototype._decodeList = function(g, w, C, T) {
    for (var k = []; !g.isEmpty(); ) {
      var q = this._peekTag(g, "end");
      if (g.isError(q))
        return q;
      var O = C.decode(g, "der", T);
      if (g.isError(O) && q)
        break;
      k.push(O);
    }
    return k;
  }, p.prototype._decodeStr = function(g, w) {
    if (w === "bitstr") {
      var C = g.readUInt8();
      return g.isError(C) ? C : { unused: C, data: g.raw() };
    } else if (w === "bmpstr") {
      var T = g.raw();
      if (T.length % 2 === 1)
        return g.error("Decoding of string type: bmpstr length mismatch");
      for (var k = "", q = 0; q < T.length / 2; q++)
        k += String.fromCharCode(T.readUInt16BE(q * 2));
      return k;
    } else if (w === "numstr") {
      var O = g.raw().toString("ascii");
      return this._isNumstr(O) ? O : g.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (w === "octstr" || w === "objDesc")
        return g.raw();
      if (w === "printstr") {
        var N = g.raw().toString("ascii");
        return this._isPrintstr(N) ? N : g.error("Decoding of string type: printstr unsupported characters");
      } else
        return /str$/.test(w) ? g.raw().toString() : g.error("Decoding of string type: " + w + " unsupported");
    }
  }, p.prototype._decodeObjid = function(g, w, C) {
    for (var T, k = [], q = 0; !g.isEmpty(); ) {
      var O = g.readUInt8();
      q <<= 7, q |= O & 127, O & 128 || (k.push(q), q = 0);
    }
    O & 128 && k.push(q);
    var N = k[0] / 40 | 0, j = k[0] % 40;
    if (C ? T = k : T = [N, j].concat(k.slice(1)), w) {
      var U = w[T.join(" ")];
      U === void 0 && (U = w[T.join(".")]), U !== void 0 && (T = U);
    }
    return T;
  }, p.prototype._decodeTime = function(g, w) {
    var C = g.raw().toString();
    if (w === "gentime")
      var T = C.slice(0, 4) | 0, k = C.slice(4, 6) | 0, q = C.slice(6, 8) | 0, O = C.slice(8, 10) | 0, N = C.slice(10, 12) | 0, j = C.slice(12, 14) | 0;
    else if (w === "utctime") {
      var T = C.slice(0, 2) | 0, k = C.slice(2, 4) | 0, q = C.slice(4, 6) | 0, O = C.slice(6, 8) | 0, N = C.slice(8, 10) | 0, j = C.slice(10, 12) | 0;
      T < 70 ? T = 2e3 + T : T = 1900 + T;
    } else
      return g.error("Decoding " + w + " time is not supported yet");
    return Date.UTC(T, k - 1, q, O, N, j, 0);
  }, p.prototype._decodeNull = function(g) {
    return null;
  }, p.prototype._decodeBool = function(g) {
    var w = g.readUInt8();
    return g.isError(w) ? w : w !== 0;
  }, p.prototype._decodeInt = function(g, w) {
    var C = g.raw(), T = new r(C);
    return w && (T = w[T.toString(10)] || T), T;
  }, p.prototype._use = function(g, w) {
    return typeof g == "function" && (g = g(w)), g._getDecoder("der").tree;
  };
  function d(g, w) {
    var C = g.readUInt8(w);
    if (g.isError(C))
      return C;
    var T = h.tagClass[C >> 6], k = (C & 32) === 0;
    if ((C & 31) === 31) {
      var q = C;
      for (C = 0; (q & 128) === 128; ) {
        if (q = g.readUInt8(w), g.isError(q))
          return q;
        C <<= 7, C |= q & 127;
      }
    } else
      C &= 31;
    var O = h.tag[C];
    return {
      cls: T,
      primitive: k,
      tag: C,
      tagStr: O
    };
  }
  function b(g, w, C) {
    var T = g.readUInt8(C);
    if (g.isError(T))
      return T;
    if (!w && T === 128)
      return null;
    if (!(T & 128))
      return T;
    var k = T & 127;
    if (k > 4)
      return g.error("length octect is too long");
    T = 0;
    for (var q = 0; q < k; q++) {
      T <<= 8;
      var O = g.readUInt8(C);
      if (g.isError(O))
        return O;
      T |= O;
    }
    return T;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1)
    return pem$1;
  hasRequiredPem$1 = 1;
  var e = requireInherits_browser(), t = requireBuffer$1().Buffer, o = requireDer$1();
  function r(h) {
    o.call(this, h), this.enc = "pem";
  }
  return e(r, o), pem$1 = r, r.prototype.decode = function(h, a) {
    for (var p = h.toString().split(/[\r\n]+/g), d = a.label.toUpperCase(), b = /^-----(BEGIN|END) ([^-]+)-----$/, g = -1, w = -1, C = 0; C < p.length; C++) {
      var T = p[C].match(b);
      if (T !== null && T[2] === d)
        if (g === -1) {
          if (T[1] !== "BEGIN")
            break;
          g = C;
        } else {
          if (T[1] !== "END")
            break;
          w = C;
          break;
        }
    }
    if (g === -1 || w === -1)
      throw new Error("PEM section not found for: " + d);
    var k = p.slice(g + 1, w).join("");
    k.replace(/[^a-z0-9\+\/=]+/gi, "");
    var q = new t(k, "base64");
    return o.prototype.decode.call(this, q, a);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(e) {
    var t = e;
    t.der = requireDer$1(), t.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer)
    return der_1;
  hasRequiredDer = 1;
  var e = requireInherits_browser(), t = requireBuffer$1().Buffer, o = requireAsn1$1(), r = o.base, h = o.constants.der;
  function a(g) {
    this.enc = "der", this.name = g.name, this.entity = g, this.tree = new p(), this.tree._init(g.body);
  }
  der_1 = a, a.prototype.encode = function(g, w) {
    return this.tree._encode(g, w).join();
  };
  function p(g) {
    r.Node.call(this, "der", g);
  }
  e(p, r.Node), p.prototype._encodeComposite = function(g, w, C, T) {
    var k = b(g, w, C, this.reporter);
    if (T.length < 128) {
      var N = new t(2);
      return N[0] = k, N[1] = T.length, this._createEncoderBuffer([N, T]);
    }
    for (var q = 1, O = T.length; O >= 256; O >>= 8)
      q++;
    var N = new t(2 + q);
    N[0] = k, N[1] = 128 | q;
    for (var O = 1 + q, j = T.length; j > 0; O--, j >>= 8)
      N[O] = j & 255;
    return this._createEncoderBuffer([N, T]);
  }, p.prototype._encodeStr = function(g, w) {
    if (w === "bitstr")
      return this._createEncoderBuffer([g.unused | 0, g.data]);
    if (w === "bmpstr") {
      for (var C = new t(g.length * 2), T = 0; T < g.length; T++)
        C.writeUInt16BE(g.charCodeAt(T), T * 2);
      return this._createEncoderBuffer(C);
    } else
      return w === "numstr" ? this._isNumstr(g) ? this._createEncoderBuffer(g) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : w === "printstr" ? this._isPrintstr(g) ? this._createEncoderBuffer(g) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(w) ? this._createEncoderBuffer(g) : w === "objDesc" ? this._createEncoderBuffer(g) : this.reporter.error("Encoding of string type: " + w + " unsupported");
  }, p.prototype._encodeObjid = function(g, w, C) {
    if (typeof g == "string") {
      if (!w)
        return this.reporter.error("string objid given, but no values map found");
      if (!w.hasOwnProperty(g))
        return this.reporter.error("objid not found in values map");
      g = w[g].split(/[\s\.]+/g);
      for (var T = 0; T < g.length; T++)
        g[T] |= 0;
    } else if (Array.isArray(g)) {
      g = g.slice();
      for (var T = 0; T < g.length; T++)
        g[T] |= 0;
    }
    if (!Array.isArray(g))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(g));
    if (!C) {
      if (g[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      g.splice(0, 2, g[0] * 40 + g[1]);
    }
    for (var k = 0, T = 0; T < g.length; T++) {
      var q = g[T];
      for (k++; q >= 128; q >>= 7)
        k++;
    }
    for (var O = new t(k), N = O.length - 1, T = g.length - 1; T >= 0; T--) {
      var q = g[T];
      for (O[N--] = q & 127; (q >>= 7) > 0; )
        O[N--] = 128 | q & 127;
    }
    return this._createEncoderBuffer(O);
  };
  function d(g) {
    return g < 10 ? "0" + g : g;
  }
  p.prototype._encodeTime = function(g, w) {
    var C, T = new Date(g);
    return w === "gentime" ? C = [
      d(T.getFullYear()),
      d(T.getUTCMonth() + 1),
      d(T.getUTCDate()),
      d(T.getUTCHours()),
      d(T.getUTCMinutes()),
      d(T.getUTCSeconds()),
      "Z"
    ].join("") : w === "utctime" ? C = [
      d(T.getFullYear() % 100),
      d(T.getUTCMonth() + 1),
      d(T.getUTCDate()),
      d(T.getUTCHours()),
      d(T.getUTCMinutes()),
      d(T.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + w + " time is not supported yet"), this._encodeStr(C, "octstr");
  }, p.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, p.prototype._encodeInt = function(g, w) {
    if (typeof g == "string") {
      if (!w)
        return this.reporter.error("String int or enum given, but no values map");
      if (!w.hasOwnProperty(g))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(g));
      g = w[g];
    }
    if (typeof g != "number" && !t.isBuffer(g)) {
      var C = g.toArray();
      !g.sign && C[0] & 128 && C.unshift(0), g = new t(C);
    }
    if (t.isBuffer(g)) {
      var T = g.length;
      g.length === 0 && T++;
      var k = new t(T);
      return g.copy(k), g.length === 0 && (k[0] = 0), this._createEncoderBuffer(k);
    }
    if (g < 128)
      return this._createEncoderBuffer(g);
    if (g < 256)
      return this._createEncoderBuffer([0, g]);
    for (var T = 1, q = g; q >= 256; q >>= 8)
      T++;
    for (var k = new Array(T), q = k.length - 1; q >= 0; q--)
      k[q] = g & 255, g >>= 8;
    return k[0] & 128 && k.unshift(0), this._createEncoderBuffer(new t(k));
  }, p.prototype._encodeBool = function(g) {
    return this._createEncoderBuffer(g ? 255 : 0);
  }, p.prototype._use = function(g, w) {
    return typeof g == "function" && (g = g(w)), g._getEncoder("der").tree;
  }, p.prototype._skipDefault = function(g, w, C) {
    var T = this._baseState, k;
    if (T.default === null)
      return !1;
    var q = g.join();
    if (T.defaultBuffer === void 0 && (T.defaultBuffer = this._encodeValue(T.default, w, C).join()), q.length !== T.defaultBuffer.length)
      return !1;
    for (k = 0; k < q.length; k++)
      if (q[k] !== T.defaultBuffer[k])
        return !1;
    return !0;
  };
  function b(g, w, C, T) {
    var k;
    if (g === "seqof" ? g = "seq" : g === "setof" && (g = "set"), h.tagByName.hasOwnProperty(g))
      k = h.tagByName[g];
    else if (typeof g == "number" && (g | 0) === g)
      k = g;
    else
      return T.error("Unknown tag: " + g);
    return k >= 31 ? T.error("Multi-octet tag encoding unsupported") : (w || (k |= 32), k |= h.tagClassByName[C || "universal"] << 6, k);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem)
    return pem;
  hasRequiredPem = 1;
  var e = requireInherits_browser(), t = requireDer();
  function o(r) {
    t.call(this, r), this.enc = "pem";
  }
  return e(o, t), pem = o, o.prototype.encode = function(r, h) {
    for (var a = t.prototype.encode.call(this, r), p = a.toString("base64"), d = ["-----BEGIN " + h.label + "-----"], b = 0; b < p.length; b += 64)
      d.push(p.slice(b, b + 64));
    return d.push("-----END " + h.label + "-----"), d.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(e) {
    var t = e;
    t.der = requireDer(), t.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
  return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1, function(e) {
    var t = e;
    t.bignum = requireBn$2(), t.define = requireApi().define, t.base = requireBase(), t.constants = requireConstants(), t.decoders = requireDecoders(), t.encoders = requireEncoders();
  }(asn1)), asn1;
}
var certificate, hasRequiredCertificate;
function requireCertificate() {
  if (hasRequiredCertificate)
    return certificate;
  hasRequiredCertificate = 1;
  var e = requireAsn1$1(), t = e.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), o = e.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), r = e.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), h = e.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(r),
      this.key("subjectPublicKey").bitstr()
    );
  }), a = e.define("RelativeDistinguishedName", function() {
    this.setof(o);
  }), p = e.define("RDNSequence", function() {
    this.seqof(a);
  }), d = e.define("Name", function() {
    this.choice({
      rdnSequence: this.use(p)
    });
  }), b = e.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(t),
      this.key("notAfter").use(t)
    );
  }), g = e.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), w = e.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(r),
      this.key("issuer").use(d),
      this.key("validity").use(b),
      this.key("subject").use(d),
      this.key("subjectPublicKeyInfo").use(h),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(g).optional()
    );
  }), C = e.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(w),
      this.key("signatureAlgorithm").use(r),
      this.key("signatureValue").bitstr()
    );
  });
  return certificate = C, certificate;
}
var hasRequiredAsn1;
function requireAsn1() {
  if (hasRequiredAsn1)
    return asn1$1;
  hasRequiredAsn1 = 1;
  var e = requireAsn1$1();
  asn1$1.certificate = requireCertificate();
  var t = e.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  asn1$1.RSAPrivateKey = t;
  var o = e.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  asn1$1.RSAPublicKey = o;
  var r = e.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), h = e.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(r),
      this.key("subjectPublicKey").bitstr()
    );
  });
  asn1$1.PublicKey = h;
  var a = e.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(r),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.PrivateKey = a;
  var p = e.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.EncryptedPrivateKey = p;
  var d = e.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  asn1$1.DSAPrivateKey = d, asn1$1.DSAparam = e.define("DSAparam", function() {
    this.int();
  });
  var b = e.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  }), g = e.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(b),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  return asn1$1.ECPrivateKey = g, asn1$1.signature = e.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), asn1$1;
}
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc, hasRequiredFixProc;
function requireFixProc() {
  if (hasRequiredFixProc)
    return fixProc;
  hasRequiredFixProc = 1;
  var e = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, t = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, o = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, r = requireEvp_bytestokey(), h = requireBrowser$6(), a = requireSafeBuffer$1().Buffer;
  return fixProc = function(p, d) {
    var b = p.toString(), g = b.match(e), w;
    if (g) {
      var C = "aes" + g[1], T = a.from(g[2], "hex"), k = a.from(g[3].replace(/[\r\n]/g, ""), "base64"), q = r(d, T.slice(0, 8), parseInt(g[1], 10)).key, O = [], N = h.createDecipheriv(C, q, T);
      O.push(N.update(k)), O.push(N.final()), w = a.concat(O);
    } else {
      var j = b.match(o);
      w = a.from(j[2].replace(/[\r\n]/g, ""), "base64");
    }
    var U = b.match(t)[1];
    return {
      tag: U,
      data: w
    };
  }, fixProc;
}
var parseAsn1, hasRequiredParseAsn1;
function requireParseAsn1() {
  if (hasRequiredParseAsn1)
    return parseAsn1;
  hasRequiredParseAsn1 = 1;
  var e = requireAsn1(), t = require$$1, o = requireFixProc(), r = requireBrowser$6(), h = requireBrowser$7(), a = requireSafeBuffer$1().Buffer;
  function p(b, g) {
    var w = b.algorithm.decrypt.kde.kdeparams.salt, C = parseInt(b.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), T = t[b.algorithm.decrypt.cipher.algo.join(".")], k = b.algorithm.decrypt.cipher.iv, q = b.subjectPrivateKey, O = parseInt(T.split("-")[1], 10) / 8, N = h.pbkdf2Sync(g, w, C, O, "sha1"), j = r.createDecipheriv(T, N, k), U = [];
    return U.push(j.update(q)), U.push(j.final()), a.concat(U);
  }
  function d(b) {
    var g;
    typeof b == "object" && !a.isBuffer(b) && (g = b.passphrase, b = b.key), typeof b == "string" && (b = a.from(b));
    var w = o(b, g), C = w.tag, T = w.data, k, q;
    switch (C) {
      case "CERTIFICATE":
        q = e.certificate.decode(T, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (q || (q = e.PublicKey.decode(T, "der")), k = q.algorithm.algorithm.join("."), k) {
          case "1.2.840.113549.1.1.1":
            return e.RSAPublicKey.decode(q.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return q.subjectPrivateKey = q.subjectPublicKey, {
              type: "ec",
              data: q
            };
          case "1.2.840.10040.4.1":
            return q.algorithm.params.pub_key = e.DSAparam.decode(q.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: q.algorithm.params
            };
          default:
            throw new Error("unknown key id " + k);
        }
      case "ENCRYPTED PRIVATE KEY":
        T = e.EncryptedPrivateKey.decode(T, "der"), T = p(T, g);
      case "PRIVATE KEY":
        switch (q = e.PrivateKey.decode(T, "der"), k = q.algorithm.algorithm.join("."), k) {
          case "1.2.840.113549.1.1.1":
            return e.RSAPrivateKey.decode(q.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: q.algorithm.curve,
              privateKey: e.ECPrivateKey.decode(q.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return q.algorithm.params.priv_key = e.DSAparam.decode(q.subjectPrivateKey, "der"), {
              type: "dsa",
              params: q.algorithm.params
            };
          default:
            throw new Error("unknown key id " + k);
        }
      case "RSA PUBLIC KEY":
        return e.RSAPublicKey.decode(T, "der");
      case "RSA PRIVATE KEY":
        return e.RSAPrivateKey.decode(T, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: e.DSAPrivateKey.decode(T, "der")
        };
      case "EC PRIVATE KEY":
        return T = e.ECPrivateKey.decode(T, "der"), {
          curve: T.parameters.value,
          privateKey: T.privateKey
        };
      default:
        throw new Error("unknown key type " + C);
    }
  }
  return d.signature = e.signature, parseAsn1 = d, parseAsn1;
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign)
    return sign.exports;
  hasRequiredSign = 1;
  var e = requireSafeBuffer$1().Buffer, t = requireBrowser$8(), o = requireBrowserifyRsa(), r = requireElliptic().ec, h = requireBn(), a = requireParseAsn1(), p = require$$4, d = 1;
  function b(j, U, H, z, ee) {
    var ne = a(U);
    if (ne.curve) {
      if (z !== "ecdsa" && z !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return g(j, ne);
    } else if (ne.type === "dsa") {
      if (z !== "dsa")
        throw new Error("wrong private key type");
      return w(j, ne, H);
    }
    if (z !== "rsa" && z !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (U.padding !== void 0 && U.padding !== d)
      throw new Error("illegal or unsupported padding mode");
    j = e.concat([ee, j]);
    for (var le = ne.modulus.byteLength(), Z = [0, 1]; j.length + Z.length + 1 < le; )
      Z.push(255);
    Z.push(0);
    for (var ie = -1; ++ie < j.length; )
      Z.push(j[ie]);
    var fe = o(Z, ne);
    return fe;
  }
  function g(j, U) {
    var H = p[U.curve.join(".")];
    if (!H)
      throw new Error("unknown curve " + U.curve.join("."));
    var z = new r(H), ee = z.keyFromPrivate(U.privateKey), ne = ee.sign(j);
    return e.from(ne.toDER());
  }
  function w(j, U, H) {
    for (var z = U.params.priv_key, ee = U.params.p, ne = U.params.q, le = U.params.g, Z = new h(0), ie, fe = k(j, ne).mod(ne), I = !1, P = T(z, ne, j, H); I === !1; )
      ie = O(ne, P, H), Z = N(le, ie, ee, ne), I = ie.invm(ne).imul(fe.add(z.mul(Z))).mod(ne), I.cmpn(0) === 0 && (I = !1, Z = new h(0));
    return C(Z, I);
  }
  function C(j, U) {
    j = j.toArray(), U = U.toArray(), j[0] & 128 && (j = [0].concat(j)), U[0] & 128 && (U = [0].concat(U));
    var H = j.length + U.length + 4, z = [
      48,
      H,
      2,
      j.length
    ];
    return z = z.concat(j, [2, U.length], U), e.from(z);
  }
  function T(j, U, H, z) {
    if (j = e.from(j.toArray()), j.length < U.byteLength()) {
      var ee = e.alloc(U.byteLength() - j.length);
      j = e.concat([ee, j]);
    }
    var ne = H.length, le = q(H, U), Z = e.alloc(ne);
    Z.fill(1);
    var ie = e.alloc(ne);
    return ie = t(z, ie).update(Z).update(e.from([0])).update(j).update(le).digest(), Z = t(z, ie).update(Z).digest(), ie = t(z, ie).update(Z).update(e.from([1])).update(j).update(le).digest(), Z = t(z, ie).update(Z).digest(), { k: ie, v: Z };
  }
  function k(j, U) {
    var H = new h(j), z = (j.length << 3) - U.bitLength();
    return z > 0 && H.ishrn(z), H;
  }
  function q(j, U) {
    j = k(j, U), j = j.mod(U);
    var H = e.from(j.toArray());
    if (H.length < U.byteLength()) {
      var z = e.alloc(U.byteLength() - H.length);
      H = e.concat([z, H]);
    }
    return H;
  }
  function O(j, U, H) {
    var z, ee;
    do {
      for (z = e.alloc(0); z.length * 8 < j.bitLength(); )
        U.v = t(H, U.k).update(U.v).digest(), z = e.concat([z, U.v]);
      ee = k(z, j), U.k = t(H, U.k).update(U.v).update(e.from([0])).digest(), U.v = t(H, U.k).update(U.v).digest();
    } while (ee.cmp(j) !== -1);
    return ee;
  }
  function N(j, U, H, z) {
    return j.toRed(h.mont(H)).redPow(U).fromRed().mod(z);
  }
  return sign.exports = b, sign.exports.getKey = T, sign.exports.makeKey = O, sign.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify)
    return verify_1;
  hasRequiredVerify = 1;
  var e = requireSafeBuffer$1().Buffer, t = requireBn(), o = requireElliptic().ec, r = requireParseAsn1(), h = require$$4;
  function a(g, w, C, T, k) {
    var q = r(C);
    if (q.type === "ec") {
      if (T !== "ecdsa" && T !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return p(g, w, q);
    } else if (q.type === "dsa") {
      if (T !== "dsa")
        throw new Error("wrong public key type");
      return d(g, w, q);
    }
    if (T !== "rsa" && T !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    w = e.concat([k, w]);
    for (var O = q.modulus.byteLength(), N = [1], j = 0; w.length + N.length + 2 < O; )
      N.push(255), j += 1;
    N.push(0);
    for (var U = -1; ++U < w.length; )
      N.push(w[U]);
    N = e.from(N);
    var H = t.mont(q.modulus);
    g = new t(g).toRed(H), g = g.redPow(new t(q.publicExponent)), g = e.from(g.fromRed().toArray());
    var z = j < 8 ? 1 : 0;
    for (O = Math.min(g.length, N.length), g.length !== N.length && (z = 1), U = -1; ++U < O; )
      z |= g[U] ^ N[U];
    return z === 0;
  }
  function p(g, w, C) {
    var T = h[C.data.algorithm.curve.join(".")];
    if (!T)
      throw new Error("unknown curve " + C.data.algorithm.curve.join("."));
    var k = new o(T), q = C.data.subjectPrivateKey.data;
    return k.verify(w, g, q);
  }
  function d(g, w, C) {
    var T = C.data.p, k = C.data.q, q = C.data.g, O = C.data.pub_key, N = r.signature.decode(g, "der"), j = N.s, U = N.r;
    b(j, k), b(U, k);
    var H = t.mont(T), z = j.invm(k), ee = q.toRed(H).redPow(new t(w).mul(z).mod(k)).fromRed().mul(O.toRed(H).redPow(U.mul(z).mod(k)).fromRed()).mod(T).mod(k);
    return ee.cmp(U) === 0;
  }
  function b(g, w) {
    if (g.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (g.cmp(w) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = a, verify_1;
}
var browser$3, hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3)
    return browser$3;
  hasRequiredBrowser$3 = 1;
  var e = requireSafeBuffer$1().Buffer, t = requireBrowser$9(), o = requireReadableBrowser(), r = requireInherits_browser(), h = requireSign(), a = requireVerify(), p = require$$6;
  Object.keys(p).forEach(function(C) {
    p[C].id = e.from(p[C].id, "hex"), p[C.toLowerCase()] = p[C];
  });
  function d(C) {
    o.Writable.call(this);
    var T = p[C];
    if (!T)
      throw new Error("Unknown message digest");
    this._hashType = T.hash, this._hash = t(T.hash), this._tag = T.id, this._signType = T.sign;
  }
  r(d, o.Writable), d.prototype._write = function(C, T, k) {
    this._hash.update(C), k();
  }, d.prototype.update = function(C, T) {
    return this._hash.update(typeof C == "string" ? e.from(C, T) : C), this;
  }, d.prototype.sign = function(C, T) {
    this.end();
    var k = this._hash.digest(), q = h(k, C, this._hashType, this._signType, this._tag);
    return T ? q.toString(T) : q;
  };
  function b(C) {
    o.Writable.call(this);
    var T = p[C];
    if (!T)
      throw new Error("Unknown message digest");
    this._hash = t(T.hash), this._tag = T.id, this._signType = T.sign;
  }
  r(b, o.Writable), b.prototype._write = function(C, T, k) {
    this._hash.update(C), k();
  }, b.prototype.update = function(C, T) {
    return this._hash.update(typeof C == "string" ? e.from(C, T) : C), this;
  }, b.prototype.verify = function(C, T, k) {
    var q = typeof T == "string" ? e.from(T, k) : T;
    this.end();
    var O = this._hash.digest();
    return a(q, O, C, this._signType, this._tag);
  };
  function g(C) {
    return new d(C);
  }
  function w(C) {
    return new b(C);
  }
  return browser$3 = {
    Sign: g,
    Verify: w,
    createSign: g,
    createVerify: w
  }, browser$3;
}
var browser$2, hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2)
    return browser$2;
  hasRequiredBrowser$2 = 1;
  var e = requireElliptic(), t = requireBn$2();
  browser$2 = function(a) {
    return new r(a);
  };
  var o = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  o.p224 = o.secp224r1, o.p256 = o.secp256r1 = o.prime256v1, o.p192 = o.secp192r1 = o.prime192v1, o.p384 = o.secp384r1, o.p521 = o.secp521r1;
  function r(a) {
    this.curveType = o[a], this.curveType || (this.curveType = {
      name: a
    }), this.curve = new e.ec(this.curveType.name), this.keys = void 0;
  }
  r.prototype.generateKeys = function(a, p) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(a, p);
  }, r.prototype.computeSecret = function(a, p, d) {
    p = p || "utf8", bufferExports.Buffer.isBuffer(a) || (a = new bufferExports.Buffer(a, p));
    var b = this.curve.keyFromPublic(a).getPublic(), g = b.mul(this.keys.getPrivate()).getX();
    return h(g, d, this.curveType.byteLength);
  }, r.prototype.getPublicKey = function(a, p) {
    var d = this.keys.getPublic(p === "compressed", !0);
    return p === "hybrid" && (d[d.length - 1] % 2 ? d[0] = 7 : d[0] = 6), h(d, a);
  }, r.prototype.getPrivateKey = function(a) {
    return h(this.keys.getPrivate(), a);
  }, r.prototype.setPublicKey = function(a, p) {
    return p = p || "utf8", bufferExports.Buffer.isBuffer(a) || (a = new bufferExports.Buffer(a, p)), this.keys._importPublic(a), this;
  }, r.prototype.setPrivateKey = function(a, p) {
    p = p || "utf8", bufferExports.Buffer.isBuffer(a) || (a = new bufferExports.Buffer(a, p));
    var d = new t(a);
    return d = d.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(d), this;
  };
  function h(a, p, d) {
    Array.isArray(a) || (a = a.toArray());
    var b = new bufferExports.Buffer(a);
    if (d && b.length < d) {
      var g = new bufferExports.Buffer(d - b.length);
      g.fill(0), b = bufferExports.Buffer.concat([g, b]);
    }
    return p ? b.toString(p) : b;
  }
  return browser$2;
}
var browser$1 = {}, mgf, hasRequiredMgf;
function requireMgf() {
  if (hasRequiredMgf)
    return mgf;
  hasRequiredMgf = 1;
  var e = requireBrowser$9(), t = requireSafeBuffer$1().Buffer;
  mgf = function(r, h) {
    for (var a = t.alloc(0), p = 0, d; a.length < h; )
      d = o(p++), a = t.concat([a, e("sha1").update(r).update(d).digest()]);
    return a.slice(0, h);
  };
  function o(r) {
    var h = t.allocUnsafe(4);
    return h.writeUInt32BE(r, 0), h;
  }
  return mgf;
}
var xor, hasRequiredXor;
function requireXor() {
  return hasRequiredXor || (hasRequiredXor = 1, xor = function(e, t) {
    for (var o = e.length, r = -1; ++r < o; )
      e[r] ^= t[r];
    return e;
  }), xor;
}
var withPublic_1, hasRequiredWithPublic;
function requireWithPublic() {
  if (hasRequiredWithPublic)
    return withPublic_1;
  hasRequiredWithPublic = 1;
  var e = requireBn$2(), t = requireSafeBuffer$1().Buffer;
  function o(r, h) {
    return t.from(r.toRed(e.mont(h.modulus)).redPow(new e(h.publicExponent)).fromRed().toArray());
  }
  return withPublic_1 = o, withPublic_1;
}
var publicEncrypt, hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
  if (hasRequiredPublicEncrypt)
    return publicEncrypt;
  hasRequiredPublicEncrypt = 1;
  var e = requireParseAsn1(), t = requireBrowser$b(), o = requireBrowser$9(), r = requireMgf(), h = requireXor(), a = requireBn$2(), p = requireWithPublic(), d = requireBrowserifyRsa(), b = requireSafeBuffer$1().Buffer;
  publicEncrypt = function(T, k, q) {
    var O;
    T.padding ? O = T.padding : q ? O = 1 : O = 4;
    var N = e(T), j;
    if (O === 4)
      j = g(N, k);
    else if (O === 1)
      j = w(N, k, q);
    else if (O === 3) {
      if (j = new a(k), j.cmp(N.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return q ? d(j, N) : p(j, N);
  };
  function g(T, k) {
    var q = T.modulus.byteLength(), O = k.length, N = o("sha1").update(b.alloc(0)).digest(), j = N.length, U = 2 * j;
    if (O > q - U - 2)
      throw new Error("message too long");
    var H = b.alloc(q - O - U - 2), z = q - j - 1, ee = t(j), ne = h(b.concat([N, H, b.alloc(1, 1), k], z), r(ee, z)), le = h(ee, r(ne, j));
    return new a(b.concat([b.alloc(1), le, ne], q));
  }
  function w(T, k, q) {
    var O = k.length, N = T.modulus.byteLength();
    if (O > N - 11)
      throw new Error("message too long");
    var j;
    return q ? j = b.alloc(N - O - 3, 255) : j = C(N - O - 3), new a(b.concat([b.from([0, q ? 1 : 2]), j, b.alloc(1), k], N));
  }
  function C(T) {
    for (var k = b.allocUnsafe(T), q = 0, O = t(T * 2), N = 0, j; q < T; )
      N === O.length && (O = t(T * 2), N = 0), j = O[N++], j && (k[q++] = j);
    return k;
  }
  return publicEncrypt;
}
var privateDecrypt, hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
  if (hasRequiredPrivateDecrypt)
    return privateDecrypt;
  hasRequiredPrivateDecrypt = 1;
  var e = requireParseAsn1(), t = requireMgf(), o = requireXor(), r = requireBn$2(), h = requireBrowserifyRsa(), a = requireBrowser$9(), p = requireWithPublic(), d = requireSafeBuffer$1().Buffer;
  privateDecrypt = function(C, T, k) {
    var q;
    C.padding ? q = C.padding : k ? q = 1 : q = 4;
    var O = e(C), N = O.modulus.byteLength();
    if (T.length > N || new r(T).cmp(O.modulus) >= 0)
      throw new Error("decryption error");
    var j;
    k ? j = p(new r(T), O) : j = h(T, O);
    var U = d.alloc(N - j.length);
    if (j = d.concat([U, j], N), q === 4)
      return b(O, j);
    if (q === 1)
      return g(O, j, k);
    if (q === 3)
      return j;
    throw new Error("unknown padding");
  };
  function b(C, T) {
    var k = C.modulus.byteLength(), q = a("sha1").update(d.alloc(0)).digest(), O = q.length;
    if (T[0] !== 0)
      throw new Error("decryption error");
    var N = T.slice(1, O + 1), j = T.slice(O + 1), U = o(N, t(j, O)), H = o(j, t(U, k - O - 1));
    if (w(q, H.slice(0, O)))
      throw new Error("decryption error");
    for (var z = O; H[z] === 0; )
      z++;
    if (H[z++] !== 1)
      throw new Error("decryption error");
    return H.slice(z);
  }
  function g(C, T, k) {
    for (var q = T.slice(0, 2), O = 2, N = 0; T[O++] !== 0; )
      if (O >= T.length) {
        N++;
        break;
      }
    var j = T.slice(2, O - 1);
    if ((q.toString("hex") !== "0002" && !k || q.toString("hex") !== "0001" && k) && N++, j.length < 8 && N++, N)
      throw new Error("decryption error");
    return T.slice(O);
  }
  function w(C, T) {
    C = d.from(C), T = d.from(T);
    var k = 0, q = C.length;
    C.length !== T.length && (k++, q = Math.min(C.length, T.length));
    for (var O = -1; ++O < q; )
      k += C[O] ^ T[O];
    return k;
  }
  return privateDecrypt;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1, function(e) {
    e.publicEncrypt = requirePublicEncrypt(), e.privateDecrypt = requirePrivateDecrypt(), e.privateEncrypt = function(t, o) {
      return e.publicEncrypt(t, o, !0);
    }, e.publicDecrypt = function(t, o) {
      return e.privateDecrypt(t, o, !0);
    };
  }(browser$1)), browser$1;
}
var browser = {}, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser;
  hasRequiredBrowser = 1;
  function e() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var t = requireSafeBuffer$1(), o = requireBrowser$b(), r = t.Buffer, h = t.kMaxLength, a = commonjsGlobal.crypto || commonjsGlobal.msCrypto, p = Math.pow(2, 32) - 1;
  function d(T, k) {
    if (typeof T != "number" || T !== T)
      throw new TypeError("offset must be a number");
    if (T > p || T < 0)
      throw new TypeError("offset must be a uint32");
    if (T > h || T > k)
      throw new RangeError("offset out of range");
  }
  function b(T, k, q) {
    if (typeof T != "number" || T !== T)
      throw new TypeError("size must be a number");
    if (T > p || T < 0)
      throw new TypeError("size must be a uint32");
    if (T + k > q || T > h)
      throw new RangeError("buffer too small");
  }
  a && a.getRandomValues || !process$1.browser ? (browser.randomFill = g, browser.randomFillSync = C) : (browser.randomFill = e, browser.randomFillSync = e);
  function g(T, k, q, O) {
    if (!r.isBuffer(T) && !(T instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof k == "function")
      O = k, k = 0, q = T.length;
    else if (typeof q == "function")
      O = q, q = T.length - k;
    else if (typeof O != "function")
      throw new TypeError('"cb" argument must be a function');
    return d(k, T.length), b(q, k, T.length), w(T, k, q, O);
  }
  function w(T, k, q, O) {
    if (process$1.browser) {
      var N = T.buffer, j = new Uint8Array(N, k, q);
      if (a.getRandomValues(j), O) {
        process$1.nextTick(function() {
          O(null, T);
        });
        return;
      }
      return T;
    }
    if (O) {
      o(q, function(H, z) {
        if (H)
          return O(H);
        z.copy(T, k), O(null, T);
      });
      return;
    }
    var U = o(q);
    return U.copy(T, k), T;
  }
  function C(T, k, q) {
    if (typeof k > "u" && (k = 0), !r.isBuffer(T) && !(T instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return d(k, T.length), q === void 0 && (q = T.length - k), b(q, k, T.length), w(T, k, q);
  }
  return browser;
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify)
    return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$b(), cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9(), cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();
  var e = requireAlgos(), t = Object.keys(e), o = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(t);
  cryptoBrowserify.getHashes = function() {
    return o;
  };
  var r = requireBrowser$7();
  cryptoBrowserify.pbkdf2 = r.pbkdf2, cryptoBrowserify.pbkdf2Sync = r.pbkdf2Sync;
  var h = requireBrowser$5();
  cryptoBrowserify.Cipher = h.Cipher, cryptoBrowserify.createCipher = h.createCipher, cryptoBrowserify.Cipheriv = h.Cipheriv, cryptoBrowserify.createCipheriv = h.createCipheriv, cryptoBrowserify.Decipher = h.Decipher, cryptoBrowserify.createDecipher = h.createDecipher, cryptoBrowserify.Decipheriv = h.Decipheriv, cryptoBrowserify.createDecipheriv = h.createDecipheriv, cryptoBrowserify.getCiphers = h.getCiphers, cryptoBrowserify.listCiphers = h.listCiphers;
  var a = requireBrowser$4();
  cryptoBrowserify.DiffieHellmanGroup = a.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = a.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = a.getDiffieHellman, cryptoBrowserify.createDiffieHellman = a.createDiffieHellman, cryptoBrowserify.DiffieHellman = a.DiffieHellman;
  var p = requireBrowser$3();
  cryptoBrowserify.createSign = p.createSign, cryptoBrowserify.Sign = p.Sign, cryptoBrowserify.createVerify = p.createVerify, cryptoBrowserify.Verify = p.Verify, cryptoBrowserify.createECDH = requireBrowser$2();
  var d = requireBrowser$1();
  cryptoBrowserify.publicEncrypt = d.publicEncrypt, cryptoBrowserify.privateEncrypt = d.privateEncrypt, cryptoBrowserify.publicDecrypt = d.publicDecrypt, cryptoBrowserify.privateDecrypt = d.privateDecrypt;
  var b = requireBrowser();
  return cryptoBrowserify.randomFill = b.randomFill, cryptoBrowserify.randomFillSync = b.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
(function(e) {
  /**
   * @license bcrypt.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
   * Released under the Apache License, Version 2.0
   * see: https://github.com/dcodeIO/bcrypt.js for details
   */
  (function(t, o) {
    typeof commonjsRequire == "function" && e && e.exports ? e.exports = o() : (t.dcodeIO = t.dcodeIO || {}).bcrypt = o();
  })(commonjsGlobal, function() {
    var t = {}, o = null;
    function r(I) {
      if (e && e.exports)
        try {
          return requireCryptoBrowserify().randomBytes(I);
        } catch {
        }
      try {
        var P;
        return (self.crypto || self.msCrypto).getRandomValues(P = new Uint32Array(I)), Array.prototype.slice.call(P);
      } catch {
      }
      if (!o)
        throw Error("Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative");
      return o(I);
    }
    var h = !1;
    try {
      r(1), h = !0;
    } catch {
    }
    o = null, t.setRandomFallback = function(I) {
      o = I;
    }, t.genSaltSync = function(I, P) {
      if (I = I || O, typeof I != "number")
        throw Error("Illegal arguments: " + typeof I + ", " + typeof P);
      I < 4 ? I = 4 : I > 31 && (I = 31);
      var f = [];
      return f.push("$2a$"), I < 10 && f.push("0"), f.push(I.toString()), f.push("$"), f.push(C(r(q), q)), f.join("");
    }, t.genSalt = function(I, P, f) {
      if (typeof P == "function" && (f = P, P = void 0), typeof I == "function" && (f = I, I = void 0), typeof I > "u")
        I = O;
      else if (typeof I != "number")
        throw Error("illegal arguments: " + typeof I);
      function y(v) {
        p(function() {
          try {
            v(null, t.genSaltSync(I));
          } catch (M) {
            v(M);
          }
        });
      }
      if (f) {
        if (typeof f != "function")
          throw Error("Illegal callback: " + typeof f);
        y(f);
      } else
        return new Promise(function(v, M) {
          y(function(B, S) {
            if (B) {
              M(B);
              return;
            }
            v(S);
          });
        });
    }, t.hashSync = function(I, P) {
      if (typeof P > "u" && (P = O), typeof P == "number" && (P = t.genSaltSync(P)), typeof I != "string" || typeof P != "string")
        throw Error("Illegal arguments: " + typeof I + ", " + typeof P);
      return fe(I, P);
    }, t.hash = function(I, P, f, y) {
      function v(M) {
        typeof I == "string" && typeof P == "number" ? t.genSalt(P, function(B, S) {
          fe(I, S, M, y);
        }) : typeof I == "string" && typeof P == "string" ? fe(I, P, M, y) : p(M.bind(this, Error("Illegal arguments: " + typeof I + ", " + typeof P)));
      }
      if (f) {
        if (typeof f != "function")
          throw Error("Illegal callback: " + typeof f);
        v(f);
      } else
        return new Promise(function(M, B) {
          v(function(S, _) {
            if (S) {
              B(S);
              return;
            }
            M(_);
          });
        });
    };
    function a(I, P) {
      for (var f = 0, y = 0, v = 0, M = I.length; v < M; ++v)
        I.charCodeAt(v) === P.charCodeAt(v) ? ++f : ++y;
      return f < 0 ? !1 : y === 0;
    }
    t.compareSync = function(I, P) {
      if (typeof I != "string" || typeof P != "string")
        throw Error("Illegal arguments: " + typeof I + ", " + typeof P);
      return P.length !== 60 ? !1 : a(t.hashSync(I, P.substr(0, P.length - 31)), P);
    }, t.compare = function(I, P, f, y) {
      function v(M) {
        if (typeof I != "string" || typeof P != "string") {
          p(M.bind(this, Error("Illegal arguments: " + typeof I + ", " + typeof P)));
          return;
        }
        if (P.length !== 60) {
          p(M.bind(this, null, !1));
          return;
        }
        t.hash(I, P.substr(0, 29), function(B, S) {
          B ? M(B) : M(null, a(S, P));
        }, y);
      }
      if (f) {
        if (typeof f != "function")
          throw Error("Illegal callback: " + typeof f);
        v(f);
      } else
        return new Promise(function(M, B) {
          v(function(S, _) {
            if (S) {
              B(S);
              return;
            }
            M(_);
          });
        });
    }, t.getRounds = function(I) {
      if (typeof I != "string")
        throw Error("Illegal arguments: " + typeof I);
      return parseInt(I.split("$")[2], 10);
    }, t.getSalt = function(I) {
      if (typeof I != "string")
        throw Error("Illegal arguments: " + typeof I);
      if (I.length !== 60)
        throw Error("Illegal hash length: " + I.length + " != 60");
      return I.substring(0, 29);
    };
    var p = typeof process$1 < "u" && process$1 && typeof process$1.nextTick == "function" ? typeof setImmediate == "function" ? setImmediate : process$1.nextTick : setTimeout;
    function d(I) {
      var P = [], f = 0;
      return k.encodeUTF16toUTF8(function() {
        return f >= I.length ? null : I.charCodeAt(f++);
      }, function(y) {
        P.push(y);
      }), P;
    }
    var b = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), g = [
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      0,
      1,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      -1,
      -1,
      -1,
      -1,
      -1
    ], w = String.fromCharCode;
    function C(I, P) {
      var f = 0, y = [], v, M;
      if (P <= 0 || P > I.length)
        throw Error("Illegal len: " + P);
      for (; f < P; ) {
        if (v = I[f++] & 255, y.push(b[v >> 2 & 63]), v = (v & 3) << 4, f >= P) {
          y.push(b[v & 63]);
          break;
        }
        if (M = I[f++] & 255, v |= M >> 4 & 15, y.push(b[v & 63]), v = (M & 15) << 2, f >= P) {
          y.push(b[v & 63]);
          break;
        }
        M = I[f++] & 255, v |= M >> 6 & 3, y.push(b[v & 63]), y.push(b[M & 63]);
      }
      return y.join("");
    }
    function T(I, P) {
      var f = 0, y = I.length, v = 0, M = [], B, S, _, E, m, A;
      if (P <= 0)
        throw Error("Illegal len: " + P);
      for (; f < y - 1 && v < P && (A = I.charCodeAt(f++), B = A < g.length ? g[A] : -1, A = I.charCodeAt(f++), S = A < g.length ? g[A] : -1, !(B == -1 || S == -1 || (m = B << 2 >>> 0, m |= (S & 48) >> 4, M.push(w(m)), ++v >= P || f >= y) || (A = I.charCodeAt(f++), _ = A < g.length ? g[A] : -1, _ == -1) || (m = (S & 15) << 4 >>> 0, m |= (_ & 60) >> 2, M.push(w(m)), ++v >= P || f >= y))); )
        A = I.charCodeAt(f++), E = A < g.length ? g[A] : -1, m = (_ & 3) << 6 >>> 0, m |= E, M.push(w(m)), ++v;
      var $ = [];
      for (f = 0; f < v; f++)
        $.push(M[f].charCodeAt(0));
      return $;
    }
    var k = function() {
      var I = {};
      return I.MAX_CODEPOINT = 1114111, I.encodeUTF8 = function(P, f) {
        var y = null;
        for (typeof P == "number" && (y = P, P = function() {
          return null;
        }); y !== null || (y = P()) !== null; )
          y < 128 ? f(y & 127) : y < 2048 ? (f(y >> 6 & 31 | 192), f(y & 63 | 128)) : y < 65536 ? (f(y >> 12 & 15 | 224), f(y >> 6 & 63 | 128), f(y & 63 | 128)) : (f(y >> 18 & 7 | 240), f(y >> 12 & 63 | 128), f(y >> 6 & 63 | 128), f(y & 63 | 128)), y = null;
      }, I.decodeUTF8 = function(P, f) {
        for (var y, v, M, B, S = function(_) {
          _ = _.slice(0, _.indexOf(null));
          var E = Error(_.toString());
          throw E.name = "TruncatedError", E.bytes = _, E;
        }; (y = P()) !== null; )
          if (!(y & 128))
            f(y);
          else if ((y & 224) === 192)
            (v = P()) === null && S([y, v]), f((y & 31) << 6 | v & 63);
          else if ((y & 240) === 224)
            ((v = P()) === null || (M = P()) === null) && S([y, v, M]), f((y & 15) << 12 | (v & 63) << 6 | M & 63);
          else if ((y & 248) === 240)
            ((v = P()) === null || (M = P()) === null || (B = P()) === null) && S([y, v, M, B]), f((y & 7) << 18 | (v & 63) << 12 | (M & 63) << 6 | B & 63);
          else
            throw RangeError("Illegal starting byte: " + y);
      }, I.UTF16toUTF8 = function(P, f) {
        for (var y, v = null; (y = v !== null ? v : P()) !== null; ) {
          if (y >= 55296 && y <= 57343 && (v = P()) !== null && v >= 56320 && v <= 57343) {
            f((y - 55296) * 1024 + v - 56320 + 65536), v = null;
            continue;
          }
          f(y);
        }
        v !== null && f(v);
      }, I.UTF8toUTF16 = function(P, f) {
        var y = null;
        for (typeof P == "number" && (y = P, P = function() {
          return null;
        }); y !== null || (y = P()) !== null; )
          y <= 65535 ? f(y) : (y -= 65536, f((y >> 10) + 55296), f(y % 1024 + 56320)), y = null;
      }, I.encodeUTF16toUTF8 = function(P, f) {
        I.UTF16toUTF8(P, function(y) {
          I.encodeUTF8(y, f);
        });
      }, I.decodeUTF8toUTF16 = function(P, f) {
        I.decodeUTF8(P, function(y) {
          I.UTF8toUTF16(y, f);
        });
      }, I.calculateCodePoint = function(P) {
        return P < 128 ? 1 : P < 2048 ? 2 : P < 65536 ? 3 : 4;
      }, I.calculateUTF8 = function(P) {
        for (var f, y = 0; (f = P()) !== null; )
          y += I.calculateCodePoint(f);
        return y;
      }, I.calculateUTF16asUTF8 = function(P) {
        var f = 0, y = 0;
        return I.UTF16toUTF8(P, function(v) {
          ++f, y += I.calculateCodePoint(v);
        }), [f, y];
      }, I;
    }();
    Date.now = Date.now || function() {
      return +/* @__PURE__ */ new Date();
    };
    var q = 16, O = 10, N = 16, j = 100, U = [
      608135816,
      2242054355,
      320440878,
      57701188,
      2752067618,
      698298832,
      137296536,
      3964562569,
      1160258022,
      953160567,
      3193202383,
      887688300,
      3232508343,
      3380367581,
      1065670069,
      3041331479,
      2450970073,
      2306472731
    ], H = [
      3509652390,
      2564797868,
      805139163,
      3491422135,
      3101798381,
      1780907670,
      3128725573,
      4046225305,
      614570311,
      3012652279,
      134345442,
      2240740374,
      1667834072,
      1901547113,
      2757295779,
      4103290238,
      227898511,
      1921955416,
      1904987480,
      2182433518,
      2069144605,
      3260701109,
      2620446009,
      720527379,
      3318853667,
      677414384,
      3393288472,
      3101374703,
      2390351024,
      1614419982,
      1822297739,
      2954791486,
      3608508353,
      3174124327,
      2024746970,
      1432378464,
      3864339955,
      2857741204,
      1464375394,
      1676153920,
      1439316330,
      715854006,
      3033291828,
      289532110,
      2706671279,
      2087905683,
      3018724369,
      1668267050,
      732546397,
      1947742710,
      3462151702,
      2609353502,
      2950085171,
      1814351708,
      2050118529,
      680887927,
      999245976,
      1800124847,
      3300911131,
      1713906067,
      1641548236,
      4213287313,
      1216130144,
      1575780402,
      4018429277,
      3917837745,
      3693486850,
      3949271944,
      596196993,
      3549867205,
      258830323,
      2213823033,
      772490370,
      2760122372,
      1774776394,
      2652871518,
      566650946,
      4142492826,
      1728879713,
      2882767088,
      1783734482,
      3629395816,
      2517608232,
      2874225571,
      1861159788,
      326777828,
      3124490320,
      2130389656,
      2716951837,
      967770486,
      1724537150,
      2185432712,
      2364442137,
      1164943284,
      2105845187,
      998989502,
      3765401048,
      2244026483,
      1075463327,
      1455516326,
      1322494562,
      910128902,
      469688178,
      1117454909,
      936433444,
      3490320968,
      3675253459,
      1240580251,
      122909385,
      2157517691,
      634681816,
      4142456567,
      3825094682,
      3061402683,
      2540495037,
      79693498,
      3249098678,
      1084186820,
      1583128258,
      426386531,
      1761308591,
      1047286709,
      322548459,
      995290223,
      1845252383,
      2603652396,
      3431023940,
      2942221577,
      3202600964,
      3727903485,
      1712269319,
      422464435,
      3234572375,
      1170764815,
      3523960633,
      3117677531,
      1434042557,
      442511882,
      3600875718,
      1076654713,
      1738483198,
      4213154764,
      2393238008,
      3677496056,
      1014306527,
      4251020053,
      793779912,
      2902807211,
      842905082,
      4246964064,
      1395751752,
      1040244610,
      2656851899,
      3396308128,
      445077038,
      3742853595,
      3577915638,
      679411651,
      2892444358,
      2354009459,
      1767581616,
      3150600392,
      3791627101,
      3102740896,
      284835224,
      4246832056,
      1258075500,
      768725851,
      2589189241,
      3069724005,
      3532540348,
      1274779536,
      3789419226,
      2764799539,
      1660621633,
      3471099624,
      4011903706,
      913787905,
      3497959166,
      737222580,
      2514213453,
      2928710040,
      3937242737,
      1804850592,
      3499020752,
      2949064160,
      2386320175,
      2390070455,
      2415321851,
      4061277028,
      2290661394,
      2416832540,
      1336762016,
      1754252060,
      3520065937,
      3014181293,
      791618072,
      3188594551,
      3933548030,
      2332172193,
      3852520463,
      3043980520,
      413987798,
      3465142937,
      3030929376,
      4245938359,
      2093235073,
      3534596313,
      375366246,
      2157278981,
      2479649556,
      555357303,
      3870105701,
      2008414854,
      3344188149,
      4221384143,
      3956125452,
      2067696032,
      3594591187,
      2921233993,
      2428461,
      544322398,
      577241275,
      1471733935,
      610547355,
      4027169054,
      1432588573,
      1507829418,
      2025931657,
      3646575487,
      545086370,
      48609733,
      2200306550,
      1653985193,
      298326376,
      1316178497,
      3007786442,
      2064951626,
      458293330,
      2589141269,
      3591329599,
      3164325604,
      727753846,
      2179363840,
      146436021,
      1461446943,
      4069977195,
      705550613,
      3059967265,
      3887724982,
      4281599278,
      3313849956,
      1404054877,
      2845806497,
      146425753,
      1854211946,
      1266315497,
      3048417604,
      3681880366,
      3289982499,
      290971e4,
      1235738493,
      2632868024,
      2414719590,
      3970600049,
      1771706367,
      1449415276,
      3266420449,
      422970021,
      1963543593,
      2690192192,
      3826793022,
      1062508698,
      1531092325,
      1804592342,
      2583117782,
      2714934279,
      4024971509,
      1294809318,
      4028980673,
      1289560198,
      2221992742,
      1669523910,
      35572830,
      157838143,
      1052438473,
      1016535060,
      1802137761,
      1753167236,
      1386275462,
      3080475397,
      2857371447,
      1040679964,
      2145300060,
      2390574316,
      1461121720,
      2956646967,
      4031777805,
      4028374788,
      33600511,
      2920084762,
      1018524850,
      629373528,
      3691585981,
      3515945977,
      2091462646,
      2486323059,
      586499841,
      988145025,
      935516892,
      3367335476,
      2599673255,
      2839830854,
      265290510,
      3972581182,
      2759138881,
      3795373465,
      1005194799,
      847297441,
      406762289,
      1314163512,
      1332590856,
      1866599683,
      4127851711,
      750260880,
      613907577,
      1450815602,
      3165620655,
      3734664991,
      3650291728,
      3012275730,
      3704569646,
      1427272223,
      778793252,
      1343938022,
      2676280711,
      2052605720,
      1946737175,
      3164576444,
      3914038668,
      3967478842,
      3682934266,
      1661551462,
      3294938066,
      4011595847,
      840292616,
      3712170807,
      616741398,
      312560963,
      711312465,
      1351876610,
      322626781,
      1910503582,
      271666773,
      2175563734,
      1594956187,
      70604529,
      3617834859,
      1007753275,
      1495573769,
      4069517037,
      2549218298,
      2663038764,
      504708206,
      2263041392,
      3941167025,
      2249088522,
      1514023603,
      1998579484,
      1312622330,
      694541497,
      2582060303,
      2151582166,
      1382467621,
      776784248,
      2618340202,
      3323268794,
      2497899128,
      2784771155,
      503983604,
      4076293799,
      907881277,
      423175695,
      432175456,
      1378068232,
      4145222326,
      3954048622,
      3938656102,
      3820766613,
      2793130115,
      2977904593,
      26017576,
      3274890735,
      3194772133,
      1700274565,
      1756076034,
      4006520079,
      3677328699,
      720338349,
      1533947780,
      354530856,
      688349552,
      3973924725,
      1637815568,
      332179504,
      3949051286,
      53804574,
      2852348879,
      3044236432,
      1282449977,
      3583942155,
      3416972820,
      4006381244,
      1617046695,
      2628476075,
      3002303598,
      1686838959,
      431878346,
      2686675385,
      1700445008,
      1080580658,
      1009431731,
      832498133,
      3223435511,
      2605976345,
      2271191193,
      2516031870,
      1648197032,
      4164389018,
      2548247927,
      300782431,
      375919233,
      238389289,
      3353747414,
      2531188641,
      2019080857,
      1475708069,
      455242339,
      2609103871,
      448939670,
      3451063019,
      1395535956,
      2413381860,
      1841049896,
      1491858159,
      885456874,
      4264095073,
      4001119347,
      1565136089,
      3898914787,
      1108368660,
      540939232,
      1173283510,
      2745871338,
      3681308437,
      4207628240,
      3343053890,
      4016749493,
      1699691293,
      1103962373,
      3625875870,
      2256883143,
      3830138730,
      1031889488,
      3479347698,
      1535977030,
      4236805024,
      3251091107,
      2132092099,
      1774941330,
      1199868427,
      1452454533,
      157007616,
      2904115357,
      342012276,
      595725824,
      1480756522,
      206960106,
      497939518,
      591360097,
      863170706,
      2375253569,
      3596610801,
      1814182875,
      2094937945,
      3421402208,
      1082520231,
      3463918190,
      2785509508,
      435703966,
      3908032597,
      1641649973,
      2842273706,
      3305899714,
      1510255612,
      2148256476,
      2655287854,
      3276092548,
      4258621189,
      236887753,
      3681803219,
      274041037,
      1734335097,
      3815195456,
      3317970021,
      1899903192,
      1026095262,
      4050517792,
      356393447,
      2410691914,
      3873677099,
      3682840055,
      3913112168,
      2491498743,
      4132185628,
      2489919796,
      1091903735,
      1979897079,
      3170134830,
      3567386728,
      3557303409,
      857797738,
      1136121015,
      1342202287,
      507115054,
      2535736646,
      337727348,
      3213592640,
      1301675037,
      2528481711,
      1895095763,
      1721773893,
      3216771564,
      62756741,
      2142006736,
      835421444,
      2531993523,
      1442658625,
      3659876326,
      2882144922,
      676362277,
      1392781812,
      170690266,
      3921047035,
      1759253602,
      3611846912,
      1745797284,
      664899054,
      1329594018,
      3901205900,
      3045908486,
      2062866102,
      2865634940,
      3543621612,
      3464012697,
      1080764994,
      553557557,
      3656615353,
      3996768171,
      991055499,
      499776247,
      1265440854,
      648242737,
      3940784050,
      980351604,
      3713745714,
      1749149687,
      3396870395,
      4211799374,
      3640570775,
      1161844396,
      3125318951,
      1431517754,
      545492359,
      4268468663,
      3499529547,
      1437099964,
      2702547544,
      3433638243,
      2581715763,
      2787789398,
      1060185593,
      1593081372,
      2418618748,
      4260947970,
      69676912,
      2159744348,
      86519011,
      2512459080,
      3838209314,
      1220612927,
      3339683548,
      133810670,
      1090789135,
      1078426020,
      1569222167,
      845107691,
      3583754449,
      4072456591,
      1091646820,
      628848692,
      1613405280,
      3757631651,
      526609435,
      236106946,
      48312990,
      2942717905,
      3402727701,
      1797494240,
      859738849,
      992217954,
      4005476642,
      2243076622,
      3870952857,
      3732016268,
      765654824,
      3490871365,
      2511836413,
      1685915746,
      3888969200,
      1414112111,
      2273134842,
      3281911079,
      4080962846,
      172450625,
      2569994100,
      980381355,
      4109958455,
      2819808352,
      2716589560,
      2568741196,
      3681446669,
      3329971472,
      1835478071,
      660984891,
      3704678404,
      4045999559,
      3422617507,
      3040415634,
      1762651403,
      1719377915,
      3470491036,
      2693910283,
      3642056355,
      3138596744,
      1364962596,
      2073328063,
      1983633131,
      926494387,
      3423689081,
      2150032023,
      4096667949,
      1749200295,
      3328846651,
      309677260,
      2016342300,
      1779581495,
      3079819751,
      111262694,
      1274766160,
      443224088,
      298511866,
      1025883608,
      3806446537,
      1145181785,
      168956806,
      3641502830,
      3584813610,
      1689216846,
      3666258015,
      3200248200,
      1692713982,
      2646376535,
      4042768518,
      1618508792,
      1610833997,
      3523052358,
      4130873264,
      2001055236,
      3610705100,
      2202168115,
      4028541809,
      2961195399,
      1006657119,
      2006996926,
      3186142756,
      1430667929,
      3210227297,
      1314452623,
      4074634658,
      4101304120,
      2273951170,
      1399257539,
      3367210612,
      3027628629,
      1190975929,
      2062231137,
      2333990788,
      2221543033,
      2438960610,
      1181637006,
      548689776,
      2362791313,
      3372408396,
      3104550113,
      3145860560,
      296247880,
      1970579870,
      3078560182,
      3769228297,
      1714227617,
      3291629107,
      3898220290,
      166772364,
      1251581989,
      493813264,
      448347421,
      195405023,
      2709975567,
      677966185,
      3703036547,
      1463355134,
      2715995803,
      1338867538,
      1343315457,
      2802222074,
      2684532164,
      233230375,
      2599980071,
      2000651841,
      3277868038,
      1638401717,
      4028070440,
      3237316320,
      6314154,
      819756386,
      300326615,
      590932579,
      1405279636,
      3267499572,
      3150704214,
      2428286686,
      3959192993,
      3461946742,
      1862657033,
      1266418056,
      963775037,
      2089974820,
      2263052895,
      1917689273,
      448879540,
      3550394620,
      3981727096,
      150775221,
      3627908307,
      1303187396,
      508620638,
      2975983352,
      2726630617,
      1817252668,
      1876281319,
      1457606340,
      908771278,
      3720792119,
      3617206836,
      2455994898,
      1729034894,
      1080033504,
      976866871,
      3556439503,
      2881648439,
      1522871579,
      1555064734,
      1336096578,
      3548522304,
      2579274686,
      3574697629,
      3205460757,
      3593280638,
      3338716283,
      3079412587,
      564236357,
      2993598910,
      1781952180,
      1464380207,
      3163844217,
      3332601554,
      1699332808,
      1393555694,
      1183702653,
      3581086237,
      1288719814,
      691649499,
      2847557200,
      2895455976,
      3193889540,
      2717570544,
      1781354906,
      1676643554,
      2592534050,
      3230253752,
      1126444790,
      2770207658,
      2633158820,
      2210423226,
      2615765581,
      2414155088,
      3127139286,
      673620729,
      2805611233,
      1269405062,
      4015350505,
      3341807571,
      4149409754,
      1057255273,
      2012875353,
      2162469141,
      2276492801,
      2601117357,
      993977747,
      3918593370,
      2654263191,
      753973209,
      36408145,
      2530585658,
      25011837,
      3520020182,
      2088578344,
      530523599,
      2918365339,
      1524020338,
      1518925132,
      3760827505,
      3759777254,
      1202760957,
      3985898139,
      3906192525,
      674977740,
      4174734889,
      2031300136,
      2019492241,
      3983892565,
      4153806404,
      3822280332,
      352677332,
      2297720250,
      60907813,
      90501309,
      3286998549,
      1016092578,
      2535922412,
      2839152426,
      457141659,
      509813237,
      4120667899,
      652014361,
      1966332200,
      2975202805,
      55981186,
      2327461051,
      676427537,
      3255491064,
      2882294119,
      3433927263,
      1307055953,
      942726286,
      933058658,
      2468411793,
      3933900994,
      4215176142,
      1361170020,
      2001714738,
      2830558078,
      3274259782,
      1222529897,
      1679025792,
      2729314320,
      3714953764,
      1770335741,
      151462246,
      3013232138,
      1682292957,
      1483529935,
      471910574,
      1539241949,
      458788160,
      3436315007,
      1807016891,
      3718408830,
      978976581,
      1043663428,
      3165965781,
      1927990952,
      4200891579,
      2372276910,
      3208408903,
      3533431907,
      1412390302,
      2931980059,
      4132332400,
      1947078029,
      3881505623,
      4168226417,
      2941484381,
      1077988104,
      1320477388,
      886195818,
      18198404,
      3786409e3,
      2509781533,
      112762804,
      3463356488,
      1866414978,
      891333506,
      18488651,
      661792760,
      1628790961,
      3885187036,
      3141171499,
      876946877,
      2693282273,
      1372485963,
      791857591,
      2686433993,
      3759982718,
      3167212022,
      3472953795,
      2716379847,
      445679433,
      3561995674,
      3504004811,
      3574258232,
      54117162,
      3331405415,
      2381918588,
      3769707343,
      4154350007,
      1140177722,
      4074052095,
      668550556,
      3214352940,
      367459370,
      261225585,
      2610173221,
      4209349473,
      3468074219,
      3265815641,
      314222801,
      3066103646,
      3808782860,
      282218597,
      3406013506,
      3773591054,
      379116347,
      1285071038,
      846784868,
      2669647154,
      3771962079,
      3550491691,
      2305946142,
      453669953,
      1268987020,
      3317592352,
      3279303384,
      3744833421,
      2610507566,
      3859509063,
      266596637,
      3847019092,
      517658769,
      3462560207,
      3443424879,
      370717030,
      4247526661,
      2224018117,
      4143653529,
      4112773975,
      2788324899,
      2477274417,
      1456262402,
      2901442914,
      1517677493,
      1846949527,
      2295493580,
      3734397586,
      2176403920,
      1280348187,
      1908823572,
      3871786941,
      846861322,
      1172426758,
      3287448474,
      3383383037,
      1655181056,
      3139813346,
      901632758,
      1897031941,
      2986607138,
      3066810236,
      3447102507,
      1393639104,
      373351379,
      950779232,
      625454576,
      3124240540,
      4148612726,
      2007998917,
      544563296,
      2244738638,
      2330496472,
      2058025392,
      1291430526,
      424198748,
      50039436,
      29584100,
      3605783033,
      2429876329,
      2791104160,
      1057563949,
      3255363231,
      3075367218,
      3463963227,
      1469046755,
      985887462
    ], z = [
      1332899944,
      1700884034,
      1701343084,
      1684370003,
      1668446532,
      1869963892
    ];
    function ee(I, P, f, y) {
      var v, M = I[P], B = I[P + 1];
      return M ^= f[0], v = y[M >>> 24], v += y[256 | M >> 16 & 255], v ^= y[512 | M >> 8 & 255], v += y[768 | M & 255], B ^= v ^ f[1], v = y[B >>> 24], v += y[256 | B >> 16 & 255], v ^= y[512 | B >> 8 & 255], v += y[768 | B & 255], M ^= v ^ f[2], v = y[M >>> 24], v += y[256 | M >> 16 & 255], v ^= y[512 | M >> 8 & 255], v += y[768 | M & 255], B ^= v ^ f[3], v = y[B >>> 24], v += y[256 | B >> 16 & 255], v ^= y[512 | B >> 8 & 255], v += y[768 | B & 255], M ^= v ^ f[4], v = y[M >>> 24], v += y[256 | M >> 16 & 255], v ^= y[512 | M >> 8 & 255], v += y[768 | M & 255], B ^= v ^ f[5], v = y[B >>> 24], v += y[256 | B >> 16 & 255], v ^= y[512 | B >> 8 & 255], v += y[768 | B & 255], M ^= v ^ f[6], v = y[M >>> 24], v += y[256 | M >> 16 & 255], v ^= y[512 | M >> 8 & 255], v += y[768 | M & 255], B ^= v ^ f[7], v = y[B >>> 24], v += y[256 | B >> 16 & 255], v ^= y[512 | B >> 8 & 255], v += y[768 | B & 255], M ^= v ^ f[8], v = y[M >>> 24], v += y[256 | M >> 16 & 255], v ^= y[512 | M >> 8 & 255], v += y[768 | M & 255], B ^= v ^ f[9], v = y[B >>> 24], v += y[256 | B >> 16 & 255], v ^= y[512 | B >> 8 & 255], v += y[768 | B & 255], M ^= v ^ f[10], v = y[M >>> 24], v += y[256 | M >> 16 & 255], v ^= y[512 | M >> 8 & 255], v += y[768 | M & 255], B ^= v ^ f[11], v = y[B >>> 24], v += y[256 | B >> 16 & 255], v ^= y[512 | B >> 8 & 255], v += y[768 | B & 255], M ^= v ^ f[12], v = y[M >>> 24], v += y[256 | M >> 16 & 255], v ^= y[512 | M >> 8 & 255], v += y[768 | M & 255], B ^= v ^ f[13], v = y[B >>> 24], v += y[256 | B >> 16 & 255], v ^= y[512 | B >> 8 & 255], v += y[768 | B & 255], M ^= v ^ f[14], v = y[M >>> 24], v += y[256 | M >> 16 & 255], v ^= y[512 | M >> 8 & 255], v += y[768 | M & 255], B ^= v ^ f[15], v = y[B >>> 24], v += y[256 | B >> 16 & 255], v ^= y[512 | B >> 8 & 255], v += y[768 | B & 255], M ^= v ^ f[16], I[P] = B ^ f[N + 1], I[P + 1] = M, I;
    }
    function ne(I, P) {
      for (var f = 0, y = 0; f < 4; ++f)
        y = y << 8 | I[P] & 255, P = (P + 1) % I.length;
      return { key: y, offp: P };
    }
    function le(I, P, f) {
      for (var y = 0, v = [0, 0], M = P.length, B = f.length, S, _ = 0; _ < M; _++)
        S = ne(I, y), y = S.offp, P[_] = P[_] ^ S.key;
      for (_ = 0; _ < M; _ += 2)
        v = ee(v, 0, P, f), P[_] = v[0], P[_ + 1] = v[1];
      for (_ = 0; _ < B; _ += 2)
        v = ee(v, 0, P, f), f[_] = v[0], f[_ + 1] = v[1];
    }
    function Z(I, P, f, y) {
      for (var v = 0, M = [0, 0], B = f.length, S = y.length, _, E = 0; E < B; E++)
        _ = ne(P, v), v = _.offp, f[E] = f[E] ^ _.key;
      for (v = 0, E = 0; E < B; E += 2)
        _ = ne(I, v), v = _.offp, M[0] ^= _.key, _ = ne(I, v), v = _.offp, M[1] ^= _.key, M = ee(M, 0, f, y), f[E] = M[0], f[E + 1] = M[1];
      for (E = 0; E < S; E += 2)
        _ = ne(I, v), v = _.offp, M[0] ^= _.key, _ = ne(I, v), v = _.offp, M[1] ^= _.key, M = ee(M, 0, f, y), y[E] = M[0], y[E + 1] = M[1];
    }
    function ie(I, P, f, y, v) {
      var M = z.slice(), B = M.length, S;
      if (f < 4 || f > 31)
        if (S = Error("Illegal number of rounds (4-31): " + f), y) {
          p(y.bind(this, S));
          return;
        } else
          throw S;
      if (P.length !== q)
        if (S = Error("Illegal salt length: " + P.length + " != " + q), y) {
          p(y.bind(this, S));
          return;
        } else
          throw S;
      f = 1 << f >>> 0;
      var _, E, m = 0, A;
      Int32Array ? (_ = new Int32Array(U), E = new Int32Array(H)) : (_ = U.slice(), E = H.slice()), Z(P, I, _, E);
      function $() {
        if (v && v(m / f), m < f)
          for (var oe = Date.now(); m < f && (m = m + 1, le(I, _, E), le(P, _, E), !(Date.now() - oe > j)); )
            ;
        else {
          for (m = 0; m < 64; m++)
            for (A = 0; A < B >> 1; A++)
              ee(M, A << 1, _, E);
          var J = [];
          for (m = 0; m < B; m++)
            J.push((M[m] >> 24 & 255) >>> 0), J.push((M[m] >> 16 & 255) >>> 0), J.push((M[m] >> 8 & 255) >>> 0), J.push((M[m] & 255) >>> 0);
          if (y) {
            y(null, J);
            return;
          } else
            return J;
        }
        y && p($);
      }
      if (typeof y < "u")
        $();
      else
        for (var X; ; )
          if (typeof (X = $()) < "u")
            return X || [];
    }
    function fe(I, P, f, y) {
      var v;
      if (typeof I != "string" || typeof P != "string")
        if (v = Error("Invalid string / salt: Not a string"), f) {
          p(f.bind(this, v));
          return;
        } else
          throw v;
      var M, B;
      if (P.charAt(0) !== "$" || P.charAt(1) !== "2")
        if (v = Error("Invalid salt version: " + P.substring(0, 2)), f) {
          p(f.bind(this, v));
          return;
        } else
          throw v;
      if (P.charAt(2) === "$")
        M = "\0", B = 3;
      else {
        if (M = P.charAt(2), M !== "a" && M !== "b" && M !== "y" || P.charAt(3) !== "$")
          if (v = Error("Invalid salt revision: " + P.substring(2, 4)), f) {
            p(f.bind(this, v));
            return;
          } else
            throw v;
        B = 4;
      }
      if (P.charAt(B + 2) > "$")
        if (v = Error("Missing salt rounds"), f) {
          p(f.bind(this, v));
          return;
        } else
          throw v;
      var S = parseInt(P.substring(B, B + 1), 10) * 10, _ = parseInt(P.substring(B + 1, B + 2), 10), E = S + _, m = P.substring(B + 3, B + 25);
      I += M >= "a" ? "\0" : "";
      var A = d(I), $ = T(m, q);
      function X(oe) {
        var J = [];
        return J.push("$2"), M >= "a" && J.push(M), J.push("$"), E < 10 && J.push("0"), J.push(E.toString()), J.push("$"), J.push(C($, $.length)), J.push(C(oe, z.length * 4 - 1)), J.join("");
      }
      if (typeof f > "u")
        return X(ie(A, $, E));
      ie(A, $, E, function(oe, J) {
        oe ? f(oe, null) : f(null, X(J));
      }, y);
    }
    return t.encodeBase64 = C, t.decodeBase64 = T, t;
  });
})(bcrypt$1);
var bcryptExports = bcrypt$1.exports;
const bcrypt = /* @__PURE__ */ getDefaultExportFromCjs(bcryptExports);
class FirebaseAuthAPI {
  constructor(t) {
    this.FIREBASE_AUTH_URL = "https://identitytoolkit.googleapis.com/v1/", this.BCRYPT_SALT = "$2a$10$QCJoWqnN.acrjPIgKYCthu";
    const o = new URL(this.FIREBASE_AUTH_URL);
    this.firebaseKey = t.apiKey, this.fetcher = new FetchAPI(o.toString());
  }
  checkError(t) {
    if (t.error)
      throw new Error(
        `Error code: ${t.error.code}, message: ${t.error.message}`
      );
  }
  async signUpWithEmailPassword(t, o, r = !0) {
    let h = o;
    r && (h = bcrypt.hashSync(o, this.BCRYPT_SALT));
    const a = JSON.stringify({
      email: t,
      password: h,
      returnSecureToken: !0
    }), p = await this.fetcher.send({
      url: "accounts:signUp",
      method: "POST",
      data: a,
      query: {
        key: this.firebaseKey
      },
      withCredentials: !1
    });
    return this.checkError(p.data), p.data;
  }
  async signInWithEmailPassword(t, o, r = !0) {
    let h = o;
    r && (h = bcrypt.hashSync(o, this.BCRYPT_SALT));
    const a = JSON.stringify({
      email: t,
      password: h,
      returnSecureToken: !0
    }), p = await this.fetcher.send({
      url: "accounts:signInWithPassword",
      method: "POST",
      data: a,
      query: {
        key: this.firebaseKey
      },
      withCredentials: !1
    });
    return this.checkError(p.data), p.data;
  }
  async getCurrentUser(t) {
    const o = JSON.stringify({
      idToken: t
    }), r = await this.fetcher.send({
      url: "accounts:lookup",
      method: "POST",
      data: o,
      query: {
        key: this.firebaseKey
      },
      withCredentials: !1
    });
    return this.checkError(r.data), r.data;
  }
  async getRefreshIdToken(t) {
    const o = JSON.stringify({
      grant_type: "refresh_token",
      refresh_token: t
    }), r = await this.fetcher.send({
      url: "token",
      method: "POST",
      data: o,
      query: {
        key: this.firebaseKey
      },
      withCredentials: !1
    }), h = r.data;
    return this.checkError(r.data), h.id_token;
  }
  async resetPassword(t, o, r = !0) {
    let h = o;
    r && (h = bcrypt.hashSync(o, this.BCRYPT_SALT));
    const a = JSON.stringify({
      oobCode: t,
      newPassword: h
    }), p = await this.fetcher.send({
      url: "accounts:resetPassword",
      method: "POST",
      data: a,
      query: {
        key: this.firebaseKey
      },
      withCredentials: !1
    });
    return this.checkError(p.data), p.data;
  }
  async verifyEmail(t) {
    const o = JSON.stringify({
      oobCode: t
    }), r = await this.fetcher.send({
      url: "accounts:update",
      method: "POST",
      data: o,
      query: {
        key: this.firebaseKey
      },
      withCredentials: !1
    });
    return this.checkError(r.data), r.data;
  }
  async signInWithCustomToken(t) {
    const o = JSON.stringify({
      token: t,
      returnSecureToken: !0
    }), r = await this.fetcher.send({
      url: "accounts:signInWithCustomToken",
      data: o,
      query: {
        key: this.firebaseKey
      },
      method: "POST",
      withCredentials: !1
    });
    return this.checkError(r.data), {
      idToken: r.data.idToken,
      refreshToken: r.data.refreshToken
    };
  }
  async updatePassword(t, o) {
    const r = bcrypt.hashSync(o, this.BCRYPT_SALT), h = JSON.stringify({
      idToken: t,
      password: r,
      returnSecureToken: !0
    }), a = await this.fetcher.send({
      url: "accounts:update",
      method: "POST",
      data: h,
      query: {
        key: this.firebaseKey
      },
      withCredentials: !1
    });
    return this.checkError(a.data), a.data;
  }
}
var u$1 = (e, t, o) => {
  if (!t.has(e))
    throw TypeError("Cannot " + o);
}, i$1 = (e, t, o) => (u$1(e, t, "read from private field"), o ? o.call(e) : t.get(e)), n$1 = (e, t, o) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, o);
}, l$1;
const s$1 = class sM {
  static getLocalStorageEnabled() {
    let t = !1;
    try {
      t = window.localStorage && !0;
    } catch {
      t = !1;
    }
    return t;
  }
  static setAllLocalStorage(t, o) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const r = JSON.stringify(o);
    localStorage.setItem(i$1(this, l$1) + t, r);
  }
  static setLocalStorage(t, o, r) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const h = this.getAllLocalStorage(t);
    if (h) {
      h[o] = r, localStorage.setItem(
        i$1(this, l$1) + t,
        // btoa(JSON.stringify(localData)),
        JSON.stringify(h)
      );
      return;
    }
    const a = { [o]: r };
    localStorage.setItem(
      i$1(this, l$1) + t,
      // btoa(JSON.stringify(newData)),
      JSON.stringify(a)
    );
  }
  static getLocalStorage(t, o) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const r = this.getAllLocalStorage(t);
    try {
      if (r)
        return JSON.parse(r[o]);
    } catch {
      return r[o];
    }
  }
  static getAllLocalStorage(t) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    try {
      return localStorage.getItem(i$1(this, l$1) + t) ? (
        // ? JSON.parse(atob(localStorage.getItem(this.#COOKIE_NAME + appId)))
        JSON.parse(localStorage.getItem(i$1(this, l$1) + t))
      ) : void 0;
    } catch {
      return;
    }
  }
  static clearLocalStorage(t, o) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    if (this.getLocalStorage(t, o)) {
      const r = this.getAllLocalStorage(t);
      delete r[o], localStorage.setItem(
        i$1(this, l$1) + t,
        // btoa(JSON.stringify(localData)),
        JSON.stringify(r)
      );
    }
  }
  static clearAllLocalStorage(t) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    localStorage.removeItem(i$1(this, l$1) + t);
  }
  static setLoginUserLocalStorage(t, o, r) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const h = {};
    return h["firebase:wepin"] = Object.assign(
      { provider: o == null ? void 0 : o.provider },
      o == null ? void 0 : o.token
    ), h["wepin:connectUser"] = {
      accessToken: r.token.access,
      refreshToken: r.token.refresh
    }, h.user_id = r.userInfo.userId, h.user_info = {
      status: "success",
      userInfo: {
        userId: r.userInfo.userId,
        email: r.userInfo.email,
        provider: o.provider,
        use2FA: r.userInfo.use2FA >= 2
      }
    }, h.user_status = {
      loginStatus: r.loginStatus,
      pinRequired: r.loginStatus === "registerRequired" ? r.pinRequired : !1
    }, r.loginStatus !== "pinRequired" && r.walletId && (h.wallet_id = r.walletId, h.user_info.walletId = r.walletId), h.oauth_provider_pending = o.provider, sM.setAllLocalStorage(t, h), {
      userInfo: h.user_info,
      connectUser: h["wepin:connectUser"]
    };
  }
};
l$1 = /* @__PURE__ */ new WeakMap(), s$1.platform = "web", n$1(s$1, l$1, "wepin:auth:");
let c$1 = s$1;
const isErrorResponse = (e) => {
  const t = e.statusCode !== void 0 || e.status !== void 0, o = e.timestamp !== void 0 && e.message !== void 0 && e.path !== void 0;
  return t && o;
}, getBaseUrl = (e) => {
  if (e.slice(0, 8) === "ak_live_")
    return "https://sdk.wepin.io/v1";
  if (e.slice(0, 8) === "ak_test_")
    return "https://stage-sdk.wepin.io/v1";
  if (e.slice(0, 7) === "ak_dev_")
    return "https://dev-sdk.wepin.io/v1";
  if (e.slice(0, 13) === "local_ak_dev_")
    return "https://local-sdk.wepin.io/v1";
  throw new Error("Invalid appKey");
};
class APIRequest {
  constructor({
    data: t,
    headers: o,
    url: r,
    query: h,
    withCredentials: a = !1,
    method: p
  }) {
    this.data = t, this.headers = o, this.url = r, this.query = h, this.withCredentials = a, this.method = p;
  }
}
const APIEvents = {
  request: "request",
  response: "response"
};
let InvalidTokenError$1 = class extends Error {
};
InvalidTokenError$1.prototype.name = "InvalidTokenError";
function b64DecodeUnicode$1(e) {
  return decodeURIComponent(atob(e).replace(/(.)/g, (t, o) => {
    let r = o.charCodeAt(0).toString(16).toUpperCase();
    return r.length < 2 && (r = "0" + r), "%" + r;
  }));
}
function base64UrlDecode$1(e) {
  let t = e.replace(/-/g, "+").replace(/_/g, "/");
  switch (t.length % 4) {
    case 0:
      break;
    case 2:
      t += "==";
      break;
    case 3:
      t += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode$1(t);
  } catch {
    return atob(t);
  }
}
function jwtDecode$1(e, t) {
  if (typeof e != "string")
    throw new InvalidTokenError$1("Invalid token specified: must be a string");
  t || (t = {});
  const o = t.header === !0 ? 0 : 1, r = e.split(".")[o];
  if (typeof r != "string")
    throw new InvalidTokenError$1(`Invalid token specified: missing part #${o + 1}`);
  let h;
  try {
    h = base64UrlDecode$1(r);
  } catch (a) {
    throw new InvalidTokenError$1(`Invalid token specified: invalid base64 for part #${o + 1} (${a.message})`);
  }
  try {
    return JSON.parse(h);
  } catch (a) {
    throw new InvalidTokenError$1(`Invalid token specified: invalid json for part #${o + 1} (${a.message})`);
  }
}
const checkJwtToken = () => {
  const e = (t) => {
    var o;
    const r = t;
    return !r || ((o = jwtDecode$1(r)) == null ? void 0 : o.exp) <= Math.floor(Date.now() / 1e3) + 60;
  };
  return {
    // isExpiredAccessToken,
    checkTokenExpired: (t, o) => {
      if (!(t === "/app/info" || t === "/user/login" || t === "/user/oauth") && e(o)) {
        if (t !== "/access-token")
          throw new Error("token_expired");
        return;
      }
    }
  };
};
class WepinSDKFetchAPI extends FetchAPI {
  constructor(t, o) {
    super(), this.baseUrl = t, this.params = o, this.addListener(APIEvents.request, this.requestCallback), this.addListener(APIEvents.response, this.responseCallback);
  }
  async send(t, o) {
    await this.emitAsync(APIEvents.request, t, o || {});
    const { data: r, url: h, headers: a } = t, p = (() => {
      if (r instanceof FormData)
        return {};
    })();
    t.headers = Object.assign(a || {}, p);
    const d = await super.send(t, o);
    return this.setToken(h, d), await this.emitAsync(
      APIEvents.response,
      d,
      o || {}
    ), d;
  }
  setToken(t, o) {
    var r, h, a, p, d, b;
    isErrorResponse(o.data) || (t === "user/login" && (r = o.data) != null && r.token ? this.params.wepinFetch.setToken({
      accessToken: (h = o.data) == null ? void 0 : h.token.access,
      refreshToken: (a = o.data) == null ? void 0 : a.token.refresh
    }) : t === "/user/access-token" && (p = o.data) != null && p.token ? this.params.wepinFetch.setToken({
      accessToken: (d = o.data) == null ? void 0 : d.token,
      refreshToken: (b = this.params.wepinFetch.Token) == null ? void 0 : b.refreshToken
    }) : t === "user/logout" && this.params.wepinFetch.setToken());
  }
  async requestCallback(t, o) {
    var r, h, a;
    try {
      t.headers || (t.headers = {}), t.headers["X-API-KEY"] = this.params.appKey;
      const p = this.params.domain && this.params.domain.includes("localhost") ? "" : this.params.domain;
      if (t.headers["X-SDK-TYPE"] = this.params.sdk.type, t.headers["X-SDK-VERSION"] = this.params.sdk.version, t.headers["X-API-DOMAIN"] = p, t.url === "/user/access-token" && (t.query = {
        refresh_token: (r = this.params.wepinFetch.Token) == null ? void 0 : r.refreshToken
      }), o != null && o.ignoreCheckToken)
        return;
      try {
        const b = (h = this.params.wepinFetch.Token) == null ? void 0 : h.accessToken, { checkTokenExpired: g } = checkJwtToken();
        g(t.url, b);
      } catch {
        const b = new APIRequest({
          url: "/user/access-token",
          method: "GET",
          withCredentials: !0
        });
        await this.send(b, { ignoreCheckToken: !0 });
      }
      const d = (a = this.params.wepinFetch.Token) == null ? void 0 : a.accessToken;
      d && (t.headers.Authorization = `Bearer ${d}`);
    } catch {
      throw new Error("Unauthorized Error");
    }
  }
  async responseCallback(t) {
    if (t.status === 401)
      throw new Error("Unauthorized Error");
  }
  // private setUserInfo(url: string, response: any) {
  //   if (!isErrorResponse(response.data) && response.data?.userInfo) {
  //     // set token
  //     if (url === 'user/login') {
  //       WepinStorage.setLocalStorage('userInfo', response.data?.userInfo)
  //       if (response.data?.walletId) {
  //         WepinStorage.setLocalStorage('walletId', response.data?.walletId)
  //       }
  //     } else if (url === '/app/register') {
  //       if (response.data?.walletId) {
  //         WepinStorage.setLocalStorage('walletId', response.data?.walletId)
  //       }
  //     }
  //   }
  // }
}
class UserAPI {
  constructor(t) {
    this.fetcher = t, this.basePath = "/user";
  }
  // 2.1 Check User Email
  async checkEmailExist(t) {
    const o = new APIRequest({
      url: `${this.basePath}/check-user`,
      method: "GET",
      query: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(o, {
      ignoreCheckToken: !0
    })).data;
  }
  // 2.2 Get User PW State
  async getUserPasswordState(t) {
    const o = new APIRequest({
      url: `${this.basePath}/password-state`,
      method: "GET",
      query: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(o, {
      ignoreCheckToken: !0
    })).data;
  }
  // 2.3 Provider Login
  async oAuth(t, o) {
    const r = new APIRequest({
      url: `${this.basePath}/oauth/login/${o.provider}`,
      method: "GET",
      query: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(r, {
      ignoreCheckToken: !0
    })).data;
  }
  // 2.4 Verify User Email
  async verify(t) {
    const o = new APIRequest({
      url: `${this.basePath}/verify`,
      method: "POST",
      data: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(o, {
      ignoreCheckToken: !0
    })).data;
  }
  // 2.5 Login
  async login(t) {
    const o = new APIRequest({
      url: `${this.basePath}/login`,
      method: "POST",
      data: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(o, { ignoreCheckToken: !0 })).data;
  }
  // 2.6 Update User PW State
  async updateUserPasswordState(t, o) {
    const r = new APIRequest({
      url: `${this.basePath}/${t.userId}/password-state`,
      method: "PATCH",
      data: o,
      withCredentials: !0
    });
    return (await this.fetcher.send(r)).data;
  }
  // 2.7 Update Terms Accepted
  async updateTermsAccepted(t, o) {
    const r = new APIRequest({
      url: `${this.basePath}/${t.userId}/terms-accepted`,
      method: "PATCH",
      data: o,
      withCredentials: !0
    });
    return (await this.fetcher.send(r)).data;
  }
  // 2.8 Get Access Token
  async refreshToken() {
    const t = new APIRequest({
      url: `${this.basePath}/access-token`,
      method: "GET",
      // query: {
      //   refresh_token: WepinStorage.getLocalStorage('token')?.refreshToken,
      // },
      withCredentials: !0
    });
    return (await this.fetcher.send(t, { ignoreCheckToken: !0 })).data;
  }
  // 2.9 Get Public Key
  async fetchKey() {
    const t = new APIRequest({
      url: `${this.basePath}/pubkey`,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(t)).data;
  }
  // 2.11 Get Terms Accepted
  async getTermsAccepted(t) {
    const o = new APIRequest({
      url: `${this.basePath}/${t.userId}/terms-accepted`,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(o)).data;
  }
  // 2.12 Logout
  async logout(t) {
    const o = new APIRequest({
      url: `${this.basePath}/${t.userId}/logout`,
      method: "POST",
      withCredentials: !0
    });
    return (await this.fetcher.send(o)).data;
  }
  // 2.13 Get Firebase Config
  async getFirebaseConfig() {
    const t = new APIRequest({
      url: `${this.basePath}/firebase-config`,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(t, { ignoreCheckToken: !0 })).data;
  }
  // 2.14 Login OAuth idToken
  async loginOAuthIdToken(t) {
    const o = new APIRequest({
      url: `${this.basePath}/oauth/login/id-token`,
      method: "POST",
      data: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(o, { ignoreCheckToken: !0 })).data;
  }
  // 2.15 Login OAuth AccessToken
  async loginOAuthAccessToken(t) {
    const o = new APIRequest({
      url: `${this.basePath}/oauth/login/access-token`,
      method: "POST",
      data: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(o, { ignoreCheckToken: !0 })).data;
  }
  // 2.18 Get User Info
  async getUserInfo(t) {
    const o = new APIRequest({
      url: `${this.basePath}/${t.userId}/detail`,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(o)).data;
  }
}
class WalletAPI {
  constructor(t) {
    this.fetcher = t, this.basePath = "/wallet";
  }
  // 3.1 Verify Wallet PIN
  async verifyPin(t) {
    const o = new APIRequest({
      url: `${this.basePath}/pin/verify`,
      data: t,
      method: "POST",
      withCredentials: !0
    });
    return (await this.fetcher.send(o)).data;
  }
  // 3.2 Change Wallet PIN
  async changePin(t) {
    const o = new APIRequest({
      url: `${this.basePath}/pin/change`,
      data: t,
      method: "PATCH",
      withCredentials: !0
    });
    return (await this.fetcher.send(o)).data;
  }
  // 3.3 Get Wallet Info
  async fetchWalletInfo(t, o) {
    const r = new APIRequest({
      url: `${this.basePath}/${t.walletId}`,
      query: o,
      method: "PATCH",
      withCredentials: !0
    });
    return (await this.fetcher.send(r)).data;
  }
  // 3.4 Get Wallet Key Info
  async getWalletKeyInfo(t, o) {
    const r = new APIRequest({
      url: `${this.basePath}/${t.walletId}/wallet-keyinfo`,
      query: o,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(r)).data;
  }
  // 3.5 Reset Wallet PIN Try Count
  async resetPinTryCount(t, o) {
    const r = new APIRequest({
      url: `${this.basePath}/${t.walletId}/pin/reset-try-count`,
      query: o,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(r)).data;
  }
}
class AppAPI {
  constructor(t) {
    this.fetcher = t, this.basePath = "/app";
  }
  // 1.1 Get Theme
  async getThemeById(t) {
    return (await fetch(`${this.fetcher.baseUrl}/app/theme/${t.id}`, {
      method: "GET"
    })).json();
  }
  async getLayoutById(t) {
    return (await fetch(`${this.fetcher.baseUrl}/app/layout/${t.id}`, {
      method: "GET"
    })).json();
  }
  // 1.3 Get App Info
  async getAppInfo(t) {
    const o = new APIRequest({
      url: `${this.basePath}/info`,
      query: t,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(o, {
      ignoreCheckToken: !0
    })).data;
  }
  // 1.4 Get App Coins
  async getAppCoins(t) {
    const o = new APIRequest({
      url: `${this.basePath}/coins`,
      method: "GET",
      query: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(o, {
      ignoreCheckToken: !0
    })).data;
  }
  // 1.5 Get App Theme
  async getAppTheme() {
    const t = new APIRequest({
      url: `${this.basePath}/theme`,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(t, {
      ignoreCheckToken: !0
    })).data;
  }
  // 1.6 Register
  async register(t) {
    const o = new APIRequest({
      url: `${this.basePath}/register`,
      method: "POST",
      data: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(o)).data;
  }
}
class AccountAPI {
  constructor(t) {
    this.fetcher = t, this.basePath = "/account";
  }
  // 4.1 Readdress
  async readdress(t) {
    const o = new APIRequest({
      url: `${this.basePath}/readdress`,
      data: t,
      method: "PATCH",
      withCredentials: !0
    });
    return (await this.fetcher.send(o)).data;
  }
  // 4.2 Get App Account
  async getAppAccountList(t) {
    const o = new APIRequest({
      url: `${this.basePath}`,
      query: t,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(o)).data;
  }
}
class AccountBalanceAPI {
  constructor(t) {
    this.fetcher = t, this.basePath = "/accountbalance";
  }
  // 5.1 Get Account Balance
  async getAccountBalance(t) {
    const o = new APIRequest({
      url: `${this.basePath}/${t.accountId}/balance`,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(o)).data;
  }
}
class NFTAPI {
  constructor(t) {
    this.fetcher = t, this.basePath = "/nft";
  }
  // 6.1 Get NFT supporting network list
  async getSupportingNetworkList() {
    const t = new APIRequest({
      url: `${this.basePath}/support-network`,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(t, {
      // ignoreCheckToken: true,
    })).data;
  }
  // 6.2 Get App NFTs
  async getAppNFTList(t) {
    const o = new APIRequest({
      url: this.basePath,
      method: "GET",
      query: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(o)).data;
  }
  // 6.3 Refresh NFTs
  async refreshAppNFTList(t) {
    const o = new APIRequest({
      url: `${this.basePath}/refresh`,
      method: "GET",
      query: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(o)).data;
  }
}
class TransactionAPI {
  constructor(t) {
    this.fetcher = t, this.basePath = "/tx";
  }
  // 7.1 Sign transaction
  async sign(t) {
    const o = new APIRequest({
      url: `${this.basePath}/sign`,
      data: t,
      method: "POST",
      withCredentials: !0
    });
    return (await this.fetcher.send(o)).data;
  }
  // 7.2 Broadcast Transaction
  async broadCast(t) {
    const o = new APIRequest({
      url: `${this.basePath}/broadcast`,
      data: t,
      method: "POST",
      withCredentials: !0
    });
    return (await this.fetcher.send(o)).data;
  }
  // 7.3 Get prepare transaction data
  async prepareTransaction(t) {
    const o = new APIRequest({
      url: `${this.basePath}/prepare`,
      data: t,
      method: "POST",
      withCredentials: !0
    });
    return (await this.fetcher.send(o)).data;
  }
  // 7.4 Check Address validation
  async checkAddressValidation(t) {
    const o = new APIRequest({
      url: `${this.basePath}/check_address`,
      query: t,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(o)).data;
  }
}
class WepinSdkAPI {
  constructor(t, o) {
    const r = new WepinSDKFetchAPI(t, o);
    this.app = new AppAPI(r), this.user = new UserAPI(r), this.wallet = new WalletAPI(r), this.account = new AccountAPI(r), this.balance = new AccountBalanceAPI(r), this.nft = new NFTAPI(r), this.transaction = new TransactionAPI(r);
  }
}
class WepinFetch {
  constructor({
    appId: t,
    appKey: o,
    domain: r,
    sdk: h,
    storage: a
  }) {
    this.version = packageJson.version, this.appId = t, this._appKey = o, this._domain = r, this._token = void 0, this.sdk = h, this._wepinStorage = a ?? c$1;
  }
  async init() {
    const t = await WepinFetch.getFirebaseConfig(
      this._appKey,
      this.sdk.type,
      this.sdk.version
    );
    this.wepinFirebaseApi = new FirebaseAuthAPI(t), this.wepinApi = new WepinSdkAPI(getBaseUrl(this._appKey), {
      appId: this.appId,
      appKey: this._appKey,
      domain: this._domain,
      sdk: this.sdk,
      wepinFetch: this
    }), this._isInitialized = !0;
  }
  isInitialized() {
    return this._isInitialized;
  }
  static async getFirebaseConfig(t, o, r) {
    const h = getBaseUrl(t), a = await (await fetch(`${h}/user/firebase-config`, {
      method: "GET",
      headers: {
        "X-API-KEY": t,
        "X-SDK-TYPE": o,
        "X-SDK-VERSION": r,
        "Content-Type": "application/json"
      }
    })).text();
    return JSON.parse(atob(a));
  }
  get Token() {
    return this._token = this._wepinStorage.getLocalStorage(
      this.appId,
      "wepin:connectUser"
    ), this._token;
  }
  setToken(t) {
    this._token = t, t ? this._wepinStorage.setLocalStorage(this.appId, "wepin:connectUser", t) : this._wepinStorage.clearLocalStorage(this.appId, "wepin:connectUser");
  }
  // public finalize() {
  //   this._wepinStorage.clearLocalStorage(this.appId, 'wepin:connectUser')
  // }
}
var ProjectPlatformKind = /* @__PURE__ */ ((e) => (e[e.web = 1] = "web", e[e.android = 2] = "android", e[e.ios = 3] = "ios", e))(ProjectPlatformKind || {});
class InvalidTokenError extends Error {
}
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(e) {
  return decodeURIComponent(atob(e).replace(/(.)/g, (t, o) => {
    let r = o.charCodeAt(0).toString(16).toUpperCase();
    return r.length < 2 && (r = "0" + r), "%" + r;
  }));
}
function base64UrlDecode(e) {
  let t = e.replace(/-/g, "+").replace(/_/g, "/");
  switch (t.length % 4) {
    case 0:
      break;
    case 2:
      t += "==";
      break;
    case 3:
      t += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode(t);
  } catch {
    return atob(t);
  }
}
function jwtDecode(e, t) {
  if (typeof e != "string")
    throw new InvalidTokenError("Invalid token specified: must be a string");
  t || (t = {});
  const o = t.header === !0 ? 0 : 1, r = e.split(".")[o];
  if (typeof r != "string")
    throw new InvalidTokenError(`Invalid token specified: missing part #${o + 1}`);
  let h;
  try {
    h = base64UrlDecode(r);
  } catch (a) {
    throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${o + 1} (${a.message})`);
  }
  try {
    return JSON.parse(h);
  } catch (a) {
    throw new InvalidTokenError(`Invalid token specified: invalid json for part #${o + 1} (${a.message})`);
  }
}
const getAccountSDK = (e) => {
  let t = [];
  return e != null && e.length && (t = e.map((o) => o.contract && o.accountTokenId ? {
    network: o.network,
    address: o.address,
    contract: o.contract,
    isAA: o.isAA
    // name: account.name,
  } : {
    network: o.network,
    address: o.address,
    isAA: o.isAA
  })), t;
}, filterAccountList = (e, t) => {
  const { accounts: o, aa_accounts: r } = e;
  return t ? r ? o.concat(r) : o : o.map((a) => {
    const p = r == null ? void 0 : r.find(
      (d) => d.coinId === a.coinId && (d == null ? void 0 : d.contract) === (a == null ? void 0 : a.contract) && (d == null ? void 0 : d.eoaAddress) === a.address
    );
    return p || a;
  });
};
var u = (e, t, o) => {
  if (!t.has(e))
    throw TypeError("Cannot " + o);
}, i = (e, t, o) => (u(e, t, "read from private field"), o ? o.call(e) : t.get(e)), n = (e, t, o) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, o);
}, l;
const s = class uM {
  static getLocalStorageEnabled() {
    let t = !1;
    try {
      t = window.localStorage && !0;
    } catch {
      t = !1;
    }
    return t;
  }
  static setAllLocalStorage(t, o) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const r = JSON.stringify(o);
    localStorage.setItem(i(this, l) + t, r);
  }
  static setLocalStorage(t, o, r) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const h = this.getAllLocalStorage(t);
    if (h) {
      h[o] = r, localStorage.setItem(
        i(this, l) + t,
        // btoa(JSON.stringify(localData)),
        JSON.stringify(h)
      );
      return;
    }
    const a = { [o]: r };
    localStorage.setItem(
      i(this, l) + t,
      // btoa(JSON.stringify(newData)),
      JSON.stringify(a)
    );
  }
  static getLocalStorage(t, o) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const r = this.getAllLocalStorage(t);
    try {
      if (r)
        return JSON.parse(r[o]);
    } catch {
      return r[o];
    }
  }
  static getAllLocalStorage(t) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    try {
      return localStorage.getItem(i(this, l) + t) ? (
        // ? JSON.parse(atob(localStorage.getItem(this.#COOKIE_NAME + appId)))
        JSON.parse(localStorage.getItem(i(this, l) + t))
      ) : void 0;
    } catch {
      return;
    }
  }
  static clearLocalStorage(t, o) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    if (this.getLocalStorage(t, o)) {
      const r = this.getAllLocalStorage(t);
      delete r[o], localStorage.setItem(
        i(this, l) + t,
        // btoa(JSON.stringify(localData)),
        JSON.stringify(r)
      );
    }
  }
  static clearAllLocalStorage(t) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    localStorage.removeItem(i(this, l) + t);
  }
  static setLoginUserLocalStorage(t, o, r) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const h = {};
    return h["firebase:wepin"] = Object.assign(
      { provider: o == null ? void 0 : o.provider },
      o == null ? void 0 : o.token
    ), h["wepin:connectUser"] = {
      accessToken: r.token.access,
      refreshToken: r.token.refresh
    }, h.user_id = r.userInfo.userId, h.user_info = {
      status: "success",
      userInfo: {
        userId: r.userInfo.userId,
        email: r.userInfo.email,
        provider: o.provider,
        use2FA: r.userInfo.use2FA >= 2
      }
    }, h.user_status = {
      loginStatus: r.loginStatus,
      pinRequired: r.loginStatus === "registerRequired" ? r.pinRequired : !1
    }, r.loginStatus !== "pinRequired" && r.walletId && (h.wallet_id = r.walletId, h.user_info.walletId = r.walletId), h.oauth_provider_pending = o.provider, uM.setAllLocalStorage(t, h), {
      userInfo: h.user_info,
      connectUser: h["wepin:connectUser"]
    };
  }
};
l = /* @__PURE__ */ new WeakMap(), s.platform = "web", n(s, l, "wepin:auth:");
let c = s;
var Me = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof _global < "u" ? _global : typeof self < "u" ? self : {};
function Gs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var pe = {}, zs = {};
zs.byteLength = cg;
zs.toByteArray = lg;
zs.fromByteArray = vg;
var Pi = [], Ur = [], og = typeof Uint8Array < "u" ? Uint8Array : Array, Gf = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var ca = 0, ug = Gf.length; ca < ug; ++ca)
  Pi[ca] = Gf[ca], Ur[Gf.charCodeAt(ca)] = ca;
Ur[45] = 62;
Ur[95] = 63;
function n1(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var o = e.indexOf("=");
  o === -1 && (o = t);
  var r = o === t ? 0 : 4 - o % 4;
  return [o, r];
}
function cg(e) {
  var t = n1(e), o = t[0], r = t[1];
  return (o + r) * 3 / 4 - r;
}
function hg(e, t, o) {
  return (t + o) * 3 / 4 - o;
}
function lg(e) {
  var t, o = n1(e), r = o[0], h = o[1], a = new og(hg(e, r, h)), p = 0, d = h > 0 ? r - 4 : r, b;
  for (b = 0; b < d; b += 4)
    t = Ur[e.charCodeAt(b)] << 18 | Ur[e.charCodeAt(b + 1)] << 12 | Ur[e.charCodeAt(b + 2)] << 6 | Ur[e.charCodeAt(b + 3)], a[p++] = t >> 16 & 255, a[p++] = t >> 8 & 255, a[p++] = t & 255;
  return h === 2 && (t = Ur[e.charCodeAt(b)] << 2 | Ur[e.charCodeAt(b + 1)] >> 4, a[p++] = t & 255), h === 1 && (t = Ur[e.charCodeAt(b)] << 10 | Ur[e.charCodeAt(b + 1)] << 4 | Ur[e.charCodeAt(b + 2)] >> 2, a[p++] = t >> 8 & 255, a[p++] = t & 255), a;
}
function dg(e) {
  return Pi[e >> 18 & 63] + Pi[e >> 12 & 63] + Pi[e >> 6 & 63] + Pi[e & 63];
}
function pg(e, t, o) {
  for (var r, h = [], a = t; a < o; a += 3)
    r = (e[a] << 16 & 16711680) + (e[a + 1] << 8 & 65280) + (e[a + 2] & 255), h.push(dg(r));
  return h.join("");
}
function vg(e) {
  for (var t, o = e.length, r = o % 3, h = [], a = 16383, p = 0, d = o - r; p < d; p += a)
    h.push(pg(e, p, p + a > d ? d : p + a));
  return r === 1 ? (t = e[o - 1], h.push(
    Pi[t >> 2] + Pi[t << 4 & 63] + "=="
  )) : r === 2 && (t = (e[o - 2] << 8) + e[o - 1], h.push(
    Pi[t >> 10] + Pi[t >> 4 & 63] + Pi[t << 2 & 63] + "="
  )), h.join("");
}
var Oc = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Oc.read = function(e, t, o, r, h) {
  var a, p, d = h * 8 - r - 1, b = (1 << d) - 1, g = b >> 1, w = -7, C = o ? h - 1 : 0, T = o ? -1 : 1, k = e[t + C];
  for (C += T, a = k & (1 << -w) - 1, k >>= -w, w += d; w > 0; a = a * 256 + e[t + C], C += T, w -= 8)
    ;
  for (p = a & (1 << -w) - 1, a >>= -w, w += r; w > 0; p = p * 256 + e[t + C], C += T, w -= 8)
    ;
  if (a === 0)
    a = 1 - g;
  else {
    if (a === b)
      return p ? NaN : (k ? -1 : 1) * (1 / 0);
    p = p + Math.pow(2, r), a = a - g;
  }
  return (k ? -1 : 1) * p * Math.pow(2, a - r);
};
Oc.write = function(e, t, o, r, h, a) {
  var p, d, b, g = a * 8 - h - 1, w = (1 << g) - 1, C = w >> 1, T = h === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, k = r ? 0 : a - 1, q = r ? 1 : -1, O = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (d = isNaN(t) ? 1 : 0, p = w) : (p = Math.floor(Math.log(t) / Math.LN2), t * (b = Math.pow(2, -p)) < 1 && (p--, b *= 2), p + C >= 1 ? t += T / b : t += T * Math.pow(2, 1 - C), t * b >= 2 && (p++, b /= 2), p + C >= w ? (d = 0, p = w) : p + C >= 1 ? (d = (t * b - 1) * Math.pow(2, h), p = p + C) : (d = t * Math.pow(2, C - 1) * Math.pow(2, h), p = 0)); h >= 8; e[o + k] = d & 255, k += q, d /= 256, h -= 8)
    ;
  for (p = p << h | d, g += h; g > 0; e[o + k] = p & 255, k += q, p /= 256, g -= 8)
    ;
  e[o + k - q] |= O * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  var t = zs, o = Oc, r = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = d, e.SlowBuffer = U, e.INSPECT_MAX_BYTES = 50;
  var h = 2147483647;
  e.kMaxLength = h, d.TYPED_ARRAY_SUPPORT = a(), !d.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function a() {
    try {
      var x = new Uint8Array(1), L = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(L, Uint8Array.prototype), Object.setPrototypeOf(x, L), x.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(d.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (d.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(d.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (d.isBuffer(this))
        return this.byteOffset;
    }
  });
  function p(x) {
    if (x > h)
      throw new RangeError('The value "' + x + '" is invalid for option "size"');
    var L = new Uint8Array(x);
    return Object.setPrototypeOf(L, d.prototype), L;
  }
  function d(x, L, D) {
    if (typeof x == "number") {
      if (typeof L == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return C(x);
    }
    return b(x, L, D);
  }
  d.poolSize = 8192;
  function b(x, L, D) {
    if (typeof x == "string")
      return T(x, L);
    if (ArrayBuffer.isView(x))
      return q(x);
    if (x == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof x
      );
    if (de(x, ArrayBuffer) || x && de(x.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (de(x, SharedArrayBuffer) || x && de(x.buffer, SharedArrayBuffer)))
      return O(x, L, D);
    if (typeof x == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    var F = x.valueOf && x.valueOf();
    if (F != null && F !== x)
      return d.from(F, L, D);
    var ue = N(x);
    if (ue)
      return ue;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof x[Symbol.toPrimitive] == "function")
      return d.from(
        x[Symbol.toPrimitive]("string"),
        L,
        D
      );
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof x
    );
  }
  d.from = function(x, L, D) {
    return b(x, L, D);
  }, Object.setPrototypeOf(d.prototype, Uint8Array.prototype), Object.setPrototypeOf(d, Uint8Array);
  function g(x) {
    if (typeof x != "number")
      throw new TypeError('"size" argument must be of type number');
    if (x < 0)
      throw new RangeError('The value "' + x + '" is invalid for option "size"');
  }
  function w(x, L, D) {
    return g(x), x <= 0 ? p(x) : L !== void 0 ? typeof D == "string" ? p(x).fill(L, D) : p(x).fill(L) : p(x);
  }
  d.alloc = function(x, L, D) {
    return w(x, L, D);
  };
  function C(x) {
    return g(x), p(x < 0 ? 0 : j(x) | 0);
  }
  d.allocUnsafe = function(x) {
    return C(x);
  }, d.allocUnsafeSlow = function(x) {
    return C(x);
  };
  function T(x, L) {
    if ((typeof L != "string" || L === "") && (L = "utf8"), !d.isEncoding(L))
      throw new TypeError("Unknown encoding: " + L);
    var D = H(x, L) | 0, F = p(D), ue = F.write(x, L);
    return ue !== D && (F = F.slice(0, ue)), F;
  }
  function k(x) {
    for (var L = x.length < 0 ? 0 : j(x.length) | 0, D = p(L), F = 0; F < L; F += 1)
      D[F] = x[F] & 255;
    return D;
  }
  function q(x) {
    if (de(x, Uint8Array)) {
      var L = new Uint8Array(x);
      return O(L.buffer, L.byteOffset, L.byteLength);
    }
    return k(x);
  }
  function O(x, L, D) {
    if (L < 0 || x.byteLength < L)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (x.byteLength < L + (D || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var F;
    return L === void 0 && D === void 0 ? F = new Uint8Array(x) : D === void 0 ? F = new Uint8Array(x, L) : F = new Uint8Array(x, L, D), Object.setPrototypeOf(F, d.prototype), F;
  }
  function N(x) {
    if (d.isBuffer(x)) {
      var L = j(x.length) | 0, D = p(L);
      return D.length === 0 || x.copy(D, 0, 0, L), D;
    }
    if (x.length !== void 0)
      return typeof x.length != "number" || Ae(x.length) ? p(0) : k(x);
    if (x.type === "Buffer" && Array.isArray(x.data))
      return k(x.data);
  }
  function j(x) {
    if (x >= h)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + h.toString(16) + " bytes");
    return x | 0;
  }
  function U(x) {
    return +x != x && (x = 0), d.alloc(+x);
  }
  d.isBuffer = function(x) {
    return x != null && x._isBuffer === !0 && x !== d.prototype;
  }, d.compare = function(x, L) {
    if (de(x, Uint8Array) && (x = d.from(x, x.offset, x.byteLength)), de(L, Uint8Array) && (L = d.from(L, L.offset, L.byteLength)), !d.isBuffer(x) || !d.isBuffer(L))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (x === L)
      return 0;
    for (var D = x.length, F = L.length, ue = 0, ge = Math.min(D, F); ue < ge; ++ue)
      if (x[ue] !== L[ue]) {
        D = x[ue], F = L[ue];
        break;
      }
    return D < F ? -1 : F < D ? 1 : 0;
  }, d.isEncoding = function(x) {
    switch (String(x).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, d.concat = function(x, L) {
    if (!Array.isArray(x))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (x.length === 0)
      return d.alloc(0);
    var D;
    if (L === void 0)
      for (L = 0, D = 0; D < x.length; ++D)
        L += x[D].length;
    var F = d.allocUnsafe(L), ue = 0;
    for (D = 0; D < x.length; ++D) {
      var ge = x[D];
      if (de(ge, Uint8Array))
        ue + ge.length > F.length ? d.from(ge).copy(F, ue) : Uint8Array.prototype.set.call(
          F,
          ge,
          ue
        );
      else if (d.isBuffer(ge))
        ge.copy(F, ue);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      ue += ge.length;
    }
    return F;
  };
  function H(x, L) {
    if (d.isBuffer(x))
      return x.length;
    if (ArrayBuffer.isView(x) || de(x, ArrayBuffer))
      return x.byteLength;
    if (typeof x != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof x
      );
    var D = x.length, F = arguments.length > 2 && arguments[2] === !0;
    if (!F && D === 0)
      return 0;
    for (var ue = !1; ; )
      switch (L) {
        case "ascii":
        case "latin1":
        case "binary":
          return D;
        case "utf8":
        case "utf-8":
          return Q(x).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return D * 2;
        case "hex":
          return D >>> 1;
        case "base64":
          return Y(x).length;
        default:
          if (ue)
            return F ? -1 : Q(x).length;
          L = ("" + L).toLowerCase(), ue = !0;
      }
  }
  d.byteLength = H;
  function z(x, L, D) {
    var F = !1;
    if ((L === void 0 || L < 0) && (L = 0), L > this.length || ((D === void 0 || D > this.length) && (D = this.length), D <= 0) || (D >>>= 0, L >>>= 0, D <= L))
      return "";
    for (x || (x = "utf8"); ; )
      switch (x) {
        case "hex":
          return _(this, L, D);
        case "utf8":
        case "utf-8":
          return y(this, L, D);
        case "ascii":
          return B(this, L, D);
        case "latin1":
        case "binary":
          return S(this, L, D);
        case "base64":
          return f(this, L, D);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return E(this, L, D);
        default:
          if (F)
            throw new TypeError("Unknown encoding: " + x);
          x = (x + "").toLowerCase(), F = !0;
      }
  }
  d.prototype._isBuffer = !0;
  function ee(x, L, D) {
    var F = x[L];
    x[L] = x[D], x[D] = F;
  }
  d.prototype.swap16 = function() {
    var x = this.length;
    if (x % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var L = 0; L < x; L += 2)
      ee(this, L, L + 1);
    return this;
  }, d.prototype.swap32 = function() {
    var x = this.length;
    if (x % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var L = 0; L < x; L += 4)
      ee(this, L, L + 3), ee(this, L + 1, L + 2);
    return this;
  }, d.prototype.swap64 = function() {
    var x = this.length;
    if (x % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var L = 0; L < x; L += 8)
      ee(this, L, L + 7), ee(this, L + 1, L + 6), ee(this, L + 2, L + 5), ee(this, L + 3, L + 4);
    return this;
  }, d.prototype.toString = function() {
    var x = this.length;
    return x === 0 ? "" : arguments.length === 0 ? y(this, 0, x) : z.apply(this, arguments);
  }, d.prototype.toLocaleString = d.prototype.toString, d.prototype.equals = function(x) {
    if (!d.isBuffer(x))
      throw new TypeError("Argument must be a Buffer");
    return this === x ? !0 : d.compare(this, x) === 0;
  }, d.prototype.inspect = function() {
    var x = "", L = e.INSPECT_MAX_BYTES;
    return x = this.toString("hex", 0, L).replace(/(.{2})/g, "$1 ").trim(), this.length > L && (x += " ... "), "<Buffer " + x + ">";
  }, r && (d.prototype[r] = d.prototype.inspect), d.prototype.compare = function(x, L, D, F, ue) {
    if (de(x, Uint8Array) && (x = d.from(x, x.offset, x.byteLength)), !d.isBuffer(x))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof x
      );
    if (L === void 0 && (L = 0), D === void 0 && (D = x ? x.length : 0), F === void 0 && (F = 0), ue === void 0 && (ue = this.length), L < 0 || D > x.length || F < 0 || ue > this.length)
      throw new RangeError("out of range index");
    if (F >= ue && L >= D)
      return 0;
    if (F >= ue)
      return -1;
    if (L >= D)
      return 1;
    if (L >>>= 0, D >>>= 0, F >>>= 0, ue >>>= 0, this === x)
      return 0;
    for (var ge = ue - F, ce = D - L, ve = Math.min(ge, ce), Re = this.slice(F, ue), ke = x.slice(L, D), Ce = 0; Ce < ve; ++Ce)
      if (Re[Ce] !== ke[Ce]) {
        ge = Re[Ce], ce = ke[Ce];
        break;
      }
    return ge < ce ? -1 : ce < ge ? 1 : 0;
  };
  function ne(x, L, D, F, ue) {
    if (x.length === 0)
      return -1;
    if (typeof D == "string" ? (F = D, D = 0) : D > 2147483647 ? D = 2147483647 : D < -2147483648 && (D = -2147483648), D = +D, Ae(D) && (D = ue ? 0 : x.length - 1), D < 0 && (D = x.length + D), D >= x.length) {
      if (ue)
        return -1;
      D = x.length - 1;
    } else if (D < 0)
      if (ue)
        D = 0;
      else
        return -1;
    if (typeof L == "string" && (L = d.from(L, F)), d.isBuffer(L))
      return L.length === 0 ? -1 : le(x, L, D, F, ue);
    if (typeof L == "number")
      return L = L & 255, typeof Uint8Array.prototype.indexOf == "function" ? ue ? Uint8Array.prototype.indexOf.call(x, L, D) : Uint8Array.prototype.lastIndexOf.call(x, L, D) : le(x, [L], D, F, ue);
    throw new TypeError("val must be string, number or Buffer");
  }
  function le(x, L, D, F, ue) {
    var ge = 1, ce = x.length, ve = L.length;
    if (F !== void 0 && (F = String(F).toLowerCase(), F === "ucs2" || F === "ucs-2" || F === "utf16le" || F === "utf-16le")) {
      if (x.length < 2 || L.length < 2)
        return -1;
      ge = 2, ce /= 2, ve /= 2, D /= 2;
    }
    function Re(Pe, et) {
      return ge === 1 ? Pe[et] : Pe.readUInt16BE(et * ge);
    }
    var ke;
    if (ue) {
      var Ce = -1;
      for (ke = D; ke < ce; ke++)
        if (Re(x, ke) === Re(L, Ce === -1 ? 0 : ke - Ce)) {
          if (Ce === -1 && (Ce = ke), ke - Ce + 1 === ve)
            return Ce * ge;
        } else
          Ce !== -1 && (ke -= ke - Ce), Ce = -1;
    } else
      for (D + ve > ce && (D = ce - ve), ke = D; ke >= 0; ke--) {
        for (var Le = !0, Oe = 0; Oe < ve; Oe++)
          if (Re(x, ke + Oe) !== Re(L, Oe)) {
            Le = !1;
            break;
          }
        if (Le)
          return ke;
      }
    return -1;
  }
  d.prototype.includes = function(x, L, D) {
    return this.indexOf(x, L, D) !== -1;
  }, d.prototype.indexOf = function(x, L, D) {
    return ne(this, x, L, D, !0);
  }, d.prototype.lastIndexOf = function(x, L, D) {
    return ne(this, x, L, D, !1);
  };
  function Z(x, L, D, F) {
    D = Number(D) || 0;
    var ue = x.length - D;
    F ? (F = Number(F), F > ue && (F = ue)) : F = ue;
    var ge = L.length;
    F > ge / 2 && (F = ge / 2);
    for (var ce = 0; ce < F; ++ce) {
      var ve = parseInt(L.substr(ce * 2, 2), 16);
      if (Ae(ve))
        return ce;
      x[D + ce] = ve;
    }
    return ce;
  }
  function ie(x, L, D, F) {
    return re(Q(L, x.length - D), x, D, F);
  }
  function fe(x, L, D, F) {
    return re(me(L), x, D, F);
  }
  function I(x, L, D, F) {
    return re(Y(L), x, D, F);
  }
  function P(x, L, D, F) {
    return re(be(L, x.length - D), x, D, F);
  }
  d.prototype.write = function(x, L, D, F) {
    if (L === void 0)
      F = "utf8", D = this.length, L = 0;
    else if (D === void 0 && typeof L == "string")
      F = L, D = this.length, L = 0;
    else if (isFinite(L))
      L = L >>> 0, isFinite(D) ? (D = D >>> 0, F === void 0 && (F = "utf8")) : (F = D, D = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    var ue = this.length - L;
    if ((D === void 0 || D > ue) && (D = ue), x.length > 0 && (D < 0 || L < 0) || L > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    F || (F = "utf8");
    for (var ge = !1; ; )
      switch (F) {
        case "hex":
          return Z(this, x, L, D);
        case "utf8":
        case "utf-8":
          return ie(this, x, L, D);
        case "ascii":
        case "latin1":
        case "binary":
          return fe(this, x, L, D);
        case "base64":
          return I(this, x, L, D);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return P(this, x, L, D);
        default:
          if (ge)
            throw new TypeError("Unknown encoding: " + F);
          F = ("" + F).toLowerCase(), ge = !0;
      }
  }, d.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function f(x, L, D) {
    return L === 0 && D === x.length ? t.fromByteArray(x) : t.fromByteArray(x.slice(L, D));
  }
  function y(x, L, D) {
    D = Math.min(x.length, D);
    for (var F = [], ue = L; ue < D; ) {
      var ge = x[ue], ce = null, ve = ge > 239 ? 4 : ge > 223 ? 3 : ge > 191 ? 2 : 1;
      if (ue + ve <= D) {
        var Re, ke, Ce, Le;
        switch (ve) {
          case 1:
            ge < 128 && (ce = ge);
            break;
          case 2:
            Re = x[ue + 1], (Re & 192) === 128 && (Le = (ge & 31) << 6 | Re & 63, Le > 127 && (ce = Le));
            break;
          case 3:
            Re = x[ue + 1], ke = x[ue + 2], (Re & 192) === 128 && (ke & 192) === 128 && (Le = (ge & 15) << 12 | (Re & 63) << 6 | ke & 63, Le > 2047 && (Le < 55296 || Le > 57343) && (ce = Le));
            break;
          case 4:
            Re = x[ue + 1], ke = x[ue + 2], Ce = x[ue + 3], (Re & 192) === 128 && (ke & 192) === 128 && (Ce & 192) === 128 && (Le = (ge & 15) << 18 | (Re & 63) << 12 | (ke & 63) << 6 | Ce & 63, Le > 65535 && Le < 1114112 && (ce = Le));
        }
      }
      ce === null ? (ce = 65533, ve = 1) : ce > 65535 && (ce -= 65536, F.push(ce >>> 10 & 1023 | 55296), ce = 56320 | ce & 1023), F.push(ce), ue += ve;
    }
    return M(F);
  }
  var v = 4096;
  function M(x) {
    var L = x.length;
    if (L <= v)
      return String.fromCharCode.apply(String, x);
    for (var D = "", F = 0; F < L; )
      D += String.fromCharCode.apply(
        String,
        x.slice(F, F += v)
      );
    return D;
  }
  function B(x, L, D) {
    var F = "";
    D = Math.min(x.length, D);
    for (var ue = L; ue < D; ++ue)
      F += String.fromCharCode(x[ue] & 127);
    return F;
  }
  function S(x, L, D) {
    var F = "";
    D = Math.min(x.length, D);
    for (var ue = L; ue < D; ++ue)
      F += String.fromCharCode(x[ue]);
    return F;
  }
  function _(x, L, D) {
    var F = x.length;
    (!L || L < 0) && (L = 0), (!D || D < 0 || D > F) && (D = F);
    for (var ue = "", ge = L; ge < D; ++ge)
      ue += qe[x[ge]];
    return ue;
  }
  function E(x, L, D) {
    for (var F = x.slice(L, D), ue = "", ge = 0; ge < F.length - 1; ge += 2)
      ue += String.fromCharCode(F[ge] + F[ge + 1] * 256);
    return ue;
  }
  d.prototype.slice = function(x, L) {
    var D = this.length;
    x = ~~x, L = L === void 0 ? D : ~~L, x < 0 ? (x += D, x < 0 && (x = 0)) : x > D && (x = D), L < 0 ? (L += D, L < 0 && (L = 0)) : L > D && (L = D), L < x && (L = x);
    var F = this.subarray(x, L);
    return Object.setPrototypeOf(F, d.prototype), F;
  };
  function m(x, L, D) {
    if (x % 1 !== 0 || x < 0)
      throw new RangeError("offset is not uint");
    if (x + L > D)
      throw new RangeError("Trying to access beyond buffer length");
  }
  d.prototype.readUintLE = d.prototype.readUIntLE = function(x, L, D) {
    x = x >>> 0, L = L >>> 0, D || m(x, L, this.length);
    for (var F = this[x], ue = 1, ge = 0; ++ge < L && (ue *= 256); )
      F += this[x + ge] * ue;
    return F;
  }, d.prototype.readUintBE = d.prototype.readUIntBE = function(x, L, D) {
    x = x >>> 0, L = L >>> 0, D || m(x, L, this.length);
    for (var F = this[x + --L], ue = 1; L > 0 && (ue *= 256); )
      F += this[x + --L] * ue;
    return F;
  }, d.prototype.readUint8 = d.prototype.readUInt8 = function(x, L) {
    return x = x >>> 0, L || m(x, 1, this.length), this[x];
  }, d.prototype.readUint16LE = d.prototype.readUInt16LE = function(x, L) {
    return x = x >>> 0, L || m(x, 2, this.length), this[x] | this[x + 1] << 8;
  }, d.prototype.readUint16BE = d.prototype.readUInt16BE = function(x, L) {
    return x = x >>> 0, L || m(x, 2, this.length), this[x] << 8 | this[x + 1];
  }, d.prototype.readUint32LE = d.prototype.readUInt32LE = function(x, L) {
    return x = x >>> 0, L || m(x, 4, this.length), (this[x] | this[x + 1] << 8 | this[x + 2] << 16) + this[x + 3] * 16777216;
  }, d.prototype.readUint32BE = d.prototype.readUInt32BE = function(x, L) {
    return x = x >>> 0, L || m(x, 4, this.length), this[x] * 16777216 + (this[x + 1] << 16 | this[x + 2] << 8 | this[x + 3]);
  }, d.prototype.readIntLE = function(x, L, D) {
    x = x >>> 0, L = L >>> 0, D || m(x, L, this.length);
    for (var F = this[x], ue = 1, ge = 0; ++ge < L && (ue *= 256); )
      F += this[x + ge] * ue;
    return ue *= 128, F >= ue && (F -= Math.pow(2, 8 * L)), F;
  }, d.prototype.readIntBE = function(x, L, D) {
    x = x >>> 0, L = L >>> 0, D || m(x, L, this.length);
    for (var F = L, ue = 1, ge = this[x + --F]; F > 0 && (ue *= 256); )
      ge += this[x + --F] * ue;
    return ue *= 128, ge >= ue && (ge -= Math.pow(2, 8 * L)), ge;
  }, d.prototype.readInt8 = function(x, L) {
    return x = x >>> 0, L || m(x, 1, this.length), this[x] & 128 ? (255 - this[x] + 1) * -1 : this[x];
  }, d.prototype.readInt16LE = function(x, L) {
    x = x >>> 0, L || m(x, 2, this.length);
    var D = this[x] | this[x + 1] << 8;
    return D & 32768 ? D | 4294901760 : D;
  }, d.prototype.readInt16BE = function(x, L) {
    x = x >>> 0, L || m(x, 2, this.length);
    var D = this[x + 1] | this[x] << 8;
    return D & 32768 ? D | 4294901760 : D;
  }, d.prototype.readInt32LE = function(x, L) {
    return x = x >>> 0, L || m(x, 4, this.length), this[x] | this[x + 1] << 8 | this[x + 2] << 16 | this[x + 3] << 24;
  }, d.prototype.readInt32BE = function(x, L) {
    return x = x >>> 0, L || m(x, 4, this.length), this[x] << 24 | this[x + 1] << 16 | this[x + 2] << 8 | this[x + 3];
  }, d.prototype.readFloatLE = function(x, L) {
    return x = x >>> 0, L || m(x, 4, this.length), o.read(this, x, !0, 23, 4);
  }, d.prototype.readFloatBE = function(x, L) {
    return x = x >>> 0, L || m(x, 4, this.length), o.read(this, x, !1, 23, 4);
  }, d.prototype.readDoubleLE = function(x, L) {
    return x = x >>> 0, L || m(x, 8, this.length), o.read(this, x, !0, 52, 8);
  }, d.prototype.readDoubleBE = function(x, L) {
    return x = x >>> 0, L || m(x, 8, this.length), o.read(this, x, !1, 52, 8);
  };
  function A(x, L, D, F, ue, ge) {
    if (!d.isBuffer(x))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (L > ue || L < ge)
      throw new RangeError('"value" argument is out of bounds');
    if (D + F > x.length)
      throw new RangeError("Index out of range");
  }
  d.prototype.writeUintLE = d.prototype.writeUIntLE = function(x, L, D, F) {
    if (x = +x, L = L >>> 0, D = D >>> 0, !F) {
      var ue = Math.pow(2, 8 * D) - 1;
      A(this, x, L, D, ue, 0);
    }
    var ge = 1, ce = 0;
    for (this[L] = x & 255; ++ce < D && (ge *= 256); )
      this[L + ce] = x / ge & 255;
    return L + D;
  }, d.prototype.writeUintBE = d.prototype.writeUIntBE = function(x, L, D, F) {
    if (x = +x, L = L >>> 0, D = D >>> 0, !F) {
      var ue = Math.pow(2, 8 * D) - 1;
      A(this, x, L, D, ue, 0);
    }
    var ge = D - 1, ce = 1;
    for (this[L + ge] = x & 255; --ge >= 0 && (ce *= 256); )
      this[L + ge] = x / ce & 255;
    return L + D;
  }, d.prototype.writeUint8 = d.prototype.writeUInt8 = function(x, L, D) {
    return x = +x, L = L >>> 0, D || A(this, x, L, 1, 255, 0), this[L] = x & 255, L + 1;
  }, d.prototype.writeUint16LE = d.prototype.writeUInt16LE = function(x, L, D) {
    return x = +x, L = L >>> 0, D || A(this, x, L, 2, 65535, 0), this[L] = x & 255, this[L + 1] = x >>> 8, L + 2;
  }, d.prototype.writeUint16BE = d.prototype.writeUInt16BE = function(x, L, D) {
    return x = +x, L = L >>> 0, D || A(this, x, L, 2, 65535, 0), this[L] = x >>> 8, this[L + 1] = x & 255, L + 2;
  }, d.prototype.writeUint32LE = d.prototype.writeUInt32LE = function(x, L, D) {
    return x = +x, L = L >>> 0, D || A(this, x, L, 4, 4294967295, 0), this[L + 3] = x >>> 24, this[L + 2] = x >>> 16, this[L + 1] = x >>> 8, this[L] = x & 255, L + 4;
  }, d.prototype.writeUint32BE = d.prototype.writeUInt32BE = function(x, L, D) {
    return x = +x, L = L >>> 0, D || A(this, x, L, 4, 4294967295, 0), this[L] = x >>> 24, this[L + 1] = x >>> 16, this[L + 2] = x >>> 8, this[L + 3] = x & 255, L + 4;
  }, d.prototype.writeIntLE = function(x, L, D, F) {
    if (x = +x, L = L >>> 0, !F) {
      var ue = Math.pow(2, 8 * D - 1);
      A(this, x, L, D, ue - 1, -ue);
    }
    var ge = 0, ce = 1, ve = 0;
    for (this[L] = x & 255; ++ge < D && (ce *= 256); )
      x < 0 && ve === 0 && this[L + ge - 1] !== 0 && (ve = 1), this[L + ge] = (x / ce >> 0) - ve & 255;
    return L + D;
  }, d.prototype.writeIntBE = function(x, L, D, F) {
    if (x = +x, L = L >>> 0, !F) {
      var ue = Math.pow(2, 8 * D - 1);
      A(this, x, L, D, ue - 1, -ue);
    }
    var ge = D - 1, ce = 1, ve = 0;
    for (this[L + ge] = x & 255; --ge >= 0 && (ce *= 256); )
      x < 0 && ve === 0 && this[L + ge + 1] !== 0 && (ve = 1), this[L + ge] = (x / ce >> 0) - ve & 255;
    return L + D;
  }, d.prototype.writeInt8 = function(x, L, D) {
    return x = +x, L = L >>> 0, D || A(this, x, L, 1, 127, -128), x < 0 && (x = 255 + x + 1), this[L] = x & 255, L + 1;
  }, d.prototype.writeInt16LE = function(x, L, D) {
    return x = +x, L = L >>> 0, D || A(this, x, L, 2, 32767, -32768), this[L] = x & 255, this[L + 1] = x >>> 8, L + 2;
  }, d.prototype.writeInt16BE = function(x, L, D) {
    return x = +x, L = L >>> 0, D || A(this, x, L, 2, 32767, -32768), this[L] = x >>> 8, this[L + 1] = x & 255, L + 2;
  }, d.prototype.writeInt32LE = function(x, L, D) {
    return x = +x, L = L >>> 0, D || A(this, x, L, 4, 2147483647, -2147483648), this[L] = x & 255, this[L + 1] = x >>> 8, this[L + 2] = x >>> 16, this[L + 3] = x >>> 24, L + 4;
  }, d.prototype.writeInt32BE = function(x, L, D) {
    return x = +x, L = L >>> 0, D || A(this, x, L, 4, 2147483647, -2147483648), x < 0 && (x = 4294967295 + x + 1), this[L] = x >>> 24, this[L + 1] = x >>> 16, this[L + 2] = x >>> 8, this[L + 3] = x & 255, L + 4;
  };
  function $(x, L, D, F, ue, ge) {
    if (D + F > x.length)
      throw new RangeError("Index out of range");
    if (D < 0)
      throw new RangeError("Index out of range");
  }
  function X(x, L, D, F, ue) {
    return L = +L, D = D >>> 0, ue || $(x, L, D, 4), o.write(x, L, D, F, 23, 4), D + 4;
  }
  d.prototype.writeFloatLE = function(x, L, D) {
    return X(this, x, L, !0, D);
  }, d.prototype.writeFloatBE = function(x, L, D) {
    return X(this, x, L, !1, D);
  };
  function oe(x, L, D, F, ue) {
    return L = +L, D = D >>> 0, ue || $(x, L, D, 8), o.write(x, L, D, F, 52, 8), D + 8;
  }
  d.prototype.writeDoubleLE = function(x, L, D) {
    return oe(this, x, L, !0, D);
  }, d.prototype.writeDoubleBE = function(x, L, D) {
    return oe(this, x, L, !1, D);
  }, d.prototype.copy = function(x, L, D, F) {
    if (!d.isBuffer(x))
      throw new TypeError("argument should be a Buffer");
    if (D || (D = 0), !F && F !== 0 && (F = this.length), L >= x.length && (L = x.length), L || (L = 0), F > 0 && F < D && (F = D), F === D || x.length === 0 || this.length === 0)
      return 0;
    if (L < 0)
      throw new RangeError("targetStart out of bounds");
    if (D < 0 || D >= this.length)
      throw new RangeError("Index out of range");
    if (F < 0)
      throw new RangeError("sourceEnd out of bounds");
    F > this.length && (F = this.length), x.length - L < F - D && (F = x.length - L + D);
    var ue = F - D;
    return this === x && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(L, D, F) : Uint8Array.prototype.set.call(
      x,
      this.subarray(D, F),
      L
    ), ue;
  }, d.prototype.fill = function(x, L, D, F) {
    if (typeof x == "string") {
      if (typeof L == "string" ? (F = L, L = 0, D = this.length) : typeof D == "string" && (F = D, D = this.length), F !== void 0 && typeof F != "string")
        throw new TypeError("encoding must be a string");
      if (typeof F == "string" && !d.isEncoding(F))
        throw new TypeError("Unknown encoding: " + F);
      if (x.length === 1) {
        var ue = x.charCodeAt(0);
        (F === "utf8" && ue < 128 || F === "latin1") && (x = ue);
      }
    } else
      typeof x == "number" ? x = x & 255 : typeof x == "boolean" && (x = Number(x));
    if (L < 0 || this.length < L || this.length < D)
      throw new RangeError("Out of range index");
    if (D <= L)
      return this;
    L = L >>> 0, D = D === void 0 ? this.length : D >>> 0, x || (x = 0);
    var ge;
    if (typeof x == "number")
      for (ge = L; ge < D; ++ge)
        this[ge] = x;
    else {
      var ce = d.isBuffer(x) ? x : d.from(x, F), ve = ce.length;
      if (ve === 0)
        throw new TypeError('The value "' + x + '" is invalid for argument "value"');
      for (ge = 0; ge < D - L; ++ge)
        this[ge + L] = ce[ge % ve];
    }
    return this;
  };
  var J = /[^+/0-9A-Za-z-_]/g;
  function W(x) {
    if (x = x.split("=")[0], x = x.trim().replace(J, ""), x.length < 2)
      return "";
    for (; x.length % 4 !== 0; )
      x = x + "=";
    return x;
  }
  function Q(x, L) {
    L = L || 1 / 0;
    for (var D, F = x.length, ue = null, ge = [], ce = 0; ce < F; ++ce) {
      if (D = x.charCodeAt(ce), D > 55295 && D < 57344) {
        if (!ue) {
          if (D > 56319) {
            (L -= 3) > -1 && ge.push(239, 191, 189);
            continue;
          } else if (ce + 1 === F) {
            (L -= 3) > -1 && ge.push(239, 191, 189);
            continue;
          }
          ue = D;
          continue;
        }
        if (D < 56320) {
          (L -= 3) > -1 && ge.push(239, 191, 189), ue = D;
          continue;
        }
        D = (ue - 55296 << 10 | D - 56320) + 65536;
      } else
        ue && (L -= 3) > -1 && ge.push(239, 191, 189);
      if (ue = null, D < 128) {
        if ((L -= 1) < 0)
          break;
        ge.push(D);
      } else if (D < 2048) {
        if ((L -= 2) < 0)
          break;
        ge.push(
          D >> 6 | 192,
          D & 63 | 128
        );
      } else if (D < 65536) {
        if ((L -= 3) < 0)
          break;
        ge.push(
          D >> 12 | 224,
          D >> 6 & 63 | 128,
          D & 63 | 128
        );
      } else if (D < 1114112) {
        if ((L -= 4) < 0)
          break;
        ge.push(
          D >> 18 | 240,
          D >> 12 & 63 | 128,
          D >> 6 & 63 | 128,
          D & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return ge;
  }
  function me(x) {
    for (var L = [], D = 0; D < x.length; ++D)
      L.push(x.charCodeAt(D) & 255);
    return L;
  }
  function be(x, L) {
    for (var D, F, ue, ge = [], ce = 0; ce < x.length && !((L -= 2) < 0); ++ce)
      D = x.charCodeAt(ce), F = D >> 8, ue = D % 256, ge.push(ue), ge.push(F);
    return ge;
  }
  function Y(x) {
    return t.toByteArray(W(x));
  }
  function re(x, L, D, F) {
    for (var ue = 0; ue < F && !(ue + D >= L.length || ue >= x.length); ++ue)
      L[ue + D] = x[ue];
    return ue;
  }
  function de(x, L) {
    return x instanceof L || x != null && x.constructor != null && x.constructor.name != null && x.constructor.name === L.name;
  }
  function Ae(x) {
    return x !== x;
  }
  var qe = function() {
    for (var x = "0123456789abcdef", L = new Array(256), D = 0; D < 16; ++D)
      for (var F = D * 16, ue = 0; ue < 16; ++ue)
        L[F + ue] = x[D] + x[ue];
    return L;
  }();
})(pe);
var a1 = { exports: {} }, $t = a1.exports = {}, Ri, Ni;
function Gu() {
  throw new Error("setTimeout has not been defined");
}
function zu() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Ri = setTimeout : Ri = Gu;
  } catch {
    Ri = Gu;
  }
  try {
    typeof clearTimeout == "function" ? Ni = clearTimeout : Ni = zu;
  } catch {
    Ni = zu;
  }
})();
function s1(e) {
  if (Ri === setTimeout)
    return setTimeout(e, 0);
  if ((Ri === Gu || !Ri) && setTimeout)
    return Ri = setTimeout, setTimeout(e, 0);
  try {
    return Ri(e, 0);
  } catch {
    try {
      return Ri.call(null, e, 0);
    } catch {
      return Ri.call(this, e, 0);
    }
  }
}
function yg(e) {
  if (Ni === clearTimeout)
    return clearTimeout(e);
  if ((Ni === zu || !Ni) && clearTimeout)
    return Ni = clearTimeout, clearTimeout(e);
  try {
    return Ni(e);
  } catch {
    try {
      return Ni.call(null, e);
    } catch {
      return Ni.call(this, e);
    }
  }
}
var en = [], xa = !1, Hn, us = -1;
function gg() {
  !xa || !Hn || (xa = !1, Hn.length ? en = Hn.concat(en) : us = -1, en.length && f1());
}
function f1() {
  if (!xa) {
    var e = s1(gg);
    xa = !0;
    for (var t = en.length; t; ) {
      for (Hn = en, en = []; ++us < t; )
        Hn && Hn[us].run();
      us = -1, t = en.length;
    }
    Hn = null, xa = !1, yg(e);
  }
}
$t.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var o = 1; o < arguments.length; o++)
      t[o - 1] = arguments[o];
  en.push(new o1(e, t)), en.length === 1 && !xa && s1(f1);
};
function o1(e, t) {
  this.fun = e, this.array = t;
}
o1.prototype.run = function() {
  this.fun.apply(null, this.array);
};
$t.title = "browser";
$t.browser = !0;
$t.env = {};
$t.argv = [];
$t.version = "";
$t.versions = {};
function cn() {
}
$t.on = cn;
$t.addListener = cn;
$t.once = cn;
$t.off = cn;
$t.removeListener = cn;
$t.removeAllListeners = cn;
$t.emit = cn;
$t.prependListener = cn;
$t.prependOnceListener = cn;
$t.listeners = function(e) {
  return [];
};
$t.binding = function(e) {
  throw new Error("process.binding is not supported");
};
$t.cwd = function() {
  return "/";
};
$t.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
$t.umask = function() {
  return 0;
};
var mg = a1.exports;
const Ve = /* @__PURE__ */ Gs(mg);
(function(e) {
  function t() {
    var r = this || self;
    return delete e.prototype.__magic__, r;
  }
  if (typeof globalThis == "object")
    return globalThis;
  if (this)
    return t();
  e.defineProperty(e.prototype, "__magic__", {
    configurable: !0,
    get: t
  });
  var o = __magic__;
  return o;
})(Object);
var u1 = { exports: {} };
function bg(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var zf = { exports: {} }, st = {}, ju = { exports: {} }, Wu = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(e, t) {
  var o = pe, r = o.Buffer;
  function h(p, d) {
    for (var b in p)
      d[b] = p[b];
  }
  r.from && r.alloc && r.allocUnsafe && r.allocUnsafeSlow ? e.exports = o : (h(o, t), t.Buffer = a);
  function a(p, d, b) {
    return r(p, d, b);
  }
  a.prototype = Object.create(r.prototype), h(r, a), a.from = function(p, d, b) {
    if (typeof p == "number")
      throw new TypeError("Argument must not be a number");
    return r(p, d, b);
  }, a.alloc = function(p, d, b) {
    if (typeof p != "number")
      throw new TypeError("Argument must be a number");
    var g = r(p);
    return d !== void 0 ? typeof b == "string" ? g.fill(d, b) : g.fill(d) : g.fill(0), g;
  }, a.allocUnsafe = function(p) {
    if (typeof p != "number")
      throw new TypeError("Argument must be a number");
    return r(p);
  }, a.allocUnsafeSlow = function(p) {
    if (typeof p != "number")
      throw new TypeError("Argument must be a number");
    return o.SlowBuffer(p);
  };
})(Wu, Wu.exports);
var ct = Wu.exports, jf = 65536, xg = 4294967295;
function _g() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var Eg = ct.Buffer, ws = Me.crypto || Me.msCrypto;
ws && ws.getRandomValues ? ju.exports = Sg : ju.exports = _g;
function Sg(e, t) {
  if (e > xg)
    throw new RangeError("requested too many random bytes");
  var o = Eg.allocUnsafe(e);
  if (e > 0)
    if (e > jf)
      for (var r = 0; r < e; r += jf)
        ws.getRandomValues(o.slice(r, r + jf));
    else
      ws.getRandomValues(o);
  return typeof t == "function" ? Ve.nextTick(function() {
    t(null, o);
  }) : o;
}
var Ua = ju.exports, Yu = { exports: {} };
typeof Object.create == "function" ? Yu.exports = function(e, t) {
  t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : Yu.exports = function(e, t) {
  if (t) {
    e.super_ = t;
    var o = function() {
    };
    o.prototype = t.prototype, e.prototype = new o(), e.prototype.constructor = e;
  }
};
var ut = Yu.exports, Xu = { exports: {} }, Pc = { exports: {} }, _a = typeof Reflect == "object" ? Reflect : null, Zh = _a && typeof _a.apply == "function" ? _a.apply : function(e, t, o) {
  return Function.prototype.apply.call(e, t, o);
}, cs;
_a && typeof _a.ownKeys == "function" ? cs = _a.ownKeys : Object.getOwnPropertySymbols ? cs = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : cs = function(e) {
  return Object.getOwnPropertyNames(e);
};
function wg(e) {
  console && console.warn && console.warn(e);
}
var c1 = Number.isNaN || function(e) {
  return e !== e;
};
function Mt() {
  Mt.init.call(this);
}
Pc.exports = Mt;
Pc.exports.once = Ig;
Mt.EventEmitter = Mt;
Mt.prototype._events = void 0;
Mt.prototype._eventsCount = 0;
Mt.prototype._maxListeners = void 0;
var Jh = 10;
function js(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(Mt, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return Jh;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || c1(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    Jh = e;
  }
});
Mt.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Mt.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || c1(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function h1(e) {
  return e._maxListeners === void 0 ? Mt.defaultMaxListeners : e._maxListeners;
}
Mt.prototype.getMaxListeners = function() {
  return h1(this);
};
Mt.prototype.emit = function(e) {
  for (var t = [], o = 1; o < arguments.length; o++)
    t.push(arguments[o]);
  var r = e === "error", h = this._events;
  if (h !== void 0)
    r = r && h.error === void 0;
  else if (!r)
    return !1;
  if (r) {
    var a;
    if (t.length > 0 && (a = t[0]), a instanceof Error)
      throw a;
    var p = new Error("Unhandled error." + (a ? " (" + a.message + ")" : ""));
    throw p.context = a, p;
  }
  var d = h[e];
  if (d === void 0)
    return !1;
  if (typeof d == "function")
    Zh(d, this, t);
  else
    for (var b = d.length, g = y1(d, b), o = 0; o < b; ++o)
      Zh(g[o], this, t);
  return !0;
};
function l1(e, t, o, r) {
  var h, a, p;
  if (js(o), a = e._events, a === void 0 ? (a = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (a.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    o.listener ? o.listener : o
  ), a = e._events), p = a[t]), p === void 0)
    p = a[t] = o, ++e._eventsCount;
  else if (typeof p == "function" ? p = a[t] = r ? [o, p] : [p, o] : r ? p.unshift(o) : p.push(o), h = h1(e), h > 0 && p.length > h && !p.warned) {
    p.warned = !0;
    var d = new Error("Possible EventEmitter memory leak detected. " + p.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    d.name = "MaxListenersExceededWarning", d.emitter = e, d.type = t, d.count = p.length, wg(d);
  }
  return e;
}
Mt.prototype.addListener = function(e, t) {
  return l1(this, e, t, !1);
};
Mt.prototype.on = Mt.prototype.addListener;
Mt.prototype.prependListener = function(e, t) {
  return l1(this, e, t, !0);
};
function Cg() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function d1(e, t, o) {
  var r = { fired: !1, wrapFn: void 0, target: e, type: t, listener: o }, h = Cg.bind(r);
  return h.listener = o, r.wrapFn = h, h;
}
Mt.prototype.once = function(e, t) {
  return js(t), this.on(e, d1(this, e, t)), this;
};
Mt.prototype.prependOnceListener = function(e, t) {
  return js(t), this.prependListener(e, d1(this, e, t)), this;
};
Mt.prototype.removeListener = function(e, t) {
  var o, r, h, a, p;
  if (js(t), r = this._events, r === void 0)
    return this;
  if (o = r[e], o === void 0)
    return this;
  if (o === t || o.listener === t)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete r[e], r.removeListener && this.emit("removeListener", e, o.listener || t));
  else if (typeof o != "function") {
    for (h = -1, a = o.length - 1; a >= 0; a--)
      if (o[a] === t || o[a].listener === t) {
        p = o[a].listener, h = a;
        break;
      }
    if (h < 0)
      return this;
    h === 0 ? o.shift() : Ag(o, h), o.length === 1 && (r[e] = o[0]), r.removeListener !== void 0 && this.emit("removeListener", e, p || t);
  }
  return this;
};
Mt.prototype.off = Mt.prototype.removeListener;
Mt.prototype.removeAllListeners = function(e) {
  var t, o, r;
  if (o = this._events, o === void 0)
    return this;
  if (o.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : o[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete o[e]), this;
  if (arguments.length === 0) {
    var h = Object.keys(o), a;
    for (r = 0; r < h.length; ++r)
      a = h[r], a !== "removeListener" && this.removeAllListeners(a);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (t = o[e], typeof t == "function")
    this.removeListener(e, t);
  else if (t !== void 0)
    for (r = t.length - 1; r >= 0; r--)
      this.removeListener(e, t[r]);
  return this;
};
function p1(e, t, o) {
  var r = e._events;
  if (r === void 0)
    return [];
  var h = r[t];
  return h === void 0 ? [] : typeof h == "function" ? o ? [h.listener || h] : [h] : o ? Bg(h) : y1(h, h.length);
}
Mt.prototype.listeners = function(e) {
  return p1(this, e, !0);
};
Mt.prototype.rawListeners = function(e) {
  return p1(this, e, !1);
};
Mt.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : v1.call(e, t);
};
Mt.prototype.listenerCount = v1;
function v1(e) {
  var t = this._events;
  if (t !== void 0) {
    var o = t[e];
    if (typeof o == "function")
      return 1;
    if (o !== void 0)
      return o.length;
  }
  return 0;
}
Mt.prototype.eventNames = function() {
  return this._eventsCount > 0 ? cs(this._events) : [];
};
function y1(e, t) {
  for (var o = new Array(t), r = 0; r < t; ++r)
    o[r] = e[r];
  return o;
}
function Ag(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function Bg(e) {
  for (var t = new Array(e.length), o = 0; o < t.length; ++o)
    t[o] = e[o].listener || e[o];
  return t;
}
function Ig(e, t) {
  return new Promise(function(o, r) {
    function h(p) {
      e.removeListener(t, a), r(p);
    }
    function a() {
      typeof e.removeListener == "function" && e.removeListener("error", h), o([].slice.call(arguments));
    }
    g1(e, t, a, { once: !0 }), t !== "error" && Tg(e, h, { once: !0 });
  });
}
function Tg(e, t, o) {
  typeof e.on == "function" && g1(e, "error", t, o);
}
function g1(e, t, o, r) {
  if (typeof e.on == "function")
    r.once ? e.once(t, o) : e.on(t, o);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function h(a) {
      r.once && e.removeEventListener(t, h), o(a);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var Lc = Pc.exports, m1 = Lc.EventEmitter, wn = {}, b1 = {}, x1 = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var e = {}, t = Symbol("test"), o = Object(t);
  if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(o) !== "[object Symbol]")
    return !1;
  var r = 42;
  e[t] = r;
  for (t in e)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
    return !1;
  var h = Object.getOwnPropertySymbols(e);
  if (h.length !== 1 || h[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var a = Object.getOwnPropertyDescriptor(e, t);
    if (a.value !== r || a.enumerable !== !0)
      return !1;
  }
  return !0;
}, Mg = x1, kc = function() {
  return Mg() && !!Symbol.toStringTag;
}, Wf, el;
function Rg() {
  if (el)
    return Wf;
  el = 1;
  var e = typeof Symbol < "u" && Symbol, t = x1;
  return Wf = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, Wf;
}
var Yf, tl;
function Ng() {
  if (tl)
    return Yf;
  tl = 1;
  var e = {
    foo: {}
  }, t = Object;
  return Yf = function() {
    return { __proto__: e }.foo === e.foo && !({ __proto__: null } instanceof t);
  }, Yf;
}
var Xf, rl;
function Dg() {
  if (rl)
    return Xf;
  rl = 1;
  var e = "Function.prototype.bind called on incompatible ", t = Array.prototype.slice, o = Object.prototype.toString, r = "[object Function]";
  return Xf = function(h) {
    var a = this;
    if (typeof a != "function" || o.call(a) !== r)
      throw new TypeError(e + a);
    for (var p = t.call(arguments, 1), d, b = function() {
      if (this instanceof d) {
        var k = a.apply(
          this,
          p.concat(t.call(arguments))
        );
        return Object(k) === k ? k : this;
      } else
        return a.apply(
          h,
          p.concat(t.call(arguments))
        );
    }, g = Math.max(0, a.length - p.length), w = [], C = 0; C < g; C++)
      w.push("$" + C);
    if (d = Function("binder", "return function (" + w.join(",") + "){ return binder.apply(this,arguments); }")(b), a.prototype) {
      var T = function() {
      };
      T.prototype = a.prototype, d.prototype = new T(), T.prototype = null;
    }
    return d;
  }, Xf;
}
var Qf, il;
function Uc() {
  if (il)
    return Qf;
  il = 1;
  var e = Dg();
  return Qf = Function.prototype.bind || e, Qf;
}
var Zf, nl;
function Og() {
  if (nl)
    return Zf;
  nl = 1;
  var e = Uc();
  return Zf = e.call(Function.call, Object.prototype.hasOwnProperty), Zf;
}
var Jf, al;
function Ws() {
  if (al)
    return Jf;
  al = 1;
  var e, t = SyntaxError, o = Function, r = TypeError, h = function(P) {
    try {
      return o('"use strict"; return (' + P + ").constructor;")();
    } catch {
    }
  }, a = Object.getOwnPropertyDescriptor;
  if (a)
    try {
      a({}, "");
    } catch {
      a = null;
    }
  var p = function() {
    throw new r();
  }, d = a ? function() {
    try {
      return arguments.callee, p;
    } catch {
      try {
        return a(arguments, "callee").get;
      } catch {
        return p;
      }
    }
  }() : p, b = Rg()(), g = Ng()(), w = Object.getPrototypeOf || (g ? function(P) {
    return P.__proto__;
  } : null), C = {}, T = typeof Uint8Array > "u" || !w ? e : w(Uint8Array), k = {
    "%AggregateError%": typeof AggregateError > "u" ? e : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? e : ArrayBuffer,
    "%ArrayIteratorPrototype%": b && w ? w([][Symbol.iterator]()) : e,
    "%AsyncFromSyncIteratorPrototype%": e,
    "%AsyncFunction%": C,
    "%AsyncGenerator%": C,
    "%AsyncGeneratorFunction%": C,
    "%AsyncIteratorPrototype%": C,
    "%Atomics%": typeof Atomics > "u" ? e : Atomics,
    "%BigInt%": typeof BigInt > "u" ? e : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? e : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? e : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? e : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array > "u" ? e : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? e : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? e : FinalizationRegistry,
    "%Function%": o,
    "%GeneratorFunction%": C,
    "%Int8Array%": typeof Int8Array > "u" ? e : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? e : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? e : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": b && w ? w(w([][Symbol.iterator]())) : e,
    "%JSON%": typeof JSON == "object" ? JSON : e,
    "%Map%": typeof Map > "u" ? e : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !b || !w ? e : w((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? e : Promise,
    "%Proxy%": typeof Proxy > "u" ? e : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect > "u" ? e : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? e : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !b || !w ? e : w((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? e : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": b && w ? w(""[Symbol.iterator]()) : e,
    "%Symbol%": b ? Symbol : e,
    "%SyntaxError%": t,
    "%ThrowTypeError%": d,
    "%TypedArray%": T,
    "%TypeError%": r,
    "%Uint8Array%": typeof Uint8Array > "u" ? e : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? e : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? e : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? e : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap > "u" ? e : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? e : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? e : WeakSet
  };
  if (w)
    try {
      null.error;
    } catch (P) {
      var q = w(w(P));
      k["%Error.prototype%"] = q;
    }
  var O = function P(f) {
    var y;
    if (f === "%AsyncFunction%")
      y = h("async function () {}");
    else if (f === "%GeneratorFunction%")
      y = h("function* () {}");
    else if (f === "%AsyncGeneratorFunction%")
      y = h("async function* () {}");
    else if (f === "%AsyncGenerator%") {
      var v = P("%AsyncGeneratorFunction%");
      v && (y = v.prototype);
    } else if (f === "%AsyncIteratorPrototype%") {
      var M = P("%AsyncGenerator%");
      M && w && (y = w(M.prototype));
    }
    return k[f] = y, y;
  }, N = {
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, j = Uc(), U = Og(), H = j.call(Function.call, Array.prototype.concat), z = j.call(Function.apply, Array.prototype.splice), ee = j.call(Function.call, String.prototype.replace), ne = j.call(Function.call, String.prototype.slice), le = j.call(Function.call, RegExp.prototype.exec), Z = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, ie = /\\(\\)?/g, fe = function(P) {
    var f = ne(P, 0, 1), y = ne(P, -1);
    if (f === "%" && y !== "%")
      throw new t("invalid intrinsic syntax, expected closing `%`");
    if (y === "%" && f !== "%")
      throw new t("invalid intrinsic syntax, expected opening `%`");
    var v = [];
    return ee(P, Z, function(M, B, S, _) {
      v[v.length] = S ? ee(_, ie, "$1") : B || M;
    }), v;
  }, I = function(P, f) {
    var y = P, v;
    if (U(N, y) && (v = N[y], y = "%" + v[0] + "%"), U(k, y)) {
      var M = k[y];
      if (M === C && (M = O(y)), typeof M > "u" && !f)
        throw new r("intrinsic " + P + " exists, but is not available. Please file an issue!");
      return {
        alias: v,
        name: y,
        value: M
      };
    }
    throw new t("intrinsic " + P + " does not exist!");
  };
  return Jf = function(P, f) {
    if (typeof P != "string" || P.length === 0)
      throw new r("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof f != "boolean")
      throw new r('"allowMissing" argument must be a boolean');
    if (le(/^%?[^%]*%?$/, P) === null)
      throw new t("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var y = fe(P), v = y.length > 0 ? y[0] : "", M = I("%" + v + "%", f), B = M.name, S = M.value, _ = !1, E = M.alias;
    E && (v = E[0], z(y, H([0, 1], E)));
    for (var m = 1, A = !0; m < y.length; m += 1) {
      var $ = y[m], X = ne($, 0, 1), oe = ne($, -1);
      if ((X === '"' || X === "'" || X === "`" || oe === '"' || oe === "'" || oe === "`") && X !== oe)
        throw new t("property names with quotes must have matching quotes");
      if (($ === "constructor" || !A) && (_ = !0), v += "." + $, B = "%" + v + "%", U(k, B))
        S = k[B];
      else if (S != null) {
        if (!($ in S)) {
          if (!f)
            throw new r("base intrinsic for " + P + " exists, but the property is not available.");
          return;
        }
        if (a && m + 1 >= y.length) {
          var J = a(S, $);
          A = !!J, A && "get" in J && !("originalValue" in J.get) ? S = J.get : S = S[$];
        } else
          A = U(S, $), S = S[$];
        A && !_ && (k[B] = S);
      }
    }
    return S;
  }, Jf;
}
var eo = { exports: {} }, sl;
function Ys() {
  return sl || (sl = 1, function(e) {
    var t = Uc(), o = Ws(), r = o("%Function.prototype.apply%"), h = o("%Function.prototype.call%"), a = o("%Reflect.apply%", !0) || t.call(h, r), p = o("%Object.getOwnPropertyDescriptor%", !0), d = o("%Object.defineProperty%", !0), b = o("%Math.max%");
    if (d)
      try {
        d({}, "a", { value: 1 });
      } catch {
        d = null;
      }
    e.exports = function(w) {
      var C = a(t, h, arguments);
      if (p && d) {
        var T = p(C, "length");
        T.configurable && d(
          C,
          "length",
          { value: 1 + b(0, w.length - (arguments.length - 1)) }
        );
      }
      return C;
    };
    var g = function() {
      return a(t, r, arguments);
    };
    d ? d(e.exports, "apply", { value: g }) : e.exports.apply = g;
  }(eo)), eo.exports;
}
var _1 = Ws(), E1 = Ys(), Pg = E1(_1("String.prototype.indexOf")), S1 = function(e, t) {
  var o = _1(e, !!t);
  return typeof o == "function" && Pg(e, ".prototype.") > -1 ? E1(o) : o;
}, Lg = kc(), kg = S1, Qu = kg("Object.prototype.toString"), Xs = function(e) {
  return Lg && e && typeof e == "object" && Symbol.toStringTag in e ? !1 : Qu(e) === "[object Arguments]";
}, w1 = function(e) {
  return Xs(e) ? !0 : e !== null && typeof e == "object" && typeof e.length == "number" && e.length >= 0 && Qu(e) !== "[object Array]" && Qu(e.callee) === "[object Function]";
}, Ug = function() {
  return Xs(arguments);
}();
Xs.isLegacyArguments = w1;
var Fg = Ug ? Xs : w1, qg = Object.prototype.toString, Vg = Function.prototype.toString, Kg = /^\s*(?:function)?\*/, C1 = kc(), to = Object.getPrototypeOf, $g = function() {
  if (!C1)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, ro, Hg = function(e) {
  if (typeof e != "function")
    return !1;
  if (Kg.test(Vg.call(e)))
    return !0;
  if (!C1) {
    var t = qg.call(e);
    return t === "[object GeneratorFunction]";
  }
  if (!to)
    return !1;
  if (typeof ro > "u") {
    var o = $g();
    ro = o ? to(o) : !1;
  }
  return to(e) === ro;
}, A1 = Function.prototype.toString, va = typeof Reflect == "object" && Reflect !== null && Reflect.apply, Zu, hs;
if (typeof va == "function" && typeof Object.defineProperty == "function")
  try {
    Zu = Object.defineProperty({}, "length", {
      get: function() {
        throw hs;
      }
    }), hs = {}, va(function() {
      throw 42;
    }, null, Zu);
  } catch (e) {
    e !== hs && (va = null);
  }
else
  va = null;
var Gg = /^\s*class\b/, Ju = function(e) {
  try {
    var t = A1.call(e);
    return Gg.test(t);
  } catch {
    return !1;
  }
}, io = function(e) {
  try {
    return Ju(e) ? !1 : (A1.call(e), !0);
  } catch {
    return !1;
  }
}, ls = Object.prototype.toString, zg = "[object Object]", jg = "[object Function]", Wg = "[object GeneratorFunction]", Yg = "[object HTMLAllCollection]", Xg = "[object HTML document.all class]", Qg = "[object HTMLCollection]", Zg = typeof Symbol == "function" && !!Symbol.toStringTag, Jg = !(0 in [,]), ec = function() {
  return !1;
};
if (typeof document == "object") {
  var em = document.all;
  ls.call(em) === ls.call(document.all) && (ec = function(e) {
    if ((Jg || !e) && (typeof e > "u" || typeof e == "object"))
      try {
        var t = ls.call(e);
        return (t === Yg || t === Xg || t === Qg || t === zg) && e("") == null;
      } catch {
      }
    return !1;
  });
}
var tm = va ? function(e) {
  if (ec(e))
    return !0;
  if (!e || typeof e != "function" && typeof e != "object")
    return !1;
  try {
    va(e, null, Zu);
  } catch (t) {
    if (t !== hs)
      return !1;
  }
  return !Ju(e) && io(e);
} : function(e) {
  if (ec(e))
    return !0;
  if (!e || typeof e != "function" && typeof e != "object")
    return !1;
  if (Zg)
    return io(e);
  if (Ju(e))
    return !1;
  var t = ls.call(e);
  return t !== jg && t !== Wg && !/^\[object HTML/.test(t) ? !1 : io(e);
}, rm = tm, im = Object.prototype.toString, B1 = Object.prototype.hasOwnProperty, nm = function(e, t, o) {
  for (var r = 0, h = e.length; r < h; r++)
    B1.call(e, r) && (o == null ? t(e[r], r, e) : t.call(o, e[r], r, e));
}, am = function(e, t, o) {
  for (var r = 0, h = e.length; r < h; r++)
    o == null ? t(e.charAt(r), r, e) : t.call(o, e.charAt(r), r, e);
}, sm = function(e, t, o) {
  for (var r in e)
    B1.call(e, r) && (o == null ? t(e[r], r, e) : t.call(o, e[r], r, e));
}, fm = function(e, t, o) {
  if (!rm(t))
    throw new TypeError("iterator must be a function");
  var r;
  arguments.length >= 3 && (r = o), im.call(e) === "[object Array]" ? nm(e, t, r) : typeof e == "string" ? am(e, t, r) : sm(e, t, r);
}, om = fm, no = [
  "BigInt64Array",
  "BigUint64Array",
  "Float32Array",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray"
], um = typeof globalThis > "u" ? Me : globalThis, cm = function() {
  for (var e = [], t = 0; t < no.length; t++)
    typeof um[no[t]] == "function" && (e[e.length] = no[t]);
  return e;
}, hm = Ws(), ds = hm("%Object.getOwnPropertyDescriptor%", !0);
if (ds)
  try {
    ds([], "length");
  } catch {
    ds = null;
  }
var lm = ds, Cs = om, dm = cm, fl = Ys(), Fc = S1, ps = lm, pm = Fc("Object.prototype.toString"), I1 = kc(), ol = typeof globalThis > "u" ? Me : globalThis, tc = dm(), qc = Fc("String.prototype.slice"), ao = Object.getPrototypeOf, vm = Fc("Array.prototype.indexOf", !0) || function(e, t) {
  for (var o = 0; o < e.length; o += 1)
    if (e[o] === t)
      return o;
  return -1;
}, As = { __proto__: null };
I1 && ps && ao ? Cs(tc, function(e) {
  var t = new ol[e]();
  if (Symbol.toStringTag in t) {
    var o = ao(t), r = ps(o, Symbol.toStringTag);
    if (!r) {
      var h = ao(o);
      r = ps(h, Symbol.toStringTag);
    }
    As["$" + e] = fl(r.get);
  }
}) : Cs(tc, function(e) {
  var t = new ol[e]();
  As["$" + e] = fl(t.slice);
});
var ym = function(e) {
  var t = !1;
  return Cs(As, function(o, r) {
    if (!t)
      try {
        "$" + o(e) === r && (t = qc(r, 1));
      } catch {
      }
  }), t;
}, gm = function(e) {
  var t = !1;
  return Cs(As, function(o, r) {
    if (!t)
      try {
        o(e), t = qc(r, 1);
      } catch {
      }
  }), t;
}, T1 = function(e) {
  if (!e || typeof e != "object")
    return !1;
  if (!I1) {
    var t = qc(pm(e), 8, -1);
    return vm(tc, t) > -1 ? t : t !== "Object" ? !1 : gm(e);
  }
  return ps ? ym(e) : null;
}, mm = T1, bm = function(e) {
  return !!mm(e);
};
(function(e) {
  var t = Fg, o = Hg, r = T1, h = bm;
  function a(F) {
    return F.call.bind(F);
  }
  var p = typeof BigInt < "u", d = typeof Symbol < "u", b = a(Object.prototype.toString), g = a(Number.prototype.valueOf), w = a(String.prototype.valueOf), C = a(Boolean.prototype.valueOf);
  if (p)
    var T = a(BigInt.prototype.valueOf);
  if (d)
    var k = a(Symbol.prototype.valueOf);
  function q(F, ue) {
    if (typeof F != "object")
      return !1;
    try {
      return ue(F), !0;
    } catch {
      return !1;
    }
  }
  e.isArgumentsObject = t, e.isGeneratorFunction = o, e.isTypedArray = h;
  function O(F) {
    return typeof Promise < "u" && F instanceof Promise || F !== null && typeof F == "object" && typeof F.then == "function" && typeof F.catch == "function";
  }
  e.isPromise = O;
  function N(F) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(F) : h(F) || $(F);
  }
  e.isArrayBufferView = N;
  function j(F) {
    return r(F) === "Uint8Array";
  }
  e.isUint8Array = j;
  function U(F) {
    return r(F) === "Uint8ClampedArray";
  }
  e.isUint8ClampedArray = U;
  function H(F) {
    return r(F) === "Uint16Array";
  }
  e.isUint16Array = H;
  function z(F) {
    return r(F) === "Uint32Array";
  }
  e.isUint32Array = z;
  function ee(F) {
    return r(F) === "Int8Array";
  }
  e.isInt8Array = ee;
  function ne(F) {
    return r(F) === "Int16Array";
  }
  e.isInt16Array = ne;
  function le(F) {
    return r(F) === "Int32Array";
  }
  e.isInt32Array = le;
  function Z(F) {
    return r(F) === "Float32Array";
  }
  e.isFloat32Array = Z;
  function ie(F) {
    return r(F) === "Float64Array";
  }
  e.isFloat64Array = ie;
  function fe(F) {
    return r(F) === "BigInt64Array";
  }
  e.isBigInt64Array = fe;
  function I(F) {
    return r(F) === "BigUint64Array";
  }
  e.isBigUint64Array = I;
  function P(F) {
    return b(F) === "[object Map]";
  }
  P.working = typeof Map < "u" && P(/* @__PURE__ */ new Map());
  function f(F) {
    return typeof Map > "u" ? !1 : P.working ? P(F) : F instanceof Map;
  }
  e.isMap = f;
  function y(F) {
    return b(F) === "[object Set]";
  }
  y.working = typeof Set < "u" && y(/* @__PURE__ */ new Set());
  function v(F) {
    return typeof Set > "u" ? !1 : y.working ? y(F) : F instanceof Set;
  }
  e.isSet = v;
  function M(F) {
    return b(F) === "[object WeakMap]";
  }
  M.working = typeof WeakMap < "u" && M(/* @__PURE__ */ new WeakMap());
  function B(F) {
    return typeof WeakMap > "u" ? !1 : M.working ? M(F) : F instanceof WeakMap;
  }
  e.isWeakMap = B;
  function S(F) {
    return b(F) === "[object WeakSet]";
  }
  S.working = typeof WeakSet < "u" && S(/* @__PURE__ */ new WeakSet());
  function _(F) {
    return S(F);
  }
  e.isWeakSet = _;
  function E(F) {
    return b(F) === "[object ArrayBuffer]";
  }
  E.working = typeof ArrayBuffer < "u" && E(new ArrayBuffer());
  function m(F) {
    return typeof ArrayBuffer > "u" ? !1 : E.working ? E(F) : F instanceof ArrayBuffer;
  }
  e.isArrayBuffer = m;
  function A(F) {
    return b(F) === "[object DataView]";
  }
  A.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && A(new DataView(new ArrayBuffer(1), 0, 1));
  function $(F) {
    return typeof DataView > "u" ? !1 : A.working ? A(F) : F instanceof DataView;
  }
  e.isDataView = $;
  var X = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function oe(F) {
    return b(F) === "[object SharedArrayBuffer]";
  }
  function J(F) {
    return typeof X > "u" ? !1 : (typeof oe.working > "u" && (oe.working = oe(new X())), oe.working ? oe(F) : F instanceof X);
  }
  e.isSharedArrayBuffer = J;
  function W(F) {
    return b(F) === "[object AsyncFunction]";
  }
  e.isAsyncFunction = W;
  function Q(F) {
    return b(F) === "[object Map Iterator]";
  }
  e.isMapIterator = Q;
  function me(F) {
    return b(F) === "[object Set Iterator]";
  }
  e.isSetIterator = me;
  function be(F) {
    return b(F) === "[object Generator]";
  }
  e.isGeneratorObject = be;
  function Y(F) {
    return b(F) === "[object WebAssembly.Module]";
  }
  e.isWebAssemblyCompiledModule = Y;
  function re(F) {
    return q(F, g);
  }
  e.isNumberObject = re;
  function de(F) {
    return q(F, w);
  }
  e.isStringObject = de;
  function Ae(F) {
    return q(F, C);
  }
  e.isBooleanObject = Ae;
  function qe(F) {
    return p && q(F, T);
  }
  e.isBigIntObject = qe;
  function x(F) {
    return d && q(F, k);
  }
  e.isSymbolObject = x;
  function L(F) {
    return re(F) || de(F) || Ae(F) || qe(F) || x(F);
  }
  e.isBoxedPrimitive = L;
  function D(F) {
    return typeof Uint8Array < "u" && (m(F) || J(F));
  }
  e.isAnyArrayBuffer = D, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(F) {
    Object.defineProperty(e, F, {
      enumerable: !1,
      value: function() {
        throw new Error(F + " is not supported in userland");
      }
    });
  });
})(b1);
var xm = function(e) {
  return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
};
(function(e) {
  var t = Object.getOwnPropertyDescriptors || function(A) {
    for (var $ = Object.keys(A), X = {}, oe = 0; oe < $.length; oe++)
      X[$[oe]] = Object.getOwnPropertyDescriptor(A, $[oe]);
    return X;
  }, o = /%[sdj%]/g;
  e.format = function(A) {
    if (!ee(A)) {
      for (var $ = [], X = 0; X < arguments.length; X++)
        $.push(p(arguments[X]));
      return $.join(" ");
    }
    for (var X = 1, oe = arguments, J = oe.length, W = String(A).replace(o, function(be) {
      if (be === "%%")
        return "%";
      if (X >= J)
        return be;
      switch (be) {
        case "%s":
          return String(oe[X++]);
        case "%d":
          return Number(oe[X++]);
        case "%j":
          try {
            return JSON.stringify(oe[X++]);
          } catch {
            return "[Circular]";
          }
        default:
          return be;
      }
    }), Q = oe[X]; X < J; Q = oe[++X])
      U(Q) || !ie(Q) ? W += " " + Q : W += " " + p(Q);
    return W;
  }, e.deprecate = function(A, $) {
    if (typeof Ve < "u" && Ve.noDeprecation === !0)
      return A;
    if (typeof Ve > "u")
      return function() {
        return e.deprecate(A, $).apply(this, arguments);
      };
    var X = !1;
    function oe() {
      if (!X) {
        if (Ve.throwDeprecation)
          throw new Error($);
        Ve.traceDeprecation ? console.trace($) : console.error($), X = !0;
      }
      return A.apply(this, arguments);
    }
    return oe;
  };
  var r = {}, h = /^$/;
  if (Ve.env.NODE_DEBUG) {
    var a = Ve.env.NODE_DEBUG;
    a = a.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), h = new RegExp("^" + a + "$", "i");
  }
  e.debuglog = function(A) {
    if (A = A.toUpperCase(), !r[A])
      if (h.test(A)) {
        var $ = Ve.pid;
        r[A] = function() {
          var X = e.format.apply(e, arguments);
          console.error("%s %d: %s", A, $, X);
        };
      } else
        r[A] = function() {
        };
    return r[A];
  };
  function p(A, $) {
    var X = {
      seen: [],
      stylize: b
    };
    return arguments.length >= 3 && (X.depth = arguments[2]), arguments.length >= 4 && (X.colors = arguments[3]), j($) ? X.showHidden = $ : $ && e._extend(X, $), le(X.showHidden) && (X.showHidden = !1), le(X.depth) && (X.depth = 2), le(X.colors) && (X.colors = !1), le(X.customInspect) && (X.customInspect = !0), X.colors && (X.stylize = d), w(X, A, X.depth);
  }
  e.inspect = p, p.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, p.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function d(A, $) {
    var X = p.styles[$];
    return X ? "\x1B[" + p.colors[X][0] + "m" + A + "\x1B[" + p.colors[X][1] + "m" : A;
  }
  function b(A, $) {
    return A;
  }
  function g(A) {
    var $ = {};
    return A.forEach(function(X, oe) {
      $[X] = !0;
    }), $;
  }
  function w(A, $, X) {
    if (A.customInspect && $ && P($.inspect) && // Filter out the util module, it's inspect function is special
    $.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
    !($.constructor && $.constructor.prototype === $)) {
      var oe = $.inspect(X, A);
      return ee(oe) || (oe = w(A, oe, X)), oe;
    }
    var J = C(A, $);
    if (J)
      return J;
    var W = Object.keys($), Q = g(W);
    if (A.showHidden && (W = Object.getOwnPropertyNames($)), I($) && (W.indexOf("message") >= 0 || W.indexOf("description") >= 0))
      return T($);
    if (W.length === 0) {
      if (P($)) {
        var me = $.name ? ": " + $.name : "";
        return A.stylize("[Function" + me + "]", "special");
      }
      if (Z($))
        return A.stylize(RegExp.prototype.toString.call($), "regexp");
      if (fe($))
        return A.stylize(Date.prototype.toString.call($), "date");
      if (I($))
        return T($);
    }
    var be = "", Y = !1, re = ["{", "}"];
    if (N($) && (Y = !0, re = ["[", "]"]), P($)) {
      var de = $.name ? ": " + $.name : "";
      be = " [Function" + de + "]";
    }
    if (Z($) && (be = " " + RegExp.prototype.toString.call($)), fe($) && (be = " " + Date.prototype.toUTCString.call($)), I($) && (be = " " + T($)), W.length === 0 && (!Y || $.length == 0))
      return re[0] + be + re[1];
    if (X < 0)
      return Z($) ? A.stylize(RegExp.prototype.toString.call($), "regexp") : A.stylize("[Object]", "special");
    A.seen.push($);
    var Ae;
    return Y ? Ae = k(A, $, X, Q, W) : Ae = W.map(function(qe) {
      return q(A, $, X, Q, qe, Y);
    }), A.seen.pop(), O(Ae, be, re);
  }
  function C(A, $) {
    if (le($))
      return A.stylize("undefined", "undefined");
    if (ee($)) {
      var X = "'" + JSON.stringify($).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return A.stylize(X, "string");
    }
    if (z($))
      return A.stylize("" + $, "number");
    if (j($))
      return A.stylize("" + $, "boolean");
    if (U($))
      return A.stylize("null", "null");
  }
  function T(A) {
    return "[" + Error.prototype.toString.call(A) + "]";
  }
  function k(A, $, X, oe, J) {
    for (var W = [], Q = 0, me = $.length; Q < me; ++Q)
      S($, String(Q)) ? W.push(q(
        A,
        $,
        X,
        oe,
        String(Q),
        !0
      )) : W.push("");
    return J.forEach(function(be) {
      be.match(/^\d+$/) || W.push(q(
        A,
        $,
        X,
        oe,
        be,
        !0
      ));
    }), W;
  }
  function q(A, $, X, oe, J, W) {
    var Q, me, be;
    if (be = Object.getOwnPropertyDescriptor($, J) || { value: $[J] }, be.get ? be.set ? me = A.stylize("[Getter/Setter]", "special") : me = A.stylize("[Getter]", "special") : be.set && (me = A.stylize("[Setter]", "special")), S(oe, J) || (Q = "[" + J + "]"), me || (A.seen.indexOf(be.value) < 0 ? (U(X) ? me = w(A, be.value, null) : me = w(A, be.value, X - 1), me.indexOf(`
`) > -1 && (W ? me = me.split(`
`).map(function(Y) {
      return "  " + Y;
    }).join(`
`).slice(2) : me = `
` + me.split(`
`).map(function(Y) {
      return "   " + Y;
    }).join(`
`))) : me = A.stylize("[Circular]", "special")), le(Q)) {
      if (W && J.match(/^\d+$/))
        return me;
      Q = JSON.stringify("" + J), Q.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (Q = Q.slice(1, -1), Q = A.stylize(Q, "name")) : (Q = Q.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), Q = A.stylize(Q, "string"));
    }
    return Q + ": " + me;
  }
  function O(A, $, X) {
    var oe = A.reduce(function(J, W) {
      return W.indexOf(`
`) >= 0, J + W.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return oe > 60 ? X[0] + ($ === "" ? "" : $ + `
 `) + " " + A.join(`,
  `) + " " + X[1] : X[0] + $ + " " + A.join(", ") + " " + X[1];
  }
  e.types = b1;
  function N(A) {
    return Array.isArray(A);
  }
  e.isArray = N;
  function j(A) {
    return typeof A == "boolean";
  }
  e.isBoolean = j;
  function U(A) {
    return A === null;
  }
  e.isNull = U;
  function H(A) {
    return A == null;
  }
  e.isNullOrUndefined = H;
  function z(A) {
    return typeof A == "number";
  }
  e.isNumber = z;
  function ee(A) {
    return typeof A == "string";
  }
  e.isString = ee;
  function ne(A) {
    return typeof A == "symbol";
  }
  e.isSymbol = ne;
  function le(A) {
    return A === void 0;
  }
  e.isUndefined = le;
  function Z(A) {
    return ie(A) && y(A) === "[object RegExp]";
  }
  e.isRegExp = Z, e.types.isRegExp = Z;
  function ie(A) {
    return typeof A == "object" && A !== null;
  }
  e.isObject = ie;
  function fe(A) {
    return ie(A) && y(A) === "[object Date]";
  }
  e.isDate = fe, e.types.isDate = fe;
  function I(A) {
    return ie(A) && (y(A) === "[object Error]" || A instanceof Error);
  }
  e.isError = I, e.types.isNativeError = I;
  function P(A) {
    return typeof A == "function";
  }
  e.isFunction = P;
  function f(A) {
    return A === null || typeof A == "boolean" || typeof A == "number" || typeof A == "string" || typeof A == "symbol" || // ES6 symbol
    typeof A > "u";
  }
  e.isPrimitive = f, e.isBuffer = xm;
  function y(A) {
    return Object.prototype.toString.call(A);
  }
  function v(A) {
    return A < 10 ? "0" + A.toString(10) : A.toString(10);
  }
  var M = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function B() {
    var A = /* @__PURE__ */ new Date(), $ = [
      v(A.getHours()),
      v(A.getMinutes()),
      v(A.getSeconds())
    ].join(":");
    return [A.getDate(), M[A.getMonth()], $].join(" ");
  }
  e.log = function() {
    console.log("%s - %s", B(), e.format.apply(e, arguments));
  }, e.inherits = ut, e._extend = function(A, $) {
    if (!$ || !ie($))
      return A;
    for (var X = Object.keys($), oe = X.length; oe--; )
      A[X[oe]] = $[X[oe]];
    return A;
  };
  function S(A, $) {
    return Object.prototype.hasOwnProperty.call(A, $);
  }
  var _ = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  e.promisify = function(A) {
    if (typeof A != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (_ && A[_]) {
      var $ = A[_];
      if (typeof $ != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty($, _, {
        value: $,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), $;
    }
    function $() {
      for (var X, oe, J = new Promise(function(me, be) {
        X = me, oe = be;
      }), W = [], Q = 0; Q < arguments.length; Q++)
        W.push(arguments[Q]);
      W.push(function(me, be) {
        me ? oe(me) : X(be);
      });
      try {
        A.apply(this, W);
      } catch (me) {
        oe(me);
      }
      return J;
    }
    return Object.setPrototypeOf($, Object.getPrototypeOf(A)), _ && Object.defineProperty($, _, {
      value: $,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      $,
      t(A)
    );
  }, e.promisify.custom = _;
  function E(A, $) {
    if (!A) {
      var X = new Error("Promise was rejected with a falsy value");
      X.reason = A, A = X;
    }
    return $(A);
  }
  function m(A) {
    if (typeof A != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function $() {
      for (var X = [], oe = 0; oe < arguments.length; oe++)
        X.push(arguments[oe]);
      var J = X.pop();
      if (typeof J != "function")
        throw new TypeError("The last argument must be of type Function");
      var W = this, Q = function() {
        return J.apply(W, arguments);
      };
      A.apply(this, X).then(
        function(me) {
          Ve.nextTick(Q.bind(null, null, me));
        },
        function(me) {
          Ve.nextTick(E.bind(null, me, Q));
        }
      );
    }
    return Object.setPrototypeOf($, Object.getPrototypeOf(A)), Object.defineProperties(
      $,
      t(A)
    ), $;
  }
  e.callbackify = m;
})(wn);
var so, ul;
function _m() {
  if (ul)
    return so;
  ul = 1;
  function e(q, O) {
    var N = Object.keys(q);
    if (Object.getOwnPropertySymbols) {
      var j = Object.getOwnPropertySymbols(q);
      O && (j = j.filter(function(U) {
        return Object.getOwnPropertyDescriptor(q, U).enumerable;
      })), N.push.apply(N, j);
    }
    return N;
  }
  function t(q) {
    for (var O = 1; O < arguments.length; O++) {
      var N = arguments[O] != null ? arguments[O] : {};
      O % 2 ? e(Object(N), !0).forEach(function(j) {
        o(q, j, N[j]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(q, Object.getOwnPropertyDescriptors(N)) : e(Object(N)).forEach(function(j) {
        Object.defineProperty(q, j, Object.getOwnPropertyDescriptor(N, j));
      });
    }
    return q;
  }
  function o(q, O, N) {
    return O = p(O), O in q ? Object.defineProperty(q, O, { value: N, enumerable: !0, configurable: !0, writable: !0 }) : q[O] = N, q;
  }
  function r(q, O) {
    if (!(q instanceof O))
      throw new TypeError("Cannot call a class as a function");
  }
  function h(q, O) {
    for (var N = 0; N < O.length; N++) {
      var j = O[N];
      j.enumerable = j.enumerable || !1, j.configurable = !0, "value" in j && (j.writable = !0), Object.defineProperty(q, p(j.key), j);
    }
  }
  function a(q, O, N) {
    return O && h(q.prototype, O), N && h(q, N), Object.defineProperty(q, "prototype", { writable: !1 }), q;
  }
  function p(q) {
    var O = d(q, "string");
    return typeof O == "symbol" ? O : String(O);
  }
  function d(q, O) {
    if (typeof q != "object" || q === null)
      return q;
    var N = q[Symbol.toPrimitive];
    if (N !== void 0) {
      var j = N.call(q, O || "default");
      if (typeof j != "object")
        return j;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (O === "string" ? String : Number)(q);
  }
  var b = pe, g = b.Buffer, w = wn, C = w.inspect, T = C && C.custom || "inspect";
  function k(q, O, N) {
    g.prototype.copy.call(q, O, N);
  }
  return so = /* @__PURE__ */ function() {
    function q() {
      r(this, q), this.head = null, this.tail = null, this.length = 0;
    }
    return a(q, [{
      key: "push",
      value: function(O) {
        var N = {
          data: O,
          next: null
        };
        this.length > 0 ? this.tail.next = N : this.head = N, this.tail = N, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(O) {
        var N = {
          data: O,
          next: this.head
        };
        this.length === 0 && (this.tail = N), this.head = N, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var O = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, O;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(O) {
        if (this.length === 0)
          return "";
        for (var N = this.head, j = "" + N.data; N = N.next; )
          j += O + N.data;
        return j;
      }
    }, {
      key: "concat",
      value: function(O) {
        if (this.length === 0)
          return g.alloc(0);
        for (var N = g.allocUnsafe(O >>> 0), j = this.head, U = 0; j; )
          k(j.data, N, U), U += j.data.length, j = j.next;
        return N;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(O, N) {
        var j;
        return O < this.head.data.length ? (j = this.head.data.slice(0, O), this.head.data = this.head.data.slice(O)) : O === this.head.data.length ? j = this.shift() : j = N ? this._getString(O) : this._getBuffer(O), j;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(O) {
        var N = this.head, j = 1, U = N.data;
        for (O -= U.length; N = N.next; ) {
          var H = N.data, z = O > H.length ? H.length : O;
          if (z === H.length ? U += H : U += H.slice(0, O), O -= z, O === 0) {
            z === H.length ? (++j, N.next ? this.head = N.next : this.head = this.tail = null) : (this.head = N, N.data = H.slice(z));
            break;
          }
          ++j;
        }
        return this.length -= j, U;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(O) {
        var N = g.allocUnsafe(O), j = this.head, U = 1;
        for (j.data.copy(N), O -= j.data.length; j = j.next; ) {
          var H = j.data, z = O > H.length ? H.length : O;
          if (H.copy(N, N.length - O, 0, z), O -= z, O === 0) {
            z === H.length ? (++U, j.next ? this.head = j.next : this.head = this.tail = null) : (this.head = j, j.data = H.slice(z));
            break;
          }
          ++U;
        }
        return this.length -= U, N;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: T,
      value: function(O, N) {
        return C(this, t(t({}, N), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), q;
  }(), so;
}
function Em(e, t) {
  var o = this, r = this._readableState && this._readableState.destroyed, h = this._writableState && this._writableState.destroyed;
  return r || h ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, Ve.nextTick(rc, this, e)) : Ve.nextTick(rc, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(a) {
    !t && a ? o._writableState ? o._writableState.errorEmitted ? Ve.nextTick(vs, o) : (o._writableState.errorEmitted = !0, Ve.nextTick(cl, o, a)) : Ve.nextTick(cl, o, a) : t ? (Ve.nextTick(vs, o), t(a)) : Ve.nextTick(vs, o);
  }), this);
}
function cl(e, t) {
  rc(e, t), vs(e);
}
function vs(e) {
  e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
}
function Sm() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function rc(e, t) {
  e.emit("error", t);
}
function wm(e, t) {
  var o = e._readableState, r = e._writableState;
  o && o.autoDestroy || r && r.autoDestroy ? e.destroy(t) : e.emit("error", t);
}
var M1 = {
  destroy: Em,
  undestroy: Sm,
  errorOrDestroy: wm
}, ta = {};
function Cm(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
}
var R1 = {};
function Xr(e, t, o) {
  o || (o = Error);
  function r(a, p, d) {
    return typeof t == "string" ? t : t(a, p, d);
  }
  var h = /* @__PURE__ */ function(a) {
    Cm(p, a);
    function p(d, b, g) {
      return a.call(this, r(d, b, g)) || this;
    }
    return p;
  }(o);
  h.prototype.name = o.name, h.prototype.code = e, R1[e] = h;
}
function hl(e, t) {
  if (Array.isArray(e)) {
    var o = e.length;
    return e = e.map(function(r) {
      return String(r);
    }), o > 2 ? "one of ".concat(t, " ").concat(e.slice(0, o - 1).join(", "), ", or ") + e[o - 1] : o === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
  } else
    return "of ".concat(t, " ").concat(String(e));
}
function Am(e, t, o) {
  return e.substr(!o || o < 0 ? 0 : +o, t.length) === t;
}
function Bm(e, t, o) {
  return (o === void 0 || o > e.length) && (o = e.length), e.substring(o - t.length, o) === t;
}
function Im(e, t, o) {
  return typeof o != "number" && (o = 0), o + t.length > e.length ? !1 : e.indexOf(t, o) !== -1;
}
Xr("ERR_INVALID_OPT_VALUE", function(e, t) {
  return 'The value "' + t + '" is invalid for option "' + e + '"';
}, TypeError);
Xr("ERR_INVALID_ARG_TYPE", function(e, t, o) {
  var r;
  typeof t == "string" && Am(t, "not ") ? (r = "must not be", t = t.replace(/^not /, "")) : r = "must be";
  var h;
  if (Bm(e, " argument"))
    h = "The ".concat(e, " ").concat(r, " ").concat(hl(t, "type"));
  else {
    var a = Im(e, ".") ? "property" : "argument";
    h = 'The "'.concat(e, '" ').concat(a, " ").concat(r, " ").concat(hl(t, "type"));
  }
  return h += ". Received type ".concat(typeof o), h;
}, TypeError);
Xr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
Xr("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
  return "The " + e + " method is not implemented";
});
Xr("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
Xr("ERR_STREAM_DESTROYED", function(e) {
  return "Cannot call " + e + " after a stream was destroyed";
});
Xr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
Xr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
Xr("ERR_STREAM_WRITE_AFTER_END", "write after end");
Xr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
Xr("ERR_UNKNOWN_ENCODING", function(e) {
  return "Unknown encoding: " + e;
}, TypeError);
Xr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
ta.codes = R1;
var Tm = ta.codes.ERR_INVALID_OPT_VALUE;
function Mm(e, t, o) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[o] : null;
}
function Rm(e, t, o, r) {
  var h = Mm(t, r, o);
  if (h != null) {
    if (!(isFinite(h) && Math.floor(h) === h) || h < 0) {
      var a = r ? o : "highWaterMark";
      throw new Tm(a, h);
    }
    return Math.floor(h);
  }
  return e.objectMode ? 16 : 16 * 1024;
}
var N1 = {
  getHighWaterMark: Rm
}, Nm = Dm;
function Dm(e, t) {
  if (fo("noDeprecation"))
    return e;
  var o = !1;
  function r() {
    if (!o) {
      if (fo("throwDeprecation"))
        throw new Error(t);
      fo("traceDeprecation") ? console.trace(t) : console.warn(t), o = !0;
    }
    return e.apply(this, arguments);
  }
  return r;
}
function fo(e) {
  try {
    if (!Me.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var t = Me.localStorage[e];
  return t == null ? !1 : String(t).toLowerCase() === "true";
}
var oo, ll;
function Vc() {
  if (ll)
    return oo;
  ll = 1, oo = Z;
  function e(J) {
    var W = this;
    this.next = null, this.entry = null, this.finish = function() {
      oe(W, J);
    };
  }
  var t;
  Z.WritableState = ne;
  var o = {
    deprecate: Nm
  }, r = m1, h = pe.Buffer, a = (typeof Me < "u" ? Me : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function p(J) {
    return h.from(J);
  }
  function d(J) {
    return h.isBuffer(J) || J instanceof a;
  }
  var b = M1, g = N1, w = g.getHighWaterMark, C = ta.codes, T = C.ERR_INVALID_ARG_TYPE, k = C.ERR_METHOD_NOT_IMPLEMENTED, q = C.ERR_MULTIPLE_CALLBACK, O = C.ERR_STREAM_CANNOT_PIPE, N = C.ERR_STREAM_DESTROYED, j = C.ERR_STREAM_NULL_VALUES, U = C.ERR_STREAM_WRITE_AFTER_END, H = C.ERR_UNKNOWN_ENCODING, z = b.errorOrDestroy;
  ut(Z, r);
  function ee() {
  }
  function ne(J, W, Q) {
    t = t || Xn(), J = J || {}, typeof Q != "boolean" && (Q = W instanceof t), this.objectMode = !!J.objectMode, Q && (this.objectMode = this.objectMode || !!J.writableObjectMode), this.highWaterMark = w(this, J, "writableHighWaterMark", Q), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var me = J.decodeStrings === !1;
    this.decodeStrings = !me, this.defaultEncoding = J.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(be) {
      M(W, be);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = J.emitClose !== !1, this.autoDestroy = !!J.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  ne.prototype.getBuffer = function() {
    for (var J = this.bufferedRequest, W = []; J; )
      W.push(J), J = J.next;
    return W;
  }, function() {
    try {
      Object.defineProperty(ne.prototype, "buffer", {
        get: o.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var le;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (le = Function.prototype[Symbol.hasInstance], Object.defineProperty(Z, Symbol.hasInstance, {
    value: function(J) {
      return le.call(this, J) ? !0 : this !== Z ? !1 : J && J._writableState instanceof ne;
    }
  })) : le = function(J) {
    return J instanceof this;
  };
  function Z(J) {
    t = t || Xn();
    var W = this instanceof t;
    if (!W && !le.call(Z, this))
      return new Z(J);
    this._writableState = new ne(J, this, W), this.writable = !0, J && (typeof J.write == "function" && (this._write = J.write), typeof J.writev == "function" && (this._writev = J.writev), typeof J.destroy == "function" && (this._destroy = J.destroy), typeof J.final == "function" && (this._final = J.final)), r.call(this);
  }
  Z.prototype.pipe = function() {
    z(this, new O());
  };
  function ie(J, W) {
    var Q = new U();
    z(J, Q), Ve.nextTick(W, Q);
  }
  function fe(J, W, Q, me) {
    var be;
    return Q === null ? be = new j() : typeof Q != "string" && !W.objectMode && (be = new T("chunk", ["string", "Buffer"], Q)), be ? (z(J, be), Ve.nextTick(me, be), !1) : !0;
  }
  Z.prototype.write = function(J, W, Q) {
    var me = this._writableState, be = !1, Y = !me.objectMode && d(J);
    return Y && !h.isBuffer(J) && (J = p(J)), typeof W == "function" && (Q = W, W = null), Y ? W = "buffer" : W || (W = me.defaultEncoding), typeof Q != "function" && (Q = ee), me.ending ? ie(this, Q) : (Y || fe(this, me, J, Q)) && (me.pendingcb++, be = P(this, me, Y, J, W, Q)), be;
  }, Z.prototype.cork = function() {
    this._writableState.corked++;
  }, Z.prototype.uncork = function() {
    var J = this._writableState;
    J.corked && (J.corked--, !J.writing && !J.corked && !J.bufferProcessing && J.bufferedRequest && _(this, J));
  }, Z.prototype.setDefaultEncoding = function(J) {
    if (typeof J == "string" && (J = J.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((J + "").toLowerCase()) > -1))
      throw new H(J);
    return this._writableState.defaultEncoding = J, this;
  }, Object.defineProperty(Z.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function I(J, W, Q) {
    return !J.objectMode && J.decodeStrings !== !1 && typeof W == "string" && (W = h.from(W, Q)), W;
  }
  Object.defineProperty(Z.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function P(J, W, Q, me, be, Y) {
    if (!Q) {
      var re = I(W, me, be);
      me !== re && (Q = !0, be = "buffer", me = re);
    }
    var de = W.objectMode ? 1 : me.length;
    W.length += de;
    var Ae = W.length < W.highWaterMark;
    if (Ae || (W.needDrain = !0), W.writing || W.corked) {
      var qe = W.lastBufferedRequest;
      W.lastBufferedRequest = {
        chunk: me,
        encoding: be,
        isBuf: Q,
        callback: Y,
        next: null
      }, qe ? qe.next = W.lastBufferedRequest : W.bufferedRequest = W.lastBufferedRequest, W.bufferedRequestCount += 1;
    } else
      f(J, W, !1, de, me, be, Y);
    return Ae;
  }
  function f(J, W, Q, me, be, Y, re) {
    W.writelen = me, W.writecb = re, W.writing = !0, W.sync = !0, W.destroyed ? W.onwrite(new N("write")) : Q ? J._writev(be, W.onwrite) : J._write(be, Y, W.onwrite), W.sync = !1;
  }
  function y(J, W, Q, me, be) {
    --W.pendingcb, Q ? (Ve.nextTick(be, me), Ve.nextTick($, J, W), J._writableState.errorEmitted = !0, z(J, me)) : (be(me), J._writableState.errorEmitted = !0, z(J, me), $(J, W));
  }
  function v(J) {
    J.writing = !1, J.writecb = null, J.length -= J.writelen, J.writelen = 0;
  }
  function M(J, W) {
    var Q = J._writableState, me = Q.sync, be = Q.writecb;
    if (typeof be != "function")
      throw new q();
    if (v(Q), W)
      y(J, Q, me, W, be);
    else {
      var Y = E(Q) || J.destroyed;
      !Y && !Q.corked && !Q.bufferProcessing && Q.bufferedRequest && _(J, Q), me ? Ve.nextTick(B, J, Q, Y, be) : B(J, Q, Y, be);
    }
  }
  function B(J, W, Q, me) {
    Q || S(J, W), W.pendingcb--, me(), $(J, W);
  }
  function S(J, W) {
    W.length === 0 && W.needDrain && (W.needDrain = !1, J.emit("drain"));
  }
  function _(J, W) {
    W.bufferProcessing = !0;
    var Q = W.bufferedRequest;
    if (J._writev && Q && Q.next) {
      var me = W.bufferedRequestCount, be = new Array(me), Y = W.corkedRequestsFree;
      Y.entry = Q;
      for (var re = 0, de = !0; Q; )
        be[re] = Q, Q.isBuf || (de = !1), Q = Q.next, re += 1;
      be.allBuffers = de, f(J, W, !0, W.length, be, "", Y.finish), W.pendingcb++, W.lastBufferedRequest = null, Y.next ? (W.corkedRequestsFree = Y.next, Y.next = null) : W.corkedRequestsFree = new e(W), W.bufferedRequestCount = 0;
    } else {
      for (; Q; ) {
        var Ae = Q.chunk, qe = Q.encoding, x = Q.callback, L = W.objectMode ? 1 : Ae.length;
        if (f(J, W, !1, L, Ae, qe, x), Q = Q.next, W.bufferedRequestCount--, W.writing)
          break;
      }
      Q === null && (W.lastBufferedRequest = null);
    }
    W.bufferedRequest = Q, W.bufferProcessing = !1;
  }
  Z.prototype._write = function(J, W, Q) {
    Q(new k("_write()"));
  }, Z.prototype._writev = null, Z.prototype.end = function(J, W, Q) {
    var me = this._writableState;
    return typeof J == "function" ? (Q = J, J = null, W = null) : typeof W == "function" && (Q = W, W = null), J != null && this.write(J, W), me.corked && (me.corked = 1, this.uncork()), me.ending || X(this, me, Q), this;
  }, Object.defineProperty(Z.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function E(J) {
    return J.ending && J.length === 0 && J.bufferedRequest === null && !J.finished && !J.writing;
  }
  function m(J, W) {
    J._final(function(Q) {
      W.pendingcb--, Q && z(J, Q), W.prefinished = !0, J.emit("prefinish"), $(J, W);
    });
  }
  function A(J, W) {
    !W.prefinished && !W.finalCalled && (typeof J._final == "function" && !W.destroyed ? (W.pendingcb++, W.finalCalled = !0, Ve.nextTick(m, J, W)) : (W.prefinished = !0, J.emit("prefinish")));
  }
  function $(J, W) {
    var Q = E(W);
    if (Q && (A(J, W), W.pendingcb === 0 && (W.finished = !0, J.emit("finish"), W.autoDestroy))) {
      var me = J._readableState;
      (!me || me.autoDestroy && me.endEmitted) && J.destroy();
    }
    return Q;
  }
  function X(J, W, Q) {
    W.ending = !0, $(J, W), Q && (W.finished ? Ve.nextTick(Q) : J.once("finish", Q)), W.ended = !0, J.writable = !1;
  }
  function oe(J, W, Q) {
    var me = J.entry;
    for (J.entry = null; me; ) {
      var be = me.callback;
      W.pendingcb--, be(Q), me = me.next;
    }
    W.corkedRequestsFree.next = J;
  }
  return Object.defineProperty(Z.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(J) {
      this._writableState && (this._writableState.destroyed = J);
    }
  }), Z.prototype.destroy = b.destroy, Z.prototype._undestroy = b.undestroy, Z.prototype._destroy = function(J, W) {
    W(J);
  }, oo;
}
var uo, dl;
function Xn() {
  if (dl)
    return uo;
  dl = 1;
  var e = Object.keys || function(g) {
    var w = [];
    for (var C in g)
      w.push(C);
    return w;
  };
  uo = p;
  var t = $c(), o = Vc();
  ut(p, t);
  for (var r = e(o.prototype), h = 0; h < r.length; h++) {
    var a = r[h];
    p.prototype[a] || (p.prototype[a] = o.prototype[a]);
  }
  function p(g) {
    if (!(this instanceof p))
      return new p(g);
    t.call(this, g), o.call(this, g), this.allowHalfOpen = !0, g && (g.readable === !1 && (this.readable = !1), g.writable === !1 && (this.writable = !1), g.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", d)));
  }
  Object.defineProperty(p.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(p.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(p.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function d() {
    this._writableState.ended || Ve.nextTick(b, this);
  }
  function b(g) {
    g.end();
  }
  return Object.defineProperty(p.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(g) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = g, this._writableState.destroyed = g);
    }
  }), uo;
}
var Bs = {}, Kc = ct.Buffer, pl = Kc.isEncoding || function(e) {
  switch (e = "" + e, e && e.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function Om(e) {
  if (!e)
    return "utf8";
  for (var t; ; )
    switch (e) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return e;
      default:
        if (t)
          return;
        e = ("" + e).toLowerCase(), t = !0;
    }
}
function Pm(e) {
  var t = Om(e);
  if (typeof t != "string" && (Kc.isEncoding === pl || !pl(e)))
    throw new Error("Unknown encoding: " + e);
  return t || e;
}
Bs.StringDecoder = M0;
function M0(e) {
  this.encoding = Pm(e);
  var t;
  switch (this.encoding) {
    case "utf16le":
      this.text = Vm, this.end = Km, t = 4;
      break;
    case "utf8":
      this.fillLast = Um, t = 4;
      break;
    case "base64":
      this.text = $m, this.end = Hm, t = 3;
      break;
    default:
      this.write = Gm, this.end = zm;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Kc.allocUnsafe(t);
}
M0.prototype.write = function(e) {
  if (e.length === 0)
    return "";
  var t, o;
  if (this.lastNeed) {
    if (t = this.fillLast(e), t === void 0)
      return "";
    o = this.lastNeed, this.lastNeed = 0;
  } else
    o = 0;
  return o < e.length ? t ? t + this.text(e, o) : this.text(e, o) : t || "";
};
M0.prototype.end = qm;
M0.prototype.text = Fm;
M0.prototype.fillLast = function(e) {
  if (this.lastNeed <= e.length)
    return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
};
function co(e) {
  return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2;
}
function Lm(e, t, o) {
  var r = t.length - 1;
  if (r < o)
    return 0;
  var h = co(t[r]);
  return h >= 0 ? (h > 0 && (e.lastNeed = h - 1), h) : --r < o || h === -2 ? 0 : (h = co(t[r]), h >= 0 ? (h > 0 && (e.lastNeed = h - 2), h) : --r < o || h === -2 ? 0 : (h = co(t[r]), h >= 0 ? (h > 0 && (h === 2 ? h = 0 : e.lastNeed = h - 3), h) : 0));
}
function km(e, t, o) {
  if ((t[0] & 192) !== 128)
    return e.lastNeed = 0, "�";
  if (e.lastNeed > 1 && t.length > 1) {
    if ((t[1] & 192) !== 128)
      return e.lastNeed = 1, "�";
    if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
      return e.lastNeed = 2, "�";
  }
}
function Um(e) {
  var t = this.lastTotal - this.lastNeed, o = km(this, e);
  if (o !== void 0)
    return o;
  if (this.lastNeed <= e.length)
    return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length;
}
function Fm(e, t) {
  var o = Lm(this, e, t);
  if (!this.lastNeed)
    return e.toString("utf8", t);
  this.lastTotal = o;
  var r = e.length - (o - this.lastNeed);
  return e.copy(this.lastChar, 0, r), e.toString("utf8", t, r);
}
function qm(e) {
  var t = e && e.length ? this.write(e) : "";
  return this.lastNeed ? t + "�" : t;
}
function Vm(e, t) {
  if ((e.length - t) % 2 === 0) {
    var o = e.toString("utf16le", t);
    if (o) {
      var r = o.charCodeAt(o.length - 1);
      if (r >= 55296 && r <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], o.slice(0, -1);
    }
    return o;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
}
function Km(e) {
  var t = e && e.length ? this.write(e) : "";
  if (this.lastNeed) {
    var o = this.lastTotal - this.lastNeed;
    return t + this.lastChar.toString("utf16le", 0, o);
  }
  return t;
}
function $m(e, t) {
  var o = (e.length - t) % 3;
  return o === 0 ? e.toString("base64", t) : (this.lastNeed = 3 - o, this.lastTotal = 3, o === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - o));
}
function Hm(e) {
  var t = e && e.length ? this.write(e) : "";
  return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
}
function Gm(e) {
  return e.toString(this.encoding);
}
function zm(e) {
  return e && e.length ? this.write(e) : "";
}
var vl = ta.codes.ERR_STREAM_PREMATURE_CLOSE;
function jm(e) {
  var t = !1;
  return function() {
    if (!t) {
      t = !0;
      for (var o = arguments.length, r = new Array(o), h = 0; h < o; h++)
        r[h] = arguments[h];
      e.apply(this, r);
    }
  };
}
function Wm() {
}
function Ym(e) {
  return e.setHeader && typeof e.abort == "function";
}
function D1(e, t, o) {
  if (typeof t == "function")
    return D1(e, null, t);
  t || (t = {}), o = jm(o || Wm);
  var r = t.readable || t.readable !== !1 && e.readable, h = t.writable || t.writable !== !1 && e.writable, a = function() {
    e.writable || d();
  }, p = e._writableState && e._writableState.finished, d = function() {
    h = !1, p = !0, r || o.call(e);
  }, b = e._readableState && e._readableState.endEmitted, g = function() {
    r = !1, b = !0, h || o.call(e);
  }, w = function(k) {
    o.call(e, k);
  }, C = function() {
    var k;
    if (r && !b)
      return (!e._readableState || !e._readableState.ended) && (k = new vl()), o.call(e, k);
    if (h && !p)
      return (!e._writableState || !e._writableState.ended) && (k = new vl()), o.call(e, k);
  }, T = function() {
    e.req.on("finish", d);
  };
  return Ym(e) ? (e.on("complete", d), e.on("abort", C), e.req ? T() : e.on("request", T)) : h && !e._writableState && (e.on("end", a), e.on("close", a)), e.on("end", g), e.on("finish", d), t.error !== !1 && e.on("error", w), e.on("close", C), function() {
    e.removeListener("complete", d), e.removeListener("abort", C), e.removeListener("request", T), e.req && e.req.removeListener("finish", d), e.removeListener("end", a), e.removeListener("close", a), e.removeListener("finish", d), e.removeListener("end", g), e.removeListener("error", w), e.removeListener("close", C);
  };
}
var Qs = D1, ho, yl;
function Xm() {
  if (yl)
    return ho;
  yl = 1;
  var e;
  function t(H, z, ee) {
    return z = o(z), z in H ? Object.defineProperty(H, z, { value: ee, enumerable: !0, configurable: !0, writable: !0 }) : H[z] = ee, H;
  }
  function o(H) {
    var z = r(H, "string");
    return typeof z == "symbol" ? z : String(z);
  }
  function r(H, z) {
    if (typeof H != "object" || H === null)
      return H;
    var ee = H[Symbol.toPrimitive];
    if (ee !== void 0) {
      var ne = ee.call(H, z || "default");
      if (typeof ne != "object")
        return ne;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (z === "string" ? String : Number)(H);
  }
  var h = Qs, a = Symbol("lastResolve"), p = Symbol("lastReject"), d = Symbol("error"), b = Symbol("ended"), g = Symbol("lastPromise"), w = Symbol("handlePromise"), C = Symbol("stream");
  function T(H, z) {
    return {
      value: H,
      done: z
    };
  }
  function k(H) {
    var z = H[a];
    if (z !== null) {
      var ee = H[C].read();
      ee !== null && (H[g] = null, H[a] = null, H[p] = null, z(T(ee, !1)));
    }
  }
  function q(H) {
    Ve.nextTick(k, H);
  }
  function O(H, z) {
    return function(ee, ne) {
      H.then(function() {
        if (z[b]) {
          ee(T(void 0, !0));
          return;
        }
        z[w](ee, ne);
      }, ne);
    };
  }
  var N = Object.getPrototypeOf(function() {
  }), j = Object.setPrototypeOf((e = {
    get stream() {
      return this[C];
    },
    next: function() {
      var H = this, z = this[d];
      if (z !== null)
        return Promise.reject(z);
      if (this[b])
        return Promise.resolve(T(void 0, !0));
      if (this[C].destroyed)
        return new Promise(function(Z, ie) {
          Ve.nextTick(function() {
            H[d] ? ie(H[d]) : Z(T(void 0, !0));
          });
        });
      var ee = this[g], ne;
      if (ee)
        ne = new Promise(O(ee, this));
      else {
        var le = this[C].read();
        if (le !== null)
          return Promise.resolve(T(le, !1));
        ne = new Promise(this[w]);
      }
      return this[g] = ne, ne;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var H = this;
    return new Promise(function(z, ee) {
      H[C].destroy(null, function(ne) {
        if (ne) {
          ee(ne);
          return;
        }
        z(T(void 0, !0));
      });
    });
  }), e), N), U = function(H) {
    var z, ee = Object.create(j, (z = {}, t(z, C, {
      value: H,
      writable: !0
    }), t(z, a, {
      value: null,
      writable: !0
    }), t(z, p, {
      value: null,
      writable: !0
    }), t(z, d, {
      value: null,
      writable: !0
    }), t(z, b, {
      value: H._readableState.endEmitted,
      writable: !0
    }), t(z, w, {
      value: function(ne, le) {
        var Z = ee[C].read();
        Z ? (ee[g] = null, ee[a] = null, ee[p] = null, ne(T(Z, !1))) : (ee[a] = ne, ee[p] = le);
      },
      writable: !0
    }), z));
    return ee[g] = null, h(H, function(ne) {
      if (ne && ne.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var le = ee[p];
        le !== null && (ee[g] = null, ee[a] = null, ee[p] = null, le(ne)), ee[d] = ne;
        return;
      }
      var Z = ee[a];
      Z !== null && (ee[g] = null, ee[a] = null, ee[p] = null, Z(T(void 0, !0))), ee[b] = !0;
    }), H.on("readable", q.bind(null, ee)), ee;
  };
  return ho = U, ho;
}
var lo, gl;
function Qm() {
  return gl || (gl = 1, lo = function() {
    throw new Error("Readable.from is not available in the browser");
  }), lo;
}
var po, ml;
function $c() {
  if (ml)
    return po;
  ml = 1, po = ie;
  var e;
  ie.ReadableState = Z, Lc.EventEmitter;
  var t = function(Y, re) {
    return Y.listeners(re).length;
  }, o = m1, r = pe.Buffer, h = (typeof Me < "u" ? Me : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function a(Y) {
    return r.from(Y);
  }
  function p(Y) {
    return r.isBuffer(Y) || Y instanceof h;
  }
  var d = wn, b;
  d && d.debuglog ? b = d.debuglog("stream") : b = function() {
  };
  var g = _m(), w = M1, C = N1, T = C.getHighWaterMark, k = ta.codes, q = k.ERR_INVALID_ARG_TYPE, O = k.ERR_STREAM_PUSH_AFTER_EOF, N = k.ERR_METHOD_NOT_IMPLEMENTED, j = k.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, U, H, z;
  ut(ie, o);
  var ee = w.errorOrDestroy, ne = ["error", "close", "destroy", "pause", "resume"];
  function le(Y, re, de) {
    if (typeof Y.prependListener == "function")
      return Y.prependListener(re, de);
    !Y._events || !Y._events[re] ? Y.on(re, de) : Array.isArray(Y._events[re]) ? Y._events[re].unshift(de) : Y._events[re] = [de, Y._events[re]];
  }
  function Z(Y, re, de) {
    e = e || Xn(), Y = Y || {}, typeof de != "boolean" && (de = re instanceof e), this.objectMode = !!Y.objectMode, de && (this.objectMode = this.objectMode || !!Y.readableObjectMode), this.highWaterMark = T(this, Y, "readableHighWaterMark", de), this.buffer = new g(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = Y.emitClose !== !1, this.autoDestroy = !!Y.autoDestroy, this.destroyed = !1, this.defaultEncoding = Y.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Y.encoding && (U || (U = Bs.StringDecoder), this.decoder = new U(Y.encoding), this.encoding = Y.encoding);
  }
  function ie(Y) {
    if (e = e || Xn(), !(this instanceof ie))
      return new ie(Y);
    var re = this instanceof e;
    this._readableState = new Z(Y, this, re), this.readable = !0, Y && (typeof Y.read == "function" && (this._read = Y.read), typeof Y.destroy == "function" && (this._destroy = Y.destroy)), o.call(this);
  }
  Object.defineProperty(ie.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Y) {
      this._readableState && (this._readableState.destroyed = Y);
    }
  }), ie.prototype.destroy = w.destroy, ie.prototype._undestroy = w.undestroy, ie.prototype._destroy = function(Y, re) {
    re(Y);
  }, ie.prototype.push = function(Y, re) {
    var de = this._readableState, Ae;
    return de.objectMode ? Ae = !0 : typeof Y == "string" && (re = re || de.defaultEncoding, re !== de.encoding && (Y = r.from(Y, re), re = ""), Ae = !0), fe(this, Y, re, !1, Ae);
  }, ie.prototype.unshift = function(Y) {
    return fe(this, Y, null, !0, !1);
  };
  function fe(Y, re, de, Ae, qe) {
    b("readableAddChunk", re);
    var x = Y._readableState;
    if (re === null)
      x.reading = !1, M(Y, x);
    else {
      var L;
      if (qe || (L = P(x, re)), L)
        ee(Y, L);
      else if (x.objectMode || re && re.length > 0)
        if (typeof re != "string" && !x.objectMode && Object.getPrototypeOf(re) !== r.prototype && (re = a(re)), Ae)
          x.endEmitted ? ee(Y, new j()) : I(Y, x, re, !0);
        else if (x.ended)
          ee(Y, new O());
        else {
          if (x.destroyed)
            return !1;
          x.reading = !1, x.decoder && !de ? (re = x.decoder.write(re), x.objectMode || re.length !== 0 ? I(Y, x, re, !1) : _(Y, x)) : I(Y, x, re, !1);
        }
      else
        Ae || (x.reading = !1, _(Y, x));
    }
    return !x.ended && (x.length < x.highWaterMark || x.length === 0);
  }
  function I(Y, re, de, Ae) {
    re.flowing && re.length === 0 && !re.sync ? (re.awaitDrain = 0, Y.emit("data", de)) : (re.length += re.objectMode ? 1 : de.length, Ae ? re.buffer.unshift(de) : re.buffer.push(de), re.needReadable && B(Y)), _(Y, re);
  }
  function P(Y, re) {
    var de;
    return !p(re) && typeof re != "string" && re !== void 0 && !Y.objectMode && (de = new q("chunk", ["string", "Buffer", "Uint8Array"], re)), de;
  }
  ie.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, ie.prototype.setEncoding = function(Y) {
    U || (U = Bs.StringDecoder);
    var re = new U(Y);
    this._readableState.decoder = re, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var de = this._readableState.buffer.head, Ae = ""; de !== null; )
      Ae += re.write(de.data), de = de.next;
    return this._readableState.buffer.clear(), Ae !== "" && this._readableState.buffer.push(Ae), this._readableState.length = Ae.length, this;
  };
  var f = 1073741824;
  function y(Y) {
    return Y >= f ? Y = f : (Y--, Y |= Y >>> 1, Y |= Y >>> 2, Y |= Y >>> 4, Y |= Y >>> 8, Y |= Y >>> 16, Y++), Y;
  }
  function v(Y, re) {
    return Y <= 0 || re.length === 0 && re.ended ? 0 : re.objectMode ? 1 : Y !== Y ? re.flowing && re.length ? re.buffer.head.data.length : re.length : (Y > re.highWaterMark && (re.highWaterMark = y(Y)), Y <= re.length ? Y : re.ended ? re.length : (re.needReadable = !0, 0));
  }
  ie.prototype.read = function(Y) {
    b("read", Y), Y = parseInt(Y, 10);
    var re = this._readableState, de = Y;
    if (Y !== 0 && (re.emittedReadable = !1), Y === 0 && re.needReadable && ((re.highWaterMark !== 0 ? re.length >= re.highWaterMark : re.length > 0) || re.ended))
      return b("read: emitReadable", re.length, re.ended), re.length === 0 && re.ended ? Q(this) : B(this), null;
    if (Y = v(Y, re), Y === 0 && re.ended)
      return re.length === 0 && Q(this), null;
    var Ae = re.needReadable;
    b("need readable", Ae), (re.length === 0 || re.length - Y < re.highWaterMark) && (Ae = !0, b("length less than watermark", Ae)), re.ended || re.reading ? (Ae = !1, b("reading or ended", Ae)) : Ae && (b("do read"), re.reading = !0, re.sync = !0, re.length === 0 && (re.needReadable = !0), this._read(re.highWaterMark), re.sync = !1, re.reading || (Y = v(de, re)));
    var qe;
    return Y > 0 ? qe = W(Y, re) : qe = null, qe === null ? (re.needReadable = re.length <= re.highWaterMark, Y = 0) : (re.length -= Y, re.awaitDrain = 0), re.length === 0 && (re.ended || (re.needReadable = !0), de !== Y && re.ended && Q(this)), qe !== null && this.emit("data", qe), qe;
  };
  function M(Y, re) {
    if (b("onEofChunk"), !re.ended) {
      if (re.decoder) {
        var de = re.decoder.end();
        de && de.length && (re.buffer.push(de), re.length += re.objectMode ? 1 : de.length);
      }
      re.ended = !0, re.sync ? B(Y) : (re.needReadable = !1, re.emittedReadable || (re.emittedReadable = !0, S(Y)));
    }
  }
  function B(Y) {
    var re = Y._readableState;
    b("emitReadable", re.needReadable, re.emittedReadable), re.needReadable = !1, re.emittedReadable || (b("emitReadable", re.flowing), re.emittedReadable = !0, Ve.nextTick(S, Y));
  }
  function S(Y) {
    var re = Y._readableState;
    b("emitReadable_", re.destroyed, re.length, re.ended), !re.destroyed && (re.length || re.ended) && (Y.emit("readable"), re.emittedReadable = !1), re.needReadable = !re.flowing && !re.ended && re.length <= re.highWaterMark, J(Y);
  }
  function _(Y, re) {
    re.readingMore || (re.readingMore = !0, Ve.nextTick(E, Y, re));
  }
  function E(Y, re) {
    for (; !re.reading && !re.ended && (re.length < re.highWaterMark || re.flowing && re.length === 0); ) {
      var de = re.length;
      if (b("maybeReadMore read 0"), Y.read(0), de === re.length)
        break;
    }
    re.readingMore = !1;
  }
  ie.prototype._read = function(Y) {
    ee(this, new N("_read()"));
  }, ie.prototype.pipe = function(Y, re) {
    var de = this, Ae = this._readableState;
    switch (Ae.pipesCount) {
      case 0:
        Ae.pipes = Y;
        break;
      case 1:
        Ae.pipes = [Ae.pipes, Y];
        break;
      default:
        Ae.pipes.push(Y);
        break;
    }
    Ae.pipesCount += 1, b("pipe count=%d opts=%j", Ae.pipesCount, re);
    var qe = (!re || re.end !== !1) && Y !== Ve.stdout && Y !== Ve.stderr, x = qe ? D : Ce;
    Ae.endEmitted ? Ve.nextTick(x) : de.once("end", x), Y.on("unpipe", L);
    function L(Le, Oe) {
      b("onunpipe"), Le === de && Oe && Oe.hasUnpiped === !1 && (Oe.hasUnpiped = !0, ge());
    }
    function D() {
      b("onend"), Y.end();
    }
    var F = m(de);
    Y.on("drain", F);
    var ue = !1;
    function ge() {
      b("cleanup"), Y.removeListener("close", Re), Y.removeListener("finish", ke), Y.removeListener("drain", F), Y.removeListener("error", ve), Y.removeListener("unpipe", L), de.removeListener("end", D), de.removeListener("end", Ce), de.removeListener("data", ce), ue = !0, Ae.awaitDrain && (!Y._writableState || Y._writableState.needDrain) && F();
    }
    de.on("data", ce);
    function ce(Le) {
      b("ondata");
      var Oe = Y.write(Le);
      b("dest.write", Oe), Oe === !1 && ((Ae.pipesCount === 1 && Ae.pipes === Y || Ae.pipesCount > 1 && be(Ae.pipes, Y) !== -1) && !ue && (b("false write response, pause", Ae.awaitDrain), Ae.awaitDrain++), de.pause());
    }
    function ve(Le) {
      b("onerror", Le), Ce(), Y.removeListener("error", ve), t(Y, "error") === 0 && ee(Y, Le);
    }
    le(Y, "error", ve);
    function Re() {
      Y.removeListener("finish", ke), Ce();
    }
    Y.once("close", Re);
    function ke() {
      b("onfinish"), Y.removeListener("close", Re), Ce();
    }
    Y.once("finish", ke);
    function Ce() {
      b("unpipe"), de.unpipe(Y);
    }
    return Y.emit("pipe", de), Ae.flowing || (b("pipe resume"), de.resume()), Y;
  };
  function m(Y) {
    return function() {
      var re = Y._readableState;
      b("pipeOnDrain", re.awaitDrain), re.awaitDrain && re.awaitDrain--, re.awaitDrain === 0 && t(Y, "data") && (re.flowing = !0, J(Y));
    };
  }
  ie.prototype.unpipe = function(Y) {
    var re = this._readableState, de = {
      hasUnpiped: !1
    };
    if (re.pipesCount === 0)
      return this;
    if (re.pipesCount === 1)
      return Y && Y !== re.pipes ? this : (Y || (Y = re.pipes), re.pipes = null, re.pipesCount = 0, re.flowing = !1, Y && Y.emit("unpipe", this, de), this);
    if (!Y) {
      var Ae = re.pipes, qe = re.pipesCount;
      re.pipes = null, re.pipesCount = 0, re.flowing = !1;
      for (var x = 0; x < qe; x++)
        Ae[x].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var L = be(re.pipes, Y);
    return L === -1 ? this : (re.pipes.splice(L, 1), re.pipesCount -= 1, re.pipesCount === 1 && (re.pipes = re.pipes[0]), Y.emit("unpipe", this, de), this);
  }, ie.prototype.on = function(Y, re) {
    var de = o.prototype.on.call(this, Y, re), Ae = this._readableState;
    return Y === "data" ? (Ae.readableListening = this.listenerCount("readable") > 0, Ae.flowing !== !1 && this.resume()) : Y === "readable" && !Ae.endEmitted && !Ae.readableListening && (Ae.readableListening = Ae.needReadable = !0, Ae.flowing = !1, Ae.emittedReadable = !1, b("on readable", Ae.length, Ae.reading), Ae.length ? B(this) : Ae.reading || Ve.nextTick($, this)), de;
  }, ie.prototype.addListener = ie.prototype.on, ie.prototype.removeListener = function(Y, re) {
    var de = o.prototype.removeListener.call(this, Y, re);
    return Y === "readable" && Ve.nextTick(A, this), de;
  }, ie.prototype.removeAllListeners = function(Y) {
    var re = o.prototype.removeAllListeners.apply(this, arguments);
    return (Y === "readable" || Y === void 0) && Ve.nextTick(A, this), re;
  };
  function A(Y) {
    var re = Y._readableState;
    re.readableListening = Y.listenerCount("readable") > 0, re.resumeScheduled && !re.paused ? re.flowing = !0 : Y.listenerCount("data") > 0 && Y.resume();
  }
  function $(Y) {
    b("readable nexttick read 0"), Y.read(0);
  }
  ie.prototype.resume = function() {
    var Y = this._readableState;
    return Y.flowing || (b("resume"), Y.flowing = !Y.readableListening, X(this, Y)), Y.paused = !1, this;
  };
  function X(Y, re) {
    re.resumeScheduled || (re.resumeScheduled = !0, Ve.nextTick(oe, Y, re));
  }
  function oe(Y, re) {
    b("resume", re.reading), re.reading || Y.read(0), re.resumeScheduled = !1, Y.emit("resume"), J(Y), re.flowing && !re.reading && Y.read(0);
  }
  ie.prototype.pause = function() {
    return b("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (b("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function J(Y) {
    var re = Y._readableState;
    for (b("flow", re.flowing); re.flowing && Y.read() !== null; )
      ;
  }
  ie.prototype.wrap = function(Y) {
    var re = this, de = this._readableState, Ae = !1;
    Y.on("end", function() {
      if (b("wrapped end"), de.decoder && !de.ended) {
        var L = de.decoder.end();
        L && L.length && re.push(L);
      }
      re.push(null);
    }), Y.on("data", function(L) {
      if (b("wrapped data"), de.decoder && (L = de.decoder.write(L)), !(de.objectMode && L == null) && !(!de.objectMode && (!L || !L.length))) {
        var D = re.push(L);
        D || (Ae = !0, Y.pause());
      }
    });
    for (var qe in Y)
      this[qe] === void 0 && typeof Y[qe] == "function" && (this[qe] = /* @__PURE__ */ function(L) {
        return function() {
          return Y[L].apply(Y, arguments);
        };
      }(qe));
    for (var x = 0; x < ne.length; x++)
      Y.on(ne[x], this.emit.bind(this, ne[x]));
    return this._read = function(L) {
      b("wrapped _read", L), Ae && (Ae = !1, Y.resume());
    }, this;
  }, typeof Symbol == "function" && (ie.prototype[Symbol.asyncIterator] = function() {
    return H === void 0 && (H = Xm()), H(this);
  }), Object.defineProperty(ie.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(ie.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(ie.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(Y) {
      this._readableState && (this._readableState.flowing = Y);
    }
  }), ie._fromList = W, Object.defineProperty(ie.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function W(Y, re) {
    if (re.length === 0)
      return null;
    var de;
    return re.objectMode ? de = re.buffer.shift() : !Y || Y >= re.length ? (re.decoder ? de = re.buffer.join("") : re.buffer.length === 1 ? de = re.buffer.first() : de = re.buffer.concat(re.length), re.buffer.clear()) : de = re.buffer.consume(Y, re.decoder), de;
  }
  function Q(Y) {
    var re = Y._readableState;
    b("endReadable", re.endEmitted), re.endEmitted || (re.ended = !0, Ve.nextTick(me, re, Y));
  }
  function me(Y, re) {
    if (b("endReadableNT", Y.endEmitted, Y.length), !Y.endEmitted && Y.length === 0 && (Y.endEmitted = !0, re.readable = !1, re.emit("end"), Y.autoDestroy)) {
      var de = re._writableState;
      (!de || de.autoDestroy && de.finished) && re.destroy();
    }
  }
  typeof Symbol == "function" && (ie.from = function(Y, re) {
    return z === void 0 && (z = Qm()), z(ie, Y, re);
  });
  function be(Y, re) {
    for (var de = 0, Ae = Y.length; de < Ae; de++)
      if (Y[de] === re)
        return de;
    return -1;
  }
  return po;
}
var Hc = sn, Zs = ta.codes, Zm = Zs.ERR_METHOD_NOT_IMPLEMENTED, Jm = Zs.ERR_MULTIPLE_CALLBACK, eb = Zs.ERR_TRANSFORM_ALREADY_TRANSFORMING, tb = Zs.ERR_TRANSFORM_WITH_LENGTH_0, Js = Xn();
ut(sn, Js);
function rb(e, t) {
  var o = this._transformState;
  o.transforming = !1;
  var r = o.writecb;
  if (r === null)
    return this.emit("error", new Jm());
  o.writechunk = null, o.writecb = null, t != null && this.push(t), r(e);
  var h = this._readableState;
  h.reading = !1, (h.needReadable || h.length < h.highWaterMark) && this._read(h.highWaterMark);
}
function sn(e) {
  if (!(this instanceof sn))
    return new sn(e);
  Js.call(this, e), this._transformState = {
    afterTransform: rb.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", ib);
}
function ib() {
  var e = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, o) {
    bl(e, t, o);
  }) : bl(this, null, null);
}
sn.prototype.push = function(e, t) {
  return this._transformState.needTransform = !1, Js.prototype.push.call(this, e, t);
};
sn.prototype._transform = function(e, t, o) {
  o(new Zm("_transform()"));
};
sn.prototype._write = function(e, t, o) {
  var r = this._transformState;
  if (r.writecb = o, r.writechunk = e, r.writeencoding = t, !r.transforming) {
    var h = this._readableState;
    (r.needTransform || h.needReadable || h.length < h.highWaterMark) && this._read(h.highWaterMark);
  }
};
sn.prototype._read = function(e) {
  var t = this._transformState;
  t.writechunk !== null && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
};
sn.prototype._destroy = function(e, t) {
  Js.prototype._destroy.call(this, e, function(o) {
    t(o);
  });
};
function bl(e, t, o) {
  if (t)
    return e.emit("error", t);
  if (o != null && e.push(o), e._writableState.length)
    throw new tb();
  if (e._transformState.transforming)
    throw new eb();
  return e.push(null);
}
var O1 = C0, P1 = Hc;
ut(C0, P1);
function C0(e) {
  if (!(this instanceof C0))
    return new C0(e);
  P1.call(this, e);
}
C0.prototype._transform = function(e, t, o) {
  o(null, e);
};
var vo;
function nb(e) {
  var t = !1;
  return function() {
    t || (t = !0, e.apply(void 0, arguments));
  };
}
var L1 = ta.codes, ab = L1.ERR_MISSING_ARGS, sb = L1.ERR_STREAM_DESTROYED;
function xl(e) {
  if (e)
    throw e;
}
function fb(e) {
  return e.setHeader && typeof e.abort == "function";
}
function ob(e, t, o, r) {
  r = nb(r);
  var h = !1;
  e.on("close", function() {
    h = !0;
  }), vo === void 0 && (vo = Qs), vo(e, {
    readable: t,
    writable: o
  }, function(p) {
    if (p)
      return r(p);
    h = !0, r();
  });
  var a = !1;
  return function(p) {
    if (!h && !a) {
      if (a = !0, fb(e))
        return e.abort();
      if (typeof e.destroy == "function")
        return e.destroy();
      r(p || new sb("pipe"));
    }
  };
}
function _l(e) {
  e();
}
function ub(e, t) {
  return e.pipe(t);
}
function cb(e) {
  return !e.length || typeof e[e.length - 1] != "function" ? xl : e.pop();
}
function hb() {
  for (var e = arguments.length, t = new Array(e), o = 0; o < e; o++)
    t[o] = arguments[o];
  var r = cb(t);
  if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
    throw new ab("streams");
  var h, a = t.map(function(p, d) {
    var b = d < t.length - 1, g = d > 0;
    return ob(p, b, g, function(w) {
      h || (h = w), w && a.forEach(_l), !b && (a.forEach(_l), r(h));
    });
  });
  return t.reduce(ub);
}
var k1 = hb;
(function(e, t) {
  t = e.exports = $c(), t.Stream = t, t.Readable = t, t.Writable = Vc(), t.Duplex = Xn(), t.Transform = Hc, t.PassThrough = O1, t.finished = Qs, t.pipeline = k1;
})(Xu, Xu.exports);
var U1 = Xu.exports, Is = ct.Buffer, F1 = U1.Transform, lb = ut;
function db(e, t) {
  if (!Is.isBuffer(e) && typeof e != "string")
    throw new TypeError(t + " must be a string or a buffer");
}
function Tn(e) {
  F1.call(this), this._block = Is.allocUnsafe(e), this._blockSize = e, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
lb(Tn, F1);
Tn.prototype._transform = function(e, t, o) {
  var r = null;
  try {
    this.update(e, t);
  } catch (h) {
    r = h;
  }
  o(r);
};
Tn.prototype._flush = function(e) {
  var t = null;
  try {
    this.push(this.digest());
  } catch (o) {
    t = o;
  }
  e(t);
};
Tn.prototype.update = function(e, t) {
  if (db(e, "Data"), this._finalized)
    throw new Error("Digest already called");
  Is.isBuffer(e) || (e = Is.from(e, t));
  for (var o = this._block, r = 0; this._blockOffset + e.length - r >= this._blockSize; ) {
    for (var h = this._blockOffset; h < this._blockSize; )
      o[h++] = e[r++];
    this._update(), this._blockOffset = 0;
  }
  for (; r < e.length; )
    o[this._blockOffset++] = e[r++];
  for (var a = 0, p = e.length * 8; p > 0; ++a)
    this._length[a] += p, p = this._length[a] / 4294967296 | 0, p > 0 && (this._length[a] -= 4294967296 * p);
  return this;
};
Tn.prototype._update = function() {
  throw new Error("_update is not implemented");
};
Tn.prototype.digest = function(e) {
  if (this._finalized)
    throw new Error("Digest already called");
  this._finalized = !0;
  var t = this._digest();
  e !== void 0 && (t = t.toString(e)), this._block.fill(0), this._blockOffset = 0;
  for (var o = 0; o < 4; ++o)
    this._length[o] = 0;
  return t;
};
Tn.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var q1 = Tn, pb = ut, V1 = q1, vb = ct.Buffer, yb = new Array(16);
function ef() {
  V1.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
pb(ef, V1);
ef.prototype._update = function() {
  for (var e = yb, t = 0; t < 16; ++t)
    e[t] = this._block.readInt32LE(t * 4);
  var o = this._a, r = this._b, h = this._c, a = this._d;
  o = ur(o, r, h, a, e[0], 3614090360, 7), a = ur(a, o, r, h, e[1], 3905402710, 12), h = ur(h, a, o, r, e[2], 606105819, 17), r = ur(r, h, a, o, e[3], 3250441966, 22), o = ur(o, r, h, a, e[4], 4118548399, 7), a = ur(a, o, r, h, e[5], 1200080426, 12), h = ur(h, a, o, r, e[6], 2821735955, 17), r = ur(r, h, a, o, e[7], 4249261313, 22), o = ur(o, r, h, a, e[8], 1770035416, 7), a = ur(a, o, r, h, e[9], 2336552879, 12), h = ur(h, a, o, r, e[10], 4294925233, 17), r = ur(r, h, a, o, e[11], 2304563134, 22), o = ur(o, r, h, a, e[12], 1804603682, 7), a = ur(a, o, r, h, e[13], 4254626195, 12), h = ur(h, a, o, r, e[14], 2792965006, 17), r = ur(r, h, a, o, e[15], 1236535329, 22), o = cr(o, r, h, a, e[1], 4129170786, 5), a = cr(a, o, r, h, e[6], 3225465664, 9), h = cr(h, a, o, r, e[11], 643717713, 14), r = cr(r, h, a, o, e[0], 3921069994, 20), o = cr(o, r, h, a, e[5], 3593408605, 5), a = cr(a, o, r, h, e[10], 38016083, 9), h = cr(h, a, o, r, e[15], 3634488961, 14), r = cr(r, h, a, o, e[4], 3889429448, 20), o = cr(o, r, h, a, e[9], 568446438, 5), a = cr(a, o, r, h, e[14], 3275163606, 9), h = cr(h, a, o, r, e[3], 4107603335, 14), r = cr(r, h, a, o, e[8], 1163531501, 20), o = cr(o, r, h, a, e[13], 2850285829, 5), a = cr(a, o, r, h, e[2], 4243563512, 9), h = cr(h, a, o, r, e[7], 1735328473, 14), r = cr(r, h, a, o, e[12], 2368359562, 20), o = hr(o, r, h, a, e[5], 4294588738, 4), a = hr(a, o, r, h, e[8], 2272392833, 11), h = hr(h, a, o, r, e[11], 1839030562, 16), r = hr(r, h, a, o, e[14], 4259657740, 23), o = hr(o, r, h, a, e[1], 2763975236, 4), a = hr(a, o, r, h, e[4], 1272893353, 11), h = hr(h, a, o, r, e[7], 4139469664, 16), r = hr(r, h, a, o, e[10], 3200236656, 23), o = hr(o, r, h, a, e[13], 681279174, 4), a = hr(a, o, r, h, e[0], 3936430074, 11), h = hr(h, a, o, r, e[3], 3572445317, 16), r = hr(r, h, a, o, e[6], 76029189, 23), o = hr(o, r, h, a, e[9], 3654602809, 4), a = hr(a, o, r, h, e[12], 3873151461, 11), h = hr(h, a, o, r, e[15], 530742520, 16), r = hr(r, h, a, o, e[2], 3299628645, 23), o = lr(o, r, h, a, e[0], 4096336452, 6), a = lr(a, o, r, h, e[7], 1126891415, 10), h = lr(h, a, o, r, e[14], 2878612391, 15), r = lr(r, h, a, o, e[5], 4237533241, 21), o = lr(o, r, h, a, e[12], 1700485571, 6), a = lr(a, o, r, h, e[3], 2399980690, 10), h = lr(h, a, o, r, e[10], 4293915773, 15), r = lr(r, h, a, o, e[1], 2240044497, 21), o = lr(o, r, h, a, e[8], 1873313359, 6), a = lr(a, o, r, h, e[15], 4264355552, 10), h = lr(h, a, o, r, e[6], 2734768916, 15), r = lr(r, h, a, o, e[13], 1309151649, 21), o = lr(o, r, h, a, e[4], 4149444226, 6), a = lr(a, o, r, h, e[11], 3174756917, 10), h = lr(h, a, o, r, e[2], 718787259, 15), r = lr(r, h, a, o, e[9], 3951481745, 21), this._a = this._a + o | 0, this._b = this._b + r | 0, this._c = this._c + h | 0, this._d = this._d + a | 0;
};
ef.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var e = vb.allocUnsafe(16);
  return e.writeInt32LE(this._a, 0), e.writeInt32LE(this._b, 4), e.writeInt32LE(this._c, 8), e.writeInt32LE(this._d, 12), e;
};
function tf(e, t) {
  return e << t | e >>> 32 - t;
}
function ur(e, t, o, r, h, a, p) {
  return tf(e + (t & o | ~t & r) + h + a | 0, p) + t | 0;
}
function cr(e, t, o, r, h, a, p) {
  return tf(e + (t & r | o & ~r) + h + a | 0, p) + t | 0;
}
function hr(e, t, o, r, h, a, p) {
  return tf(e + (t ^ o ^ r) + h + a | 0, p) + t | 0;
}
function lr(e, t, o, r, h, a, p) {
  return tf(e + (o ^ (t | ~r)) + h + a | 0, p) + t | 0;
}
var Gc = ef, yo = pe.Buffer, gb = ut, K1 = q1, mb = new Array(16), i0 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], n0 = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], a0 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], s0 = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], f0 = [0, 1518500249, 1859775393, 2400959708, 2840853838], o0 = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function rf() {
  K1.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
gb(rf, K1);
rf.prototype._update = function() {
  for (var e = mb, t = 0; t < 16; ++t)
    e[t] = this._block.readInt32LE(t * 4);
  for (var o = this._a | 0, r = this._b | 0, h = this._c | 0, a = this._d | 0, p = this._e | 0, d = this._a | 0, b = this._b | 0, g = this._c | 0, w = this._d | 0, C = this._e | 0, T = 0; T < 80; T += 1) {
    var k, q;
    T < 16 ? (k = El(o, r, h, a, p, e[i0[T]], f0[0], a0[T]), q = Al(d, b, g, w, C, e[n0[T]], o0[0], s0[T])) : T < 32 ? (k = Sl(o, r, h, a, p, e[i0[T]], f0[1], a0[T]), q = Cl(d, b, g, w, C, e[n0[T]], o0[1], s0[T])) : T < 48 ? (k = wl(o, r, h, a, p, e[i0[T]], f0[2], a0[T]), q = wl(d, b, g, w, C, e[n0[T]], o0[2], s0[T])) : T < 64 ? (k = Cl(o, r, h, a, p, e[i0[T]], f0[3], a0[T]), q = Sl(d, b, g, w, C, e[n0[T]], o0[3], s0[T])) : (k = Al(o, r, h, a, p, e[i0[T]], f0[4], a0[T]), q = El(d, b, g, w, C, e[n0[T]], o0[4], s0[T])), o = p, p = a, a = Qn(h, 10), h = r, r = k, d = C, C = w, w = Qn(g, 10), g = b, b = q;
  }
  var O = this._b + h + w | 0;
  this._b = this._c + a + C | 0, this._c = this._d + p + d | 0, this._d = this._e + o + b | 0, this._e = this._a + r + g | 0, this._a = O;
};
rf.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var e = yo.alloc ? yo.alloc(20) : new yo(20);
  return e.writeInt32LE(this._a, 0), e.writeInt32LE(this._b, 4), e.writeInt32LE(this._c, 8), e.writeInt32LE(this._d, 12), e.writeInt32LE(this._e, 16), e;
};
function Qn(e, t) {
  return e << t | e >>> 32 - t;
}
function El(e, t, o, r, h, a, p, d) {
  return Qn(e + (t ^ o ^ r) + a + p | 0, d) + h | 0;
}
function Sl(e, t, o, r, h, a, p, d) {
  return Qn(e + (t & o | ~t & r) + a + p | 0, d) + h | 0;
}
function wl(e, t, o, r, h, a, p, d) {
  return Qn(e + ((t | ~o) ^ r) + a + p | 0, d) + h | 0;
}
function Cl(e, t, o, r, h, a, p, d) {
  return Qn(e + (t & r | o & ~r) + a + p | 0, d) + h | 0;
}
function Al(e, t, o, r, h, a, p, d) {
  return Qn(e + (t ^ (o | ~r)) + a + p | 0, d) + h | 0;
}
var zc = rf, $1 = { exports: {} }, H1 = ct.Buffer;
function nf(e, t) {
  this._block = H1.alloc(e), this._finalSize = t, this._blockSize = e, this._len = 0;
}
nf.prototype.update = function(e, t) {
  typeof e == "string" && (t = t || "utf8", e = H1.from(e, t));
  for (var o = this._block, r = this._blockSize, h = e.length, a = this._len, p = 0; p < h; ) {
    for (var d = a % r, b = Math.min(h - p, r - d), g = 0; g < b; g++)
      o[d + g] = e[p + g];
    a += b, p += b, a % r === 0 && this._update(o);
  }
  return this._len += h, this;
};
nf.prototype.digest = function(e) {
  var t = this._len % this._blockSize;
  this._block[t] = 128, this._block.fill(0, t + 1), t >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var o = this._len * 8;
  if (o <= 4294967295)
    this._block.writeUInt32BE(o, this._blockSize - 4);
  else {
    var r = (o & 4294967295) >>> 0, h = (o - r) / 4294967296;
    this._block.writeUInt32BE(h, this._blockSize - 8), this._block.writeUInt32BE(r, this._blockSize - 4);
  }
  this._update(this._block);
  var a = this._hash();
  return e ? a.toString(e) : a;
};
nf.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var Fa = nf, bb = ut, G1 = Fa, xb = ct.Buffer, _b = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], Eb = new Array(80);
function R0() {
  this.init(), this._w = Eb, G1.call(this, 64, 56);
}
bb(R0, G1);
R0.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function Sb(e) {
  return e << 5 | e >>> 27;
}
function wb(e) {
  return e << 30 | e >>> 2;
}
function Cb(e, t, o, r) {
  return e === 0 ? t & o | ~t & r : e === 2 ? t & o | t & r | o & r : t ^ o ^ r;
}
R0.prototype._update = function(e) {
  for (var t = this._w, o = this._a | 0, r = this._b | 0, h = this._c | 0, a = this._d | 0, p = this._e | 0, d = 0; d < 16; ++d)
    t[d] = e.readInt32BE(d * 4);
  for (; d < 80; ++d)
    t[d] = t[d - 3] ^ t[d - 8] ^ t[d - 14] ^ t[d - 16];
  for (var b = 0; b < 80; ++b) {
    var g = ~~(b / 20), w = Sb(o) + Cb(g, r, h, a) + p + t[b] + _b[g] | 0;
    p = a, a = h, h = wb(r), r = o, o = w;
  }
  this._a = o + this._a | 0, this._b = r + this._b | 0, this._c = h + this._c | 0, this._d = a + this._d | 0, this._e = p + this._e | 0;
};
R0.prototype._hash = function() {
  var e = xb.allocUnsafe(20);
  return e.writeInt32BE(this._a | 0, 0), e.writeInt32BE(this._b | 0, 4), e.writeInt32BE(this._c | 0, 8), e.writeInt32BE(this._d | 0, 12), e.writeInt32BE(this._e | 0, 16), e;
};
var Ab = R0, Bb = ut, z1 = Fa, Ib = ct.Buffer, Tb = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], Mb = new Array(80);
function N0() {
  this.init(), this._w = Mb, z1.call(this, 64, 56);
}
Bb(N0, z1);
N0.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function Rb(e) {
  return e << 1 | e >>> 31;
}
function Nb(e) {
  return e << 5 | e >>> 27;
}
function Db(e) {
  return e << 30 | e >>> 2;
}
function Ob(e, t, o, r) {
  return e === 0 ? t & o | ~t & r : e === 2 ? t & o | t & r | o & r : t ^ o ^ r;
}
N0.prototype._update = function(e) {
  for (var t = this._w, o = this._a | 0, r = this._b | 0, h = this._c | 0, a = this._d | 0, p = this._e | 0, d = 0; d < 16; ++d)
    t[d] = e.readInt32BE(d * 4);
  for (; d < 80; ++d)
    t[d] = Rb(t[d - 3] ^ t[d - 8] ^ t[d - 14] ^ t[d - 16]);
  for (var b = 0; b < 80; ++b) {
    var g = ~~(b / 20), w = Nb(o) + Ob(g, r, h, a) + p + t[b] + Tb[g] | 0;
    p = a, a = h, h = Db(r), r = o, o = w;
  }
  this._a = o + this._a | 0, this._b = r + this._b | 0, this._c = h + this._c | 0, this._d = a + this._d | 0, this._e = p + this._e | 0;
};
N0.prototype._hash = function() {
  var e = Ib.allocUnsafe(20);
  return e.writeInt32BE(this._a | 0, 0), e.writeInt32BE(this._b | 0, 4), e.writeInt32BE(this._c | 0, 8), e.writeInt32BE(this._d | 0, 12), e.writeInt32BE(this._e | 0, 16), e;
};
var Pb = N0, Lb = ut, j1 = Fa, kb = ct.Buffer, Ub = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], Fb = new Array(64);
function D0() {
  this.init(), this._w = Fb, j1.call(this, 64, 56);
}
Lb(D0, j1);
D0.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function qb(e, t, o) {
  return o ^ e & (t ^ o);
}
function Vb(e, t, o) {
  return e & t | o & (e | t);
}
function Kb(e) {
  return (e >>> 2 | e << 30) ^ (e >>> 13 | e << 19) ^ (e >>> 22 | e << 10);
}
function $b(e) {
  return (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
}
function Hb(e) {
  return (e >>> 7 | e << 25) ^ (e >>> 18 | e << 14) ^ e >>> 3;
}
function Gb(e) {
  return (e >>> 17 | e << 15) ^ (e >>> 19 | e << 13) ^ e >>> 10;
}
D0.prototype._update = function(e) {
  for (var t = this._w, o = this._a | 0, r = this._b | 0, h = this._c | 0, a = this._d | 0, p = this._e | 0, d = this._f | 0, b = this._g | 0, g = this._h | 0, w = 0; w < 16; ++w)
    t[w] = e.readInt32BE(w * 4);
  for (; w < 64; ++w)
    t[w] = Gb(t[w - 2]) + t[w - 7] + Hb(t[w - 15]) + t[w - 16] | 0;
  for (var C = 0; C < 64; ++C) {
    var T = g + $b(p) + qb(p, d, b) + Ub[C] + t[C] | 0, k = Kb(o) + Vb(o, r, h) | 0;
    g = b, b = d, d = p, p = a + T | 0, a = h, h = r, r = o, o = T + k | 0;
  }
  this._a = o + this._a | 0, this._b = r + this._b | 0, this._c = h + this._c | 0, this._d = a + this._d | 0, this._e = p + this._e | 0, this._f = d + this._f | 0, this._g = b + this._g | 0, this._h = g + this._h | 0;
};
D0.prototype._hash = function() {
  var e = kb.allocUnsafe(32);
  return e.writeInt32BE(this._a, 0), e.writeInt32BE(this._b, 4), e.writeInt32BE(this._c, 8), e.writeInt32BE(this._d, 12), e.writeInt32BE(this._e, 16), e.writeInt32BE(this._f, 20), e.writeInt32BE(this._g, 24), e.writeInt32BE(this._h, 28), e;
};
var W1 = D0, zb = ut, jb = W1, Wb = Fa, Yb = ct.Buffer, Xb = new Array(64);
function af() {
  this.init(), this._w = Xb, Wb.call(this, 64, 56);
}
zb(af, jb);
af.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
af.prototype._hash = function() {
  var e = Yb.allocUnsafe(28);
  return e.writeInt32BE(this._a, 0), e.writeInt32BE(this._b, 4), e.writeInt32BE(this._c, 8), e.writeInt32BE(this._d, 12), e.writeInt32BE(this._e, 16), e.writeInt32BE(this._f, 20), e.writeInt32BE(this._g, 24), e;
};
var Qb = af, Zb = ut, Y1 = Fa, Jb = ct.Buffer, Bl = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], ex = new Array(160);
function O0() {
  this.init(), this._w = ex, Y1.call(this, 128, 112);
}
Zb(O0, Y1);
O0.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function Il(e, t, o) {
  return o ^ e & (t ^ o);
}
function Tl(e, t, o) {
  return e & t | o & (e | t);
}
function Ml(e, t) {
  return (e >>> 28 | t << 4) ^ (t >>> 2 | e << 30) ^ (t >>> 7 | e << 25);
}
function Rl(e, t) {
  return (e >>> 14 | t << 18) ^ (e >>> 18 | t << 14) ^ (t >>> 9 | e << 23);
}
function tx(e, t) {
  return (e >>> 1 | t << 31) ^ (e >>> 8 | t << 24) ^ e >>> 7;
}
function rx(e, t) {
  return (e >>> 1 | t << 31) ^ (e >>> 8 | t << 24) ^ (e >>> 7 | t << 25);
}
function ix(e, t) {
  return (e >>> 19 | t << 13) ^ (t >>> 29 | e << 3) ^ e >>> 6;
}
function nx(e, t) {
  return (e >>> 19 | t << 13) ^ (t >>> 29 | e << 3) ^ (e >>> 6 | t << 26);
}
function Wt(e, t) {
  return e >>> 0 < t >>> 0 ? 1 : 0;
}
O0.prototype._update = function(e) {
  for (var t = this._w, o = this._ah | 0, r = this._bh | 0, h = this._ch | 0, a = this._dh | 0, p = this._eh | 0, d = this._fh | 0, b = this._gh | 0, g = this._hh | 0, w = this._al | 0, C = this._bl | 0, T = this._cl | 0, k = this._dl | 0, q = this._el | 0, O = this._fl | 0, N = this._gl | 0, j = this._hl | 0, U = 0; U < 32; U += 2)
    t[U] = e.readInt32BE(U * 4), t[U + 1] = e.readInt32BE(U * 4 + 4);
  for (; U < 160; U += 2) {
    var H = t[U - 30], z = t[U - 15 * 2 + 1], ee = tx(H, z), ne = rx(z, H);
    H = t[U - 2 * 2], z = t[U - 2 * 2 + 1];
    var le = ix(H, z), Z = nx(z, H), ie = t[U - 7 * 2], fe = t[U - 7 * 2 + 1], I = t[U - 16 * 2], P = t[U - 16 * 2 + 1], f = ne + fe | 0, y = ee + ie + Wt(f, ne) | 0;
    f = f + Z | 0, y = y + le + Wt(f, Z) | 0, f = f + P | 0, y = y + I + Wt(f, P) | 0, t[U] = y, t[U + 1] = f;
  }
  for (var v = 0; v < 160; v += 2) {
    y = t[v], f = t[v + 1];
    var M = Tl(o, r, h), B = Tl(w, C, T), S = Ml(o, w), _ = Ml(w, o), E = Rl(p, q), m = Rl(q, p), A = Bl[v], $ = Bl[v + 1], X = Il(p, d, b), oe = Il(q, O, N), J = j + m | 0, W = g + E + Wt(J, j) | 0;
    J = J + oe | 0, W = W + X + Wt(J, oe) | 0, J = J + $ | 0, W = W + A + Wt(J, $) | 0, J = J + f | 0, W = W + y + Wt(J, f) | 0;
    var Q = _ + B | 0, me = S + M + Wt(Q, _) | 0;
    g = b, j = N, b = d, N = O, d = p, O = q, q = k + J | 0, p = a + W + Wt(q, k) | 0, a = h, k = T, h = r, T = C, r = o, C = w, w = J + Q | 0, o = W + me + Wt(w, J) | 0;
  }
  this._al = this._al + w | 0, this._bl = this._bl + C | 0, this._cl = this._cl + T | 0, this._dl = this._dl + k | 0, this._el = this._el + q | 0, this._fl = this._fl + O | 0, this._gl = this._gl + N | 0, this._hl = this._hl + j | 0, this._ah = this._ah + o + Wt(this._al, w) | 0, this._bh = this._bh + r + Wt(this._bl, C) | 0, this._ch = this._ch + h + Wt(this._cl, T) | 0, this._dh = this._dh + a + Wt(this._dl, k) | 0, this._eh = this._eh + p + Wt(this._el, q) | 0, this._fh = this._fh + d + Wt(this._fl, O) | 0, this._gh = this._gh + b + Wt(this._gl, N) | 0, this._hh = this._hh + g + Wt(this._hl, j) | 0;
};
O0.prototype._hash = function() {
  var e = Jb.allocUnsafe(64);
  function t(o, r, h) {
    e.writeInt32BE(o, h), e.writeInt32BE(r, h + 4);
  }
  return t(this._ah, this._al, 0), t(this._bh, this._bl, 8), t(this._ch, this._cl, 16), t(this._dh, this._dl, 24), t(this._eh, this._el, 32), t(this._fh, this._fl, 40), t(this._gh, this._gl, 48), t(this._hh, this._hl, 56), e;
};
var X1 = O0, ax = ut, sx = X1, fx = Fa, ox = ct.Buffer, ux = new Array(160);
function sf() {
  this.init(), this._w = ux, fx.call(this, 128, 112);
}
ax(sf, sx);
sf.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
sf.prototype._hash = function() {
  var e = ox.allocUnsafe(48);
  function t(o, r, h) {
    e.writeInt32BE(o, h), e.writeInt32BE(r, h + 4);
  }
  return t(this._ah, this._al, 0), t(this._bh, this._bl, 8), t(this._ch, this._cl, 16), t(this._dh, this._dl, 24), t(this._eh, this._el, 32), t(this._fh, this._fl, 40), e;
};
var cx = sf, ra = $1.exports = function(e) {
  e = e.toLowerCase();
  var t = ra[e];
  if (!t)
    throw new Error(e + " is not supported (we accept pull requests)");
  return new t();
};
ra.sha = Ab;
ra.sha1 = Pb;
ra.sha224 = Qb;
ra.sha256 = W1;
ra.sha384 = cx;
ra.sha512 = X1;
var jc = $1.exports, hx = jr, Wc = Lc.EventEmitter, lx = ut;
lx(jr, Wc);
jr.Readable = $c();
jr.Writable = Vc();
jr.Duplex = Xn();
jr.Transform = Hc;
jr.PassThrough = O1;
jr.finished = Qs;
jr.pipeline = k1;
jr.Stream = jr;
function jr() {
  Wc.call(this);
}
jr.prototype.pipe = function(e, t) {
  var o = this;
  function r(w) {
    e.writable && e.write(w) === !1 && o.pause && o.pause();
  }
  o.on("data", r);
  function h() {
    o.readable && o.resume && o.resume();
  }
  e.on("drain", h), !e._isStdio && (!t || t.end !== !1) && (o.on("end", p), o.on("close", d));
  var a = !1;
  function p() {
    a || (a = !0, e.end());
  }
  function d() {
    a || (a = !0, typeof e.destroy == "function" && e.destroy());
  }
  function b(w) {
    if (g(), Wc.listenerCount(this, "error") === 0)
      throw w;
  }
  o.on("error", b), e.on("error", b);
  function g() {
    o.removeListener("data", r), e.removeListener("drain", h), o.removeListener("end", p), o.removeListener("close", d), o.removeListener("error", b), e.removeListener("error", b), o.removeListener("end", g), o.removeListener("close", g), e.removeListener("close", g);
  }
  return o.on("end", g), o.on("close", g), e.on("close", g), e.emit("pipe", o), e;
};
var Q1 = ct.Buffer, Z1 = hx.Transform, dx = Bs.StringDecoder, px = ut;
function Ci(e) {
  Z1.call(this), this.hashMode = typeof e == "string", this.hashMode ? this[e] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
px(Ci, Z1);
Ci.prototype.update = function(e, t, o) {
  typeof e == "string" && (e = Q1.from(e, t));
  var r = this._update(e);
  return this.hashMode ? this : (o && (r = this._toString(r, o)), r);
};
Ci.prototype.setAutoPadding = function() {
};
Ci.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
Ci.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
Ci.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
Ci.prototype._transform = function(e, t, o) {
  var r;
  try {
    this.hashMode ? this._update(e) : this.push(this._update(e));
  } catch (h) {
    r = h;
  } finally {
    o(r);
  }
};
Ci.prototype._flush = function(e) {
  var t;
  try {
    this.push(this.__final());
  } catch (o) {
    t = o;
  }
  e(t);
};
Ci.prototype._finalOrDigest = function(e) {
  var t = this.__final() || Q1.alloc(0);
  return e && (t = this._toString(t, e, !0)), t;
};
Ci.prototype._toString = function(e, t, o) {
  if (this._decoder || (this._decoder = new dx(t), this._encoding = t), this._encoding !== t)
    throw new Error("can't switch encodings");
  var r = this._decoder.write(e);
  return o && (r += this._decoder.end()), r;
};
var Mn = Ci, vx = ut, yx = Gc, gx = zc, mx = jc, J1 = Mn;
function ff(e) {
  J1.call(this, "digest"), this._hash = e;
}
vx(ff, J1);
ff.prototype._update = function(e) {
  this._hash.update(e);
};
ff.prototype._final = function() {
  return this._hash.digest();
};
var P0 = function(e) {
  return e = e.toLowerCase(), e === "md5" ? new yx() : e === "rmd160" || e === "ripemd160" ? new gx() : new ff(mx(e));
}, bx = ut, Gn = ct.Buffer, ev = Mn, xx = Gn.alloc(128), ha = 64;
function of(e, t) {
  ev.call(this, "digest"), typeof t == "string" && (t = Gn.from(t)), this._alg = e, this._key = t, t.length > ha ? t = e(t) : t.length < ha && (t = Gn.concat([t, xx], ha));
  for (var o = this._ipad = Gn.allocUnsafe(ha), r = this._opad = Gn.allocUnsafe(ha), h = 0; h < ha; h++)
    o[h] = t[h] ^ 54, r[h] = t[h] ^ 92;
  this._hash = [o];
}
bx(of, ev);
of.prototype._update = function(e) {
  this._hash.push(e);
};
of.prototype._final = function() {
  var e = this._alg(Gn.concat(this._hash));
  return this._alg(Gn.concat([this._opad, e]));
};
var _x = of, Ex = Gc, tv = function(e) {
  return new Ex().update(e).digest();
}, Sx = ut, wx = _x, rv = Mn, y0 = ct.Buffer, Cx = tv, ic = zc, nc = jc, Ax = y0.alloc(128);
function A0(e, t) {
  rv.call(this, "digest"), typeof t == "string" && (t = y0.from(t));
  var o = e === "sha512" || e === "sha384" ? 128 : 64;
  if (this._alg = e, this._key = t, t.length > o) {
    var r = e === "rmd160" ? new ic() : nc(e);
    t = r.update(t).digest();
  } else
    t.length < o && (t = y0.concat([t, Ax], o));
  for (var h = this._ipad = y0.allocUnsafe(o), a = this._opad = y0.allocUnsafe(o), p = 0; p < o; p++)
    h[p] = t[p] ^ 54, a[p] = t[p] ^ 92;
  this._hash = e === "rmd160" ? new ic() : nc(e), this._hash.update(h);
}
Sx(A0, rv);
A0.prototype._update = function(e) {
  this._hash.update(e);
};
A0.prototype._final = function() {
  var e = this._hash.digest(), t = this._alg === "rmd160" ? new ic() : nc(this._alg);
  return t.update(this._opad).update(e).digest();
};
var iv = function(e, t) {
  return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new A0("rmd160", t) : e === "md5" ? new wx(Cx, t) : new A0(e, t);
};
const Bx = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, Ix = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, Tx = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, Mx = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, Rx = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, Nx = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, Dx = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, Ox = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, Px = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, Lx = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, kx = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, nv = {
  sha224WithRSAEncryption: Bx,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption: Ix,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption: Tx,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption: Mx,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: Rx,
  sha224: Nx,
  sha384: Dx,
  sha512: Ox,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA: Px,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA: Lx,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption: kx,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var Ux = nv, uf = {}, Fx = Math.pow(2, 30) - 1, av = function(e, t) {
  if (typeof e != "number")
    throw new TypeError("Iterations not a number");
  if (e < 0)
    throw new TypeError("Bad iterations");
  if (typeof t != "number")
    throw new TypeError("Key length not a number");
  if (t < 0 || t > Fx || t !== t)
    throw new TypeError("Bad key length");
}, ys;
if (Me.process && Me.process.browser)
  ys = "utf-8";
else if (Me.process && Me.process.version) {
  var qx = parseInt(Ve.version.split(".")[0].slice(1), 10);
  ys = qx >= 6 ? "utf-8" : "binary";
} else
  ys = "utf-8";
var sv = ys, go = ct.Buffer, fv = function(e, t, o) {
  if (go.isBuffer(e))
    return e;
  if (typeof e == "string")
    return go.from(e, t);
  if (ArrayBuffer.isView(e))
    return go.from(e.buffer);
  throw new TypeError(o + " must be a string, a Buffer, a typed array or a DataView");
}, Vx = tv, Kx = zc, $x = jc, zn = ct.Buffer, Hx = av, Nl = sv, Dl = fv, Gx = zn.alloc(128), gs = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};
function ov(e, t, o) {
  var r = zx(e), h = e === "sha512" || e === "sha384" ? 128 : 64;
  t.length > h ? t = r(t) : t.length < h && (t = zn.concat([t, Gx], h));
  for (var a = zn.allocUnsafe(h + gs[e]), p = zn.allocUnsafe(h + gs[e]), d = 0; d < h; d++)
    a[d] = t[d] ^ 54, p[d] = t[d] ^ 92;
  var b = zn.allocUnsafe(h + o + 4);
  a.copy(b, 0, 0, h), this.ipad1 = b, this.ipad2 = a, this.opad = p, this.alg = e, this.blocksize = h, this.hash = r, this.size = gs[e];
}
ov.prototype.run = function(e, t) {
  e.copy(t, this.blocksize);
  var o = this.hash(t);
  return o.copy(this.opad, this.blocksize), this.hash(this.opad);
};
function zx(e) {
  function t(r) {
    return $x(e).update(r).digest();
  }
  function o(r) {
    return new Kx().update(r).digest();
  }
  return e === "rmd160" || e === "ripemd160" ? o : e === "md5" ? Vx : t;
}
function jx(e, t, o, r, h) {
  Hx(o, r), e = Dl(e, Nl, "Password"), t = Dl(t, Nl, "Salt"), h = h || "sha1";
  var a = new ov(h, e, t.length), p = zn.allocUnsafe(r), d = zn.allocUnsafe(t.length + 4);
  t.copy(d, 0, 0, t.length);
  for (var b = 0, g = gs[h], w = Math.ceil(r / g), C = 1; C <= w; C++) {
    d.writeUInt32BE(C, t.length);
    for (var T = a.run(d, a.ipad1), k = T, q = 1; q < o; q++) {
      k = a.run(k, a.ipad2);
      for (var O = 0; O < g; O++)
        T[O] ^= k[O];
    }
    T.copy(p, b), b += g;
  }
  return p;
}
var uv = jx, cv = ct.Buffer, Wx = av, Ol = sv, Pl = uv, Ll = fv, X0, _0 = Me.crypto && Me.crypto.subtle, Yx = {
  sha: "SHA-1",
  "sha-1": "SHA-1",
  sha1: "SHA-1",
  sha256: "SHA-256",
  "sha-256": "SHA-256",
  sha384: "SHA-384",
  "sha-384": "SHA-384",
  "sha-512": "SHA-512",
  sha512: "SHA-512"
}, mo = [];
function Xx(e) {
  if (Me.process && !Me.process.browser || !_0 || !_0.importKey || !_0.deriveBits)
    return Promise.resolve(!1);
  if (mo[e] !== void 0)
    return mo[e];
  X0 = X0 || cv.alloc(8);
  var t = hv(X0, X0, 10, 128, e).then(function() {
    return !0;
  }).catch(function() {
    return !1;
  });
  return mo[e] = t, t;
}
var On;
function ac() {
  return On || (Me.process && Me.process.nextTick ? On = Me.process.nextTick : Me.queueMicrotask ? On = Me.queueMicrotask : Me.setImmediate ? On = Me.setImmediate : On = Me.setTimeout, On);
}
function hv(e, t, o, r, h) {
  return _0.importKey(
    "raw",
    e,
    { name: "PBKDF2" },
    !1,
    ["deriveBits"]
  ).then(function(a) {
    return _0.deriveBits({
      name: "PBKDF2",
      salt: t,
      iterations: o,
      hash: {
        name: h
      }
    }, a, r << 3);
  }).then(function(a) {
    return cv.from(a);
  });
}
function Qx(e, t) {
  e.then(function(o) {
    ac()(function() {
      t(null, o);
    });
  }, function(o) {
    ac()(function() {
      t(o);
    });
  });
}
var Zx = function(e, t, o, r, h, a) {
  typeof h == "function" && (a = h, h = void 0), h = h || "sha1";
  var p = Yx[h.toLowerCase()];
  if (!p || typeof Me.Promise != "function") {
    ac()(function() {
      var d;
      try {
        d = Pl(e, t, o, r, h);
      } catch (b) {
        return a(b);
      }
      a(null, d);
    });
    return;
  }
  if (Wx(o, r), e = Ll(e, Ol, "Password"), t = Ll(t, Ol, "Salt"), typeof a != "function")
    throw new Error("No callback provided to pbkdf2");
  Qx(Xx(p).then(function(d) {
    return d ? hv(e, t, o, r, p) : Pl(e, t, o, r, h);
  }), a);
};
uf.pbkdf2 = Zx;
uf.pbkdf2Sync = uv;
var Si = {}, qa = {}, Or = {};
Or.readUInt32BE = function(e, t) {
  var o = e[0 + t] << 24 | e[1 + t] << 16 | e[2 + t] << 8 | e[3 + t];
  return o >>> 0;
};
Or.writeUInt32BE = function(e, t, o) {
  e[0 + o] = t >>> 24, e[1 + o] = t >>> 16 & 255, e[2 + o] = t >>> 8 & 255, e[3 + o] = t & 255;
};
Or.ip = function(e, t, o, r) {
  for (var h = 0, a = 0, p = 6; p >= 0; p -= 2) {
    for (var d = 0; d <= 24; d += 8)
      h <<= 1, h |= t >>> d + p & 1;
    for (var d = 0; d <= 24; d += 8)
      h <<= 1, h |= e >>> d + p & 1;
  }
  for (var p = 6; p >= 0; p -= 2) {
    for (var d = 1; d <= 25; d += 8)
      a <<= 1, a |= t >>> d + p & 1;
    for (var d = 1; d <= 25; d += 8)
      a <<= 1, a |= e >>> d + p & 1;
  }
  o[r + 0] = h >>> 0, o[r + 1] = a >>> 0;
};
Or.rip = function(e, t, o, r) {
  for (var h = 0, a = 0, p = 0; p < 4; p++)
    for (var d = 24; d >= 0; d -= 8)
      h <<= 1, h |= t >>> d + p & 1, h <<= 1, h |= e >>> d + p & 1;
  for (var p = 4; p < 8; p++)
    for (var d = 24; d >= 0; d -= 8)
      a <<= 1, a |= t >>> d + p & 1, a <<= 1, a |= e >>> d + p & 1;
  o[r + 0] = h >>> 0, o[r + 1] = a >>> 0;
};
Or.pc1 = function(e, t, o, r) {
  for (var h = 0, a = 0, p = 7; p >= 5; p--) {
    for (var d = 0; d <= 24; d += 8)
      h <<= 1, h |= t >> d + p & 1;
    for (var d = 0; d <= 24; d += 8)
      h <<= 1, h |= e >> d + p & 1;
  }
  for (var d = 0; d <= 24; d += 8)
    h <<= 1, h |= t >> d + p & 1;
  for (var p = 1; p <= 3; p++) {
    for (var d = 0; d <= 24; d += 8)
      a <<= 1, a |= t >> d + p & 1;
    for (var d = 0; d <= 24; d += 8)
      a <<= 1, a |= e >> d + p & 1;
  }
  for (var d = 0; d <= 24; d += 8)
    a <<= 1, a |= e >> d + p & 1;
  o[r + 0] = h >>> 0, o[r + 1] = a >>> 0;
};
Or.r28shl = function(e, t) {
  return e << t & 268435455 | e >>> 28 - t;
};
var Q0 = [
  // inL => outL
  14,
  11,
  17,
  4,
  27,
  23,
  25,
  0,
  13,
  22,
  7,
  18,
  5,
  9,
  16,
  24,
  2,
  20,
  12,
  21,
  1,
  8,
  15,
  26,
  // inR => outR
  15,
  4,
  25,
  19,
  9,
  1,
  26,
  16,
  5,
  11,
  23,
  8,
  12,
  7,
  17,
  0,
  22,
  3,
  10,
  14,
  6,
  20,
  27,
  24
];
Or.pc2 = function(e, t, o, r) {
  for (var h = 0, a = 0, p = Q0.length >>> 1, d = 0; d < p; d++)
    h <<= 1, h |= e >>> Q0[d] & 1;
  for (var d = p; d < Q0.length; d++)
    a <<= 1, a |= t >>> Q0[d] & 1;
  o[r + 0] = h >>> 0, o[r + 1] = a >>> 0;
};
Or.expand = function(e, t, o) {
  var r = 0, h = 0;
  r = (e & 1) << 5 | e >>> 27;
  for (var a = 23; a >= 15; a -= 4)
    r <<= 6, r |= e >>> a & 63;
  for (var a = 11; a >= 3; a -= 4)
    h |= e >>> a & 63, h <<= 6;
  h |= (e & 31) << 1 | e >>> 31, t[o + 0] = r >>> 0, t[o + 1] = h >>> 0;
};
var kl = [
  14,
  0,
  4,
  15,
  13,
  7,
  1,
  4,
  2,
  14,
  15,
  2,
  11,
  13,
  8,
  1,
  3,
  10,
  10,
  6,
  6,
  12,
  12,
  11,
  5,
  9,
  9,
  5,
  0,
  3,
  7,
  8,
  4,
  15,
  1,
  12,
  14,
  8,
  8,
  2,
  13,
  4,
  6,
  9,
  2,
  1,
  11,
  7,
  15,
  5,
  12,
  11,
  9,
  3,
  7,
  14,
  3,
  10,
  10,
  0,
  5,
  6,
  0,
  13,
  15,
  3,
  1,
  13,
  8,
  4,
  14,
  7,
  6,
  15,
  11,
  2,
  3,
  8,
  4,
  14,
  9,
  12,
  7,
  0,
  2,
  1,
  13,
  10,
  12,
  6,
  0,
  9,
  5,
  11,
  10,
  5,
  0,
  13,
  14,
  8,
  7,
  10,
  11,
  1,
  10,
  3,
  4,
  15,
  13,
  4,
  1,
  2,
  5,
  11,
  8,
  6,
  12,
  7,
  6,
  12,
  9,
  0,
  3,
  5,
  2,
  14,
  15,
  9,
  10,
  13,
  0,
  7,
  9,
  0,
  14,
  9,
  6,
  3,
  3,
  4,
  15,
  6,
  5,
  10,
  1,
  2,
  13,
  8,
  12,
  5,
  7,
  14,
  11,
  12,
  4,
  11,
  2,
  15,
  8,
  1,
  13,
  1,
  6,
  10,
  4,
  13,
  9,
  0,
  8,
  6,
  15,
  9,
  3,
  8,
  0,
  7,
  11,
  4,
  1,
  15,
  2,
  14,
  12,
  3,
  5,
  11,
  10,
  5,
  14,
  2,
  7,
  12,
  7,
  13,
  13,
  8,
  14,
  11,
  3,
  5,
  0,
  6,
  6,
  15,
  9,
  0,
  10,
  3,
  1,
  4,
  2,
  7,
  8,
  2,
  5,
  12,
  11,
  1,
  12,
  10,
  4,
  14,
  15,
  9,
  10,
  3,
  6,
  15,
  9,
  0,
  0,
  6,
  12,
  10,
  11,
  1,
  7,
  13,
  13,
  8,
  15,
  9,
  1,
  4,
  3,
  5,
  14,
  11,
  5,
  12,
  2,
  7,
  8,
  2,
  4,
  14,
  2,
  14,
  12,
  11,
  4,
  2,
  1,
  12,
  7,
  4,
  10,
  7,
  11,
  13,
  6,
  1,
  8,
  5,
  5,
  0,
  3,
  15,
  15,
  10,
  13,
  3,
  0,
  9,
  14,
  8,
  9,
  6,
  4,
  11,
  2,
  8,
  1,
  12,
  11,
  7,
  10,
  1,
  13,
  14,
  7,
  2,
  8,
  13,
  15,
  6,
  9,
  15,
  12,
  0,
  5,
  9,
  6,
  10,
  3,
  4,
  0,
  5,
  14,
  3,
  12,
  10,
  1,
  15,
  10,
  4,
  15,
  2,
  9,
  7,
  2,
  12,
  6,
  9,
  8,
  5,
  0,
  6,
  13,
  1,
  3,
  13,
  4,
  14,
  14,
  0,
  7,
  11,
  5,
  3,
  11,
  8,
  9,
  4,
  14,
  3,
  15,
  2,
  5,
  12,
  2,
  9,
  8,
  5,
  12,
  15,
  3,
  10,
  7,
  11,
  0,
  14,
  4,
  1,
  10,
  7,
  1,
  6,
  13,
  0,
  11,
  8,
  6,
  13,
  4,
  13,
  11,
  0,
  2,
  11,
  14,
  7,
  15,
  4,
  0,
  9,
  8,
  1,
  13,
  10,
  3,
  14,
  12,
  3,
  9,
  5,
  7,
  12,
  5,
  2,
  10,
  15,
  6,
  8,
  1,
  6,
  1,
  6,
  4,
  11,
  11,
  13,
  13,
  8,
  12,
  1,
  3,
  4,
  7,
  10,
  14,
  7,
  10,
  9,
  15,
  5,
  6,
  0,
  8,
  15,
  0,
  14,
  5,
  2,
  9,
  3,
  2,
  12,
  13,
  1,
  2,
  15,
  8,
  13,
  4,
  8,
  6,
  10,
  15,
  3,
  11,
  7,
  1,
  4,
  10,
  12,
  9,
  5,
  3,
  6,
  14,
  11,
  5,
  0,
  0,
  14,
  12,
  9,
  7,
  2,
  7,
  2,
  11,
  1,
  4,
  14,
  1,
  7,
  9,
  4,
  12,
  10,
  14,
  8,
  2,
  13,
  0,
  15,
  6,
  12,
  10,
  9,
  13,
  0,
  15,
  3,
  3,
  5,
  5,
  6,
  8,
  11
];
Or.substitute = function(e, t) {
  for (var o = 0, r = 0; r < 4; r++) {
    var h = e >>> 18 - r * 6 & 63, a = kl[r * 64 + h];
    o <<= 4, o |= a;
  }
  for (var r = 0; r < 4; r++) {
    var h = t >>> 18 - r * 6 & 63, a = kl[4 * 64 + r * 64 + h];
    o <<= 4, o |= a;
  }
  return o >>> 0;
};
var Ul = [
  16,
  25,
  12,
  11,
  3,
  20,
  4,
  15,
  31,
  17,
  9,
  6,
  27,
  14,
  1,
  22,
  30,
  24,
  8,
  18,
  0,
  5,
  29,
  23,
  13,
  19,
  2,
  26,
  10,
  21,
  28,
  7
];
Or.permute = function(e) {
  for (var t = 0, o = 0; o < Ul.length; o++)
    t <<= 1, t |= e >>> Ul[o] & 1;
  return t >>> 0;
};
Or.padSplit = function(e, t, o) {
  for (var r = e.toString(2); r.length < t; )
    r = "0" + r;
  for (var h = [], a = 0; a < t; a += o)
    h.push(r.slice(a, a + o));
  return h.join(" ");
};
var Qr = lv;
function lv(e, t) {
  if (!e)
    throw new Error(t || "Assertion failed");
}
lv.equal = function(e, t, o) {
  if (e != t)
    throw new Error(o || "Assertion failed: " + e + " != " + t);
};
var Jx = Qr;
function Zr(e) {
  this.options = e, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = e.padding !== !1;
}
var Yc = Zr;
Zr.prototype._init = function() {
};
Zr.prototype.update = function(e) {
  return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e);
};
Zr.prototype._buffer = function(e, t) {
  for (var o = Math.min(this.buffer.length - this.bufferOff, e.length - t), r = 0; r < o; r++)
    this.buffer[this.bufferOff + r] = e[t + r];
  return this.bufferOff += o, o;
};
Zr.prototype._flushBuffer = function(e, t) {
  return this._update(this.buffer, 0, e, t), this.bufferOff = 0, this.blockSize;
};
Zr.prototype._updateEncrypt = function(e) {
  var t = 0, o = 0, r = (this.bufferOff + e.length) / this.blockSize | 0, h = new Array(r * this.blockSize);
  this.bufferOff !== 0 && (t += this._buffer(e, t), this.bufferOff === this.buffer.length && (o += this._flushBuffer(h, o)));
  for (var a = e.length - (e.length - t) % this.blockSize; t < a; t += this.blockSize)
    this._update(e, t, h, o), o += this.blockSize;
  for (; t < e.length; t++, this.bufferOff++)
    this.buffer[this.bufferOff] = e[t];
  return h;
};
Zr.prototype._updateDecrypt = function(e) {
  for (var t = 0, o = 0, r = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, h = new Array(r * this.blockSize); r > 0; r--)
    t += this._buffer(e, t), o += this._flushBuffer(h, o);
  return t += this._buffer(e, t), h;
};
Zr.prototype.final = function(e) {
  var t;
  e && (t = this.update(e));
  var o;
  return this.type === "encrypt" ? o = this._finalEncrypt() : o = this._finalDecrypt(), t ? t.concat(o) : o;
};
Zr.prototype._pad = function(e, t) {
  if (t === 0)
    return !1;
  for (; t < e.length; )
    e[t++] = 0;
  return !0;
};
Zr.prototype._finalEncrypt = function() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];
  var e = new Array(this.blockSize);
  return this._update(this.buffer, 0, e, 0), e;
};
Zr.prototype._unpad = function(e) {
  return e;
};
Zr.prototype._finalDecrypt = function() {
  Jx.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
  var e = new Array(this.blockSize);
  return this._flushBuffer(e, 0), this._unpad(e);
};
var dv = Qr, e4 = ut, jt = Or, pv = Yc;
function t4() {
  this.tmp = new Array(2), this.keys = null;
}
function $i(e) {
  pv.call(this, e);
  var t = new t4();
  this._desState = t, this.deriveKeys(t, e.key);
}
e4($i, pv);
var vv = $i;
$i.create = function(e) {
  return new $i(e);
};
var r4 = [
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1
];
$i.prototype.deriveKeys = function(e, t) {
  e.keys = new Array(16 * 2), dv.equal(t.length, this.blockSize, "Invalid key length");
  var o = jt.readUInt32BE(t, 0), r = jt.readUInt32BE(t, 4);
  jt.pc1(o, r, e.tmp, 0), o = e.tmp[0], r = e.tmp[1];
  for (var h = 0; h < e.keys.length; h += 2) {
    var a = r4[h >>> 1];
    o = jt.r28shl(o, a), r = jt.r28shl(r, a), jt.pc2(o, r, e.keys, h);
  }
};
$i.prototype._update = function(e, t, o, r) {
  var h = this._desState, a = jt.readUInt32BE(e, t), p = jt.readUInt32BE(e, t + 4);
  jt.ip(a, p, h.tmp, 0), a = h.tmp[0], p = h.tmp[1], this.type === "encrypt" ? this._encrypt(h, a, p, h.tmp, 0) : this._decrypt(h, a, p, h.tmp, 0), a = h.tmp[0], p = h.tmp[1], jt.writeUInt32BE(o, a, r), jt.writeUInt32BE(o, p, r + 4);
};
$i.prototype._pad = function(e, t) {
  if (this.padding === !1)
    return !1;
  for (var o = e.length - t, r = t; r < e.length; r++)
    e[r] = o;
  return !0;
};
$i.prototype._unpad = function(e) {
  if (this.padding === !1)
    return e;
  for (var t = e[e.length - 1], o = e.length - t; o < e.length; o++)
    dv.equal(e[o], t);
  return e.slice(0, e.length - t);
};
$i.prototype._encrypt = function(e, t, o, r, h) {
  for (var a = t, p = o, d = 0; d < e.keys.length; d += 2) {
    var b = e.keys[d], g = e.keys[d + 1];
    jt.expand(p, e.tmp, 0), b ^= e.tmp[0], g ^= e.tmp[1];
    var w = jt.substitute(b, g), C = jt.permute(w), T = p;
    p = (a ^ C) >>> 0, a = T;
  }
  jt.rip(p, a, r, h);
};
$i.prototype._decrypt = function(e, t, o, r, h) {
  for (var a = o, p = t, d = e.keys.length - 2; d >= 0; d -= 2) {
    var b = e.keys[d], g = e.keys[d + 1];
    jt.expand(a, e.tmp, 0), b ^= e.tmp[0], g ^= e.tmp[1];
    var w = jt.substitute(b, g), C = jt.permute(w), T = a;
    a = (p ^ C) >>> 0, p = T;
  }
  jt.rip(a, p, r, h);
};
var yv = {}, i4 = Qr, n4 = ut, Ts = {};
function a4(e) {
  i4.equal(e.length, 8, "Invalid IV length"), this.iv = new Array(8);
  for (var t = 0; t < this.iv.length; t++)
    this.iv[t] = e[t];
}
function s4(e) {
  function t(a) {
    e.call(this, a), this._cbcInit();
  }
  n4(t, e);
  for (var o = Object.keys(Ts), r = 0; r < o.length; r++) {
    var h = o[r];
    t.prototype[h] = Ts[h];
  }
  return t.create = function(a) {
    return new t(a);
  }, t;
}
yv.instantiate = s4;
Ts._cbcInit = function() {
  var e = new a4(this.options.iv);
  this._cbcState = e;
};
Ts._update = function(e, t, o, r) {
  var h = this._cbcState, a = this.constructor.super_.prototype, p = h.iv;
  if (this.type === "encrypt") {
    for (var d = 0; d < this.blockSize; d++)
      p[d] ^= e[t + d];
    a._update.call(this, p, 0, o, r);
    for (var d = 0; d < this.blockSize; d++)
      p[d] = o[r + d];
  } else {
    a._update.call(this, e, t, o, r);
    for (var d = 0; d < this.blockSize; d++)
      o[r + d] ^= p[d];
    for (var d = 0; d < this.blockSize; d++)
      p[d] = e[t + d];
  }
};
var f4 = Qr, o4 = ut, gv = Yc, pn = vv;
function u4(e, t) {
  f4.equal(t.length, 24, "Invalid key length");
  var o = t.slice(0, 8), r = t.slice(8, 16), h = t.slice(16, 24);
  e === "encrypt" ? this.ciphers = [
    pn.create({ type: "encrypt", key: o }),
    pn.create({ type: "decrypt", key: r }),
    pn.create({ type: "encrypt", key: h })
  ] : this.ciphers = [
    pn.create({ type: "decrypt", key: h }),
    pn.create({ type: "encrypt", key: r }),
    pn.create({ type: "decrypt", key: o })
  ];
}
function Zn(e) {
  gv.call(this, e);
  var t = new u4(this.type, this.options.key);
  this._edeState = t;
}
o4(Zn, gv);
var c4 = Zn;
Zn.create = function(e) {
  return new Zn(e);
};
Zn.prototype._update = function(e, t, o, r) {
  var h = this._edeState;
  h.ciphers[0]._update(e, t, o, r), h.ciphers[1]._update(o, r, o, r), h.ciphers[2]._update(o, r, o, r);
};
Zn.prototype._pad = pn.prototype._pad;
Zn.prototype._unpad = pn.prototype._unpad;
qa.utils = Or;
qa.Cipher = Yc;
qa.DES = vv;
qa.CBC = yv;
qa.EDE = c4;
var mv = Mn, Xi = qa, h4 = ut, qn = ct.Buffer, B0 = {
  "des-ede3-cbc": Xi.CBC.instantiate(Xi.EDE),
  "des-ede3": Xi.EDE,
  "des-ede-cbc": Xi.CBC.instantiate(Xi.EDE),
  "des-ede": Xi.EDE,
  "des-cbc": Xi.CBC.instantiate(Xi.DES),
  "des-ecb": Xi.DES
};
B0.des = B0["des-cbc"];
B0.des3 = B0["des-ede3-cbc"];
var l4 = cf;
h4(cf, mv);
function cf(e) {
  mv.call(this);
  var t = e.mode.toLowerCase(), o = B0[t], r;
  e.decrypt ? r = "decrypt" : r = "encrypt";
  var h = e.key;
  qn.isBuffer(h) || (h = qn.from(h)), (t === "des-ede" || t === "des-ede-cbc") && (h = qn.concat([h, h.slice(0, 8)]));
  var a = e.iv;
  qn.isBuffer(a) || (a = qn.from(a)), this._des = o.create({
    key: h,
    iv: a,
    type: r
  });
}
cf.prototype._update = function(e) {
  return qn.from(this._des.update(e));
};
cf.prototype._final = function() {
  return qn.from(this._des.final());
};
var Dr = {}, Xc = {}, Qc = {};
Qc.encrypt = function(e, t) {
  return e._cipher.encryptBlock(t);
};
Qc.decrypt = function(e, t) {
  return e._cipher.decryptBlock(t);
};
var Zc = {}, L0 = function(e, t) {
  for (var o = Math.min(e.length, t.length), r = new pe.Buffer(o), h = 0; h < o; ++h)
    r[h] = e[h] ^ t[h];
  return r;
}, bv = L0;
Zc.encrypt = function(e, t) {
  var o = bv(t, e._prev);
  return e._prev = e._cipher.encryptBlock(o), e._prev;
};
Zc.decrypt = function(e, t) {
  var o = e._prev;
  e._prev = t;
  var r = e._cipher.decryptBlock(t);
  return bv(r, o);
};
var xv = {}, g0 = ct.Buffer, d4 = L0;
function Fl(e, t, o) {
  var r = t.length, h = d4(t, e._cache);
  return e._cache = e._cache.slice(r), e._prev = g0.concat([e._prev, o ? t : h]), h;
}
xv.encrypt = function(e, t, o) {
  for (var r = g0.allocUnsafe(0), h; t.length; )
    if (e._cache.length === 0 && (e._cache = e._cipher.encryptBlock(e._prev), e._prev = g0.allocUnsafe(0)), e._cache.length <= t.length)
      h = e._cache.length, r = g0.concat([r, Fl(e, t.slice(0, h), o)]), t = t.slice(h);
    else {
      r = g0.concat([r, Fl(e, t, o)]);
      break;
    }
  return r;
};
var _v = {}, sc = ct.Buffer;
function p4(e, t, o) {
  var r = e._cipher.encryptBlock(e._prev), h = r[0] ^ t;
  return e._prev = sc.concat([
    e._prev.slice(1),
    sc.from([o ? t : h])
  ]), h;
}
_v.encrypt = function(e, t, o) {
  for (var r = t.length, h = sc.allocUnsafe(r), a = -1; ++a < r; )
    h[a] = p4(e, t[a], o);
  return h;
};
var Ev = {}, ms = ct.Buffer;
function v4(e, t, o) {
  for (var r, h = -1, a = 8, p = 0, d, b; ++h < a; )
    r = e._cipher.encryptBlock(e._prev), d = t & 1 << 7 - h ? 128 : 0, b = r[0] ^ d, p += (b & 128) >> h % 8, e._prev = y4(e._prev, o ? d : b);
  return p;
}
function y4(e, t) {
  var o = e.length, r = -1, h = ms.allocUnsafe(e.length);
  for (e = ms.concat([e, ms.from([t])]); ++r < o; )
    h[r] = e[r] << 1 | e[r + 1] >> 7;
  return h;
}
Ev.encrypt = function(e, t, o) {
  for (var r = t.length, h = ms.allocUnsafe(r), a = -1; ++a < r; )
    h[a] = v4(e, t[a], o);
  return h;
};
var Sv = {}, g4 = L0;
function m4(e) {
  return e._prev = e._cipher.encryptBlock(e._prev), e._prev;
}
Sv.encrypt = function(e, t) {
  for (; e._cache.length < t.length; )
    e._cache = pe.Buffer.concat([e._cache, m4(e)]);
  var o = e._cache.slice(0, t.length);
  return e._cache = e._cache.slice(t.length), g4(t, o);
};
var fc = {};
function b4(e) {
  for (var t = e.length, o; t--; )
    if (o = e.readUInt8(t), o === 255)
      e.writeUInt8(0, t);
    else {
      o++, e.writeUInt8(o, t);
      break;
    }
}
var wv = b4, x4 = L0, ql = ct.Buffer, _4 = wv;
function E4(e) {
  var t = e._cipher.encryptBlockRaw(e._prev);
  return _4(e._prev), t;
}
var bo = 16;
fc.encrypt = function(e, t) {
  var o = Math.ceil(t.length / bo), r = e._cache.length;
  e._cache = ql.concat([
    e._cache,
    ql.allocUnsafe(o * bo)
  ]);
  for (var h = 0; h < o; h++) {
    var a = E4(e), p = r + h * bo;
    e._cache.writeUInt32BE(a[0], p + 0), e._cache.writeUInt32BE(a[1], p + 4), e._cache.writeUInt32BE(a[2], p + 8), e._cache.writeUInt32BE(a[3], p + 12);
  }
  var d = e._cache.slice(0, t.length);
  return e._cache = e._cache.slice(t.length), x4(t, d);
};
const S4 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, w4 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, C4 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, Cv = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128: S4,
  aes192: w4,
  aes256: C4,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var A4 = {
  ECB: Qc,
  CBC: Zc,
  CFB: xv,
  CFB8: _v,
  CFB1: Ev,
  OFB: Sv,
  CTR: fc,
  GCM: fc
}, bs = Cv;
for (var Vl in bs)
  bs[Vl].module = A4[bs[Vl].mode];
var Jc = bs, k0 = {}, Ms = ct.Buffer;
function eh(e) {
  Ms.isBuffer(e) || (e = Ms.from(e));
  for (var t = e.length / 4 | 0, o = new Array(t), r = 0; r < t; r++)
    o[r] = e.readUInt32BE(r * 4);
  return o;
}
function xo(e) {
  for (var t = 0; t < e.length; e++)
    e[t] = 0;
}
function Av(e, t, o, r, h) {
  for (var a = o[0], p = o[1], d = o[2], b = o[3], g = e[0] ^ t[0], w = e[1] ^ t[1], C = e[2] ^ t[2], T = e[3] ^ t[3], k, q, O, N, j = 4, U = 1; U < h; U++)
    k = a[g >>> 24] ^ p[w >>> 16 & 255] ^ d[C >>> 8 & 255] ^ b[T & 255] ^ t[j++], q = a[w >>> 24] ^ p[C >>> 16 & 255] ^ d[T >>> 8 & 255] ^ b[g & 255] ^ t[j++], O = a[C >>> 24] ^ p[T >>> 16 & 255] ^ d[g >>> 8 & 255] ^ b[w & 255] ^ t[j++], N = a[T >>> 24] ^ p[g >>> 16 & 255] ^ d[w >>> 8 & 255] ^ b[C & 255] ^ t[j++], g = k, w = q, C = O, T = N;
  return k = (r[g >>> 24] << 24 | r[w >>> 16 & 255] << 16 | r[C >>> 8 & 255] << 8 | r[T & 255]) ^ t[j++], q = (r[w >>> 24] << 24 | r[C >>> 16 & 255] << 16 | r[T >>> 8 & 255] << 8 | r[g & 255]) ^ t[j++], O = (r[C >>> 24] << 24 | r[T >>> 16 & 255] << 16 | r[g >>> 8 & 255] << 8 | r[w & 255]) ^ t[j++], N = (r[T >>> 24] << 24 | r[g >>> 16 & 255] << 16 | r[w >>> 8 & 255] << 8 | r[C & 255]) ^ t[j++], k = k >>> 0, q = q >>> 0, O = O >>> 0, N = N >>> 0, [k, q, O, N];
}
var B4 = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], Ht = function() {
  for (var e = new Array(256), t = 0; t < 256; t++)
    t < 128 ? e[t] = t << 1 : e[t] = t << 1 ^ 283;
  for (var o = [], r = [], h = [[], [], [], []], a = [[], [], [], []], p = 0, d = 0, b = 0; b < 256; ++b) {
    var g = d ^ d << 1 ^ d << 2 ^ d << 3 ^ d << 4;
    g = g >>> 8 ^ g & 255 ^ 99, o[p] = g, r[g] = p;
    var w = e[p], C = e[w], T = e[C], k = e[g] * 257 ^ g * 16843008;
    h[0][p] = k << 24 | k >>> 8, h[1][p] = k << 16 | k >>> 16, h[2][p] = k << 8 | k >>> 24, h[3][p] = k, k = T * 16843009 ^ C * 65537 ^ w * 257 ^ p * 16843008, a[0][g] = k << 24 | k >>> 8, a[1][g] = k << 16 | k >>> 16, a[2][g] = k << 8 | k >>> 24, a[3][g] = k, p === 0 ? p = d = 1 : (p = w ^ e[e[e[T ^ w]]], d ^= e[e[d]]);
  }
  return {
    SBOX: o,
    INV_SBOX: r,
    SUB_MIX: h,
    INV_SUB_MIX: a
  };
}();
function Wr(e) {
  this._key = eh(e), this._reset();
}
Wr.blockSize = 4 * 4;
Wr.keySize = 256 / 8;
Wr.prototype.blockSize = Wr.blockSize;
Wr.prototype.keySize = Wr.keySize;
Wr.prototype._reset = function() {
  for (var e = this._key, t = e.length, o = t + 6, r = (o + 1) * 4, h = [], a = 0; a < t; a++)
    h[a] = e[a];
  for (a = t; a < r; a++) {
    var p = h[a - 1];
    a % t === 0 ? (p = p << 8 | p >>> 24, p = Ht.SBOX[p >>> 24] << 24 | Ht.SBOX[p >>> 16 & 255] << 16 | Ht.SBOX[p >>> 8 & 255] << 8 | Ht.SBOX[p & 255], p ^= B4[a / t | 0] << 24) : t > 6 && a % t === 4 && (p = Ht.SBOX[p >>> 24] << 24 | Ht.SBOX[p >>> 16 & 255] << 16 | Ht.SBOX[p >>> 8 & 255] << 8 | Ht.SBOX[p & 255]), h[a] = h[a - t] ^ p;
  }
  for (var d = [], b = 0; b < r; b++) {
    var g = r - b, w = h[g - (b % 4 ? 0 : 4)];
    b < 4 || g <= 4 ? d[b] = w : d[b] = Ht.INV_SUB_MIX[0][Ht.SBOX[w >>> 24]] ^ Ht.INV_SUB_MIX[1][Ht.SBOX[w >>> 16 & 255]] ^ Ht.INV_SUB_MIX[2][Ht.SBOX[w >>> 8 & 255]] ^ Ht.INV_SUB_MIX[3][Ht.SBOX[w & 255]];
  }
  this._nRounds = o, this._keySchedule = h, this._invKeySchedule = d;
};
Wr.prototype.encryptBlockRaw = function(e) {
  return e = eh(e), Av(e, this._keySchedule, Ht.SUB_MIX, Ht.SBOX, this._nRounds);
};
Wr.prototype.encryptBlock = function(e) {
  var t = this.encryptBlockRaw(e), o = Ms.allocUnsafe(16);
  return o.writeUInt32BE(t[0], 0), o.writeUInt32BE(t[1], 4), o.writeUInt32BE(t[2], 8), o.writeUInt32BE(t[3], 12), o;
};
Wr.prototype.decryptBlock = function(e) {
  e = eh(e);
  var t = e[1];
  e[1] = e[3], e[3] = t;
  var o = Av(e, this._invKeySchedule, Ht.INV_SUB_MIX, Ht.INV_SBOX, this._nRounds), r = Ms.allocUnsafe(16);
  return r.writeUInt32BE(o[0], 0), r.writeUInt32BE(o[3], 4), r.writeUInt32BE(o[2], 8), r.writeUInt32BE(o[1], 12), r;
};
Wr.prototype.scrub = function() {
  xo(this._keySchedule), xo(this._invKeySchedule), xo(this._key);
};
k0.AES = Wr;
var Ca = ct.Buffer, I4 = Ca.alloc(16, 0);
function T4(e) {
  return [
    e.readUInt32BE(0),
    e.readUInt32BE(4),
    e.readUInt32BE(8),
    e.readUInt32BE(12)
  ];
}
function Bv(e) {
  var t = Ca.allocUnsafe(16);
  return t.writeUInt32BE(e[0] >>> 0, 0), t.writeUInt32BE(e[1] >>> 0, 4), t.writeUInt32BE(e[2] >>> 0, 8), t.writeUInt32BE(e[3] >>> 0, 12), t;
}
function U0(e) {
  this.h = e, this.state = Ca.alloc(16, 0), this.cache = Ca.allocUnsafe(0);
}
U0.prototype.ghash = function(e) {
  for (var t = -1; ++t < e.length; )
    this.state[t] ^= e[t];
  this._multiply();
};
U0.prototype._multiply = function() {
  for (var e = T4(this.h), t = [0, 0, 0, 0], o, r, h, a = -1; ++a < 128; ) {
    for (r = (this.state[~~(a / 8)] & 1 << 7 - a % 8) !== 0, r && (t[0] ^= e[0], t[1] ^= e[1], t[2] ^= e[2], t[3] ^= e[3]), h = (e[3] & 1) !== 0, o = 3; o > 0; o--)
      e[o] = e[o] >>> 1 | (e[o - 1] & 1) << 31;
    e[0] = e[0] >>> 1, h && (e[0] = e[0] ^ 225 << 24);
  }
  this.state = Bv(t);
};
U0.prototype.update = function(e) {
  this.cache = Ca.concat([this.cache, e]);
  for (var t; this.cache.length >= 16; )
    t = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(t);
};
U0.prototype.final = function(e, t) {
  return this.cache.length && this.ghash(Ca.concat([this.cache, I4], 16)), this.ghash(Bv([0, e, 0, t])), this.state;
};
var M4 = U0, R4 = k0, wr = ct.Buffer, Iv = Mn, N4 = ut, Tv = M4, D4 = L0, O4 = wv;
function P4(e, t) {
  var o = 0;
  e.length !== t.length && o++;
  for (var r = Math.min(e.length, t.length), h = 0; h < r; ++h)
    o += e[h] ^ t[h];
  return o;
}
function L4(e, t, o) {
  if (t.length === 12)
    return e._finID = wr.concat([t, wr.from([0, 0, 0, 1])]), wr.concat([t, wr.from([0, 0, 0, 2])]);
  var r = new Tv(o), h = t.length, a = h % 16;
  r.update(t), a && (a = 16 - a, r.update(wr.alloc(a, 0))), r.update(wr.alloc(8, 0));
  var p = h * 8, d = wr.alloc(8);
  d.writeUIntBE(p, 0, 8), r.update(d), e._finID = r.state;
  var b = wr.from(e._finID);
  return O4(b), b;
}
function ia(e, t, o, r) {
  Iv.call(this);
  var h = wr.alloc(4, 0);
  this._cipher = new R4.AES(t);
  var a = this._cipher.encryptBlock(h);
  this._ghash = new Tv(a), o = L4(this, o, a), this._prev = wr.from(o), this._cache = wr.allocUnsafe(0), this._secCache = wr.allocUnsafe(0), this._decrypt = r, this._alen = 0, this._len = 0, this._mode = e, this._authTag = null, this._called = !1;
}
N4(ia, Iv);
ia.prototype._update = function(e) {
  if (!this._called && this._alen) {
    var t = 16 - this._alen % 16;
    t < 16 && (t = wr.alloc(t, 0), this._ghash.update(t));
  }
  this._called = !0;
  var o = this._mode.encrypt(this, e);
  return this._decrypt ? this._ghash.update(e) : this._ghash.update(o), this._len += e.length, o;
};
ia.prototype._final = function() {
  if (this._decrypt && !this._authTag)
    throw new Error("Unsupported state or unable to authenticate data");
  var e = D4(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && P4(e, this._authTag))
    throw new Error("Unsupported state or unable to authenticate data");
  this._authTag = e, this._cipher.scrub();
};
ia.prototype.getAuthTag = function() {
  if (this._decrypt || !wr.isBuffer(this._authTag))
    throw new Error("Attempting to get auth tag in unsupported state");
  return this._authTag;
};
ia.prototype.setAuthTag = function(e) {
  if (!this._decrypt)
    throw new Error("Attempting to set auth tag in unsupported state");
  this._authTag = e;
};
ia.prototype.setAAD = function(e) {
  if (this._called)
    throw new Error("Attempting to set AAD in unsupported state");
  this._ghash.update(e), this._alen += e.length;
};
var Mv = ia, k4 = k0, _o = ct.Buffer, Rv = Mn, U4 = ut;
function hf(e, t, o, r) {
  Rv.call(this), this._cipher = new k4.AES(t), this._prev = _o.from(o), this._cache = _o.allocUnsafe(0), this._secCache = _o.allocUnsafe(0), this._decrypt = r, this._mode = e;
}
U4(hf, Rv);
hf.prototype._update = function(e) {
  return this._mode.encrypt(this, e, this._decrypt);
};
hf.prototype._final = function() {
  this._cipher.scrub();
};
var Nv = hf, Pn = ct.Buffer, F4 = Gc;
function q4(e, t, o, r) {
  if (Pn.isBuffer(e) || (e = Pn.from(e, "binary")), t && (Pn.isBuffer(t) || (t = Pn.from(t, "binary")), t.length !== 8))
    throw new RangeError("salt should be Buffer with 8 byte length");
  for (var h = o / 8, a = Pn.alloc(h), p = Pn.alloc(r || 0), d = Pn.alloc(0); h > 0 || r > 0; ) {
    var b = new F4();
    b.update(d), b.update(e), t && b.update(t), d = b.digest();
    var g = 0;
    if (h > 0) {
      var w = a.length - h;
      g = Math.min(h, d.length), d.copy(a, w, 0, g), h -= g;
    }
    if (g < d.length && r > 0) {
      var C = p.length - r, T = Math.min(r, d.length - g);
      d.copy(p, C, g, g + T), r -= T;
    }
  }
  return d.fill(0), { key: a, iv: p };
}
var lf = q4, Dv = Jc, V4 = Mv, fn = ct.Buffer, K4 = Nv, Ov = Mn, $4 = k0, H4 = lf, G4 = ut;
function F0(e, t, o) {
  Ov.call(this), this._cache = new df(), this._cipher = new $4.AES(t), this._prev = fn.from(o), this._mode = e, this._autopadding = !0;
}
G4(F0, Ov);
F0.prototype._update = function(e) {
  this._cache.add(e);
  for (var t, o, r = []; t = this._cache.get(); )
    o = this._mode.encrypt(this, t), r.push(o);
  return fn.concat(r);
};
var z4 = fn.alloc(16, 16);
F0.prototype._final = function() {
  var e = this._cache.flush();
  if (this._autopadding)
    return e = this._mode.encrypt(this, e), this._cipher.scrub(), e;
  if (!e.equals(z4))
    throw this._cipher.scrub(), new Error("data not multiple of block length");
};
F0.prototype.setAutoPadding = function(e) {
  return this._autopadding = !!e, this;
};
function df() {
  this.cache = fn.allocUnsafe(0);
}
df.prototype.add = function(e) {
  this.cache = fn.concat([this.cache, e]);
};
df.prototype.get = function() {
  if (this.cache.length > 15) {
    var e = this.cache.slice(0, 16);
    return this.cache = this.cache.slice(16), e;
  }
  return null;
};
df.prototype.flush = function() {
  for (var e = 16 - this.cache.length, t = fn.allocUnsafe(e), o = -1; ++o < e; )
    t.writeUInt8(e, o);
  return fn.concat([this.cache, t]);
};
function Pv(e, t, o) {
  var r = Dv[e.toLowerCase()];
  if (!r)
    throw new TypeError("invalid suite type");
  if (typeof t == "string" && (t = fn.from(t)), t.length !== r.key / 8)
    throw new TypeError("invalid key length " + t.length);
  if (typeof o == "string" && (o = fn.from(o)), r.mode !== "GCM" && o.length !== r.iv)
    throw new TypeError("invalid iv length " + o.length);
  return r.type === "stream" ? new K4(r.module, t, o) : r.type === "auth" ? new V4(r.module, t, o) : new F0(r.module, t, o);
}
function j4(e, t) {
  var o = Dv[e.toLowerCase()];
  if (!o)
    throw new TypeError("invalid suite type");
  var r = H4(t, !1, o.key, o.iv);
  return Pv(e, r.key, r.iv);
}
Xc.createCipheriv = Pv;
Xc.createCipher = j4;
var th = {}, W4 = Mv, Aa = ct.Buffer, Lv = Jc, Y4 = Nv, kv = Mn, X4 = k0, Q4 = lf, Z4 = ut;
function q0(e, t, o) {
  kv.call(this), this._cache = new pf(), this._last = void 0, this._cipher = new X4.AES(t), this._prev = Aa.from(o), this._mode = e, this._autopadding = !0;
}
Z4(q0, kv);
q0.prototype._update = function(e) {
  this._cache.add(e);
  for (var t, o, r = []; t = this._cache.get(this._autopadding); )
    o = this._mode.decrypt(this, t), r.push(o);
  return Aa.concat(r);
};
q0.prototype._final = function() {
  var e = this._cache.flush();
  if (this._autopadding)
    return J4(this._mode.decrypt(this, e));
  if (e)
    throw new Error("data not multiple of block length");
};
q0.prototype.setAutoPadding = function(e) {
  return this._autopadding = !!e, this;
};
function pf() {
  this.cache = Aa.allocUnsafe(0);
}
pf.prototype.add = function(e) {
  this.cache = Aa.concat([this.cache, e]);
};
pf.prototype.get = function(e) {
  var t;
  if (e) {
    if (this.cache.length > 16)
      return t = this.cache.slice(0, 16), this.cache = this.cache.slice(16), t;
  } else if (this.cache.length >= 16)
    return t = this.cache.slice(0, 16), this.cache = this.cache.slice(16), t;
  return null;
};
pf.prototype.flush = function() {
  if (this.cache.length)
    return this.cache;
};
function J4(e) {
  var t = e[15];
  if (t < 1 || t > 16)
    throw new Error("unable to decrypt data");
  for (var o = -1; ++o < t; )
    if (e[o + (16 - t)] !== t)
      throw new Error("unable to decrypt data");
  if (t !== 16)
    return e.slice(0, 16 - t);
}
function Uv(e, t, o) {
  var r = Lv[e.toLowerCase()];
  if (!r)
    throw new TypeError("invalid suite type");
  if (typeof o == "string" && (o = Aa.from(o)), r.mode !== "GCM" && o.length !== r.iv)
    throw new TypeError("invalid iv length " + o.length);
  if (typeof t == "string" && (t = Aa.from(t)), t.length !== r.key / 8)
    throw new TypeError("invalid key length " + t.length);
  return r.type === "stream" ? new Y4(r.module, t, o, !0) : r.type === "auth" ? new W4(r.module, t, o, !0) : new q0(r.module, t, o);
}
function e3(e, t) {
  var o = Lv[e.toLowerCase()];
  if (!o)
    throw new TypeError("invalid suite type");
  var r = Q4(t, !1, o.key, o.iv);
  return Uv(e, r.key, r.iv);
}
th.createDecipher = e3;
th.createDecipheriv = Uv;
var Fv = Xc, qv = th, t3 = Cv;
function r3() {
  return Object.keys(t3);
}
Dr.createCipher = Dr.Cipher = Fv.createCipher;
Dr.createCipheriv = Dr.Cipheriv = Fv.createCipheriv;
Dr.createDecipher = Dr.Decipher = qv.createDecipher;
Dr.createDecipheriv = Dr.Decipheriv = qv.createDecipheriv;
Dr.listCiphers = Dr.getCiphers = r3;
var Vv = {};
(function(e) {
  e["des-ecb"] = {
    key: 8,
    iv: 0
  }, e["des-cbc"] = e.des = {
    key: 8,
    iv: 8
  }, e["des-ede3-cbc"] = e.des3 = {
    key: 24,
    iv: 8
  }, e["des-ede3"] = {
    key: 24,
    iv: 0
  }, e["des-ede-cbc"] = {
    key: 16,
    iv: 8
  }, e["des-ede"] = {
    key: 16,
    iv: 0
  };
})(Vv);
var Kv = l4, rh = Dr, En = Jc, nn = Vv, $v = lf;
function i3(e, t) {
  e = e.toLowerCase();
  var o, r;
  if (En[e])
    o = En[e].key, r = En[e].iv;
  else if (nn[e])
    o = nn[e].key * 8, r = nn[e].iv;
  else
    throw new TypeError("invalid suite type");
  var h = $v(t, !1, o, r);
  return Hv(e, h.key, h.iv);
}
function n3(e, t) {
  e = e.toLowerCase();
  var o, r;
  if (En[e])
    o = En[e].key, r = En[e].iv;
  else if (nn[e])
    o = nn[e].key * 8, r = nn[e].iv;
  else
    throw new TypeError("invalid suite type");
  var h = $v(t, !1, o, r);
  return Gv(e, h.key, h.iv);
}
function Hv(e, t, o) {
  if (e = e.toLowerCase(), En[e])
    return rh.createCipheriv(e, t, o);
  if (nn[e])
    return new Kv({ key: t, iv: o, mode: e });
  throw new TypeError("invalid suite type");
}
function Gv(e, t, o) {
  if (e = e.toLowerCase(), En[e])
    return rh.createDecipheriv(e, t, o);
  if (nn[e])
    return new Kv({ key: t, iv: o, mode: e, decrypt: !0 });
  throw new TypeError("invalid suite type");
}
function a3() {
  return Object.keys(nn).concat(rh.getCiphers());
}
Si.createCipher = Si.Cipher = i3;
Si.createCipheriv = Si.Cipheriv = Hv;
Si.createDecipher = Si.Decipher = n3;
Si.createDecipheriv = Si.Decipheriv = Gv;
Si.listCiphers = Si.getCiphers = a3;
var Ln = {}, ih = { exports: {} };
(function(e) {
  (function(t, o) {
    function r(I, P) {
      if (!I)
        throw new Error(P || "Assertion failed");
    }
    function h(I, P) {
      I.super_ = P;
      var f = function() {
      };
      f.prototype = P.prototype, I.prototype = new f(), I.prototype.constructor = I;
    }
    function a(I, P, f) {
      if (a.isBN(I))
        return I;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, I !== null && ((P === "le" || P === "be") && (f = P, P = 10), this._init(I || 0, P || 10, f || "be"));
    }
    typeof t == "object" ? t.exports = a : o.BN = a, a.BN = a, a.wordSize = 26;
    var p;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = pe.Buffer;
    } catch {
    }
    a.isBN = function(I) {
      return I instanceof a ? !0 : I !== null && typeof I == "object" && I.constructor.wordSize === a.wordSize && Array.isArray(I.words);
    }, a.max = function(I, P) {
      return I.cmp(P) > 0 ? I : P;
    }, a.min = function(I, P) {
      return I.cmp(P) < 0 ? I : P;
    }, a.prototype._init = function(I, P, f) {
      if (typeof I == "number")
        return this._initNumber(I, P, f);
      if (typeof I == "object")
        return this._initArray(I, P, f);
      P === "hex" && (P = 16), r(P === (P | 0) && P >= 2 && P <= 36), I = I.toString().replace(/\s+/g, "");
      var y = 0;
      I[0] === "-" && (y++, this.negative = 1), y < I.length && (P === 16 ? this._parseHex(I, y, f) : (this._parseBase(I, P, y), f === "le" && this._initArray(this.toArray(), P, f)));
    }, a.prototype._initNumber = function(I, P, f) {
      I < 0 && (this.negative = 1, I = -I), I < 67108864 ? (this.words = [I & 67108863], this.length = 1) : I < 4503599627370496 ? (this.words = [
        I & 67108863,
        I / 67108864 & 67108863
      ], this.length = 2) : (r(I < 9007199254740992), this.words = [
        I & 67108863,
        I / 67108864 & 67108863,
        1
      ], this.length = 3), f === "le" && this._initArray(this.toArray(), P, f);
    }, a.prototype._initArray = function(I, P, f) {
      if (r(typeof I.length == "number"), I.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(I.length / 3), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++)
        this.words[y] = 0;
      var v, M, B = 0;
      if (f === "be")
        for (y = I.length - 1, v = 0; y >= 0; y -= 3)
          M = I[y] | I[y - 1] << 8 | I[y - 2] << 16, this.words[v] |= M << B & 67108863, this.words[v + 1] = M >>> 26 - B & 67108863, B += 24, B >= 26 && (B -= 26, v++);
      else if (f === "le")
        for (y = 0, v = 0; y < I.length; y += 3)
          M = I[y] | I[y + 1] << 8 | I[y + 2] << 16, this.words[v] |= M << B & 67108863, this.words[v + 1] = M >>> 26 - B & 67108863, B += 24, B >= 26 && (B -= 26, v++);
      return this.strip();
    };
    function d(I, P) {
      var f = I.charCodeAt(P);
      return f >= 65 && f <= 70 ? f - 55 : f >= 97 && f <= 102 ? f - 87 : f - 48 & 15;
    }
    function b(I, P, f) {
      var y = d(I, f);
      return f - 1 >= P && (y |= d(I, f - 1) << 4), y;
    }
    a.prototype._parseHex = function(I, P, f) {
      this.length = Math.ceil((I.length - P) / 6), this.words = new Array(this.length);
      for (var y = 0; y < this.length; y++)
        this.words[y] = 0;
      var v = 0, M = 0, B;
      if (f === "be")
        for (y = I.length - 1; y >= P; y -= 2)
          B = b(I, P, y) << v, this.words[M] |= B & 67108863, v >= 18 ? (v -= 18, M += 1, this.words[M] |= B >>> 26) : v += 8;
      else {
        var S = I.length - P;
        for (y = S % 2 === 0 ? P + 1 : P; y < I.length; y += 2)
          B = b(I, P, y) << v, this.words[M] |= B & 67108863, v >= 18 ? (v -= 18, M += 1, this.words[M] |= B >>> 26) : v += 8;
      }
      this.strip();
    };
    function g(I, P, f, y) {
      for (var v = 0, M = Math.min(I.length, f), B = P; B < M; B++) {
        var S = I.charCodeAt(B) - 48;
        v *= y, S >= 49 ? v += S - 49 + 10 : S >= 17 ? v += S - 17 + 10 : v += S;
      }
      return v;
    }
    a.prototype._parseBase = function(I, P, f) {
      this.words = [0], this.length = 1;
      for (var y = 0, v = 1; v <= 67108863; v *= P)
        y++;
      y--, v = v / P | 0;
      for (var M = I.length - f, B = M % y, S = Math.min(M, M - B) + f, _ = 0, E = f; E < S; E += y)
        _ = g(I, E, E + y, P), this.imuln(v), this.words[0] + _ < 67108864 ? this.words[0] += _ : this._iaddn(_);
      if (B !== 0) {
        var m = 1;
        for (_ = g(I, E, I.length, P), E = 0; E < B; E++)
          m *= P;
        this.imuln(m), this.words[0] + _ < 67108864 ? this.words[0] += _ : this._iaddn(_);
      }
      this.strip();
    }, a.prototype.copy = function(I) {
      I.words = new Array(this.length);
      for (var P = 0; P < this.length; P++)
        I.words[P] = this.words[P];
      I.length = this.length, I.negative = this.negative, I.red = this.red;
    }, a.prototype.clone = function() {
      var I = new a(null);
      return this.copy(I), I;
    }, a.prototype._expand = function(I) {
      for (; this.length < I; )
        this.words[this.length++] = 0;
      return this;
    }, a.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, a.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, a.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var w = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], C = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], T = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    a.prototype.toString = function(I, P) {
      I = I || 10, P = P | 0 || 1;
      var f;
      if (I === 16 || I === "hex") {
        f = "";
        for (var y = 0, v = 0, M = 0; M < this.length; M++) {
          var B = this.words[M], S = ((B << y | v) & 16777215).toString(16);
          v = B >>> 24 - y & 16777215, v !== 0 || M !== this.length - 1 ? f = w[6 - S.length] + S + f : f = S + f, y += 2, y >= 26 && (y -= 26, M--);
        }
        for (v !== 0 && (f = v.toString(16) + f); f.length % P !== 0; )
          f = "0" + f;
        return this.negative !== 0 && (f = "-" + f), f;
      }
      if (I === (I | 0) && I >= 2 && I <= 36) {
        var _ = C[I], E = T[I];
        f = "";
        var m = this.clone();
        for (m.negative = 0; !m.isZero(); ) {
          var A = m.modn(E).toString(I);
          m = m.idivn(E), m.isZero() ? f = A + f : f = w[_ - A.length] + A + f;
        }
        for (this.isZero() && (f = "0" + f); f.length % P !== 0; )
          f = "0" + f;
        return this.negative !== 0 && (f = "-" + f), f;
      }
      r(!1, "Base should be between 2 and 36");
    }, a.prototype.toNumber = function() {
      var I = this.words[0];
      return this.length === 2 ? I += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? I += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -I : I;
    }, a.prototype.toJSON = function() {
      return this.toString(16);
    }, a.prototype.toBuffer = function(I, P) {
      return r(typeof p < "u"), this.toArrayLike(p, I, P);
    }, a.prototype.toArray = function(I, P) {
      return this.toArrayLike(Array, I, P);
    }, a.prototype.toArrayLike = function(I, P, f) {
      var y = this.byteLength(), v = f || Math.max(1, y);
      r(y <= v, "byte array longer than desired length"), r(v > 0, "Requested array length <= 0"), this.strip();
      var M = P === "le", B = new I(v), S, _, E = this.clone();
      if (M) {
        for (_ = 0; !E.isZero(); _++)
          S = E.andln(255), E.iushrn(8), B[_] = S;
        for (; _ < v; _++)
          B[_] = 0;
      } else {
        for (_ = 0; _ < v - y; _++)
          B[_] = 0;
        for (_ = 0; !E.isZero(); _++)
          S = E.andln(255), E.iushrn(8), B[v - _ - 1] = S;
      }
      return B;
    }, Math.clz32 ? a.prototype._countBits = function(I) {
      return 32 - Math.clz32(I);
    } : a.prototype._countBits = function(I) {
      var P = I, f = 0;
      return P >= 4096 && (f += 13, P >>>= 13), P >= 64 && (f += 7, P >>>= 7), P >= 8 && (f += 4, P >>>= 4), P >= 2 && (f += 2, P >>>= 2), f + P;
    }, a.prototype._zeroBits = function(I) {
      if (I === 0)
        return 26;
      var P = I, f = 0;
      return P & 8191 || (f += 13, P >>>= 13), P & 127 || (f += 7, P >>>= 7), P & 15 || (f += 4, P >>>= 4), P & 3 || (f += 2, P >>>= 2), P & 1 || f++, f;
    }, a.prototype.bitLength = function() {
      var I = this.words[this.length - 1], P = this._countBits(I);
      return (this.length - 1) * 26 + P;
    };
    function k(I) {
      for (var P = new Array(I.bitLength()), f = 0; f < P.length; f++) {
        var y = f / 26 | 0, v = f % 26;
        P[f] = (I.words[y] & 1 << v) >>> v;
      }
      return P;
    }
    a.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var I = 0, P = 0; P < this.length; P++) {
        var f = this._zeroBits(this.words[P]);
        if (I += f, f !== 26)
          break;
      }
      return I;
    }, a.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, a.prototype.toTwos = function(I) {
      return this.negative !== 0 ? this.abs().inotn(I).iaddn(1) : this.clone();
    }, a.prototype.fromTwos = function(I) {
      return this.testn(I - 1) ? this.notn(I).iaddn(1).ineg() : this.clone();
    }, a.prototype.isNeg = function() {
      return this.negative !== 0;
    }, a.prototype.neg = function() {
      return this.clone().ineg();
    }, a.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, a.prototype.iuor = function(I) {
      for (; this.length < I.length; )
        this.words[this.length++] = 0;
      for (var P = 0; P < I.length; P++)
        this.words[P] = this.words[P] | I.words[P];
      return this.strip();
    }, a.prototype.ior = function(I) {
      return r((this.negative | I.negative) === 0), this.iuor(I);
    }, a.prototype.or = function(I) {
      return this.length > I.length ? this.clone().ior(I) : I.clone().ior(this);
    }, a.prototype.uor = function(I) {
      return this.length > I.length ? this.clone().iuor(I) : I.clone().iuor(this);
    }, a.prototype.iuand = function(I) {
      var P;
      this.length > I.length ? P = I : P = this;
      for (var f = 0; f < P.length; f++)
        this.words[f] = this.words[f] & I.words[f];
      return this.length = P.length, this.strip();
    }, a.prototype.iand = function(I) {
      return r((this.negative | I.negative) === 0), this.iuand(I);
    }, a.prototype.and = function(I) {
      return this.length > I.length ? this.clone().iand(I) : I.clone().iand(this);
    }, a.prototype.uand = function(I) {
      return this.length > I.length ? this.clone().iuand(I) : I.clone().iuand(this);
    }, a.prototype.iuxor = function(I) {
      var P, f;
      this.length > I.length ? (P = this, f = I) : (P = I, f = this);
      for (var y = 0; y < f.length; y++)
        this.words[y] = P.words[y] ^ f.words[y];
      if (this !== P)
        for (; y < P.length; y++)
          this.words[y] = P.words[y];
      return this.length = P.length, this.strip();
    }, a.prototype.ixor = function(I) {
      return r((this.negative | I.negative) === 0), this.iuxor(I);
    }, a.prototype.xor = function(I) {
      return this.length > I.length ? this.clone().ixor(I) : I.clone().ixor(this);
    }, a.prototype.uxor = function(I) {
      return this.length > I.length ? this.clone().iuxor(I) : I.clone().iuxor(this);
    }, a.prototype.inotn = function(I) {
      r(typeof I == "number" && I >= 0);
      var P = Math.ceil(I / 26) | 0, f = I % 26;
      this._expand(P), f > 0 && P--;
      for (var y = 0; y < P; y++)
        this.words[y] = ~this.words[y] & 67108863;
      return f > 0 && (this.words[y] = ~this.words[y] & 67108863 >> 26 - f), this.strip();
    }, a.prototype.notn = function(I) {
      return this.clone().inotn(I);
    }, a.prototype.setn = function(I, P) {
      r(typeof I == "number" && I >= 0);
      var f = I / 26 | 0, y = I % 26;
      return this._expand(f + 1), P ? this.words[f] = this.words[f] | 1 << y : this.words[f] = this.words[f] & ~(1 << y), this.strip();
    }, a.prototype.iadd = function(I) {
      var P;
      if (this.negative !== 0 && I.negative === 0)
        return this.negative = 0, P = this.isub(I), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && I.negative !== 0)
        return I.negative = 0, P = this.isub(I), I.negative = 1, P._normSign();
      var f, y;
      this.length > I.length ? (f = this, y = I) : (f = I, y = this);
      for (var v = 0, M = 0; M < y.length; M++)
        P = (f.words[M] | 0) + (y.words[M] | 0) + v, this.words[M] = P & 67108863, v = P >>> 26;
      for (; v !== 0 && M < f.length; M++)
        P = (f.words[M] | 0) + v, this.words[M] = P & 67108863, v = P >>> 26;
      if (this.length = f.length, v !== 0)
        this.words[this.length] = v, this.length++;
      else if (f !== this)
        for (; M < f.length; M++)
          this.words[M] = f.words[M];
      return this;
    }, a.prototype.add = function(I) {
      var P;
      return I.negative !== 0 && this.negative === 0 ? (I.negative = 0, P = this.sub(I), I.negative ^= 1, P) : I.negative === 0 && this.negative !== 0 ? (this.negative = 0, P = I.sub(this), this.negative = 1, P) : this.length > I.length ? this.clone().iadd(I) : I.clone().iadd(this);
    }, a.prototype.isub = function(I) {
      if (I.negative !== 0) {
        I.negative = 0;
        var P = this.iadd(I);
        return I.negative = 1, P._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(I), this.negative = 1, this._normSign();
      var f = this.cmp(I);
      if (f === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var y, v;
      f > 0 ? (y = this, v = I) : (y = I, v = this);
      for (var M = 0, B = 0; B < v.length; B++)
        P = (y.words[B] | 0) - (v.words[B] | 0) + M, M = P >> 26, this.words[B] = P & 67108863;
      for (; M !== 0 && B < y.length; B++)
        P = (y.words[B] | 0) + M, M = P >> 26, this.words[B] = P & 67108863;
      if (M === 0 && B < y.length && y !== this)
        for (; B < y.length; B++)
          this.words[B] = y.words[B];
      return this.length = Math.max(this.length, B), y !== this && (this.negative = 1), this.strip();
    }, a.prototype.sub = function(I) {
      return this.clone().isub(I);
    };
    function q(I, P, f) {
      f.negative = P.negative ^ I.negative;
      var y = I.length + P.length | 0;
      f.length = y, y = y - 1 | 0;
      var v = I.words[0] | 0, M = P.words[0] | 0, B = v * M, S = B & 67108863, _ = B / 67108864 | 0;
      f.words[0] = S;
      for (var E = 1; E < y; E++) {
        for (var m = _ >>> 26, A = _ & 67108863, $ = Math.min(E, P.length - 1), X = Math.max(0, E - I.length + 1); X <= $; X++) {
          var oe = E - X | 0;
          v = I.words[oe] | 0, M = P.words[X] | 0, B = v * M + A, m += B / 67108864 | 0, A = B & 67108863;
        }
        f.words[E] = A | 0, _ = m | 0;
      }
      return _ !== 0 ? f.words[E] = _ | 0 : f.length--, f.strip();
    }
    var O = function(I, P, f) {
      var y = I.words, v = P.words, M = f.words, B = 0, S, _, E, m = y[0] | 0, A = m & 8191, $ = m >>> 13, X = y[1] | 0, oe = X & 8191, J = X >>> 13, W = y[2] | 0, Q = W & 8191, me = W >>> 13, be = y[3] | 0, Y = be & 8191, re = be >>> 13, de = y[4] | 0, Ae = de & 8191, qe = de >>> 13, x = y[5] | 0, L = x & 8191, D = x >>> 13, F = y[6] | 0, ue = F & 8191, ge = F >>> 13, ce = y[7] | 0, ve = ce & 8191, Re = ce >>> 13, ke = y[8] | 0, Ce = ke & 8191, Le = ke >>> 13, Oe = y[9] | 0, Pe = Oe & 8191, et = Oe >>> 13, Ye = v[0] | 0, Ne = Ye & 8191, Tt = Ye >>> 13, tt = v[1] | 0, Ue = tt & 8191, Ct = tt >>> 13, rt = v[2] | 0, Ke = rt & 8191, ii = rt >>> 13, it = v[3] | 0, $e = it & 8191, Ot = it >>> 13, vt = v[4] | 0, Fe = vt & 8191, ni = vt >>> 13, nt = v[5] | 0, ze = nt & 8191, oi = nt >>> 13, ot = v[6] | 0, Xe = ot & 8191, Dt = ot >>> 13, Ze = v[7] | 0, je = Ze & 8191, ri = Ze >>> 13, St = v[8] | 0, Qe = St & 8191, ai = St >>> 13, It = v[9] | 0, Je = It & 8191, si = It >>> 13;
      f.negative = I.negative ^ P.negative, f.length = 19, S = Math.imul(A, Ne), _ = Math.imul(A, Tt), _ = _ + Math.imul($, Ne) | 0, E = Math.imul($, Tt);
      var At = (B + S | 0) + ((_ & 8191) << 13) | 0;
      B = (E + (_ >>> 13) | 0) + (At >>> 26) | 0, At &= 67108863, S = Math.imul(oe, Ne), _ = Math.imul(oe, Tt), _ = _ + Math.imul(J, Ne) | 0, E = Math.imul(J, Tt), S = S + Math.imul(A, Ue) | 0, _ = _ + Math.imul(A, Ct) | 0, _ = _ + Math.imul($, Ue) | 0, E = E + Math.imul($, Ct) | 0;
      var Bt = (B + S | 0) + ((_ & 8191) << 13) | 0;
      B = (E + (_ >>> 13) | 0) + (Bt >>> 26) | 0, Bt &= 67108863, S = Math.imul(Q, Ne), _ = Math.imul(Q, Tt), _ = _ + Math.imul(me, Ne) | 0, E = Math.imul(me, Tt), S = S + Math.imul(oe, Ue) | 0, _ = _ + Math.imul(oe, Ct) | 0, _ = _ + Math.imul(J, Ue) | 0, E = E + Math.imul(J, Ct) | 0, S = S + Math.imul(A, Ke) | 0, _ = _ + Math.imul(A, ii) | 0, _ = _ + Math.imul($, Ke) | 0, E = E + Math.imul($, ii) | 0;
      var ui = (B + S | 0) + ((_ & 8191) << 13) | 0;
      B = (E + (_ >>> 13) | 0) + (ui >>> 26) | 0, ui &= 67108863, S = Math.imul(Y, Ne), _ = Math.imul(Y, Tt), _ = _ + Math.imul(re, Ne) | 0, E = Math.imul(re, Tt), S = S + Math.imul(Q, Ue) | 0, _ = _ + Math.imul(Q, Ct) | 0, _ = _ + Math.imul(me, Ue) | 0, E = E + Math.imul(me, Ct) | 0, S = S + Math.imul(oe, Ke) | 0, _ = _ + Math.imul(oe, ii) | 0, _ = _ + Math.imul(J, Ke) | 0, E = E + Math.imul(J, ii) | 0, S = S + Math.imul(A, $e) | 0, _ = _ + Math.imul(A, Ot) | 0, _ = _ + Math.imul($, $e) | 0, E = E + Math.imul($, Ot) | 0;
      var fi = (B + S | 0) + ((_ & 8191) << 13) | 0;
      B = (E + (_ >>> 13) | 0) + (fi >>> 26) | 0, fi &= 67108863, S = Math.imul(Ae, Ne), _ = Math.imul(Ae, Tt), _ = _ + Math.imul(qe, Ne) | 0, E = Math.imul(qe, Tt), S = S + Math.imul(Y, Ue) | 0, _ = _ + Math.imul(Y, Ct) | 0, _ = _ + Math.imul(re, Ue) | 0, E = E + Math.imul(re, Ct) | 0, S = S + Math.imul(Q, Ke) | 0, _ = _ + Math.imul(Q, ii) | 0, _ = _ + Math.imul(me, Ke) | 0, E = E + Math.imul(me, ii) | 0, S = S + Math.imul(oe, $e) | 0, _ = _ + Math.imul(oe, Ot) | 0, _ = _ + Math.imul(J, $e) | 0, E = E + Math.imul(J, Ot) | 0, S = S + Math.imul(A, Fe) | 0, _ = _ + Math.imul(A, ni) | 0, _ = _ + Math.imul($, Fe) | 0, E = E + Math.imul($, ni) | 0;
      var hi = (B + S | 0) + ((_ & 8191) << 13) | 0;
      B = (E + (_ >>> 13) | 0) + (hi >>> 26) | 0, hi &= 67108863, S = Math.imul(L, Ne), _ = Math.imul(L, Tt), _ = _ + Math.imul(D, Ne) | 0, E = Math.imul(D, Tt), S = S + Math.imul(Ae, Ue) | 0, _ = _ + Math.imul(Ae, Ct) | 0, _ = _ + Math.imul(qe, Ue) | 0, E = E + Math.imul(qe, Ct) | 0, S = S + Math.imul(Y, Ke) | 0, _ = _ + Math.imul(Y, ii) | 0, _ = _ + Math.imul(re, Ke) | 0, E = E + Math.imul(re, ii) | 0, S = S + Math.imul(Q, $e) | 0, _ = _ + Math.imul(Q, Ot) | 0, _ = _ + Math.imul(me, $e) | 0, E = E + Math.imul(me, Ot) | 0, S = S + Math.imul(oe, Fe) | 0, _ = _ + Math.imul(oe, ni) | 0, _ = _ + Math.imul(J, Fe) | 0, E = E + Math.imul(J, ni) | 0, S = S + Math.imul(A, ze) | 0, _ = _ + Math.imul(A, oi) | 0, _ = _ + Math.imul($, ze) | 0, E = E + Math.imul($, oi) | 0;
      var ci = (B + S | 0) + ((_ & 8191) << 13) | 0;
      B = (E + (_ >>> 13) | 0) + (ci >>> 26) | 0, ci &= 67108863, S = Math.imul(ue, Ne), _ = Math.imul(ue, Tt), _ = _ + Math.imul(ge, Ne) | 0, E = Math.imul(ge, Tt), S = S + Math.imul(L, Ue) | 0, _ = _ + Math.imul(L, Ct) | 0, _ = _ + Math.imul(D, Ue) | 0, E = E + Math.imul(D, Ct) | 0, S = S + Math.imul(Ae, Ke) | 0, _ = _ + Math.imul(Ae, ii) | 0, _ = _ + Math.imul(qe, Ke) | 0, E = E + Math.imul(qe, ii) | 0, S = S + Math.imul(Y, $e) | 0, _ = _ + Math.imul(Y, Ot) | 0, _ = _ + Math.imul(re, $e) | 0, E = E + Math.imul(re, Ot) | 0, S = S + Math.imul(Q, Fe) | 0, _ = _ + Math.imul(Q, ni) | 0, _ = _ + Math.imul(me, Fe) | 0, E = E + Math.imul(me, ni) | 0, S = S + Math.imul(oe, ze) | 0, _ = _ + Math.imul(oe, oi) | 0, _ = _ + Math.imul(J, ze) | 0, E = E + Math.imul(J, oi) | 0, S = S + Math.imul(A, Xe) | 0, _ = _ + Math.imul(A, Dt) | 0, _ = _ + Math.imul($, Xe) | 0, E = E + Math.imul($, Dt) | 0;
      var li = (B + S | 0) + ((_ & 8191) << 13) | 0;
      B = (E + (_ >>> 13) | 0) + (li >>> 26) | 0, li &= 67108863, S = Math.imul(ve, Ne), _ = Math.imul(ve, Tt), _ = _ + Math.imul(Re, Ne) | 0, E = Math.imul(Re, Tt), S = S + Math.imul(ue, Ue) | 0, _ = _ + Math.imul(ue, Ct) | 0, _ = _ + Math.imul(ge, Ue) | 0, E = E + Math.imul(ge, Ct) | 0, S = S + Math.imul(L, Ke) | 0, _ = _ + Math.imul(L, ii) | 0, _ = _ + Math.imul(D, Ke) | 0, E = E + Math.imul(D, ii) | 0, S = S + Math.imul(Ae, $e) | 0, _ = _ + Math.imul(Ae, Ot) | 0, _ = _ + Math.imul(qe, $e) | 0, E = E + Math.imul(qe, Ot) | 0, S = S + Math.imul(Y, Fe) | 0, _ = _ + Math.imul(Y, ni) | 0, _ = _ + Math.imul(re, Fe) | 0, E = E + Math.imul(re, ni) | 0, S = S + Math.imul(Q, ze) | 0, _ = _ + Math.imul(Q, oi) | 0, _ = _ + Math.imul(me, ze) | 0, E = E + Math.imul(me, oi) | 0, S = S + Math.imul(oe, Xe) | 0, _ = _ + Math.imul(oe, Dt) | 0, _ = _ + Math.imul(J, Xe) | 0, E = E + Math.imul(J, Dt) | 0, S = S + Math.imul(A, je) | 0, _ = _ + Math.imul(A, ri) | 0, _ = _ + Math.imul($, je) | 0, E = E + Math.imul($, ri) | 0;
      var di = (B + S | 0) + ((_ & 8191) << 13) | 0;
      B = (E + (_ >>> 13) | 0) + (di >>> 26) | 0, di &= 67108863, S = Math.imul(Ce, Ne), _ = Math.imul(Ce, Tt), _ = _ + Math.imul(Le, Ne) | 0, E = Math.imul(Le, Tt), S = S + Math.imul(ve, Ue) | 0, _ = _ + Math.imul(ve, Ct) | 0, _ = _ + Math.imul(Re, Ue) | 0, E = E + Math.imul(Re, Ct) | 0, S = S + Math.imul(ue, Ke) | 0, _ = _ + Math.imul(ue, ii) | 0, _ = _ + Math.imul(ge, Ke) | 0, E = E + Math.imul(ge, ii) | 0, S = S + Math.imul(L, $e) | 0, _ = _ + Math.imul(L, Ot) | 0, _ = _ + Math.imul(D, $e) | 0, E = E + Math.imul(D, Ot) | 0, S = S + Math.imul(Ae, Fe) | 0, _ = _ + Math.imul(Ae, ni) | 0, _ = _ + Math.imul(qe, Fe) | 0, E = E + Math.imul(qe, ni) | 0, S = S + Math.imul(Y, ze) | 0, _ = _ + Math.imul(Y, oi) | 0, _ = _ + Math.imul(re, ze) | 0, E = E + Math.imul(re, oi) | 0, S = S + Math.imul(Q, Xe) | 0, _ = _ + Math.imul(Q, Dt) | 0, _ = _ + Math.imul(me, Xe) | 0, E = E + Math.imul(me, Dt) | 0, S = S + Math.imul(oe, je) | 0, _ = _ + Math.imul(oe, ri) | 0, _ = _ + Math.imul(J, je) | 0, E = E + Math.imul(J, ri) | 0, S = S + Math.imul(A, Qe) | 0, _ = _ + Math.imul(A, ai) | 0, _ = _ + Math.imul($, Qe) | 0, E = E + Math.imul($, ai) | 0;
      var pi = (B + S | 0) + ((_ & 8191) << 13) | 0;
      B = (E + (_ >>> 13) | 0) + (pi >>> 26) | 0, pi &= 67108863, S = Math.imul(Pe, Ne), _ = Math.imul(Pe, Tt), _ = _ + Math.imul(et, Ne) | 0, E = Math.imul(et, Tt), S = S + Math.imul(Ce, Ue) | 0, _ = _ + Math.imul(Ce, Ct) | 0, _ = _ + Math.imul(Le, Ue) | 0, E = E + Math.imul(Le, Ct) | 0, S = S + Math.imul(ve, Ke) | 0, _ = _ + Math.imul(ve, ii) | 0, _ = _ + Math.imul(Re, Ke) | 0, E = E + Math.imul(Re, ii) | 0, S = S + Math.imul(ue, $e) | 0, _ = _ + Math.imul(ue, Ot) | 0, _ = _ + Math.imul(ge, $e) | 0, E = E + Math.imul(ge, Ot) | 0, S = S + Math.imul(L, Fe) | 0, _ = _ + Math.imul(L, ni) | 0, _ = _ + Math.imul(D, Fe) | 0, E = E + Math.imul(D, ni) | 0, S = S + Math.imul(Ae, ze) | 0, _ = _ + Math.imul(Ae, oi) | 0, _ = _ + Math.imul(qe, ze) | 0, E = E + Math.imul(qe, oi) | 0, S = S + Math.imul(Y, Xe) | 0, _ = _ + Math.imul(Y, Dt) | 0, _ = _ + Math.imul(re, Xe) | 0, E = E + Math.imul(re, Dt) | 0, S = S + Math.imul(Q, je) | 0, _ = _ + Math.imul(Q, ri) | 0, _ = _ + Math.imul(me, je) | 0, E = E + Math.imul(me, ri) | 0, S = S + Math.imul(oe, Qe) | 0, _ = _ + Math.imul(oe, ai) | 0, _ = _ + Math.imul(J, Qe) | 0, E = E + Math.imul(J, ai) | 0, S = S + Math.imul(A, Je) | 0, _ = _ + Math.imul(A, si) | 0, _ = _ + Math.imul($, Je) | 0, E = E + Math.imul($, si) | 0;
      var yi = (B + S | 0) + ((_ & 8191) << 13) | 0;
      B = (E + (_ >>> 13) | 0) + (yi >>> 26) | 0, yi &= 67108863, S = Math.imul(Pe, Ue), _ = Math.imul(Pe, Ct), _ = _ + Math.imul(et, Ue) | 0, E = Math.imul(et, Ct), S = S + Math.imul(Ce, Ke) | 0, _ = _ + Math.imul(Ce, ii) | 0, _ = _ + Math.imul(Le, Ke) | 0, E = E + Math.imul(Le, ii) | 0, S = S + Math.imul(ve, $e) | 0, _ = _ + Math.imul(ve, Ot) | 0, _ = _ + Math.imul(Re, $e) | 0, E = E + Math.imul(Re, Ot) | 0, S = S + Math.imul(ue, Fe) | 0, _ = _ + Math.imul(ue, ni) | 0, _ = _ + Math.imul(ge, Fe) | 0, E = E + Math.imul(ge, ni) | 0, S = S + Math.imul(L, ze) | 0, _ = _ + Math.imul(L, oi) | 0, _ = _ + Math.imul(D, ze) | 0, E = E + Math.imul(D, oi) | 0, S = S + Math.imul(Ae, Xe) | 0, _ = _ + Math.imul(Ae, Dt) | 0, _ = _ + Math.imul(qe, Xe) | 0, E = E + Math.imul(qe, Dt) | 0, S = S + Math.imul(Y, je) | 0, _ = _ + Math.imul(Y, ri) | 0, _ = _ + Math.imul(re, je) | 0, E = E + Math.imul(re, ri) | 0, S = S + Math.imul(Q, Qe) | 0, _ = _ + Math.imul(Q, ai) | 0, _ = _ + Math.imul(me, Qe) | 0, E = E + Math.imul(me, ai) | 0, S = S + Math.imul(oe, Je) | 0, _ = _ + Math.imul(oe, si) | 0, _ = _ + Math.imul(J, Je) | 0, E = E + Math.imul(J, si) | 0;
      var mi = (B + S | 0) + ((_ & 8191) << 13) | 0;
      B = (E + (_ >>> 13) | 0) + (mi >>> 26) | 0, mi &= 67108863, S = Math.imul(Pe, Ke), _ = Math.imul(Pe, ii), _ = _ + Math.imul(et, Ke) | 0, E = Math.imul(et, ii), S = S + Math.imul(Ce, $e) | 0, _ = _ + Math.imul(Ce, Ot) | 0, _ = _ + Math.imul(Le, $e) | 0, E = E + Math.imul(Le, Ot) | 0, S = S + Math.imul(ve, Fe) | 0, _ = _ + Math.imul(ve, ni) | 0, _ = _ + Math.imul(Re, Fe) | 0, E = E + Math.imul(Re, ni) | 0, S = S + Math.imul(ue, ze) | 0, _ = _ + Math.imul(ue, oi) | 0, _ = _ + Math.imul(ge, ze) | 0, E = E + Math.imul(ge, oi) | 0, S = S + Math.imul(L, Xe) | 0, _ = _ + Math.imul(L, Dt) | 0, _ = _ + Math.imul(D, Xe) | 0, E = E + Math.imul(D, Dt) | 0, S = S + Math.imul(Ae, je) | 0, _ = _ + Math.imul(Ae, ri) | 0, _ = _ + Math.imul(qe, je) | 0, E = E + Math.imul(qe, ri) | 0, S = S + Math.imul(Y, Qe) | 0, _ = _ + Math.imul(Y, ai) | 0, _ = _ + Math.imul(re, Qe) | 0, E = E + Math.imul(re, ai) | 0, S = S + Math.imul(Q, Je) | 0, _ = _ + Math.imul(Q, si) | 0, _ = _ + Math.imul(me, Je) | 0, E = E + Math.imul(me, si) | 0;
      var gi = (B + S | 0) + ((_ & 8191) << 13) | 0;
      B = (E + (_ >>> 13) | 0) + (gi >>> 26) | 0, gi &= 67108863, S = Math.imul(Pe, $e), _ = Math.imul(Pe, Ot), _ = _ + Math.imul(et, $e) | 0, E = Math.imul(et, Ot), S = S + Math.imul(Ce, Fe) | 0, _ = _ + Math.imul(Ce, ni) | 0, _ = _ + Math.imul(Le, Fe) | 0, E = E + Math.imul(Le, ni) | 0, S = S + Math.imul(ve, ze) | 0, _ = _ + Math.imul(ve, oi) | 0, _ = _ + Math.imul(Re, ze) | 0, E = E + Math.imul(Re, oi) | 0, S = S + Math.imul(ue, Xe) | 0, _ = _ + Math.imul(ue, Dt) | 0, _ = _ + Math.imul(ge, Xe) | 0, E = E + Math.imul(ge, Dt) | 0, S = S + Math.imul(L, je) | 0, _ = _ + Math.imul(L, ri) | 0, _ = _ + Math.imul(D, je) | 0, E = E + Math.imul(D, ri) | 0, S = S + Math.imul(Ae, Qe) | 0, _ = _ + Math.imul(Ae, ai) | 0, _ = _ + Math.imul(qe, Qe) | 0, E = E + Math.imul(qe, ai) | 0, S = S + Math.imul(Y, Je) | 0, _ = _ + Math.imul(Y, si) | 0, _ = _ + Math.imul(re, Je) | 0, E = E + Math.imul(re, si) | 0;
      var vi = (B + S | 0) + ((_ & 8191) << 13) | 0;
      B = (E + (_ >>> 13) | 0) + (vi >>> 26) | 0, vi &= 67108863, S = Math.imul(Pe, Fe), _ = Math.imul(Pe, ni), _ = _ + Math.imul(et, Fe) | 0, E = Math.imul(et, ni), S = S + Math.imul(Ce, ze) | 0, _ = _ + Math.imul(Ce, oi) | 0, _ = _ + Math.imul(Le, ze) | 0, E = E + Math.imul(Le, oi) | 0, S = S + Math.imul(ve, Xe) | 0, _ = _ + Math.imul(ve, Dt) | 0, _ = _ + Math.imul(Re, Xe) | 0, E = E + Math.imul(Re, Dt) | 0, S = S + Math.imul(ue, je) | 0, _ = _ + Math.imul(ue, ri) | 0, _ = _ + Math.imul(ge, je) | 0, E = E + Math.imul(ge, ri) | 0, S = S + Math.imul(L, Qe) | 0, _ = _ + Math.imul(L, ai) | 0, _ = _ + Math.imul(D, Qe) | 0, E = E + Math.imul(D, ai) | 0, S = S + Math.imul(Ae, Je) | 0, _ = _ + Math.imul(Ae, si) | 0, _ = _ + Math.imul(qe, Je) | 0, E = E + Math.imul(qe, si) | 0;
      var Nn = (B + S | 0) + ((_ & 8191) << 13) | 0;
      B = (E + (_ >>> 13) | 0) + (Nn >>> 26) | 0, Nn &= 67108863, S = Math.imul(Pe, ze), _ = Math.imul(Pe, oi), _ = _ + Math.imul(et, ze) | 0, E = Math.imul(et, oi), S = S + Math.imul(Ce, Xe) | 0, _ = _ + Math.imul(Ce, Dt) | 0, _ = _ + Math.imul(Le, Xe) | 0, E = E + Math.imul(Le, Dt) | 0, S = S + Math.imul(ve, je) | 0, _ = _ + Math.imul(ve, ri) | 0, _ = _ + Math.imul(Re, je) | 0, E = E + Math.imul(Re, ri) | 0, S = S + Math.imul(ue, Qe) | 0, _ = _ + Math.imul(ue, ai) | 0, _ = _ + Math.imul(ge, Qe) | 0, E = E + Math.imul(ge, ai) | 0, S = S + Math.imul(L, Je) | 0, _ = _ + Math.imul(L, si) | 0, _ = _ + Math.imul(D, Je) | 0, E = E + Math.imul(D, si) | 0;
      var Dn = (B + S | 0) + ((_ & 8191) << 13) | 0;
      B = (E + (_ >>> 13) | 0) + (Dn >>> 26) | 0, Dn &= 67108863, S = Math.imul(Pe, Xe), _ = Math.imul(Pe, Dt), _ = _ + Math.imul(et, Xe) | 0, E = Math.imul(et, Dt), S = S + Math.imul(Ce, je) | 0, _ = _ + Math.imul(Ce, ri) | 0, _ = _ + Math.imul(Le, je) | 0, E = E + Math.imul(Le, ri) | 0, S = S + Math.imul(ve, Qe) | 0, _ = _ + Math.imul(ve, ai) | 0, _ = _ + Math.imul(Re, Qe) | 0, E = E + Math.imul(Re, ai) | 0, S = S + Math.imul(ue, Je) | 0, _ = _ + Math.imul(ue, si) | 0, _ = _ + Math.imul(ge, Je) | 0, E = E + Math.imul(ge, si) | 0;
      var eM = (B + S | 0) + ((_ & 8191) << 13) | 0;
      B = (E + (_ >>> 13) | 0) + (eM >>> 26) | 0, eM &= 67108863, S = Math.imul(Pe, je), _ = Math.imul(Pe, ri), _ = _ + Math.imul(et, je) | 0, E = Math.imul(et, ri), S = S + Math.imul(Ce, Qe) | 0, _ = _ + Math.imul(Ce, ai) | 0, _ = _ + Math.imul(Le, Qe) | 0, E = E + Math.imul(Le, ai) | 0, S = S + Math.imul(ve, Je) | 0, _ = _ + Math.imul(ve, si) | 0, _ = _ + Math.imul(Re, Je) | 0, E = E + Math.imul(Re, si) | 0;
      var tM = (B + S | 0) + ((_ & 8191) << 13) | 0;
      B = (E + (_ >>> 13) | 0) + (tM >>> 26) | 0, tM &= 67108863, S = Math.imul(Pe, Qe), _ = Math.imul(Pe, ai), _ = _ + Math.imul(et, Qe) | 0, E = Math.imul(et, ai), S = S + Math.imul(Ce, Je) | 0, _ = _ + Math.imul(Ce, si) | 0, _ = _ + Math.imul(Le, Je) | 0, E = E + Math.imul(Le, si) | 0;
      var rM = (B + S | 0) + ((_ & 8191) << 13) | 0;
      B = (E + (_ >>> 13) | 0) + (rM >>> 26) | 0, rM &= 67108863, S = Math.imul(Pe, Je), _ = Math.imul(Pe, si), _ = _ + Math.imul(et, Je) | 0, E = Math.imul(et, si);
      var iM = (B + S | 0) + ((_ & 8191) << 13) | 0;
      return B = (E + (_ >>> 13) | 0) + (iM >>> 26) | 0, iM &= 67108863, M[0] = At, M[1] = Bt, M[2] = ui, M[3] = fi, M[4] = hi, M[5] = ci, M[6] = li, M[7] = di, M[8] = pi, M[9] = yi, M[10] = mi, M[11] = gi, M[12] = vi, M[13] = Nn, M[14] = Dn, M[15] = eM, M[16] = tM, M[17] = rM, M[18] = iM, B !== 0 && (M[19] = B, f.length++), f;
    };
    Math.imul || (O = q);
    function N(I, P, f) {
      f.negative = P.negative ^ I.negative, f.length = I.length + P.length;
      for (var y = 0, v = 0, M = 0; M < f.length - 1; M++) {
        var B = v;
        v = 0;
        for (var S = y & 67108863, _ = Math.min(M, P.length - 1), E = Math.max(0, M - I.length + 1); E <= _; E++) {
          var m = M - E, A = I.words[m] | 0, $ = P.words[E] | 0, X = A * $, oe = X & 67108863;
          B = B + (X / 67108864 | 0) | 0, oe = oe + S | 0, S = oe & 67108863, B = B + (oe >>> 26) | 0, v += B >>> 26, B &= 67108863;
        }
        f.words[M] = S, y = B, B = v;
      }
      return y !== 0 ? f.words[M] = y : f.length--, f.strip();
    }
    function j(I, P, f) {
      var y = new U();
      return y.mulp(I, P, f);
    }
    a.prototype.mulTo = function(I, P) {
      var f, y = this.length + I.length;
      return this.length === 10 && I.length === 10 ? f = O(this, I, P) : y < 63 ? f = q(this, I, P) : y < 1024 ? f = N(this, I, P) : f = j(this, I, P), f;
    };
    function U(I, P) {
      this.x = I, this.y = P;
    }
    U.prototype.makeRBT = function(I) {
      for (var P = new Array(I), f = a.prototype._countBits(I) - 1, y = 0; y < I; y++)
        P[y] = this.revBin(y, f, I);
      return P;
    }, U.prototype.revBin = function(I, P, f) {
      if (I === 0 || I === f - 1)
        return I;
      for (var y = 0, v = 0; v < P; v++)
        y |= (I & 1) << P - v - 1, I >>= 1;
      return y;
    }, U.prototype.permute = function(I, P, f, y, v, M) {
      for (var B = 0; B < M; B++)
        y[B] = P[I[B]], v[B] = f[I[B]];
    }, U.prototype.transform = function(I, P, f, y, v, M) {
      this.permute(M, I, P, f, y, v);
      for (var B = 1; B < v; B <<= 1)
        for (var S = B << 1, _ = Math.cos(2 * Math.PI / S), E = Math.sin(2 * Math.PI / S), m = 0; m < v; m += S)
          for (var A = _, $ = E, X = 0; X < B; X++) {
            var oe = f[m + X], J = y[m + X], W = f[m + X + B], Q = y[m + X + B], me = A * W - $ * Q;
            Q = A * Q + $ * W, W = me, f[m + X] = oe + W, y[m + X] = J + Q, f[m + X + B] = oe - W, y[m + X + B] = J - Q, X !== S && (me = _ * A - E * $, $ = _ * $ + E * A, A = me);
          }
    }, U.prototype.guessLen13b = function(I, P) {
      var f = Math.max(P, I) | 1, y = f & 1, v = 0;
      for (f = f / 2 | 0; f; f = f >>> 1)
        v++;
      return 1 << v + 1 + y;
    }, U.prototype.conjugate = function(I, P, f) {
      if (!(f <= 1))
        for (var y = 0; y < f / 2; y++) {
          var v = I[y];
          I[y] = I[f - y - 1], I[f - y - 1] = v, v = P[y], P[y] = -P[f - y - 1], P[f - y - 1] = -v;
        }
    }, U.prototype.normalize13b = function(I, P) {
      for (var f = 0, y = 0; y < P / 2; y++) {
        var v = Math.round(I[2 * y + 1] / P) * 8192 + Math.round(I[2 * y] / P) + f;
        I[y] = v & 67108863, v < 67108864 ? f = 0 : f = v / 67108864 | 0;
      }
      return I;
    }, U.prototype.convert13b = function(I, P, f, y) {
      for (var v = 0, M = 0; M < P; M++)
        v = v + (I[M] | 0), f[2 * M] = v & 8191, v = v >>> 13, f[2 * M + 1] = v & 8191, v = v >>> 13;
      for (M = 2 * P; M < y; ++M)
        f[M] = 0;
      r(v === 0), r((v & -8192) === 0);
    }, U.prototype.stub = function(I) {
      for (var P = new Array(I), f = 0; f < I; f++)
        P[f] = 0;
      return P;
    }, U.prototype.mulp = function(I, P, f) {
      var y = 2 * this.guessLen13b(I.length, P.length), v = this.makeRBT(y), M = this.stub(y), B = new Array(y), S = new Array(y), _ = new Array(y), E = new Array(y), m = new Array(y), A = new Array(y), $ = f.words;
      $.length = y, this.convert13b(I.words, I.length, B, y), this.convert13b(P.words, P.length, E, y), this.transform(B, M, S, _, y, v), this.transform(E, M, m, A, y, v);
      for (var X = 0; X < y; X++) {
        var oe = S[X] * m[X] - _[X] * A[X];
        _[X] = S[X] * A[X] + _[X] * m[X], S[X] = oe;
      }
      return this.conjugate(S, _, y), this.transform(S, _, $, M, y, v), this.conjugate($, M, y), this.normalize13b($, y), f.negative = I.negative ^ P.negative, f.length = I.length + P.length, f.strip();
    }, a.prototype.mul = function(I) {
      var P = new a(null);
      return P.words = new Array(this.length + I.length), this.mulTo(I, P);
    }, a.prototype.mulf = function(I) {
      var P = new a(null);
      return P.words = new Array(this.length + I.length), j(this, I, P);
    }, a.prototype.imul = function(I) {
      return this.clone().mulTo(I, this);
    }, a.prototype.imuln = function(I) {
      r(typeof I == "number"), r(I < 67108864);
      for (var P = 0, f = 0; f < this.length; f++) {
        var y = (this.words[f] | 0) * I, v = (y & 67108863) + (P & 67108863);
        P >>= 26, P += y / 67108864 | 0, P += v >>> 26, this.words[f] = v & 67108863;
      }
      return P !== 0 && (this.words[f] = P, this.length++), this;
    }, a.prototype.muln = function(I) {
      return this.clone().imuln(I);
    }, a.prototype.sqr = function() {
      return this.mul(this);
    }, a.prototype.isqr = function() {
      return this.imul(this.clone());
    }, a.prototype.pow = function(I) {
      var P = k(I);
      if (P.length === 0)
        return new a(1);
      for (var f = this, y = 0; y < P.length && P[y] === 0; y++, f = f.sqr())
        ;
      if (++y < P.length)
        for (var v = f.sqr(); y < P.length; y++, v = v.sqr())
          P[y] !== 0 && (f = f.mul(v));
      return f;
    }, a.prototype.iushln = function(I) {
      r(typeof I == "number" && I >= 0);
      var P = I % 26, f = (I - P) / 26, y = 67108863 >>> 26 - P << 26 - P, v;
      if (P !== 0) {
        var M = 0;
        for (v = 0; v < this.length; v++) {
          var B = this.words[v] & y, S = (this.words[v] | 0) - B << P;
          this.words[v] = S | M, M = B >>> 26 - P;
        }
        M && (this.words[v] = M, this.length++);
      }
      if (f !== 0) {
        for (v = this.length - 1; v >= 0; v--)
          this.words[v + f] = this.words[v];
        for (v = 0; v < f; v++)
          this.words[v] = 0;
        this.length += f;
      }
      return this.strip();
    }, a.prototype.ishln = function(I) {
      return r(this.negative === 0), this.iushln(I);
    }, a.prototype.iushrn = function(I, P, f) {
      r(typeof I == "number" && I >= 0);
      var y;
      P ? y = (P - P % 26) / 26 : y = 0;
      var v = I % 26, M = Math.min((I - v) / 26, this.length), B = 67108863 ^ 67108863 >>> v << v, S = f;
      if (y -= M, y = Math.max(0, y), S) {
        for (var _ = 0; _ < M; _++)
          S.words[_] = this.words[_];
        S.length = M;
      }
      if (M !== 0)
        if (this.length > M)
          for (this.length -= M, _ = 0; _ < this.length; _++)
            this.words[_] = this.words[_ + M];
        else
          this.words[0] = 0, this.length = 1;
      var E = 0;
      for (_ = this.length - 1; _ >= 0 && (E !== 0 || _ >= y); _--) {
        var m = this.words[_] | 0;
        this.words[_] = E << 26 - v | m >>> v, E = m & B;
      }
      return S && E !== 0 && (S.words[S.length++] = E), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, a.prototype.ishrn = function(I, P, f) {
      return r(this.negative === 0), this.iushrn(I, P, f);
    }, a.prototype.shln = function(I) {
      return this.clone().ishln(I);
    }, a.prototype.ushln = function(I) {
      return this.clone().iushln(I);
    }, a.prototype.shrn = function(I) {
      return this.clone().ishrn(I);
    }, a.prototype.ushrn = function(I) {
      return this.clone().iushrn(I);
    }, a.prototype.testn = function(I) {
      r(typeof I == "number" && I >= 0);
      var P = I % 26, f = (I - P) / 26, y = 1 << P;
      if (this.length <= f)
        return !1;
      var v = this.words[f];
      return !!(v & y);
    }, a.prototype.imaskn = function(I) {
      r(typeof I == "number" && I >= 0);
      var P = I % 26, f = (I - P) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= f)
        return this;
      if (P !== 0 && f++, this.length = Math.min(f, this.length), P !== 0) {
        var y = 67108863 ^ 67108863 >>> P << P;
        this.words[this.length - 1] &= y;
      }
      return this.strip();
    }, a.prototype.maskn = function(I) {
      return this.clone().imaskn(I);
    }, a.prototype.iaddn = function(I) {
      return r(typeof I == "number"), r(I < 67108864), I < 0 ? this.isubn(-I) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < I ? (this.words[0] = I - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(I), this.negative = 1, this) : this._iaddn(I);
    }, a.prototype._iaddn = function(I) {
      this.words[0] += I;
      for (var P = 0; P < this.length && this.words[P] >= 67108864; P++)
        this.words[P] -= 67108864, P === this.length - 1 ? this.words[P + 1] = 1 : this.words[P + 1]++;
      return this.length = Math.max(this.length, P + 1), this;
    }, a.prototype.isubn = function(I) {
      if (r(typeof I == "number"), r(I < 67108864), I < 0)
        return this.iaddn(-I);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(I), this.negative = 1, this;
      if (this.words[0] -= I, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var P = 0; P < this.length && this.words[P] < 0; P++)
          this.words[P] += 67108864, this.words[P + 1] -= 1;
      return this.strip();
    }, a.prototype.addn = function(I) {
      return this.clone().iaddn(I);
    }, a.prototype.subn = function(I) {
      return this.clone().isubn(I);
    }, a.prototype.iabs = function() {
      return this.negative = 0, this;
    }, a.prototype.abs = function() {
      return this.clone().iabs();
    }, a.prototype._ishlnsubmul = function(I, P, f) {
      var y = I.length + f, v;
      this._expand(y);
      var M, B = 0;
      for (v = 0; v < I.length; v++) {
        M = (this.words[v + f] | 0) + B;
        var S = (I.words[v] | 0) * P;
        M -= S & 67108863, B = (M >> 26) - (S / 67108864 | 0), this.words[v + f] = M & 67108863;
      }
      for (; v < this.length - f; v++)
        M = (this.words[v + f] | 0) + B, B = M >> 26, this.words[v + f] = M & 67108863;
      if (B === 0)
        return this.strip();
      for (r(B === -1), B = 0, v = 0; v < this.length; v++)
        M = -(this.words[v] | 0) + B, B = M >> 26, this.words[v] = M & 67108863;
      return this.negative = 1, this.strip();
    }, a.prototype._wordDiv = function(I, P) {
      var f = this.length - I.length, y = this.clone(), v = I, M = v.words[v.length - 1] | 0, B = this._countBits(M);
      f = 26 - B, f !== 0 && (v = v.ushln(f), y.iushln(f), M = v.words[v.length - 1] | 0);
      var S = y.length - v.length, _;
      if (P !== "mod") {
        _ = new a(null), _.length = S + 1, _.words = new Array(_.length);
        for (var E = 0; E < _.length; E++)
          _.words[E] = 0;
      }
      var m = y.clone()._ishlnsubmul(v, 1, S);
      m.negative === 0 && (y = m, _ && (_.words[S] = 1));
      for (var A = S - 1; A >= 0; A--) {
        var $ = (y.words[v.length + A] | 0) * 67108864 + (y.words[v.length + A - 1] | 0);
        for ($ = Math.min($ / M | 0, 67108863), y._ishlnsubmul(v, $, A); y.negative !== 0; )
          $--, y.negative = 0, y._ishlnsubmul(v, 1, A), y.isZero() || (y.negative ^= 1);
        _ && (_.words[A] = $);
      }
      return _ && _.strip(), y.strip(), P !== "div" && f !== 0 && y.iushrn(f), {
        div: _ || null,
        mod: y
      };
    }, a.prototype.divmod = function(I, P, f) {
      if (r(!I.isZero()), this.isZero())
        return {
          div: new a(0),
          mod: new a(0)
        };
      var y, v, M;
      return this.negative !== 0 && I.negative === 0 ? (M = this.neg().divmod(I, P), P !== "mod" && (y = M.div.neg()), P !== "div" && (v = M.mod.neg(), f && v.negative !== 0 && v.iadd(I)), {
        div: y,
        mod: v
      }) : this.negative === 0 && I.negative !== 0 ? (M = this.divmod(I.neg(), P), P !== "mod" && (y = M.div.neg()), {
        div: y,
        mod: M.mod
      }) : this.negative & I.negative ? (M = this.neg().divmod(I.neg(), P), P !== "div" && (v = M.mod.neg(), f && v.negative !== 0 && v.isub(I)), {
        div: M.div,
        mod: v
      }) : I.length > this.length || this.cmp(I) < 0 ? {
        div: new a(0),
        mod: this
      } : I.length === 1 ? P === "div" ? {
        div: this.divn(I.words[0]),
        mod: null
      } : P === "mod" ? {
        div: null,
        mod: new a(this.modn(I.words[0]))
      } : {
        div: this.divn(I.words[0]),
        mod: new a(this.modn(I.words[0]))
      } : this._wordDiv(I, P);
    }, a.prototype.div = function(I) {
      return this.divmod(I, "div", !1).div;
    }, a.prototype.mod = function(I) {
      return this.divmod(I, "mod", !1).mod;
    }, a.prototype.umod = function(I) {
      return this.divmod(I, "mod", !0).mod;
    }, a.prototype.divRound = function(I) {
      var P = this.divmod(I);
      if (P.mod.isZero())
        return P.div;
      var f = P.div.negative !== 0 ? P.mod.isub(I) : P.mod, y = I.ushrn(1), v = I.andln(1), M = f.cmp(y);
      return M < 0 || v === 1 && M === 0 ? P.div : P.div.negative !== 0 ? P.div.isubn(1) : P.div.iaddn(1);
    }, a.prototype.modn = function(I) {
      r(I <= 67108863);
      for (var P = (1 << 26) % I, f = 0, y = this.length - 1; y >= 0; y--)
        f = (P * f + (this.words[y] | 0)) % I;
      return f;
    }, a.prototype.idivn = function(I) {
      r(I <= 67108863);
      for (var P = 0, f = this.length - 1; f >= 0; f--) {
        var y = (this.words[f] | 0) + P * 67108864;
        this.words[f] = y / I | 0, P = y % I;
      }
      return this.strip();
    }, a.prototype.divn = function(I) {
      return this.clone().idivn(I);
    }, a.prototype.egcd = function(I) {
      r(I.negative === 0), r(!I.isZero());
      var P = this, f = I.clone();
      P.negative !== 0 ? P = P.umod(I) : P = P.clone();
      for (var y = new a(1), v = new a(0), M = new a(0), B = new a(1), S = 0; P.isEven() && f.isEven(); )
        P.iushrn(1), f.iushrn(1), ++S;
      for (var _ = f.clone(), E = P.clone(); !P.isZero(); ) {
        for (var m = 0, A = 1; !(P.words[0] & A) && m < 26; ++m, A <<= 1)
          ;
        if (m > 0)
          for (P.iushrn(m); m-- > 0; )
            (y.isOdd() || v.isOdd()) && (y.iadd(_), v.isub(E)), y.iushrn(1), v.iushrn(1);
        for (var $ = 0, X = 1; !(f.words[0] & X) && $ < 26; ++$, X <<= 1)
          ;
        if ($ > 0)
          for (f.iushrn($); $-- > 0; )
            (M.isOdd() || B.isOdd()) && (M.iadd(_), B.isub(E)), M.iushrn(1), B.iushrn(1);
        P.cmp(f) >= 0 ? (P.isub(f), y.isub(M), v.isub(B)) : (f.isub(P), M.isub(y), B.isub(v));
      }
      return {
        a: M,
        b: B,
        gcd: f.iushln(S)
      };
    }, a.prototype._invmp = function(I) {
      r(I.negative === 0), r(!I.isZero());
      var P = this, f = I.clone();
      P.negative !== 0 ? P = P.umod(I) : P = P.clone();
      for (var y = new a(1), v = new a(0), M = f.clone(); P.cmpn(1) > 0 && f.cmpn(1) > 0; ) {
        for (var B = 0, S = 1; !(P.words[0] & S) && B < 26; ++B, S <<= 1)
          ;
        if (B > 0)
          for (P.iushrn(B); B-- > 0; )
            y.isOdd() && y.iadd(M), y.iushrn(1);
        for (var _ = 0, E = 1; !(f.words[0] & E) && _ < 26; ++_, E <<= 1)
          ;
        if (_ > 0)
          for (f.iushrn(_); _-- > 0; )
            v.isOdd() && v.iadd(M), v.iushrn(1);
        P.cmp(f) >= 0 ? (P.isub(f), y.isub(v)) : (f.isub(P), v.isub(y));
      }
      var m;
      return P.cmpn(1) === 0 ? m = y : m = v, m.cmpn(0) < 0 && m.iadd(I), m;
    }, a.prototype.gcd = function(I) {
      if (this.isZero())
        return I.abs();
      if (I.isZero())
        return this.abs();
      var P = this.clone(), f = I.clone();
      P.negative = 0, f.negative = 0;
      for (var y = 0; P.isEven() && f.isEven(); y++)
        P.iushrn(1), f.iushrn(1);
      do {
        for (; P.isEven(); )
          P.iushrn(1);
        for (; f.isEven(); )
          f.iushrn(1);
        var v = P.cmp(f);
        if (v < 0) {
          var M = P;
          P = f, f = M;
        } else if (v === 0 || f.cmpn(1) === 0)
          break;
        P.isub(f);
      } while (!0);
      return f.iushln(y);
    }, a.prototype.invm = function(I) {
      return this.egcd(I).a.umod(I);
    }, a.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, a.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, a.prototype.andln = function(I) {
      return this.words[0] & I;
    }, a.prototype.bincn = function(I) {
      r(typeof I == "number");
      var P = I % 26, f = (I - P) / 26, y = 1 << P;
      if (this.length <= f)
        return this._expand(f + 1), this.words[f] |= y, this;
      for (var v = y, M = f; v !== 0 && M < this.length; M++) {
        var B = this.words[M] | 0;
        B += v, v = B >>> 26, B &= 67108863, this.words[M] = B;
      }
      return v !== 0 && (this.words[M] = v, this.length++), this;
    }, a.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, a.prototype.cmpn = function(I) {
      var P = I < 0;
      if (this.negative !== 0 && !P)
        return -1;
      if (this.negative === 0 && P)
        return 1;
      this.strip();
      var f;
      if (this.length > 1)
        f = 1;
      else {
        P && (I = -I), r(I <= 67108863, "Number is too big");
        var y = this.words[0] | 0;
        f = y === I ? 0 : y < I ? -1 : 1;
      }
      return this.negative !== 0 ? -f | 0 : f;
    }, a.prototype.cmp = function(I) {
      if (this.negative !== 0 && I.negative === 0)
        return -1;
      if (this.negative === 0 && I.negative !== 0)
        return 1;
      var P = this.ucmp(I);
      return this.negative !== 0 ? -P | 0 : P;
    }, a.prototype.ucmp = function(I) {
      if (this.length > I.length)
        return 1;
      if (this.length < I.length)
        return -1;
      for (var P = 0, f = this.length - 1; f >= 0; f--) {
        var y = this.words[f] | 0, v = I.words[f] | 0;
        if (y !== v) {
          y < v ? P = -1 : y > v && (P = 1);
          break;
        }
      }
      return P;
    }, a.prototype.gtn = function(I) {
      return this.cmpn(I) === 1;
    }, a.prototype.gt = function(I) {
      return this.cmp(I) === 1;
    }, a.prototype.gten = function(I) {
      return this.cmpn(I) >= 0;
    }, a.prototype.gte = function(I) {
      return this.cmp(I) >= 0;
    }, a.prototype.ltn = function(I) {
      return this.cmpn(I) === -1;
    }, a.prototype.lt = function(I) {
      return this.cmp(I) === -1;
    }, a.prototype.lten = function(I) {
      return this.cmpn(I) <= 0;
    }, a.prototype.lte = function(I) {
      return this.cmp(I) <= 0;
    }, a.prototype.eqn = function(I) {
      return this.cmpn(I) === 0;
    }, a.prototype.eq = function(I) {
      return this.cmp(I) === 0;
    }, a.red = function(I) {
      return new ie(I);
    }, a.prototype.toRed = function(I) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), I.convertTo(this)._forceRed(I);
    }, a.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, a.prototype._forceRed = function(I) {
      return this.red = I, this;
    }, a.prototype.forceRed = function(I) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(I);
    }, a.prototype.redAdd = function(I) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, I);
    }, a.prototype.redIAdd = function(I) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, I);
    }, a.prototype.redSub = function(I) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, I);
    }, a.prototype.redISub = function(I) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, I);
    }, a.prototype.redShl = function(I) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, I);
    }, a.prototype.redMul = function(I) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, I), this.red.mul(this, I);
    }, a.prototype.redIMul = function(I) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, I), this.red.imul(this, I);
    }, a.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, a.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, a.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, a.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, a.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, a.prototype.redPow = function(I) {
      return r(this.red && !I.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, I);
    };
    var H = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function z(I, P) {
      this.name = I, this.p = new a(P, 16), this.n = this.p.bitLength(), this.k = new a(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    z.prototype._tmp = function() {
      var I = new a(null);
      return I.words = new Array(Math.ceil(this.n / 13)), I;
    }, z.prototype.ireduce = function(I) {
      var P = I, f;
      do
        this.split(P, this.tmp), P = this.imulK(P), P = P.iadd(this.tmp), f = P.bitLength();
      while (f > this.n);
      var y = f < this.n ? -1 : P.ucmp(this.p);
      return y === 0 ? (P.words[0] = 0, P.length = 1) : y > 0 ? P.isub(this.p) : P.strip !== void 0 ? P.strip() : P._strip(), P;
    }, z.prototype.split = function(I, P) {
      I.iushrn(this.n, 0, P);
    }, z.prototype.imulK = function(I) {
      return I.imul(this.k);
    };
    function ee() {
      z.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    h(ee, z), ee.prototype.split = function(I, P) {
      for (var f = 4194303, y = Math.min(I.length, 9), v = 0; v < y; v++)
        P.words[v] = I.words[v];
      if (P.length = y, I.length <= 9) {
        I.words[0] = 0, I.length = 1;
        return;
      }
      var M = I.words[9];
      for (P.words[P.length++] = M & f, v = 10; v < I.length; v++) {
        var B = I.words[v] | 0;
        I.words[v - 10] = (B & f) << 4 | M >>> 22, M = B;
      }
      M >>>= 22, I.words[v - 10] = M, M === 0 && I.length > 10 ? I.length -= 10 : I.length -= 9;
    }, ee.prototype.imulK = function(I) {
      I.words[I.length] = 0, I.words[I.length + 1] = 0, I.length += 2;
      for (var P = 0, f = 0; f < I.length; f++) {
        var y = I.words[f] | 0;
        P += y * 977, I.words[f] = P & 67108863, P = y * 64 + (P / 67108864 | 0);
      }
      return I.words[I.length - 1] === 0 && (I.length--, I.words[I.length - 1] === 0 && I.length--), I;
    };
    function ne() {
      z.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    h(ne, z);
    function le() {
      z.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    h(le, z);
    function Z() {
      z.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    h(Z, z), Z.prototype.imulK = function(I) {
      for (var P = 0, f = 0; f < I.length; f++) {
        var y = (I.words[f] | 0) * 19 + P, v = y & 67108863;
        y >>>= 26, I.words[f] = v, P = y;
      }
      return P !== 0 && (I.words[I.length++] = P), I;
    }, a._prime = function(I) {
      if (H[I])
        return H[I];
      var P;
      if (I === "k256")
        P = new ee();
      else if (I === "p224")
        P = new ne();
      else if (I === "p192")
        P = new le();
      else if (I === "p25519")
        P = new Z();
      else
        throw new Error("Unknown prime " + I);
      return H[I] = P, P;
    };
    function ie(I) {
      if (typeof I == "string") {
        var P = a._prime(I);
        this.m = P.p, this.prime = P;
      } else
        r(I.gtn(1), "modulus must be greater than 1"), this.m = I, this.prime = null;
    }
    ie.prototype._verify1 = function(I) {
      r(I.negative === 0, "red works only with positives"), r(I.red, "red works only with red numbers");
    }, ie.prototype._verify2 = function(I, P) {
      r((I.negative | P.negative) === 0, "red works only with positives"), r(
        I.red && I.red === P.red,
        "red works only with red numbers"
      );
    }, ie.prototype.imod = function(I) {
      return this.prime ? this.prime.ireduce(I)._forceRed(this) : I.umod(this.m)._forceRed(this);
    }, ie.prototype.neg = function(I) {
      return I.isZero() ? I.clone() : this.m.sub(I)._forceRed(this);
    }, ie.prototype.add = function(I, P) {
      this._verify2(I, P);
      var f = I.add(P);
      return f.cmp(this.m) >= 0 && f.isub(this.m), f._forceRed(this);
    }, ie.prototype.iadd = function(I, P) {
      this._verify2(I, P);
      var f = I.iadd(P);
      return f.cmp(this.m) >= 0 && f.isub(this.m), f;
    }, ie.prototype.sub = function(I, P) {
      this._verify2(I, P);
      var f = I.sub(P);
      return f.cmpn(0) < 0 && f.iadd(this.m), f._forceRed(this);
    }, ie.prototype.isub = function(I, P) {
      this._verify2(I, P);
      var f = I.isub(P);
      return f.cmpn(0) < 0 && f.iadd(this.m), f;
    }, ie.prototype.shl = function(I, P) {
      return this._verify1(I), this.imod(I.ushln(P));
    }, ie.prototype.imul = function(I, P) {
      return this._verify2(I, P), this.imod(I.imul(P));
    }, ie.prototype.mul = function(I, P) {
      return this._verify2(I, P), this.imod(I.mul(P));
    }, ie.prototype.isqr = function(I) {
      return this.imul(I, I.clone());
    }, ie.prototype.sqr = function(I) {
      return this.mul(I, I);
    }, ie.prototype.sqrt = function(I) {
      if (I.isZero())
        return I.clone();
      var P = this.m.andln(3);
      if (r(P % 2 === 1), P === 3) {
        var f = this.m.add(new a(1)).iushrn(2);
        return this.pow(I, f);
      }
      for (var y = this.m.subn(1), v = 0; !y.isZero() && y.andln(1) === 0; )
        v++, y.iushrn(1);
      r(!y.isZero());
      var M = new a(1).toRed(this), B = M.redNeg(), S = this.m.subn(1).iushrn(1), _ = this.m.bitLength();
      for (_ = new a(2 * _ * _).toRed(this); this.pow(_, S).cmp(B) !== 0; )
        _.redIAdd(B);
      for (var E = this.pow(_, y), m = this.pow(I, y.addn(1).iushrn(1)), A = this.pow(I, y), $ = v; A.cmp(M) !== 0; ) {
        for (var X = A, oe = 0; X.cmp(M) !== 0; oe++)
          X = X.redSqr();
        r(oe < $);
        var J = this.pow(E, new a(1).iushln($ - oe - 1));
        m = m.redMul(J), E = J.redSqr(), A = A.redMul(E), $ = oe;
      }
      return m;
    }, ie.prototype.invm = function(I) {
      var P = I._invmp(this.m);
      return P.negative !== 0 ? (P.negative = 0, this.imod(P).redNeg()) : this.imod(P);
    }, ie.prototype.pow = function(I, P) {
      if (P.isZero())
        return new a(1).toRed(this);
      if (P.cmpn(1) === 0)
        return I.clone();
      var f = 4, y = new Array(1 << f);
      y[0] = new a(1).toRed(this), y[1] = I;
      for (var v = 2; v < y.length; v++)
        y[v] = this.mul(y[v - 1], I);
      var M = y[0], B = 0, S = 0, _ = P.bitLength() % 26;
      for (_ === 0 && (_ = 26), v = P.length - 1; v >= 0; v--) {
        for (var E = P.words[v], m = _ - 1; m >= 0; m--) {
          var A = E >> m & 1;
          if (M !== y[0] && (M = this.sqr(M)), A === 0 && B === 0) {
            S = 0;
            continue;
          }
          B <<= 1, B |= A, S++, !(S !== f && (v !== 0 || m !== 0)) && (M = this.mul(M, y[B]), S = 0, B = 0);
        }
        _ = 26;
      }
      return M;
    }, ie.prototype.convertTo = function(I) {
      var P = I.umod(this.m);
      return P === I ? P.clone() : P;
    }, ie.prototype.convertFrom = function(I) {
      var P = I.clone();
      return P.red = null, P;
    }, a.mont = function(I) {
      return new fe(I);
    };
    function fe(I) {
      ie.call(this, I), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new a(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    h(fe, ie), fe.prototype.convertTo = function(I) {
      return this.imod(I.ushln(this.shift));
    }, fe.prototype.convertFrom = function(I) {
      var P = this.imod(I.mul(this.rinv));
      return P.red = null, P;
    }, fe.prototype.imul = function(I, P) {
      if (I.isZero() || P.isZero())
        return I.words[0] = 0, I.length = 1, I;
      var f = I.imul(P), y = f.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), v = f.isub(y).iushrn(this.shift), M = v;
      return v.cmp(this.m) >= 0 ? M = v.isub(this.m) : v.cmpn(0) < 0 && (M = v.iadd(this.m)), M._forceRed(this);
    }, fe.prototype.mul = function(I, P) {
      if (I.isZero() || P.isZero())
        return new a(0)._forceRed(this);
      var f = I.mul(P), y = f.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), v = f.isub(y).iushrn(this.shift), M = v;
      return v.cmp(this.m) >= 0 ? M = v.isub(this.m) : v.cmpn(0) < 0 && (M = v.iadd(this.m)), M._forceRed(this);
    }, fe.prototype.invm = function(I) {
      var P = this.imod(I._invmp(this.m).mul(this.r2));
      return P._forceRed(this);
    };
  })(e, Me);
})(ih);
var rr = ih.exports, Z0 = { exports: {} }, Kl;
function nh() {
  if (Kl)
    return Z0.exports;
  Kl = 1;
  var e;
  Z0.exports = function(r) {
    return e || (e = new t(null)), e.generate(r);
  };
  function t(r) {
    this.rand = r;
  }
  if (Z0.exports.Rand = t, t.prototype.generate = function(r) {
    return this._rand(r);
  }, t.prototype._rand = function(r) {
    if (this.rand.getBytes)
      return this.rand.getBytes(r);
    for (var h = new Uint8Array(r), a = 0; a < h.length; a++)
      h[a] = this.rand.getByte();
    return h;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? t.prototype._rand = function(r) {
      var h = new Uint8Array(r);
      return self.crypto.getRandomValues(h), h;
    } : self.msCrypto && self.msCrypto.getRandomValues ? t.prototype._rand = function(r) {
      var h = new Uint8Array(r);
      return self.msCrypto.getRandomValues(h), h;
    } : typeof window == "object" && (t.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var o = _r();
      if (typeof o.randomBytes != "function")
        throw new Error("Not supported");
      t.prototype._rand = function(r) {
        return o.randomBytes(r);
      };
    } catch {
    }
  return Z0.exports;
}
var Eo, $l;
function zv() {
  if ($l)
    return Eo;
  $l = 1;
  var e = rr, t = nh();
  function o(r) {
    this.rand = r || new t.Rand();
  }
  return Eo = o, o.create = function(r) {
    return new o(r);
  }, o.prototype._randbelow = function(r) {
    var h = r.bitLength(), a = Math.ceil(h / 8);
    do
      var p = new e(this.rand.generate(a));
    while (p.cmp(r) >= 0);
    return p;
  }, o.prototype._randrange = function(r, h) {
    var a = h.sub(r);
    return r.add(this._randbelow(a));
  }, o.prototype.test = function(r, h, a) {
    var p = r.bitLength(), d = e.mont(r), b = new e(1).toRed(d);
    h || (h = Math.max(1, p / 48 | 0));
    for (var g = r.subn(1), w = 0; !g.testn(w); w++)
      ;
    for (var C = r.shrn(w), T = g.toRed(d), k = !0; h > 0; h--) {
      var q = this._randrange(new e(2), g);
      a && a(q);
      var O = q.toRed(d).redPow(C);
      if (!(O.cmp(b) === 0 || O.cmp(T) === 0)) {
        for (var N = 1; N < w; N++) {
          if (O = O.redSqr(), O.cmp(b) === 0)
            return !1;
          if (O.cmp(T) === 0)
            break;
        }
        if (N === w)
          return !1;
      }
    }
    return k;
  }, o.prototype.getDivisor = function(r, h) {
    var a = r.bitLength(), p = e.mont(r), d = new e(1).toRed(p);
    h || (h = Math.max(1, a / 48 | 0));
    for (var b = r.subn(1), g = 0; !b.testn(g); g++)
      ;
    for (var w = r.shrn(g), C = b.toRed(p); h > 0; h--) {
      var T = this._randrange(new e(2), b), k = r.gcd(T);
      if (k.cmpn(1) !== 0)
        return k;
      var q = T.toRed(p).redPow(w);
      if (!(q.cmp(d) === 0 || q.cmp(C) === 0)) {
        for (var O = 1; O < g; O++) {
          if (q = q.redSqr(), q.cmp(d) === 0)
            return q.fromRed().subn(1).gcd(r);
          if (q.cmp(C) === 0)
            break;
        }
        if (O === g)
          return q = q.redSqr(), q.fromRed().subn(1).gcd(r);
      }
    }
    return !1;
  }, Eo;
}
var So, Hl;
function jv() {
  if (Hl)
    return So;
  Hl = 1;
  var e = Ua;
  So = N, N.simpleSieve = q, N.fermatTest = O;
  var t = rr, o = new t(24), r = zv(), h = new r(), a = new t(1), p = new t(2), d = new t(5);
  new t(16), new t(8);
  var b = new t(10), g = new t(3);
  new t(7);
  var w = new t(11), C = new t(4);
  new t(12);
  var T = null;
  function k() {
    if (T !== null)
      return T;
    var j = 1048576, U = [];
    U[0] = 2;
    for (var H = 1, z = 3; z < j; z += 2) {
      for (var ee = Math.ceil(Math.sqrt(z)), ne = 0; ne < H && U[ne] <= ee && z % U[ne] !== 0; ne++)
        ;
      H !== ne && U[ne] <= ee || (U[H++] = z);
    }
    return T = U, U;
  }
  function q(j) {
    for (var U = k(), H = 0; H < U.length; H++)
      if (j.modn(U[H]) === 0)
        return j.cmpn(U[H]) === 0;
    return !0;
  }
  function O(j) {
    var U = t.mont(j);
    return p.toRed(U).redPow(j.subn(1)).fromRed().cmpn(1) === 0;
  }
  function N(j, U) {
    if (j < 16)
      return U === 2 || U === 5 ? new t([140, 123]) : new t([140, 39]);
    U = new t(U);
    for (var H, z; ; ) {
      for (H = new t(e(Math.ceil(j / 8))); H.bitLength() > j; )
        H.ishrn(1);
      if (H.isEven() && H.iadd(a), H.testn(1) || H.iadd(p), U.cmp(p)) {
        if (!U.cmp(d))
          for (; H.mod(b).cmp(g); )
            H.iadd(C);
      } else
        for (; H.mod(o).cmp(w); )
          H.iadd(C);
      if (z = H.shrn(1), q(z) && q(H) && O(z) && O(H) && h.test(z) && h.test(H))
        return H;
    }
  }
  return So;
}
const s3 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, f3 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, o3 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, u3 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, c3 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, h3 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, l3 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, d3 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, p3 = {
  modp1: s3,
  modp2: f3,
  modp5: o3,
  modp14: u3,
  modp15: c3,
  modp16: h3,
  modp17: l3,
  modp18: d3
};
var wo, Gl;
function v3() {
  if (Gl)
    return wo;
  Gl = 1;
  var e = rr, t = zv(), o = new t(), r = new e(24), h = new e(11), a = new e(10), p = new e(3), d = new e(7), b = jv(), g = Ua;
  wo = q;
  function w(N, j) {
    return j = j || "utf8", pe.Buffer.isBuffer(N) || (N = new pe.Buffer(N, j)), this._pub = new e(N), this;
  }
  function C(N, j) {
    return j = j || "utf8", pe.Buffer.isBuffer(N) || (N = new pe.Buffer(N, j)), this._priv = new e(N), this;
  }
  var T = {};
  function k(N, j) {
    var U = j.toString("hex"), H = [U, N.toString(16)].join("_");
    if (H in T)
      return T[H];
    var z = 0;
    if (N.isEven() || !b.simpleSieve || !b.fermatTest(N) || !o.test(N))
      return z += 1, U === "02" || U === "05" ? z += 8 : z += 4, T[H] = z, z;
    o.test(N.shrn(1)) || (z += 2);
    var ee;
    switch (U) {
      case "02":
        N.mod(r).cmp(h) && (z += 8);
        break;
      case "05":
        ee = N.mod(a), ee.cmp(p) && ee.cmp(d) && (z += 8);
        break;
      default:
        z += 4;
    }
    return T[H] = z, z;
  }
  function q(N, j, U) {
    this.setGenerator(j), this.__prime = new e(N), this._prime = e.mont(this.__prime), this._primeLen = N.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, U ? (this.setPublicKey = w, this.setPrivateKey = C) : this._primeCode = 8;
  }
  Object.defineProperty(q.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = k(this.__prime, this.__gen)), this._primeCode;
    }
  }), q.prototype.generateKeys = function() {
    return this._priv || (this._priv = new e(g(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, q.prototype.computeSecret = function(N) {
    N = new e(N), N = N.toRed(this._prime);
    var j = N.redPow(this._priv).fromRed(), U = new pe.Buffer(j.toArray()), H = this.getPrime();
    if (U.length < H.length) {
      var z = new pe.Buffer(H.length - U.length);
      z.fill(0), U = pe.Buffer.concat([z, U]);
    }
    return U;
  }, q.prototype.getPublicKey = function(N) {
    return O(this._pub, N);
  }, q.prototype.getPrivateKey = function(N) {
    return O(this._priv, N);
  }, q.prototype.getPrime = function(N) {
    return O(this.__prime, N);
  }, q.prototype.getGenerator = function(N) {
    return O(this._gen, N);
  }, q.prototype.setGenerator = function(N, j) {
    return j = j || "utf8", pe.Buffer.isBuffer(N) || (N = new pe.Buffer(N, j)), this.__gen = N, this._gen = new e(N), this;
  };
  function O(N, j) {
    var U = new pe.Buffer(N.toArray());
    return j ? U.toString(j) : U;
  }
  return wo;
}
var zl;
function y3() {
  if (zl)
    return Ln;
  zl = 1;
  var e = jv(), t = p3, o = v3();
  function r(p) {
    var d = new pe.Buffer(t[p].prime, "hex"), b = new pe.Buffer(t[p].gen, "hex");
    return new o(d, b);
  }
  var h = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function a(p, d, b, g) {
    return pe.Buffer.isBuffer(d) || h[d] === void 0 ? a(p, "binary", d, b) : (d = d || "binary", g = g || "binary", b = b || new pe.Buffer([2]), pe.Buffer.isBuffer(b) || (b = new pe.Buffer(b, g)), typeof p == "number" ? new o(e(p, b), b, !0) : (pe.Buffer.isBuffer(p) || (p = new pe.Buffer(p, d)), new o(p, b, !0)));
  }
  return Ln.DiffieHellmanGroup = Ln.createDiffieHellmanGroup = Ln.getDiffieHellman = r, Ln.createDiffieHellman = Ln.DiffieHellman = a, Ln;
}
var u0 = { exports: {} }, ah = { exports: {} };
(function(e) {
  (function(t, o) {
    function r(f, y) {
      if (!f)
        throw new Error(y || "Assertion failed");
    }
    function h(f, y) {
      f.super_ = y;
      var v = function() {
      };
      v.prototype = y.prototype, f.prototype = new v(), f.prototype.constructor = f;
    }
    function a(f, y, v) {
      if (a.isBN(f))
        return f;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, f !== null && ((y === "le" || y === "be") && (v = y, y = 10), this._init(f || 0, y || 10, v || "be"));
    }
    typeof t == "object" ? t.exports = a : o.BN = a, a.BN = a, a.wordSize = 26;
    var p;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = pe.Buffer;
    } catch {
    }
    a.isBN = function(f) {
      return f instanceof a ? !0 : f !== null && typeof f == "object" && f.constructor.wordSize === a.wordSize && Array.isArray(f.words);
    }, a.max = function(f, y) {
      return f.cmp(y) > 0 ? f : y;
    }, a.min = function(f, y) {
      return f.cmp(y) < 0 ? f : y;
    }, a.prototype._init = function(f, y, v) {
      if (typeof f == "number")
        return this._initNumber(f, y, v);
      if (typeof f == "object")
        return this._initArray(f, y, v);
      y === "hex" && (y = 16), r(y === (y | 0) && y >= 2 && y <= 36), f = f.toString().replace(/\s+/g, "");
      var M = 0;
      f[0] === "-" && (M++, this.negative = 1), M < f.length && (y === 16 ? this._parseHex(f, M, v) : (this._parseBase(f, y, M), v === "le" && this._initArray(this.toArray(), y, v)));
    }, a.prototype._initNumber = function(f, y, v) {
      f < 0 && (this.negative = 1, f = -f), f < 67108864 ? (this.words = [f & 67108863], this.length = 1) : f < 4503599627370496 ? (this.words = [
        f & 67108863,
        f / 67108864 & 67108863
      ], this.length = 2) : (r(f < 9007199254740992), this.words = [
        f & 67108863,
        f / 67108864 & 67108863,
        1
      ], this.length = 3), v === "le" && this._initArray(this.toArray(), y, v);
    }, a.prototype._initArray = function(f, y, v) {
      if (r(typeof f.length == "number"), f.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(f.length / 3), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var B, S, _ = 0;
      if (v === "be")
        for (M = f.length - 1, B = 0; M >= 0; M -= 3)
          S = f[M] | f[M - 1] << 8 | f[M - 2] << 16, this.words[B] |= S << _ & 67108863, this.words[B + 1] = S >>> 26 - _ & 67108863, _ += 24, _ >= 26 && (_ -= 26, B++);
      else if (v === "le")
        for (M = 0, B = 0; M < f.length; M += 3)
          S = f[M] | f[M + 1] << 8 | f[M + 2] << 16, this.words[B] |= S << _ & 67108863, this.words[B + 1] = S >>> 26 - _ & 67108863, _ += 24, _ >= 26 && (_ -= 26, B++);
      return this._strip();
    };
    function d(f, y) {
      var v = f.charCodeAt(y);
      if (v >= 48 && v <= 57)
        return v - 48;
      if (v >= 65 && v <= 70)
        return v - 55;
      if (v >= 97 && v <= 102)
        return v - 87;
      r(!1, "Invalid character in " + f);
    }
    function b(f, y, v) {
      var M = d(f, v);
      return v - 1 >= y && (M |= d(f, v - 1) << 4), M;
    }
    a.prototype._parseHex = function(f, y, v) {
      this.length = Math.ceil((f.length - y) / 6), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var B = 0, S = 0, _;
      if (v === "be")
        for (M = f.length - 1; M >= y; M -= 2)
          _ = b(f, y, M) << B, this.words[S] |= _ & 67108863, B >= 18 ? (B -= 18, S += 1, this.words[S] |= _ >>> 26) : B += 8;
      else {
        var E = f.length - y;
        for (M = E % 2 === 0 ? y + 1 : y; M < f.length; M += 2)
          _ = b(f, y, M) << B, this.words[S] |= _ & 67108863, B >= 18 ? (B -= 18, S += 1, this.words[S] |= _ >>> 26) : B += 8;
      }
      this._strip();
    };
    function g(f, y, v, M) {
      for (var B = 0, S = 0, _ = Math.min(f.length, v), E = y; E < _; E++) {
        var m = f.charCodeAt(E) - 48;
        B *= M, m >= 49 ? S = m - 49 + 10 : m >= 17 ? S = m - 17 + 10 : S = m, r(m >= 0 && S < M, "Invalid character"), B += S;
      }
      return B;
    }
    a.prototype._parseBase = function(f, y, v) {
      this.words = [0], this.length = 1;
      for (var M = 0, B = 1; B <= 67108863; B *= y)
        M++;
      M--, B = B / y | 0;
      for (var S = f.length - v, _ = S % M, E = Math.min(S, S - _) + v, m = 0, A = v; A < E; A += M)
        m = g(f, A, A + M, y), this.imuln(B), this.words[0] + m < 67108864 ? this.words[0] += m : this._iaddn(m);
      if (_ !== 0) {
        var $ = 1;
        for (m = g(f, A, f.length, y), A = 0; A < _; A++)
          $ *= y;
        this.imuln($), this.words[0] + m < 67108864 ? this.words[0] += m : this._iaddn(m);
      }
      this._strip();
    }, a.prototype.copy = function(f) {
      f.words = new Array(this.length);
      for (var y = 0; y < this.length; y++)
        f.words[y] = this.words[y];
      f.length = this.length, f.negative = this.negative, f.red = this.red;
    };
    function w(f, y) {
      f.words = y.words, f.length = y.length, f.negative = y.negative, f.red = y.red;
    }
    if (a.prototype._move = function(f) {
      w(f, this);
    }, a.prototype.clone = function() {
      var f = new a(null);
      return this.copy(f), f;
    }, a.prototype._expand = function(f) {
      for (; this.length < f; )
        this.words[this.length++] = 0;
      return this;
    }, a.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, a.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        a.prototype[Symbol.for("nodejs.util.inspect.custom")] = C;
      } catch {
        a.prototype.inspect = C;
      }
    else
      a.prototype.inspect = C;
    function C() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var T = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], k = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], q = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    a.prototype.toString = function(f, y) {
      f = f || 10, y = y | 0 || 1;
      var v;
      if (f === 16 || f === "hex") {
        v = "";
        for (var M = 0, B = 0, S = 0; S < this.length; S++) {
          var _ = this.words[S], E = ((_ << M | B) & 16777215).toString(16);
          B = _ >>> 24 - M & 16777215, M += 2, M >= 26 && (M -= 26, S--), B !== 0 || S !== this.length - 1 ? v = T[6 - E.length] + E + v : v = E + v;
        }
        for (B !== 0 && (v = B.toString(16) + v); v.length % y !== 0; )
          v = "0" + v;
        return this.negative !== 0 && (v = "-" + v), v;
      }
      if (f === (f | 0) && f >= 2 && f <= 36) {
        var m = k[f], A = q[f];
        v = "";
        var $ = this.clone();
        for ($.negative = 0; !$.isZero(); ) {
          var X = $.modrn(A).toString(f);
          $ = $.idivn(A), $.isZero() ? v = X + v : v = T[m - X.length] + X + v;
        }
        for (this.isZero() && (v = "0" + v); v.length % y !== 0; )
          v = "0" + v;
        return this.negative !== 0 && (v = "-" + v), v;
      }
      r(!1, "Base should be between 2 and 36");
    }, a.prototype.toNumber = function() {
      var f = this.words[0];
      return this.length === 2 ? f += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f : f;
    }, a.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, p && (a.prototype.toBuffer = function(f, y) {
      return this.toArrayLike(p, f, y);
    }), a.prototype.toArray = function(f, y) {
      return this.toArrayLike(Array, f, y);
    };
    var O = function(f, y) {
      return f.allocUnsafe ? f.allocUnsafe(y) : new f(y);
    };
    a.prototype.toArrayLike = function(f, y, v) {
      this._strip();
      var M = this.byteLength(), B = v || Math.max(1, M);
      r(M <= B, "byte array longer than desired length"), r(B > 0, "Requested array length <= 0");
      var S = O(f, B), _ = y === "le" ? "LE" : "BE";
      return this["_toArrayLike" + _](S, M), S;
    }, a.prototype._toArrayLikeLE = function(f, y) {
      for (var v = 0, M = 0, B = 0, S = 0; B < this.length; B++) {
        var _ = this.words[B] << S | M;
        f[v++] = _ & 255, v < f.length && (f[v++] = _ >> 8 & 255), v < f.length && (f[v++] = _ >> 16 & 255), S === 6 ? (v < f.length && (f[v++] = _ >> 24 & 255), M = 0, S = 0) : (M = _ >>> 24, S += 2);
      }
      if (v < f.length)
        for (f[v++] = M; v < f.length; )
          f[v++] = 0;
    }, a.prototype._toArrayLikeBE = function(f, y) {
      for (var v = f.length - 1, M = 0, B = 0, S = 0; B < this.length; B++) {
        var _ = this.words[B] << S | M;
        f[v--] = _ & 255, v >= 0 && (f[v--] = _ >> 8 & 255), v >= 0 && (f[v--] = _ >> 16 & 255), S === 6 ? (v >= 0 && (f[v--] = _ >> 24 & 255), M = 0, S = 0) : (M = _ >>> 24, S += 2);
      }
      if (v >= 0)
        for (f[v--] = M; v >= 0; )
          f[v--] = 0;
    }, Math.clz32 ? a.prototype._countBits = function(f) {
      return 32 - Math.clz32(f);
    } : a.prototype._countBits = function(f) {
      var y = f, v = 0;
      return y >= 4096 && (v += 13, y >>>= 13), y >= 64 && (v += 7, y >>>= 7), y >= 8 && (v += 4, y >>>= 4), y >= 2 && (v += 2, y >>>= 2), v + y;
    }, a.prototype._zeroBits = function(f) {
      if (f === 0)
        return 26;
      var y = f, v = 0;
      return y & 8191 || (v += 13, y >>>= 13), y & 127 || (v += 7, y >>>= 7), y & 15 || (v += 4, y >>>= 4), y & 3 || (v += 2, y >>>= 2), y & 1 || v++, v;
    }, a.prototype.bitLength = function() {
      var f = this.words[this.length - 1], y = this._countBits(f);
      return (this.length - 1) * 26 + y;
    };
    function N(f) {
      for (var y = new Array(f.bitLength()), v = 0; v < y.length; v++) {
        var M = v / 26 | 0, B = v % 26;
        y[v] = f.words[M] >>> B & 1;
      }
      return y;
    }
    a.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var f = 0, y = 0; y < this.length; y++) {
        var v = this._zeroBits(this.words[y]);
        if (f += v, v !== 26)
          break;
      }
      return f;
    }, a.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, a.prototype.toTwos = function(f) {
      return this.negative !== 0 ? this.abs().inotn(f).iaddn(1) : this.clone();
    }, a.prototype.fromTwos = function(f) {
      return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone();
    }, a.prototype.isNeg = function() {
      return this.negative !== 0;
    }, a.prototype.neg = function() {
      return this.clone().ineg();
    }, a.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, a.prototype.iuor = function(f) {
      for (; this.length < f.length; )
        this.words[this.length++] = 0;
      for (var y = 0; y < f.length; y++)
        this.words[y] = this.words[y] | f.words[y];
      return this._strip();
    }, a.prototype.ior = function(f) {
      return r((this.negative | f.negative) === 0), this.iuor(f);
    }, a.prototype.or = function(f) {
      return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this);
    }, a.prototype.uor = function(f) {
      return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this);
    }, a.prototype.iuand = function(f) {
      var y;
      this.length > f.length ? y = f : y = this;
      for (var v = 0; v < y.length; v++)
        this.words[v] = this.words[v] & f.words[v];
      return this.length = y.length, this._strip();
    }, a.prototype.iand = function(f) {
      return r((this.negative | f.negative) === 0), this.iuand(f);
    }, a.prototype.and = function(f) {
      return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this);
    }, a.prototype.uand = function(f) {
      return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this);
    }, a.prototype.iuxor = function(f) {
      var y, v;
      this.length > f.length ? (y = this, v = f) : (y = f, v = this);
      for (var M = 0; M < v.length; M++)
        this.words[M] = y.words[M] ^ v.words[M];
      if (this !== y)
        for (; M < y.length; M++)
          this.words[M] = y.words[M];
      return this.length = y.length, this._strip();
    }, a.prototype.ixor = function(f) {
      return r((this.negative | f.negative) === 0), this.iuxor(f);
    }, a.prototype.xor = function(f) {
      return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this);
    }, a.prototype.uxor = function(f) {
      return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this);
    }, a.prototype.inotn = function(f) {
      r(typeof f == "number" && f >= 0);
      var y = Math.ceil(f / 26) | 0, v = f % 26;
      this._expand(y), v > 0 && y--;
      for (var M = 0; M < y; M++)
        this.words[M] = ~this.words[M] & 67108863;
      return v > 0 && (this.words[M] = ~this.words[M] & 67108863 >> 26 - v), this._strip();
    }, a.prototype.notn = function(f) {
      return this.clone().inotn(f);
    }, a.prototype.setn = function(f, y) {
      r(typeof f == "number" && f >= 0);
      var v = f / 26 | 0, M = f % 26;
      return this._expand(v + 1), y ? this.words[v] = this.words[v] | 1 << M : this.words[v] = this.words[v] & ~(1 << M), this._strip();
    }, a.prototype.iadd = function(f) {
      var y;
      if (this.negative !== 0 && f.negative === 0)
        return this.negative = 0, y = this.isub(f), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && f.negative !== 0)
        return f.negative = 0, y = this.isub(f), f.negative = 1, y._normSign();
      var v, M;
      this.length > f.length ? (v = this, M = f) : (v = f, M = this);
      for (var B = 0, S = 0; S < M.length; S++)
        y = (v.words[S] | 0) + (M.words[S] | 0) + B, this.words[S] = y & 67108863, B = y >>> 26;
      for (; B !== 0 && S < v.length; S++)
        y = (v.words[S] | 0) + B, this.words[S] = y & 67108863, B = y >>> 26;
      if (this.length = v.length, B !== 0)
        this.words[this.length] = B, this.length++;
      else if (v !== this)
        for (; S < v.length; S++)
          this.words[S] = v.words[S];
      return this;
    }, a.prototype.add = function(f) {
      var y;
      return f.negative !== 0 && this.negative === 0 ? (f.negative = 0, y = this.sub(f), f.negative ^= 1, y) : f.negative === 0 && this.negative !== 0 ? (this.negative = 0, y = f.sub(this), this.negative = 1, y) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this);
    }, a.prototype.isub = function(f) {
      if (f.negative !== 0) {
        f.negative = 0;
        var y = this.iadd(f);
        return f.negative = 1, y._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(f), this.negative = 1, this._normSign();
      var v = this.cmp(f);
      if (v === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var M, B;
      v > 0 ? (M = this, B = f) : (M = f, B = this);
      for (var S = 0, _ = 0; _ < B.length; _++)
        y = (M.words[_] | 0) - (B.words[_] | 0) + S, S = y >> 26, this.words[_] = y & 67108863;
      for (; S !== 0 && _ < M.length; _++)
        y = (M.words[_] | 0) + S, S = y >> 26, this.words[_] = y & 67108863;
      if (S === 0 && _ < M.length && M !== this)
        for (; _ < M.length; _++)
          this.words[_] = M.words[_];
      return this.length = Math.max(this.length, _), M !== this && (this.negative = 1), this._strip();
    }, a.prototype.sub = function(f) {
      return this.clone().isub(f);
    };
    function j(f, y, v) {
      v.negative = y.negative ^ f.negative;
      var M = f.length + y.length | 0;
      v.length = M, M = M - 1 | 0;
      var B = f.words[0] | 0, S = y.words[0] | 0, _ = B * S, E = _ & 67108863, m = _ / 67108864 | 0;
      v.words[0] = E;
      for (var A = 1; A < M; A++) {
        for (var $ = m >>> 26, X = m & 67108863, oe = Math.min(A, y.length - 1), J = Math.max(0, A - f.length + 1); J <= oe; J++) {
          var W = A - J | 0;
          B = f.words[W] | 0, S = y.words[J] | 0, _ = B * S + X, $ += _ / 67108864 | 0, X = _ & 67108863;
        }
        v.words[A] = X | 0, m = $ | 0;
      }
      return m !== 0 ? v.words[A] = m | 0 : v.length--, v._strip();
    }
    var U = function(f, y, v) {
      var M = f.words, B = y.words, S = v.words, _ = 0, E, m, A, $ = M[0] | 0, X = $ & 8191, oe = $ >>> 13, J = M[1] | 0, W = J & 8191, Q = J >>> 13, me = M[2] | 0, be = me & 8191, Y = me >>> 13, re = M[3] | 0, de = re & 8191, Ae = re >>> 13, qe = M[4] | 0, x = qe & 8191, L = qe >>> 13, D = M[5] | 0, F = D & 8191, ue = D >>> 13, ge = M[6] | 0, ce = ge & 8191, ve = ge >>> 13, Re = M[7] | 0, ke = Re & 8191, Ce = Re >>> 13, Le = M[8] | 0, Oe = Le & 8191, Pe = Le >>> 13, et = M[9] | 0, Ye = et & 8191, Ne = et >>> 13, Tt = B[0] | 0, tt = Tt & 8191, Ue = Tt >>> 13, Ct = B[1] | 0, rt = Ct & 8191, Ke = Ct >>> 13, ii = B[2] | 0, it = ii & 8191, $e = ii >>> 13, Ot = B[3] | 0, vt = Ot & 8191, Fe = Ot >>> 13, ni = B[4] | 0, nt = ni & 8191, ze = ni >>> 13, oi = B[5] | 0, ot = oi & 8191, Xe = oi >>> 13, Dt = B[6] | 0, Ze = Dt & 8191, je = Dt >>> 13, ri = B[7] | 0, St = ri & 8191, Qe = ri >>> 13, ai = B[8] | 0, It = ai & 8191, Je = ai >>> 13, si = B[9] | 0, At = si & 8191, Bt = si >>> 13;
      v.negative = f.negative ^ y.negative, v.length = 19, E = Math.imul(X, tt), m = Math.imul(X, Ue), m = m + Math.imul(oe, tt) | 0, A = Math.imul(oe, Ue);
      var ui = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (ui >>> 26) | 0, ui &= 67108863, E = Math.imul(W, tt), m = Math.imul(W, Ue), m = m + Math.imul(Q, tt) | 0, A = Math.imul(Q, Ue), E = E + Math.imul(X, rt) | 0, m = m + Math.imul(X, Ke) | 0, m = m + Math.imul(oe, rt) | 0, A = A + Math.imul(oe, Ke) | 0;
      var fi = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (fi >>> 26) | 0, fi &= 67108863, E = Math.imul(be, tt), m = Math.imul(be, Ue), m = m + Math.imul(Y, tt) | 0, A = Math.imul(Y, Ue), E = E + Math.imul(W, rt) | 0, m = m + Math.imul(W, Ke) | 0, m = m + Math.imul(Q, rt) | 0, A = A + Math.imul(Q, Ke) | 0, E = E + Math.imul(X, it) | 0, m = m + Math.imul(X, $e) | 0, m = m + Math.imul(oe, it) | 0, A = A + Math.imul(oe, $e) | 0;
      var hi = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (hi >>> 26) | 0, hi &= 67108863, E = Math.imul(de, tt), m = Math.imul(de, Ue), m = m + Math.imul(Ae, tt) | 0, A = Math.imul(Ae, Ue), E = E + Math.imul(be, rt) | 0, m = m + Math.imul(be, Ke) | 0, m = m + Math.imul(Y, rt) | 0, A = A + Math.imul(Y, Ke) | 0, E = E + Math.imul(W, it) | 0, m = m + Math.imul(W, $e) | 0, m = m + Math.imul(Q, it) | 0, A = A + Math.imul(Q, $e) | 0, E = E + Math.imul(X, vt) | 0, m = m + Math.imul(X, Fe) | 0, m = m + Math.imul(oe, vt) | 0, A = A + Math.imul(oe, Fe) | 0;
      var ci = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (ci >>> 26) | 0, ci &= 67108863, E = Math.imul(x, tt), m = Math.imul(x, Ue), m = m + Math.imul(L, tt) | 0, A = Math.imul(L, Ue), E = E + Math.imul(de, rt) | 0, m = m + Math.imul(de, Ke) | 0, m = m + Math.imul(Ae, rt) | 0, A = A + Math.imul(Ae, Ke) | 0, E = E + Math.imul(be, it) | 0, m = m + Math.imul(be, $e) | 0, m = m + Math.imul(Y, it) | 0, A = A + Math.imul(Y, $e) | 0, E = E + Math.imul(W, vt) | 0, m = m + Math.imul(W, Fe) | 0, m = m + Math.imul(Q, vt) | 0, A = A + Math.imul(Q, Fe) | 0, E = E + Math.imul(X, nt) | 0, m = m + Math.imul(X, ze) | 0, m = m + Math.imul(oe, nt) | 0, A = A + Math.imul(oe, ze) | 0;
      var li = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (li >>> 26) | 0, li &= 67108863, E = Math.imul(F, tt), m = Math.imul(F, Ue), m = m + Math.imul(ue, tt) | 0, A = Math.imul(ue, Ue), E = E + Math.imul(x, rt) | 0, m = m + Math.imul(x, Ke) | 0, m = m + Math.imul(L, rt) | 0, A = A + Math.imul(L, Ke) | 0, E = E + Math.imul(de, it) | 0, m = m + Math.imul(de, $e) | 0, m = m + Math.imul(Ae, it) | 0, A = A + Math.imul(Ae, $e) | 0, E = E + Math.imul(be, vt) | 0, m = m + Math.imul(be, Fe) | 0, m = m + Math.imul(Y, vt) | 0, A = A + Math.imul(Y, Fe) | 0, E = E + Math.imul(W, nt) | 0, m = m + Math.imul(W, ze) | 0, m = m + Math.imul(Q, nt) | 0, A = A + Math.imul(Q, ze) | 0, E = E + Math.imul(X, ot) | 0, m = m + Math.imul(X, Xe) | 0, m = m + Math.imul(oe, ot) | 0, A = A + Math.imul(oe, Xe) | 0;
      var di = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (di >>> 26) | 0, di &= 67108863, E = Math.imul(ce, tt), m = Math.imul(ce, Ue), m = m + Math.imul(ve, tt) | 0, A = Math.imul(ve, Ue), E = E + Math.imul(F, rt) | 0, m = m + Math.imul(F, Ke) | 0, m = m + Math.imul(ue, rt) | 0, A = A + Math.imul(ue, Ke) | 0, E = E + Math.imul(x, it) | 0, m = m + Math.imul(x, $e) | 0, m = m + Math.imul(L, it) | 0, A = A + Math.imul(L, $e) | 0, E = E + Math.imul(de, vt) | 0, m = m + Math.imul(de, Fe) | 0, m = m + Math.imul(Ae, vt) | 0, A = A + Math.imul(Ae, Fe) | 0, E = E + Math.imul(be, nt) | 0, m = m + Math.imul(be, ze) | 0, m = m + Math.imul(Y, nt) | 0, A = A + Math.imul(Y, ze) | 0, E = E + Math.imul(W, ot) | 0, m = m + Math.imul(W, Xe) | 0, m = m + Math.imul(Q, ot) | 0, A = A + Math.imul(Q, Xe) | 0, E = E + Math.imul(X, Ze) | 0, m = m + Math.imul(X, je) | 0, m = m + Math.imul(oe, Ze) | 0, A = A + Math.imul(oe, je) | 0;
      var pi = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (pi >>> 26) | 0, pi &= 67108863, E = Math.imul(ke, tt), m = Math.imul(ke, Ue), m = m + Math.imul(Ce, tt) | 0, A = Math.imul(Ce, Ue), E = E + Math.imul(ce, rt) | 0, m = m + Math.imul(ce, Ke) | 0, m = m + Math.imul(ve, rt) | 0, A = A + Math.imul(ve, Ke) | 0, E = E + Math.imul(F, it) | 0, m = m + Math.imul(F, $e) | 0, m = m + Math.imul(ue, it) | 0, A = A + Math.imul(ue, $e) | 0, E = E + Math.imul(x, vt) | 0, m = m + Math.imul(x, Fe) | 0, m = m + Math.imul(L, vt) | 0, A = A + Math.imul(L, Fe) | 0, E = E + Math.imul(de, nt) | 0, m = m + Math.imul(de, ze) | 0, m = m + Math.imul(Ae, nt) | 0, A = A + Math.imul(Ae, ze) | 0, E = E + Math.imul(be, ot) | 0, m = m + Math.imul(be, Xe) | 0, m = m + Math.imul(Y, ot) | 0, A = A + Math.imul(Y, Xe) | 0, E = E + Math.imul(W, Ze) | 0, m = m + Math.imul(W, je) | 0, m = m + Math.imul(Q, Ze) | 0, A = A + Math.imul(Q, je) | 0, E = E + Math.imul(X, St) | 0, m = m + Math.imul(X, Qe) | 0, m = m + Math.imul(oe, St) | 0, A = A + Math.imul(oe, Qe) | 0;
      var yi = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (yi >>> 26) | 0, yi &= 67108863, E = Math.imul(Oe, tt), m = Math.imul(Oe, Ue), m = m + Math.imul(Pe, tt) | 0, A = Math.imul(Pe, Ue), E = E + Math.imul(ke, rt) | 0, m = m + Math.imul(ke, Ke) | 0, m = m + Math.imul(Ce, rt) | 0, A = A + Math.imul(Ce, Ke) | 0, E = E + Math.imul(ce, it) | 0, m = m + Math.imul(ce, $e) | 0, m = m + Math.imul(ve, it) | 0, A = A + Math.imul(ve, $e) | 0, E = E + Math.imul(F, vt) | 0, m = m + Math.imul(F, Fe) | 0, m = m + Math.imul(ue, vt) | 0, A = A + Math.imul(ue, Fe) | 0, E = E + Math.imul(x, nt) | 0, m = m + Math.imul(x, ze) | 0, m = m + Math.imul(L, nt) | 0, A = A + Math.imul(L, ze) | 0, E = E + Math.imul(de, ot) | 0, m = m + Math.imul(de, Xe) | 0, m = m + Math.imul(Ae, ot) | 0, A = A + Math.imul(Ae, Xe) | 0, E = E + Math.imul(be, Ze) | 0, m = m + Math.imul(be, je) | 0, m = m + Math.imul(Y, Ze) | 0, A = A + Math.imul(Y, je) | 0, E = E + Math.imul(W, St) | 0, m = m + Math.imul(W, Qe) | 0, m = m + Math.imul(Q, St) | 0, A = A + Math.imul(Q, Qe) | 0, E = E + Math.imul(X, It) | 0, m = m + Math.imul(X, Je) | 0, m = m + Math.imul(oe, It) | 0, A = A + Math.imul(oe, Je) | 0;
      var mi = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (mi >>> 26) | 0, mi &= 67108863, E = Math.imul(Ye, tt), m = Math.imul(Ye, Ue), m = m + Math.imul(Ne, tt) | 0, A = Math.imul(Ne, Ue), E = E + Math.imul(Oe, rt) | 0, m = m + Math.imul(Oe, Ke) | 0, m = m + Math.imul(Pe, rt) | 0, A = A + Math.imul(Pe, Ke) | 0, E = E + Math.imul(ke, it) | 0, m = m + Math.imul(ke, $e) | 0, m = m + Math.imul(Ce, it) | 0, A = A + Math.imul(Ce, $e) | 0, E = E + Math.imul(ce, vt) | 0, m = m + Math.imul(ce, Fe) | 0, m = m + Math.imul(ve, vt) | 0, A = A + Math.imul(ve, Fe) | 0, E = E + Math.imul(F, nt) | 0, m = m + Math.imul(F, ze) | 0, m = m + Math.imul(ue, nt) | 0, A = A + Math.imul(ue, ze) | 0, E = E + Math.imul(x, ot) | 0, m = m + Math.imul(x, Xe) | 0, m = m + Math.imul(L, ot) | 0, A = A + Math.imul(L, Xe) | 0, E = E + Math.imul(de, Ze) | 0, m = m + Math.imul(de, je) | 0, m = m + Math.imul(Ae, Ze) | 0, A = A + Math.imul(Ae, je) | 0, E = E + Math.imul(be, St) | 0, m = m + Math.imul(be, Qe) | 0, m = m + Math.imul(Y, St) | 0, A = A + Math.imul(Y, Qe) | 0, E = E + Math.imul(W, It) | 0, m = m + Math.imul(W, Je) | 0, m = m + Math.imul(Q, It) | 0, A = A + Math.imul(Q, Je) | 0, E = E + Math.imul(X, At) | 0, m = m + Math.imul(X, Bt) | 0, m = m + Math.imul(oe, At) | 0, A = A + Math.imul(oe, Bt) | 0;
      var gi = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (gi >>> 26) | 0, gi &= 67108863, E = Math.imul(Ye, rt), m = Math.imul(Ye, Ke), m = m + Math.imul(Ne, rt) | 0, A = Math.imul(Ne, Ke), E = E + Math.imul(Oe, it) | 0, m = m + Math.imul(Oe, $e) | 0, m = m + Math.imul(Pe, it) | 0, A = A + Math.imul(Pe, $e) | 0, E = E + Math.imul(ke, vt) | 0, m = m + Math.imul(ke, Fe) | 0, m = m + Math.imul(Ce, vt) | 0, A = A + Math.imul(Ce, Fe) | 0, E = E + Math.imul(ce, nt) | 0, m = m + Math.imul(ce, ze) | 0, m = m + Math.imul(ve, nt) | 0, A = A + Math.imul(ve, ze) | 0, E = E + Math.imul(F, ot) | 0, m = m + Math.imul(F, Xe) | 0, m = m + Math.imul(ue, ot) | 0, A = A + Math.imul(ue, Xe) | 0, E = E + Math.imul(x, Ze) | 0, m = m + Math.imul(x, je) | 0, m = m + Math.imul(L, Ze) | 0, A = A + Math.imul(L, je) | 0, E = E + Math.imul(de, St) | 0, m = m + Math.imul(de, Qe) | 0, m = m + Math.imul(Ae, St) | 0, A = A + Math.imul(Ae, Qe) | 0, E = E + Math.imul(be, It) | 0, m = m + Math.imul(be, Je) | 0, m = m + Math.imul(Y, It) | 0, A = A + Math.imul(Y, Je) | 0, E = E + Math.imul(W, At) | 0, m = m + Math.imul(W, Bt) | 0, m = m + Math.imul(Q, At) | 0, A = A + Math.imul(Q, Bt) | 0;
      var vi = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (vi >>> 26) | 0, vi &= 67108863, E = Math.imul(Ye, it), m = Math.imul(Ye, $e), m = m + Math.imul(Ne, it) | 0, A = Math.imul(Ne, $e), E = E + Math.imul(Oe, vt) | 0, m = m + Math.imul(Oe, Fe) | 0, m = m + Math.imul(Pe, vt) | 0, A = A + Math.imul(Pe, Fe) | 0, E = E + Math.imul(ke, nt) | 0, m = m + Math.imul(ke, ze) | 0, m = m + Math.imul(Ce, nt) | 0, A = A + Math.imul(Ce, ze) | 0, E = E + Math.imul(ce, ot) | 0, m = m + Math.imul(ce, Xe) | 0, m = m + Math.imul(ve, ot) | 0, A = A + Math.imul(ve, Xe) | 0, E = E + Math.imul(F, Ze) | 0, m = m + Math.imul(F, je) | 0, m = m + Math.imul(ue, Ze) | 0, A = A + Math.imul(ue, je) | 0, E = E + Math.imul(x, St) | 0, m = m + Math.imul(x, Qe) | 0, m = m + Math.imul(L, St) | 0, A = A + Math.imul(L, Qe) | 0, E = E + Math.imul(de, It) | 0, m = m + Math.imul(de, Je) | 0, m = m + Math.imul(Ae, It) | 0, A = A + Math.imul(Ae, Je) | 0, E = E + Math.imul(be, At) | 0, m = m + Math.imul(be, Bt) | 0, m = m + Math.imul(Y, At) | 0, A = A + Math.imul(Y, Bt) | 0;
      var Nn = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (Nn >>> 26) | 0, Nn &= 67108863, E = Math.imul(Ye, vt), m = Math.imul(Ye, Fe), m = m + Math.imul(Ne, vt) | 0, A = Math.imul(Ne, Fe), E = E + Math.imul(Oe, nt) | 0, m = m + Math.imul(Oe, ze) | 0, m = m + Math.imul(Pe, nt) | 0, A = A + Math.imul(Pe, ze) | 0, E = E + Math.imul(ke, ot) | 0, m = m + Math.imul(ke, Xe) | 0, m = m + Math.imul(Ce, ot) | 0, A = A + Math.imul(Ce, Xe) | 0, E = E + Math.imul(ce, Ze) | 0, m = m + Math.imul(ce, je) | 0, m = m + Math.imul(ve, Ze) | 0, A = A + Math.imul(ve, je) | 0, E = E + Math.imul(F, St) | 0, m = m + Math.imul(F, Qe) | 0, m = m + Math.imul(ue, St) | 0, A = A + Math.imul(ue, Qe) | 0, E = E + Math.imul(x, It) | 0, m = m + Math.imul(x, Je) | 0, m = m + Math.imul(L, It) | 0, A = A + Math.imul(L, Je) | 0, E = E + Math.imul(de, At) | 0, m = m + Math.imul(de, Bt) | 0, m = m + Math.imul(Ae, At) | 0, A = A + Math.imul(Ae, Bt) | 0;
      var Dn = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (Dn >>> 26) | 0, Dn &= 67108863, E = Math.imul(Ye, nt), m = Math.imul(Ye, ze), m = m + Math.imul(Ne, nt) | 0, A = Math.imul(Ne, ze), E = E + Math.imul(Oe, ot) | 0, m = m + Math.imul(Oe, Xe) | 0, m = m + Math.imul(Pe, ot) | 0, A = A + Math.imul(Pe, Xe) | 0, E = E + Math.imul(ke, Ze) | 0, m = m + Math.imul(ke, je) | 0, m = m + Math.imul(Ce, Ze) | 0, A = A + Math.imul(Ce, je) | 0, E = E + Math.imul(ce, St) | 0, m = m + Math.imul(ce, Qe) | 0, m = m + Math.imul(ve, St) | 0, A = A + Math.imul(ve, Qe) | 0, E = E + Math.imul(F, It) | 0, m = m + Math.imul(F, Je) | 0, m = m + Math.imul(ue, It) | 0, A = A + Math.imul(ue, Je) | 0, E = E + Math.imul(x, At) | 0, m = m + Math.imul(x, Bt) | 0, m = m + Math.imul(L, At) | 0, A = A + Math.imul(L, Bt) | 0;
      var eM = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (eM >>> 26) | 0, eM &= 67108863, E = Math.imul(Ye, ot), m = Math.imul(Ye, Xe), m = m + Math.imul(Ne, ot) | 0, A = Math.imul(Ne, Xe), E = E + Math.imul(Oe, Ze) | 0, m = m + Math.imul(Oe, je) | 0, m = m + Math.imul(Pe, Ze) | 0, A = A + Math.imul(Pe, je) | 0, E = E + Math.imul(ke, St) | 0, m = m + Math.imul(ke, Qe) | 0, m = m + Math.imul(Ce, St) | 0, A = A + Math.imul(Ce, Qe) | 0, E = E + Math.imul(ce, It) | 0, m = m + Math.imul(ce, Je) | 0, m = m + Math.imul(ve, It) | 0, A = A + Math.imul(ve, Je) | 0, E = E + Math.imul(F, At) | 0, m = m + Math.imul(F, Bt) | 0, m = m + Math.imul(ue, At) | 0, A = A + Math.imul(ue, Bt) | 0;
      var tM = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (tM >>> 26) | 0, tM &= 67108863, E = Math.imul(Ye, Ze), m = Math.imul(Ye, je), m = m + Math.imul(Ne, Ze) | 0, A = Math.imul(Ne, je), E = E + Math.imul(Oe, St) | 0, m = m + Math.imul(Oe, Qe) | 0, m = m + Math.imul(Pe, St) | 0, A = A + Math.imul(Pe, Qe) | 0, E = E + Math.imul(ke, It) | 0, m = m + Math.imul(ke, Je) | 0, m = m + Math.imul(Ce, It) | 0, A = A + Math.imul(Ce, Je) | 0, E = E + Math.imul(ce, At) | 0, m = m + Math.imul(ce, Bt) | 0, m = m + Math.imul(ve, At) | 0, A = A + Math.imul(ve, Bt) | 0;
      var rM = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (rM >>> 26) | 0, rM &= 67108863, E = Math.imul(Ye, St), m = Math.imul(Ye, Qe), m = m + Math.imul(Ne, St) | 0, A = Math.imul(Ne, Qe), E = E + Math.imul(Oe, It) | 0, m = m + Math.imul(Oe, Je) | 0, m = m + Math.imul(Pe, It) | 0, A = A + Math.imul(Pe, Je) | 0, E = E + Math.imul(ke, At) | 0, m = m + Math.imul(ke, Bt) | 0, m = m + Math.imul(Ce, At) | 0, A = A + Math.imul(Ce, Bt) | 0;
      var iM = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (iM >>> 26) | 0, iM &= 67108863, E = Math.imul(Ye, It), m = Math.imul(Ye, Je), m = m + Math.imul(Ne, It) | 0, A = Math.imul(Ne, Je), E = E + Math.imul(Oe, At) | 0, m = m + Math.imul(Oe, Bt) | 0, m = m + Math.imul(Pe, At) | 0, A = A + Math.imul(Pe, Bt) | 0;
      var nM = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (nM >>> 26) | 0, nM &= 67108863, E = Math.imul(Ye, At), m = Math.imul(Ye, Bt), m = m + Math.imul(Ne, At) | 0, A = Math.imul(Ne, Bt);
      var oM = (_ + E | 0) + ((m & 8191) << 13) | 0;
      return _ = (A + (m >>> 13) | 0) + (oM >>> 26) | 0, oM &= 67108863, S[0] = ui, S[1] = fi, S[2] = hi, S[3] = ci, S[4] = li, S[5] = di, S[6] = pi, S[7] = yi, S[8] = mi, S[9] = gi, S[10] = vi, S[11] = Nn, S[12] = Dn, S[13] = eM, S[14] = tM, S[15] = rM, S[16] = iM, S[17] = nM, S[18] = oM, _ !== 0 && (S[19] = _, v.length++), v;
    };
    Math.imul || (U = j);
    function H(f, y, v) {
      v.negative = y.negative ^ f.negative, v.length = f.length + y.length;
      for (var M = 0, B = 0, S = 0; S < v.length - 1; S++) {
        var _ = B;
        B = 0;
        for (var E = M & 67108863, m = Math.min(S, y.length - 1), A = Math.max(0, S - f.length + 1); A <= m; A++) {
          var $ = S - A, X = f.words[$] | 0, oe = y.words[A] | 0, J = X * oe, W = J & 67108863;
          _ = _ + (J / 67108864 | 0) | 0, W = W + E | 0, E = W & 67108863, _ = _ + (W >>> 26) | 0, B += _ >>> 26, _ &= 67108863;
        }
        v.words[S] = E, M = _, _ = B;
      }
      return M !== 0 ? v.words[S] = M : v.length--, v._strip();
    }
    function z(f, y, v) {
      return H(f, y, v);
    }
    a.prototype.mulTo = function(f, y) {
      var v, M = this.length + f.length;
      return this.length === 10 && f.length === 10 ? v = U(this, f, y) : M < 63 ? v = j(this, f, y) : M < 1024 ? v = H(this, f, y) : v = z(this, f, y), v;
    }, a.prototype.mul = function(f) {
      var y = new a(null);
      return y.words = new Array(this.length + f.length), this.mulTo(f, y);
    }, a.prototype.mulf = function(f) {
      var y = new a(null);
      return y.words = new Array(this.length + f.length), z(this, f, y);
    }, a.prototype.imul = function(f) {
      return this.clone().mulTo(f, this);
    }, a.prototype.imuln = function(f) {
      var y = f < 0;
      y && (f = -f), r(typeof f == "number"), r(f < 67108864);
      for (var v = 0, M = 0; M < this.length; M++) {
        var B = (this.words[M] | 0) * f, S = (B & 67108863) + (v & 67108863);
        v >>= 26, v += B / 67108864 | 0, v += S >>> 26, this.words[M] = S & 67108863;
      }
      return v !== 0 && (this.words[M] = v, this.length++), y ? this.ineg() : this;
    }, a.prototype.muln = function(f) {
      return this.clone().imuln(f);
    }, a.prototype.sqr = function() {
      return this.mul(this);
    }, a.prototype.isqr = function() {
      return this.imul(this.clone());
    }, a.prototype.pow = function(f) {
      var y = N(f);
      if (y.length === 0)
        return new a(1);
      for (var v = this, M = 0; M < y.length && y[M] === 0; M++, v = v.sqr())
        ;
      if (++M < y.length)
        for (var B = v.sqr(); M < y.length; M++, B = B.sqr())
          y[M] !== 0 && (v = v.mul(B));
      return v;
    }, a.prototype.iushln = function(f) {
      r(typeof f == "number" && f >= 0);
      var y = f % 26, v = (f - y) / 26, M = 67108863 >>> 26 - y << 26 - y, B;
      if (y !== 0) {
        var S = 0;
        for (B = 0; B < this.length; B++) {
          var _ = this.words[B] & M, E = (this.words[B] | 0) - _ << y;
          this.words[B] = E | S, S = _ >>> 26 - y;
        }
        S && (this.words[B] = S, this.length++);
      }
      if (v !== 0) {
        for (B = this.length - 1; B >= 0; B--)
          this.words[B + v] = this.words[B];
        for (B = 0; B < v; B++)
          this.words[B] = 0;
        this.length += v;
      }
      return this._strip();
    }, a.prototype.ishln = function(f) {
      return r(this.negative === 0), this.iushln(f);
    }, a.prototype.iushrn = function(f, y, v) {
      r(typeof f == "number" && f >= 0);
      var M;
      y ? M = (y - y % 26) / 26 : M = 0;
      var B = f % 26, S = Math.min((f - B) / 26, this.length), _ = 67108863 ^ 67108863 >>> B << B, E = v;
      if (M -= S, M = Math.max(0, M), E) {
        for (var m = 0; m < S; m++)
          E.words[m] = this.words[m];
        E.length = S;
      }
      if (S !== 0)
        if (this.length > S)
          for (this.length -= S, m = 0; m < this.length; m++)
            this.words[m] = this.words[m + S];
        else
          this.words[0] = 0, this.length = 1;
      var A = 0;
      for (m = this.length - 1; m >= 0 && (A !== 0 || m >= M); m--) {
        var $ = this.words[m] | 0;
        this.words[m] = A << 26 - B | $ >>> B, A = $ & _;
      }
      return E && A !== 0 && (E.words[E.length++] = A), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, a.prototype.ishrn = function(f, y, v) {
      return r(this.negative === 0), this.iushrn(f, y, v);
    }, a.prototype.shln = function(f) {
      return this.clone().ishln(f);
    }, a.prototype.ushln = function(f) {
      return this.clone().iushln(f);
    }, a.prototype.shrn = function(f) {
      return this.clone().ishrn(f);
    }, a.prototype.ushrn = function(f) {
      return this.clone().iushrn(f);
    }, a.prototype.testn = function(f) {
      r(typeof f == "number" && f >= 0);
      var y = f % 26, v = (f - y) / 26, M = 1 << y;
      if (this.length <= v)
        return !1;
      var B = this.words[v];
      return !!(B & M);
    }, a.prototype.imaskn = function(f) {
      r(typeof f == "number" && f >= 0);
      var y = f % 26, v = (f - y) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= v)
        return this;
      if (y !== 0 && v++, this.length = Math.min(v, this.length), y !== 0) {
        var M = 67108863 ^ 67108863 >>> y << y;
        this.words[this.length - 1] &= M;
      }
      return this._strip();
    }, a.prototype.maskn = function(f) {
      return this.clone().imaskn(f);
    }, a.prototype.iaddn = function(f) {
      return r(typeof f == "number"), r(f < 67108864), f < 0 ? this.isubn(-f) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f ? (this.words[0] = f - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f), this.negative = 1, this) : this._iaddn(f);
    }, a.prototype._iaddn = function(f) {
      this.words[0] += f;
      for (var y = 0; y < this.length && this.words[y] >= 67108864; y++)
        this.words[y] -= 67108864, y === this.length - 1 ? this.words[y + 1] = 1 : this.words[y + 1]++;
      return this.length = Math.max(this.length, y + 1), this;
    }, a.prototype.isubn = function(f) {
      if (r(typeof f == "number"), r(f < 67108864), f < 0)
        return this.iaddn(-f);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(f), this.negative = 1, this;
      if (this.words[0] -= f, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var y = 0; y < this.length && this.words[y] < 0; y++)
          this.words[y] += 67108864, this.words[y + 1] -= 1;
      return this._strip();
    }, a.prototype.addn = function(f) {
      return this.clone().iaddn(f);
    }, a.prototype.subn = function(f) {
      return this.clone().isubn(f);
    }, a.prototype.iabs = function() {
      return this.negative = 0, this;
    }, a.prototype.abs = function() {
      return this.clone().iabs();
    }, a.prototype._ishlnsubmul = function(f, y, v) {
      var M = f.length + v, B;
      this._expand(M);
      var S, _ = 0;
      for (B = 0; B < f.length; B++) {
        S = (this.words[B + v] | 0) + _;
        var E = (f.words[B] | 0) * y;
        S -= E & 67108863, _ = (S >> 26) - (E / 67108864 | 0), this.words[B + v] = S & 67108863;
      }
      for (; B < this.length - v; B++)
        S = (this.words[B + v] | 0) + _, _ = S >> 26, this.words[B + v] = S & 67108863;
      if (_ === 0)
        return this._strip();
      for (r(_ === -1), _ = 0, B = 0; B < this.length; B++)
        S = -(this.words[B] | 0) + _, _ = S >> 26, this.words[B] = S & 67108863;
      return this.negative = 1, this._strip();
    }, a.prototype._wordDiv = function(f, y) {
      var v = this.length - f.length, M = this.clone(), B = f, S = B.words[B.length - 1] | 0, _ = this._countBits(S);
      v = 26 - _, v !== 0 && (B = B.ushln(v), M.iushln(v), S = B.words[B.length - 1] | 0);
      var E = M.length - B.length, m;
      if (y !== "mod") {
        m = new a(null), m.length = E + 1, m.words = new Array(m.length);
        for (var A = 0; A < m.length; A++)
          m.words[A] = 0;
      }
      var $ = M.clone()._ishlnsubmul(B, 1, E);
      $.negative === 0 && (M = $, m && (m.words[E] = 1));
      for (var X = E - 1; X >= 0; X--) {
        var oe = (M.words[B.length + X] | 0) * 67108864 + (M.words[B.length + X - 1] | 0);
        for (oe = Math.min(oe / S | 0, 67108863), M._ishlnsubmul(B, oe, X); M.negative !== 0; )
          oe--, M.negative = 0, M._ishlnsubmul(B, 1, X), M.isZero() || (M.negative ^= 1);
        m && (m.words[X] = oe);
      }
      return m && m._strip(), M._strip(), y !== "div" && v !== 0 && M.iushrn(v), {
        div: m || null,
        mod: M
      };
    }, a.prototype.divmod = function(f, y, v) {
      if (r(!f.isZero()), this.isZero())
        return {
          div: new a(0),
          mod: new a(0)
        };
      var M, B, S;
      return this.negative !== 0 && f.negative === 0 ? (S = this.neg().divmod(f, y), y !== "mod" && (M = S.div.neg()), y !== "div" && (B = S.mod.neg(), v && B.negative !== 0 && B.iadd(f)), {
        div: M,
        mod: B
      }) : this.negative === 0 && f.negative !== 0 ? (S = this.divmod(f.neg(), y), y !== "mod" && (M = S.div.neg()), {
        div: M,
        mod: S.mod
      }) : this.negative & f.negative ? (S = this.neg().divmod(f.neg(), y), y !== "div" && (B = S.mod.neg(), v && B.negative !== 0 && B.isub(f)), {
        div: S.div,
        mod: B
      }) : f.length > this.length || this.cmp(f) < 0 ? {
        div: new a(0),
        mod: this
      } : f.length === 1 ? y === "div" ? {
        div: this.divn(f.words[0]),
        mod: null
      } : y === "mod" ? {
        div: null,
        mod: new a(this.modrn(f.words[0]))
      } : {
        div: this.divn(f.words[0]),
        mod: new a(this.modrn(f.words[0]))
      } : this._wordDiv(f, y);
    }, a.prototype.div = function(f) {
      return this.divmod(f, "div", !1).div;
    }, a.prototype.mod = function(f) {
      return this.divmod(f, "mod", !1).mod;
    }, a.prototype.umod = function(f) {
      return this.divmod(f, "mod", !0).mod;
    }, a.prototype.divRound = function(f) {
      var y = this.divmod(f);
      if (y.mod.isZero())
        return y.div;
      var v = y.div.negative !== 0 ? y.mod.isub(f) : y.mod, M = f.ushrn(1), B = f.andln(1), S = v.cmp(M);
      return S < 0 || B === 1 && S === 0 ? y.div : y.div.negative !== 0 ? y.div.isubn(1) : y.div.iaddn(1);
    }, a.prototype.modrn = function(f) {
      var y = f < 0;
      y && (f = -f), r(f <= 67108863);
      for (var v = (1 << 26) % f, M = 0, B = this.length - 1; B >= 0; B--)
        M = (v * M + (this.words[B] | 0)) % f;
      return y ? -M : M;
    }, a.prototype.modn = function(f) {
      return this.modrn(f);
    }, a.prototype.idivn = function(f) {
      var y = f < 0;
      y && (f = -f), r(f <= 67108863);
      for (var v = 0, M = this.length - 1; M >= 0; M--) {
        var B = (this.words[M] | 0) + v * 67108864;
        this.words[M] = B / f | 0, v = B % f;
      }
      return this._strip(), y ? this.ineg() : this;
    }, a.prototype.divn = function(f) {
      return this.clone().idivn(f);
    }, a.prototype.egcd = function(f) {
      r(f.negative === 0), r(!f.isZero());
      var y = this, v = f.clone();
      y.negative !== 0 ? y = y.umod(f) : y = y.clone();
      for (var M = new a(1), B = new a(0), S = new a(0), _ = new a(1), E = 0; y.isEven() && v.isEven(); )
        y.iushrn(1), v.iushrn(1), ++E;
      for (var m = v.clone(), A = y.clone(); !y.isZero(); ) {
        for (var $ = 0, X = 1; !(y.words[0] & X) && $ < 26; ++$, X <<= 1)
          ;
        if ($ > 0)
          for (y.iushrn($); $-- > 0; )
            (M.isOdd() || B.isOdd()) && (M.iadd(m), B.isub(A)), M.iushrn(1), B.iushrn(1);
        for (var oe = 0, J = 1; !(v.words[0] & J) && oe < 26; ++oe, J <<= 1)
          ;
        if (oe > 0)
          for (v.iushrn(oe); oe-- > 0; )
            (S.isOdd() || _.isOdd()) && (S.iadd(m), _.isub(A)), S.iushrn(1), _.iushrn(1);
        y.cmp(v) >= 0 ? (y.isub(v), M.isub(S), B.isub(_)) : (v.isub(y), S.isub(M), _.isub(B));
      }
      return {
        a: S,
        b: _,
        gcd: v.iushln(E)
      };
    }, a.prototype._invmp = function(f) {
      r(f.negative === 0), r(!f.isZero());
      var y = this, v = f.clone();
      y.negative !== 0 ? y = y.umod(f) : y = y.clone();
      for (var M = new a(1), B = new a(0), S = v.clone(); y.cmpn(1) > 0 && v.cmpn(1) > 0; ) {
        for (var _ = 0, E = 1; !(y.words[0] & E) && _ < 26; ++_, E <<= 1)
          ;
        if (_ > 0)
          for (y.iushrn(_); _-- > 0; )
            M.isOdd() && M.iadd(S), M.iushrn(1);
        for (var m = 0, A = 1; !(v.words[0] & A) && m < 26; ++m, A <<= 1)
          ;
        if (m > 0)
          for (v.iushrn(m); m-- > 0; )
            B.isOdd() && B.iadd(S), B.iushrn(1);
        y.cmp(v) >= 0 ? (y.isub(v), M.isub(B)) : (v.isub(y), B.isub(M));
      }
      var $;
      return y.cmpn(1) === 0 ? $ = M : $ = B, $.cmpn(0) < 0 && $.iadd(f), $;
    }, a.prototype.gcd = function(f) {
      if (this.isZero())
        return f.abs();
      if (f.isZero())
        return this.abs();
      var y = this.clone(), v = f.clone();
      y.negative = 0, v.negative = 0;
      for (var M = 0; y.isEven() && v.isEven(); M++)
        y.iushrn(1), v.iushrn(1);
      do {
        for (; y.isEven(); )
          y.iushrn(1);
        for (; v.isEven(); )
          v.iushrn(1);
        var B = y.cmp(v);
        if (B < 0) {
          var S = y;
          y = v, v = S;
        } else if (B === 0 || v.cmpn(1) === 0)
          break;
        y.isub(v);
      } while (!0);
      return v.iushln(M);
    }, a.prototype.invm = function(f) {
      return this.egcd(f).a.umod(f);
    }, a.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, a.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, a.prototype.andln = function(f) {
      return this.words[0] & f;
    }, a.prototype.bincn = function(f) {
      r(typeof f == "number");
      var y = f % 26, v = (f - y) / 26, M = 1 << y;
      if (this.length <= v)
        return this._expand(v + 1), this.words[v] |= M, this;
      for (var B = M, S = v; B !== 0 && S < this.length; S++) {
        var _ = this.words[S] | 0;
        _ += B, B = _ >>> 26, _ &= 67108863, this.words[S] = _;
      }
      return B !== 0 && (this.words[S] = B, this.length++), this;
    }, a.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, a.prototype.cmpn = function(f) {
      var y = f < 0;
      if (this.negative !== 0 && !y)
        return -1;
      if (this.negative === 0 && y)
        return 1;
      this._strip();
      var v;
      if (this.length > 1)
        v = 1;
      else {
        y && (f = -f), r(f <= 67108863, "Number is too big");
        var M = this.words[0] | 0;
        v = M === f ? 0 : M < f ? -1 : 1;
      }
      return this.negative !== 0 ? -v | 0 : v;
    }, a.prototype.cmp = function(f) {
      if (this.negative !== 0 && f.negative === 0)
        return -1;
      if (this.negative === 0 && f.negative !== 0)
        return 1;
      var y = this.ucmp(f);
      return this.negative !== 0 ? -y | 0 : y;
    }, a.prototype.ucmp = function(f) {
      if (this.length > f.length)
        return 1;
      if (this.length < f.length)
        return -1;
      for (var y = 0, v = this.length - 1; v >= 0; v--) {
        var M = this.words[v] | 0, B = f.words[v] | 0;
        if (M !== B) {
          M < B ? y = -1 : M > B && (y = 1);
          break;
        }
      }
      return y;
    }, a.prototype.gtn = function(f) {
      return this.cmpn(f) === 1;
    }, a.prototype.gt = function(f) {
      return this.cmp(f) === 1;
    }, a.prototype.gten = function(f) {
      return this.cmpn(f) >= 0;
    }, a.prototype.gte = function(f) {
      return this.cmp(f) >= 0;
    }, a.prototype.ltn = function(f) {
      return this.cmpn(f) === -1;
    }, a.prototype.lt = function(f) {
      return this.cmp(f) === -1;
    }, a.prototype.lten = function(f) {
      return this.cmpn(f) <= 0;
    }, a.prototype.lte = function(f) {
      return this.cmp(f) <= 0;
    }, a.prototype.eqn = function(f) {
      return this.cmpn(f) === 0;
    }, a.prototype.eq = function(f) {
      return this.cmp(f) === 0;
    }, a.red = function(f) {
      return new I(f);
    }, a.prototype.toRed = function(f) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), f.convertTo(this)._forceRed(f);
    }, a.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, a.prototype._forceRed = function(f) {
      return this.red = f, this;
    }, a.prototype.forceRed = function(f) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(f);
    }, a.prototype.redAdd = function(f) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, f);
    }, a.prototype.redIAdd = function(f) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f);
    }, a.prototype.redSub = function(f) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, f);
    }, a.prototype.redISub = function(f) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, f);
    }, a.prototype.redShl = function(f) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, f);
    }, a.prototype.redMul = function(f) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.mul(this, f);
    }, a.prototype.redIMul = function(f) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.imul(this, f);
    }, a.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, a.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, a.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, a.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, a.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, a.prototype.redPow = function(f) {
      return r(this.red && !f.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f);
    };
    var ee = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function ne(f, y) {
      this.name = f, this.p = new a(y, 16), this.n = this.p.bitLength(), this.k = new a(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    ne.prototype._tmp = function() {
      var f = new a(null);
      return f.words = new Array(Math.ceil(this.n / 13)), f;
    }, ne.prototype.ireduce = function(f) {
      var y = f, v;
      do
        this.split(y, this.tmp), y = this.imulK(y), y = y.iadd(this.tmp), v = y.bitLength();
      while (v > this.n);
      var M = v < this.n ? -1 : y.ucmp(this.p);
      return M === 0 ? (y.words[0] = 0, y.length = 1) : M > 0 ? y.isub(this.p) : y.strip !== void 0 ? y.strip() : y._strip(), y;
    }, ne.prototype.split = function(f, y) {
      f.iushrn(this.n, 0, y);
    }, ne.prototype.imulK = function(f) {
      return f.imul(this.k);
    };
    function le() {
      ne.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    h(le, ne), le.prototype.split = function(f, y) {
      for (var v = 4194303, M = Math.min(f.length, 9), B = 0; B < M; B++)
        y.words[B] = f.words[B];
      if (y.length = M, f.length <= 9) {
        f.words[0] = 0, f.length = 1;
        return;
      }
      var S = f.words[9];
      for (y.words[y.length++] = S & v, B = 10; B < f.length; B++) {
        var _ = f.words[B] | 0;
        f.words[B - 10] = (_ & v) << 4 | S >>> 22, S = _;
      }
      S >>>= 22, f.words[B - 10] = S, S === 0 && f.length > 10 ? f.length -= 10 : f.length -= 9;
    }, le.prototype.imulK = function(f) {
      f.words[f.length] = 0, f.words[f.length + 1] = 0, f.length += 2;
      for (var y = 0, v = 0; v < f.length; v++) {
        var M = f.words[v] | 0;
        y += M * 977, f.words[v] = y & 67108863, y = M * 64 + (y / 67108864 | 0);
      }
      return f.words[f.length - 1] === 0 && (f.length--, f.words[f.length - 1] === 0 && f.length--), f;
    };
    function Z() {
      ne.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    h(Z, ne);
    function ie() {
      ne.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    h(ie, ne);
    function fe() {
      ne.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    h(fe, ne), fe.prototype.imulK = function(f) {
      for (var y = 0, v = 0; v < f.length; v++) {
        var M = (f.words[v] | 0) * 19 + y, B = M & 67108863;
        M >>>= 26, f.words[v] = B, y = M;
      }
      return y !== 0 && (f.words[f.length++] = y), f;
    }, a._prime = function(f) {
      if (ee[f])
        return ee[f];
      var y;
      if (f === "k256")
        y = new le();
      else if (f === "p224")
        y = new Z();
      else if (f === "p192")
        y = new ie();
      else if (f === "p25519")
        y = new fe();
      else
        throw new Error("Unknown prime " + f);
      return ee[f] = y, y;
    };
    function I(f) {
      if (typeof f == "string") {
        var y = a._prime(f);
        this.m = y.p, this.prime = y;
      } else
        r(f.gtn(1), "modulus must be greater than 1"), this.m = f, this.prime = null;
    }
    I.prototype._verify1 = function(f) {
      r(f.negative === 0, "red works only with positives"), r(f.red, "red works only with red numbers");
    }, I.prototype._verify2 = function(f, y) {
      r((f.negative | y.negative) === 0, "red works only with positives"), r(
        f.red && f.red === y.red,
        "red works only with red numbers"
      );
    }, I.prototype.imod = function(f) {
      return this.prime ? this.prime.ireduce(f)._forceRed(this) : (w(f, f.umod(this.m)._forceRed(this)), f);
    }, I.prototype.neg = function(f) {
      return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this);
    }, I.prototype.add = function(f, y) {
      this._verify2(f, y);
      var v = f.add(y);
      return v.cmp(this.m) >= 0 && v.isub(this.m), v._forceRed(this);
    }, I.prototype.iadd = function(f, y) {
      this._verify2(f, y);
      var v = f.iadd(y);
      return v.cmp(this.m) >= 0 && v.isub(this.m), v;
    }, I.prototype.sub = function(f, y) {
      this._verify2(f, y);
      var v = f.sub(y);
      return v.cmpn(0) < 0 && v.iadd(this.m), v._forceRed(this);
    }, I.prototype.isub = function(f, y) {
      this._verify2(f, y);
      var v = f.isub(y);
      return v.cmpn(0) < 0 && v.iadd(this.m), v;
    }, I.prototype.shl = function(f, y) {
      return this._verify1(f), this.imod(f.ushln(y));
    }, I.prototype.imul = function(f, y) {
      return this._verify2(f, y), this.imod(f.imul(y));
    }, I.prototype.mul = function(f, y) {
      return this._verify2(f, y), this.imod(f.mul(y));
    }, I.prototype.isqr = function(f) {
      return this.imul(f, f.clone());
    }, I.prototype.sqr = function(f) {
      return this.mul(f, f);
    }, I.prototype.sqrt = function(f) {
      if (f.isZero())
        return f.clone();
      var y = this.m.andln(3);
      if (r(y % 2 === 1), y === 3) {
        var v = this.m.add(new a(1)).iushrn(2);
        return this.pow(f, v);
      }
      for (var M = this.m.subn(1), B = 0; !M.isZero() && M.andln(1) === 0; )
        B++, M.iushrn(1);
      r(!M.isZero());
      var S = new a(1).toRed(this), _ = S.redNeg(), E = this.m.subn(1).iushrn(1), m = this.m.bitLength();
      for (m = new a(2 * m * m).toRed(this); this.pow(m, E).cmp(_) !== 0; )
        m.redIAdd(_);
      for (var A = this.pow(m, M), $ = this.pow(f, M.addn(1).iushrn(1)), X = this.pow(f, M), oe = B; X.cmp(S) !== 0; ) {
        for (var J = X, W = 0; J.cmp(S) !== 0; W++)
          J = J.redSqr();
        r(W < oe);
        var Q = this.pow(A, new a(1).iushln(oe - W - 1));
        $ = $.redMul(Q), A = Q.redSqr(), X = X.redMul(A), oe = W;
      }
      return $;
    }, I.prototype.invm = function(f) {
      var y = f._invmp(this.m);
      return y.negative !== 0 ? (y.negative = 0, this.imod(y).redNeg()) : this.imod(y);
    }, I.prototype.pow = function(f, y) {
      if (y.isZero())
        return new a(1).toRed(this);
      if (y.cmpn(1) === 0)
        return f.clone();
      var v = 4, M = new Array(1 << v);
      M[0] = new a(1).toRed(this), M[1] = f;
      for (var B = 2; B < M.length; B++)
        M[B] = this.mul(M[B - 1], f);
      var S = M[0], _ = 0, E = 0, m = y.bitLength() % 26;
      for (m === 0 && (m = 26), B = y.length - 1; B >= 0; B--) {
        for (var A = y.words[B], $ = m - 1; $ >= 0; $--) {
          var X = A >> $ & 1;
          if (S !== M[0] && (S = this.sqr(S)), X === 0 && _ === 0) {
            E = 0;
            continue;
          }
          _ <<= 1, _ |= X, E++, !(E !== v && (B !== 0 || $ !== 0)) && (S = this.mul(S, M[_]), E = 0, _ = 0);
        }
        m = 26;
      }
      return S;
    }, I.prototype.convertTo = function(f) {
      var y = f.umod(this.m);
      return y === f ? y.clone() : y;
    }, I.prototype.convertFrom = function(f) {
      var y = f.clone();
      return y.red = null, y;
    }, a.mont = function(f) {
      return new P(f);
    };
    function P(f) {
      I.call(this, f), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new a(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    h(P, I), P.prototype.convertTo = function(f) {
      return this.imod(f.ushln(this.shift));
    }, P.prototype.convertFrom = function(f) {
      var y = this.imod(f.mul(this.rinv));
      return y.red = null, y;
    }, P.prototype.imul = function(f, y) {
      if (f.isZero() || y.isZero())
        return f.words[0] = 0, f.length = 1, f;
      var v = f.imul(y), M = v.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), B = v.isub(M).iushrn(this.shift), S = B;
      return B.cmp(this.m) >= 0 ? S = B.isub(this.m) : B.cmpn(0) < 0 && (S = B.iadd(this.m)), S._forceRed(this);
    }, P.prototype.mul = function(f, y) {
      if (f.isZero() || y.isZero())
        return new a(0)._forceRed(this);
      var v = f.mul(y), M = v.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), B = v.isub(M).iushrn(this.shift), S = B;
      return B.cmp(this.m) >= 0 ? S = B.isub(this.m) : B.cmpn(0) < 0 && (S = B.iadd(this.m)), S._forceRed(this);
    }, P.prototype.invm = function(f) {
      var y = this.imod(f._invmp(this.m).mul(this.r2));
      return y._forceRed(this);
    };
  })(e, Me);
})(ah);
var g3 = ah.exports, Ea = g3, m3 = Ua;
function b3(e) {
  var t = Wv(e), o = t.toRed(Ea.mont(e.modulus)).redPow(new Ea(e.publicExponent)).fromRed();
  return { blinder: o, unblinder: t.invm(e.modulus) };
}
function Wv(e) {
  var t = e.modulus.byteLength(), o;
  do
    o = new Ea(m3(t));
  while (o.cmp(e.modulus) >= 0 || !o.umod(e.prime1) || !o.umod(e.prime2));
  return o;
}
function Yv(e, t) {
  var o = b3(t), r = t.modulus.byteLength(), h = new Ea(e).mul(o.blinder).umod(t.modulus), a = h.toRed(Ea.mont(t.prime1)), p = h.toRed(Ea.mont(t.prime2)), d = t.coefficient, b = t.prime1, g = t.prime2, w = a.redPow(t.exponent1).fromRed(), C = p.redPow(t.exponent2).fromRed(), T = w.isub(C).imul(d).umod(b).imul(g);
  return C.iadd(T).imul(o.unblinder).umod(t.modulus).toArrayLike(pe.Buffer, "be", r);
}
Yv.getr = Wv;
var sh = Yv, Co = {};
const x3 = "elliptic", _3 = "6.5.4", E3 = "EC cryptography", S3 = "lib/elliptic.js", w3 = [
  "lib"
], C3 = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, A3 = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, B3 = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], I3 = "Fedor Indutny <fedor@indutny.com>", T3 = "MIT", M3 = {
  url: "https://github.com/indutny/elliptic/issues"
}, R3 = "https://github.com/indutny/elliptic", N3 = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, D3 = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, O3 = {
  name: x3,
  version: _3,
  description: E3,
  main: S3,
  files: w3,
  scripts: C3,
  repository: A3,
  keywords: B3,
  author: I3,
  license: T3,
  bugs: M3,
  homepage: R3,
  devDependencies: N3,
  dependencies: D3
};
var Pr = {}, fh = {};
(function(e) {
  var t = e;
  function o(a, p) {
    if (Array.isArray(a))
      return a.slice();
    if (!a)
      return [];
    var d = [];
    if (typeof a != "string") {
      for (var b = 0; b < a.length; b++)
        d[b] = a[b] | 0;
      return d;
    }
    if (p === "hex") {
      a = a.replace(/[^a-z0-9]+/ig, ""), a.length % 2 !== 0 && (a = "0" + a);
      for (var b = 0; b < a.length; b += 2)
        d.push(parseInt(a[b] + a[b + 1], 16));
    } else
      for (var b = 0; b < a.length; b++) {
        var g = a.charCodeAt(b), w = g >> 8, C = g & 255;
        w ? d.push(w, C) : d.push(C);
      }
    return d;
  }
  t.toArray = o;
  function r(a) {
    return a.length === 1 ? "0" + a : a;
  }
  t.zero2 = r;
  function h(a) {
    for (var p = "", d = 0; d < a.length; d++)
      p += r(a[d].toString(16));
    return p;
  }
  t.toHex = h, t.encode = function(a, p) {
    return p === "hex" ? h(a) : a;
  };
})(fh);
(function(e) {
  var t = e, o = rr, r = Qr, h = fh;
  t.assert = r, t.toArray = h.toArray, t.zero2 = h.zero2, t.toHex = h.toHex, t.encode = h.encode;
  function a(w, C, T) {
    var k = new Array(Math.max(w.bitLength(), T) + 1);
    k.fill(0);
    for (var q = 1 << C + 1, O = w.clone(), N = 0; N < k.length; N++) {
      var j, U = O.andln(q - 1);
      O.isOdd() ? (U > (q >> 1) - 1 ? j = (q >> 1) - U : j = U, O.isubn(j)) : j = 0, k[N] = j, O.iushrn(1);
    }
    return k;
  }
  t.getNAF = a;
  function p(w, C) {
    var T = [
      [],
      []
    ];
    w = w.clone(), C = C.clone();
    for (var k = 0, q = 0, O; w.cmpn(-k) > 0 || C.cmpn(-q) > 0; ) {
      var N = w.andln(3) + k & 3, j = C.andln(3) + q & 3;
      N === 3 && (N = -1), j === 3 && (j = -1);
      var U;
      N & 1 ? (O = w.andln(7) + k & 7, (O === 3 || O === 5) && j === 2 ? U = -N : U = N) : U = 0, T[0].push(U);
      var H;
      j & 1 ? (O = C.andln(7) + q & 7, (O === 3 || O === 5) && N === 2 ? H = -j : H = j) : H = 0, T[1].push(H), 2 * k === U + 1 && (k = 1 - k), 2 * q === H + 1 && (q = 1 - q), w.iushrn(1), C.iushrn(1);
    }
    return T;
  }
  t.getJSF = p;
  function d(w, C, T) {
    var k = "_" + C;
    w.prototype[C] = function() {
      return this[k] !== void 0 ? this[k] : this[k] = T.call(this);
    };
  }
  t.cachedProperty = d;
  function b(w) {
    return typeof w == "string" ? t.toArray(w, "hex") : w;
  }
  t.parseBytes = b;
  function g(w) {
    return new o(w, "hex", "le");
  }
  t.intFromLE = g;
})(Pr);
var oh = {}, kn = rr, V0 = Pr, Rs = V0.getNAF, P3 = V0.getJSF, Ns = V0.assert;
function Rn(e, t) {
  this.type = e, this.p = new kn(t.p, 16), this.red = t.prime ? kn.red(t.prime) : kn.mont(this.p), this.zero = new kn(0).toRed(this.red), this.one = new kn(1).toRed(this.red), this.two = new kn(2).toRed(this.red), this.n = t.n && new kn(t.n, 16), this.g = t.g && this.pointFromJSON(t.g, t.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var o = this.n && this.p.div(this.n);
  !o || o.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var vf = Rn;
Rn.prototype.point = function() {
  throw new Error("Not implemented");
};
Rn.prototype.validate = function() {
  throw new Error("Not implemented");
};
Rn.prototype._fixedNafMul = function(e, t) {
  Ns(e.precomputed);
  var o = e._getDoubles(), r = Rs(t, 1, this._bitLength), h = (1 << o.step + 1) - (o.step % 2 === 0 ? 2 : 1);
  h /= 3;
  var a = [], p, d;
  for (p = 0; p < r.length; p += o.step) {
    d = 0;
    for (var b = p + o.step - 1; b >= p; b--)
      d = (d << 1) + r[b];
    a.push(d);
  }
  for (var g = this.jpoint(null, null, null), w = this.jpoint(null, null, null), C = h; C > 0; C--) {
    for (p = 0; p < a.length; p++)
      d = a[p], d === C ? w = w.mixedAdd(o.points[p]) : d === -C && (w = w.mixedAdd(o.points[p].neg()));
    g = g.add(w);
  }
  return g.toP();
};
Rn.prototype._wnafMul = function(e, t) {
  var o = 4, r = e._getNAFPoints(o);
  o = r.wnd;
  for (var h = r.points, a = Rs(t, o, this._bitLength), p = this.jpoint(null, null, null), d = a.length - 1; d >= 0; d--) {
    for (var b = 0; d >= 0 && a[d] === 0; d--)
      b++;
    if (d >= 0 && b++, p = p.dblp(b), d < 0)
      break;
    var g = a[d];
    Ns(g !== 0), e.type === "affine" ? g > 0 ? p = p.mixedAdd(h[g - 1 >> 1]) : p = p.mixedAdd(h[-g - 1 >> 1].neg()) : g > 0 ? p = p.add(h[g - 1 >> 1]) : p = p.add(h[-g - 1 >> 1].neg());
  }
  return e.type === "affine" ? p.toP() : p;
};
Rn.prototype._wnafMulAdd = function(e, t, o, r, h) {
  var a = this._wnafT1, p = this._wnafT2, d = this._wnafT3, b = 0, g, w, C;
  for (g = 0; g < r; g++) {
    C = t[g];
    var T = C._getNAFPoints(e);
    a[g] = T.wnd, p[g] = T.points;
  }
  for (g = r - 1; g >= 1; g -= 2) {
    var k = g - 1, q = g;
    if (a[k] !== 1 || a[q] !== 1) {
      d[k] = Rs(o[k], a[k], this._bitLength), d[q] = Rs(o[q], a[q], this._bitLength), b = Math.max(d[k].length, b), b = Math.max(d[q].length, b);
      continue;
    }
    var O = [
      t[k],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      t[q]
      /* 7 */
    ];
    t[k].y.cmp(t[q].y) === 0 ? (O[1] = t[k].add(t[q]), O[2] = t[k].toJ().mixedAdd(t[q].neg())) : t[k].y.cmp(t[q].y.redNeg()) === 0 ? (O[1] = t[k].toJ().mixedAdd(t[q]), O[2] = t[k].add(t[q].neg())) : (O[1] = t[k].toJ().mixedAdd(t[q]), O[2] = t[k].toJ().mixedAdd(t[q].neg()));
    var N = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], j = P3(o[k], o[q]);
    for (b = Math.max(j[0].length, b), d[k] = new Array(b), d[q] = new Array(b), w = 0; w < b; w++) {
      var U = j[0][w] | 0, H = j[1][w] | 0;
      d[k][w] = N[(U + 1) * 3 + (H + 1)], d[q][w] = 0, p[k] = O;
    }
  }
  var z = this.jpoint(null, null, null), ee = this._wnafT4;
  for (g = b; g >= 0; g--) {
    for (var ne = 0; g >= 0; ) {
      var le = !0;
      for (w = 0; w < r; w++)
        ee[w] = d[w][g] | 0, ee[w] !== 0 && (le = !1);
      if (!le)
        break;
      ne++, g--;
    }
    if (g >= 0 && ne++, z = z.dblp(ne), g < 0)
      break;
    for (w = 0; w < r; w++) {
      var Z = ee[w];
      Z !== 0 && (Z > 0 ? C = p[w][Z - 1 >> 1] : Z < 0 && (C = p[w][-Z - 1 >> 1].neg()), C.type === "affine" ? z = z.mixedAdd(C) : z = z.add(C));
    }
  }
  for (g = 0; g < r; g++)
    p[g] = null;
  return h ? z : z.toP();
};
function Jr(e, t) {
  this.curve = e, this.type = t, this.precomputed = null;
}
Rn.BasePoint = Jr;
Jr.prototype.eq = function() {
  throw new Error("Not implemented");
};
Jr.prototype.validate = function() {
  return this.curve.validate(this);
};
Rn.prototype.decodePoint = function(e, t) {
  e = V0.toArray(e, t);
  var o = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * o) {
    e[0] === 6 ? Ns(e[e.length - 1] % 2 === 0) : e[0] === 7 && Ns(e[e.length - 1] % 2 === 1);
    var r = this.point(
      e.slice(1, 1 + o),
      e.slice(1 + o, 1 + 2 * o)
    );
    return r;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === o)
    return this.pointFromX(e.slice(1, 1 + o), e[0] === 3);
  throw new Error("Unknown point format");
};
Jr.prototype.encodeCompressed = function(e) {
  return this.encode(e, !0);
};
Jr.prototype._encode = function(e) {
  var t = this.curve.p.byteLength(), o = this.getX().toArray("be", t);
  return e ? [this.getY().isEven() ? 2 : 3].concat(o) : [4].concat(o, this.getY().toArray("be", t));
};
Jr.prototype.encode = function(e, t) {
  return V0.encode(this._encode(t), e);
};
Jr.prototype.precompute = function(e) {
  if (this.precomputed)
    return this;
  var t = {
    doubles: null,
    naf: null,
    beta: null
  };
  return t.naf = this._getNAFPoints(8), t.doubles = this._getDoubles(4, e), t.beta = this._getBeta(), this.precomputed = t, this;
};
Jr.prototype._hasDoubles = function(e) {
  if (!this.precomputed)
    return !1;
  var t = this.precomputed.doubles;
  return t ? t.points.length >= Math.ceil((e.bitLength() + 1) / t.step) : !1;
};
Jr.prototype._getDoubles = function(e, t) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var o = [this], r = this, h = 0; h < t; h += e) {
    for (var a = 0; a < e; a++)
      r = r.dbl();
    o.push(r);
  }
  return {
    step: e,
    points: o
  };
};
Jr.prototype._getNAFPoints = function(e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var t = [this], o = (1 << e) - 1, r = o === 1 ? null : this.dbl(), h = 1; h < o; h++)
    t[h] = t[h - 1].add(r);
  return {
    wnd: e,
    points: t
  };
};
Jr.prototype._getBeta = function() {
  return null;
};
Jr.prototype.dblp = function(e) {
  for (var t = this, o = 0; o < e; o++)
    t = t.dbl();
  return t;
};
var L3 = Pr, Vt = rr, uh = ut, Va = vf, k3 = L3.assert;
function ei(e) {
  Va.call(this, "short", e), this.a = new Vt(e.a, 16).toRed(this.red), this.b = new Vt(e.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(e), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
uh(ei, Va);
var U3 = ei;
ei.prototype._getEndomorphism = function(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var t, o;
    if (e.beta)
      t = new Vt(e.beta, 16).toRed(this.red);
    else {
      var r = this._getEndoRoots(this.p);
      t = r[0].cmp(r[1]) < 0 ? r[0] : r[1], t = t.toRed(this.red);
    }
    if (e.lambda)
      o = new Vt(e.lambda, 16);
    else {
      var h = this._getEndoRoots(this.n);
      this.g.mul(h[0]).x.cmp(this.g.x.redMul(t)) === 0 ? o = h[0] : (o = h[1], k3(this.g.mul(o).x.cmp(this.g.x.redMul(t)) === 0));
    }
    var a;
    return e.basis ? a = e.basis.map(function(p) {
      return {
        a: new Vt(p.a, 16),
        b: new Vt(p.b, 16)
      };
    }) : a = this._getEndoBasis(o), {
      beta: t,
      lambda: o,
      basis: a
    };
  }
};
ei.prototype._getEndoRoots = function(e) {
  var t = e === this.p ? this.red : Vt.mont(e), o = new Vt(2).toRed(t).redInvm(), r = o.redNeg(), h = new Vt(3).toRed(t).redNeg().redSqrt().redMul(o), a = r.redAdd(h).fromRed(), p = r.redSub(h).fromRed();
  return [a, p];
};
ei.prototype._getEndoBasis = function(e) {
  for (var t = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), o = e, r = this.n.clone(), h = new Vt(1), a = new Vt(0), p = new Vt(0), d = new Vt(1), b, g, w, C, T, k, q, O = 0, N, j; o.cmpn(0) !== 0; ) {
    var U = r.div(o);
    N = r.sub(U.mul(o)), j = p.sub(U.mul(h));
    var H = d.sub(U.mul(a));
    if (!w && N.cmp(t) < 0)
      b = q.neg(), g = h, w = N.neg(), C = j;
    else if (w && ++O === 2)
      break;
    q = N, r = o, o = N, p = h, h = j, d = a, a = H;
  }
  T = N.neg(), k = j;
  var z = w.sqr().add(C.sqr()), ee = T.sqr().add(k.sqr());
  return ee.cmp(z) >= 0 && (T = b, k = g), w.negative && (w = w.neg(), C = C.neg()), T.negative && (T = T.neg(), k = k.neg()), [
    { a: w, b: C },
    { a: T, b: k }
  ];
};
ei.prototype._endoSplit = function(e) {
  var t = this.endo.basis, o = t[0], r = t[1], h = r.b.mul(e).divRound(this.n), a = o.b.neg().mul(e).divRound(this.n), p = h.mul(o.a), d = a.mul(r.a), b = h.mul(o.b), g = a.mul(r.b), w = e.sub(p).sub(d), C = b.add(g).neg();
  return { k1: w, k2: C };
};
ei.prototype.pointFromX = function(e, t) {
  e = new Vt(e, 16), e.red || (e = e.toRed(this.red));
  var o = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), r = o.redSqrt();
  if (r.redSqr().redSub(o).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var h = r.fromRed().isOdd();
  return (t && !h || !t && h) && (r = r.redNeg()), this.point(e, r);
};
ei.prototype.validate = function(e) {
  if (e.inf)
    return !0;
  var t = e.x, o = e.y, r = this.a.redMul(t), h = t.redSqr().redMul(t).redIAdd(r).redIAdd(this.b);
  return o.redSqr().redISub(h).cmpn(0) === 0;
};
ei.prototype._endoWnafMulAdd = function(e, t, o) {
  for (var r = this._endoWnafT1, h = this._endoWnafT2, a = 0; a < e.length; a++) {
    var p = this._endoSplit(t[a]), d = e[a], b = d._getBeta();
    p.k1.negative && (p.k1.ineg(), d = d.neg(!0)), p.k2.negative && (p.k2.ineg(), b = b.neg(!0)), r[a * 2] = d, r[a * 2 + 1] = b, h[a * 2] = p.k1, h[a * 2 + 1] = p.k2;
  }
  for (var g = this._wnafMulAdd(1, r, h, a * 2, o), w = 0; w < a * 2; w++)
    r[w] = null, h[w] = null;
  return g;
};
function ir(e, t, o, r) {
  Va.BasePoint.call(this, e, "affine"), t === null && o === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new Vt(t, 16), this.y = new Vt(o, 16), r && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
uh(ir, Va.BasePoint);
ei.prototype.point = function(e, t, o) {
  return new ir(this, e, t, o);
};
ei.prototype.pointFromJSON = function(e, t) {
  return ir.fromJSON(this, e, t);
};
ir.prototype._getBeta = function() {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta)
      return e.beta;
    var t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var o = this.curve, r = function(h) {
        return o.point(h.x.redMul(o.endo.beta), h.y);
      };
      e.beta = t, t.precomputed = {
        beta: null,
        naf: e.naf && {
          wnd: e.naf.wnd,
          points: e.naf.points.map(r)
        },
        doubles: e.doubles && {
          step: e.doubles.step,
          points: e.doubles.points.map(r)
        }
      };
    }
    return t;
  }
};
ir.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
ir.fromJSON = function(e, t, o) {
  typeof t == "string" && (t = JSON.parse(t));
  var r = e.point(t[0], t[1], o);
  if (!t[2])
    return r;
  function h(p) {
    return e.point(p[0], p[1], o);
  }
  var a = t[2];
  return r.precomputed = {
    beta: null,
    doubles: a.doubles && {
      step: a.doubles.step,
      points: [r].concat(a.doubles.points.map(h))
    },
    naf: a.naf && {
      wnd: a.naf.wnd,
      points: [r].concat(a.naf.points.map(h))
    }
  }, r;
};
ir.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
ir.prototype.isInfinity = function() {
  return this.inf;
};
ir.prototype.add = function(e) {
  if (this.inf)
    return e;
  if (e.inf)
    return this;
  if (this.eq(e))
    return this.dbl();
  if (this.neg().eq(e))
    return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0)
    return this.curve.point(null, null);
  var t = this.y.redSub(e.y);
  t.cmpn(0) !== 0 && (t = t.redMul(this.x.redSub(e.x).redInvm()));
  var o = t.redSqr().redISub(this.x).redISub(e.x), r = t.redMul(this.x.redSub(o)).redISub(this.y);
  return this.curve.point(o, r);
};
ir.prototype.dbl = function() {
  if (this.inf)
    return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var t = this.curve.a, o = this.x.redSqr(), r = e.redInvm(), h = o.redAdd(o).redIAdd(o).redIAdd(t).redMul(r), a = h.redSqr().redISub(this.x.redAdd(this.x)), p = h.redMul(this.x.redSub(a)).redISub(this.y);
  return this.curve.point(a, p);
};
ir.prototype.getX = function() {
  return this.x.fromRed();
};
ir.prototype.getY = function() {
  return this.y.fromRed();
};
ir.prototype.mul = function(e) {
  return e = new Vt(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
ir.prototype.mulAdd = function(e, t, o) {
  var r = [this, t], h = [e, o];
  return this.curve.endo ? this.curve._endoWnafMulAdd(r, h) : this.curve._wnafMulAdd(1, r, h, 2);
};
ir.prototype.jmulAdd = function(e, t, o) {
  var r = [this, t], h = [e, o];
  return this.curve.endo ? this.curve._endoWnafMulAdd(r, h, !0) : this.curve._wnafMulAdd(1, r, h, 2, !0);
};
ir.prototype.eq = function(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
ir.prototype.neg = function(e) {
  if (this.inf)
    return this;
  var t = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var o = this.precomputed, r = function(h) {
      return h.neg();
    };
    t.precomputed = {
      naf: o.naf && {
        wnd: o.naf.wnd,
        points: o.naf.points.map(r)
      },
      doubles: o.doubles && {
        step: o.doubles.step,
        points: o.doubles.points.map(r)
      }
    };
  }
  return t;
};
ir.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function fr(e, t, o, r) {
  Va.BasePoint.call(this, e, "jacobian"), t === null && o === null && r === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new Vt(0)) : (this.x = new Vt(t, 16), this.y = new Vt(o, 16), this.z = new Vt(r, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
uh(fr, Va.BasePoint);
ei.prototype.jpoint = function(e, t, o) {
  return new fr(this, e, t, o);
};
fr.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var e = this.z.redInvm(), t = e.redSqr(), o = this.x.redMul(t), r = this.y.redMul(t).redMul(e);
  return this.curve.point(o, r);
};
fr.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
fr.prototype.add = function(e) {
  if (this.isInfinity())
    return e;
  if (e.isInfinity())
    return this;
  var t = e.z.redSqr(), o = this.z.redSqr(), r = this.x.redMul(t), h = e.x.redMul(o), a = this.y.redMul(t.redMul(e.z)), p = e.y.redMul(o.redMul(this.z)), d = r.redSub(h), b = a.redSub(p);
  if (d.cmpn(0) === 0)
    return b.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var g = d.redSqr(), w = g.redMul(d), C = r.redMul(g), T = b.redSqr().redIAdd(w).redISub(C).redISub(C), k = b.redMul(C.redISub(T)).redISub(a.redMul(w)), q = this.z.redMul(e.z).redMul(d);
  return this.curve.jpoint(T, k, q);
};
fr.prototype.mixedAdd = function(e) {
  if (this.isInfinity())
    return e.toJ();
  if (e.isInfinity())
    return this;
  var t = this.z.redSqr(), o = this.x, r = e.x.redMul(t), h = this.y, a = e.y.redMul(t).redMul(this.z), p = o.redSub(r), d = h.redSub(a);
  if (p.cmpn(0) === 0)
    return d.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var b = p.redSqr(), g = b.redMul(p), w = o.redMul(b), C = d.redSqr().redIAdd(g).redISub(w).redISub(w), T = d.redMul(w.redISub(C)).redISub(h.redMul(g)), k = this.z.redMul(p);
  return this.curve.jpoint(C, T, k);
};
fr.prototype.dblp = function(e) {
  if (e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!e)
    return this.dbl();
  var t;
  if (this.curve.zeroA || this.curve.threeA) {
    var o = this;
    for (t = 0; t < e; t++)
      o = o.dbl();
    return o;
  }
  var r = this.curve.a, h = this.curve.tinv, a = this.x, p = this.y, d = this.z, b = d.redSqr().redSqr(), g = p.redAdd(p);
  for (t = 0; t < e; t++) {
    var w = a.redSqr(), C = g.redSqr(), T = C.redSqr(), k = w.redAdd(w).redIAdd(w).redIAdd(r.redMul(b)), q = a.redMul(C), O = k.redSqr().redISub(q.redAdd(q)), N = q.redISub(O), j = k.redMul(N);
    j = j.redIAdd(j).redISub(T);
    var U = g.redMul(d);
    t + 1 < e && (b = b.redMul(T)), a = O, d = U, g = j;
  }
  return this.curve.jpoint(a, g.redMul(h), d);
};
fr.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
fr.prototype._zeroDbl = function() {
  var e, t, o;
  if (this.zOne) {
    var r = this.x.redSqr(), h = this.y.redSqr(), a = h.redSqr(), p = this.x.redAdd(h).redSqr().redISub(r).redISub(a);
    p = p.redIAdd(p);
    var d = r.redAdd(r).redIAdd(r), b = d.redSqr().redISub(p).redISub(p), g = a.redIAdd(a);
    g = g.redIAdd(g), g = g.redIAdd(g), e = b, t = d.redMul(p.redISub(b)).redISub(g), o = this.y.redAdd(this.y);
  } else {
    var w = this.x.redSqr(), C = this.y.redSqr(), T = C.redSqr(), k = this.x.redAdd(C).redSqr().redISub(w).redISub(T);
    k = k.redIAdd(k);
    var q = w.redAdd(w).redIAdd(w), O = q.redSqr(), N = T.redIAdd(T);
    N = N.redIAdd(N), N = N.redIAdd(N), e = O.redISub(k).redISub(k), t = q.redMul(k.redISub(e)).redISub(N), o = this.y.redMul(this.z), o = o.redIAdd(o);
  }
  return this.curve.jpoint(e, t, o);
};
fr.prototype._threeDbl = function() {
  var e, t, o;
  if (this.zOne) {
    var r = this.x.redSqr(), h = this.y.redSqr(), a = h.redSqr(), p = this.x.redAdd(h).redSqr().redISub(r).redISub(a);
    p = p.redIAdd(p);
    var d = r.redAdd(r).redIAdd(r).redIAdd(this.curve.a), b = d.redSqr().redISub(p).redISub(p);
    e = b;
    var g = a.redIAdd(a);
    g = g.redIAdd(g), g = g.redIAdd(g), t = d.redMul(p.redISub(b)).redISub(g), o = this.y.redAdd(this.y);
  } else {
    var w = this.z.redSqr(), C = this.y.redSqr(), T = this.x.redMul(C), k = this.x.redSub(w).redMul(this.x.redAdd(w));
    k = k.redAdd(k).redIAdd(k);
    var q = T.redIAdd(T);
    q = q.redIAdd(q);
    var O = q.redAdd(q);
    e = k.redSqr().redISub(O), o = this.y.redAdd(this.z).redSqr().redISub(C).redISub(w);
    var N = C.redSqr();
    N = N.redIAdd(N), N = N.redIAdd(N), N = N.redIAdd(N), t = k.redMul(q.redISub(e)).redISub(N);
  }
  return this.curve.jpoint(e, t, o);
};
fr.prototype._dbl = function() {
  var e = this.curve.a, t = this.x, o = this.y, r = this.z, h = r.redSqr().redSqr(), a = t.redSqr(), p = o.redSqr(), d = a.redAdd(a).redIAdd(a).redIAdd(e.redMul(h)), b = t.redAdd(t);
  b = b.redIAdd(b);
  var g = b.redMul(p), w = d.redSqr().redISub(g.redAdd(g)), C = g.redISub(w), T = p.redSqr();
  T = T.redIAdd(T), T = T.redIAdd(T), T = T.redIAdd(T);
  var k = d.redMul(C).redISub(T), q = o.redAdd(o).redMul(r);
  return this.curve.jpoint(w, k, q);
};
fr.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var e = this.x.redSqr(), t = this.y.redSqr(), o = this.z.redSqr(), r = t.redSqr(), h = e.redAdd(e).redIAdd(e), a = h.redSqr(), p = this.x.redAdd(t).redSqr().redISub(e).redISub(r);
  p = p.redIAdd(p), p = p.redAdd(p).redIAdd(p), p = p.redISub(a);
  var d = p.redSqr(), b = r.redIAdd(r);
  b = b.redIAdd(b), b = b.redIAdd(b), b = b.redIAdd(b);
  var g = h.redIAdd(p).redSqr().redISub(a).redISub(d).redISub(b), w = t.redMul(g);
  w = w.redIAdd(w), w = w.redIAdd(w);
  var C = this.x.redMul(d).redISub(w);
  C = C.redIAdd(C), C = C.redIAdd(C);
  var T = this.y.redMul(g.redMul(b.redISub(g)).redISub(p.redMul(d)));
  T = T.redIAdd(T), T = T.redIAdd(T), T = T.redIAdd(T);
  var k = this.z.redAdd(p).redSqr().redISub(o).redISub(d);
  return this.curve.jpoint(C, T, k);
};
fr.prototype.mul = function(e, t) {
  return e = new Vt(e, t), this.curve._wnafMul(this, e);
};
fr.prototype.eq = function(e) {
  if (e.type === "affine")
    return this.eq(e.toJ());
  if (this === e)
    return !0;
  var t = this.z.redSqr(), o = e.z.redSqr();
  if (this.x.redMul(o).redISub(e.x.redMul(t)).cmpn(0) !== 0)
    return !1;
  var r = t.redMul(this.z), h = o.redMul(e.z);
  return this.y.redMul(h).redISub(e.y.redMul(r)).cmpn(0) === 0;
};
fr.prototype.eqXToP = function(e) {
  var t = this.z.redSqr(), o = e.toRed(this.curve.red).redMul(t);
  if (this.x.cmp(o) === 0)
    return !0;
  for (var r = e.clone(), h = this.curve.redN.redMul(t); ; ) {
    if (r.iadd(this.curve.n), r.cmp(this.curve.p) >= 0)
      return !1;
    if (o.redIAdd(h), this.x.cmp(o) === 0)
      return !0;
  }
};
fr.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
fr.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var ya = rr, Xv = ut, yf = vf, F3 = Pr;
function Ka(e) {
  yf.call(this, "mont", e), this.a = new ya(e.a, 16).toRed(this.red), this.b = new ya(e.b, 16).toRed(this.red), this.i4 = new ya(4).toRed(this.red).redInvm(), this.two = new ya(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
Xv(Ka, yf);
var q3 = Ka;
Ka.prototype.validate = function(e) {
  var t = e.normalize().x, o = t.redSqr(), r = o.redMul(t).redAdd(o.redMul(this.a)).redAdd(t), h = r.redSqrt();
  return h.redSqr().cmp(r) === 0;
};
function er(e, t, o) {
  yf.BasePoint.call(this, e, "projective"), t === null && o === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new ya(t, 16), this.z = new ya(o, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
Xv(er, yf.BasePoint);
Ka.prototype.decodePoint = function(e, t) {
  return this.point(F3.toArray(e, t), 1);
};
Ka.prototype.point = function(e, t) {
  return new er(this, e, t);
};
Ka.prototype.pointFromJSON = function(e) {
  return er.fromJSON(this, e);
};
er.prototype.precompute = function() {
};
er.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
er.fromJSON = function(e, t) {
  return new er(e, t[0], t[1] || e.one);
};
er.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
er.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
er.prototype.dbl = function() {
  var e = this.x.redAdd(this.z), t = e.redSqr(), o = this.x.redSub(this.z), r = o.redSqr(), h = t.redSub(r), a = t.redMul(r), p = h.redMul(r.redAdd(this.curve.a24.redMul(h)));
  return this.curve.point(a, p);
};
er.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
};
er.prototype.diffAdd = function(e, t) {
  var o = this.x.redAdd(this.z), r = this.x.redSub(this.z), h = e.x.redAdd(e.z), a = e.x.redSub(e.z), p = a.redMul(o), d = h.redMul(r), b = t.z.redMul(p.redAdd(d).redSqr()), g = t.x.redMul(p.redISub(d).redSqr());
  return this.curve.point(b, g);
};
er.prototype.mul = function(e) {
  for (var t = e.clone(), o = this, r = this.curve.point(null, null), h = this, a = []; t.cmpn(0) !== 0; t.iushrn(1))
    a.push(t.andln(1));
  for (var p = a.length - 1; p >= 0; p--)
    a[p] === 0 ? (o = o.diffAdd(r, h), r = r.dbl()) : (r = o.diffAdd(r, h), o = o.dbl());
  return r;
};
er.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
er.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
er.prototype.eq = function(e) {
  return this.getX().cmp(e.getX()) === 0;
};
er.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
er.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var V3 = Pr, tn = rr, Qv = ut, gf = vf, K3 = V3.assert;
function ji(e) {
  this.twisted = (e.a | 0) !== 1, this.mOneA = this.twisted && (e.a | 0) === -1, this.extended = this.mOneA, gf.call(this, "edwards", e), this.a = new tn(e.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new tn(e.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new tn(e.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), K3(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (e.c | 0) === 1;
}
Qv(ji, gf);
var $3 = ji;
ji.prototype._mulA = function(e) {
  return this.mOneA ? e.redNeg() : this.a.redMul(e);
};
ji.prototype._mulC = function(e) {
  return this.oneC ? e : this.c.redMul(e);
};
ji.prototype.jpoint = function(e, t, o, r) {
  return this.point(e, t, o, r);
};
ji.prototype.pointFromX = function(e, t) {
  e = new tn(e, 16), e.red || (e = e.toRed(this.red));
  var o = e.redSqr(), r = this.c2.redSub(this.a.redMul(o)), h = this.one.redSub(this.c2.redMul(this.d).redMul(o)), a = r.redMul(h.redInvm()), p = a.redSqrt();
  if (p.redSqr().redSub(a).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var d = p.fromRed().isOdd();
  return (t && !d || !t && d) && (p = p.redNeg()), this.point(e, p);
};
ji.prototype.pointFromY = function(e, t) {
  e = new tn(e, 16), e.red || (e = e.toRed(this.red));
  var o = e.redSqr(), r = o.redSub(this.c2), h = o.redMul(this.d).redMul(this.c2).redSub(this.a), a = r.redMul(h.redInvm());
  if (a.cmp(this.zero) === 0) {
    if (t)
      throw new Error("invalid point");
    return this.point(this.zero, e);
  }
  var p = a.redSqrt();
  if (p.redSqr().redSub(a).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return p.fromRed().isOdd() !== t && (p = p.redNeg()), this.point(p, e);
};
ji.prototype.validate = function(e) {
  if (e.isInfinity())
    return !0;
  e.normalize();
  var t = e.x.redSqr(), o = e.y.redSqr(), r = t.redMul(this.a).redAdd(o), h = this.c2.redMul(this.one.redAdd(this.d.redMul(t).redMul(o)));
  return r.cmp(h) === 0;
};
function kt(e, t, o, r, h) {
  gf.BasePoint.call(this, e, "projective"), t === null && o === null && r === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new tn(t, 16), this.y = new tn(o, 16), this.z = r ? new tn(r, 16) : this.curve.one, this.t = h && new tn(h, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
Qv(kt, gf.BasePoint);
ji.prototype.pointFromJSON = function(e) {
  return kt.fromJSON(this, e);
};
ji.prototype.point = function(e, t, o, r) {
  return new kt(this, e, t, o, r);
};
kt.fromJSON = function(e, t) {
  return new kt(e, t[0], t[1], t[2]);
};
kt.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
kt.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
kt.prototype._extDbl = function() {
  var e = this.x.redSqr(), t = this.y.redSqr(), o = this.z.redSqr();
  o = o.redIAdd(o);
  var r = this.curve._mulA(e), h = this.x.redAdd(this.y).redSqr().redISub(e).redISub(t), a = r.redAdd(t), p = a.redSub(o), d = r.redSub(t), b = h.redMul(p), g = a.redMul(d), w = h.redMul(d), C = p.redMul(a);
  return this.curve.point(b, g, C, w);
};
kt.prototype._projDbl = function() {
  var e = this.x.redAdd(this.y).redSqr(), t = this.x.redSqr(), o = this.y.redSqr(), r, h, a, p, d, b;
  if (this.curve.twisted) {
    p = this.curve._mulA(t);
    var g = p.redAdd(o);
    this.zOne ? (r = e.redSub(t).redSub(o).redMul(g.redSub(this.curve.two)), h = g.redMul(p.redSub(o)), a = g.redSqr().redSub(g).redSub(g)) : (d = this.z.redSqr(), b = g.redSub(d).redISub(d), r = e.redSub(t).redISub(o).redMul(b), h = g.redMul(p.redSub(o)), a = g.redMul(b));
  } else
    p = t.redAdd(o), d = this.curve._mulC(this.z).redSqr(), b = p.redSub(d).redSub(d), r = this.curve._mulC(e.redISub(p)).redMul(b), h = this.curve._mulC(p).redMul(t.redISub(o)), a = p.redMul(b);
  return this.curve.point(r, h, a);
};
kt.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
kt.prototype._extAdd = function(e) {
  var t = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), o = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), r = this.t.redMul(this.curve.dd).redMul(e.t), h = this.z.redMul(e.z.redAdd(e.z)), a = o.redSub(t), p = h.redSub(r), d = h.redAdd(r), b = o.redAdd(t), g = a.redMul(p), w = d.redMul(b), C = a.redMul(b), T = p.redMul(d);
  return this.curve.point(g, w, T, C);
};
kt.prototype._projAdd = function(e) {
  var t = this.z.redMul(e.z), o = t.redSqr(), r = this.x.redMul(e.x), h = this.y.redMul(e.y), a = this.curve.d.redMul(r).redMul(h), p = o.redSub(a), d = o.redAdd(a), b = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(r).redISub(h), g = t.redMul(p).redMul(b), w, C;
  return this.curve.twisted ? (w = t.redMul(d).redMul(h.redSub(this.curve._mulA(r))), C = p.redMul(d)) : (w = t.redMul(d).redMul(h.redSub(r)), C = this.curve._mulC(p).redMul(d)), this.curve.point(g, w, C);
};
kt.prototype.add = function(e) {
  return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
};
kt.prototype.mul = function(e) {
  return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
};
kt.prototype.mulAdd = function(e, t, o) {
  return this.curve._wnafMulAdd(1, [this, t], [e, o], 2, !1);
};
kt.prototype.jmulAdd = function(e, t, o) {
  return this.curve._wnafMulAdd(1, [this, t], [e, o], 2, !0);
};
kt.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var e = this.z.redInvm();
  return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = !0, this;
};
kt.prototype.neg = function() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
kt.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
kt.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
};
kt.prototype.eq = function(e) {
  return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
};
kt.prototype.eqXToP = function(e) {
  var t = e.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(t) === 0)
    return !0;
  for (var o = e.clone(), r = this.curve.redN.redMul(this.z); ; ) {
    if (o.iadd(this.curve.n), o.cmp(this.curve.p) >= 0)
      return !1;
    if (t.redIAdd(r), this.x.cmp(t) === 0)
      return !0;
  }
};
kt.prototype.toP = kt.prototype.normalize;
kt.prototype.mixedAdd = kt.prototype.add;
(function(e) {
  var t = e;
  t.base = vf, t.short = U3, t.mont = q3, t.edwards = $3;
})(oh);
var mf = {}, bf = {}, gt = {}, H3 = Qr, G3 = ut;
gt.inherits = G3;
function z3(e, t) {
  return (e.charCodeAt(t) & 64512) !== 55296 || t < 0 || t + 1 >= e.length ? !1 : (e.charCodeAt(t + 1) & 64512) === 56320;
}
function j3(e, t) {
  if (Array.isArray(e))
    return e.slice();
  if (!e)
    return [];
  var o = [];
  if (typeof e == "string")
    if (t) {
      if (t === "hex")
        for (e = e.replace(/[^a-z0-9]+/ig, ""), e.length % 2 !== 0 && (e = "0" + e), h = 0; h < e.length; h += 2)
          o.push(parseInt(e[h] + e[h + 1], 16));
    } else
      for (var r = 0, h = 0; h < e.length; h++) {
        var a = e.charCodeAt(h);
        a < 128 ? o[r++] = a : a < 2048 ? (o[r++] = a >> 6 | 192, o[r++] = a & 63 | 128) : z3(e, h) ? (a = 65536 + ((a & 1023) << 10) + (e.charCodeAt(++h) & 1023), o[r++] = a >> 18 | 240, o[r++] = a >> 12 & 63 | 128, o[r++] = a >> 6 & 63 | 128, o[r++] = a & 63 | 128) : (o[r++] = a >> 12 | 224, o[r++] = a >> 6 & 63 | 128, o[r++] = a & 63 | 128);
      }
  else
    for (h = 0; h < e.length; h++)
      o[h] = e[h] | 0;
  return o;
}
gt.toArray = j3;
function W3(e) {
  for (var t = "", o = 0; o < e.length; o++)
    t += Jv(e[o].toString(16));
  return t;
}
gt.toHex = W3;
function Zv(e) {
  var t = e >>> 24 | e >>> 8 & 65280 | e << 8 & 16711680 | (e & 255) << 24;
  return t >>> 0;
}
gt.htonl = Zv;
function Y3(e, t) {
  for (var o = "", r = 0; r < e.length; r++) {
    var h = e[r];
    t === "little" && (h = Zv(h)), o += ey(h.toString(16));
  }
  return o;
}
gt.toHex32 = Y3;
function Jv(e) {
  return e.length === 1 ? "0" + e : e;
}
gt.zero2 = Jv;
function ey(e) {
  return e.length === 7 ? "0" + e : e.length === 6 ? "00" + e : e.length === 5 ? "000" + e : e.length === 4 ? "0000" + e : e.length === 3 ? "00000" + e : e.length === 2 ? "000000" + e : e.length === 1 ? "0000000" + e : e;
}
gt.zero8 = ey;
function X3(e, t, o, r) {
  var h = o - t;
  H3(h % 4 === 0);
  for (var a = new Array(h / 4), p = 0, d = t; p < a.length; p++, d += 4) {
    var b;
    r === "big" ? b = e[d] << 24 | e[d + 1] << 16 | e[d + 2] << 8 | e[d + 3] : b = e[d + 3] << 24 | e[d + 2] << 16 | e[d + 1] << 8 | e[d], a[p] = b >>> 0;
  }
  return a;
}
gt.join32 = X3;
function Q3(e, t) {
  for (var o = new Array(e.length * 4), r = 0, h = 0; r < e.length; r++, h += 4) {
    var a = e[r];
    t === "big" ? (o[h] = a >>> 24, o[h + 1] = a >>> 16 & 255, o[h + 2] = a >>> 8 & 255, o[h + 3] = a & 255) : (o[h + 3] = a >>> 24, o[h + 2] = a >>> 16 & 255, o[h + 1] = a >>> 8 & 255, o[h] = a & 255);
  }
  return o;
}
gt.split32 = Q3;
function Z3(e, t) {
  return e >>> t | e << 32 - t;
}
gt.rotr32 = Z3;
function J3(e, t) {
  return e << t | e >>> 32 - t;
}
gt.rotl32 = J3;
function e6(e, t) {
  return e + t >>> 0;
}
gt.sum32 = e6;
function t6(e, t, o) {
  return e + t + o >>> 0;
}
gt.sum32_3 = t6;
function r6(e, t, o, r) {
  return e + t + o + r >>> 0;
}
gt.sum32_4 = r6;
function i6(e, t, o, r, h) {
  return e + t + o + r + h >>> 0;
}
gt.sum32_5 = i6;
function n6(e, t, o, r) {
  var h = e[t], a = e[t + 1], p = r + a >>> 0, d = (p < r ? 1 : 0) + o + h;
  e[t] = d >>> 0, e[t + 1] = p;
}
gt.sum64 = n6;
function a6(e, t, o, r) {
  var h = t + r >>> 0, a = (h < t ? 1 : 0) + e + o;
  return a >>> 0;
}
gt.sum64_hi = a6;
function s6(e, t, o, r) {
  var h = t + r;
  return h >>> 0;
}
gt.sum64_lo = s6;
function f6(e, t, o, r, h, a, p, d) {
  var b = 0, g = t;
  g = g + r >>> 0, b += g < t ? 1 : 0, g = g + a >>> 0, b += g < a ? 1 : 0, g = g + d >>> 0, b += g < d ? 1 : 0;
  var w = e + o + h + p + b;
  return w >>> 0;
}
gt.sum64_4_hi = f6;
function o6(e, t, o, r, h, a, p, d) {
  var b = t + r + a + d;
  return b >>> 0;
}
gt.sum64_4_lo = o6;
function u6(e, t, o, r, h, a, p, d, b, g) {
  var w = 0, C = t;
  C = C + r >>> 0, w += C < t ? 1 : 0, C = C + a >>> 0, w += C < a ? 1 : 0, C = C + d >>> 0, w += C < d ? 1 : 0, C = C + g >>> 0, w += C < g ? 1 : 0;
  var T = e + o + h + p + b + w;
  return T >>> 0;
}
gt.sum64_5_hi = u6;
function c6(e, t, o, r, h, a, p, d, b, g) {
  var w = t + r + a + d + g;
  return w >>> 0;
}
gt.sum64_5_lo = c6;
function h6(e, t, o) {
  var r = t << 32 - o | e >>> o;
  return r >>> 0;
}
gt.rotr64_hi = h6;
function l6(e, t, o) {
  var r = e << 32 - o | t >>> o;
  return r >>> 0;
}
gt.rotr64_lo = l6;
function d6(e, t, o) {
  return e >>> o;
}
gt.shr64_hi = d6;
function p6(e, t, o) {
  var r = e << 32 - o | t >>> o;
  return r >>> 0;
}
gt.shr64_lo = p6;
var $a = {}, jl = gt, v6 = Qr;
function xf() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
$a.BlockHash = xf;
xf.prototype.update = function(e, t) {
  if (e = jl.toArray(e, t), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
    e = this.pending;
    var o = e.length % this._delta8;
    this.pending = e.slice(e.length - o, e.length), this.pending.length === 0 && (this.pending = null), e = jl.join32(e, 0, e.length - o, this.endian);
    for (var r = 0; r < e.length; r += this._delta32)
      this._update(e, r, r + this._delta32);
  }
  return this;
};
xf.prototype.digest = function(e) {
  return this.update(this._pad()), v6(this.pending === null), this._digest(e);
};
xf.prototype._pad = function() {
  var e = this.pendingTotal, t = this._delta8, o = t - (e + this.padLength) % t, r = new Array(o + this.padLength);
  r[0] = 128;
  for (var h = 1; h < o; h++)
    r[h] = 0;
  if (e <<= 3, this.endian === "big") {
    for (var a = 8; a < this.padLength; a++)
      r[h++] = 0;
    r[h++] = 0, r[h++] = 0, r[h++] = 0, r[h++] = 0, r[h++] = e >>> 24 & 255, r[h++] = e >>> 16 & 255, r[h++] = e >>> 8 & 255, r[h++] = e & 255;
  } else
    for (r[h++] = e & 255, r[h++] = e >>> 8 & 255, r[h++] = e >>> 16 & 255, r[h++] = e >>> 24 & 255, r[h++] = 0, r[h++] = 0, r[h++] = 0, r[h++] = 0, a = 8; a < this.padLength; a++)
      r[h++] = 0;
  return r;
};
var Ha = {}, Wi = {}, y6 = gt, qi = y6.rotr32;
function g6(e, t, o, r) {
  if (e === 0)
    return ty(t, o, r);
  if (e === 1 || e === 3)
    return iy(t, o, r);
  if (e === 2)
    return ry(t, o, r);
}
Wi.ft_1 = g6;
function ty(e, t, o) {
  return e & t ^ ~e & o;
}
Wi.ch32 = ty;
function ry(e, t, o) {
  return e & t ^ e & o ^ t & o;
}
Wi.maj32 = ry;
function iy(e, t, o) {
  return e ^ t ^ o;
}
Wi.p32 = iy;
function m6(e) {
  return qi(e, 2) ^ qi(e, 13) ^ qi(e, 22);
}
Wi.s0_256 = m6;
function b6(e) {
  return qi(e, 6) ^ qi(e, 11) ^ qi(e, 25);
}
Wi.s1_256 = b6;
function x6(e) {
  return qi(e, 7) ^ qi(e, 18) ^ e >>> 3;
}
Wi.g0_256 = x6;
function _6(e) {
  return qi(e, 17) ^ qi(e, 19) ^ e >>> 10;
}
Wi.g1_256 = _6;
var Ba = gt, E6 = $a, S6 = Wi, Ao = Ba.rotl32, c0 = Ba.sum32, w6 = Ba.sum32_5, C6 = S6.ft_1, ny = E6.BlockHash, A6 = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function Hi() {
  if (!(this instanceof Hi))
    return new Hi();
  ny.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
Ba.inherits(Hi, ny);
var B6 = Hi;
Hi.blockSize = 512;
Hi.outSize = 160;
Hi.hmacStrength = 80;
Hi.padLength = 64;
Hi.prototype._update = function(e, t) {
  for (var o = this.W, r = 0; r < 16; r++)
    o[r] = e[t + r];
  for (; r < o.length; r++)
    o[r] = Ao(o[r - 3] ^ o[r - 8] ^ o[r - 14] ^ o[r - 16], 1);
  var h = this.h[0], a = this.h[1], p = this.h[2], d = this.h[3], b = this.h[4];
  for (r = 0; r < o.length; r++) {
    var g = ~~(r / 20), w = w6(Ao(h, 5), C6(g, a, p, d), b, o[r], A6[g]);
    b = d, d = p, p = Ao(a, 30), a = h, h = w;
  }
  this.h[0] = c0(this.h[0], h), this.h[1] = c0(this.h[1], a), this.h[2] = c0(this.h[2], p), this.h[3] = c0(this.h[3], d), this.h[4] = c0(this.h[4], b);
};
Hi.prototype._digest = function(e) {
  return e === "hex" ? Ba.toHex32(this.h, "big") : Ba.split32(this.h, "big");
};
var Ia = gt, I6 = $a, Ga = Wi, T6 = Qr, bi = Ia.sum32, M6 = Ia.sum32_4, R6 = Ia.sum32_5, N6 = Ga.ch32, D6 = Ga.maj32, O6 = Ga.s0_256, P6 = Ga.s1_256, L6 = Ga.g0_256, k6 = Ga.g1_256, ay = I6.BlockHash, U6 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function Gi() {
  if (!(this instanceof Gi))
    return new Gi();
  ay.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = U6, this.W = new Array(64);
}
Ia.inherits(Gi, ay);
var sy = Gi;
Gi.blockSize = 512;
Gi.outSize = 256;
Gi.hmacStrength = 192;
Gi.padLength = 64;
Gi.prototype._update = function(e, t) {
  for (var o = this.W, r = 0; r < 16; r++)
    o[r] = e[t + r];
  for (; r < o.length; r++)
    o[r] = M6(k6(o[r - 2]), o[r - 7], L6(o[r - 15]), o[r - 16]);
  var h = this.h[0], a = this.h[1], p = this.h[2], d = this.h[3], b = this.h[4], g = this.h[5], w = this.h[6], C = this.h[7];
  for (T6(this.k.length === o.length), r = 0; r < o.length; r++) {
    var T = R6(C, P6(b), N6(b, g, w), this.k[r], o[r]), k = bi(O6(h), D6(h, a, p));
    C = w, w = g, g = b, b = bi(d, T), d = p, p = a, a = h, h = bi(T, k);
  }
  this.h[0] = bi(this.h[0], h), this.h[1] = bi(this.h[1], a), this.h[2] = bi(this.h[2], p), this.h[3] = bi(this.h[3], d), this.h[4] = bi(this.h[4], b), this.h[5] = bi(this.h[5], g), this.h[6] = bi(this.h[6], w), this.h[7] = bi(this.h[7], C);
};
Gi.prototype._digest = function(e) {
  return e === "hex" ? Ia.toHex32(this.h, "big") : Ia.split32(this.h, "big");
};
var oc = gt, fy = sy;
function on() {
  if (!(this instanceof on))
    return new on();
  fy.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
oc.inherits(on, fy);
var F6 = on;
on.blockSize = 512;
on.outSize = 224;
on.hmacStrength = 192;
on.padLength = 64;
on.prototype._digest = function(e) {
  return e === "hex" ? oc.toHex32(this.h.slice(0, 7), "big") : oc.split32(this.h.slice(0, 7), "big");
};
var Br = gt, q6 = $a, V6 = Qr, Vi = Br.rotr64_hi, Ki = Br.rotr64_lo, oy = Br.shr64_hi, uy = Br.shr64_lo, hn = Br.sum64, Bo = Br.sum64_hi, Io = Br.sum64_lo, K6 = Br.sum64_4_hi, $6 = Br.sum64_4_lo, H6 = Br.sum64_5_hi, G6 = Br.sum64_5_lo, cy = q6.BlockHash, z6 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function wi() {
  if (!(this instanceof wi))
    return new wi();
  cy.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = z6, this.W = new Array(160);
}
Br.inherits(wi, cy);
var hy = wi;
wi.blockSize = 1024;
wi.outSize = 512;
wi.hmacStrength = 192;
wi.padLength = 128;
wi.prototype._prepareBlock = function(e, t) {
  for (var o = this.W, r = 0; r < 32; r++)
    o[r] = e[t + r];
  for (; r < o.length; r += 2) {
    var h = i8(o[r - 4], o[r - 3]), a = n8(o[r - 4], o[r - 3]), p = o[r - 14], d = o[r - 13], b = t8(o[r - 30], o[r - 29]), g = r8(o[r - 30], o[r - 29]), w = o[r - 32], C = o[r - 31];
    o[r] = K6(
      h,
      a,
      p,
      d,
      b,
      g,
      w,
      C
    ), o[r + 1] = $6(
      h,
      a,
      p,
      d,
      b,
      g,
      w,
      C
    );
  }
};
wi.prototype._update = function(e, t) {
  this._prepareBlock(e, t);
  var o = this.W, r = this.h[0], h = this.h[1], a = this.h[2], p = this.h[3], d = this.h[4], b = this.h[5], g = this.h[6], w = this.h[7], C = this.h[8], T = this.h[9], k = this.h[10], q = this.h[11], O = this.h[12], N = this.h[13], j = this.h[14], U = this.h[15];
  V6(this.k.length === o.length);
  for (var H = 0; H < o.length; H += 2) {
    var z = j, ee = U, ne = J6(C, T), le = e8(C, T), Z = j6(C, T, k, q, O), ie = W6(C, T, k, q, O, N), fe = this.k[H], I = this.k[H + 1], P = o[H], f = o[H + 1], y = H6(
      z,
      ee,
      ne,
      le,
      Z,
      ie,
      fe,
      I,
      P,
      f
    ), v = G6(
      z,
      ee,
      ne,
      le,
      Z,
      ie,
      fe,
      I,
      P,
      f
    );
    z = Q6(r, h), ee = Z6(r, h), ne = Y6(r, h, a, p, d), le = X6(r, h, a, p, d, b);
    var M = Bo(z, ee, ne, le), B = Io(z, ee, ne, le);
    j = O, U = N, O = k, N = q, k = C, q = T, C = Bo(g, w, y, v), T = Io(w, w, y, v), g = d, w = b, d = a, b = p, a = r, p = h, r = Bo(y, v, M, B), h = Io(y, v, M, B);
  }
  hn(this.h, 0, r, h), hn(this.h, 2, a, p), hn(this.h, 4, d, b), hn(this.h, 6, g, w), hn(this.h, 8, C, T), hn(this.h, 10, k, q), hn(this.h, 12, O, N), hn(this.h, 14, j, U);
};
wi.prototype._digest = function(e) {
  return e === "hex" ? Br.toHex32(this.h, "big") : Br.split32(this.h, "big");
};
function j6(e, t, o, r, h) {
  var a = e & o ^ ~e & h;
  return a < 0 && (a += 4294967296), a;
}
function W6(e, t, o, r, h, a) {
  var p = t & r ^ ~t & a;
  return p < 0 && (p += 4294967296), p;
}
function Y6(e, t, o, r, h) {
  var a = e & o ^ e & h ^ o & h;
  return a < 0 && (a += 4294967296), a;
}
function X6(e, t, o, r, h, a) {
  var p = t & r ^ t & a ^ r & a;
  return p < 0 && (p += 4294967296), p;
}
function Q6(e, t) {
  var o = Vi(e, t, 28), r = Vi(t, e, 2), h = Vi(t, e, 7), a = o ^ r ^ h;
  return a < 0 && (a += 4294967296), a;
}
function Z6(e, t) {
  var o = Ki(e, t, 28), r = Ki(t, e, 2), h = Ki(t, e, 7), a = o ^ r ^ h;
  return a < 0 && (a += 4294967296), a;
}
function J6(e, t) {
  var o = Vi(e, t, 14), r = Vi(e, t, 18), h = Vi(t, e, 9), a = o ^ r ^ h;
  return a < 0 && (a += 4294967296), a;
}
function e8(e, t) {
  var o = Ki(e, t, 14), r = Ki(e, t, 18), h = Ki(t, e, 9), a = o ^ r ^ h;
  return a < 0 && (a += 4294967296), a;
}
function t8(e, t) {
  var o = Vi(e, t, 1), r = Vi(e, t, 8), h = oy(e, t, 7), a = o ^ r ^ h;
  return a < 0 && (a += 4294967296), a;
}
function r8(e, t) {
  var o = Ki(e, t, 1), r = Ki(e, t, 8), h = uy(e, t, 7), a = o ^ r ^ h;
  return a < 0 && (a += 4294967296), a;
}
function i8(e, t) {
  var o = Vi(e, t, 19), r = Vi(t, e, 29), h = oy(e, t, 6), a = o ^ r ^ h;
  return a < 0 && (a += 4294967296), a;
}
function n8(e, t) {
  var o = Ki(e, t, 19), r = Ki(t, e, 29), h = uy(e, t, 6), a = o ^ r ^ h;
  return a < 0 && (a += 4294967296), a;
}
var uc = gt, ly = hy;
function un() {
  if (!(this instanceof un))
    return new un();
  ly.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
uc.inherits(un, ly);
var a8 = un;
un.blockSize = 1024;
un.outSize = 384;
un.hmacStrength = 192;
un.padLength = 128;
un.prototype._digest = function(e) {
  return e === "hex" ? uc.toHex32(this.h.slice(0, 12), "big") : uc.split32(this.h.slice(0, 12), "big");
};
Ha.sha1 = B6;
Ha.sha224 = F6;
Ha.sha256 = sy;
Ha.sha384 = a8;
Ha.sha512 = hy;
var dy = {}, Jn = gt, s8 = $a, J0 = Jn.rotl32, Wl = Jn.sum32, h0 = Jn.sum32_3, Yl = Jn.sum32_4, py = s8.BlockHash;
function zi() {
  if (!(this instanceof zi))
    return new zi();
  py.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
Jn.inherits(zi, py);
dy.ripemd160 = zi;
zi.blockSize = 512;
zi.outSize = 160;
zi.hmacStrength = 192;
zi.padLength = 64;
zi.prototype._update = function(e, t) {
  for (var o = this.h[0], r = this.h[1], h = this.h[2], a = this.h[3], p = this.h[4], d = o, b = r, g = h, w = a, C = p, T = 0; T < 80; T++) {
    var k = Wl(
      J0(
        Yl(o, Xl(T, r, h, a), e[u8[T] + t], f8(T)),
        h8[T]
      ),
      p
    );
    o = p, p = a, a = J0(h, 10), h = r, r = k, k = Wl(
      J0(
        Yl(d, Xl(79 - T, b, g, w), e[c8[T] + t], o8(T)),
        l8[T]
      ),
      C
    ), d = C, C = w, w = J0(g, 10), g = b, b = k;
  }
  k = h0(this.h[1], h, w), this.h[1] = h0(this.h[2], a, C), this.h[2] = h0(this.h[3], p, d), this.h[3] = h0(this.h[4], o, b), this.h[4] = h0(this.h[0], r, g), this.h[0] = k;
};
zi.prototype._digest = function(e) {
  return e === "hex" ? Jn.toHex32(this.h, "little") : Jn.split32(this.h, "little");
};
function Xl(e, t, o, r) {
  return e <= 15 ? t ^ o ^ r : e <= 31 ? t & o | ~t & r : e <= 47 ? (t | ~o) ^ r : e <= 63 ? t & r | o & ~r : t ^ (o | ~r);
}
function f8(e) {
  return e <= 15 ? 0 : e <= 31 ? 1518500249 : e <= 47 ? 1859775393 : e <= 63 ? 2400959708 : 2840853838;
}
function o8(e) {
  return e <= 15 ? 1352829926 : e <= 31 ? 1548603684 : e <= 47 ? 1836072691 : e <= 63 ? 2053994217 : 0;
}
var u8 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], c8 = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], h8 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], l8 = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], d8 = gt, p8 = Qr;
function Ta(e, t, o) {
  if (!(this instanceof Ta))
    return new Ta(e, t, o);
  this.Hash = e, this.blockSize = e.blockSize / 8, this.outSize = e.outSize / 8, this.inner = null, this.outer = null, this._init(d8.toArray(t, o));
}
var v8 = Ta;
Ta.prototype._init = function(e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()), p8(e.length <= this.blockSize);
  for (var t = e.length; t < this.blockSize; t++)
    e.push(0);
  for (t = 0; t < e.length; t++)
    e[t] ^= 54;
  for (this.inner = new this.Hash().update(e), t = 0; t < e.length; t++)
    e[t] ^= 106;
  this.outer = new this.Hash().update(e);
};
Ta.prototype.update = function(e, t) {
  return this.inner.update(e, t), this;
};
Ta.prototype.digest = function(e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function(e) {
  var t = e;
  t.utils = gt, t.common = $a, t.sha = Ha, t.ripemd = dy, t.hmac = v8, t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160;
})(bf);
var To, Ql;
function y8() {
  return Ql || (Ql = 1, To = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), To;
}
(function(e) {
  var t = e, o = bf, r = oh, h = Pr, a = h.assert;
  function p(g) {
    g.type === "short" ? this.curve = new r.short(g) : g.type === "edwards" ? this.curve = new r.edwards(g) : this.curve = new r.mont(g), this.g = this.curve.g, this.n = this.curve.n, this.hash = g.hash, a(this.g.validate(), "Invalid curve"), a(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  t.PresetCurve = p;
  function d(g, w) {
    Object.defineProperty(t, g, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var C = new p(w);
        return Object.defineProperty(t, g, {
          configurable: !0,
          enumerable: !0,
          value: C
        }), C;
      }
    });
  }
  d("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: o.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), d("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: o.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), d("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: o.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), d("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: o.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), d("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: o.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), d("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: o.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), d("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: o.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var b;
  try {
    b = y8();
  } catch {
    b = void 0;
  }
  d("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: o.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      b
    ]
  });
})(mf);
var g8 = bf, Wn = fh, vy = Qr;
function Cn(e) {
  if (!(this instanceof Cn))
    return new Cn(e);
  this.hash = e.hash, this.predResist = !!e.predResist, this.outLen = this.hash.outSize, this.minEntropy = e.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var t = Wn.toArray(e.entropy, e.entropyEnc || "hex"), o = Wn.toArray(e.nonce, e.nonceEnc || "hex"), r = Wn.toArray(e.pers, e.persEnc || "hex");
  vy(
    t.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(t, o, r);
}
var m8 = Cn;
Cn.prototype._init = function(e, t, o) {
  var r = e.concat(t).concat(o);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var h = 0; h < this.V.length; h++)
    this.K[h] = 0, this.V[h] = 1;
  this._update(r), this._reseed = 1, this.reseedInterval = 281474976710656;
};
Cn.prototype._hmac = function() {
  return new g8.hmac(this.hash, this.K);
};
Cn.prototype._update = function(e) {
  var t = this._hmac().update(this.V).update([0]);
  e && (t = t.update(e)), this.K = t.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
Cn.prototype.reseed = function(e, t, o, r) {
  typeof t != "string" && (r = o, o = t, t = null), e = Wn.toArray(e, t), o = Wn.toArray(o, r), vy(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(e.concat(o || [])), this._reseed = 1;
};
Cn.prototype.generate = function(e, t, o, r) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof t != "string" && (r = o, o = t, t = null), o && (o = Wn.toArray(o, r || "hex"), this._update(o));
  for (var h = []; h.length < e; )
    this.V = this._hmac().update(this.V).digest(), h = h.concat(this.V);
  var a = h.slice(0, e);
  return this._update(o), this._reseed++, Wn.encode(a, t);
};
var b8 = rr, x8 = Pr, cc = x8.assert;
function dr(e, t) {
  this.ec = e, this.priv = null, this.pub = null, t.priv && this._importPrivate(t.priv, t.privEnc), t.pub && this._importPublic(t.pub, t.pubEnc);
}
var _8 = dr;
dr.fromPublic = function(e, t, o) {
  return t instanceof dr ? t : new dr(e, {
    pub: t,
    pubEnc: o
  });
};
dr.fromPrivate = function(e, t, o) {
  return t instanceof dr ? t : new dr(e, {
    priv: t,
    privEnc: o
  });
};
dr.prototype.validate = function() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
dr.prototype.getPublic = function(e, t) {
  return typeof e == "string" && (t = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), t ? this.pub.encode(t, e) : this.pub;
};
dr.prototype.getPrivate = function(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
dr.prototype._importPrivate = function(e, t) {
  this.priv = new b8(e, t || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
dr.prototype._importPublic = function(e, t) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? cc(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && cc(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, t);
};
dr.prototype.derive = function(e) {
  return e.validate() || cc(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
dr.prototype.sign = function(e, t, o) {
  return this.ec.sign(e, this, t, o);
};
dr.prototype.verify = function(e, t) {
  return this.ec.verify(e, t, this);
};
dr.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var Ds = rr, ch = Pr, E8 = ch.assert;
function _f(e, t) {
  if (e instanceof _f)
    return e;
  this._importDER(e, t) || (E8(e.r && e.s, "Signature without r or s"), this.r = new Ds(e.r, 16), this.s = new Ds(e.s, 16), e.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = e.recoveryParam);
}
var S8 = _f;
function w8() {
  this.place = 0;
}
function Mo(e, t) {
  var o = e[t.place++];
  if (!(o & 128))
    return o;
  var r = o & 15;
  if (r === 0 || r > 4)
    return !1;
  for (var h = 0, a = 0, p = t.place; a < r; a++, p++)
    h <<= 8, h |= e[p], h >>>= 0;
  return h <= 127 ? !1 : (t.place = p, h);
}
function Zl(e) {
  for (var t = 0, o = e.length - 1; !e[t] && !(e[t + 1] & 128) && t < o; )
    t++;
  return t === 0 ? e : e.slice(t);
}
_f.prototype._importDER = function(e, t) {
  e = ch.toArray(e, t);
  var o = new w8();
  if (e[o.place++] !== 48)
    return !1;
  var r = Mo(e, o);
  if (r === !1 || r + o.place !== e.length || e[o.place++] !== 2)
    return !1;
  var h = Mo(e, o);
  if (h === !1)
    return !1;
  var a = e.slice(o.place, h + o.place);
  if (o.place += h, e[o.place++] !== 2)
    return !1;
  var p = Mo(e, o);
  if (p === !1 || e.length !== p + o.place)
    return !1;
  var d = e.slice(o.place, p + o.place);
  if (a[0] === 0)
    if (a[1] & 128)
      a = a.slice(1);
    else
      return !1;
  if (d[0] === 0)
    if (d[1] & 128)
      d = d.slice(1);
    else
      return !1;
  return this.r = new Ds(a), this.s = new Ds(d), this.recoveryParam = null, !0;
};
function Ro(e, t) {
  if (t < 128) {
    e.push(t);
    return;
  }
  var o = 1 + (Math.log(t) / Math.LN2 >>> 3);
  for (e.push(o | 128); --o; )
    e.push(t >>> (o << 3) & 255);
  e.push(t);
}
_f.prototype.toDER = function(e) {
  var t = this.r.toArray(), o = this.s.toArray();
  for (t[0] & 128 && (t = [0].concat(t)), o[0] & 128 && (o = [0].concat(o)), t = Zl(t), o = Zl(o); !o[0] && !(o[1] & 128); )
    o = o.slice(1);
  var r = [2];
  Ro(r, t.length), r = r.concat(t), r.push(2), Ro(r, o.length);
  var h = r.concat(o), a = [48];
  return Ro(a, h.length), a = a.concat(h), ch.encode(a, e);
};
var No, Jl;
function C8() {
  if (Jl)
    return No;
  Jl = 1;
  var e = rr, t = m8, o = Pr, r = mf, h = nh(), a = o.assert, p = _8, d = S8;
  function b(g) {
    if (!(this instanceof b))
      return new b(g);
    typeof g == "string" && (a(
      Object.prototype.hasOwnProperty.call(r, g),
      "Unknown curve " + g
    ), g = r[g]), g instanceof r.PresetCurve && (g = { curve: g }), this.curve = g.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = g.curve.g, this.g.precompute(g.curve.n.bitLength() + 1), this.hash = g.hash || g.curve.hash;
  }
  return No = b, b.prototype.keyPair = function(g) {
    return new p(this, g);
  }, b.prototype.keyFromPrivate = function(g, w) {
    return p.fromPrivate(this, g, w);
  }, b.prototype.keyFromPublic = function(g, w) {
    return p.fromPublic(this, g, w);
  }, b.prototype.genKeyPair = function(g) {
    g || (g = {});
    for (var w = new t({
      hash: this.hash,
      pers: g.pers,
      persEnc: g.persEnc || "utf8",
      entropy: g.entropy || h(this.hash.hmacStrength),
      entropyEnc: g.entropy && g.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), C = this.n.byteLength(), T = this.n.sub(new e(2)); ; ) {
      var k = new e(w.generate(C));
      if (!(k.cmp(T) > 0))
        return k.iaddn(1), this.keyFromPrivate(k);
    }
  }, b.prototype._truncateToN = function(g, w) {
    var C = g.byteLength() * 8 - this.n.bitLength();
    return C > 0 && (g = g.ushrn(C)), !w && g.cmp(this.n) >= 0 ? g.sub(this.n) : g;
  }, b.prototype.sign = function(g, w, C, T) {
    typeof C == "object" && (T = C, C = null), T || (T = {}), w = this.keyFromPrivate(w, C), g = this._truncateToN(new e(g, 16));
    for (var k = this.n.byteLength(), q = w.getPrivate().toArray("be", k), O = g.toArray("be", k), N = new t({
      hash: this.hash,
      entropy: q,
      nonce: O,
      pers: T.pers,
      persEnc: T.persEnc || "utf8"
    }), j = this.n.sub(new e(1)), U = 0; ; U++) {
      var H = T.k ? T.k(U) : new e(N.generate(this.n.byteLength()));
      if (H = this._truncateToN(H, !0), !(H.cmpn(1) <= 0 || H.cmp(j) >= 0)) {
        var z = this.g.mul(H);
        if (!z.isInfinity()) {
          var ee = z.getX(), ne = ee.umod(this.n);
          if (ne.cmpn(0) !== 0) {
            var le = H.invm(this.n).mul(ne.mul(w.getPrivate()).iadd(g));
            if (le = le.umod(this.n), le.cmpn(0) !== 0) {
              var Z = (z.getY().isOdd() ? 1 : 0) | (ee.cmp(ne) !== 0 ? 2 : 0);
              return T.canonical && le.cmp(this.nh) > 0 && (le = this.n.sub(le), Z ^= 1), new d({ r: ne, s: le, recoveryParam: Z });
            }
          }
        }
      }
    }
  }, b.prototype.verify = function(g, w, C, T) {
    g = this._truncateToN(new e(g, 16)), C = this.keyFromPublic(C, T), w = new d(w, "hex");
    var k = w.r, q = w.s;
    if (k.cmpn(1) < 0 || k.cmp(this.n) >= 0 || q.cmpn(1) < 0 || q.cmp(this.n) >= 0)
      return !1;
    var O = q.invm(this.n), N = O.mul(g).umod(this.n), j = O.mul(k).umod(this.n), U;
    return this.curve._maxwellTrick ? (U = this.g.jmulAdd(N, C.getPublic(), j), U.isInfinity() ? !1 : U.eqXToP(k)) : (U = this.g.mulAdd(N, C.getPublic(), j), U.isInfinity() ? !1 : U.getX().umod(this.n).cmp(k) === 0);
  }, b.prototype.recoverPubKey = function(g, w, C, T) {
    a((3 & C) === C, "The recovery param is more than two bits"), w = new d(w, T);
    var k = this.n, q = new e(g), O = w.r, N = w.s, j = C & 1, U = C >> 1;
    if (O.cmp(this.curve.p.umod(this.curve.n)) >= 0 && U)
      throw new Error("Unable to find sencond key candinate");
    U ? O = this.curve.pointFromX(O.add(this.curve.n), j) : O = this.curve.pointFromX(O, j);
    var H = w.r.invm(k), z = k.sub(q).mul(H).umod(k), ee = N.mul(H).umod(k);
    return this.g.mulAdd(z, O, ee);
  }, b.prototype.getKeyRecoveryParam = function(g, w, C, T) {
    if (w = new d(w, T), w.recoveryParam !== null)
      return w.recoveryParam;
    for (var k = 0; k < 4; k++) {
      var q;
      try {
        q = this.recoverPubKey(g, w, k);
      } catch {
        continue;
      }
      if (q.eq(C))
        return k;
    }
    throw new Error("Unable to find valid recovery factor");
  }, No;
}
var K0 = Pr, yy = K0.assert, ed = K0.parseBytes, za = K0.cachedProperty;
function Zt(e, t) {
  this.eddsa = e, this._secret = ed(t.secret), e.isPoint(t.pub) ? this._pub = t.pub : this._pubBytes = ed(t.pub);
}
Zt.fromPublic = function(e, t) {
  return t instanceof Zt ? t : new Zt(e, { pub: t });
};
Zt.fromSecret = function(e, t) {
  return t instanceof Zt ? t : new Zt(e, { secret: t });
};
Zt.prototype.secret = function() {
  return this._secret;
};
za(Zt, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
});
za(Zt, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
za(Zt, "privBytes", function() {
  var e = this.eddsa, t = this.hash(), o = e.encodingLength - 1, r = t.slice(0, e.encodingLength);
  return r[0] &= 248, r[o] &= 127, r[o] |= 64, r;
});
za(Zt, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
});
za(Zt, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
});
za(Zt, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
});
Zt.prototype.sign = function(e) {
  return yy(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
};
Zt.prototype.verify = function(e, t) {
  return this.eddsa.verify(e, t, this);
};
Zt.prototype.getSecret = function(e) {
  return yy(this._secret, "KeyPair is public only"), K0.encode(this.secret(), e);
};
Zt.prototype.getPublic = function(e) {
  return K0.encode(this.pubBytes(), e);
};
var A8 = Zt, B8 = rr, Ef = Pr, I8 = Ef.assert, Sf = Ef.cachedProperty, T8 = Ef.parseBytes;
function na(e, t) {
  this.eddsa = e, typeof t != "object" && (t = T8(t)), Array.isArray(t) && (t = {
    R: t.slice(0, e.encodingLength),
    S: t.slice(e.encodingLength)
  }), I8(t.R && t.S, "Signature without R or S"), e.isPoint(t.R) && (this._R = t.R), t.S instanceof B8 && (this._S = t.S), this._Rencoded = Array.isArray(t.R) ? t.R : t.Rencoded, this._Sencoded = Array.isArray(t.S) ? t.S : t.Sencoded;
}
Sf(na, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
});
Sf(na, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
});
Sf(na, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
});
Sf(na, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
});
na.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
};
na.prototype.toHex = function() {
  return Ef.encode(this.toBytes(), "hex").toUpperCase();
};
var M8 = na, R8 = bf, N8 = mf, Ma = Pr, D8 = Ma.assert, gy = Ma.parseBytes, my = A8, td = M8;
function Ir(e) {
  if (D8(e === "ed25519", "only tested with ed25519 so far"), !(this instanceof Ir))
    return new Ir(e);
  e = N8[e].curve, this.curve = e, this.g = e.g, this.g.precompute(e.n.bitLength() + 1), this.pointClass = e.point().constructor, this.encodingLength = Math.ceil(e.n.bitLength() / 8), this.hash = R8.sha512;
}
var O8 = Ir;
Ir.prototype.sign = function(e, t) {
  e = gy(e);
  var o = this.keyFromSecret(t), r = this.hashInt(o.messagePrefix(), e), h = this.g.mul(r), a = this.encodePoint(h), p = this.hashInt(a, o.pubBytes(), e).mul(o.priv()), d = r.add(p).umod(this.curve.n);
  return this.makeSignature({ R: h, S: d, Rencoded: a });
};
Ir.prototype.verify = function(e, t, o) {
  e = gy(e), t = this.makeSignature(t);
  var r = this.keyFromPublic(o), h = this.hashInt(t.Rencoded(), r.pubBytes(), e), a = this.g.mul(t.S()), p = t.R().add(r.pub().mul(h));
  return p.eq(a);
};
Ir.prototype.hashInt = function() {
  for (var e = this.hash(), t = 0; t < arguments.length; t++)
    e.update(arguments[t]);
  return Ma.intFromLE(e.digest()).umod(this.curve.n);
};
Ir.prototype.keyFromPublic = function(e) {
  return my.fromPublic(this, e);
};
Ir.prototype.keyFromSecret = function(e) {
  return my.fromSecret(this, e);
};
Ir.prototype.makeSignature = function(e) {
  return e instanceof td ? e : new td(this, e);
};
Ir.prototype.encodePoint = function(e) {
  var t = e.getY().toArray("le", this.encodingLength);
  return t[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, t;
};
Ir.prototype.decodePoint = function(e) {
  e = Ma.parseBytes(e);
  var t = e.length - 1, o = e.slice(0, t).concat(e[t] & -129), r = (e[t] & 128) !== 0, h = Ma.intFromLE(o);
  return this.curve.pointFromY(h, r);
};
Ir.prototype.encodeInt = function(e) {
  return e.toArray("le", this.encodingLength);
};
Ir.prototype.decodeInt = function(e) {
  return Ma.intFromLE(e);
};
Ir.prototype.isPoint = function(e) {
  return e instanceof this.pointClass;
};
var rd;
function hh() {
  return rd || (rd = 1, function(e) {
    var t = e;
    t.version = O3.version, t.utils = Pr, t.rand = nh(), t.curve = oh, t.curves = mf, t.ec = C8(), t.eddsa = O8;
  }(Co)), Co;
}
var lh = { exports: {} };
(function(e) {
  (function(t, o) {
    function r(f, y) {
      if (!f)
        throw new Error(y || "Assertion failed");
    }
    function h(f, y) {
      f.super_ = y;
      var v = function() {
      };
      v.prototype = y.prototype, f.prototype = new v(), f.prototype.constructor = f;
    }
    function a(f, y, v) {
      if (a.isBN(f))
        return f;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, f !== null && ((y === "le" || y === "be") && (v = y, y = 10), this._init(f || 0, y || 10, v || "be"));
    }
    typeof t == "object" ? t.exports = a : o.BN = a, a.BN = a, a.wordSize = 26;
    var p;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? p = window.Buffer : p = pe.Buffer;
    } catch {
    }
    a.isBN = function(f) {
      return f instanceof a ? !0 : f !== null && typeof f == "object" && f.constructor.wordSize === a.wordSize && Array.isArray(f.words);
    }, a.max = function(f, y) {
      return f.cmp(y) > 0 ? f : y;
    }, a.min = function(f, y) {
      return f.cmp(y) < 0 ? f : y;
    }, a.prototype._init = function(f, y, v) {
      if (typeof f == "number")
        return this._initNumber(f, y, v);
      if (typeof f == "object")
        return this._initArray(f, y, v);
      y === "hex" && (y = 16), r(y === (y | 0) && y >= 2 && y <= 36), f = f.toString().replace(/\s+/g, "");
      var M = 0;
      f[0] === "-" && (M++, this.negative = 1), M < f.length && (y === 16 ? this._parseHex(f, M, v) : (this._parseBase(f, y, M), v === "le" && this._initArray(this.toArray(), y, v)));
    }, a.prototype._initNumber = function(f, y, v) {
      f < 0 && (this.negative = 1, f = -f), f < 67108864 ? (this.words = [f & 67108863], this.length = 1) : f < 4503599627370496 ? (this.words = [
        f & 67108863,
        f / 67108864 & 67108863
      ], this.length = 2) : (r(f < 9007199254740992), this.words = [
        f & 67108863,
        f / 67108864 & 67108863,
        1
      ], this.length = 3), v === "le" && this._initArray(this.toArray(), y, v);
    }, a.prototype._initArray = function(f, y, v) {
      if (r(typeof f.length == "number"), f.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(f.length / 3), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var B, S, _ = 0;
      if (v === "be")
        for (M = f.length - 1, B = 0; M >= 0; M -= 3)
          S = f[M] | f[M - 1] << 8 | f[M - 2] << 16, this.words[B] |= S << _ & 67108863, this.words[B + 1] = S >>> 26 - _ & 67108863, _ += 24, _ >= 26 && (_ -= 26, B++);
      else if (v === "le")
        for (M = 0, B = 0; M < f.length; M += 3)
          S = f[M] | f[M + 1] << 8 | f[M + 2] << 16, this.words[B] |= S << _ & 67108863, this.words[B + 1] = S >>> 26 - _ & 67108863, _ += 24, _ >= 26 && (_ -= 26, B++);
      return this._strip();
    };
    function d(f, y) {
      var v = f.charCodeAt(y);
      if (v >= 48 && v <= 57)
        return v - 48;
      if (v >= 65 && v <= 70)
        return v - 55;
      if (v >= 97 && v <= 102)
        return v - 87;
      r(!1, "Invalid character in " + f);
    }
    function b(f, y, v) {
      var M = d(f, v);
      return v - 1 >= y && (M |= d(f, v - 1) << 4), M;
    }
    a.prototype._parseHex = function(f, y, v) {
      this.length = Math.ceil((f.length - y) / 6), this.words = new Array(this.length);
      for (var M = 0; M < this.length; M++)
        this.words[M] = 0;
      var B = 0, S = 0, _;
      if (v === "be")
        for (M = f.length - 1; M >= y; M -= 2)
          _ = b(f, y, M) << B, this.words[S] |= _ & 67108863, B >= 18 ? (B -= 18, S += 1, this.words[S] |= _ >>> 26) : B += 8;
      else {
        var E = f.length - y;
        for (M = E % 2 === 0 ? y + 1 : y; M < f.length; M += 2)
          _ = b(f, y, M) << B, this.words[S] |= _ & 67108863, B >= 18 ? (B -= 18, S += 1, this.words[S] |= _ >>> 26) : B += 8;
      }
      this._strip();
    };
    function g(f, y, v, M) {
      for (var B = 0, S = 0, _ = Math.min(f.length, v), E = y; E < _; E++) {
        var m = f.charCodeAt(E) - 48;
        B *= M, m >= 49 ? S = m - 49 + 10 : m >= 17 ? S = m - 17 + 10 : S = m, r(m >= 0 && S < M, "Invalid character"), B += S;
      }
      return B;
    }
    a.prototype._parseBase = function(f, y, v) {
      this.words = [0], this.length = 1;
      for (var M = 0, B = 1; B <= 67108863; B *= y)
        M++;
      M--, B = B / y | 0;
      for (var S = f.length - v, _ = S % M, E = Math.min(S, S - _) + v, m = 0, A = v; A < E; A += M)
        m = g(f, A, A + M, y), this.imuln(B), this.words[0] + m < 67108864 ? this.words[0] += m : this._iaddn(m);
      if (_ !== 0) {
        var $ = 1;
        for (m = g(f, A, f.length, y), A = 0; A < _; A++)
          $ *= y;
        this.imuln($), this.words[0] + m < 67108864 ? this.words[0] += m : this._iaddn(m);
      }
      this._strip();
    }, a.prototype.copy = function(f) {
      f.words = new Array(this.length);
      for (var y = 0; y < this.length; y++)
        f.words[y] = this.words[y];
      f.length = this.length, f.negative = this.negative, f.red = this.red;
    };
    function w(f, y) {
      f.words = y.words, f.length = y.length, f.negative = y.negative, f.red = y.red;
    }
    if (a.prototype._move = function(f) {
      w(f, this);
    }, a.prototype.clone = function() {
      var f = new a(null);
      return this.copy(f), f;
    }, a.prototype._expand = function(f) {
      for (; this.length < f; )
        this.words[this.length++] = 0;
      return this;
    }, a.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, a.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        a.prototype[Symbol.for("nodejs.util.inspect.custom")] = C;
      } catch {
        a.prototype.inspect = C;
      }
    else
      a.prototype.inspect = C;
    function C() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var T = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], k = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], q = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    a.prototype.toString = function(f, y) {
      f = f || 10, y = y | 0 || 1;
      var v;
      if (f === 16 || f === "hex") {
        v = "";
        for (var M = 0, B = 0, S = 0; S < this.length; S++) {
          var _ = this.words[S], E = ((_ << M | B) & 16777215).toString(16);
          B = _ >>> 24 - M & 16777215, M += 2, M >= 26 && (M -= 26, S--), B !== 0 || S !== this.length - 1 ? v = T[6 - E.length] + E + v : v = E + v;
        }
        for (B !== 0 && (v = B.toString(16) + v); v.length % y !== 0; )
          v = "0" + v;
        return this.negative !== 0 && (v = "-" + v), v;
      }
      if (f === (f | 0) && f >= 2 && f <= 36) {
        var m = k[f], A = q[f];
        v = "";
        var $ = this.clone();
        for ($.negative = 0; !$.isZero(); ) {
          var X = $.modrn(A).toString(f);
          $ = $.idivn(A), $.isZero() ? v = X + v : v = T[m - X.length] + X + v;
        }
        for (this.isZero() && (v = "0" + v); v.length % y !== 0; )
          v = "0" + v;
        return this.negative !== 0 && (v = "-" + v), v;
      }
      r(!1, "Base should be between 2 and 36");
    }, a.prototype.toNumber = function() {
      var f = this.words[0];
      return this.length === 2 ? f += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? f += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && r(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -f : f;
    }, a.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, p && (a.prototype.toBuffer = function(f, y) {
      return this.toArrayLike(p, f, y);
    }), a.prototype.toArray = function(f, y) {
      return this.toArrayLike(Array, f, y);
    };
    var O = function(f, y) {
      return f.allocUnsafe ? f.allocUnsafe(y) : new f(y);
    };
    a.prototype.toArrayLike = function(f, y, v) {
      this._strip();
      var M = this.byteLength(), B = v || Math.max(1, M);
      r(M <= B, "byte array longer than desired length"), r(B > 0, "Requested array length <= 0");
      var S = O(f, B), _ = y === "le" ? "LE" : "BE";
      return this["_toArrayLike" + _](S, M), S;
    }, a.prototype._toArrayLikeLE = function(f, y) {
      for (var v = 0, M = 0, B = 0, S = 0; B < this.length; B++) {
        var _ = this.words[B] << S | M;
        f[v++] = _ & 255, v < f.length && (f[v++] = _ >> 8 & 255), v < f.length && (f[v++] = _ >> 16 & 255), S === 6 ? (v < f.length && (f[v++] = _ >> 24 & 255), M = 0, S = 0) : (M = _ >>> 24, S += 2);
      }
      if (v < f.length)
        for (f[v++] = M; v < f.length; )
          f[v++] = 0;
    }, a.prototype._toArrayLikeBE = function(f, y) {
      for (var v = f.length - 1, M = 0, B = 0, S = 0; B < this.length; B++) {
        var _ = this.words[B] << S | M;
        f[v--] = _ & 255, v >= 0 && (f[v--] = _ >> 8 & 255), v >= 0 && (f[v--] = _ >> 16 & 255), S === 6 ? (v >= 0 && (f[v--] = _ >> 24 & 255), M = 0, S = 0) : (M = _ >>> 24, S += 2);
      }
      if (v >= 0)
        for (f[v--] = M; v >= 0; )
          f[v--] = 0;
    }, Math.clz32 ? a.prototype._countBits = function(f) {
      return 32 - Math.clz32(f);
    } : a.prototype._countBits = function(f) {
      var y = f, v = 0;
      return y >= 4096 && (v += 13, y >>>= 13), y >= 64 && (v += 7, y >>>= 7), y >= 8 && (v += 4, y >>>= 4), y >= 2 && (v += 2, y >>>= 2), v + y;
    }, a.prototype._zeroBits = function(f) {
      if (f === 0)
        return 26;
      var y = f, v = 0;
      return y & 8191 || (v += 13, y >>>= 13), y & 127 || (v += 7, y >>>= 7), y & 15 || (v += 4, y >>>= 4), y & 3 || (v += 2, y >>>= 2), y & 1 || v++, v;
    }, a.prototype.bitLength = function() {
      var f = this.words[this.length - 1], y = this._countBits(f);
      return (this.length - 1) * 26 + y;
    };
    function N(f) {
      for (var y = new Array(f.bitLength()), v = 0; v < y.length; v++) {
        var M = v / 26 | 0, B = v % 26;
        y[v] = f.words[M] >>> B & 1;
      }
      return y;
    }
    a.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var f = 0, y = 0; y < this.length; y++) {
        var v = this._zeroBits(this.words[y]);
        if (f += v, v !== 26)
          break;
      }
      return f;
    }, a.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, a.prototype.toTwos = function(f) {
      return this.negative !== 0 ? this.abs().inotn(f).iaddn(1) : this.clone();
    }, a.prototype.fromTwos = function(f) {
      return this.testn(f - 1) ? this.notn(f).iaddn(1).ineg() : this.clone();
    }, a.prototype.isNeg = function() {
      return this.negative !== 0;
    }, a.prototype.neg = function() {
      return this.clone().ineg();
    }, a.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, a.prototype.iuor = function(f) {
      for (; this.length < f.length; )
        this.words[this.length++] = 0;
      for (var y = 0; y < f.length; y++)
        this.words[y] = this.words[y] | f.words[y];
      return this._strip();
    }, a.prototype.ior = function(f) {
      return r((this.negative | f.negative) === 0), this.iuor(f);
    }, a.prototype.or = function(f) {
      return this.length > f.length ? this.clone().ior(f) : f.clone().ior(this);
    }, a.prototype.uor = function(f) {
      return this.length > f.length ? this.clone().iuor(f) : f.clone().iuor(this);
    }, a.prototype.iuand = function(f) {
      var y;
      this.length > f.length ? y = f : y = this;
      for (var v = 0; v < y.length; v++)
        this.words[v] = this.words[v] & f.words[v];
      return this.length = y.length, this._strip();
    }, a.prototype.iand = function(f) {
      return r((this.negative | f.negative) === 0), this.iuand(f);
    }, a.prototype.and = function(f) {
      return this.length > f.length ? this.clone().iand(f) : f.clone().iand(this);
    }, a.prototype.uand = function(f) {
      return this.length > f.length ? this.clone().iuand(f) : f.clone().iuand(this);
    }, a.prototype.iuxor = function(f) {
      var y, v;
      this.length > f.length ? (y = this, v = f) : (y = f, v = this);
      for (var M = 0; M < v.length; M++)
        this.words[M] = y.words[M] ^ v.words[M];
      if (this !== y)
        for (; M < y.length; M++)
          this.words[M] = y.words[M];
      return this.length = y.length, this._strip();
    }, a.prototype.ixor = function(f) {
      return r((this.negative | f.negative) === 0), this.iuxor(f);
    }, a.prototype.xor = function(f) {
      return this.length > f.length ? this.clone().ixor(f) : f.clone().ixor(this);
    }, a.prototype.uxor = function(f) {
      return this.length > f.length ? this.clone().iuxor(f) : f.clone().iuxor(this);
    }, a.prototype.inotn = function(f) {
      r(typeof f == "number" && f >= 0);
      var y = Math.ceil(f / 26) | 0, v = f % 26;
      this._expand(y), v > 0 && y--;
      for (var M = 0; M < y; M++)
        this.words[M] = ~this.words[M] & 67108863;
      return v > 0 && (this.words[M] = ~this.words[M] & 67108863 >> 26 - v), this._strip();
    }, a.prototype.notn = function(f) {
      return this.clone().inotn(f);
    }, a.prototype.setn = function(f, y) {
      r(typeof f == "number" && f >= 0);
      var v = f / 26 | 0, M = f % 26;
      return this._expand(v + 1), y ? this.words[v] = this.words[v] | 1 << M : this.words[v] = this.words[v] & ~(1 << M), this._strip();
    }, a.prototype.iadd = function(f) {
      var y;
      if (this.negative !== 0 && f.negative === 0)
        return this.negative = 0, y = this.isub(f), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && f.negative !== 0)
        return f.negative = 0, y = this.isub(f), f.negative = 1, y._normSign();
      var v, M;
      this.length > f.length ? (v = this, M = f) : (v = f, M = this);
      for (var B = 0, S = 0; S < M.length; S++)
        y = (v.words[S] | 0) + (M.words[S] | 0) + B, this.words[S] = y & 67108863, B = y >>> 26;
      for (; B !== 0 && S < v.length; S++)
        y = (v.words[S] | 0) + B, this.words[S] = y & 67108863, B = y >>> 26;
      if (this.length = v.length, B !== 0)
        this.words[this.length] = B, this.length++;
      else if (v !== this)
        for (; S < v.length; S++)
          this.words[S] = v.words[S];
      return this;
    }, a.prototype.add = function(f) {
      var y;
      return f.negative !== 0 && this.negative === 0 ? (f.negative = 0, y = this.sub(f), f.negative ^= 1, y) : f.negative === 0 && this.negative !== 0 ? (this.negative = 0, y = f.sub(this), this.negative = 1, y) : this.length > f.length ? this.clone().iadd(f) : f.clone().iadd(this);
    }, a.prototype.isub = function(f) {
      if (f.negative !== 0) {
        f.negative = 0;
        var y = this.iadd(f);
        return f.negative = 1, y._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(f), this.negative = 1, this._normSign();
      var v = this.cmp(f);
      if (v === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var M, B;
      v > 0 ? (M = this, B = f) : (M = f, B = this);
      for (var S = 0, _ = 0; _ < B.length; _++)
        y = (M.words[_] | 0) - (B.words[_] | 0) + S, S = y >> 26, this.words[_] = y & 67108863;
      for (; S !== 0 && _ < M.length; _++)
        y = (M.words[_] | 0) + S, S = y >> 26, this.words[_] = y & 67108863;
      if (S === 0 && _ < M.length && M !== this)
        for (; _ < M.length; _++)
          this.words[_] = M.words[_];
      return this.length = Math.max(this.length, _), M !== this && (this.negative = 1), this._strip();
    }, a.prototype.sub = function(f) {
      return this.clone().isub(f);
    };
    function j(f, y, v) {
      v.negative = y.negative ^ f.negative;
      var M = f.length + y.length | 0;
      v.length = M, M = M - 1 | 0;
      var B = f.words[0] | 0, S = y.words[0] | 0, _ = B * S, E = _ & 67108863, m = _ / 67108864 | 0;
      v.words[0] = E;
      for (var A = 1; A < M; A++) {
        for (var $ = m >>> 26, X = m & 67108863, oe = Math.min(A, y.length - 1), J = Math.max(0, A - f.length + 1); J <= oe; J++) {
          var W = A - J | 0;
          B = f.words[W] | 0, S = y.words[J] | 0, _ = B * S + X, $ += _ / 67108864 | 0, X = _ & 67108863;
        }
        v.words[A] = X | 0, m = $ | 0;
      }
      return m !== 0 ? v.words[A] = m | 0 : v.length--, v._strip();
    }
    var U = function(f, y, v) {
      var M = f.words, B = y.words, S = v.words, _ = 0, E, m, A, $ = M[0] | 0, X = $ & 8191, oe = $ >>> 13, J = M[1] | 0, W = J & 8191, Q = J >>> 13, me = M[2] | 0, be = me & 8191, Y = me >>> 13, re = M[3] | 0, de = re & 8191, Ae = re >>> 13, qe = M[4] | 0, x = qe & 8191, L = qe >>> 13, D = M[5] | 0, F = D & 8191, ue = D >>> 13, ge = M[6] | 0, ce = ge & 8191, ve = ge >>> 13, Re = M[7] | 0, ke = Re & 8191, Ce = Re >>> 13, Le = M[8] | 0, Oe = Le & 8191, Pe = Le >>> 13, et = M[9] | 0, Ye = et & 8191, Ne = et >>> 13, Tt = B[0] | 0, tt = Tt & 8191, Ue = Tt >>> 13, Ct = B[1] | 0, rt = Ct & 8191, Ke = Ct >>> 13, ii = B[2] | 0, it = ii & 8191, $e = ii >>> 13, Ot = B[3] | 0, vt = Ot & 8191, Fe = Ot >>> 13, ni = B[4] | 0, nt = ni & 8191, ze = ni >>> 13, oi = B[5] | 0, ot = oi & 8191, Xe = oi >>> 13, Dt = B[6] | 0, Ze = Dt & 8191, je = Dt >>> 13, ri = B[7] | 0, St = ri & 8191, Qe = ri >>> 13, ai = B[8] | 0, It = ai & 8191, Je = ai >>> 13, si = B[9] | 0, At = si & 8191, Bt = si >>> 13;
      v.negative = f.negative ^ y.negative, v.length = 19, E = Math.imul(X, tt), m = Math.imul(X, Ue), m = m + Math.imul(oe, tt) | 0, A = Math.imul(oe, Ue);
      var ui = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (ui >>> 26) | 0, ui &= 67108863, E = Math.imul(W, tt), m = Math.imul(W, Ue), m = m + Math.imul(Q, tt) | 0, A = Math.imul(Q, Ue), E = E + Math.imul(X, rt) | 0, m = m + Math.imul(X, Ke) | 0, m = m + Math.imul(oe, rt) | 0, A = A + Math.imul(oe, Ke) | 0;
      var fi = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (fi >>> 26) | 0, fi &= 67108863, E = Math.imul(be, tt), m = Math.imul(be, Ue), m = m + Math.imul(Y, tt) | 0, A = Math.imul(Y, Ue), E = E + Math.imul(W, rt) | 0, m = m + Math.imul(W, Ke) | 0, m = m + Math.imul(Q, rt) | 0, A = A + Math.imul(Q, Ke) | 0, E = E + Math.imul(X, it) | 0, m = m + Math.imul(X, $e) | 0, m = m + Math.imul(oe, it) | 0, A = A + Math.imul(oe, $e) | 0;
      var hi = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (hi >>> 26) | 0, hi &= 67108863, E = Math.imul(de, tt), m = Math.imul(de, Ue), m = m + Math.imul(Ae, tt) | 0, A = Math.imul(Ae, Ue), E = E + Math.imul(be, rt) | 0, m = m + Math.imul(be, Ke) | 0, m = m + Math.imul(Y, rt) | 0, A = A + Math.imul(Y, Ke) | 0, E = E + Math.imul(W, it) | 0, m = m + Math.imul(W, $e) | 0, m = m + Math.imul(Q, it) | 0, A = A + Math.imul(Q, $e) | 0, E = E + Math.imul(X, vt) | 0, m = m + Math.imul(X, Fe) | 0, m = m + Math.imul(oe, vt) | 0, A = A + Math.imul(oe, Fe) | 0;
      var ci = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (ci >>> 26) | 0, ci &= 67108863, E = Math.imul(x, tt), m = Math.imul(x, Ue), m = m + Math.imul(L, tt) | 0, A = Math.imul(L, Ue), E = E + Math.imul(de, rt) | 0, m = m + Math.imul(de, Ke) | 0, m = m + Math.imul(Ae, rt) | 0, A = A + Math.imul(Ae, Ke) | 0, E = E + Math.imul(be, it) | 0, m = m + Math.imul(be, $e) | 0, m = m + Math.imul(Y, it) | 0, A = A + Math.imul(Y, $e) | 0, E = E + Math.imul(W, vt) | 0, m = m + Math.imul(W, Fe) | 0, m = m + Math.imul(Q, vt) | 0, A = A + Math.imul(Q, Fe) | 0, E = E + Math.imul(X, nt) | 0, m = m + Math.imul(X, ze) | 0, m = m + Math.imul(oe, nt) | 0, A = A + Math.imul(oe, ze) | 0;
      var li = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (li >>> 26) | 0, li &= 67108863, E = Math.imul(F, tt), m = Math.imul(F, Ue), m = m + Math.imul(ue, tt) | 0, A = Math.imul(ue, Ue), E = E + Math.imul(x, rt) | 0, m = m + Math.imul(x, Ke) | 0, m = m + Math.imul(L, rt) | 0, A = A + Math.imul(L, Ke) | 0, E = E + Math.imul(de, it) | 0, m = m + Math.imul(de, $e) | 0, m = m + Math.imul(Ae, it) | 0, A = A + Math.imul(Ae, $e) | 0, E = E + Math.imul(be, vt) | 0, m = m + Math.imul(be, Fe) | 0, m = m + Math.imul(Y, vt) | 0, A = A + Math.imul(Y, Fe) | 0, E = E + Math.imul(W, nt) | 0, m = m + Math.imul(W, ze) | 0, m = m + Math.imul(Q, nt) | 0, A = A + Math.imul(Q, ze) | 0, E = E + Math.imul(X, ot) | 0, m = m + Math.imul(X, Xe) | 0, m = m + Math.imul(oe, ot) | 0, A = A + Math.imul(oe, Xe) | 0;
      var di = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (di >>> 26) | 0, di &= 67108863, E = Math.imul(ce, tt), m = Math.imul(ce, Ue), m = m + Math.imul(ve, tt) | 0, A = Math.imul(ve, Ue), E = E + Math.imul(F, rt) | 0, m = m + Math.imul(F, Ke) | 0, m = m + Math.imul(ue, rt) | 0, A = A + Math.imul(ue, Ke) | 0, E = E + Math.imul(x, it) | 0, m = m + Math.imul(x, $e) | 0, m = m + Math.imul(L, it) | 0, A = A + Math.imul(L, $e) | 0, E = E + Math.imul(de, vt) | 0, m = m + Math.imul(de, Fe) | 0, m = m + Math.imul(Ae, vt) | 0, A = A + Math.imul(Ae, Fe) | 0, E = E + Math.imul(be, nt) | 0, m = m + Math.imul(be, ze) | 0, m = m + Math.imul(Y, nt) | 0, A = A + Math.imul(Y, ze) | 0, E = E + Math.imul(W, ot) | 0, m = m + Math.imul(W, Xe) | 0, m = m + Math.imul(Q, ot) | 0, A = A + Math.imul(Q, Xe) | 0, E = E + Math.imul(X, Ze) | 0, m = m + Math.imul(X, je) | 0, m = m + Math.imul(oe, Ze) | 0, A = A + Math.imul(oe, je) | 0;
      var pi = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (pi >>> 26) | 0, pi &= 67108863, E = Math.imul(ke, tt), m = Math.imul(ke, Ue), m = m + Math.imul(Ce, tt) | 0, A = Math.imul(Ce, Ue), E = E + Math.imul(ce, rt) | 0, m = m + Math.imul(ce, Ke) | 0, m = m + Math.imul(ve, rt) | 0, A = A + Math.imul(ve, Ke) | 0, E = E + Math.imul(F, it) | 0, m = m + Math.imul(F, $e) | 0, m = m + Math.imul(ue, it) | 0, A = A + Math.imul(ue, $e) | 0, E = E + Math.imul(x, vt) | 0, m = m + Math.imul(x, Fe) | 0, m = m + Math.imul(L, vt) | 0, A = A + Math.imul(L, Fe) | 0, E = E + Math.imul(de, nt) | 0, m = m + Math.imul(de, ze) | 0, m = m + Math.imul(Ae, nt) | 0, A = A + Math.imul(Ae, ze) | 0, E = E + Math.imul(be, ot) | 0, m = m + Math.imul(be, Xe) | 0, m = m + Math.imul(Y, ot) | 0, A = A + Math.imul(Y, Xe) | 0, E = E + Math.imul(W, Ze) | 0, m = m + Math.imul(W, je) | 0, m = m + Math.imul(Q, Ze) | 0, A = A + Math.imul(Q, je) | 0, E = E + Math.imul(X, St) | 0, m = m + Math.imul(X, Qe) | 0, m = m + Math.imul(oe, St) | 0, A = A + Math.imul(oe, Qe) | 0;
      var yi = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (yi >>> 26) | 0, yi &= 67108863, E = Math.imul(Oe, tt), m = Math.imul(Oe, Ue), m = m + Math.imul(Pe, tt) | 0, A = Math.imul(Pe, Ue), E = E + Math.imul(ke, rt) | 0, m = m + Math.imul(ke, Ke) | 0, m = m + Math.imul(Ce, rt) | 0, A = A + Math.imul(Ce, Ke) | 0, E = E + Math.imul(ce, it) | 0, m = m + Math.imul(ce, $e) | 0, m = m + Math.imul(ve, it) | 0, A = A + Math.imul(ve, $e) | 0, E = E + Math.imul(F, vt) | 0, m = m + Math.imul(F, Fe) | 0, m = m + Math.imul(ue, vt) | 0, A = A + Math.imul(ue, Fe) | 0, E = E + Math.imul(x, nt) | 0, m = m + Math.imul(x, ze) | 0, m = m + Math.imul(L, nt) | 0, A = A + Math.imul(L, ze) | 0, E = E + Math.imul(de, ot) | 0, m = m + Math.imul(de, Xe) | 0, m = m + Math.imul(Ae, ot) | 0, A = A + Math.imul(Ae, Xe) | 0, E = E + Math.imul(be, Ze) | 0, m = m + Math.imul(be, je) | 0, m = m + Math.imul(Y, Ze) | 0, A = A + Math.imul(Y, je) | 0, E = E + Math.imul(W, St) | 0, m = m + Math.imul(W, Qe) | 0, m = m + Math.imul(Q, St) | 0, A = A + Math.imul(Q, Qe) | 0, E = E + Math.imul(X, It) | 0, m = m + Math.imul(X, Je) | 0, m = m + Math.imul(oe, It) | 0, A = A + Math.imul(oe, Je) | 0;
      var mi = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (mi >>> 26) | 0, mi &= 67108863, E = Math.imul(Ye, tt), m = Math.imul(Ye, Ue), m = m + Math.imul(Ne, tt) | 0, A = Math.imul(Ne, Ue), E = E + Math.imul(Oe, rt) | 0, m = m + Math.imul(Oe, Ke) | 0, m = m + Math.imul(Pe, rt) | 0, A = A + Math.imul(Pe, Ke) | 0, E = E + Math.imul(ke, it) | 0, m = m + Math.imul(ke, $e) | 0, m = m + Math.imul(Ce, it) | 0, A = A + Math.imul(Ce, $e) | 0, E = E + Math.imul(ce, vt) | 0, m = m + Math.imul(ce, Fe) | 0, m = m + Math.imul(ve, vt) | 0, A = A + Math.imul(ve, Fe) | 0, E = E + Math.imul(F, nt) | 0, m = m + Math.imul(F, ze) | 0, m = m + Math.imul(ue, nt) | 0, A = A + Math.imul(ue, ze) | 0, E = E + Math.imul(x, ot) | 0, m = m + Math.imul(x, Xe) | 0, m = m + Math.imul(L, ot) | 0, A = A + Math.imul(L, Xe) | 0, E = E + Math.imul(de, Ze) | 0, m = m + Math.imul(de, je) | 0, m = m + Math.imul(Ae, Ze) | 0, A = A + Math.imul(Ae, je) | 0, E = E + Math.imul(be, St) | 0, m = m + Math.imul(be, Qe) | 0, m = m + Math.imul(Y, St) | 0, A = A + Math.imul(Y, Qe) | 0, E = E + Math.imul(W, It) | 0, m = m + Math.imul(W, Je) | 0, m = m + Math.imul(Q, It) | 0, A = A + Math.imul(Q, Je) | 0, E = E + Math.imul(X, At) | 0, m = m + Math.imul(X, Bt) | 0, m = m + Math.imul(oe, At) | 0, A = A + Math.imul(oe, Bt) | 0;
      var gi = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (gi >>> 26) | 0, gi &= 67108863, E = Math.imul(Ye, rt), m = Math.imul(Ye, Ke), m = m + Math.imul(Ne, rt) | 0, A = Math.imul(Ne, Ke), E = E + Math.imul(Oe, it) | 0, m = m + Math.imul(Oe, $e) | 0, m = m + Math.imul(Pe, it) | 0, A = A + Math.imul(Pe, $e) | 0, E = E + Math.imul(ke, vt) | 0, m = m + Math.imul(ke, Fe) | 0, m = m + Math.imul(Ce, vt) | 0, A = A + Math.imul(Ce, Fe) | 0, E = E + Math.imul(ce, nt) | 0, m = m + Math.imul(ce, ze) | 0, m = m + Math.imul(ve, nt) | 0, A = A + Math.imul(ve, ze) | 0, E = E + Math.imul(F, ot) | 0, m = m + Math.imul(F, Xe) | 0, m = m + Math.imul(ue, ot) | 0, A = A + Math.imul(ue, Xe) | 0, E = E + Math.imul(x, Ze) | 0, m = m + Math.imul(x, je) | 0, m = m + Math.imul(L, Ze) | 0, A = A + Math.imul(L, je) | 0, E = E + Math.imul(de, St) | 0, m = m + Math.imul(de, Qe) | 0, m = m + Math.imul(Ae, St) | 0, A = A + Math.imul(Ae, Qe) | 0, E = E + Math.imul(be, It) | 0, m = m + Math.imul(be, Je) | 0, m = m + Math.imul(Y, It) | 0, A = A + Math.imul(Y, Je) | 0, E = E + Math.imul(W, At) | 0, m = m + Math.imul(W, Bt) | 0, m = m + Math.imul(Q, At) | 0, A = A + Math.imul(Q, Bt) | 0;
      var vi = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (vi >>> 26) | 0, vi &= 67108863, E = Math.imul(Ye, it), m = Math.imul(Ye, $e), m = m + Math.imul(Ne, it) | 0, A = Math.imul(Ne, $e), E = E + Math.imul(Oe, vt) | 0, m = m + Math.imul(Oe, Fe) | 0, m = m + Math.imul(Pe, vt) | 0, A = A + Math.imul(Pe, Fe) | 0, E = E + Math.imul(ke, nt) | 0, m = m + Math.imul(ke, ze) | 0, m = m + Math.imul(Ce, nt) | 0, A = A + Math.imul(Ce, ze) | 0, E = E + Math.imul(ce, ot) | 0, m = m + Math.imul(ce, Xe) | 0, m = m + Math.imul(ve, ot) | 0, A = A + Math.imul(ve, Xe) | 0, E = E + Math.imul(F, Ze) | 0, m = m + Math.imul(F, je) | 0, m = m + Math.imul(ue, Ze) | 0, A = A + Math.imul(ue, je) | 0, E = E + Math.imul(x, St) | 0, m = m + Math.imul(x, Qe) | 0, m = m + Math.imul(L, St) | 0, A = A + Math.imul(L, Qe) | 0, E = E + Math.imul(de, It) | 0, m = m + Math.imul(de, Je) | 0, m = m + Math.imul(Ae, It) | 0, A = A + Math.imul(Ae, Je) | 0, E = E + Math.imul(be, At) | 0, m = m + Math.imul(be, Bt) | 0, m = m + Math.imul(Y, At) | 0, A = A + Math.imul(Y, Bt) | 0;
      var Nn = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (Nn >>> 26) | 0, Nn &= 67108863, E = Math.imul(Ye, vt), m = Math.imul(Ye, Fe), m = m + Math.imul(Ne, vt) | 0, A = Math.imul(Ne, Fe), E = E + Math.imul(Oe, nt) | 0, m = m + Math.imul(Oe, ze) | 0, m = m + Math.imul(Pe, nt) | 0, A = A + Math.imul(Pe, ze) | 0, E = E + Math.imul(ke, ot) | 0, m = m + Math.imul(ke, Xe) | 0, m = m + Math.imul(Ce, ot) | 0, A = A + Math.imul(Ce, Xe) | 0, E = E + Math.imul(ce, Ze) | 0, m = m + Math.imul(ce, je) | 0, m = m + Math.imul(ve, Ze) | 0, A = A + Math.imul(ve, je) | 0, E = E + Math.imul(F, St) | 0, m = m + Math.imul(F, Qe) | 0, m = m + Math.imul(ue, St) | 0, A = A + Math.imul(ue, Qe) | 0, E = E + Math.imul(x, It) | 0, m = m + Math.imul(x, Je) | 0, m = m + Math.imul(L, It) | 0, A = A + Math.imul(L, Je) | 0, E = E + Math.imul(de, At) | 0, m = m + Math.imul(de, Bt) | 0, m = m + Math.imul(Ae, At) | 0, A = A + Math.imul(Ae, Bt) | 0;
      var Dn = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (Dn >>> 26) | 0, Dn &= 67108863, E = Math.imul(Ye, nt), m = Math.imul(Ye, ze), m = m + Math.imul(Ne, nt) | 0, A = Math.imul(Ne, ze), E = E + Math.imul(Oe, ot) | 0, m = m + Math.imul(Oe, Xe) | 0, m = m + Math.imul(Pe, ot) | 0, A = A + Math.imul(Pe, Xe) | 0, E = E + Math.imul(ke, Ze) | 0, m = m + Math.imul(ke, je) | 0, m = m + Math.imul(Ce, Ze) | 0, A = A + Math.imul(Ce, je) | 0, E = E + Math.imul(ce, St) | 0, m = m + Math.imul(ce, Qe) | 0, m = m + Math.imul(ve, St) | 0, A = A + Math.imul(ve, Qe) | 0, E = E + Math.imul(F, It) | 0, m = m + Math.imul(F, Je) | 0, m = m + Math.imul(ue, It) | 0, A = A + Math.imul(ue, Je) | 0, E = E + Math.imul(x, At) | 0, m = m + Math.imul(x, Bt) | 0, m = m + Math.imul(L, At) | 0, A = A + Math.imul(L, Bt) | 0;
      var eM = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (eM >>> 26) | 0, eM &= 67108863, E = Math.imul(Ye, ot), m = Math.imul(Ye, Xe), m = m + Math.imul(Ne, ot) | 0, A = Math.imul(Ne, Xe), E = E + Math.imul(Oe, Ze) | 0, m = m + Math.imul(Oe, je) | 0, m = m + Math.imul(Pe, Ze) | 0, A = A + Math.imul(Pe, je) | 0, E = E + Math.imul(ke, St) | 0, m = m + Math.imul(ke, Qe) | 0, m = m + Math.imul(Ce, St) | 0, A = A + Math.imul(Ce, Qe) | 0, E = E + Math.imul(ce, It) | 0, m = m + Math.imul(ce, Je) | 0, m = m + Math.imul(ve, It) | 0, A = A + Math.imul(ve, Je) | 0, E = E + Math.imul(F, At) | 0, m = m + Math.imul(F, Bt) | 0, m = m + Math.imul(ue, At) | 0, A = A + Math.imul(ue, Bt) | 0;
      var tM = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (tM >>> 26) | 0, tM &= 67108863, E = Math.imul(Ye, Ze), m = Math.imul(Ye, je), m = m + Math.imul(Ne, Ze) | 0, A = Math.imul(Ne, je), E = E + Math.imul(Oe, St) | 0, m = m + Math.imul(Oe, Qe) | 0, m = m + Math.imul(Pe, St) | 0, A = A + Math.imul(Pe, Qe) | 0, E = E + Math.imul(ke, It) | 0, m = m + Math.imul(ke, Je) | 0, m = m + Math.imul(Ce, It) | 0, A = A + Math.imul(Ce, Je) | 0, E = E + Math.imul(ce, At) | 0, m = m + Math.imul(ce, Bt) | 0, m = m + Math.imul(ve, At) | 0, A = A + Math.imul(ve, Bt) | 0;
      var rM = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (rM >>> 26) | 0, rM &= 67108863, E = Math.imul(Ye, St), m = Math.imul(Ye, Qe), m = m + Math.imul(Ne, St) | 0, A = Math.imul(Ne, Qe), E = E + Math.imul(Oe, It) | 0, m = m + Math.imul(Oe, Je) | 0, m = m + Math.imul(Pe, It) | 0, A = A + Math.imul(Pe, Je) | 0, E = E + Math.imul(ke, At) | 0, m = m + Math.imul(ke, Bt) | 0, m = m + Math.imul(Ce, At) | 0, A = A + Math.imul(Ce, Bt) | 0;
      var iM = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (iM >>> 26) | 0, iM &= 67108863, E = Math.imul(Ye, It), m = Math.imul(Ye, Je), m = m + Math.imul(Ne, It) | 0, A = Math.imul(Ne, Je), E = E + Math.imul(Oe, At) | 0, m = m + Math.imul(Oe, Bt) | 0, m = m + Math.imul(Pe, At) | 0, A = A + Math.imul(Pe, Bt) | 0;
      var nM = (_ + E | 0) + ((m & 8191) << 13) | 0;
      _ = (A + (m >>> 13) | 0) + (nM >>> 26) | 0, nM &= 67108863, E = Math.imul(Ye, At), m = Math.imul(Ye, Bt), m = m + Math.imul(Ne, At) | 0, A = Math.imul(Ne, Bt);
      var oM = (_ + E | 0) + ((m & 8191) << 13) | 0;
      return _ = (A + (m >>> 13) | 0) + (oM >>> 26) | 0, oM &= 67108863, S[0] = ui, S[1] = fi, S[2] = hi, S[3] = ci, S[4] = li, S[5] = di, S[6] = pi, S[7] = yi, S[8] = mi, S[9] = gi, S[10] = vi, S[11] = Nn, S[12] = Dn, S[13] = eM, S[14] = tM, S[15] = rM, S[16] = iM, S[17] = nM, S[18] = oM, _ !== 0 && (S[19] = _, v.length++), v;
    };
    Math.imul || (U = j);
    function H(f, y, v) {
      v.negative = y.negative ^ f.negative, v.length = f.length + y.length;
      for (var M = 0, B = 0, S = 0; S < v.length - 1; S++) {
        var _ = B;
        B = 0;
        for (var E = M & 67108863, m = Math.min(S, y.length - 1), A = Math.max(0, S - f.length + 1); A <= m; A++) {
          var $ = S - A, X = f.words[$] | 0, oe = y.words[A] | 0, J = X * oe, W = J & 67108863;
          _ = _ + (J / 67108864 | 0) | 0, W = W + E | 0, E = W & 67108863, _ = _ + (W >>> 26) | 0, B += _ >>> 26, _ &= 67108863;
        }
        v.words[S] = E, M = _, _ = B;
      }
      return M !== 0 ? v.words[S] = M : v.length--, v._strip();
    }
    function z(f, y, v) {
      return H(f, y, v);
    }
    a.prototype.mulTo = function(f, y) {
      var v, M = this.length + f.length;
      return this.length === 10 && f.length === 10 ? v = U(this, f, y) : M < 63 ? v = j(this, f, y) : M < 1024 ? v = H(this, f, y) : v = z(this, f, y), v;
    }, a.prototype.mul = function(f) {
      var y = new a(null);
      return y.words = new Array(this.length + f.length), this.mulTo(f, y);
    }, a.prototype.mulf = function(f) {
      var y = new a(null);
      return y.words = new Array(this.length + f.length), z(this, f, y);
    }, a.prototype.imul = function(f) {
      return this.clone().mulTo(f, this);
    }, a.prototype.imuln = function(f) {
      var y = f < 0;
      y && (f = -f), r(typeof f == "number"), r(f < 67108864);
      for (var v = 0, M = 0; M < this.length; M++) {
        var B = (this.words[M] | 0) * f, S = (B & 67108863) + (v & 67108863);
        v >>= 26, v += B / 67108864 | 0, v += S >>> 26, this.words[M] = S & 67108863;
      }
      return v !== 0 && (this.words[M] = v, this.length++), y ? this.ineg() : this;
    }, a.prototype.muln = function(f) {
      return this.clone().imuln(f);
    }, a.prototype.sqr = function() {
      return this.mul(this);
    }, a.prototype.isqr = function() {
      return this.imul(this.clone());
    }, a.prototype.pow = function(f) {
      var y = N(f);
      if (y.length === 0)
        return new a(1);
      for (var v = this, M = 0; M < y.length && y[M] === 0; M++, v = v.sqr())
        ;
      if (++M < y.length)
        for (var B = v.sqr(); M < y.length; M++, B = B.sqr())
          y[M] !== 0 && (v = v.mul(B));
      return v;
    }, a.prototype.iushln = function(f) {
      r(typeof f == "number" && f >= 0);
      var y = f % 26, v = (f - y) / 26, M = 67108863 >>> 26 - y << 26 - y, B;
      if (y !== 0) {
        var S = 0;
        for (B = 0; B < this.length; B++) {
          var _ = this.words[B] & M, E = (this.words[B] | 0) - _ << y;
          this.words[B] = E | S, S = _ >>> 26 - y;
        }
        S && (this.words[B] = S, this.length++);
      }
      if (v !== 0) {
        for (B = this.length - 1; B >= 0; B--)
          this.words[B + v] = this.words[B];
        for (B = 0; B < v; B++)
          this.words[B] = 0;
        this.length += v;
      }
      return this._strip();
    }, a.prototype.ishln = function(f) {
      return r(this.negative === 0), this.iushln(f);
    }, a.prototype.iushrn = function(f, y, v) {
      r(typeof f == "number" && f >= 0);
      var M;
      y ? M = (y - y % 26) / 26 : M = 0;
      var B = f % 26, S = Math.min((f - B) / 26, this.length), _ = 67108863 ^ 67108863 >>> B << B, E = v;
      if (M -= S, M = Math.max(0, M), E) {
        for (var m = 0; m < S; m++)
          E.words[m] = this.words[m];
        E.length = S;
      }
      if (S !== 0)
        if (this.length > S)
          for (this.length -= S, m = 0; m < this.length; m++)
            this.words[m] = this.words[m + S];
        else
          this.words[0] = 0, this.length = 1;
      var A = 0;
      for (m = this.length - 1; m >= 0 && (A !== 0 || m >= M); m--) {
        var $ = this.words[m] | 0;
        this.words[m] = A << 26 - B | $ >>> B, A = $ & _;
      }
      return E && A !== 0 && (E.words[E.length++] = A), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, a.prototype.ishrn = function(f, y, v) {
      return r(this.negative === 0), this.iushrn(f, y, v);
    }, a.prototype.shln = function(f) {
      return this.clone().ishln(f);
    }, a.prototype.ushln = function(f) {
      return this.clone().iushln(f);
    }, a.prototype.shrn = function(f) {
      return this.clone().ishrn(f);
    }, a.prototype.ushrn = function(f) {
      return this.clone().iushrn(f);
    }, a.prototype.testn = function(f) {
      r(typeof f == "number" && f >= 0);
      var y = f % 26, v = (f - y) / 26, M = 1 << y;
      if (this.length <= v)
        return !1;
      var B = this.words[v];
      return !!(B & M);
    }, a.prototype.imaskn = function(f) {
      r(typeof f == "number" && f >= 0);
      var y = f % 26, v = (f - y) / 26;
      if (r(this.negative === 0, "imaskn works only with positive numbers"), this.length <= v)
        return this;
      if (y !== 0 && v++, this.length = Math.min(v, this.length), y !== 0) {
        var M = 67108863 ^ 67108863 >>> y << y;
        this.words[this.length - 1] &= M;
      }
      return this._strip();
    }, a.prototype.maskn = function(f) {
      return this.clone().imaskn(f);
    }, a.prototype.iaddn = function(f) {
      return r(typeof f == "number"), r(f < 67108864), f < 0 ? this.isubn(-f) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= f ? (this.words[0] = f - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(f), this.negative = 1, this) : this._iaddn(f);
    }, a.prototype._iaddn = function(f) {
      this.words[0] += f;
      for (var y = 0; y < this.length && this.words[y] >= 67108864; y++)
        this.words[y] -= 67108864, y === this.length - 1 ? this.words[y + 1] = 1 : this.words[y + 1]++;
      return this.length = Math.max(this.length, y + 1), this;
    }, a.prototype.isubn = function(f) {
      if (r(typeof f == "number"), r(f < 67108864), f < 0)
        return this.iaddn(-f);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(f), this.negative = 1, this;
      if (this.words[0] -= f, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var y = 0; y < this.length && this.words[y] < 0; y++)
          this.words[y] += 67108864, this.words[y + 1] -= 1;
      return this._strip();
    }, a.prototype.addn = function(f) {
      return this.clone().iaddn(f);
    }, a.prototype.subn = function(f) {
      return this.clone().isubn(f);
    }, a.prototype.iabs = function() {
      return this.negative = 0, this;
    }, a.prototype.abs = function() {
      return this.clone().iabs();
    }, a.prototype._ishlnsubmul = function(f, y, v) {
      var M = f.length + v, B;
      this._expand(M);
      var S, _ = 0;
      for (B = 0; B < f.length; B++) {
        S = (this.words[B + v] | 0) + _;
        var E = (f.words[B] | 0) * y;
        S -= E & 67108863, _ = (S >> 26) - (E / 67108864 | 0), this.words[B + v] = S & 67108863;
      }
      for (; B < this.length - v; B++)
        S = (this.words[B + v] | 0) + _, _ = S >> 26, this.words[B + v] = S & 67108863;
      if (_ === 0)
        return this._strip();
      for (r(_ === -1), _ = 0, B = 0; B < this.length; B++)
        S = -(this.words[B] | 0) + _, _ = S >> 26, this.words[B] = S & 67108863;
      return this.negative = 1, this._strip();
    }, a.prototype._wordDiv = function(f, y) {
      var v = this.length - f.length, M = this.clone(), B = f, S = B.words[B.length - 1] | 0, _ = this._countBits(S);
      v = 26 - _, v !== 0 && (B = B.ushln(v), M.iushln(v), S = B.words[B.length - 1] | 0);
      var E = M.length - B.length, m;
      if (y !== "mod") {
        m = new a(null), m.length = E + 1, m.words = new Array(m.length);
        for (var A = 0; A < m.length; A++)
          m.words[A] = 0;
      }
      var $ = M.clone()._ishlnsubmul(B, 1, E);
      $.negative === 0 && (M = $, m && (m.words[E] = 1));
      for (var X = E - 1; X >= 0; X--) {
        var oe = (M.words[B.length + X] | 0) * 67108864 + (M.words[B.length + X - 1] | 0);
        for (oe = Math.min(oe / S | 0, 67108863), M._ishlnsubmul(B, oe, X); M.negative !== 0; )
          oe--, M.negative = 0, M._ishlnsubmul(B, 1, X), M.isZero() || (M.negative ^= 1);
        m && (m.words[X] = oe);
      }
      return m && m._strip(), M._strip(), y !== "div" && v !== 0 && M.iushrn(v), {
        div: m || null,
        mod: M
      };
    }, a.prototype.divmod = function(f, y, v) {
      if (r(!f.isZero()), this.isZero())
        return {
          div: new a(0),
          mod: new a(0)
        };
      var M, B, S;
      return this.negative !== 0 && f.negative === 0 ? (S = this.neg().divmod(f, y), y !== "mod" && (M = S.div.neg()), y !== "div" && (B = S.mod.neg(), v && B.negative !== 0 && B.iadd(f)), {
        div: M,
        mod: B
      }) : this.negative === 0 && f.negative !== 0 ? (S = this.divmod(f.neg(), y), y !== "mod" && (M = S.div.neg()), {
        div: M,
        mod: S.mod
      }) : this.negative & f.negative ? (S = this.neg().divmod(f.neg(), y), y !== "div" && (B = S.mod.neg(), v && B.negative !== 0 && B.isub(f)), {
        div: S.div,
        mod: B
      }) : f.length > this.length || this.cmp(f) < 0 ? {
        div: new a(0),
        mod: this
      } : f.length === 1 ? y === "div" ? {
        div: this.divn(f.words[0]),
        mod: null
      } : y === "mod" ? {
        div: null,
        mod: new a(this.modrn(f.words[0]))
      } : {
        div: this.divn(f.words[0]),
        mod: new a(this.modrn(f.words[0]))
      } : this._wordDiv(f, y);
    }, a.prototype.div = function(f) {
      return this.divmod(f, "div", !1).div;
    }, a.prototype.mod = function(f) {
      return this.divmod(f, "mod", !1).mod;
    }, a.prototype.umod = function(f) {
      return this.divmod(f, "mod", !0).mod;
    }, a.prototype.divRound = function(f) {
      var y = this.divmod(f);
      if (y.mod.isZero())
        return y.div;
      var v = y.div.negative !== 0 ? y.mod.isub(f) : y.mod, M = f.ushrn(1), B = f.andln(1), S = v.cmp(M);
      return S < 0 || B === 1 && S === 0 ? y.div : y.div.negative !== 0 ? y.div.isubn(1) : y.div.iaddn(1);
    }, a.prototype.modrn = function(f) {
      var y = f < 0;
      y && (f = -f), r(f <= 67108863);
      for (var v = (1 << 26) % f, M = 0, B = this.length - 1; B >= 0; B--)
        M = (v * M + (this.words[B] | 0)) % f;
      return y ? -M : M;
    }, a.prototype.modn = function(f) {
      return this.modrn(f);
    }, a.prototype.idivn = function(f) {
      var y = f < 0;
      y && (f = -f), r(f <= 67108863);
      for (var v = 0, M = this.length - 1; M >= 0; M--) {
        var B = (this.words[M] | 0) + v * 67108864;
        this.words[M] = B / f | 0, v = B % f;
      }
      return this._strip(), y ? this.ineg() : this;
    }, a.prototype.divn = function(f) {
      return this.clone().idivn(f);
    }, a.prototype.egcd = function(f) {
      r(f.negative === 0), r(!f.isZero());
      var y = this, v = f.clone();
      y.negative !== 0 ? y = y.umod(f) : y = y.clone();
      for (var M = new a(1), B = new a(0), S = new a(0), _ = new a(1), E = 0; y.isEven() && v.isEven(); )
        y.iushrn(1), v.iushrn(1), ++E;
      for (var m = v.clone(), A = y.clone(); !y.isZero(); ) {
        for (var $ = 0, X = 1; !(y.words[0] & X) && $ < 26; ++$, X <<= 1)
          ;
        if ($ > 0)
          for (y.iushrn($); $-- > 0; )
            (M.isOdd() || B.isOdd()) && (M.iadd(m), B.isub(A)), M.iushrn(1), B.iushrn(1);
        for (var oe = 0, J = 1; !(v.words[0] & J) && oe < 26; ++oe, J <<= 1)
          ;
        if (oe > 0)
          for (v.iushrn(oe); oe-- > 0; )
            (S.isOdd() || _.isOdd()) && (S.iadd(m), _.isub(A)), S.iushrn(1), _.iushrn(1);
        y.cmp(v) >= 0 ? (y.isub(v), M.isub(S), B.isub(_)) : (v.isub(y), S.isub(M), _.isub(B));
      }
      return {
        a: S,
        b: _,
        gcd: v.iushln(E)
      };
    }, a.prototype._invmp = function(f) {
      r(f.negative === 0), r(!f.isZero());
      var y = this, v = f.clone();
      y.negative !== 0 ? y = y.umod(f) : y = y.clone();
      for (var M = new a(1), B = new a(0), S = v.clone(); y.cmpn(1) > 0 && v.cmpn(1) > 0; ) {
        for (var _ = 0, E = 1; !(y.words[0] & E) && _ < 26; ++_, E <<= 1)
          ;
        if (_ > 0)
          for (y.iushrn(_); _-- > 0; )
            M.isOdd() && M.iadd(S), M.iushrn(1);
        for (var m = 0, A = 1; !(v.words[0] & A) && m < 26; ++m, A <<= 1)
          ;
        if (m > 0)
          for (v.iushrn(m); m-- > 0; )
            B.isOdd() && B.iadd(S), B.iushrn(1);
        y.cmp(v) >= 0 ? (y.isub(v), M.isub(B)) : (v.isub(y), B.isub(M));
      }
      var $;
      return y.cmpn(1) === 0 ? $ = M : $ = B, $.cmpn(0) < 0 && $.iadd(f), $;
    }, a.prototype.gcd = function(f) {
      if (this.isZero())
        return f.abs();
      if (f.isZero())
        return this.abs();
      var y = this.clone(), v = f.clone();
      y.negative = 0, v.negative = 0;
      for (var M = 0; y.isEven() && v.isEven(); M++)
        y.iushrn(1), v.iushrn(1);
      do {
        for (; y.isEven(); )
          y.iushrn(1);
        for (; v.isEven(); )
          v.iushrn(1);
        var B = y.cmp(v);
        if (B < 0) {
          var S = y;
          y = v, v = S;
        } else if (B === 0 || v.cmpn(1) === 0)
          break;
        y.isub(v);
      } while (!0);
      return v.iushln(M);
    }, a.prototype.invm = function(f) {
      return this.egcd(f).a.umod(f);
    }, a.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, a.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, a.prototype.andln = function(f) {
      return this.words[0] & f;
    }, a.prototype.bincn = function(f) {
      r(typeof f == "number");
      var y = f % 26, v = (f - y) / 26, M = 1 << y;
      if (this.length <= v)
        return this._expand(v + 1), this.words[v] |= M, this;
      for (var B = M, S = v; B !== 0 && S < this.length; S++) {
        var _ = this.words[S] | 0;
        _ += B, B = _ >>> 26, _ &= 67108863, this.words[S] = _;
      }
      return B !== 0 && (this.words[S] = B, this.length++), this;
    }, a.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, a.prototype.cmpn = function(f) {
      var y = f < 0;
      if (this.negative !== 0 && !y)
        return -1;
      if (this.negative === 0 && y)
        return 1;
      this._strip();
      var v;
      if (this.length > 1)
        v = 1;
      else {
        y && (f = -f), r(f <= 67108863, "Number is too big");
        var M = this.words[0] | 0;
        v = M === f ? 0 : M < f ? -1 : 1;
      }
      return this.negative !== 0 ? -v | 0 : v;
    }, a.prototype.cmp = function(f) {
      if (this.negative !== 0 && f.negative === 0)
        return -1;
      if (this.negative === 0 && f.negative !== 0)
        return 1;
      var y = this.ucmp(f);
      return this.negative !== 0 ? -y | 0 : y;
    }, a.prototype.ucmp = function(f) {
      if (this.length > f.length)
        return 1;
      if (this.length < f.length)
        return -1;
      for (var y = 0, v = this.length - 1; v >= 0; v--) {
        var M = this.words[v] | 0, B = f.words[v] | 0;
        if (M !== B) {
          M < B ? y = -1 : M > B && (y = 1);
          break;
        }
      }
      return y;
    }, a.prototype.gtn = function(f) {
      return this.cmpn(f) === 1;
    }, a.prototype.gt = function(f) {
      return this.cmp(f) === 1;
    }, a.prototype.gten = function(f) {
      return this.cmpn(f) >= 0;
    }, a.prototype.gte = function(f) {
      return this.cmp(f) >= 0;
    }, a.prototype.ltn = function(f) {
      return this.cmpn(f) === -1;
    }, a.prototype.lt = function(f) {
      return this.cmp(f) === -1;
    }, a.prototype.lten = function(f) {
      return this.cmpn(f) <= 0;
    }, a.prototype.lte = function(f) {
      return this.cmp(f) <= 0;
    }, a.prototype.eqn = function(f) {
      return this.cmpn(f) === 0;
    }, a.prototype.eq = function(f) {
      return this.cmp(f) === 0;
    }, a.red = function(f) {
      return new I(f);
    }, a.prototype.toRed = function(f) {
      return r(!this.red, "Already a number in reduction context"), r(this.negative === 0, "red works only with positives"), f.convertTo(this)._forceRed(f);
    }, a.prototype.fromRed = function() {
      return r(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, a.prototype._forceRed = function(f) {
      return this.red = f, this;
    }, a.prototype.forceRed = function(f) {
      return r(!this.red, "Already a number in reduction context"), this._forceRed(f);
    }, a.prototype.redAdd = function(f) {
      return r(this.red, "redAdd works only with red numbers"), this.red.add(this, f);
    }, a.prototype.redIAdd = function(f) {
      return r(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, f);
    }, a.prototype.redSub = function(f) {
      return r(this.red, "redSub works only with red numbers"), this.red.sub(this, f);
    }, a.prototype.redISub = function(f) {
      return r(this.red, "redISub works only with red numbers"), this.red.isub(this, f);
    }, a.prototype.redShl = function(f) {
      return r(this.red, "redShl works only with red numbers"), this.red.shl(this, f);
    }, a.prototype.redMul = function(f) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.mul(this, f);
    }, a.prototype.redIMul = function(f) {
      return r(this.red, "redMul works only with red numbers"), this.red._verify2(this, f), this.red.imul(this, f);
    }, a.prototype.redSqr = function() {
      return r(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, a.prototype.redISqr = function() {
      return r(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, a.prototype.redSqrt = function() {
      return r(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, a.prototype.redInvm = function() {
      return r(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, a.prototype.redNeg = function() {
      return r(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, a.prototype.redPow = function(f) {
      return r(this.red && !f.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, f);
    };
    var ee = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function ne(f, y) {
      this.name = f, this.p = new a(y, 16), this.n = this.p.bitLength(), this.k = new a(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    ne.prototype._tmp = function() {
      var f = new a(null);
      return f.words = new Array(Math.ceil(this.n / 13)), f;
    }, ne.prototype.ireduce = function(f) {
      var y = f, v;
      do
        this.split(y, this.tmp), y = this.imulK(y), y = y.iadd(this.tmp), v = y.bitLength();
      while (v > this.n);
      var M = v < this.n ? -1 : y.ucmp(this.p);
      return M === 0 ? (y.words[0] = 0, y.length = 1) : M > 0 ? y.isub(this.p) : y.strip !== void 0 ? y.strip() : y._strip(), y;
    }, ne.prototype.split = function(f, y) {
      f.iushrn(this.n, 0, y);
    }, ne.prototype.imulK = function(f) {
      return f.imul(this.k);
    };
    function le() {
      ne.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    h(le, ne), le.prototype.split = function(f, y) {
      for (var v = 4194303, M = Math.min(f.length, 9), B = 0; B < M; B++)
        y.words[B] = f.words[B];
      if (y.length = M, f.length <= 9) {
        f.words[0] = 0, f.length = 1;
        return;
      }
      var S = f.words[9];
      for (y.words[y.length++] = S & v, B = 10; B < f.length; B++) {
        var _ = f.words[B] | 0;
        f.words[B - 10] = (_ & v) << 4 | S >>> 22, S = _;
      }
      S >>>= 22, f.words[B - 10] = S, S === 0 && f.length > 10 ? f.length -= 10 : f.length -= 9;
    }, le.prototype.imulK = function(f) {
      f.words[f.length] = 0, f.words[f.length + 1] = 0, f.length += 2;
      for (var y = 0, v = 0; v < f.length; v++) {
        var M = f.words[v] | 0;
        y += M * 977, f.words[v] = y & 67108863, y = M * 64 + (y / 67108864 | 0);
      }
      return f.words[f.length - 1] === 0 && (f.length--, f.words[f.length - 1] === 0 && f.length--), f;
    };
    function Z() {
      ne.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    h(Z, ne);
    function ie() {
      ne.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    h(ie, ne);
    function fe() {
      ne.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    h(fe, ne), fe.prototype.imulK = function(f) {
      for (var y = 0, v = 0; v < f.length; v++) {
        var M = (f.words[v] | 0) * 19 + y, B = M & 67108863;
        M >>>= 26, f.words[v] = B, y = M;
      }
      return y !== 0 && (f.words[f.length++] = y), f;
    }, a._prime = function(f) {
      if (ee[f])
        return ee[f];
      var y;
      if (f === "k256")
        y = new le();
      else if (f === "p224")
        y = new Z();
      else if (f === "p192")
        y = new ie();
      else if (f === "p25519")
        y = new fe();
      else
        throw new Error("Unknown prime " + f);
      return ee[f] = y, y;
    };
    function I(f) {
      if (typeof f == "string") {
        var y = a._prime(f);
        this.m = y.p, this.prime = y;
      } else
        r(f.gtn(1), "modulus must be greater than 1"), this.m = f, this.prime = null;
    }
    I.prototype._verify1 = function(f) {
      r(f.negative === 0, "red works only with positives"), r(f.red, "red works only with red numbers");
    }, I.prototype._verify2 = function(f, y) {
      r((f.negative | y.negative) === 0, "red works only with positives"), r(
        f.red && f.red === y.red,
        "red works only with red numbers"
      );
    }, I.prototype.imod = function(f) {
      return this.prime ? this.prime.ireduce(f)._forceRed(this) : (w(f, f.umod(this.m)._forceRed(this)), f);
    }, I.prototype.neg = function(f) {
      return f.isZero() ? f.clone() : this.m.sub(f)._forceRed(this);
    }, I.prototype.add = function(f, y) {
      this._verify2(f, y);
      var v = f.add(y);
      return v.cmp(this.m) >= 0 && v.isub(this.m), v._forceRed(this);
    }, I.prototype.iadd = function(f, y) {
      this._verify2(f, y);
      var v = f.iadd(y);
      return v.cmp(this.m) >= 0 && v.isub(this.m), v;
    }, I.prototype.sub = function(f, y) {
      this._verify2(f, y);
      var v = f.sub(y);
      return v.cmpn(0) < 0 && v.iadd(this.m), v._forceRed(this);
    }, I.prototype.isub = function(f, y) {
      this._verify2(f, y);
      var v = f.isub(y);
      return v.cmpn(0) < 0 && v.iadd(this.m), v;
    }, I.prototype.shl = function(f, y) {
      return this._verify1(f), this.imod(f.ushln(y));
    }, I.prototype.imul = function(f, y) {
      return this._verify2(f, y), this.imod(f.imul(y));
    }, I.prototype.mul = function(f, y) {
      return this._verify2(f, y), this.imod(f.mul(y));
    }, I.prototype.isqr = function(f) {
      return this.imul(f, f.clone());
    }, I.prototype.sqr = function(f) {
      return this.mul(f, f);
    }, I.prototype.sqrt = function(f) {
      if (f.isZero())
        return f.clone();
      var y = this.m.andln(3);
      if (r(y % 2 === 1), y === 3) {
        var v = this.m.add(new a(1)).iushrn(2);
        return this.pow(f, v);
      }
      for (var M = this.m.subn(1), B = 0; !M.isZero() && M.andln(1) === 0; )
        B++, M.iushrn(1);
      r(!M.isZero());
      var S = new a(1).toRed(this), _ = S.redNeg(), E = this.m.subn(1).iushrn(1), m = this.m.bitLength();
      for (m = new a(2 * m * m).toRed(this); this.pow(m, E).cmp(_) !== 0; )
        m.redIAdd(_);
      for (var A = this.pow(m, M), $ = this.pow(f, M.addn(1).iushrn(1)), X = this.pow(f, M), oe = B; X.cmp(S) !== 0; ) {
        for (var J = X, W = 0; J.cmp(S) !== 0; W++)
          J = J.redSqr();
        r(W < oe);
        var Q = this.pow(A, new a(1).iushln(oe - W - 1));
        $ = $.redMul(Q), A = Q.redSqr(), X = X.redMul(A), oe = W;
      }
      return $;
    }, I.prototype.invm = function(f) {
      var y = f._invmp(this.m);
      return y.negative !== 0 ? (y.negative = 0, this.imod(y).redNeg()) : this.imod(y);
    }, I.prototype.pow = function(f, y) {
      if (y.isZero())
        return new a(1).toRed(this);
      if (y.cmpn(1) === 0)
        return f.clone();
      var v = 4, M = new Array(1 << v);
      M[0] = new a(1).toRed(this), M[1] = f;
      for (var B = 2; B < M.length; B++)
        M[B] = this.mul(M[B - 1], f);
      var S = M[0], _ = 0, E = 0, m = y.bitLength() % 26;
      for (m === 0 && (m = 26), B = y.length - 1; B >= 0; B--) {
        for (var A = y.words[B], $ = m - 1; $ >= 0; $--) {
          var X = A >> $ & 1;
          if (S !== M[0] && (S = this.sqr(S)), X === 0 && _ === 0) {
            E = 0;
            continue;
          }
          _ <<= 1, _ |= X, E++, !(E !== v && (B !== 0 || $ !== 0)) && (S = this.mul(S, M[_]), E = 0, _ = 0);
        }
        m = 26;
      }
      return S;
    }, I.prototype.convertTo = function(f) {
      var y = f.umod(this.m);
      return y === f ? y.clone() : y;
    }, I.prototype.convertFrom = function(f) {
      var y = f.clone();
      return y.red = null, y;
    }, a.mont = function(f) {
      return new P(f);
    };
    function P(f) {
      I.call(this, f), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new a(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    h(P, I), P.prototype.convertTo = function(f) {
      return this.imod(f.ushln(this.shift));
    }, P.prototype.convertFrom = function(f) {
      var y = this.imod(f.mul(this.rinv));
      return y.red = null, y;
    }, P.prototype.imul = function(f, y) {
      if (f.isZero() || y.isZero())
        return f.words[0] = 0, f.length = 1, f;
      var v = f.imul(y), M = v.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), B = v.isub(M).iushrn(this.shift), S = B;
      return B.cmp(this.m) >= 0 ? S = B.isub(this.m) : B.cmpn(0) < 0 && (S = B.iadd(this.m)), S._forceRed(this);
    }, P.prototype.mul = function(f, y) {
      if (f.isZero() || y.isZero())
        return new a(0)._forceRed(this);
      var v = f.mul(y), M = v.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), B = v.isub(M).iushrn(this.shift), S = B;
      return B.cmp(this.m) >= 0 ? S = B.isub(this.m) : B.cmpn(0) < 0 && (S = B.iadd(this.m)), S._forceRed(this);
    }, P.prototype.invm = function(f) {
      var y = this.imod(f._invmp(this.m).mul(this.r2));
      return y._forceRed(this);
    };
  })(e, Me);
})(lh);
var by = lh.exports, Ai = {}, dh = {}, xy = {}, ph = {}, xs = pe, Sa = xs.Buffer, qr = {}, Vr;
for (Vr in xs)
  xs.hasOwnProperty(Vr) && (Vr === "SlowBuffer" || Vr === "Buffer" || (qr[Vr] = xs[Vr]));
var wa = qr.Buffer = {};
for (Vr in Sa)
  Sa.hasOwnProperty(Vr) && (Vr === "allocUnsafe" || Vr === "allocUnsafeSlow" || (wa[Vr] = Sa[Vr]));
qr.Buffer.prototype = Sa.prototype;
(!wa.from || wa.from === Uint8Array.from) && (wa.from = function(e, t, o) {
  if (typeof e == "number")
    throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof e);
  if (e && typeof e.length > "u")
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
  return Sa(e, t, o);
});
wa.alloc || (wa.alloc = function(e, t, o) {
  if (typeof e != "number")
    throw new TypeError('The "size" argument must be of type number. Received type ' + typeof e);
  if (e < 0 || e >= 2 * (1 << 30))
    throw new RangeError('The value "' + e + '" is invalid for option "size"');
  var r = Sa(e);
  return !t || t.length === 0 ? r.fill(0) : typeof o == "string" ? r.fill(t, o) : r.fill(t), r;
});
if (!qr.kStringMaxLength)
  try {
    qr.kStringMaxLength = Ve.binding("buffer").kStringMaxLength;
  } catch {
  }
qr.constants || (qr.constants = {
  MAX_LENGTH: qr.kMaxLength
}, qr.kStringMaxLength && (qr.constants.MAX_STRING_LENGTH = qr.kStringMaxLength));
var $0 = qr, wf = {};
const P8 = ut;
function ti(e) {
  this._reporterState = {
    obj: null,
    path: [],
    options: e || {},
    errors: []
  };
}
wf.Reporter = ti;
ti.prototype.isError = function(e) {
  return e instanceof Ra;
};
ti.prototype.save = function() {
  const e = this._reporterState;
  return { obj: e.obj, pathLen: e.path.length };
};
ti.prototype.restore = function(e) {
  const t = this._reporterState;
  t.obj = e.obj, t.path = t.path.slice(0, e.pathLen);
};
ti.prototype.enterKey = function(e) {
  return this._reporterState.path.push(e);
};
ti.prototype.exitKey = function(e) {
  const t = this._reporterState;
  t.path = t.path.slice(0, e - 1);
};
ti.prototype.leaveKey = function(e, t, o) {
  const r = this._reporterState;
  this.exitKey(e), r.obj !== null && (r.obj[t] = o);
};
ti.prototype.path = function() {
  return this._reporterState.path.join("/");
};
ti.prototype.enterObject = function() {
  const e = this._reporterState, t = e.obj;
  return e.obj = {}, t;
};
ti.prototype.leaveObject = function(e) {
  const t = this._reporterState, o = t.obj;
  return t.obj = e, o;
};
ti.prototype.error = function(e) {
  let t;
  const o = this._reporterState, r = e instanceof Ra;
  if (r ? t = e : t = new Ra(o.path.map(function(h) {
    return "[" + JSON.stringify(h) + "]";
  }).join(""), e.message || e, e.stack), !o.options.partial)
    throw t;
  return r || o.errors.push(t), t;
};
ti.prototype.wrapResult = function(e) {
  const t = this._reporterState;
  return t.options.partial ? {
    result: this.isError(e) ? null : e,
    errors: t.errors
  } : e;
};
function Ra(e, t) {
  this.path = e, this.rethrow(t);
}
P8(Ra, Error);
Ra.prototype.rethrow = function(e) {
  if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, Ra), !this.stack)
    try {
      throw new Error(this.message);
    } catch (t) {
      this.stack = t.stack;
    }
  return this;
};
var ea = {};
const L8 = ut, Cf = wf.Reporter, Na = $0.Buffer;
function Yr(e, t) {
  if (Cf.call(this, t), !Na.isBuffer(e)) {
    this.error("Input not Buffer");
    return;
  }
  this.base = e, this.offset = 0, this.length = e.length;
}
L8(Yr, Cf);
ea.DecoderBuffer = Yr;
Yr.isDecoderBuffer = function(e) {
  return e instanceof Yr ? !0 : typeof e == "object" && Na.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function";
};
Yr.prototype.save = function() {
  return { offset: this.offset, reporter: Cf.prototype.save.call(this) };
};
Yr.prototype.restore = function(e) {
  const t = new Yr(this.base);
  return t.offset = e.offset, t.length = this.offset, this.offset = e.offset, Cf.prototype.restore.call(this, e.reporter), t;
};
Yr.prototype.isEmpty = function() {
  return this.offset === this.length;
};
Yr.prototype.readUInt8 = function(e) {
  return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(e || "DecoderBuffer overrun");
};
Yr.prototype.skip = function(e, t) {
  if (!(this.offset + e <= this.length))
    return this.error(t || "DecoderBuffer overrun");
  const o = new Yr(this.base);
  return o._reporterState = this._reporterState, o.offset = this.offset, o.length = this.offset + e, this.offset += e, o;
};
Yr.prototype.raw = function(e) {
  return this.base.slice(e ? e.offset : this.offset, this.length);
};
function Da(e, t) {
  if (Array.isArray(e))
    this.length = 0, this.value = e.map(function(o) {
      return Da.isEncoderBuffer(o) || (o = new Da(o, t)), this.length += o.length, o;
    }, this);
  else if (typeof e == "number") {
    if (!(0 <= e && e <= 255))
      return t.error("non-byte EncoderBuffer value");
    this.value = e, this.length = 1;
  } else if (typeof e == "string")
    this.value = e, this.length = Na.byteLength(e);
  else if (Na.isBuffer(e))
    this.value = e, this.length = e.length;
  else
    return t.error("Unsupported type: " + typeof e);
}
ea.EncoderBuffer = Da;
Da.isEncoderBuffer = function(e) {
  return e instanceof Da ? !0 : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function";
};
Da.prototype.join = function(e, t) {
  return e || (e = Na.alloc(this.length)), t || (t = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(o) {
    o.join(e, t), t += o.length;
  }) : (typeof this.value == "number" ? e[t] = this.value : typeof this.value == "string" ? e.write(this.value, t) : Na.isBuffer(this.value) && this.value.copy(e, t), t += this.length)), e;
};
const k8 = wf.Reporter, U8 = ea.EncoderBuffer, F8 = ea.DecoderBuffer, xr = Qr, _y = [
  "seq",
  "seqof",
  "set",
  "setof",
  "objid",
  "bool",
  "gentime",
  "utctime",
  "null_",
  "enum",
  "int",
  "objDesc",
  "bitstr",
  "bmpstr",
  "charstr",
  "genstr",
  "graphstr",
  "ia5str",
  "iso646str",
  "numstr",
  "octstr",
  "printstr",
  "t61str",
  "unistr",
  "utf8str",
  "videostr"
], q8 = [
  "key",
  "obj",
  "use",
  "optional",
  "explicit",
  "implicit",
  "def",
  "choice",
  "any",
  "contains"
].concat(_y), V8 = [
  "_peekTag",
  "_decodeTag",
  "_use",
  "_decodeStr",
  "_decodeObjid",
  "_decodeTime",
  "_decodeNull",
  "_decodeInt",
  "_decodeBool",
  "_decodeList",
  "_encodeComposite",
  "_encodeStr",
  "_encodeObjid",
  "_encodeTime",
  "_encodeNull",
  "_encodeInt",
  "_encodeBool"
];
function Rt(e, t, o) {
  const r = {};
  this._baseState = r, r.name = o, r.enc = e, r.parent = t || null, r.children = null, r.tag = null, r.args = null, r.reverseArgs = null, r.choice = null, r.optional = !1, r.any = !1, r.obj = !1, r.use = null, r.useDecoder = null, r.key = null, r.default = null, r.explicit = null, r.implicit = null, r.contains = null, r.parent || (r.children = [], this._wrap());
}
var vh = Rt;
const K8 = [
  "enc",
  "parent",
  "children",
  "tag",
  "args",
  "reverseArgs",
  "choice",
  "optional",
  "any",
  "obj",
  "use",
  "alteredUse",
  "key",
  "default",
  "explicit",
  "implicit",
  "contains"
];
Rt.prototype.clone = function() {
  const e = this._baseState, t = {};
  K8.forEach(function(r) {
    t[r] = e[r];
  });
  const o = new this.constructor(t.parent);
  return o._baseState = t, o;
};
Rt.prototype._wrap = function() {
  const e = this._baseState;
  q8.forEach(function(t) {
    this[t] = function() {
      const o = new this.constructor(this);
      return e.children.push(o), o[t].apply(o, arguments);
    };
  }, this);
};
Rt.prototype._init = function(e) {
  const t = this._baseState;
  xr(t.parent === null), e.call(this), t.children = t.children.filter(function(o) {
    return o._baseState.parent === this;
  }, this), xr.equal(t.children.length, 1, "Root node can have only one child");
};
Rt.prototype._useArgs = function(e) {
  const t = this._baseState, o = e.filter(function(r) {
    return r instanceof this.constructor;
  }, this);
  e = e.filter(function(r) {
    return !(r instanceof this.constructor);
  }, this), o.length !== 0 && (xr(t.children === null), t.children = o, o.forEach(function(r) {
    r._baseState.parent = this;
  }, this)), e.length !== 0 && (xr(t.args === null), t.args = e, t.reverseArgs = e.map(function(r) {
    if (typeof r != "object" || r.constructor !== Object)
      return r;
    const h = {};
    return Object.keys(r).forEach(function(a) {
      a == (a | 0) && (a |= 0);
      const p = r[a];
      h[p] = a;
    }), h;
  }));
};
V8.forEach(function(e) {
  Rt.prototype[e] = function() {
    const t = this._baseState;
    throw new Error(e + " not implemented for encoding: " + t.enc);
  };
});
_y.forEach(function(e) {
  Rt.prototype[e] = function() {
    const t = this._baseState, o = Array.prototype.slice.call(arguments);
    return xr(t.tag === null), t.tag = e, this._useArgs(o), this;
  };
});
Rt.prototype.use = function(e) {
  xr(e);
  const t = this._baseState;
  return xr(t.use === null), t.use = e, this;
};
Rt.prototype.optional = function() {
  const e = this._baseState;
  return e.optional = !0, this;
};
Rt.prototype.def = function(e) {
  const t = this._baseState;
  return xr(t.default === null), t.default = e, t.optional = !0, this;
};
Rt.prototype.explicit = function(e) {
  const t = this._baseState;
  return xr(t.explicit === null && t.implicit === null), t.explicit = e, this;
};
Rt.prototype.implicit = function(e) {
  const t = this._baseState;
  return xr(t.explicit === null && t.implicit === null), t.implicit = e, this;
};
Rt.prototype.obj = function() {
  const e = this._baseState, t = Array.prototype.slice.call(arguments);
  return e.obj = !0, t.length !== 0 && this._useArgs(t), this;
};
Rt.prototype.key = function(e) {
  const t = this._baseState;
  return xr(t.key === null), t.key = e, this;
};
Rt.prototype.any = function() {
  const e = this._baseState;
  return e.any = !0, this;
};
Rt.prototype.choice = function(e) {
  const t = this._baseState;
  return xr(t.choice === null), t.choice = e, this._useArgs(Object.keys(e).map(function(o) {
    return e[o];
  })), this;
};
Rt.prototype.contains = function(e) {
  const t = this._baseState;
  return xr(t.use === null), t.contains = e, this;
};
Rt.prototype._decode = function(e, t) {
  const o = this._baseState;
  if (o.parent === null)
    return e.wrapResult(o.children[0]._decode(e, t));
  let r = o.default, h = !0, a = null;
  if (o.key !== null && (a = e.enterKey(o.key)), o.optional) {
    let d = null;
    if (o.explicit !== null ? d = o.explicit : o.implicit !== null ? d = o.implicit : o.tag !== null && (d = o.tag), d === null && !o.any) {
      const b = e.save();
      try {
        o.choice === null ? this._decodeGeneric(o.tag, e, t) : this._decodeChoice(e, t), h = !0;
      } catch {
        h = !1;
      }
      e.restore(b);
    } else if (h = this._peekTag(e, d, o.any), e.isError(h))
      return h;
  }
  let p;
  if (o.obj && h && (p = e.enterObject()), h) {
    if (o.explicit !== null) {
      const b = this._decodeTag(e, o.explicit);
      if (e.isError(b))
        return b;
      e = b;
    }
    const d = e.offset;
    if (o.use === null && o.choice === null) {
      let b;
      o.any && (b = e.save());
      const g = this._decodeTag(
        e,
        o.implicit !== null ? o.implicit : o.tag,
        o.any
      );
      if (e.isError(g))
        return g;
      o.any ? r = e.raw(b) : e = g;
    }
    if (t && t.track && o.tag !== null && t.track(e.path(), d, e.length, "tagged"), t && t.track && o.tag !== null && t.track(e.path(), e.offset, e.length, "content"), o.any || (o.choice === null ? r = this._decodeGeneric(o.tag, e, t) : r = this._decodeChoice(e, t)), e.isError(r))
      return r;
    if (!o.any && o.choice === null && o.children !== null && o.children.forEach(function(b) {
      b._decode(e, t);
    }), o.contains && (o.tag === "octstr" || o.tag === "bitstr")) {
      const b = new F8(r);
      r = this._getUse(o.contains, e._reporterState.obj)._decode(b, t);
    }
  }
  return o.obj && h && (r = e.leaveObject(p)), o.key !== null && (r !== null || h === !0) ? e.leaveKey(a, o.key, r) : a !== null && e.exitKey(a), r;
};
Rt.prototype._decodeGeneric = function(e, t, o) {
  const r = this._baseState;
  return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(t, e, r.args[0], o) : /str$/.test(e) ? this._decodeStr(t, e, o) : e === "objid" && r.args ? this._decodeObjid(t, r.args[0], r.args[1], o) : e === "objid" ? this._decodeObjid(t, null, null, o) : e === "gentime" || e === "utctime" ? this._decodeTime(t, e, o) : e === "null_" ? this._decodeNull(t, o) : e === "bool" ? this._decodeBool(t, o) : e === "objDesc" ? this._decodeStr(t, e, o) : e === "int" || e === "enum" ? this._decodeInt(t, r.args && r.args[0], o) : r.use !== null ? this._getUse(r.use, t._reporterState.obj)._decode(t, o) : t.error("unknown tag: " + e);
};
Rt.prototype._getUse = function(e, t) {
  const o = this._baseState;
  return o.useDecoder = this._use(e, t), xr(o.useDecoder._baseState.parent === null), o.useDecoder = o.useDecoder._baseState.children[0], o.implicit !== o.useDecoder._baseState.implicit && (o.useDecoder = o.useDecoder.clone(), o.useDecoder._baseState.implicit = o.implicit), o.useDecoder;
};
Rt.prototype._decodeChoice = function(e, t) {
  const o = this._baseState;
  let r = null, h = !1;
  return Object.keys(o.choice).some(function(a) {
    const p = e.save(), d = o.choice[a];
    try {
      const b = d._decode(e, t);
      if (e.isError(b))
        return !1;
      r = { type: a, value: b }, h = !0;
    } catch {
      return e.restore(p), !1;
    }
    return !0;
  }, this), h ? r : e.error("Choice not matched");
};
Rt.prototype._createEncoderBuffer = function(e) {
  return new U8(e, this.reporter);
};
Rt.prototype._encode = function(e, t, o) {
  const r = this._baseState;
  if (r.default !== null && r.default === e)
    return;
  const h = this._encodeValue(e, t, o);
  if (h !== void 0 && !this._skipDefault(h, t, o))
    return h;
};
Rt.prototype._encodeValue = function(e, t, o) {
  const r = this._baseState;
  if (r.parent === null)
    return r.children[0]._encode(e, t || new k8());
  let h = null;
  if (this.reporter = t, r.optional && e === void 0)
    if (r.default !== null)
      e = r.default;
    else
      return;
  let a = null, p = !1;
  if (r.any)
    h = this._createEncoderBuffer(e);
  else if (r.choice)
    h = this._encodeChoice(e, t);
  else if (r.contains)
    a = this._getUse(r.contains, o)._encode(e, t), p = !0;
  else if (r.children)
    a = r.children.map(function(d) {
      if (d._baseState.tag === "null_")
        return d._encode(null, t, e);
      if (d._baseState.key === null)
        return t.error("Child should have a key");
      const b = t.enterKey(d._baseState.key);
      if (typeof e != "object")
        return t.error("Child expected, but input is not object");
      const g = d._encode(e[d._baseState.key], t, e);
      return t.leaveKey(b), g;
    }, this).filter(function(d) {
      return d;
    }), a = this._createEncoderBuffer(a);
  else if (r.tag === "seqof" || r.tag === "setof") {
    if (!(r.args && r.args.length === 1))
      return t.error("Too many args for : " + r.tag);
    if (!Array.isArray(e))
      return t.error("seqof/setof, but data is not Array");
    const d = this.clone();
    d._baseState.implicit = null, a = this._createEncoderBuffer(e.map(function(b) {
      const g = this._baseState;
      return this._getUse(g.args[0], e)._encode(b, t);
    }, d));
  } else
    r.use !== null ? h = this._getUse(r.use, o)._encode(e, t) : (a = this._encodePrimitive(r.tag, e), p = !0);
  if (!r.any && r.choice === null) {
    const d = r.implicit !== null ? r.implicit : r.tag, b = r.implicit === null ? "universal" : "context";
    d === null ? r.use === null && t.error("Tag could be omitted only for .use()") : r.use === null && (h = this._encodeComposite(d, p, b, a));
  }
  return r.explicit !== null && (h = this._encodeComposite(r.explicit, !1, "context", h)), h;
};
Rt.prototype._encodeChoice = function(e, t) {
  const o = this._baseState, r = o.choice[e.type];
  return r || xr(
    !1,
    e.type + " not found in " + JSON.stringify(Object.keys(o.choice))
  ), r._encode(e.value, t);
};
Rt.prototype._encodePrimitive = function(e, t) {
  const o = this._baseState;
  if (/str$/.test(e))
    return this._encodeStr(t, e);
  if (e === "objid" && o.args)
    return this._encodeObjid(t, o.reverseArgs[0], o.args[1]);
  if (e === "objid")
    return this._encodeObjid(t, null, null);
  if (e === "gentime" || e === "utctime")
    return this._encodeTime(t, e);
  if (e === "null_")
    return this._encodeNull();
  if (e === "int" || e === "enum")
    return this._encodeInt(t, o.args && o.reverseArgs[0]);
  if (e === "bool")
    return this._encodeBool(t);
  if (e === "objDesc")
    return this._encodeStr(t, e);
  throw new Error("Unsupported tag: " + e);
};
Rt.prototype._isNumstr = function(e) {
  return /^[0-9 ]*$/.test(e);
};
Rt.prototype._isPrintstr = function(e) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e);
};
var Af = {};
(function(e) {
  function t(o) {
    const r = {};
    return Object.keys(o).forEach(function(h) {
      (h | 0) == h && (h = h | 0);
      const a = o[h];
      r[a] = h;
    }), r;
  }
  e.tagClass = {
    0: "universal",
    1: "application",
    2: "context",
    3: "private"
  }, e.tagClassByName = t(e.tagClass), e.tag = {
    0: "end",
    1: "bool",
    2: "int",
    3: "bitstr",
    4: "octstr",
    5: "null_",
    6: "objid",
    7: "objDesc",
    8: "external",
    9: "real",
    10: "enum",
    11: "embed",
    12: "utf8str",
    13: "relativeOid",
    16: "seq",
    17: "set",
    18: "numstr",
    19: "printstr",
    20: "t61str",
    21: "videostr",
    22: "ia5str",
    23: "utctime",
    24: "gentime",
    25: "graphstr",
    26: "iso646str",
    27: "genstr",
    28: "unistr",
    29: "charstr",
    30: "bmpstr"
  }, e.tagByName = t(e.tag);
})(Af);
const $8 = ut, Ji = $0.Buffer, Ey = vh, Do = Af;
function Sy(e) {
  this.enc = "der", this.name = e.name, this.entity = e, this.tree = new Bi(), this.tree._init(e.body);
}
var wy = Sy;
Sy.prototype.encode = function(e, t) {
  return this.tree._encode(e, t).join();
};
function Bi(e) {
  Ey.call(this, "der", e);
}
$8(Bi, Ey);
Bi.prototype._encodeComposite = function(e, t, o, r) {
  const h = H8(e, t, o, this.reporter);
  if (r.length < 128) {
    const d = Ji.alloc(2);
    return d[0] = h, d[1] = r.length, this._createEncoderBuffer([d, r]);
  }
  let a = 1;
  for (let d = r.length; d >= 256; d >>= 8)
    a++;
  const p = Ji.alloc(2 + a);
  p[0] = h, p[1] = 128 | a;
  for (let d = 1 + a, b = r.length; b > 0; d--, b >>= 8)
    p[d] = b & 255;
  return this._createEncoderBuffer([p, r]);
};
Bi.prototype._encodeStr = function(e, t) {
  if (t === "bitstr")
    return this._createEncoderBuffer([e.unused | 0, e.data]);
  if (t === "bmpstr") {
    const o = Ji.alloc(e.length * 2);
    for (let r = 0; r < e.length; r++)
      o.writeUInt16BE(e.charCodeAt(r), r * 2);
    return this._createEncoderBuffer(o);
  } else
    return t === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : t === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(t) ? this._createEncoderBuffer(e) : t === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + t + " unsupported");
};
Bi.prototype._encodeObjid = function(e, t, o) {
  if (typeof e == "string") {
    if (!t)
      return this.reporter.error("string objid given, but no values map found");
    if (!t.hasOwnProperty(e))
      return this.reporter.error("objid not found in values map");
    e = t[e].split(/[\s.]+/g);
    for (let p = 0; p < e.length; p++)
      e[p] |= 0;
  } else if (Array.isArray(e)) {
    e = e.slice();
    for (let p = 0; p < e.length; p++)
      e[p] |= 0;
  }
  if (!Array.isArray(e))
    return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
  if (!o) {
    if (e[1] >= 40)
      return this.reporter.error("Second objid identifier OOB");
    e.splice(0, 2, e[0] * 40 + e[1]);
  }
  let r = 0;
  for (let p = 0; p < e.length; p++) {
    let d = e[p];
    for (r++; d >= 128; d >>= 7)
      r++;
  }
  const h = Ji.alloc(r);
  let a = h.length - 1;
  for (let p = e.length - 1; p >= 0; p--) {
    let d = e[p];
    for (h[a--] = d & 127; (d >>= 7) > 0; )
      h[a--] = 128 | d & 127;
  }
  return this._createEncoderBuffer(h);
};
function kr(e) {
  return e < 10 ? "0" + e : e;
}
Bi.prototype._encodeTime = function(e, t) {
  let o;
  const r = new Date(e);
  return t === "gentime" ? o = [
    kr(r.getUTCFullYear()),
    kr(r.getUTCMonth() + 1),
    kr(r.getUTCDate()),
    kr(r.getUTCHours()),
    kr(r.getUTCMinutes()),
    kr(r.getUTCSeconds()),
    "Z"
  ].join("") : t === "utctime" ? o = [
    kr(r.getUTCFullYear() % 100),
    kr(r.getUTCMonth() + 1),
    kr(r.getUTCDate()),
    kr(r.getUTCHours()),
    kr(r.getUTCMinutes()),
    kr(r.getUTCSeconds()),
    "Z"
  ].join("") : this.reporter.error("Encoding " + t + " time is not supported yet"), this._encodeStr(o, "octstr");
};
Bi.prototype._encodeNull = function() {
  return this._createEncoderBuffer("");
};
Bi.prototype._encodeInt = function(e, t) {
  if (typeof e == "string") {
    if (!t)
      return this.reporter.error("String int or enum given, but no values map");
    if (!t.hasOwnProperty(e))
      return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
    e = t[e];
  }
  if (typeof e != "number" && !Ji.isBuffer(e)) {
    const h = e.toArray();
    !e.sign && h[0] & 128 && h.unshift(0), e = Ji.from(h);
  }
  if (Ji.isBuffer(e)) {
    let h = e.length;
    e.length === 0 && h++;
    const a = Ji.alloc(h);
    return e.copy(a), e.length === 0 && (a[0] = 0), this._createEncoderBuffer(a);
  }
  if (e < 128)
    return this._createEncoderBuffer(e);
  if (e < 256)
    return this._createEncoderBuffer([0, e]);
  let o = 1;
  for (let h = e; h >= 256; h >>= 8)
    o++;
  const r = new Array(o);
  for (let h = r.length - 1; h >= 0; h--)
    r[h] = e & 255, e >>= 8;
  return r[0] & 128 && r.unshift(0), this._createEncoderBuffer(Ji.from(r));
};
Bi.prototype._encodeBool = function(e) {
  return this._createEncoderBuffer(e ? 255 : 0);
};
Bi.prototype._use = function(e, t) {
  return typeof e == "function" && (e = e(t)), e._getEncoder("der").tree;
};
Bi.prototype._skipDefault = function(e, t, o) {
  const r = this._baseState;
  let h;
  if (r.default === null)
    return !1;
  const a = e.join();
  if (r.defaultBuffer === void 0 && (r.defaultBuffer = this._encodeValue(r.default, t, o).join()), a.length !== r.defaultBuffer.length)
    return !1;
  for (h = 0; h < a.length; h++)
    if (a[h] !== r.defaultBuffer[h])
      return !1;
  return !0;
};
function H8(e, t, o, r) {
  let h;
  if (e === "seqof" ? e = "seq" : e === "setof" && (e = "set"), Do.tagByName.hasOwnProperty(e))
    h = Do.tagByName[e];
  else if (typeof e == "number" && (e | 0) === e)
    h = e;
  else
    return r.error("Unknown tag: " + e);
  return h >= 31 ? r.error("Multi-octet tag encoding unsupported") : (t || (h |= 32), h |= Do.tagClassByName[o || "universal"] << 6, h);
}
const G8 = ut, yh = wy;
function gh(e) {
  yh.call(this, e), this.enc = "pem";
}
G8(gh, yh);
var z8 = gh;
gh.prototype.encode = function(e, t) {
  const o = yh.prototype.encode.call(this, e).toString("base64"), r = ["-----BEGIN " + t.label + "-----"];
  for (let h = 0; h < o.length; h += 64)
    r.push(o.slice(h, h + 64));
  return r.push("-----END " + t.label + "-----"), r.join(`
`);
};
(function(e) {
  const t = e;
  t.der = wy, t.pem = z8;
})(ph);
var mh = {};
const j8 = ut, W8 = rr, id = ea.DecoderBuffer, Cy = vh, nd = Af;
function Ay(e) {
  this.enc = "der", this.name = e.name, this.entity = e, this.tree = new Lr(), this.tree._init(e.body);
}
var By = Ay;
Ay.prototype.decode = function(e, t) {
  return id.isDecoderBuffer(e) || (e = new id(e, t)), this.tree._decode(e, t);
};
function Lr(e) {
  Cy.call(this, "der", e);
}
j8(Lr, Cy);
Lr.prototype._peekTag = function(e, t, o) {
  if (e.isEmpty())
    return !1;
  const r = e.save(), h = bh(e, 'Failed to peek tag: "' + t + '"');
  return e.isError(h) ? h : (e.restore(r), h.tag === t || h.tagStr === t || h.tagStr + "of" === t || o);
};
Lr.prototype._decodeTag = function(e, t, o) {
  const r = bh(
    e,
    'Failed to decode tag of "' + t + '"'
  );
  if (e.isError(r))
    return r;
  let h = Iy(
    e,
    r.primitive,
    'Failed to get length of "' + t + '"'
  );
  if (e.isError(h))
    return h;
  if (!o && r.tag !== t && r.tagStr !== t && r.tagStr + "of" !== t)
    return e.error('Failed to match tag: "' + t + '"');
  if (r.primitive || h !== null)
    return e.skip(h, 'Failed to match body of: "' + t + '"');
  const a = e.save(), p = this._skipUntilEnd(
    e,
    'Failed to skip indefinite length body: "' + this.tag + '"'
  );
  return e.isError(p) ? p : (h = e.offset - a.offset, e.restore(a), e.skip(h, 'Failed to match body of: "' + t + '"'));
};
Lr.prototype._skipUntilEnd = function(e, t) {
  for (; ; ) {
    const o = bh(e, t);
    if (e.isError(o))
      return o;
    const r = Iy(e, o.primitive, t);
    if (e.isError(r))
      return r;
    let h;
    if (o.primitive || r !== null ? h = e.skip(r) : h = this._skipUntilEnd(e, t), e.isError(h))
      return h;
    if (o.tagStr === "end")
      break;
  }
};
Lr.prototype._decodeList = function(e, t, o, r) {
  const h = [];
  for (; !e.isEmpty(); ) {
    const a = this._peekTag(e, "end");
    if (e.isError(a))
      return a;
    const p = o.decode(e, "der", r);
    if (e.isError(p) && a)
      break;
    h.push(p);
  }
  return h;
};
Lr.prototype._decodeStr = function(e, t) {
  if (t === "bitstr") {
    const o = e.readUInt8();
    return e.isError(o) ? o : { unused: o, data: e.raw() };
  } else if (t === "bmpstr") {
    const o = e.raw();
    if (o.length % 2 === 1)
      return e.error("Decoding of string type: bmpstr length mismatch");
    let r = "";
    for (let h = 0; h < o.length / 2; h++)
      r += String.fromCharCode(o.readUInt16BE(h * 2));
    return r;
  } else if (t === "numstr") {
    const o = e.raw().toString("ascii");
    return this._isNumstr(o) ? o : e.error("Decoding of string type: numstr unsupported characters");
  } else {
    if (t === "octstr" || t === "objDesc")
      return e.raw();
    if (t === "printstr") {
      const o = e.raw().toString("ascii");
      return this._isPrintstr(o) ? o : e.error("Decoding of string type: printstr unsupported characters");
    } else
      return /str$/.test(t) ? e.raw().toString() : e.error("Decoding of string type: " + t + " unsupported");
  }
};
Lr.prototype._decodeObjid = function(e, t, o) {
  let r;
  const h = [];
  let a = 0, p = 0;
  for (; !e.isEmpty(); )
    p = e.readUInt8(), a <<= 7, a |= p & 127, p & 128 || (h.push(a), a = 0);
  p & 128 && h.push(a);
  const d = h[0] / 40 | 0, b = h[0] % 40;
  if (o ? r = h : r = [d, b].concat(h.slice(1)), t) {
    let g = t[r.join(" ")];
    g === void 0 && (g = t[r.join(".")]), g !== void 0 && (r = g);
  }
  return r;
};
Lr.prototype._decodeTime = function(e, t) {
  const o = e.raw().toString();
  let r, h, a, p, d, b;
  if (t === "gentime")
    r = o.slice(0, 4) | 0, h = o.slice(4, 6) | 0, a = o.slice(6, 8) | 0, p = o.slice(8, 10) | 0, d = o.slice(10, 12) | 0, b = o.slice(12, 14) | 0;
  else if (t === "utctime")
    r = o.slice(0, 2) | 0, h = o.slice(2, 4) | 0, a = o.slice(4, 6) | 0, p = o.slice(6, 8) | 0, d = o.slice(8, 10) | 0, b = o.slice(10, 12) | 0, r < 70 ? r = 2e3 + r : r = 1900 + r;
  else
    return e.error("Decoding " + t + " time is not supported yet");
  return Date.UTC(r, h - 1, a, p, d, b, 0);
};
Lr.prototype._decodeNull = function() {
  return null;
};
Lr.prototype._decodeBool = function(e) {
  const t = e.readUInt8();
  return e.isError(t) ? t : t !== 0;
};
Lr.prototype._decodeInt = function(e, t) {
  const o = e.raw();
  let r = new W8(o);
  return t && (r = t[r.toString(10)] || r), r;
};
Lr.prototype._use = function(e, t) {
  return typeof e == "function" && (e = e(t)), e._getDecoder("der").tree;
};
function bh(e, t) {
  let o = e.readUInt8(t);
  if (e.isError(o))
    return o;
  const r = nd.tagClass[o >> 6], h = (o & 32) === 0;
  if ((o & 31) === 31) {
    let p = o;
    for (o = 0; (p & 128) === 128; ) {
      if (p = e.readUInt8(t), e.isError(p))
        return p;
      o <<= 7, o |= p & 127;
    }
  } else
    o &= 31;
  const a = nd.tag[o];
  return {
    cls: r,
    primitive: h,
    tag: o,
    tagStr: a
  };
}
function Iy(e, t, o) {
  let r = e.readUInt8(o);
  if (e.isError(r))
    return r;
  if (!t && r === 128)
    return null;
  if (!(r & 128))
    return r;
  const h = r & 127;
  if (h > 4)
    return e.error("length octect is too long");
  r = 0;
  for (let a = 0; a < h; a++) {
    r <<= 8;
    const p = e.readUInt8(o);
    if (e.isError(p))
      return p;
    r |= p;
  }
  return r;
}
const Y8 = ut, X8 = $0.Buffer, xh = By;
function _h(e) {
  xh.call(this, e), this.enc = "pem";
}
Y8(_h, xh);
var Q8 = _h;
_h.prototype.decode = function(e, t) {
  const o = e.toString().split(/[\r\n]+/g), r = t.label.toUpperCase(), h = /^-----(BEGIN|END) ([^-]+)-----$/;
  let a = -1, p = -1;
  for (let g = 0; g < o.length; g++) {
    const w = o[g].match(h);
    if (w !== null && w[2] === r)
      if (a === -1) {
        if (w[1] !== "BEGIN")
          break;
        a = g;
      } else {
        if (w[1] !== "END")
          break;
        p = g;
        break;
      }
  }
  if (a === -1 || p === -1)
    throw new Error("PEM section not found for: " + r);
  const d = o.slice(a + 1, p).join("");
  d.replace(/[^a-z0-9+/=]+/gi, "");
  const b = X8.from(d, "base64");
  return xh.prototype.decode.call(this, b, t);
};
(function(e) {
  const t = e;
  t.der = By, t.pem = Q8;
})(mh);
(function(e) {
  const t = ph, o = mh, r = ut, h = e;
  h.define = function(p, d) {
    return new a(p, d);
  };
  function a(p, d) {
    this.name = p, this.body = d, this.decoders = {}, this.encoders = {};
  }
  a.prototype._createNamed = function(p) {
    const d = this.name;
    function b(g) {
      this._initNamed(g, d);
    }
    return r(b, p), b.prototype._initNamed = function(g, w) {
      p.call(this, g, w);
    }, new b(this);
  }, a.prototype._getDecoder = function(p) {
    return p = p || "der", this.decoders.hasOwnProperty(p) || (this.decoders[p] = this._createNamed(o[p])), this.decoders[p];
  }, a.prototype.decode = function(p, d, b) {
    return this._getDecoder(d).decode(p, b);
  }, a.prototype._getEncoder = function(p) {
    return p = p || "der", this.encoders.hasOwnProperty(p) || (this.encoders[p] = this._createNamed(t[p])), this.encoders[p];
  }, a.prototype.encode = function(p, d, b) {
    return this._getEncoder(d).encode(p, b);
  };
})(xy);
var Ty = {};
(function(e) {
  const t = e;
  t.Reporter = wf.Reporter, t.DecoderBuffer = ea.DecoderBuffer, t.EncoderBuffer = ea.EncoderBuffer, t.Node = vh;
})(Ty);
var My = {};
(function(e) {
  const t = e;
  t._reverse = function(o) {
    const r = {};
    return Object.keys(o).forEach(function(h) {
      (h | 0) == h && (h = h | 0);
      const a = o[h];
      r[a] = h;
    }), r;
  }, t.der = Af;
})(My);
(function(e) {
  const t = e;
  t.bignum = rr, t.define = xy.define, t.base = Ty, t.constants = My, t.decoders = mh, t.encoders = ph;
})(dh);
var Ii = dh, ad = Ii.define("Time", function() {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
}), Z8 = Ii.define("AttributeTypeValue", function() {
  this.seq().obj(
    this.key("type").objid(),
    this.key("value").any()
  );
}), Eh = Ii.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("parameters").optional(),
    this.key("curve").objid().optional()
  );
}), J8 = Ii.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(Eh),
    this.key("subjectPublicKey").bitstr()
  );
}), e5 = Ii.define("RelativeDistinguishedName", function() {
  this.setof(Z8);
}), t5 = Ii.define("RDNSequence", function() {
  this.seqof(e5);
}), sd = Ii.define("Name", function() {
  this.choice({
    rdnSequence: this.use(t5)
  });
}), r5 = Ii.define("Validity", function() {
  this.seq().obj(
    this.key("notBefore").use(ad),
    this.key("notAfter").use(ad)
  );
}), i5 = Ii.define("Extension", function() {
  this.seq().obj(
    this.key("extnID").objid(),
    this.key("critical").bool().def(!1),
    this.key("extnValue").octstr()
  );
}), n5 = Ii.define("TBSCertificate", function() {
  this.seq().obj(
    this.key("version").explicit(0).int().optional(),
    this.key("serialNumber").int(),
    this.key("signature").use(Eh),
    this.key("issuer").use(sd),
    this.key("validity").use(r5),
    this.key("subject").use(sd),
    this.key("subjectPublicKeyInfo").use(J8),
    this.key("issuerUniqueID").implicit(1).bitstr().optional(),
    this.key("subjectUniqueID").implicit(2).bitstr().optional(),
    this.key("extensions").explicit(3).seqof(i5).optional()
  );
}), a5 = Ii.define("X509Certificate", function() {
  this.seq().obj(
    this.key("tbsCertificate").use(n5),
    this.key("signatureAlgorithm").use(Eh),
    this.key("signatureValue").bitstr()
  );
}), s5 = a5, Ti = dh;
Ai.certificate = s5;
var f5 = Ti.define("RSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("modulus").int(),
    this.key("publicExponent").int(),
    this.key("privateExponent").int(),
    this.key("prime1").int(),
    this.key("prime2").int(),
    this.key("exponent1").int(),
    this.key("exponent2").int(),
    this.key("coefficient").int()
  );
});
Ai.RSAPrivateKey = f5;
var o5 = Ti.define("RSAPublicKey", function() {
  this.seq().obj(
    this.key("modulus").int(),
    this.key("publicExponent").int()
  );
});
Ai.RSAPublicKey = o5;
var u5 = Ti.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(Ry),
    this.key("subjectPublicKey").bitstr()
  );
});
Ai.PublicKey = u5;
var Ry = Ti.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("none").null_().optional(),
    this.key("curve").objid().optional(),
    this.key("params").seq().obj(
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int()
    ).optional()
  );
}), c5 = Ti.define("PrivateKeyInfo", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("algorithm").use(Ry),
    this.key("subjectPrivateKey").octstr()
  );
});
Ai.PrivateKey = c5;
var h5 = Ti.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").seq().obj(
      this.key("id").objid(),
      this.key("decrypt").seq().obj(
        this.key("kde").seq().obj(
          this.key("id").objid(),
          this.key("kdeparams").seq().obj(
            this.key("salt").octstr(),
            this.key("iters").int()
          )
        ),
        this.key("cipher").seq().obj(
          this.key("algo").objid(),
          this.key("iv").octstr()
        )
      )
    ),
    this.key("subjectPrivateKey").octstr()
  );
});
Ai.EncryptedPrivateKey = h5;
var l5 = Ti.define("DSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("p").int(),
    this.key("q").int(),
    this.key("g").int(),
    this.key("pub_key").int(),
    this.key("priv_key").int()
  );
});
Ai.DSAPrivateKey = l5;
Ai.DSAparam = Ti.define("DSAparam", function() {
  this.int();
});
var d5 = Ti.define("ECPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("privateKey").octstr(),
    this.key("parameters").optional().explicit(0).use(p5),
    this.key("publicKey").optional().explicit(1).bitstr()
  );
});
Ai.ECPrivateKey = d5;
var p5 = Ti.define("ECParameters", function() {
  this.choice({
    namedCurve: this.objid()
  });
});
Ai.signature = Ti.define("signature", function() {
  this.seq().obj(
    this.key("r").int(),
    this.key("s").int()
  );
});
const v5 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var y5 = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, g5 = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, m5 = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, b5 = lf, x5 = Dr, es = ct.Buffer, _5 = function(e, t) {
  var o = e.toString(), r = o.match(y5), h;
  if (r) {
    var a = "aes" + r[1], p = es.from(r[2], "hex"), d = es.from(r[3].replace(/[\r\n]/g, ""), "base64"), b = b5(t, p.slice(0, 8), parseInt(r[1], 10)).key, g = [], w = x5.createDecipheriv(a, b, p);
    g.push(w.update(d)), g.push(w.final()), h = es.concat(g);
  } else {
    var C = o.match(m5);
    h = es.from(C[2].replace(/[\r\n]/g, ""), "base64");
  }
  var T = o.match(g5)[1];
  return {
    tag: T,
    data: h
  };
}, Sr = Ai, E5 = v5, S5 = _5, w5 = Dr, C5 = uf, hc = ct.Buffer, Bf = Ny;
function Ny(e) {
  var t;
  typeof e == "object" && !hc.isBuffer(e) && (t = e.passphrase, e = e.key), typeof e == "string" && (e = hc.from(e));
  var o = S5(e, t), r = o.tag, h = o.data, a, p;
  switch (r) {
    case "CERTIFICATE":
      p = Sr.certificate.decode(h, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      switch (p || (p = Sr.PublicKey.decode(h, "der")), a = p.algorithm.algorithm.join("."), a) {
        case "1.2.840.113549.1.1.1":
          return Sr.RSAPublicKey.decode(p.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          return p.subjectPrivateKey = p.subjectPublicKey, {
            type: "ec",
            data: p
          };
        case "1.2.840.10040.4.1":
          return p.algorithm.params.pub_key = Sr.DSAparam.decode(p.subjectPublicKey.data, "der"), {
            type: "dsa",
            data: p.algorithm.params
          };
        default:
          throw new Error("unknown key id " + a);
      }
    case "ENCRYPTED PRIVATE KEY":
      h = Sr.EncryptedPrivateKey.decode(h, "der"), h = A5(h, t);
    case "PRIVATE KEY":
      switch (p = Sr.PrivateKey.decode(h, "der"), a = p.algorithm.algorithm.join("."), a) {
        case "1.2.840.113549.1.1.1":
          return Sr.RSAPrivateKey.decode(p.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return {
            curve: p.algorithm.curve,
            privateKey: Sr.ECPrivateKey.decode(p.subjectPrivateKey, "der").privateKey
          };
        case "1.2.840.10040.4.1":
          return p.algorithm.params.priv_key = Sr.DSAparam.decode(p.subjectPrivateKey, "der"), {
            type: "dsa",
            params: p.algorithm.params
          };
        default:
          throw new Error("unknown key id " + a);
      }
    case "RSA PUBLIC KEY":
      return Sr.RSAPublicKey.decode(h, "der");
    case "RSA PRIVATE KEY":
      return Sr.RSAPrivateKey.decode(h, "der");
    case "DSA PRIVATE KEY":
      return {
        type: "dsa",
        params: Sr.DSAPrivateKey.decode(h, "der")
      };
    case "EC PRIVATE KEY":
      return h = Sr.ECPrivateKey.decode(h, "der"), {
        curve: h.parameters.value,
        privateKey: h.privateKey
      };
    default:
      throw new Error("unknown key type " + r);
  }
}
Ny.signature = Sr.signature;
function A5(e, t) {
  var o = e.algorithm.decrypt.kde.kdeparams.salt, r = parseInt(e.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), h = E5[e.algorithm.decrypt.cipher.algo.join(".")], a = e.algorithm.decrypt.cipher.iv, p = e.subjectPrivateKey, d = parseInt(h.split("-")[1], 10) / 8, b = C5.pbkdf2Sync(t, o, r, d, "sha1"), g = w5.createDecipheriv(h, b, a), w = [];
  return w.push(g.update(p)), w.push(g.final()), hc.concat(w);
}
const Dy = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var fd;
function B5() {
  if (fd)
    return u0.exports;
  fd = 1;
  var e = ct.Buffer, t = iv, o = sh, r = hh().ec, h = by, a = Bf, p = Dy;
  function d(N, j, U, H, z) {
    var ee = a(j);
    if (ee.curve) {
      if (H !== "ecdsa" && H !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return b(N, ee);
    } else if (ee.type === "dsa") {
      if (H !== "dsa")
        throw new Error("wrong private key type");
      return g(N, ee, U);
    } else if (H !== "rsa" && H !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    N = e.concat([z, N]);
    for (var ne = ee.modulus.byteLength(), le = [0, 1]; N.length + le.length + 1 < ne; )
      le.push(255);
    le.push(0);
    for (var Z = -1; ++Z < N.length; )
      le.push(N[Z]);
    var ie = o(le, ee);
    return ie;
  }
  function b(N, j) {
    var U = p[j.curve.join(".")];
    if (!U)
      throw new Error("unknown curve " + j.curve.join("."));
    var H = new r(U), z = H.keyFromPrivate(j.privateKey), ee = z.sign(N);
    return e.from(ee.toDER());
  }
  function g(N, j, U) {
    for (var H = j.params.priv_key, z = j.params.p, ee = j.params.q, ne = j.params.g, le = new h(0), Z, ie = T(N, ee).mod(ee), fe = !1, I = C(H, ee, N, U); fe === !1; )
      Z = q(ee, I, U), le = O(ne, Z, z, ee), fe = Z.invm(ee).imul(ie.add(H.mul(le))).mod(ee), fe.cmpn(0) === 0 && (fe = !1, le = new h(0));
    return w(le, fe);
  }
  function w(N, j) {
    N = N.toArray(), j = j.toArray(), N[0] & 128 && (N = [0].concat(N)), j[0] & 128 && (j = [0].concat(j));
    var U = N.length + j.length + 4, H = [48, U, 2, N.length];
    return H = H.concat(N, [2, j.length], j), e.from(H);
  }
  function C(N, j, U, H) {
    if (N = e.from(N.toArray()), N.length < j.byteLength()) {
      var z = e.alloc(j.byteLength() - N.length);
      N = e.concat([z, N]);
    }
    var ee = U.length, ne = k(U, j), le = e.alloc(ee);
    le.fill(1);
    var Z = e.alloc(ee);
    return Z = t(H, Z).update(le).update(e.from([0])).update(N).update(ne).digest(), le = t(H, Z).update(le).digest(), Z = t(H, Z).update(le).update(e.from([1])).update(N).update(ne).digest(), le = t(H, Z).update(le).digest(), { k: Z, v: le };
  }
  function T(N, j) {
    var U = new h(N), H = (N.length << 3) - j.bitLength();
    return H > 0 && U.ishrn(H), U;
  }
  function k(N, j) {
    N = T(N, j), N = N.mod(j);
    var U = e.from(N.toArray());
    if (U.length < j.byteLength()) {
      var H = e.alloc(j.byteLength() - U.length);
      U = e.concat([H, U]);
    }
    return U;
  }
  function q(N, j, U) {
    var H, z;
    do {
      for (H = e.alloc(0); H.length * 8 < N.bitLength(); )
        j.v = t(U, j.k).update(j.v).digest(), H = e.concat([H, j.v]);
      z = T(H, N), j.k = t(U, j.k).update(j.v).update(e.from([0])).digest(), j.v = t(U, j.k).update(j.v).digest();
    } while (z.cmp(N) !== -1);
    return z;
  }
  function O(N, j, U, H) {
    return N.toRed(h.mont(U)).redPow(j).fromRed().mod(H);
  }
  return u0.exports = d, u0.exports.getKey = C, u0.exports.makeKey = q, u0.exports;
}
var Oo, od;
function I5() {
  if (od)
    return Oo;
  od = 1;
  var e = ct.Buffer, t = by, o = hh().ec, r = Bf, h = Dy;
  function a(g, w, C, T, k) {
    var q = r(C);
    if (q.type === "ec") {
      if (T !== "ecdsa" && T !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return p(g, w, q);
    } else if (q.type === "dsa") {
      if (T !== "dsa")
        throw new Error("wrong public key type");
      return d(g, w, q);
    } else if (T !== "rsa" && T !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    w = e.concat([k, w]);
    for (var O = q.modulus.byteLength(), N = [1], j = 0; w.length + N.length + 2 < O; )
      N.push(255), j++;
    N.push(0);
    for (var U = -1; ++U < w.length; )
      N.push(w[U]);
    N = e.from(N);
    var H = t.mont(q.modulus);
    g = new t(g).toRed(H), g = g.redPow(new t(q.publicExponent)), g = e.from(g.fromRed().toArray());
    var z = j < 8 ? 1 : 0;
    for (O = Math.min(g.length, N.length), g.length !== N.length && (z = 1), U = -1; ++U < O; )
      z |= g[U] ^ N[U];
    return z === 0;
  }
  function p(g, w, C) {
    var T = h[C.data.algorithm.curve.join(".")];
    if (!T)
      throw new Error("unknown curve " + C.data.algorithm.curve.join("."));
    var k = new o(T), q = C.data.subjectPrivateKey.data;
    return k.verify(w, g, q);
  }
  function d(g, w, C) {
    var T = C.data.p, k = C.data.q, q = C.data.g, O = C.data.pub_key, N = r.signature.decode(g, "der"), j = N.s, U = N.r;
    b(j, k), b(U, k);
    var H = t.mont(T), z = j.invm(k), ee = q.toRed(H).redPow(new t(w).mul(z).mod(k)).fromRed().mul(O.toRed(H).redPow(U.mul(z).mod(k)).fromRed()).mod(T).mod(k);
    return ee.cmp(U) === 0;
  }
  function b(g, w) {
    if (g.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (g.cmp(w) >= w)
      throw new Error("invalid sig");
  }
  return Oo = a, Oo;
}
var Po, ud;
function T5() {
  if (ud)
    return Po;
  ud = 1;
  var e = ct.Buffer, t = P0, o = U1, r = ut, h = B5(), a = I5(), p = nv;
  Object.keys(p).forEach(function(C) {
    p[C].id = e.from(p[C].id, "hex"), p[C.toLowerCase()] = p[C];
  });
  function d(C) {
    o.Writable.call(this);
    var T = p[C];
    if (!T)
      throw new Error("Unknown message digest");
    this._hashType = T.hash, this._hash = t(T.hash), this._tag = T.id, this._signType = T.sign;
  }
  r(d, o.Writable), d.prototype._write = function(C, T, k) {
    this._hash.update(C), k();
  }, d.prototype.update = function(C, T) {
    return typeof C == "string" && (C = e.from(C, T)), this._hash.update(C), this;
  }, d.prototype.sign = function(C, T) {
    this.end();
    var k = this._hash.digest(), q = h(k, C, this._hashType, this._signType, this._tag);
    return T ? q.toString(T) : q;
  };
  function b(C) {
    o.Writable.call(this);
    var T = p[C];
    if (!T)
      throw new Error("Unknown message digest");
    this._hash = t(T.hash), this._tag = T.id, this._signType = T.sign;
  }
  r(b, o.Writable), b.prototype._write = function(C, T, k) {
    this._hash.update(C), k();
  }, b.prototype.update = function(C, T) {
    return typeof C == "string" && (C = e.from(C, T)), this._hash.update(C), this;
  }, b.prototype.verify = function(C, T, k) {
    typeof T == "string" && (T = e.from(T, k)), this.end();
    var q = this._hash.digest();
    return a(T, q, C, this._signType, this._tag);
  };
  function g(C) {
    return new d(C);
  }
  function w(C) {
    return new b(C);
  }
  return Po = {
    Sign: g,
    Verify: w,
    createSign: g,
    createVerify: w
  }, Po;
}
var Lo, cd;
function M5() {
  if (cd)
    return Lo;
  cd = 1;
  var e = hh(), t = rr;
  Lo = function(a) {
    return new r(a);
  };
  var o = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  o.p224 = o.secp224r1, o.p256 = o.secp256r1 = o.prime256v1, o.p192 = o.secp192r1 = o.prime192v1, o.p384 = o.secp384r1, o.p521 = o.secp521r1;
  function r(a) {
    this.curveType = o[a], this.curveType || (this.curveType = {
      name: a
    }), this.curve = new e.ec(this.curveType.name), this.keys = void 0;
  }
  r.prototype.generateKeys = function(a, p) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(a, p);
  }, r.prototype.computeSecret = function(a, p, d) {
    p = p || "utf8", pe.Buffer.isBuffer(a) || (a = new pe.Buffer(a, p));
    var b = this.curve.keyFromPublic(a).getPublic(), g = b.mul(this.keys.getPrivate()).getX();
    return h(g, d, this.curveType.byteLength);
  }, r.prototype.getPublicKey = function(a, p) {
    var d = this.keys.getPublic(p === "compressed", !0);
    return p === "hybrid" && (d[d.length - 1] % 2 ? d[0] = 7 : d[0] = 6), h(d, a);
  }, r.prototype.getPrivateKey = function(a) {
    return h(this.keys.getPrivate(), a);
  }, r.prototype.setPublicKey = function(a, p) {
    return p = p || "utf8", pe.Buffer.isBuffer(a) || (a = new pe.Buffer(a, p)), this.keys._importPublic(a), this;
  }, r.prototype.setPrivateKey = function(a, p) {
    p = p || "utf8", pe.Buffer.isBuffer(a) || (a = new pe.Buffer(a, p));
    var d = new t(a);
    return d = d.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(d), this;
  };
  function h(a, p, d) {
    Array.isArray(a) || (a = a.toArray());
    var b = new pe.Buffer(a);
    if (d && b.length < d) {
      var g = new pe.Buffer(d - b.length);
      g.fill(0), b = pe.Buffer.concat([g, b]);
    }
    return p ? b.toString(p) : b;
  }
  return Lo;
}
var Oy = {}, R5 = P0, lc = ct.Buffer, Py = function(e, t) {
  for (var o = lc.alloc(0), r = 0, h; o.length < t; )
    h = N5(r++), o = lc.concat([o, R5("sha1").update(e).update(h).digest()]);
  return o.slice(0, t);
};
function N5(e) {
  var t = lc.allocUnsafe(4);
  return t.writeUInt32BE(e, 0), t;
}
var Ly = function(e, t) {
  for (var o = e.length, r = -1; ++r < o; )
    e[r] ^= t[r];
  return e;
}, hd = rr, D5 = ct.Buffer;
function O5(e, t) {
  return D5.from(e.toRed(hd.mont(t.modulus)).redPow(new hd(t.publicExponent)).fromRed().toArray());
}
var ky = O5, P5 = Bf, dc = Ua, L5 = P0, ld = Py, dd = Ly, Sh = rr, k5 = ky, U5 = sh, _i = ct.Buffer, F5 = function(e, t, o) {
  var r;
  e.padding ? r = e.padding : o ? r = 1 : r = 4;
  var h = P5(e), a;
  if (r === 4)
    a = q5(h, t);
  else if (r === 1)
    a = V5(h, t, o);
  else if (r === 3) {
    if (a = new Sh(t), a.cmp(h.modulus) >= 0)
      throw new Error("data too long for modulus");
  } else
    throw new Error("unknown padding");
  return o ? U5(a, h) : k5(a, h);
};
function q5(e, t) {
  var o = e.modulus.byteLength(), r = t.length, h = L5("sha1").update(_i.alloc(0)).digest(), a = h.length, p = 2 * a;
  if (r > o - p - 2)
    throw new Error("message too long");
  var d = _i.alloc(o - r - p - 2), b = o - a - 1, g = dc(a), w = dd(_i.concat([h, d, _i.alloc(1, 1), t], b), ld(g, b)), C = dd(g, ld(w, a));
  return new Sh(_i.concat([_i.alloc(1), C, w], o));
}
function V5(e, t, o) {
  var r = t.length, h = e.modulus.byteLength();
  if (r > h - 11)
    throw new Error("message too long");
  var a;
  return o ? a = _i.alloc(h - r - 3, 255) : a = K5(h - r - 3), new Sh(_i.concat([_i.from([0, o ? 1 : 2]), a, _i.alloc(1), t], h));
}
function K5(e) {
  for (var t = _i.allocUnsafe(e), o = 0, r = dc(e * 2), h = 0, a; o < e; )
    h === r.length && (r = dc(e * 2), h = 0), a = r[h++], a && (t[o++] = a);
  return t;
}
var $5 = Bf, pd = Py, vd = Ly, yd = rr, H5 = sh, G5 = P0, z5 = ky, I0 = ct.Buffer, j5 = function(e, t, o) {
  var r;
  e.padding ? r = e.padding : o ? r = 1 : r = 4;
  var h = $5(e), a = h.modulus.byteLength();
  if (t.length > a || new yd(t).cmp(h.modulus) >= 0)
    throw new Error("decryption error");
  var p;
  o ? p = z5(new yd(t), h) : p = H5(t, h);
  var d = I0.alloc(a - p.length);
  if (p = I0.concat([d, p], a), r === 4)
    return W5(h, p);
  if (r === 1)
    return Y5(h, p, o);
  if (r === 3)
    return p;
  throw new Error("unknown padding");
};
function W5(e, t) {
  var o = e.modulus.byteLength(), r = G5("sha1").update(I0.alloc(0)).digest(), h = r.length;
  if (t[0] !== 0)
    throw new Error("decryption error");
  var a = t.slice(1, h + 1), p = t.slice(h + 1), d = vd(a, pd(p, h)), b = vd(p, pd(d, o - h - 1));
  if (X5(r, b.slice(0, h)))
    throw new Error("decryption error");
  for (var g = h; b[g] === 0; )
    g++;
  if (b[g++] !== 1)
    throw new Error("decryption error");
  return b.slice(g);
}
function Y5(e, t, o) {
  for (var r = t.slice(0, 2), h = 2, a = 0; t[h++] !== 0; )
    if (h >= t.length) {
      a++;
      break;
    }
  var p = t.slice(2, h - 1);
  if ((r.toString("hex") !== "0002" && !o || r.toString("hex") !== "0001" && o) && a++, p.length < 8 && a++, a)
    throw new Error("decryption error");
  return t.slice(h);
}
function X5(e, t) {
  e = I0.from(e), t = I0.from(t);
  var o = 0, r = e.length;
  e.length !== t.length && (o++, r = Math.min(e.length, t.length));
  for (var h = -1; ++h < r; )
    o += e[h] ^ t[h];
  return o;
}
(function(e) {
  e.publicEncrypt = F5, e.privateDecrypt = j5, e.privateEncrypt = function(t, o) {
    return e.publicEncrypt(t, o, !0);
  }, e.publicDecrypt = function(t, o) {
    return e.privateDecrypt(t, o, !0);
  };
})(Oy);
var m0 = {};
function gd() {
  throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
}
var Uy = ct, md = Ua, Fy = Uy.Buffer, qy = Uy.kMaxLength, pc = Me.crypto || Me.msCrypto, Vy = Math.pow(2, 32) - 1;
function Ky(e, t) {
  if (typeof e != "number" || e !== e)
    throw new TypeError("offset must be a number");
  if (e > Vy || e < 0)
    throw new TypeError("offset must be a uint32");
  if (e > qy || e > t)
    throw new RangeError("offset out of range");
}
function $y(e, t, o) {
  if (typeof e != "number" || e !== e)
    throw new TypeError("size must be a number");
  if (e > Vy || e < 0)
    throw new TypeError("size must be a uint32");
  if (e + t > o || e > qy)
    throw new RangeError("buffer too small");
}
pc && pc.getRandomValues || !Ve.browser ? (m0.randomFill = Q5, m0.randomFillSync = Z5) : (m0.randomFill = gd, m0.randomFillSync = gd);
function Q5(e, t, o, r) {
  if (!Fy.isBuffer(e) && !(e instanceof Me.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  if (typeof t == "function")
    r = t, t = 0, o = e.length;
  else if (typeof o == "function")
    r = o, o = e.length - t;
  else if (typeof r != "function")
    throw new TypeError('"cb" argument must be a function');
  return Ky(t, e.length), $y(o, t, e.length), Hy(e, t, o, r);
}
function Hy(e, t, o, r) {
  if (Ve.browser) {
    var h = e.buffer, a = new Uint8Array(h, t, o);
    if (pc.getRandomValues(a), r) {
      Ve.nextTick(function() {
        r(null, e);
      });
      return;
    }
    return e;
  }
  if (r) {
    md(o, function(d, b) {
      if (d)
        return r(d);
      b.copy(e, t), r(null, e);
    });
    return;
  }
  var p = md(o);
  return p.copy(e, t), e;
}
function Z5(e, t, o) {
  if (typeof t > "u" && (t = 0), !Fy.isBuffer(e) && !(e instanceof Me.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  return Ky(t, e.length), o === void 0 && (o = e.length - t), $y(o, t, e.length), Hy(e, t, o);
}
var bd;
function _r() {
  if (bd)
    return st;
  bd = 1, st.randomBytes = st.rng = st.pseudoRandomBytes = st.prng = Ua, st.createHash = st.Hash = P0, st.createHmac = st.Hmac = iv;
  var e = Ux, t = Object.keys(e), o = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(t);
  st.getHashes = function() {
    return o;
  };
  var r = uf;
  st.pbkdf2 = r.pbkdf2, st.pbkdf2Sync = r.pbkdf2Sync;
  var h = Si;
  st.Cipher = h.Cipher, st.createCipher = h.createCipher, st.Cipheriv = h.Cipheriv, st.createCipheriv = h.createCipheriv, st.Decipher = h.Decipher, st.createDecipher = h.createDecipher, st.Decipheriv = h.Decipheriv, st.createDecipheriv = h.createDecipheriv, st.getCiphers = h.getCiphers, st.listCiphers = h.listCiphers;
  var a = y3();
  st.DiffieHellmanGroup = a.DiffieHellmanGroup, st.createDiffieHellmanGroup = a.createDiffieHellmanGroup, st.getDiffieHellman = a.getDiffieHellman, st.createDiffieHellman = a.createDiffieHellman, st.DiffieHellman = a.DiffieHellman;
  var p = T5();
  st.createSign = p.createSign, st.Sign = p.Sign, st.createVerify = p.createVerify, st.Verify = p.Verify, st.createECDH = M5();
  var d = Oy;
  st.publicEncrypt = d.publicEncrypt, st.privateEncrypt = d.privateEncrypt, st.publicDecrypt = d.publicDecrypt, st.privateDecrypt = d.privateDecrypt;
  var b = m0;
  return st.randomFill = b.randomFill, st.randomFillSync = b.randomFillSync, st.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, st.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, st;
}
var xd;
function xt() {
  return xd || (xd = 1, function(e, t) {
    (function(o, r) {
      e.exports = r();
    })(Me, function() {
      var o = o || function(r, h) {
        var a;
        if (typeof window < "u" && window.crypto && (a = window.crypto), typeof self < "u" && self.crypto && (a = self.crypto), typeof globalThis < "u" && globalThis.crypto && (a = globalThis.crypto), !a && typeof window < "u" && window.msCrypto && (a = window.msCrypto), !a && typeof Me < "u" && Me.crypto && (a = Me.crypto), !a && typeof bg == "function")
          try {
            a = _r();
          } catch {
          }
        var p = function() {
          if (a) {
            if (typeof a.getRandomValues == "function")
              try {
                return a.getRandomValues(new Uint32Array(1))[0];
              } catch {
              }
            if (typeof a.randomBytes == "function")
              try {
                return a.randomBytes(4).readInt32LE();
              } catch {
              }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        }, d = Object.create || /* @__PURE__ */ function() {
          function U() {
          }
          return function(H) {
            var z;
            return U.prototype = H, z = new U(), U.prototype = null, z;
          };
        }(), b = {}, g = b.lib = {}, w = g.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(U) {
              var H = d(this);
              return U && H.mixIn(U), (!H.hasOwnProperty("init") || this.init === H.init) && (H.init = function() {
                H.$super.init.apply(this, arguments);
              }), H.init.prototype = H, H.$super = this, H;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var U = this.extend();
              return U.init.apply(U, arguments), U;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(U) {
              for (var H in U)
                U.hasOwnProperty(H) && (this[H] = U[H]);
              U.hasOwnProperty("toString") && (this.toString = U.toString);
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }(), C = g.WordArray = w.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(U, H) {
            U = this.words = U || [], H != h ? this.sigBytes = H : this.sigBytes = U.length * 4;
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(U) {
            return (U || k).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(U) {
            var H = this.words, z = U.words, ee = this.sigBytes, ne = U.sigBytes;
            if (this.clamp(), ee % 4)
              for (var le = 0; le < ne; le++) {
                var Z = z[le >>> 2] >>> 24 - le % 4 * 8 & 255;
                H[ee + le >>> 2] |= Z << 24 - (ee + le) % 4 * 8;
              }
            else
              for (var ie = 0; ie < ne; ie += 4)
                H[ee + ie >>> 2] = z[ie >>> 2];
            return this.sigBytes += ne, this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var U = this.words, H = this.sigBytes;
            U[H >>> 2] &= 4294967295 << 32 - H % 4 * 8, U.length = r.ceil(H / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var U = w.clone.call(this);
            return U.words = this.words.slice(0), U;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(U) {
            for (var H = [], z = 0; z < U; z += 4)
              H.push(p());
            return new C.init(H, U);
          }
        }), T = b.enc = {}, k = T.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(U) {
            for (var H = U.words, z = U.sigBytes, ee = [], ne = 0; ne < z; ne++) {
              var le = H[ne >>> 2] >>> 24 - ne % 4 * 8 & 255;
              ee.push((le >>> 4).toString(16)), ee.push((le & 15).toString(16));
            }
            return ee.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(U) {
            for (var H = U.length, z = [], ee = 0; ee < H; ee += 2)
              z[ee >>> 3] |= parseInt(U.substr(ee, 2), 16) << 24 - ee % 8 * 4;
            return new C.init(z, H / 2);
          }
        }, q = T.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(U) {
            for (var H = U.words, z = U.sigBytes, ee = [], ne = 0; ne < z; ne++) {
              var le = H[ne >>> 2] >>> 24 - ne % 4 * 8 & 255;
              ee.push(String.fromCharCode(le));
            }
            return ee.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(U) {
            for (var H = U.length, z = [], ee = 0; ee < H; ee++)
              z[ee >>> 2] |= (U.charCodeAt(ee) & 255) << 24 - ee % 4 * 8;
            return new C.init(z, H);
          }
        }, O = T.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(U) {
            try {
              return decodeURIComponent(escape(q.stringify(U)));
            } catch {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(U) {
            return q.parse(unescape(encodeURIComponent(U)));
          }
        }, N = g.BufferedBlockAlgorithm = w.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new C.init(), this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(U) {
            typeof U == "string" && (U = O.parse(U)), this._data.concat(U), this._nDataBytes += U.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(U) {
            var H, z = this._data, ee = z.words, ne = z.sigBytes, le = this.blockSize, Z = le * 4, ie = ne / Z;
            U ? ie = r.ceil(ie) : ie = r.max((ie | 0) - this._minBufferSize, 0);
            var fe = ie * le, I = r.min(fe * 4, ne);
            if (fe) {
              for (var P = 0; P < fe; P += le)
                this._doProcessBlock(ee, P);
              H = ee.splice(0, fe), z.sigBytes -= I;
            }
            return new C.init(H, I);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var U = w.clone.call(this);
            return U._data = this._data.clone(), U;
          },
          _minBufferSize: 0
        });
        g.Hasher = N.extend({
          /**
           * Configuration options.
           */
          cfg: w.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(U) {
            this.cfg = this.cfg.extend(U), this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            N.reset.call(this), this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(U) {
            return this._append(U), this._process(), this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(U) {
            U && this._append(U);
            var H = this._doFinalize();
            return H;
          },
          blockSize: 16,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(U) {
            return function(H, z) {
              return new U.init(z).finalize(H);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(U) {
            return function(H, z) {
              return new j.HMAC.init(U, z).finalize(H);
            };
          }
        });
        var j = b.algo = {};
        return b;
      }(Math);
      return o;
    });
  }(zf)), zf.exports;
}
var ko = { exports: {} }, _d;
function If() {
  return _d || (_d = 1, function(e, t) {
    (function(o, r) {
      e.exports = r(xt());
    })(Me, function(o) {
      return function(r) {
        var h = o, a = h.lib, p = a.Base, d = a.WordArray, b = h.x64 = {};
        b.Word = p.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(g, w) {
            this.high = g, this.low = w;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        }), b.WordArray = p.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(g, w) {
            g = this.words = g || [], w != r ? this.sigBytes = w : this.sigBytes = g.length * 8;
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            for (var g = this.words, w = g.length, C = [], T = 0; T < w; T++) {
              var k = g[T];
              C.push(k.high), C.push(k.low);
            }
            return d.create(C, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            for (var g = p.clone.call(this), w = g.words = this.words.slice(0), C = w.length, T = 0; T < C; T++)
              w[T] = w[T].clone();
            return g;
          }
        });
      }(), o;
    });
  }(ko)), ko.exports;
}
var Uo = { exports: {} }, Ed;
function J5() {
  return Ed || (Ed = 1, function(e, t) {
    (function(o, r) {
      e.exports = r(xt());
    })(Me, function(o) {
      return function() {
        if (typeof ArrayBuffer == "function") {
          var r = o, h = r.lib, a = h.WordArray, p = a.init, d = a.init = function(b) {
            if (b instanceof ArrayBuffer && (b = new Uint8Array(b)), (b instanceof Int8Array || typeof Uint8ClampedArray < "u" && b instanceof Uint8ClampedArray || b instanceof Int16Array || b instanceof Uint16Array || b instanceof Int32Array || b instanceof Uint32Array || b instanceof Float32Array || b instanceof Float64Array) && (b = new Uint8Array(b.buffer, b.byteOffset, b.byteLength)), b instanceof Uint8Array) {
              for (var g = b.byteLength, w = [], C = 0; C < g; C++)
                w[C >>> 2] |= b[C] << 24 - C % 4 * 8;
              p.call(this, w, g);
            } else
              p.apply(this, arguments);
          };
          d.prototype = a;
        }
      }(), o.lib.WordArray;
    });
  }(Uo)), Uo.exports;
}
var Fo = { exports: {} }, Sd;
function e_() {
  return Sd || (Sd = 1, function(e, t) {
    (function(o, r) {
      e.exports = r(xt());
    })(Me, function(o) {
      return function() {
        var r = o, h = r.lib, a = h.WordArray, p = r.enc;
        p.Utf16 = p.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: function(b) {
            for (var g = b.words, w = b.sigBytes, C = [], T = 0; T < w; T += 2) {
              var k = g[T >>> 2] >>> 16 - T % 4 * 8 & 65535;
              C.push(String.fromCharCode(k));
            }
            return C.join("");
          },
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: function(b) {
            for (var g = b.length, w = [], C = 0; C < g; C++)
              w[C >>> 1] |= b.charCodeAt(C) << 16 - C % 2 * 16;
            return a.create(w, g * 2);
          }
        }, p.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: function(b) {
            for (var g = b.words, w = b.sigBytes, C = [], T = 0; T < w; T += 2) {
              var k = d(g[T >>> 2] >>> 16 - T % 4 * 8 & 65535);
              C.push(String.fromCharCode(k));
            }
            return C.join("");
          },
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: function(b) {
            for (var g = b.length, w = [], C = 0; C < g; C++)
              w[C >>> 1] |= d(b.charCodeAt(C) << 16 - C % 2 * 16);
            return a.create(w, g * 2);
          }
        };
        function d(b) {
          return b << 8 & 4278255360 | b >>> 8 & 16711935;
        }
      }(), o.enc.Utf16;
    });
  }(Fo)), Fo.exports;
}
var qo = { exports: {} }, wd;
function ja() {
  return wd || (wd = 1, function(e, t) {
    (function(o, r) {
      e.exports = r(xt());
    })(Me, function(o) {
      return function() {
        var r = o, h = r.lib, a = h.WordArray, p = r.enc;
        p.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(b) {
            var g = b.words, w = b.sigBytes, C = this._map;
            b.clamp();
            for (var T = [], k = 0; k < w; k += 3)
              for (var q = g[k >>> 2] >>> 24 - k % 4 * 8 & 255, O = g[k + 1 >>> 2] >>> 24 - (k + 1) % 4 * 8 & 255, N = g[k + 2 >>> 2] >>> 24 - (k + 2) % 4 * 8 & 255, j = q << 16 | O << 8 | N, U = 0; U < 4 && k + U * 0.75 < w; U++)
                T.push(C.charAt(j >>> 6 * (3 - U) & 63));
            var H = C.charAt(64);
            if (H)
              for (; T.length % 4; )
                T.push(H);
            return T.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(b) {
            var g = b.length, w = this._map, C = this._reverseMap;
            if (!C) {
              C = this._reverseMap = [];
              for (var T = 0; T < w.length; T++)
                C[w.charCodeAt(T)] = T;
            }
            var k = w.charAt(64);
            if (k) {
              var q = b.indexOf(k);
              q !== -1 && (g = q);
            }
            return d(b, g, C);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function d(b, g, w) {
          for (var C = [], T = 0, k = 0; k < g; k++)
            if (k % 4) {
              var q = w[b.charCodeAt(k - 1)] << k % 4 * 2, O = w[b.charCodeAt(k)] >>> 6 - k % 4 * 2, N = q | O;
              C[T >>> 2] |= N << 24 - T % 4 * 8, T++;
            }
          return a.create(C, T);
        }
      }(), o.enc.Base64;
    });
  }(qo)), qo.exports;
}
var Vo = { exports: {} }, Cd;
function t_() {
  return Cd || (Cd = 1, function(e, t) {
    (function(o, r) {
      e.exports = r(xt());
    })(Me, function(o) {
      return function() {
        var r = o, h = r.lib, a = h.WordArray, p = r.enc;
        p.Base64url = {
          /**
           * Converts a word array to a Base64url string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {string} The Base64url string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
           */
          stringify: function(b, g = !0) {
            var w = b.words, C = b.sigBytes, T = g ? this._safe_map : this._map;
            b.clamp();
            for (var k = [], q = 0; q < C; q += 3)
              for (var O = w[q >>> 2] >>> 24 - q % 4 * 8 & 255, N = w[q + 1 >>> 2] >>> 24 - (q + 1) % 4 * 8 & 255, j = w[q + 2 >>> 2] >>> 24 - (q + 2) % 4 * 8 & 255, U = O << 16 | N << 8 | j, H = 0; H < 4 && q + H * 0.75 < C; H++)
                k.push(T.charAt(U >>> 6 * (3 - H) & 63));
            var z = T.charAt(64);
            if (z)
              for (; k.length % 4; )
                k.push(z);
            return k.join("");
          },
          /**
           * Converts a Base64url string to a word array.
           *
           * @param {string} base64Str The Base64url string.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
           */
          parse: function(b, g = !0) {
            var w = b.length, C = g ? this._safe_map : this._map, T = this._reverseMap;
            if (!T) {
              T = this._reverseMap = [];
              for (var k = 0; k < C.length; k++)
                T[C.charCodeAt(k)] = k;
            }
            var q = C.charAt(64);
            if (q) {
              var O = b.indexOf(q);
              O !== -1 && (w = O);
            }
            return d(b, w, T);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function d(b, g, w) {
          for (var C = [], T = 0, k = 0; k < g; k++)
            if (k % 4) {
              var q = w[b.charCodeAt(k - 1)] << k % 4 * 2, O = w[b.charCodeAt(k)] >>> 6 - k % 4 * 2, N = q | O;
              C[T >>> 2] |= N << 24 - T % 4 * 8, T++;
            }
          return a.create(C, T);
        }
      }(), o.enc.Base64url;
    });
  }(Vo)), Vo.exports;
}
var Ko = { exports: {} }, Ad;
function Wa() {
  return Ad || (Ad = 1, function(e, t) {
    (function(o, r) {
      e.exports = r(xt());
    })(Me, function(o) {
      return function(r) {
        var h = o, a = h.lib, p = a.WordArray, d = a.Hasher, b = h.algo, g = [];
        (function() {
          for (var O = 0; O < 64; O++)
            g[O] = r.abs(r.sin(O + 1)) * 4294967296 | 0;
        })();
        var w = b.MD5 = d.extend({
          _doReset: function() {
            this._hash = new p.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(O, N) {
            for (var j = 0; j < 16; j++) {
              var U = N + j, H = O[U];
              O[U] = (H << 8 | H >>> 24) & 16711935 | (H << 24 | H >>> 8) & 4278255360;
            }
            var z = this._hash.words, ee = O[N + 0], ne = O[N + 1], le = O[N + 2], Z = O[N + 3], ie = O[N + 4], fe = O[N + 5], I = O[N + 6], P = O[N + 7], f = O[N + 8], y = O[N + 9], v = O[N + 10], M = O[N + 11], B = O[N + 12], S = O[N + 13], _ = O[N + 14], E = O[N + 15], m = z[0], A = z[1], $ = z[2], X = z[3];
            m = C(m, A, $, X, ee, 7, g[0]), X = C(X, m, A, $, ne, 12, g[1]), $ = C($, X, m, A, le, 17, g[2]), A = C(A, $, X, m, Z, 22, g[3]), m = C(m, A, $, X, ie, 7, g[4]), X = C(X, m, A, $, fe, 12, g[5]), $ = C($, X, m, A, I, 17, g[6]), A = C(A, $, X, m, P, 22, g[7]), m = C(m, A, $, X, f, 7, g[8]), X = C(X, m, A, $, y, 12, g[9]), $ = C($, X, m, A, v, 17, g[10]), A = C(A, $, X, m, M, 22, g[11]), m = C(m, A, $, X, B, 7, g[12]), X = C(X, m, A, $, S, 12, g[13]), $ = C($, X, m, A, _, 17, g[14]), A = C(A, $, X, m, E, 22, g[15]), m = T(m, A, $, X, ne, 5, g[16]), X = T(X, m, A, $, I, 9, g[17]), $ = T($, X, m, A, M, 14, g[18]), A = T(A, $, X, m, ee, 20, g[19]), m = T(m, A, $, X, fe, 5, g[20]), X = T(X, m, A, $, v, 9, g[21]), $ = T($, X, m, A, E, 14, g[22]), A = T(A, $, X, m, ie, 20, g[23]), m = T(m, A, $, X, y, 5, g[24]), X = T(X, m, A, $, _, 9, g[25]), $ = T($, X, m, A, Z, 14, g[26]), A = T(A, $, X, m, f, 20, g[27]), m = T(m, A, $, X, S, 5, g[28]), X = T(X, m, A, $, le, 9, g[29]), $ = T($, X, m, A, P, 14, g[30]), A = T(A, $, X, m, B, 20, g[31]), m = k(m, A, $, X, fe, 4, g[32]), X = k(X, m, A, $, f, 11, g[33]), $ = k($, X, m, A, M, 16, g[34]), A = k(A, $, X, m, _, 23, g[35]), m = k(m, A, $, X, ne, 4, g[36]), X = k(X, m, A, $, ie, 11, g[37]), $ = k($, X, m, A, P, 16, g[38]), A = k(A, $, X, m, v, 23, g[39]), m = k(m, A, $, X, S, 4, g[40]), X = k(X, m, A, $, ee, 11, g[41]), $ = k($, X, m, A, Z, 16, g[42]), A = k(A, $, X, m, I, 23, g[43]), m = k(m, A, $, X, y, 4, g[44]), X = k(X, m, A, $, B, 11, g[45]), $ = k($, X, m, A, E, 16, g[46]), A = k(A, $, X, m, le, 23, g[47]), m = q(m, A, $, X, ee, 6, g[48]), X = q(X, m, A, $, P, 10, g[49]), $ = q($, X, m, A, _, 15, g[50]), A = q(A, $, X, m, fe, 21, g[51]), m = q(m, A, $, X, B, 6, g[52]), X = q(X, m, A, $, Z, 10, g[53]), $ = q($, X, m, A, v, 15, g[54]), A = q(A, $, X, m, ne, 21, g[55]), m = q(m, A, $, X, f, 6, g[56]), X = q(X, m, A, $, E, 10, g[57]), $ = q($, X, m, A, I, 15, g[58]), A = q(A, $, X, m, S, 21, g[59]), m = q(m, A, $, X, ie, 6, g[60]), X = q(X, m, A, $, M, 10, g[61]), $ = q($, X, m, A, le, 15, g[62]), A = q(A, $, X, m, y, 21, g[63]), z[0] = z[0] + m | 0, z[1] = z[1] + A | 0, z[2] = z[2] + $ | 0, z[3] = z[3] + X | 0;
          },
          _doFinalize: function() {
            var O = this._data, N = O.words, j = this._nDataBytes * 8, U = O.sigBytes * 8;
            N[U >>> 5] |= 128 << 24 - U % 32;
            var H = r.floor(j / 4294967296), z = j;
            N[(U + 64 >>> 9 << 4) + 15] = (H << 8 | H >>> 24) & 16711935 | (H << 24 | H >>> 8) & 4278255360, N[(U + 64 >>> 9 << 4) + 14] = (z << 8 | z >>> 24) & 16711935 | (z << 24 | z >>> 8) & 4278255360, O.sigBytes = (N.length + 1) * 4, this._process();
            for (var ee = this._hash, ne = ee.words, le = 0; le < 4; le++) {
              var Z = ne[le];
              ne[le] = (Z << 8 | Z >>> 24) & 16711935 | (Z << 24 | Z >>> 8) & 4278255360;
            }
            return ee;
          },
          clone: function() {
            var O = d.clone.call(this);
            return O._hash = this._hash.clone(), O;
          }
        });
        function C(O, N, j, U, H, z, ee) {
          var ne = O + (N & j | ~N & U) + H + ee;
          return (ne << z | ne >>> 32 - z) + N;
        }
        function T(O, N, j, U, H, z, ee) {
          var ne = O + (N & U | j & ~U) + H + ee;
          return (ne << z | ne >>> 32 - z) + N;
        }
        function k(O, N, j, U, H, z, ee) {
          var ne = O + (N ^ j ^ U) + H + ee;
          return (ne << z | ne >>> 32 - z) + N;
        }
        function q(O, N, j, U, H, z, ee) {
          var ne = O + (j ^ (N | ~U)) + H + ee;
          return (ne << z | ne >>> 32 - z) + N;
        }
        h.MD5 = d._createHelper(w), h.HmacMD5 = d._createHmacHelper(w);
      }(Math), o.MD5;
    });
  }(Ko)), Ko.exports;
}
var $o = { exports: {} }, Bd;
function wh() {
  return Bd || (Bd = 1, function(e, t) {
    (function(o, r) {
      e.exports = r(xt());
    })(Me, function(o) {
      return function() {
        var r = o, h = r.lib, a = h.WordArray, p = h.Hasher, d = r.algo, b = [], g = d.SHA1 = p.extend({
          _doReset: function() {
            this._hash = new a.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(w, C) {
            for (var T = this._hash.words, k = T[0], q = T[1], O = T[2], N = T[3], j = T[4], U = 0; U < 80; U++) {
              if (U < 16)
                b[U] = w[C + U] | 0;
              else {
                var H = b[U - 3] ^ b[U - 8] ^ b[U - 14] ^ b[U - 16];
                b[U] = H << 1 | H >>> 31;
              }
              var z = (k << 5 | k >>> 27) + j + b[U];
              U < 20 ? z += (q & O | ~q & N) + 1518500249 : U < 40 ? z += (q ^ O ^ N) + 1859775393 : U < 60 ? z += (q & O | q & N | O & N) - 1894007588 : z += (q ^ O ^ N) - 899497514, j = N, N = O, O = q << 30 | q >>> 2, q = k, k = z;
            }
            T[0] = T[0] + k | 0, T[1] = T[1] + q | 0, T[2] = T[2] + O | 0, T[3] = T[3] + N | 0, T[4] = T[4] + j | 0;
          },
          _doFinalize: function() {
            var w = this._data, C = w.words, T = this._nDataBytes * 8, k = w.sigBytes * 8;
            return C[k >>> 5] |= 128 << 24 - k % 32, C[(k + 64 >>> 9 << 4) + 14] = Math.floor(T / 4294967296), C[(k + 64 >>> 9 << 4) + 15] = T, w.sigBytes = C.length * 4, this._process(), this._hash;
          },
          clone: function() {
            var w = p.clone.call(this);
            return w._hash = this._hash.clone(), w;
          }
        });
        r.SHA1 = p._createHelper(g), r.HmacSHA1 = p._createHmacHelper(g);
      }(), o.SHA1;
    });
  }($o)), $o.exports;
}
var Ho = { exports: {} }, Id;
function Gy() {
  return Id || (Id = 1, function(e, t) {
    (function(o, r) {
      e.exports = r(xt());
    })(Me, function(o) {
      return function(r) {
        var h = o, a = h.lib, p = a.WordArray, d = a.Hasher, b = h.algo, g = [], w = [];
        (function() {
          function k(j) {
            for (var U = r.sqrt(j), H = 2; H <= U; H++)
              if (!(j % H))
                return !1;
            return !0;
          }
          function q(j) {
            return (j - (j | 0)) * 4294967296 | 0;
          }
          for (var O = 2, N = 0; N < 64; )
            k(O) && (N < 8 && (g[N] = q(r.pow(O, 1 / 2))), w[N] = q(r.pow(O, 1 / 3)), N++), O++;
        })();
        var C = [], T = b.SHA256 = d.extend({
          _doReset: function() {
            this._hash = new p.init(g.slice(0));
          },
          _doProcessBlock: function(k, q) {
            for (var O = this._hash.words, N = O[0], j = O[1], U = O[2], H = O[3], z = O[4], ee = O[5], ne = O[6], le = O[7], Z = 0; Z < 64; Z++) {
              if (Z < 16)
                C[Z] = k[q + Z] | 0;
              else {
                var ie = C[Z - 15], fe = (ie << 25 | ie >>> 7) ^ (ie << 14 | ie >>> 18) ^ ie >>> 3, I = C[Z - 2], P = (I << 15 | I >>> 17) ^ (I << 13 | I >>> 19) ^ I >>> 10;
                C[Z] = fe + C[Z - 7] + P + C[Z - 16];
              }
              var f = z & ee ^ ~z & ne, y = N & j ^ N & U ^ j & U, v = (N << 30 | N >>> 2) ^ (N << 19 | N >>> 13) ^ (N << 10 | N >>> 22), M = (z << 26 | z >>> 6) ^ (z << 21 | z >>> 11) ^ (z << 7 | z >>> 25), B = le + M + f + w[Z] + C[Z], S = v + y;
              le = ne, ne = ee, ee = z, z = H + B | 0, H = U, U = j, j = N, N = B + S | 0;
            }
            O[0] = O[0] + N | 0, O[1] = O[1] + j | 0, O[2] = O[2] + U | 0, O[3] = O[3] + H | 0, O[4] = O[4] + z | 0, O[5] = O[5] + ee | 0, O[6] = O[6] + ne | 0, O[7] = O[7] + le | 0;
          },
          _doFinalize: function() {
            var k = this._data, q = k.words, O = this._nDataBytes * 8, N = k.sigBytes * 8;
            return q[N >>> 5] |= 128 << 24 - N % 32, q[(N + 64 >>> 9 << 4) + 14] = r.floor(O / 4294967296), q[(N + 64 >>> 9 << 4) + 15] = O, k.sigBytes = q.length * 4, this._process(), this._hash;
          },
          clone: function() {
            var k = d.clone.call(this);
            return k._hash = this._hash.clone(), k;
          }
        });
        h.SHA256 = d._createHelper(T), h.HmacSHA256 = d._createHmacHelper(T);
      }(Math), o.SHA256;
    });
  }(Ho)), Ho.exports;
}
var Go = { exports: {} }, Td;
function r_() {
  return Td || (Td = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), Gy());
    })(Me, function(o) {
      return function() {
        var r = o, h = r.lib, a = h.WordArray, p = r.algo, d = p.SHA256, b = p.SHA224 = d.extend({
          _doReset: function() {
            this._hash = new a.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var g = d._doFinalize.call(this);
            return g.sigBytes -= 4, g;
          }
        });
        r.SHA224 = d._createHelper(b), r.HmacSHA224 = d._createHmacHelper(b);
      }(), o.SHA224;
    });
  }(Go)), Go.exports;
}
var zo = { exports: {} }, Md;
function zy() {
  return Md || (Md = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), If());
    })(Me, function(o) {
      return function() {
        var r = o, h = r.lib, a = h.Hasher, p = r.x64, d = p.Word, b = p.WordArray, g = r.algo;
        function w() {
          return d.create.apply(d, arguments);
        }
        var C = [
          w(1116352408, 3609767458),
          w(1899447441, 602891725),
          w(3049323471, 3964484399),
          w(3921009573, 2173295548),
          w(961987163, 4081628472),
          w(1508970993, 3053834265),
          w(2453635748, 2937671579),
          w(2870763221, 3664609560),
          w(3624381080, 2734883394),
          w(310598401, 1164996542),
          w(607225278, 1323610764),
          w(1426881987, 3590304994),
          w(1925078388, 4068182383),
          w(2162078206, 991336113),
          w(2614888103, 633803317),
          w(3248222580, 3479774868),
          w(3835390401, 2666613458),
          w(4022224774, 944711139),
          w(264347078, 2341262773),
          w(604807628, 2007800933),
          w(770255983, 1495990901),
          w(1249150122, 1856431235),
          w(1555081692, 3175218132),
          w(1996064986, 2198950837),
          w(2554220882, 3999719339),
          w(2821834349, 766784016),
          w(2952996808, 2566594879),
          w(3210313671, 3203337956),
          w(3336571891, 1034457026),
          w(3584528711, 2466948901),
          w(113926993, 3758326383),
          w(338241895, 168717936),
          w(666307205, 1188179964),
          w(773529912, 1546045734),
          w(1294757372, 1522805485),
          w(1396182291, 2643833823),
          w(1695183700, 2343527390),
          w(1986661051, 1014477480),
          w(2177026350, 1206759142),
          w(2456956037, 344077627),
          w(2730485921, 1290863460),
          w(2820302411, 3158454273),
          w(3259730800, 3505952657),
          w(3345764771, 106217008),
          w(3516065817, 3606008344),
          w(3600352804, 1432725776),
          w(4094571909, 1467031594),
          w(275423344, 851169720),
          w(430227734, 3100823752),
          w(506948616, 1363258195),
          w(659060556, 3750685593),
          w(883997877, 3785050280),
          w(958139571, 3318307427),
          w(1322822218, 3812723403),
          w(1537002063, 2003034995),
          w(1747873779, 3602036899),
          w(1955562222, 1575990012),
          w(2024104815, 1125592928),
          w(2227730452, 2716904306),
          w(2361852424, 442776044),
          w(2428436474, 593698344),
          w(2756734187, 3733110249),
          w(3204031479, 2999351573),
          w(3329325298, 3815920427),
          w(3391569614, 3928383900),
          w(3515267271, 566280711),
          w(3940187606, 3454069534),
          w(4118630271, 4000239992),
          w(116418474, 1914138554),
          w(174292421, 2731055270),
          w(289380356, 3203993006),
          w(460393269, 320620315),
          w(685471733, 587496836),
          w(852142971, 1086792851),
          w(1017036298, 365543100),
          w(1126000580, 2618297676),
          w(1288033470, 3409855158),
          w(1501505948, 4234509866),
          w(1607167915, 987167468),
          w(1816402316, 1246189591)
        ], T = [];
        (function() {
          for (var q = 0; q < 80; q++)
            T[q] = w();
        })();
        var k = g.SHA512 = a.extend({
          _doReset: function() {
            this._hash = new b.init([
              new d.init(1779033703, 4089235720),
              new d.init(3144134277, 2227873595),
              new d.init(1013904242, 4271175723),
              new d.init(2773480762, 1595750129),
              new d.init(1359893119, 2917565137),
              new d.init(2600822924, 725511199),
              new d.init(528734635, 4215389547),
              new d.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(q, O) {
            for (var N = this._hash.words, j = N[0], U = N[1], H = N[2], z = N[3], ee = N[4], ne = N[5], le = N[6], Z = N[7], ie = j.high, fe = j.low, I = U.high, P = U.low, f = H.high, y = H.low, v = z.high, M = z.low, B = ee.high, S = ee.low, _ = ne.high, E = ne.low, m = le.high, A = le.low, $ = Z.high, X = Z.low, oe = ie, J = fe, W = I, Q = P, me = f, be = y, Y = v, re = M, de = B, Ae = S, qe = _, x = E, L = m, D = A, F = $, ue = X, ge = 0; ge < 80; ge++) {
              var ce, ve, Re = T[ge];
              if (ge < 16)
                ve = Re.high = q[O + ge * 2] | 0, ce = Re.low = q[O + ge * 2 + 1] | 0;
              else {
                var ke = T[ge - 15], Ce = ke.high, Le = ke.low, Oe = (Ce >>> 1 | Le << 31) ^ (Ce >>> 8 | Le << 24) ^ Ce >>> 7, Pe = (Le >>> 1 | Ce << 31) ^ (Le >>> 8 | Ce << 24) ^ (Le >>> 7 | Ce << 25), et = T[ge - 2], Ye = et.high, Ne = et.low, Tt = (Ye >>> 19 | Ne << 13) ^ (Ye << 3 | Ne >>> 29) ^ Ye >>> 6, tt = (Ne >>> 19 | Ye << 13) ^ (Ne << 3 | Ye >>> 29) ^ (Ne >>> 6 | Ye << 26), Ue = T[ge - 7], Ct = Ue.high, rt = Ue.low, Ke = T[ge - 16], ii = Ke.high, it = Ke.low;
                ce = Pe + rt, ve = Oe + Ct + (ce >>> 0 < Pe >>> 0 ? 1 : 0), ce = ce + tt, ve = ve + Tt + (ce >>> 0 < tt >>> 0 ? 1 : 0), ce = ce + it, ve = ve + ii + (ce >>> 0 < it >>> 0 ? 1 : 0), Re.high = ve, Re.low = ce;
              }
              var $e = de & qe ^ ~de & L, Ot = Ae & x ^ ~Ae & D, vt = oe & W ^ oe & me ^ W & me, Fe = J & Q ^ J & be ^ Q & be, ni = (oe >>> 28 | J << 4) ^ (oe << 30 | J >>> 2) ^ (oe << 25 | J >>> 7), nt = (J >>> 28 | oe << 4) ^ (J << 30 | oe >>> 2) ^ (J << 25 | oe >>> 7), ze = (de >>> 14 | Ae << 18) ^ (de >>> 18 | Ae << 14) ^ (de << 23 | Ae >>> 9), oi = (Ae >>> 14 | de << 18) ^ (Ae >>> 18 | de << 14) ^ (Ae << 23 | de >>> 9), ot = C[ge], Xe = ot.high, Dt = ot.low, Ze = ue + oi, je = F + ze + (Ze >>> 0 < ue >>> 0 ? 1 : 0), Ze = Ze + Ot, je = je + $e + (Ze >>> 0 < Ot >>> 0 ? 1 : 0), Ze = Ze + Dt, je = je + Xe + (Ze >>> 0 < Dt >>> 0 ? 1 : 0), Ze = Ze + ce, je = je + ve + (Ze >>> 0 < ce >>> 0 ? 1 : 0), ri = nt + Fe, St = ni + vt + (ri >>> 0 < nt >>> 0 ? 1 : 0);
              F = L, ue = D, L = qe, D = x, qe = de, x = Ae, Ae = re + Ze | 0, de = Y + je + (Ae >>> 0 < re >>> 0 ? 1 : 0) | 0, Y = me, re = be, me = W, be = Q, W = oe, Q = J, J = Ze + ri | 0, oe = je + St + (J >>> 0 < Ze >>> 0 ? 1 : 0) | 0;
            }
            fe = j.low = fe + J, j.high = ie + oe + (fe >>> 0 < J >>> 0 ? 1 : 0), P = U.low = P + Q, U.high = I + W + (P >>> 0 < Q >>> 0 ? 1 : 0), y = H.low = y + be, H.high = f + me + (y >>> 0 < be >>> 0 ? 1 : 0), M = z.low = M + re, z.high = v + Y + (M >>> 0 < re >>> 0 ? 1 : 0), S = ee.low = S + Ae, ee.high = B + de + (S >>> 0 < Ae >>> 0 ? 1 : 0), E = ne.low = E + x, ne.high = _ + qe + (E >>> 0 < x >>> 0 ? 1 : 0), A = le.low = A + D, le.high = m + L + (A >>> 0 < D >>> 0 ? 1 : 0), X = Z.low = X + ue, Z.high = $ + F + (X >>> 0 < ue >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var q = this._data, O = q.words, N = this._nDataBytes * 8, j = q.sigBytes * 8;
            O[j >>> 5] |= 128 << 24 - j % 32, O[(j + 128 >>> 10 << 5) + 30] = Math.floor(N / 4294967296), O[(j + 128 >>> 10 << 5) + 31] = N, q.sigBytes = O.length * 4, this._process();
            var U = this._hash.toX32();
            return U;
          },
          clone: function() {
            var q = a.clone.call(this);
            return q._hash = this._hash.clone(), q;
          },
          blockSize: 1024 / 32
        });
        r.SHA512 = a._createHelper(k), r.HmacSHA512 = a._createHmacHelper(k);
      }(), o.SHA512;
    });
  }(zo)), zo.exports;
}
var jo = { exports: {} }, Rd;
function i_() {
  return Rd || (Rd = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), If(), zy());
    })(Me, function(o) {
      return function() {
        var r = o, h = r.x64, a = h.Word, p = h.WordArray, d = r.algo, b = d.SHA512, g = d.SHA384 = b.extend({
          _doReset: function() {
            this._hash = new p.init([
              new a.init(3418070365, 3238371032),
              new a.init(1654270250, 914150663),
              new a.init(2438529370, 812702999),
              new a.init(355462360, 4144912697),
              new a.init(1731405415, 4290775857),
              new a.init(2394180231, 1750603025),
              new a.init(3675008525, 1694076839),
              new a.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var w = b._doFinalize.call(this);
            return w.sigBytes -= 16, w;
          }
        });
        r.SHA384 = b._createHelper(g), r.HmacSHA384 = b._createHmacHelper(g);
      }(), o.SHA384;
    });
  }(jo)), jo.exports;
}
var Wo = { exports: {} }, Nd;
function n_() {
  return Nd || (Nd = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), If());
    })(Me, function(o) {
      return function(r) {
        var h = o, a = h.lib, p = a.WordArray, d = a.Hasher, b = h.x64, g = b.Word, w = h.algo, C = [], T = [], k = [];
        (function() {
          for (var N = 1, j = 0, U = 0; U < 24; U++) {
            C[N + 5 * j] = (U + 1) * (U + 2) / 2 % 64;
            var H = j % 5, z = (2 * N + 3 * j) % 5;
            N = H, j = z;
          }
          for (var N = 0; N < 5; N++)
            for (var j = 0; j < 5; j++)
              T[N + 5 * j] = j + (2 * N + 3 * j) % 5 * 5;
          for (var ee = 1, ne = 0; ne < 24; ne++) {
            for (var le = 0, Z = 0, ie = 0; ie < 7; ie++) {
              if (ee & 1) {
                var fe = (1 << ie) - 1;
                fe < 32 ? Z ^= 1 << fe : le ^= 1 << fe - 32;
              }
              ee & 128 ? ee = ee << 1 ^ 113 : ee <<= 1;
            }
            k[ne] = g.create(le, Z);
          }
        })();
        var q = [];
        (function() {
          for (var N = 0; N < 25; N++)
            q[N] = g.create();
        })();
        var O = w.SHA3 = d.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: d.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            for (var N = this._state = [], j = 0; j < 25; j++)
              N[j] = new g.init();
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(N, j) {
            for (var U = this._state, H = this.blockSize / 2, z = 0; z < H; z++) {
              var ee = N[j + 2 * z], ne = N[j + 2 * z + 1];
              ee = (ee << 8 | ee >>> 24) & 16711935 | (ee << 24 | ee >>> 8) & 4278255360, ne = (ne << 8 | ne >>> 24) & 16711935 | (ne << 24 | ne >>> 8) & 4278255360;
              var le = U[z];
              le.high ^= ne, le.low ^= ee;
            }
            for (var Z = 0; Z < 24; Z++) {
              for (var ie = 0; ie < 5; ie++) {
                for (var fe = 0, I = 0, P = 0; P < 5; P++) {
                  var le = U[ie + 5 * P];
                  fe ^= le.high, I ^= le.low;
                }
                var f = q[ie];
                f.high = fe, f.low = I;
              }
              for (var ie = 0; ie < 5; ie++)
                for (var y = q[(ie + 4) % 5], v = q[(ie + 1) % 5], M = v.high, B = v.low, fe = y.high ^ (M << 1 | B >>> 31), I = y.low ^ (B << 1 | M >>> 31), P = 0; P < 5; P++) {
                  var le = U[ie + 5 * P];
                  le.high ^= fe, le.low ^= I;
                }
              for (var S = 1; S < 25; S++) {
                var fe, I, le = U[S], _ = le.high, E = le.low, m = C[S];
                m < 32 ? (fe = _ << m | E >>> 32 - m, I = E << m | _ >>> 32 - m) : (fe = E << m - 32 | _ >>> 64 - m, I = _ << m - 32 | E >>> 64 - m);
                var A = q[T[S]];
                A.high = fe, A.low = I;
              }
              var $ = q[0], X = U[0];
              $.high = X.high, $.low = X.low;
              for (var ie = 0; ie < 5; ie++)
                for (var P = 0; P < 5; P++) {
                  var S = ie + 5 * P, le = U[S], oe = q[S], J = q[(ie + 1) % 5 + 5 * P], W = q[(ie + 2) % 5 + 5 * P];
                  le.high = oe.high ^ ~J.high & W.high, le.low = oe.low ^ ~J.low & W.low;
                }
              var le = U[0], Q = k[Z];
              le.high ^= Q.high, le.low ^= Q.low;
            }
          },
          _doFinalize: function() {
            var N = this._data, j = N.words;
            this._nDataBytes * 8;
            var U = N.sigBytes * 8, H = this.blockSize * 32;
            j[U >>> 5] |= 1 << 24 - U % 32, j[(r.ceil((U + 1) / H) * H >>> 5) - 1] |= 128, N.sigBytes = j.length * 4, this._process();
            for (var z = this._state, ee = this.cfg.outputLength / 8, ne = ee / 8, le = [], Z = 0; Z < ne; Z++) {
              var ie = z[Z], fe = ie.high, I = ie.low;
              fe = (fe << 8 | fe >>> 24) & 16711935 | (fe << 24 | fe >>> 8) & 4278255360, I = (I << 8 | I >>> 24) & 16711935 | (I << 24 | I >>> 8) & 4278255360, le.push(I), le.push(fe);
            }
            return new p.init(le, ee);
          },
          clone: function() {
            for (var N = d.clone.call(this), j = N._state = this._state.slice(0), U = 0; U < 25; U++)
              j[U] = j[U].clone();
            return N;
          }
        });
        h.SHA3 = d._createHelper(O), h.HmacSHA3 = d._createHmacHelper(O);
      }(Math), o.SHA3;
    });
  }(Wo)), Wo.exports;
}
var Yo = { exports: {} }, Dd;
function a_() {
  return Dd || (Dd = 1, function(e, t) {
    (function(o, r) {
      e.exports = r(xt());
    })(Me, function(o) {
      /** @preserve
      			(c) 2012 by Cédric Mesnil. All rights reserved.
      
      			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
      
      			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
      			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
      
      			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      			*/
      return function(r) {
        var h = o, a = h.lib, p = a.WordArray, d = a.Hasher, b = h.algo, g = p.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]), w = p.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]), C = p.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]), T = p.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]), k = p.create([0, 1518500249, 1859775393, 2400959708, 2840853838]), q = p.create([1352829926, 1548603684, 1836072691, 2053994217, 0]), O = b.RIPEMD160 = d.extend({
          _doReset: function() {
            this._hash = p.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(ne, le) {
            for (var Z = 0; Z < 16; Z++) {
              var ie = le + Z, fe = ne[ie];
              ne[ie] = (fe << 8 | fe >>> 24) & 16711935 | (fe << 24 | fe >>> 8) & 4278255360;
            }
            var I = this._hash.words, P = k.words, f = q.words, y = g.words, v = w.words, M = C.words, B = T.words, S, _, E, m, A, $, X, oe, J, W;
            $ = S = I[0], X = _ = I[1], oe = E = I[2], J = m = I[3], W = A = I[4];
            for (var Q, Z = 0; Z < 80; Z += 1)
              Q = S + ne[le + y[Z]] | 0, Z < 16 ? Q += N(_, E, m) + P[0] : Z < 32 ? Q += j(_, E, m) + P[1] : Z < 48 ? Q += U(_, E, m) + P[2] : Z < 64 ? Q += H(_, E, m) + P[3] : Q += z(_, E, m) + P[4], Q = Q | 0, Q = ee(Q, M[Z]), Q = Q + A | 0, S = A, A = m, m = ee(E, 10), E = _, _ = Q, Q = $ + ne[le + v[Z]] | 0, Z < 16 ? Q += z(X, oe, J) + f[0] : Z < 32 ? Q += H(X, oe, J) + f[1] : Z < 48 ? Q += U(X, oe, J) + f[2] : Z < 64 ? Q += j(X, oe, J) + f[3] : Q += N(X, oe, J) + f[4], Q = Q | 0, Q = ee(Q, B[Z]), Q = Q + W | 0, $ = W, W = J, J = ee(oe, 10), oe = X, X = Q;
            Q = I[1] + E + J | 0, I[1] = I[2] + m + W | 0, I[2] = I[3] + A + $ | 0, I[3] = I[4] + S + X | 0, I[4] = I[0] + _ + oe | 0, I[0] = Q;
          },
          _doFinalize: function() {
            var ne = this._data, le = ne.words, Z = this._nDataBytes * 8, ie = ne.sigBytes * 8;
            le[ie >>> 5] |= 128 << 24 - ie % 32, le[(ie + 64 >>> 9 << 4) + 14] = (Z << 8 | Z >>> 24) & 16711935 | (Z << 24 | Z >>> 8) & 4278255360, ne.sigBytes = (le.length + 1) * 4, this._process();
            for (var fe = this._hash, I = fe.words, P = 0; P < 5; P++) {
              var f = I[P];
              I[P] = (f << 8 | f >>> 24) & 16711935 | (f << 24 | f >>> 8) & 4278255360;
            }
            return fe;
          },
          clone: function() {
            var ne = d.clone.call(this);
            return ne._hash = this._hash.clone(), ne;
          }
        });
        function N(ne, le, Z) {
          return ne ^ le ^ Z;
        }
        function j(ne, le, Z) {
          return ne & le | ~ne & Z;
        }
        function U(ne, le, Z) {
          return (ne | ~le) ^ Z;
        }
        function H(ne, le, Z) {
          return ne & Z | le & ~Z;
        }
        function z(ne, le, Z) {
          return ne ^ (le | ~Z);
        }
        function ee(ne, le) {
          return ne << le | ne >>> 32 - le;
        }
        h.RIPEMD160 = d._createHelper(O), h.HmacRIPEMD160 = d._createHmacHelper(O);
      }(), o.RIPEMD160;
    });
  }(Yo)), Yo.exports;
}
var Xo = { exports: {} }, Od;
function Ch() {
  return Od || (Od = 1, function(e, t) {
    (function(o, r) {
      e.exports = r(xt());
    })(Me, function(o) {
      (function() {
        var r = o, h = r.lib, a = h.Base, p = r.enc, d = p.Utf8, b = r.algo;
        b.HMAC = a.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(g, w) {
            g = this._hasher = new g.init(), typeof w == "string" && (w = d.parse(w));
            var C = g.blockSize, T = C * 4;
            w.sigBytes > T && (w = g.finalize(w)), w.clamp();
            for (var k = this._oKey = w.clone(), q = this._iKey = w.clone(), O = k.words, N = q.words, j = 0; j < C; j++)
              O[j] ^= 1549556828, N[j] ^= 909522486;
            k.sigBytes = q.sigBytes = T, this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var g = this._hasher;
            g.reset(), g.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(g) {
            return this._hasher.update(g), this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(g) {
            var w = this._hasher, C = w.finalize(g);
            w.reset();
            var T = w.finalize(this._oKey.clone().concat(C));
            return T;
          }
        });
      })();
    });
  }(Xo)), Xo.exports;
}
var Qo = { exports: {} }, Pd;
function s_() {
  return Pd || (Pd = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), wh(), Ch());
    })(Me, function(o) {
      return function() {
        var r = o, h = r.lib, a = h.Base, p = h.WordArray, d = r.algo, b = d.SHA1, g = d.HMAC, w = d.PBKDF2 = a.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA1
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: a.extend({
            keySize: 128 / 32,
            hasher: b,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: function(C) {
            this.cfg = this.cfg.extend(C);
          },
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(C, T) {
            for (var k = this.cfg, q = g.create(k.hasher, C), O = p.create(), N = p.create([1]), j = O.words, U = N.words, H = k.keySize, z = k.iterations; j.length < H; ) {
              var ee = q.update(T).finalize(N);
              q.reset();
              for (var ne = ee.words, le = ne.length, Z = ee, ie = 1; ie < z; ie++) {
                Z = q.finalize(Z), q.reset();
                for (var fe = Z.words, I = 0; I < le; I++)
                  ne[I] ^= fe[I];
              }
              O.concat(ee), U[0]++;
            }
            return O.sigBytes = H * 4, O;
          }
        });
        r.PBKDF2 = function(C, T, k) {
          return w.create(k).compute(C, T);
        };
      }(), o.PBKDF2;
    });
  }(Qo)), Qo.exports;
}
var Zo = { exports: {} }, Ld;
function aa() {
  return Ld || (Ld = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), wh(), Ch());
    })(Me, function(o) {
      return function() {
        var r = o, h = r.lib, a = h.Base, p = h.WordArray, d = r.algo, b = d.MD5, g = d.EvpKDF = a.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: a.extend({
            keySize: 128 / 32,
            hasher: b,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(w) {
            this.cfg = this.cfg.extend(w);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(w, C) {
            for (var T, k = this.cfg, q = k.hasher.create(), O = p.create(), N = O.words, j = k.keySize, U = k.iterations; N.length < j; ) {
              T && q.update(T), T = q.update(w).finalize(C), q.reset();
              for (var H = 1; H < U; H++)
                T = q.finalize(T), q.reset();
              O.concat(T);
            }
            return O.sigBytes = j * 4, O;
          }
        });
        r.EvpKDF = function(w, C, T) {
          return g.create(T).compute(w, C);
        };
      }(), o.EvpKDF;
    });
  }(Zo)), Zo.exports;
}
var Jo = { exports: {} }, kd;
function or() {
  return kd || (kd = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), aa());
    })(Me, function(o) {
      o.lib.Cipher || function(r) {
        var h = o, a = h.lib, p = a.Base, d = a.WordArray, b = a.BufferedBlockAlgorithm, g = h.enc;
        g.Utf8;
        var w = g.Base64, C = h.algo, T = C.EvpKDF, k = a.Cipher = b.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: p.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function(fe, I) {
            return this.create(this._ENC_XFORM_MODE, fe, I);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function(fe, I) {
            return this.create(this._DEC_XFORM_MODE, fe, I);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function(fe, I, P) {
            this.cfg = this.cfg.extend(P), this._xformMode = fe, this._key = I, this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            b.reset.call(this), this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function(fe) {
            return this._append(fe), this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function(fe) {
            fe && this._append(fe);
            var I = this._doFinalize();
            return I;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: /* @__PURE__ */ function() {
            function fe(I) {
              return typeof I == "string" ? ie : ne;
            }
            return function(I) {
              return {
                encrypt: function(P, f, y) {
                  return fe(f).encrypt(I, P, f, y);
                },
                decrypt: function(P, f, y) {
                  return fe(f).decrypt(I, P, f, y);
                }
              };
            };
          }()
        });
        a.StreamCipher = k.extend({
          _doFinalize: function() {
            var fe = this._process(!0);
            return fe;
          },
          blockSize: 1
        });
        var q = h.mode = {}, O = a.BlockCipherMode = p.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function(fe, I) {
            return this.Encryptor.create(fe, I);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function(fe, I) {
            return this.Decryptor.create(fe, I);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function(fe, I) {
            this._cipher = fe, this._iv = I;
          }
        }), N = q.CBC = function() {
          var fe = O.extend();
          fe.Encryptor = fe.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(P, f) {
              var y = this._cipher, v = y.blockSize;
              I.call(this, P, f, v), y.encryptBlock(P, f), this._prevBlock = P.slice(f, f + v);
            }
          }), fe.Decryptor = fe.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(P, f) {
              var y = this._cipher, v = y.blockSize, M = P.slice(f, f + v);
              y.decryptBlock(P, f), I.call(this, P, f, v), this._prevBlock = M;
            }
          });
          function I(P, f, y) {
            var v, M = this._iv;
            M ? (v = M, this._iv = r) : v = this._prevBlock;
            for (var B = 0; B < y; B++)
              P[f + B] ^= v[B];
          }
          return fe;
        }(), j = h.pad = {}, U = j.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function(fe, I) {
            for (var P = I * 4, f = P - fe.sigBytes % P, y = f << 24 | f << 16 | f << 8 | f, v = [], M = 0; M < f; M += 4)
              v.push(y);
            var B = d.create(v, f);
            fe.concat(B);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function(fe) {
            var I = fe.words[fe.sigBytes - 1 >>> 2] & 255;
            fe.sigBytes -= I;
          }
        };
        a.BlockCipher = k.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: k.cfg.extend({
            mode: N,
            padding: U
          }),
          reset: function() {
            var fe;
            k.reset.call(this);
            var I = this.cfg, P = I.iv, f = I.mode;
            this._xformMode == this._ENC_XFORM_MODE ? fe = f.createEncryptor : (fe = f.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == fe ? this._mode.init(this, P && P.words) : (this._mode = fe.call(f, this, P && P.words), this._mode.__creator = fe);
          },
          _doProcessBlock: function(fe, I) {
            this._mode.processBlock(fe, I);
          },
          _doFinalize: function() {
            var fe, I = this.cfg.padding;
            return this._xformMode == this._ENC_XFORM_MODE ? (I.pad(this._data, this.blockSize), fe = this._process(!0)) : (fe = this._process(!0), I.unpad(fe)), fe;
          },
          blockSize: 128 / 32
        });
        var H = a.CipherParams = p.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function(fe) {
            this.mixIn(fe);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function(fe) {
            return (fe || this.formatter).stringify(this);
          }
        }), z = h.format = {}, ee = z.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function(fe) {
            var I, P = fe.ciphertext, f = fe.salt;
            return f ? I = d.create([1398893684, 1701076831]).concat(f).concat(P) : I = P, I.toString(w);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function(fe) {
            var I, P = w.parse(fe), f = P.words;
            return f[0] == 1398893684 && f[1] == 1701076831 && (I = d.create(f.slice(2, 4)), f.splice(0, 4), P.sigBytes -= 16), H.create({ ciphertext: P, salt: I });
          }
        }, ne = a.SerializableCipher = p.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: p.extend({
            format: ee
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(fe, I, P, f) {
            f = this.cfg.extend(f);
            var y = fe.createEncryptor(P, f), v = y.finalize(I), M = y.cfg;
            return H.create({
              ciphertext: v,
              key: P,
              iv: M.iv,
              algorithm: fe,
              mode: M.mode,
              padding: M.padding,
              blockSize: fe.blockSize,
              formatter: f.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(fe, I, P, f) {
            f = this.cfg.extend(f), I = this._parse(I, f.format);
            var y = fe.createDecryptor(P, f).finalize(I.ciphertext);
            return y;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function(fe, I) {
            return typeof fe == "string" ? I.parse(fe, this) : fe;
          }
        }), le = h.kdf = {}, Z = le.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function(fe, I, P, f) {
            f || (f = d.random(64 / 8));
            var y = T.create({ keySize: I + P }).compute(fe, f), v = d.create(y.words.slice(I), P * 4);
            return y.sigBytes = I * 4, H.create({ key: y, iv: v, salt: f });
          }
        }, ie = a.PasswordBasedCipher = ne.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: ne.cfg.extend({
            kdf: Z
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(fe, I, P, f) {
            f = this.cfg.extend(f);
            var y = f.kdf.execute(P, fe.keySize, fe.ivSize);
            f.iv = y.iv;
            var v = ne.encrypt.call(this, fe, I, y.key, f);
            return v.mixIn(y), v;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(fe, I, P, f) {
            f = this.cfg.extend(f), I = this._parse(I, f.format);
            var y = f.kdf.execute(P, fe.keySize, fe.ivSize, I.salt);
            f.iv = y.iv;
            var v = ne.decrypt.call(this, fe, I, y.key, f);
            return v;
          }
        });
      }();
    });
  }(Jo)), Jo.exports;
}
var eu = { exports: {} }, Ud;
function f_() {
  return Ud || (Ud = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), or());
    })(Me, function(o) {
      return o.mode.CFB = function() {
        var r = o.lib.BlockCipherMode.extend();
        r.Encryptor = r.extend({
          processBlock: function(a, p) {
            var d = this._cipher, b = d.blockSize;
            h.call(this, a, p, b, d), this._prevBlock = a.slice(p, p + b);
          }
        }), r.Decryptor = r.extend({
          processBlock: function(a, p) {
            var d = this._cipher, b = d.blockSize, g = a.slice(p, p + b);
            h.call(this, a, p, b, d), this._prevBlock = g;
          }
        });
        function h(a, p, d, b) {
          var g, w = this._iv;
          w ? (g = w.slice(0), this._iv = void 0) : g = this._prevBlock, b.encryptBlock(g, 0);
          for (var C = 0; C < d; C++)
            a[p + C] ^= g[C];
        }
        return r;
      }(), o.mode.CFB;
    });
  }(eu)), eu.exports;
}
var tu = { exports: {} }, Fd;
function o_() {
  return Fd || (Fd = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), or());
    })(Me, function(o) {
      return o.mode.CTR = function() {
        var r = o.lib.BlockCipherMode.extend(), h = r.Encryptor = r.extend({
          processBlock: function(a, p) {
            var d = this._cipher, b = d.blockSize, g = this._iv, w = this._counter;
            g && (w = this._counter = g.slice(0), this._iv = void 0);
            var C = w.slice(0);
            d.encryptBlock(C, 0), w[b - 1] = w[b - 1] + 1 | 0;
            for (var T = 0; T < b; T++)
              a[p + T] ^= C[T];
          }
        });
        return r.Decryptor = h, r;
      }(), o.mode.CTR;
    });
  }(tu)), tu.exports;
}
var ru = { exports: {} }, qd;
function u_() {
  return qd || (qd = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), or());
    })(Me, function(o) {
      /** @preserve
       * Counter block mode compatible with  Dr Brian Gladman fileenc.c
       * derived from CryptoJS.mode.CTR
       * Jan Hruby jhruby.web@gmail.com
       */
      return o.mode.CTRGladman = function() {
        var r = o.lib.BlockCipherMode.extend();
        function h(d) {
          if ((d >> 24 & 255) === 255) {
            var b = d >> 16 & 255, g = d >> 8 & 255, w = d & 255;
            b === 255 ? (b = 0, g === 255 ? (g = 0, w === 255 ? w = 0 : ++w) : ++g) : ++b, d = 0, d += b << 16, d += g << 8, d += w;
          } else
            d += 1 << 24;
          return d;
        }
        function a(d) {
          return (d[0] = h(d[0])) === 0 && (d[1] = h(d[1])), d;
        }
        var p = r.Encryptor = r.extend({
          processBlock: function(d, b) {
            var g = this._cipher, w = g.blockSize, C = this._iv, T = this._counter;
            C && (T = this._counter = C.slice(0), this._iv = void 0), a(T);
            var k = T.slice(0);
            g.encryptBlock(k, 0);
            for (var q = 0; q < w; q++)
              d[b + q] ^= k[q];
          }
        });
        return r.Decryptor = p, r;
      }(), o.mode.CTRGladman;
    });
  }(ru)), ru.exports;
}
var iu = { exports: {} }, Vd;
function c_() {
  return Vd || (Vd = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), or());
    })(Me, function(o) {
      return o.mode.OFB = function() {
        var r = o.lib.BlockCipherMode.extend(), h = r.Encryptor = r.extend({
          processBlock: function(a, p) {
            var d = this._cipher, b = d.blockSize, g = this._iv, w = this._keystream;
            g && (w = this._keystream = g.slice(0), this._iv = void 0), d.encryptBlock(w, 0);
            for (var C = 0; C < b; C++)
              a[p + C] ^= w[C];
          }
        });
        return r.Decryptor = h, r;
      }(), o.mode.OFB;
    });
  }(iu)), iu.exports;
}
var nu = { exports: {} }, Kd;
function h_() {
  return Kd || (Kd = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), or());
    })(Me, function(o) {
      return o.mode.ECB = function() {
        var r = o.lib.BlockCipherMode.extend();
        return r.Encryptor = r.extend({
          processBlock: function(h, a) {
            this._cipher.encryptBlock(h, a);
          }
        }), r.Decryptor = r.extend({
          processBlock: function(h, a) {
            this._cipher.decryptBlock(h, a);
          }
        }), r;
      }(), o.mode.ECB;
    });
  }(nu)), nu.exports;
}
var au = { exports: {} }, $d;
function l_() {
  return $d || ($d = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), or());
    })(Me, function(o) {
      return o.pad.AnsiX923 = {
        pad: function(r, h) {
          var a = r.sigBytes, p = h * 4, d = p - a % p, b = a + d - 1;
          r.clamp(), r.words[b >>> 2] |= d << 24 - b % 4 * 8, r.sigBytes += d;
        },
        unpad: function(r) {
          var h = r.words[r.sigBytes - 1 >>> 2] & 255;
          r.sigBytes -= h;
        }
      }, o.pad.Ansix923;
    });
  }(au)), au.exports;
}
var su = { exports: {} }, Hd;
function d_() {
  return Hd || (Hd = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), or());
    })(Me, function(o) {
      return o.pad.Iso10126 = {
        pad: function(r, h) {
          var a = h * 4, p = a - r.sigBytes % a;
          r.concat(o.lib.WordArray.random(p - 1)).concat(o.lib.WordArray.create([p << 24], 1));
        },
        unpad: function(r) {
          var h = r.words[r.sigBytes - 1 >>> 2] & 255;
          r.sigBytes -= h;
        }
      }, o.pad.Iso10126;
    });
  }(su)), su.exports;
}
var fu = { exports: {} }, Gd;
function p_() {
  return Gd || (Gd = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), or());
    })(Me, function(o) {
      return o.pad.Iso97971 = {
        pad: function(r, h) {
          r.concat(o.lib.WordArray.create([2147483648], 1)), o.pad.ZeroPadding.pad(r, h);
        },
        unpad: function(r) {
          o.pad.ZeroPadding.unpad(r), r.sigBytes--;
        }
      }, o.pad.Iso97971;
    });
  }(fu)), fu.exports;
}
var ou = { exports: {} }, zd;
function v_() {
  return zd || (zd = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), or());
    })(Me, function(o) {
      return o.pad.ZeroPadding = {
        pad: function(r, h) {
          var a = h * 4;
          r.clamp(), r.sigBytes += a - (r.sigBytes % a || a);
        },
        unpad: function(r) {
          for (var h = r.words, a = r.sigBytes - 1, a = r.sigBytes - 1; a >= 0; a--)
            if (h[a >>> 2] >>> 24 - a % 4 * 8 & 255) {
              r.sigBytes = a + 1;
              break;
            }
        }
      }, o.pad.ZeroPadding;
    });
  }(ou)), ou.exports;
}
var uu = { exports: {} }, jd;
function y_() {
  return jd || (jd = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), or());
    })(Me, function(o) {
      return o.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      }, o.pad.NoPadding;
    });
  }(uu)), uu.exports;
}
var cu = { exports: {} }, Wd;
function g_() {
  return Wd || (Wd = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), or());
    })(Me, function(o) {
      return function(r) {
        var h = o, a = h.lib, p = a.CipherParams, d = h.enc, b = d.Hex, g = h.format;
        g.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: function(w) {
            return w.ciphertext.toString(b);
          },
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: function(w) {
            var C = b.parse(w);
            return p.create({ ciphertext: C });
          }
        };
      }(), o.format.Hex;
    });
  }(cu)), cu.exports;
}
var hu = { exports: {} }, Yd;
function m_() {
  return Yd || (Yd = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), ja(), Wa(), aa(), or());
    })(Me, function(o) {
      return function() {
        var r = o, h = r.lib, a = h.BlockCipher, p = r.algo, d = [], b = [], g = [], w = [], C = [], T = [], k = [], q = [], O = [], N = [];
        (function() {
          for (var H = [], z = 0; z < 256; z++)
            z < 128 ? H[z] = z << 1 : H[z] = z << 1 ^ 283;
          for (var ee = 0, ne = 0, z = 0; z < 256; z++) {
            var le = ne ^ ne << 1 ^ ne << 2 ^ ne << 3 ^ ne << 4;
            le = le >>> 8 ^ le & 255 ^ 99, d[ee] = le, b[le] = ee;
            var Z = H[ee], ie = H[Z], fe = H[ie], I = H[le] * 257 ^ le * 16843008;
            g[ee] = I << 24 | I >>> 8, w[ee] = I << 16 | I >>> 16, C[ee] = I << 8 | I >>> 24, T[ee] = I;
            var I = fe * 16843009 ^ ie * 65537 ^ Z * 257 ^ ee * 16843008;
            k[le] = I << 24 | I >>> 8, q[le] = I << 16 | I >>> 16, O[le] = I << 8 | I >>> 24, N[le] = I, ee ? (ee = Z ^ H[H[H[fe ^ Z]]], ne ^= H[H[ne]]) : ee = ne = 1;
          }
        })();
        var j = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], U = p.AES = a.extend({
          _doReset: function() {
            var H;
            if (!(this._nRounds && this._keyPriorReset === this._key)) {
              for (var z = this._keyPriorReset = this._key, ee = z.words, ne = z.sigBytes / 4, le = this._nRounds = ne + 6, Z = (le + 1) * 4, ie = this._keySchedule = [], fe = 0; fe < Z; fe++)
                fe < ne ? ie[fe] = ee[fe] : (H = ie[fe - 1], fe % ne ? ne > 6 && fe % ne == 4 && (H = d[H >>> 24] << 24 | d[H >>> 16 & 255] << 16 | d[H >>> 8 & 255] << 8 | d[H & 255]) : (H = H << 8 | H >>> 24, H = d[H >>> 24] << 24 | d[H >>> 16 & 255] << 16 | d[H >>> 8 & 255] << 8 | d[H & 255], H ^= j[fe / ne | 0] << 24), ie[fe] = ie[fe - ne] ^ H);
              for (var I = this._invKeySchedule = [], P = 0; P < Z; P++) {
                var fe = Z - P;
                if (P % 4)
                  var H = ie[fe];
                else
                  var H = ie[fe - 4];
                P < 4 || fe <= 4 ? I[P] = H : I[P] = k[d[H >>> 24]] ^ q[d[H >>> 16 & 255]] ^ O[d[H >>> 8 & 255]] ^ N[d[H & 255]];
              }
            }
          },
          encryptBlock: function(H, z) {
            this._doCryptBlock(H, z, this._keySchedule, g, w, C, T, d);
          },
          decryptBlock: function(H, z) {
            var ee = H[z + 1];
            H[z + 1] = H[z + 3], H[z + 3] = ee, this._doCryptBlock(H, z, this._invKeySchedule, k, q, O, N, b);
            var ee = H[z + 1];
            H[z + 1] = H[z + 3], H[z + 3] = ee;
          },
          _doCryptBlock: function(H, z, ee, ne, le, Z, ie, fe) {
            for (var I = this._nRounds, P = H[z] ^ ee[0], f = H[z + 1] ^ ee[1], y = H[z + 2] ^ ee[2], v = H[z + 3] ^ ee[3], M = 4, B = 1; B < I; B++) {
              var S = ne[P >>> 24] ^ le[f >>> 16 & 255] ^ Z[y >>> 8 & 255] ^ ie[v & 255] ^ ee[M++], _ = ne[f >>> 24] ^ le[y >>> 16 & 255] ^ Z[v >>> 8 & 255] ^ ie[P & 255] ^ ee[M++], E = ne[y >>> 24] ^ le[v >>> 16 & 255] ^ Z[P >>> 8 & 255] ^ ie[f & 255] ^ ee[M++], m = ne[v >>> 24] ^ le[P >>> 16 & 255] ^ Z[f >>> 8 & 255] ^ ie[y & 255] ^ ee[M++];
              P = S, f = _, y = E, v = m;
            }
            var S = (fe[P >>> 24] << 24 | fe[f >>> 16 & 255] << 16 | fe[y >>> 8 & 255] << 8 | fe[v & 255]) ^ ee[M++], _ = (fe[f >>> 24] << 24 | fe[y >>> 16 & 255] << 16 | fe[v >>> 8 & 255] << 8 | fe[P & 255]) ^ ee[M++], E = (fe[y >>> 24] << 24 | fe[v >>> 16 & 255] << 16 | fe[P >>> 8 & 255] << 8 | fe[f & 255]) ^ ee[M++], m = (fe[v >>> 24] << 24 | fe[P >>> 16 & 255] << 16 | fe[f >>> 8 & 255] << 8 | fe[y & 255]) ^ ee[M++];
            H[z] = S, H[z + 1] = _, H[z + 2] = E, H[z + 3] = m;
          },
          keySize: 256 / 32
        });
        r.AES = a._createHelper(U);
      }(), o.AES;
    });
  }(hu)), hu.exports;
}
var lu = { exports: {} }, Xd;
function b_() {
  return Xd || (Xd = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), ja(), Wa(), aa(), or());
    })(Me, function(o) {
      return function() {
        var r = o, h = r.lib, a = h.WordArray, p = h.BlockCipher, d = r.algo, b = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ], g = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ], w = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28], C = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ], T = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ], k = d.DES = p.extend({
          _doReset: function() {
            for (var j = this._key, U = j.words, H = [], z = 0; z < 56; z++) {
              var ee = b[z] - 1;
              H[z] = U[ee >>> 5] >>> 31 - ee % 32 & 1;
            }
            for (var ne = this._subKeys = [], le = 0; le < 16; le++) {
              for (var Z = ne[le] = [], ie = w[le], z = 0; z < 24; z++)
                Z[z / 6 | 0] |= H[(g[z] - 1 + ie) % 28] << 31 - z % 6, Z[4 + (z / 6 | 0)] |= H[28 + (g[z + 24] - 1 + ie) % 28] << 31 - z % 6;
              Z[0] = Z[0] << 1 | Z[0] >>> 31;
              for (var z = 1; z < 7; z++)
                Z[z] = Z[z] >>> (z - 1) * 4 + 3;
              Z[7] = Z[7] << 5 | Z[7] >>> 27;
            }
            for (var fe = this._invSubKeys = [], z = 0; z < 16; z++)
              fe[z] = ne[15 - z];
          },
          encryptBlock: function(j, U) {
            this._doCryptBlock(j, U, this._subKeys);
          },
          decryptBlock: function(j, U) {
            this._doCryptBlock(j, U, this._invSubKeys);
          },
          _doCryptBlock: function(j, U, H) {
            this._lBlock = j[U], this._rBlock = j[U + 1], q.call(this, 4, 252645135), q.call(this, 16, 65535), O.call(this, 2, 858993459), O.call(this, 8, 16711935), q.call(this, 1, 1431655765);
            for (var z = 0; z < 16; z++) {
              for (var ee = H[z], ne = this._lBlock, le = this._rBlock, Z = 0, ie = 0; ie < 8; ie++)
                Z |= C[ie][((le ^ ee[ie]) & T[ie]) >>> 0];
              this._lBlock = le, this._rBlock = ne ^ Z;
            }
            var fe = this._lBlock;
            this._lBlock = this._rBlock, this._rBlock = fe, q.call(this, 1, 1431655765), O.call(this, 8, 16711935), O.call(this, 2, 858993459), q.call(this, 16, 65535), q.call(this, 4, 252645135), j[U] = this._lBlock, j[U + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function q(j, U) {
          var H = (this._lBlock >>> j ^ this._rBlock) & U;
          this._rBlock ^= H, this._lBlock ^= H << j;
        }
        function O(j, U) {
          var H = (this._rBlock >>> j ^ this._lBlock) & U;
          this._lBlock ^= H, this._rBlock ^= H << j;
        }
        r.DES = p._createHelper(k);
        var N = d.TripleDES = p.extend({
          _doReset: function() {
            var j = this._key, U = j.words;
            if (U.length !== 2 && U.length !== 4 && U.length < 6)
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            var H = U.slice(0, 2), z = U.length < 4 ? U.slice(0, 2) : U.slice(2, 4), ee = U.length < 6 ? U.slice(0, 2) : U.slice(4, 6);
            this._des1 = k.createEncryptor(a.create(H)), this._des2 = k.createEncryptor(a.create(z)), this._des3 = k.createEncryptor(a.create(ee));
          },
          encryptBlock: function(j, U) {
            this._des1.encryptBlock(j, U), this._des2.decryptBlock(j, U), this._des3.encryptBlock(j, U);
          },
          decryptBlock: function(j, U) {
            this._des3.decryptBlock(j, U), this._des2.encryptBlock(j, U), this._des1.decryptBlock(j, U);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        r.TripleDES = p._createHelper(N);
      }(), o.TripleDES;
    });
  }(lu)), lu.exports;
}
var du = { exports: {} }, Qd;
function x_() {
  return Qd || (Qd = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), ja(), Wa(), aa(), or());
    })(Me, function(o) {
      return function() {
        var r = o, h = r.lib, a = h.StreamCipher, p = r.algo, d = p.RC4 = a.extend({
          _doReset: function() {
            for (var w = this._key, C = w.words, T = w.sigBytes, k = this._S = [], q = 0; q < 256; q++)
              k[q] = q;
            for (var q = 0, O = 0; q < 256; q++) {
              var N = q % T, j = C[N >>> 2] >>> 24 - N % 4 * 8 & 255;
              O = (O + k[q] + j) % 256;
              var U = k[q];
              k[q] = k[O], k[O] = U;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(w, C) {
            w[C] ^= b.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function b() {
          for (var w = this._S, C = this._i, T = this._j, k = 0, q = 0; q < 4; q++) {
            C = (C + 1) % 256, T = (T + w[C]) % 256;
            var O = w[C];
            w[C] = w[T], w[T] = O, k |= w[(w[C] + w[T]) % 256] << 24 - q * 8;
          }
          return this._i = C, this._j = T, k;
        }
        r.RC4 = a._createHelper(d);
        var g = p.RC4Drop = d.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: d.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            d._doReset.call(this);
            for (var w = this.cfg.drop; w > 0; w--)
              b.call(this);
          }
        });
        r.RC4Drop = a._createHelper(g);
      }(), o.RC4;
    });
  }(du)), du.exports;
}
var pu = { exports: {} }, Zd;
function __() {
  return Zd || (Zd = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), ja(), Wa(), aa(), or());
    })(Me, function(o) {
      return function() {
        var r = o, h = r.lib, a = h.StreamCipher, p = r.algo, d = [], b = [], g = [], w = p.Rabbit = a.extend({
          _doReset: function() {
            for (var T = this._key.words, k = this.cfg.iv, q = 0; q < 4; q++)
              T[q] = (T[q] << 8 | T[q] >>> 24) & 16711935 | (T[q] << 24 | T[q] >>> 8) & 4278255360;
            var O = this._X = [
              T[0],
              T[3] << 16 | T[2] >>> 16,
              T[1],
              T[0] << 16 | T[3] >>> 16,
              T[2],
              T[1] << 16 | T[0] >>> 16,
              T[3],
              T[2] << 16 | T[1] >>> 16
            ], N = this._C = [
              T[2] << 16 | T[2] >>> 16,
              T[0] & 4294901760 | T[1] & 65535,
              T[3] << 16 | T[3] >>> 16,
              T[1] & 4294901760 | T[2] & 65535,
              T[0] << 16 | T[0] >>> 16,
              T[2] & 4294901760 | T[3] & 65535,
              T[1] << 16 | T[1] >>> 16,
              T[3] & 4294901760 | T[0] & 65535
            ];
            this._b = 0;
            for (var q = 0; q < 4; q++)
              C.call(this);
            for (var q = 0; q < 8; q++)
              N[q] ^= O[q + 4 & 7];
            if (k) {
              var j = k.words, U = j[0], H = j[1], z = (U << 8 | U >>> 24) & 16711935 | (U << 24 | U >>> 8) & 4278255360, ee = (H << 8 | H >>> 24) & 16711935 | (H << 24 | H >>> 8) & 4278255360, ne = z >>> 16 | ee & 4294901760, le = ee << 16 | z & 65535;
              N[0] ^= z, N[1] ^= ne, N[2] ^= ee, N[3] ^= le, N[4] ^= z, N[5] ^= ne, N[6] ^= ee, N[7] ^= le;
              for (var q = 0; q < 4; q++)
                C.call(this);
            }
          },
          _doProcessBlock: function(T, k) {
            var q = this._X;
            C.call(this), d[0] = q[0] ^ q[5] >>> 16 ^ q[3] << 16, d[1] = q[2] ^ q[7] >>> 16 ^ q[5] << 16, d[2] = q[4] ^ q[1] >>> 16 ^ q[7] << 16, d[3] = q[6] ^ q[3] >>> 16 ^ q[1] << 16;
            for (var O = 0; O < 4; O++)
              d[O] = (d[O] << 8 | d[O] >>> 24) & 16711935 | (d[O] << 24 | d[O] >>> 8) & 4278255360, T[k + O] ^= d[O];
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function C() {
          for (var T = this._X, k = this._C, q = 0; q < 8; q++)
            b[q] = k[q];
          k[0] = k[0] + 1295307597 + this._b | 0, k[1] = k[1] + 3545052371 + (k[0] >>> 0 < b[0] >>> 0 ? 1 : 0) | 0, k[2] = k[2] + 886263092 + (k[1] >>> 0 < b[1] >>> 0 ? 1 : 0) | 0, k[3] = k[3] + 1295307597 + (k[2] >>> 0 < b[2] >>> 0 ? 1 : 0) | 0, k[4] = k[4] + 3545052371 + (k[3] >>> 0 < b[3] >>> 0 ? 1 : 0) | 0, k[5] = k[5] + 886263092 + (k[4] >>> 0 < b[4] >>> 0 ? 1 : 0) | 0, k[6] = k[6] + 1295307597 + (k[5] >>> 0 < b[5] >>> 0 ? 1 : 0) | 0, k[7] = k[7] + 3545052371 + (k[6] >>> 0 < b[6] >>> 0 ? 1 : 0) | 0, this._b = k[7] >>> 0 < b[7] >>> 0 ? 1 : 0;
          for (var q = 0; q < 8; q++) {
            var O = T[q] + k[q], N = O & 65535, j = O >>> 16, U = ((N * N >>> 17) + N * j >>> 15) + j * j, H = ((O & 4294901760) * O | 0) + ((O & 65535) * O | 0);
            g[q] = U ^ H;
          }
          T[0] = g[0] + (g[7] << 16 | g[7] >>> 16) + (g[6] << 16 | g[6] >>> 16) | 0, T[1] = g[1] + (g[0] << 8 | g[0] >>> 24) + g[7] | 0, T[2] = g[2] + (g[1] << 16 | g[1] >>> 16) + (g[0] << 16 | g[0] >>> 16) | 0, T[3] = g[3] + (g[2] << 8 | g[2] >>> 24) + g[1] | 0, T[4] = g[4] + (g[3] << 16 | g[3] >>> 16) + (g[2] << 16 | g[2] >>> 16) | 0, T[5] = g[5] + (g[4] << 8 | g[4] >>> 24) + g[3] | 0, T[6] = g[6] + (g[5] << 16 | g[5] >>> 16) + (g[4] << 16 | g[4] >>> 16) | 0, T[7] = g[7] + (g[6] << 8 | g[6] >>> 24) + g[5] | 0;
        }
        r.Rabbit = a._createHelper(w);
      }(), o.Rabbit;
    });
  }(pu)), pu.exports;
}
var vu = { exports: {} }, Jd;
function E_() {
  return Jd || (Jd = 1, function(e, t) {
    (function(o, r, h) {
      e.exports = r(xt(), ja(), Wa(), aa(), or());
    })(Me, function(o) {
      return function() {
        var r = o, h = r.lib, a = h.StreamCipher, p = r.algo, d = [], b = [], g = [], w = p.RabbitLegacy = a.extend({
          _doReset: function() {
            var T = this._key.words, k = this.cfg.iv, q = this._X = [
              T[0],
              T[3] << 16 | T[2] >>> 16,
              T[1],
              T[0] << 16 | T[3] >>> 16,
              T[2],
              T[1] << 16 | T[0] >>> 16,
              T[3],
              T[2] << 16 | T[1] >>> 16
            ], O = this._C = [
              T[2] << 16 | T[2] >>> 16,
              T[0] & 4294901760 | T[1] & 65535,
              T[3] << 16 | T[3] >>> 16,
              T[1] & 4294901760 | T[2] & 65535,
              T[0] << 16 | T[0] >>> 16,
              T[2] & 4294901760 | T[3] & 65535,
              T[1] << 16 | T[1] >>> 16,
              T[3] & 4294901760 | T[0] & 65535
            ];
            this._b = 0;
            for (var N = 0; N < 4; N++)
              C.call(this);
            for (var N = 0; N < 8; N++)
              O[N] ^= q[N + 4 & 7];
            if (k) {
              var j = k.words, U = j[0], H = j[1], z = (U << 8 | U >>> 24) & 16711935 | (U << 24 | U >>> 8) & 4278255360, ee = (H << 8 | H >>> 24) & 16711935 | (H << 24 | H >>> 8) & 4278255360, ne = z >>> 16 | ee & 4294901760, le = ee << 16 | z & 65535;
              O[0] ^= z, O[1] ^= ne, O[2] ^= ee, O[3] ^= le, O[4] ^= z, O[5] ^= ne, O[6] ^= ee, O[7] ^= le;
              for (var N = 0; N < 4; N++)
                C.call(this);
            }
          },
          _doProcessBlock: function(T, k) {
            var q = this._X;
            C.call(this), d[0] = q[0] ^ q[5] >>> 16 ^ q[3] << 16, d[1] = q[2] ^ q[7] >>> 16 ^ q[5] << 16, d[2] = q[4] ^ q[1] >>> 16 ^ q[7] << 16, d[3] = q[6] ^ q[3] >>> 16 ^ q[1] << 16;
            for (var O = 0; O < 4; O++)
              d[O] = (d[O] << 8 | d[O] >>> 24) & 16711935 | (d[O] << 24 | d[O] >>> 8) & 4278255360, T[k + O] ^= d[O];
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function C() {
          for (var T = this._X, k = this._C, q = 0; q < 8; q++)
            b[q] = k[q];
          k[0] = k[0] + 1295307597 + this._b | 0, k[1] = k[1] + 3545052371 + (k[0] >>> 0 < b[0] >>> 0 ? 1 : 0) | 0, k[2] = k[2] + 886263092 + (k[1] >>> 0 < b[1] >>> 0 ? 1 : 0) | 0, k[3] = k[3] + 1295307597 + (k[2] >>> 0 < b[2] >>> 0 ? 1 : 0) | 0, k[4] = k[4] + 3545052371 + (k[3] >>> 0 < b[3] >>> 0 ? 1 : 0) | 0, k[5] = k[5] + 886263092 + (k[4] >>> 0 < b[4] >>> 0 ? 1 : 0) | 0, k[6] = k[6] + 1295307597 + (k[5] >>> 0 < b[5] >>> 0 ? 1 : 0) | 0, k[7] = k[7] + 3545052371 + (k[6] >>> 0 < b[6] >>> 0 ? 1 : 0) | 0, this._b = k[7] >>> 0 < b[7] >>> 0 ? 1 : 0;
          for (var q = 0; q < 8; q++) {
            var O = T[q] + k[q], N = O & 65535, j = O >>> 16, U = ((N * N >>> 17) + N * j >>> 15) + j * j, H = ((O & 4294901760) * O | 0) + ((O & 65535) * O | 0);
            g[q] = U ^ H;
          }
          T[0] = g[0] + (g[7] << 16 | g[7] >>> 16) + (g[6] << 16 | g[6] >>> 16) | 0, T[1] = g[1] + (g[0] << 8 | g[0] >>> 24) + g[7] | 0, T[2] = g[2] + (g[1] << 16 | g[1] >>> 16) + (g[0] << 16 | g[0] >>> 16) | 0, T[3] = g[3] + (g[2] << 8 | g[2] >>> 24) + g[1] | 0, T[4] = g[4] + (g[3] << 16 | g[3] >>> 16) + (g[2] << 16 | g[2] >>> 16) | 0, T[5] = g[5] + (g[4] << 8 | g[4] >>> 24) + g[3] | 0, T[6] = g[6] + (g[5] << 16 | g[5] >>> 16) + (g[4] << 16 | g[4] >>> 16) | 0, T[7] = g[7] + (g[6] << 8 | g[6] >>> 24) + g[5] | 0;
        }
        r.RabbitLegacy = a._createHelper(w);
      }(), o.RabbitLegacy;
    });
  }(vu)), vu.exports;
}
(function(e, t) {
  (function(o, r, h) {
    e.exports = r(xt(), If(), J5(), e_(), ja(), t_(), Wa(), wh(), Gy(), r_(), zy(), i_(), n_(), a_(), Ch(), s_(), aa(), or(), f_(), o_(), u_(), c_(), h_(), l_(), d_(), p_(), v_(), y_(), g_(), m_(), b_(), x_(), __(), E_());
  })(Me, function(o) {
    return o;
  });
})(u1);
var S_ = u1.exports;
const Cr = /* @__PURE__ */ Gs(S_), w_ = 0, C_ = 1, A_ = 2, B_ = 61440, I_ = 32768, T_ = 16384, M_ = 8192, R_ = 24576, N_ = 4096, D_ = 40960, O_ = 49152, P_ = 512, L_ = 2048, k_ = 131072, U_ = 1024, F_ = 8, q_ = 1048576, V_ = 256, K_ = 128, $_ = 2097152, H_ = 4, G_ = 448, z_ = 256, j_ = 128, W_ = 64, Y_ = 56, X_ = 32, Q_ = 16, Z_ = 8, J_ = 7, eE = 4, tE = 2, rE = 1, iE = 7, nE = 13, aE = 48, sE = 49, fE = 47, oE = 35, uE = 37, cE = 9, hE = 94, lE = 16, dE = 89, pE = 10, vE = 53, yE = 61, gE = 54, mE = 11, bE = 39, xE = 33, _E = 69, EE = 17, SE = 14, wE = 27, CE = 65, AE = 90, BE = 92, IE = 36, TE = 4, ME = 22, RE = 5, NE = 56, DE = 21, OE = 62, PE = 24, LE = 31, kE = 40, UE = 95, FE = 63, qE = 50, VE = 52, KE = 51, $E = 23, HE = 55, GE = 96, zE = 19, jE = 2, WE = 8, YE = 77, XE = 97, QE = 12, ZE = 91, JE = 42, eS = 28, tS = 98, rS = 99, iS = 78, nS = 57, aS = 20, sS = 66, fS = 38, oS = 45, uS = 25, cS = 6, hS = 102, lS = 84, dS = 1, pS = 32, vS = 100, yS = 43, gS = 41, mS = 34, bS = 30, xS = 29, _S = 3, ES = 70, SS = 101, wS = 60, CS = 26, AS = 35, BS = 18, IS = 1, TS = 2, MS = 3, RS = 4, NS = 5, DS = 6, OS = 6, PS = 10, LS = 8, kS = 9, US = 30, FS = 11, qS = 31, VS = 13, KS = 14, $S = 15, HS = 20, GS = 19, zS = 17, jS = 18, WS = 21, YS = 22, XS = 16, QS = 24, ZS = 25, JS = 26, ew = 27, tw = 28, rw = 23, iw = 12, nw = 2147486719, aw = 262144, sw = 4194304, fw = 32768, ow = 8192, uw = 2147483648, cw = 2048, hw = 0, lw = 4, dw = 32, pw = 1, vw = 0, yw = 536870912, gw = 2, mw = 1073741824, bw = 8, xw = 131072, _w = 4096, Ew = 65536, Sw = 16777216, ww = 33554432, Cw = 16384, Aw = 67108864, Bw = 268435456, Iw = 134217728, Tw = 0, Mw = 0, Rw = 1048576, Nw = 524288, Dw = 128, Ow = 0, Pw = 512, Lw = 256, kw = 8388608, Uw = 2, Fw = 4, qw = 8, Vw = 16, Kw = 32, $w = 64, Hw = 128, Gw = 256, zw = 512, jw = 1024, Ww = 65535, Yw = 0, Xw = 2, Qw = 1, Zw = 4, Jw = 8, e7 = 1, t7 = 1, r7 = 2, i7 = 3, n7 = 4, a7 = 5, s7 = 6, f7 = 2, o7 = 4, u7 = 6, c7 = 0, h7 = 4, l7 = 2, d7 = 1, p7 = 4, Ah = {
  O_RDONLY: w_,
  O_WRONLY: C_,
  O_RDWR: A_,
  S_IFMT: B_,
  S_IFREG: I_,
  S_IFDIR: T_,
  S_IFCHR: M_,
  S_IFBLK: R_,
  S_IFIFO: N_,
  S_IFLNK: D_,
  S_IFSOCK: O_,
  O_CREAT: P_,
  O_EXCL: L_,
  O_NOCTTY: k_,
  O_TRUNC: U_,
  O_APPEND: F_,
  O_DIRECTORY: q_,
  O_NOFOLLOW: V_,
  O_SYNC: K_,
  O_SYMLINK: $_,
  O_NONBLOCK: H_,
  S_IRWXU: G_,
  S_IRUSR: z_,
  S_IWUSR: j_,
  S_IXUSR: W_,
  S_IRWXG: Y_,
  S_IRGRP: X_,
  S_IWGRP: Q_,
  S_IXGRP: Z_,
  S_IRWXO: J_,
  S_IROTH: eE,
  S_IWOTH: tE,
  S_IXOTH: rE,
  E2BIG: iE,
  EACCES: nE,
  EADDRINUSE: aE,
  EADDRNOTAVAIL: sE,
  EAFNOSUPPORT: fE,
  EAGAIN: oE,
  EALREADY: uE,
  EBADF: cE,
  EBADMSG: hE,
  EBUSY: lE,
  ECANCELED: dE,
  ECHILD: pE,
  ECONNABORTED: vE,
  ECONNREFUSED: yE,
  ECONNRESET: gE,
  EDEADLK: mE,
  EDESTADDRREQ: bE,
  EDOM: xE,
  EDQUOT: _E,
  EEXIST: EE,
  EFAULT: SE,
  EFBIG: wE,
  EHOSTUNREACH: CE,
  EIDRM: AE,
  EILSEQ: BE,
  EINPROGRESS: IE,
  EINTR: TE,
  EINVAL: ME,
  EIO: RE,
  EISCONN: NE,
  EISDIR: DE,
  ELOOP: OE,
  EMFILE: PE,
  EMLINK: LE,
  EMSGSIZE: kE,
  EMULTIHOP: UE,
  ENAMETOOLONG: FE,
  ENETDOWN: qE,
  ENETRESET: VE,
  ENETUNREACH: KE,
  ENFILE: $E,
  ENOBUFS: HE,
  ENODATA: GE,
  ENODEV: zE,
  ENOENT: jE,
  ENOEXEC: WE,
  ENOLCK: YE,
  ENOLINK: XE,
  ENOMEM: QE,
  ENOMSG: ZE,
  ENOPROTOOPT: JE,
  ENOSPC: eS,
  ENOSR: tS,
  ENOSTR: rS,
  ENOSYS: iS,
  ENOTCONN: nS,
  ENOTDIR: aS,
  ENOTEMPTY: sS,
  ENOTSOCK: fS,
  ENOTSUP: oS,
  ENOTTY: uS,
  ENXIO: cS,
  EOPNOTSUPP: hS,
  EOVERFLOW: lS,
  EPERM: dS,
  EPIPE: pS,
  EPROTO: vS,
  EPROTONOSUPPORT: yS,
  EPROTOTYPE: gS,
  ERANGE: mS,
  EROFS: bS,
  ESPIPE: xS,
  ESRCH: _S,
  ESTALE: ES,
  ETIME: SS,
  ETIMEDOUT: wS,
  ETXTBSY: CS,
  EWOULDBLOCK: AS,
  EXDEV: BS,
  SIGHUP: IS,
  SIGINT: TS,
  SIGQUIT: MS,
  SIGILL: RS,
  SIGTRAP: NS,
  SIGABRT: DS,
  SIGIOT: OS,
  SIGBUS: PS,
  SIGFPE: LS,
  SIGKILL: kS,
  SIGUSR1: US,
  SIGSEGV: FS,
  SIGUSR2: qS,
  SIGPIPE: VS,
  SIGALRM: KS,
  SIGTERM: $S,
  SIGCHLD: HS,
  SIGCONT: GS,
  SIGSTOP: zS,
  SIGTSTP: jS,
  SIGTTIN: WS,
  SIGTTOU: YS,
  SIGURG: XS,
  SIGXCPU: QS,
  SIGXFSZ: ZS,
  SIGVTALRM: JS,
  SIGPROF: ew,
  SIGWINCH: tw,
  SIGIO: rw,
  SIGSYS: iw,
  SSL_OP_ALL: nw,
  SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: aw,
  SSL_OP_CIPHER_SERVER_PREFERENCE: sw,
  SSL_OP_CISCO_ANYCONNECT: fw,
  SSL_OP_COOKIE_EXCHANGE: ow,
  SSL_OP_CRYPTOPRO_TLSEXT_BUG: uw,
  SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: cw,
  SSL_OP_EPHEMERAL_RSA: hw,
  SSL_OP_LEGACY_SERVER_CONNECT: lw,
  SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: dw,
  SSL_OP_MICROSOFT_SESS_ID_BUG: pw,
  SSL_OP_MSIE_SSLV2_RSA_PADDING: vw,
  SSL_OP_NETSCAPE_CA_DN_BUG: yw,
  SSL_OP_NETSCAPE_CHALLENGE_BUG: gw,
  SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: mw,
  SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: bw,
  SSL_OP_NO_COMPRESSION: xw,
  SSL_OP_NO_QUERY_MTU: _w,
  SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: Ew,
  SSL_OP_NO_SSLv2: Sw,
  SSL_OP_NO_SSLv3: ww,
  SSL_OP_NO_TICKET: Cw,
  SSL_OP_NO_TLSv1: Aw,
  SSL_OP_NO_TLSv1_1: Bw,
  SSL_OP_NO_TLSv1_2: Iw,
  SSL_OP_PKCS1_CHECK_1: Tw,
  SSL_OP_PKCS1_CHECK_2: Mw,
  SSL_OP_SINGLE_DH_USE: Rw,
  SSL_OP_SINGLE_ECDH_USE: Nw,
  SSL_OP_SSLEAY_080_CLIENT_DH_BUG: Dw,
  SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: Ow,
  SSL_OP_TLS_BLOCK_PADDING_BUG: Pw,
  SSL_OP_TLS_D5_BUG: Lw,
  SSL_OP_TLS_ROLLBACK_BUG: kw,
  ENGINE_METHOD_DSA: Uw,
  ENGINE_METHOD_DH: Fw,
  ENGINE_METHOD_RAND: qw,
  ENGINE_METHOD_ECDH: Vw,
  ENGINE_METHOD_ECDSA: Kw,
  ENGINE_METHOD_CIPHERS: $w,
  ENGINE_METHOD_DIGESTS: Hw,
  ENGINE_METHOD_STORE: Gw,
  ENGINE_METHOD_PKEY_METHS: zw,
  ENGINE_METHOD_PKEY_ASN1_METHS: jw,
  ENGINE_METHOD_ALL: Ww,
  ENGINE_METHOD_NONE: Yw,
  DH_CHECK_P_NOT_SAFE_PRIME: Xw,
  DH_CHECK_P_NOT_PRIME: Qw,
  DH_UNABLE_TO_CHECK_GENERATOR: Zw,
  DH_NOT_SUITABLE_GENERATOR: Jw,
  NPN_ENABLED: e7,
  RSA_PKCS1_PADDING: t7,
  RSA_SSLV23_PADDING: r7,
  RSA_NO_PADDING: i7,
  RSA_PKCS1_OAEP_PADDING: n7,
  RSA_X931_PADDING: a7,
  RSA_PKCS1_PSS_PADDING: s7,
  POINT_CONVERSION_COMPRESSED: f7,
  POINT_CONVERSION_UNCOMPRESSED: o7,
  POINT_CONVERSION_HYBRID: u7,
  F_OK: c7,
  R_OK: h7,
  W_OK: l7,
  X_OK: d7,
  UV_UDP_REUSEADDR: p7
};
var Bh = {}, tr = {};
_r();
tr.linebrk = function(e, t) {
  for (var o = "", r = 0; r + t < e.length; )
    o += e.substring(r, r + t) + `
`, r += t;
  return o + e.substring(r, e.length);
};
tr.detectEnvironment = function() {
  return typeof window < "u" && window && !(Ve && Ve.title === "node") ? "browser" : "node";
};
tr.get32IntFromBuffer = function(e, t) {
  t = t || 0;
  var o = 0;
  if ((o = e.length - t) > 0) {
    if (o >= 4)
      return e.readUIntBE(t, o);
    for (var r = 0, h = t + o, a = 0; h > t; h--, a += 2)
      r += e[h - 1] * Math.pow(16, a);
    return r;
  } else
    return NaN;
};
tr._ = {
  isObject: function(e) {
    var t = typeof e;
    return !!e && (t == "object" || t == "function");
  },
  isString: function(e) {
    return typeof e == "string" || e instanceof String;
  },
  isNumber: function(e) {
    return typeof e == "number" || !isNaN(parseFloat(e)) && isFinite(e);
  },
  /**
   * Returns copy of `obj` without `removeProp` field.
   * @param obj
   * @param removeProp
   * @returns Object
   */
  omit: function(e, t) {
    var o = {};
    for (var r in e)
      !e.hasOwnProperty(r) || r === t || (o[r] = e[r]);
    return o;
  }
};
tr.trimSurroundingText = function(e, t, o) {
  var r = 0, h = e.length, a = e.indexOf(t);
  a >= 0 && (r = a + t.length);
  var p = e.indexOf(o, a);
  return p >= 0 && (h = p), e.substring(r, h);
};
var v7 = _r(), y7 = tr._, Ya;
function Ee(e, t) {
  e != null && (typeof e == "number" ? this.fromNumber(e, t) : pe.Buffer.isBuffer(e) ? this.fromBuffer(e) : t == null && typeof e != "string" ? this.fromByteArray(e) : this.fromString(e, t));
}
function mt() {
  return new Ee(null);
}
function g7(e, t, o, r, h, a) {
  for (var p = t & 16383, d = t >> 14; --a >= 0; ) {
    var b = this[e] & 16383, g = this[e++] >> 14, w = d * b + g * p;
    b = p * b + ((w & 16383) << 14) + o[r] + h, h = (b >> 28) + (w >> 14) + d * g, o[r++] = b & 268435455;
  }
  return h;
}
Ee.prototype.am = g7;
Ya = 28;
Ee.prototype.DB = Ya;
Ee.prototype.DM = (1 << Ya) - 1;
Ee.prototype.DV = 1 << Ya;
var Ih = 52;
Ee.prototype.FV = Math.pow(2, Ih);
Ee.prototype.F1 = Ih - Ya;
Ee.prototype.F2 = 2 * Ya - Ih;
var m7 = "0123456789abcdefghijklmnopqrstuvwxyz", Tf = new Array(), Xa, Kr;
Xa = 48;
for (Kr = 0; Kr <= 9; ++Kr)
  Tf[Xa++] = Kr;
Xa = 97;
for (Kr = 10; Kr < 36; ++Kr)
  Tf[Xa++] = Kr;
Xa = 65;
for (Kr = 10; Kr < 36; ++Kr)
  Tf[Xa++] = Kr;
function vc(e) {
  return m7.charAt(e);
}
function jy(e, t) {
  var o = Tf[e.charCodeAt(t)];
  return o ?? -1;
}
function b7(e) {
  for (var t = this.t - 1; t >= 0; --t)
    e[t] = this[t];
  e.t = this.t, e.s = this.s;
}
function x7(e) {
  this.t = 1, this.s = e < 0 ? -1 : 0, e > 0 ? this[0] = e : e < -1 ? this[0] = e + DV : this.t = 0;
}
function vn(e) {
  var t = mt();
  return t.fromInt(e), t;
}
function _7(e, t, o) {
  var r;
  switch (t) {
    case 2:
      r = 1;
      break;
    case 4:
      r = 2;
      break;
    case 8:
      r = 3;
      break;
    case 16:
      r = 4;
      break;
    case 32:
      r = 5;
      break;
    case 256:
      r = 8;
      break;
    default:
      this.fromRadix(e, t);
      return;
  }
  this.t = 0, this.s = 0;
  for (var h = e.length, a = !1, p = 0; --h >= 0; ) {
    var d = r == 8 ? e[h] & 255 : jy(e, h);
    if (d < 0) {
      e.charAt(h) == "-" && (a = !0);
      continue;
    }
    a = !1, p === 0 ? this[this.t++] = d : p + r > this.DB ? (this[this.t - 1] |= (d & (1 << this.DB - p) - 1) << p, this[this.t++] = d >> this.DB - p) : this[this.t - 1] |= d << p, p += r, p >= this.DB && (p -= this.DB);
  }
  !o && r == 8 && e[0] & 128 && (this.s = -1, p > 0 && (this[this.t - 1] |= (1 << this.DB - p) - 1 << p)), this.clamp(), a && Ee.ZERO.subTo(this, this);
}
function E7(e, t) {
  this.fromString(e, 256, t);
}
function S7(e) {
  this.fromString(e, 256, !0);
}
function w7() {
  for (var e = this.s & this.DM; this.t > 0 && this[this.t - 1] == e; )
    --this.t;
}
function C7(e) {
  if (this.s < 0)
    return "-" + this.negate().toString(e);
  var t;
  if (e == 16)
    t = 4;
  else if (e == 8)
    t = 3;
  else if (e == 2)
    t = 1;
  else if (e == 32)
    t = 5;
  else if (e == 4)
    t = 2;
  else
    return this.toRadix(e);
  var o = (1 << t) - 1, r, h = !1, a = "", p = this.t, d = this.DB - p * this.DB % t;
  if (p-- > 0)
    for (d < this.DB && (r = this[p] >> d) > 0 && (h = !0, a = vc(r)); p >= 0; )
      d < t ? (r = (this[p] & (1 << d) - 1) << t - d, r |= this[--p] >> (d += this.DB - t)) : (r = this[p] >> (d -= t) & o, d <= 0 && (d += this.DB, --p)), r > 0 && (h = !0), h && (a += vc(r));
  return h ? a : "0";
}
function A7() {
  var e = mt();
  return Ee.ZERO.subTo(this, e), e;
}
function B7() {
  return this.s < 0 ? this.negate() : this;
}
function I7(e) {
  var t = this.s - e.s;
  if (t != 0)
    return t;
  var o = this.t;
  if (t = o - e.t, t != 0)
    return this.s < 0 ? -t : t;
  for (; --o >= 0; )
    if ((t = this[o] - e[o]) != 0)
      return t;
  return 0;
}
function Mf(e) {
  var t = 1, o;
  return (o = e >>> 16) != 0 && (e = o, t += 16), (o = e >> 8) != 0 && (e = o, t += 8), (o = e >> 4) != 0 && (e = o, t += 4), (o = e >> 2) != 0 && (e = o, t += 2), (o = e >> 1) != 0 && (e = o, t += 1), t;
}
function T7() {
  return this.t <= 0 ? 0 : this.DB * (this.t - 1) + Mf(this[this.t - 1] ^ this.s & this.DM);
}
function M7(e, t) {
  var o;
  for (o = this.t - 1; o >= 0; --o)
    t[o + e] = this[o];
  for (o = e - 1; o >= 0; --o)
    t[o] = 0;
  t.t = this.t + e, t.s = this.s;
}
function R7(e, t) {
  for (var o = e; o < this.t; ++o)
    t[o - e] = this[o];
  t.t = Math.max(this.t - e, 0), t.s = this.s;
}
function N7(e, t) {
  var o = e % this.DB, r = this.DB - o, h = (1 << r) - 1, a = Math.floor(e / this.DB), p = this.s << o & this.DM, d;
  for (d = this.t - 1; d >= 0; --d)
    t[d + a + 1] = this[d] >> r | p, p = (this[d] & h) << o;
  for (d = a - 1; d >= 0; --d)
    t[d] = 0;
  t[a] = p, t.t = this.t + a + 1, t.s = this.s, t.clamp();
}
function D7(e, t) {
  t.s = this.s;
  var o = Math.floor(e / this.DB);
  if (o >= this.t) {
    t.t = 0;
    return;
  }
  var r = e % this.DB, h = this.DB - r, a = (1 << r) - 1;
  t[0] = this[o] >> r;
  for (var p = o + 1; p < this.t; ++p)
    t[p - o - 1] |= (this[p] & a) << h, t[p - o] = this[p] >> r;
  r > 0 && (t[this.t - o - 1] |= (this.s & a) << h), t.t = this.t - o, t.clamp();
}
function O7(e, t) {
  for (var o = 0, r = 0, h = Math.min(e.t, this.t); o < h; )
    r += this[o] - e[o], t[o++] = r & this.DM, r >>= this.DB;
  if (e.t < this.t) {
    for (r -= e.s; o < this.t; )
      r += this[o], t[o++] = r & this.DM, r >>= this.DB;
    r += this.s;
  } else {
    for (r += this.s; o < e.t; )
      r -= e[o], t[o++] = r & this.DM, r >>= this.DB;
    r -= e.s;
  }
  t.s = r < 0 ? -1 : 0, r < -1 ? t[o++] = this.DV + r : r > 0 && (t[o++] = r), t.t = o, t.clamp();
}
function P7(e, t) {
  var o = this.abs(), r = e.abs(), h = o.t;
  for (t.t = h + r.t; --h >= 0; )
    t[h] = 0;
  for (h = 0; h < r.t; ++h)
    t[h + o.t] = o.am(0, r[h], t, h, 0, o.t);
  t.s = 0, t.clamp(), this.s != e.s && Ee.ZERO.subTo(t, t);
}
function L7(e) {
  for (var t = this.abs(), o = e.t = 2 * t.t; --o >= 0; )
    e[o] = 0;
  for (o = 0; o < t.t - 1; ++o) {
    var r = t.am(o, t[o], e, 2 * o, 0, 1);
    (e[o + t.t] += t.am(o + 1, 2 * t[o], e, 2 * o + 1, r, t.t - o - 1)) >= t.DV && (e[o + t.t] -= t.DV, e[o + t.t + 1] = 1);
  }
  e.t > 0 && (e[e.t - 1] += t.am(o, t[o], e, 2 * o, 0, 1)), e.s = 0, e.clamp();
}
function k7(e, t, o) {
  var r = e.abs();
  if (!(r.t <= 0)) {
    var h = this.abs();
    if (h.t < r.t) {
      t != null && t.fromInt(0), o != null && this.copyTo(o);
      return;
    }
    o == null && (o = mt());
    var a = mt(), p = this.s, d = e.s, b = this.DB - Mf(r[r.t - 1]);
    b > 0 ? (r.lShiftTo(b, a), h.lShiftTo(b, o)) : (r.copyTo(a), h.copyTo(o));
    var g = a.t, w = a[g - 1];
    if (w !== 0) {
      var C = w * (1 << this.F1) + (g > 1 ? a[g - 2] >> this.F2 : 0), T = this.FV / C, k = (1 << this.F1) / C, q = 1 << this.F2, O = o.t, N = O - g, j = t ?? mt();
      for (a.dlShiftTo(N, j), o.compareTo(j) >= 0 && (o[o.t++] = 1, o.subTo(j, o)), Ee.ONE.dlShiftTo(g, j), j.subTo(a, a); a.t < g; )
        a[a.t++] = 0;
      for (; --N >= 0; ) {
        var U = o[--O] == w ? this.DM : Math.floor(o[O] * T + (o[O - 1] + q) * k);
        if ((o[O] += a.am(0, U, o, N, 0, g)) < U)
          for (a.dlShiftTo(N, j), o.subTo(j, o); o[O] < --U; )
            o.subTo(j, o);
      }
      t != null && (o.drShiftTo(g, t), p != d && Ee.ZERO.subTo(t, t)), o.t = g, o.clamp(), b > 0 && o.rShiftTo(b, o), p < 0 && Ee.ZERO.subTo(o, o);
    }
  }
}
function U7(e) {
  var t = mt();
  return this.abs().divRemTo(e, null, t), this.s < 0 && t.compareTo(Ee.ZERO) > 0 && e.subTo(t, t), t;
}
function sa(e) {
  this.m = e;
}
function F7(e) {
  return e.s < 0 || e.compareTo(this.m) >= 0 ? e.mod(this.m) : e;
}
function q7(e) {
  return e;
}
function V7(e) {
  e.divRemTo(this.m, null, e);
}
function K7(e, t, o) {
  e.multiplyTo(t, o), this.reduce(o);
}
function $7(e, t) {
  e.squareTo(t), this.reduce(t);
}
sa.prototype.convert = F7;
sa.prototype.revert = q7;
sa.prototype.reduce = V7;
sa.prototype.mulTo = K7;
sa.prototype.sqrTo = $7;
function H7() {
  if (this.t < 1)
    return 0;
  var e = this[0];
  if (!(e & 1))
    return 0;
  var t = e & 3;
  return t = t * (2 - (e & 15) * t) & 15, t = t * (2 - (e & 255) * t) & 255, t = t * (2 - ((e & 65535) * t & 65535)) & 65535, t = t * (2 - e * t % this.DV) % this.DV, t > 0 ? this.DV - t : -t;
}
function fa(e) {
  this.m = e, this.mp = e.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << e.DB - 15) - 1, this.mt2 = 2 * e.t;
}
function G7(e) {
  var t = mt();
  return e.abs().dlShiftTo(this.m.t, t), t.divRemTo(this.m, null, t), e.s < 0 && t.compareTo(Ee.ZERO) > 0 && this.m.subTo(t, t), t;
}
function z7(e) {
  var t = mt();
  return e.copyTo(t), this.reduce(t), t;
}
function j7(e) {
  for (; e.t <= this.mt2; )
    e[e.t++] = 0;
  for (var t = 0; t < this.m.t; ++t) {
    var o = e[t] & 32767, r = o * this.mpl + ((o * this.mph + (e[t] >> 15) * this.mpl & this.um) << 15) & e.DM;
    for (o = t + this.m.t, e[o] += this.m.am(0, r, e, t, 0, this.m.t); e[o] >= e.DV; )
      e[o] -= e.DV, e[++o]++;
  }
  e.clamp(), e.drShiftTo(this.m.t, e), e.compareTo(this.m) >= 0 && e.subTo(this.m, e);
}
function W7(e, t) {
  e.squareTo(t), this.reduce(t);
}
function Y7(e, t, o) {
  e.multiplyTo(t, o), this.reduce(o);
}
fa.prototype.convert = G7;
fa.prototype.revert = z7;
fa.prototype.reduce = j7;
fa.prototype.mulTo = Y7;
fa.prototype.sqrTo = W7;
function X7() {
  return (this.t > 0 ? this[0] & 1 : this.s) === 0;
}
function Q7(e, t) {
  if (e > 4294967295 || e < 1)
    return Ee.ONE;
  var o = mt(), r = mt(), h = t.convert(this), a = Mf(e) - 1;
  for (h.copyTo(o); --a >= 0; )
    if (t.sqrTo(o, r), (e & 1 << a) > 0)
      t.mulTo(r, h, o);
    else {
      var p = o;
      o = r, r = p;
    }
  return t.revert(o);
}
function Z7(e, t) {
  var o;
  return e < 256 || t.isEven() ? o = new sa(t) : o = new fa(t), this.exp(e, o);
}
function J7() {
  var e = mt();
  return this.copyTo(e), e;
}
function e9() {
  if (this.s < 0) {
    if (this.t == 1)
      return this[0] - this.DV;
    if (this.t === 0)
      return -1;
  } else {
    if (this.t == 1)
      return this[0];
    if (this.t === 0)
      return 0;
  }
  return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
}
function t9() {
  return this.t == 0 ? this.s : this[0] << 24 >> 24;
}
function r9() {
  return this.t == 0 ? this.s : this[0] << 16 >> 16;
}
function i9(e) {
  return Math.floor(Math.LN2 * this.DB / Math.log(e));
}
function n9() {
  return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this[0] <= 0 ? 0 : 1;
}
function a9(e) {
  if (e == null && (e = 10), this.signum() === 0 || e < 2 || e > 36)
    return "0";
  var t = this.chunkSize(e), o = Math.pow(e, t), r = vn(o), h = mt(), a = mt(), p = "";
  for (this.divRemTo(r, h, a); h.signum() > 0; )
    p = (o + a.intValue()).toString(e).substr(1) + p, h.divRemTo(r, h, a);
  return a.intValue().toString(e) + p;
}
function s9(e, t) {
  this.fromInt(0), t == null && (t = 10);
  for (var o = this.chunkSize(t), r = Math.pow(t, o), h = !1, a = 0, p = 0, d = 0; d < e.length; ++d) {
    var b = jy(e, d);
    if (b < 0) {
      e.charAt(d) == "-" && this.signum() === 0 && (h = !0);
      continue;
    }
    p = t * p + b, ++a >= o && (this.dMultiply(r), this.dAddOffset(p, 0), a = 0, p = 0);
  }
  a > 0 && (this.dMultiply(Math.pow(t, a)), this.dAddOffset(p, 0)), h && Ee.ZERO.subTo(this, this);
}
function f9(e, t) {
  if (typeof t == "number")
    if (e < 2)
      this.fromInt(1);
    else
      for (this.fromNumber(e), this.testBit(e - 1) || this.bitwiseTo(Ee.ONE.shiftLeft(e - 1), Th, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(t); )
        this.dAddOffset(2, 0), this.bitLength() > e && this.subTo(Ee.ONE.shiftLeft(e - 1), this);
  else {
    var o = v7.randomBytes((e >> 3) + 1), r = e & 7;
    r > 0 ? o[0] &= (1 << r) - 1 : o[0] = 0, this.fromByteArray(o);
  }
}
function o9() {
  var e = this.t, t = new Array();
  t[0] = this.s;
  var o = this.DB - e * this.DB % 8, r, h = 0;
  if (e-- > 0)
    for (o < this.DB && (r = this[e] >> o) != (this.s & this.DM) >> o && (t[h++] = r | this.s << this.DB - o); e >= 0; )
      o < 8 ? (r = (this[e] & (1 << o) - 1) << 8 - o, r |= this[--e] >> (o += this.DB - 8)) : (r = this[e] >> (o -= 8) & 255, o <= 0 && (o += this.DB, --e)), r & 128 && (r |= -256), h === 0 && (this.s & 128) != (r & 128) && ++h, (h > 0 || r != this.s) && (t[h++] = r);
  return t;
}
function u9(e) {
  var t = pe.Buffer.from(this.toByteArray());
  if (e === !0 && t[0] === 0)
    t = t.slice(1);
  else if (y7.isNumber(e)) {
    if (t.length > e) {
      for (var o = 0; o < t.length - e; o++)
        if (t[o] !== 0)
          return null;
      return t.slice(t.length - e);
    } else if (t.length < e) {
      var r = pe.Buffer.alloc(e);
      return r.fill(0, 0, e - t.length), t.copy(r, e - t.length), r;
    }
  }
  return t;
}
function c9(e) {
  return this.compareTo(e) == 0;
}
function h9(e) {
  return this.compareTo(e) < 0 ? this : e;
}
function l9(e) {
  return this.compareTo(e) > 0 ? this : e;
}
function d9(e, t, o) {
  var r, h, a = Math.min(e.t, this.t);
  for (r = 0; r < a; ++r)
    o[r] = t(this[r], e[r]);
  if (e.t < this.t) {
    for (h = e.s & this.DM, r = a; r < this.t; ++r)
      o[r] = t(this[r], h);
    o.t = this.t;
  } else {
    for (h = this.s & this.DM, r = a; r < e.t; ++r)
      o[r] = t(h, e[r]);
    o.t = e.t;
  }
  o.s = t(this.s, e.s), o.clamp();
}
function p9(e, t) {
  return e & t;
}
function v9(e) {
  var t = mt();
  return this.bitwiseTo(e, p9, t), t;
}
function Th(e, t) {
  return e | t;
}
function y9(e) {
  var t = mt();
  return this.bitwiseTo(e, Th, t), t;
}
function Wy(e, t) {
  return e ^ t;
}
function g9(e) {
  var t = mt();
  return this.bitwiseTo(e, Wy, t), t;
}
function Yy(e, t) {
  return e & ~t;
}
function m9(e) {
  var t = mt();
  return this.bitwiseTo(e, Yy, t), t;
}
function b9() {
  for (var e = mt(), t = 0; t < this.t; ++t)
    e[t] = this.DM & ~this[t];
  return e.t = this.t, e.s = ~this.s, e;
}
function x9(e) {
  var t = mt();
  return e < 0 ? this.rShiftTo(-e, t) : this.lShiftTo(e, t), t;
}
function _9(e) {
  var t = mt();
  return e < 0 ? this.lShiftTo(-e, t) : this.rShiftTo(e, t), t;
}
function E9(e) {
  if (e === 0)
    return -1;
  var t = 0;
  return e & 65535 || (e >>= 16, t += 16), e & 255 || (e >>= 8, t += 8), e & 15 || (e >>= 4, t += 4), e & 3 || (e >>= 2, t += 2), e & 1 || ++t, t;
}
function S9() {
  for (var e = 0; e < this.t; ++e)
    if (this[e] != 0)
      return e * this.DB + E9(this[e]);
  return this.s < 0 ? this.t * this.DB : -1;
}
function w9(e) {
  for (var t = 0; e != 0; )
    e &= e - 1, ++t;
  return t;
}
function C9() {
  for (var e = 0, t = this.s & this.DM, o = 0; o < this.t; ++o)
    e += w9(this[o] ^ t);
  return e;
}
function A9(e) {
  var t = Math.floor(e / this.DB);
  return t >= this.t ? this.s != 0 : (this[t] & 1 << e % this.DB) != 0;
}
function B9(e, t) {
  var o = Ee.ONE.shiftLeft(e);
  return this.bitwiseTo(o, t, o), o;
}
function I9(e) {
  return this.changeBit(e, Th);
}
function T9(e) {
  return this.changeBit(e, Yy);
}
function M9(e) {
  return this.changeBit(e, Wy);
}
function R9(e, t) {
  for (var o = 0, r = 0, h = Math.min(e.t, this.t); o < h; )
    r += this[o] + e[o], t[o++] = r & this.DM, r >>= this.DB;
  if (e.t < this.t) {
    for (r += e.s; o < this.t; )
      r += this[o], t[o++] = r & this.DM, r >>= this.DB;
    r += this.s;
  } else {
    for (r += this.s; o < e.t; )
      r += e[o], t[o++] = r & this.DM, r >>= this.DB;
    r += e.s;
  }
  t.s = r < 0 ? -1 : 0, r > 0 ? t[o++] = r : r < -1 && (t[o++] = this.DV + r), t.t = o, t.clamp();
}
function N9(e) {
  var t = mt();
  return this.addTo(e, t), t;
}
function D9(e) {
  var t = mt();
  return this.subTo(e, t), t;
}
function O9(e) {
  var t = mt();
  return this.multiplyTo(e, t), t;
}
function P9() {
  var e = mt();
  return this.squareTo(e), e;
}
function L9(e) {
  var t = mt();
  return this.divRemTo(e, t, null), t;
}
function k9(e) {
  var t = mt();
  return this.divRemTo(e, null, t), t;
}
function U9(e) {
  var t = mt(), o = mt();
  return this.divRemTo(e, t, o), new Array(t, o);
}
function F9(e) {
  this[this.t] = this.am(0, e - 1, this, 0, 0, this.t), ++this.t, this.clamp();
}
function q9(e, t) {
  if (e !== 0) {
    for (; this.t <= t; )
      this[this.t++] = 0;
    for (this[t] += e; this[t] >= this.DV; )
      this[t] -= this.DV, ++t >= this.t && (this[this.t++] = 0), ++this[t];
  }
}
function H0() {
}
function Xy(e) {
  return e;
}
function V9(e, t, o) {
  e.multiplyTo(t, o);
}
function K9(e, t) {
  e.squareTo(t);
}
H0.prototype.convert = Xy;
H0.prototype.revert = Xy;
H0.prototype.mulTo = V9;
H0.prototype.sqrTo = K9;
function $9(e) {
  return this.exp(e, new H0());
}
function H9(e, t, o) {
  var r = Math.min(this.t + e.t, t);
  for (o.s = 0, o.t = r; r > 0; )
    o[--r] = 0;
  var h;
  for (h = o.t - this.t; r < h; ++r)
    o[r + this.t] = this.am(0, e[r], o, r, 0, this.t);
  for (h = Math.min(e.t, t); r < h; ++r)
    this.am(0, e[r], o, r, 0, t - r);
  o.clamp();
}
function G9(e, t, o) {
  --t;
  var r = o.t = this.t + e.t - t;
  for (o.s = 0; --r >= 0; )
    o[r] = 0;
  for (r = Math.max(t - this.t, 0); r < e.t; ++r)
    o[this.t + r - t] = this.am(t - r, e[r], o, 0, 0, this.t + r - t);
  o.clamp(), o.drShiftTo(1, o);
}
function Qa(e) {
  this.r2 = mt(), this.q3 = mt(), Ee.ONE.dlShiftTo(2 * e.t, this.r2), this.mu = this.r2.divide(e), this.m = e;
}
function z9(e) {
  if (e.s < 0 || e.t > 2 * this.m.t)
    return e.mod(this.m);
  if (e.compareTo(this.m) < 0)
    return e;
  var t = mt();
  return e.copyTo(t), this.reduce(t), t;
}
function j9(e) {
  return e;
}
function W9(e) {
  for (e.drShiftTo(this.m.t - 1, this.r2), e.t > this.m.t + 1 && (e.t = this.m.t + 1, e.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); e.compareTo(this.r2) < 0; )
    e.dAddOffset(1, this.m.t + 1);
  for (e.subTo(this.r2, e); e.compareTo(this.m) >= 0; )
    e.subTo(this.m, e);
}
function Y9(e, t) {
  e.squareTo(t), this.reduce(t);
}
function X9(e, t, o) {
  e.multiplyTo(t, o), this.reduce(o);
}
Qa.prototype.convert = z9;
Qa.prototype.revert = j9;
Qa.prototype.reduce = W9;
Qa.prototype.mulTo = X9;
Qa.prototype.sqrTo = Y9;
function Q9(e, t) {
  var o = e.bitLength(), r, h = vn(1), a;
  if (o <= 0)
    return h;
  o < 18 ? r = 1 : o < 48 ? r = 3 : o < 144 ? r = 4 : o < 768 ? r = 5 : r = 6, o < 8 ? a = new sa(t) : t.isEven() ? a = new Qa(t) : a = new fa(t);
  var p = new Array(), d = 3, b = r - 1, g = (1 << r) - 1;
  if (p[1] = a.convert(this), r > 1) {
    var w = mt();
    for (a.sqrTo(p[1], w); d <= g; )
      p[d] = mt(), a.mulTo(w, p[d - 2], p[d]), d += 2;
  }
  var C = e.t - 1, T, k = !0, q = mt(), O;
  for (o = Mf(e[C]) - 1; C >= 0; ) {
    for (o >= b ? T = e[C] >> o - b & g : (T = (e[C] & (1 << o + 1) - 1) << b - o, C > 0 && (T |= e[C - 1] >> this.DB + o - b)), d = r; !(T & 1); )
      T >>= 1, --d;
    if ((o -= d) < 0 && (o += this.DB, --C), k)
      p[T].copyTo(h), k = !1;
    else {
      for (; d > 1; )
        a.sqrTo(h, q), a.sqrTo(q, h), d -= 2;
      d > 0 ? a.sqrTo(h, q) : (O = h, h = q, q = O), a.mulTo(q, p[T], h);
    }
    for (; C >= 0 && !(e[C] & 1 << o); )
      a.sqrTo(h, q), O = h, h = q, q = O, --o < 0 && (o = this.DB - 1, --C);
  }
  return a.revert(h);
}
function Z9(e) {
  var t = this.s < 0 ? this.negate() : this.clone(), o = e.s < 0 ? e.negate() : e.clone();
  if (t.compareTo(o) < 0) {
    var r = t;
    t = o, o = r;
  }
  var h = t.getLowestSetBit(), a = o.getLowestSetBit();
  if (a < 0)
    return t;
  for (h < a && (a = h), a > 0 && (t.rShiftTo(a, t), o.rShiftTo(a, o)); t.signum() > 0; )
    (h = t.getLowestSetBit()) > 0 && t.rShiftTo(h, t), (h = o.getLowestSetBit()) > 0 && o.rShiftTo(h, o), t.compareTo(o) >= 0 ? (t.subTo(o, t), t.rShiftTo(1, t)) : (o.subTo(t, o), o.rShiftTo(1, o));
  return a > 0 && o.lShiftTo(a, o), o;
}
function J9(e) {
  if (e <= 0)
    return 0;
  var t = this.DV % e, o = this.s < 0 ? e - 1 : 0;
  if (this.t > 0)
    if (t === 0)
      o = this[0] % e;
    else
      for (var r = this.t - 1; r >= 0; --r)
        o = (t * o + this[r]) % e;
  return o;
}
function eC(e) {
  var t = e.isEven();
  if (this.isEven() && t || e.signum() === 0)
    return Ee.ZERO;
  for (var o = e.clone(), r = this.clone(), h = vn(1), a = vn(0), p = vn(0), d = vn(1); o.signum() != 0; ) {
    for (; o.isEven(); )
      o.rShiftTo(1, o), t ? ((!h.isEven() || !a.isEven()) && (h.addTo(this, h), a.subTo(e, a)), h.rShiftTo(1, h)) : a.isEven() || a.subTo(e, a), a.rShiftTo(1, a);
    for (; r.isEven(); )
      r.rShiftTo(1, r), t ? ((!p.isEven() || !d.isEven()) && (p.addTo(this, p), d.subTo(e, d)), p.rShiftTo(1, p)) : d.isEven() || d.subTo(e, d), d.rShiftTo(1, d);
    o.compareTo(r) >= 0 ? (o.subTo(r, o), t && h.subTo(p, h), a.subTo(d, a)) : (r.subTo(o, r), t && p.subTo(h, p), d.subTo(a, d));
  }
  if (r.compareTo(Ee.ONE) != 0)
    return Ee.ZERO;
  if (d.compareTo(e) >= 0)
    return d.subtract(e);
  if (d.signum() < 0)
    d.addTo(e, d);
  else
    return d;
  return d.signum() < 0 ? d.add(e) : d;
}
var gr = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997], tC = (1 << 26) / gr[gr.length - 1];
function rC(e) {
  var t, o = this.abs();
  if (o.t == 1 && o[0] <= gr[gr.length - 1]) {
    for (t = 0; t < gr.length; ++t)
      if (o[0] == gr[t])
        return !0;
    return !1;
  }
  if (o.isEven())
    return !1;
  for (t = 1; t < gr.length; ) {
    for (var r = gr[t], h = t + 1; h < gr.length && r < tC; )
      r *= gr[h++];
    for (r = o.modInt(r); t < h; )
      if (r % gr[t++] === 0)
        return !1;
  }
  return o.millerRabin(e);
}
function iC(e) {
  var t = this.subtract(Ee.ONE), o = t.getLowestSetBit();
  if (o <= 0)
    return !1;
  var r = t.shiftRight(o);
  e = e + 1 >> 1, e > gr.length && (e = gr.length);
  for (var h = mt(), a = 0; a < e; ++a) {
    h.fromInt(gr[Math.floor(Math.random() * gr.length)]);
    var p = h.modPow(r, this);
    if (p.compareTo(Ee.ONE) != 0 && p.compareTo(t) != 0) {
      for (var d = 1; d++ < o && p.compareTo(t) != 0; )
        if (p = p.modPowInt(2, this), p.compareTo(Ee.ONE) === 0)
          return !1;
      if (p.compareTo(t) != 0)
        return !1;
    }
  }
  return !0;
}
Ee.prototype.copyTo = b7;
Ee.prototype.fromInt = x7;
Ee.prototype.fromString = _7;
Ee.prototype.fromByteArray = E7;
Ee.prototype.fromBuffer = S7;
Ee.prototype.clamp = w7;
Ee.prototype.dlShiftTo = M7;
Ee.prototype.drShiftTo = R7;
Ee.prototype.lShiftTo = N7;
Ee.prototype.rShiftTo = D7;
Ee.prototype.subTo = O7;
Ee.prototype.multiplyTo = P7;
Ee.prototype.squareTo = L7;
Ee.prototype.divRemTo = k7;
Ee.prototype.invDigit = H7;
Ee.prototype.isEven = X7;
Ee.prototype.exp = Q7;
Ee.prototype.chunkSize = i9;
Ee.prototype.toRadix = a9;
Ee.prototype.fromRadix = s9;
Ee.prototype.fromNumber = f9;
Ee.prototype.bitwiseTo = d9;
Ee.prototype.changeBit = B9;
Ee.prototype.addTo = R9;
Ee.prototype.dMultiply = F9;
Ee.prototype.dAddOffset = q9;
Ee.prototype.multiplyLowerTo = H9;
Ee.prototype.multiplyUpperTo = G9;
Ee.prototype.modInt = J9;
Ee.prototype.millerRabin = iC;
Ee.prototype.toString = C7;
Ee.prototype.negate = A7;
Ee.prototype.abs = B7;
Ee.prototype.compareTo = I7;
Ee.prototype.bitLength = T7;
Ee.prototype.mod = U7;
Ee.prototype.modPowInt = Z7;
Ee.prototype.clone = J7;
Ee.prototype.intValue = e9;
Ee.prototype.byteValue = t9;
Ee.prototype.shortValue = r9;
Ee.prototype.signum = n9;
Ee.prototype.toByteArray = o9;
Ee.prototype.toBuffer = u9;
Ee.prototype.equals = c9;
Ee.prototype.min = h9;
Ee.prototype.max = l9;
Ee.prototype.and = v9;
Ee.prototype.or = y9;
Ee.prototype.xor = g9;
Ee.prototype.andNot = m9;
Ee.prototype.not = b9;
Ee.prototype.shiftLeft = x9;
Ee.prototype.shiftRight = _9;
Ee.prototype.getLowestSetBit = S9;
Ee.prototype.bitCount = C9;
Ee.prototype.testBit = A9;
Ee.prototype.setBit = I9;
Ee.prototype.clearBit = T9;
Ee.prototype.flipBit = M9;
Ee.prototype.add = N9;
Ee.prototype.subtract = D9;
Ee.prototype.multiply = O9;
Ee.prototype.divide = L9;
Ee.prototype.remainder = k9;
Ee.prototype.divideAndRemainder = U9;
Ee.prototype.modPow = Q9;
Ee.prototype.modInverse = eC;
Ee.prototype.pow = $9;
Ee.prototype.gcd = Z9;
Ee.prototype.isProbablePrime = rC;
Ee.int2char = vc;
Ee.ZERO = vn(0);
Ee.ONE = vn(1);
Ee.prototype.square = P9;
var G0 = Ee, yu = { exports: {} }, Mh = { exports: {} }, ep = G0, la = _r(), ts = Ah, nC = {
  md2: pe.Buffer.from("3020300c06082a864886f70d020205000410", "hex"),
  md5: pe.Buffer.from("3020300c06082a864886f70d020505000410", "hex"),
  sha1: pe.Buffer.from("3021300906052b0e03021a05000414", "hex"),
  sha224: pe.Buffer.from("302d300d06096086480165030402040500041c", "hex"),
  sha256: pe.Buffer.from("3031300d060960864801650304020105000420", "hex"),
  sha384: pe.Buffer.from("3041300d060960864801650304020205000430", "hex"),
  sha512: pe.Buffer.from("3051300d060960864801650304020305000440", "hex"),
  ripemd160: pe.Buffer.from("3021300906052b2403020105000414", "hex"),
  rmd160: pe.Buffer.from("3021300906052b2403020105000414", "hex")
}, tp = {
  ripemd160: "rmd160"
}, rp = "sha256";
Mh.exports = {
  isEncryption: !0,
  isSignature: !0
};
Mh.exports.makeScheme = function(e, t) {
  function o(r, h) {
    this.key = r, this.options = h;
  }
  return o.prototype.maxMessageLength = function() {
    return this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == ts.RSA_NO_PADDING ? this.key.encryptedDataLength : this.key.encryptedDataLength - 11;
  }, o.prototype.encPad = function(r, h) {
    h = h || {};
    var a;
    if (r.length > this.key.maxMessageLength)
      throw new Error("Message too long for RSA (n=" + this.key.encryptedDataLength + ", l=" + r.length + ")");
    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == ts.RSA_NO_PADDING)
      return a = pe.Buffer.alloc(this.key.maxMessageLength - r.length), a.fill(0), pe.Buffer.concat([a, r]);
    if (h.type === 1)
      return a = pe.Buffer.alloc(this.key.encryptedDataLength - r.length - 1), a.fill(255, 0, a.length - 1), a[0] = 1, a[a.length - 1] = 0, pe.Buffer.concat([a, r]);
    a = pe.Buffer.alloc(this.key.encryptedDataLength - r.length), a[0] = 0, a[1] = 2;
    for (var p = la.randomBytes(a.length - 3), d = 0; d < p.length; d++) {
      for (var b = p[d]; b === 0; )
        b = la.randomBytes(1)[0];
      a[d + 2] = b;
    }
    return a[a.length - 1] = 0, pe.Buffer.concat([a, r]);
  }, o.prototype.encUnPad = function(r, h) {
    h = h || {};
    var a = 0;
    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == ts.RSA_NO_PADDING) {
      var p;
      return typeof r.lastIndexOf == "function" ? p = r.slice(r.lastIndexOf("\0") + 1, r.length) : p = r.slice(String.prototype.lastIndexOf.call(r, "\0") + 1, r.length), p;
    }
    if (r.length < 4)
      return null;
    if (h.type === 1) {
      if (r[0] !== 0 || r[1] !== 1)
        return null;
      for (a = 3; r[a] !== 0; )
        if (r[a] != 255 || ++a >= r.length)
          return null;
    } else {
      if (r[0] !== 0 || r[1] !== 2)
        return null;
      for (a = 3; r[a] !== 0; )
        if (++a >= r.length)
          return null;
    }
    return r.slice(a + 1, r.length);
  }, o.prototype.sign = function(r) {
    var h = this.options.signingSchemeOptions.hash || rp;
    if (this.options.environment === "browser") {
      h = tp[h] || h;
      var a = la.createHash(h);
      a.update(r);
      var p = this.pkcs1pad(a.digest(), h), d = this.key.$doPrivate(new ep(p)).toBuffer(this.key.encryptedDataLength);
      return d;
    } else {
      var b = la.createSign("RSA-" + h.toUpperCase());
      return b.update(r), b.sign(this.options.rsaUtils.exportKey("private"));
    }
  }, o.prototype.verify = function(r, h, a) {
    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == ts.RSA_NO_PADDING)
      return !1;
    var p = this.options.signingSchemeOptions.hash || rp;
    if (this.options.environment === "browser") {
      p = tp[p] || p, a && (h = pe.Buffer.from(h, a));
      var d = la.createHash(p);
      d.update(r);
      var b = this.pkcs1pad(d.digest(), p), g = this.key.$doPublic(new ep(h));
      return g.toBuffer().toString("hex") == b.toString("hex");
    } else {
      var w = la.createVerify("RSA-" + p.toUpperCase());
      return w.update(r), w.verify(this.options.rsaUtils.exportKey("public"), h, a);
    }
  }, o.prototype.pkcs0pad = function(r) {
    var h = pe.Buffer.alloc(this.key.maxMessageLength - r.length);
    return h.fill(0), pe.Buffer.concat([h, r]);
  }, o.prototype.pkcs0unpad = function(r) {
    var h;
    return typeof r.lastIndexOf == "function" ? h = r.slice(r.lastIndexOf("\0") + 1, r.length) : h = r.slice(String.prototype.lastIndexOf.call(r, "\0") + 1, r.length), h;
  }, o.prototype.pkcs1pad = function(r, h) {
    var a = nC[h];
    if (!a)
      throw Error("Unsupported hash algorithm");
    var p = pe.Buffer.concat([a, r]);
    if (p.length + 10 > this.key.encryptedDataLength)
      throw Error("Key is too short for signing algorithm (" + h + ")");
    var d = pe.Buffer.alloc(this.key.encryptedDataLength - p.length - 1);
    d.fill(255, 0, d.length - 1), d[0] = 1, d[d.length - 1] = 0;
    var b = pe.Buffer.concat([d, p]);
    return b;
  }, new o(e, t);
};
var aC = Mh.exports, Qy = { exports: {} };
(function(e) {
  var t = _r();
  e.exports = {
    isEncryption: !0,
    isSignature: !1
  }, e.exports.digestLength = {
    md4: 16,
    md5: 16,
    ripemd160: 20,
    rmd160: 20,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64
  };
  var o = "sha1";
  e.exports.eme_oaep_mgf1 = function(r, h, a) {
    a = a || o;
    for (var p = e.exports.digestLength[a], d = Math.ceil(h / p), b = pe.Buffer.alloc(p * d), g = pe.Buffer.alloc(4), w = 0; w < d; ++w) {
      var C = t.createHash(a);
      C.update(r), g.writeUInt32BE(w, 0), C.update(g), C.digest().copy(b, w * p);
    }
    return b.slice(0, h);
  }, e.exports.makeScheme = function(r, h) {
    function a(p, d) {
      this.key = p, this.options = d;
    }
    return a.prototype.maxMessageLength = function() {
      return this.key.encryptedDataLength - 2 * e.exports.digestLength[this.options.encryptionSchemeOptions.hash || o] - 2;
    }, a.prototype.encPad = function(p) {
      var d = this.options.encryptionSchemeOptions.hash || o, b = this.options.encryptionSchemeOptions.mgf || e.exports.eme_oaep_mgf1, g = this.options.encryptionSchemeOptions.label || pe.Buffer.alloc(0), w = this.key.encryptedDataLength, C = e.exports.digestLength[d];
      if (p.length > w - 2 * C - 2)
        throw new Error("Message is too long to encode into an encoded message with a length of " + w + " bytes, increaseemLen to fix this error (minimum value for given parameters and options: " + (w - 2 * C - 2) + ")");
      var T = t.createHash(d);
      T.update(g), T = T.digest();
      var k = pe.Buffer.alloc(w - p.length - 2 * C - 1);
      k.fill(0), k[k.length - 1] = 1;
      for (var q = pe.Buffer.concat([T, k, p]), O = t.randomBytes(C), N = b(O, q.length, d), j = 0; j < q.length; j++)
        q[j] ^= N[j];
      for (N = b(q, C, d), j = 0; j < O.length; j++)
        O[j] ^= N[j];
      var U = pe.Buffer.alloc(1 + O.length + q.length);
      return U[0] = 0, O.copy(U, 1), q.copy(U, 1 + O.length), U;
    }, a.prototype.encUnPad = function(p) {
      var d = this.options.encryptionSchemeOptions.hash || o, b = this.options.encryptionSchemeOptions.mgf || e.exports.eme_oaep_mgf1, g = this.options.encryptionSchemeOptions.label || pe.Buffer.alloc(0), w = e.exports.digestLength[d];
      if (p.length < 2 * w + 2)
        throw new Error("Error decoding message, the supplied message is not long enough to be a valid OAEP encoded message");
      for (var C = p.slice(1, w + 1), T = p.slice(1 + w), k = b(T, w, d), q = 0; q < C.length; q++)
        C[q] ^= k[q];
      for (k = b(C, T.length, d), q = 0; q < T.length; q++)
        T[q] ^= k[q];
      var O = t.createHash(d);
      O.update(g), O = O.digest();
      var N = T.slice(0, w);
      if (N.toString("hex") != O.toString("hex"))
        throw new Error("Error decoding message, the lHash calculated from the label provided and the lHash in the encrypted data do not match.");
      for (q = w; T[q++] === 0 && q < T.length; )
        ;
      if (T[q - 1] != 1)
        throw new Error("Error decoding message, there is no padding message separator byte");
      return T.slice(q);
    }, new a(r, h);
  };
})(Qy);
var sC = Qy.exports, rs = { exports: {} }, ip;
function fC() {
  if (ip)
    return rs.exports;
  ip = 1;
  var e = G0, t = _r();
  rs.exports = {
    isEncryption: !1,
    isSignature: !0
  };
  var o = "sha1", r = 20;
  return rs.exports.makeScheme = function(h, a) {
    var p = Za().pkcs1_oaep;
    function d(b, g) {
      this.key = b, this.options = g;
    }
    return d.prototype.sign = function(b) {
      var g = t.createHash(this.options.signingSchemeOptions.hash || o);
      g.update(b);
      var w = this.emsa_pss_encode(g.digest(), this.key.keySize - 1);
      return this.key.$doPrivate(new e(w)).toBuffer(this.key.encryptedDataLength);
    }, d.prototype.verify = function(b, g, w) {
      w && (g = pe.Buffer.from(g, w)), g = new e(g);
      var C = Math.ceil((this.key.keySize - 1) / 8), T = this.key.$doPublic(g).toBuffer(C), k = t.createHash(this.options.signingSchemeOptions.hash || o);
      return k.update(b), this.emsa_pss_verify(k.digest(), T, this.key.keySize - 1);
    }, d.prototype.emsa_pss_encode = function(b, g) {
      var w = this.options.signingSchemeOptions.hash || o, C = this.options.signingSchemeOptions.mgf || p.eme_oaep_mgf1, T = this.options.signingSchemeOptions.saltLength || r, k = p.digestLength[w], q = Math.ceil(g / 8);
      if (q < k + T + 2)
        throw new Error(
          "Output length passed to emBits(" + g + ") is too small for the options specified(" + w + ", " + T + "). To fix this issue increase the value of emBits. (minimum size: " + (8 * k + 8 * T + 9) + ")"
        );
      var O = t.randomBytes(T), N = pe.Buffer.alloc(8 + k + T);
      N.fill(0, 0, 8), b.copy(N, 8), O.copy(N, 8 + b.length);
      var j = t.createHash(w);
      j.update(N), j = j.digest();
      var U = pe.Buffer.alloc(q - O.length - k - 2);
      U.fill(0);
      var H = pe.Buffer.alloc(U.length + 1 + O.length);
      U.copy(H), H[U.length] = 1, O.copy(H, U.length + 1);
      for (var z = C(j, H.length, w), ee = pe.Buffer.alloc(H.length), ne = 0; ne < z.length; ne++)
        ee[ne] = H[ne] ^ z[ne];
      var le = 8 * q - g, Z = 255 ^ 255 >> 8 - le << 8 - le;
      ee[0] = ee[0] & Z;
      var ie = pe.Buffer.alloc(ee.length + j.length + 1);
      return ee.copy(ie, 0), j.copy(ie, ee.length), ie[ie.length - 1] = 188, ie;
    }, d.prototype.emsa_pss_verify = function(b, g, w) {
      var C = this.options.signingSchemeOptions.hash || o, T = this.options.signingSchemeOptions.mgf || p.eme_oaep_mgf1, k = this.options.signingSchemeOptions.saltLength || r, q = p.digestLength[C], O = Math.ceil(w / 8);
      if (O < q + k + 2 || g[g.length - 1] != 188)
        return !1;
      var N = pe.Buffer.alloc(O - q - 1);
      g.copy(N, 0, 0, O - q - 1);
      for (var j = 0, U = 0, H = 8 * O - w; U < H; U++)
        j |= 1 << 7 - U;
      if (N[0] & j)
        return !1;
      var z = g.slice(O - q - 1, O - 1), ee = T(z, N.length, C);
      for (U = 0; U < N.length; U++)
        N[U] ^= ee[U];
      for (H = 8 * O - w, j = 255 ^ 255 >> 8 - H << 8 - H, N[0] = N[0] & j, U = 0; N[U] === 0 && U < N.length; U++)
        ;
      if (N[U] != 1)
        return !1;
      var ne = N.slice(N.length - k), le = pe.Buffer.alloc(8 + q + k);
      le.fill(0, 0, 8), b.copy(le, 8), ne.copy(le, 8 + b.length);
      var Z = t.createHash(C);
      return Z.update(le), Z = Z.digest(), z.toString("hex") === Z.toString("hex");
    }, new d(h, a);
  }, rs.exports;
}
var np;
function Za() {
  return np || (np = 1, function(e) {
    e.exports = {
      pkcs1: aC,
      pkcs1_oaep: sC,
      pss: fC(),
      /**
       * Check if scheme has padding methods
       * @param scheme {string}
       * @returns {Boolean}
       */
      isEncryption: function(t) {
        return e.exports[t] && e.exports[t].isEncryption;
      },
      /**
       * Check if scheme has sign/verify methods
       * @param scheme {string}
       * @returns {Boolean}
       */
      isSignature: function(t) {
        return e.exports[t] && e.exports[t].isSignature;
      }
    };
  }(yu)), yu.exports;
}
var gu, ap;
function Zy() {
  if (ap)
    return gu;
  ap = 1;
  var e = G0, t = Za();
  return gu = function(o, r) {
    var h = t.pkcs1.makeScheme(o, r);
    return {
      encrypt: function(a, p) {
        var d, b;
        return p ? (d = new e(h.encPad(a, { type: 1 })), b = o.$doPrivate(d)) : (d = new e(o.encryptionScheme.encPad(a)), b = o.$doPublic(d)), b.toBuffer(o.encryptedDataLength);
      },
      decrypt: function(a, p) {
        var d, b = new e(a);
        return p ? (d = o.$doPublic(b), h.encUnPad(d.toBuffer(o.encryptedDataLength), { type: 1 })) : (d = o.$doPrivate(b), o.encryptionScheme.encUnPad(d.toBuffer(o.encryptedDataLength)));
      }
    };
  }, gu;
}
var mu, sp;
function oC() {
  if (sp)
    return mu;
  sp = 1;
  var e = _r(), t = Ah, o = Za();
  return mu = function(r, h) {
    var a = o.pkcs1.makeScheme(r, h);
    return {
      encrypt: function(p, d) {
        var b;
        if (d)
          return b = t.RSA_PKCS1_PADDING, h.encryptionSchemeOptions && h.encryptionSchemeOptions.padding && (b = h.encryptionSchemeOptions.padding), e.privateEncrypt({
            key: h.rsaUtils.exportKey("private"),
            padding: b
          }, p);
        b = t.RSA_PKCS1_OAEP_PADDING, h.encryptionScheme === "pkcs1" && (b = t.RSA_PKCS1_PADDING), h.encryptionSchemeOptions && h.encryptionSchemeOptions.padding && (b = h.encryptionSchemeOptions.padding);
        var g = p;
        return b === t.RSA_NO_PADDING && (g = a.pkcs0pad(p)), e.publicEncrypt({
          key: h.rsaUtils.exportKey("public"),
          padding: b
        }, g);
      },
      decrypt: function(p, d) {
        var b;
        if (d)
          return b = t.RSA_PKCS1_PADDING, h.encryptionSchemeOptions && h.encryptionSchemeOptions.padding && (b = h.encryptionSchemeOptions.padding), e.publicDecrypt({
            key: h.rsaUtils.exportKey("public"),
            padding: b
          }, p);
        b = t.RSA_PKCS1_OAEP_PADDING, h.encryptionScheme === "pkcs1" && (b = t.RSA_PKCS1_PADDING), h.encryptionSchemeOptions && h.encryptionSchemeOptions.padding && (b = h.encryptionSchemeOptions.padding);
        var g = e.privateDecrypt({
          key: h.rsaUtils.exportKey("private"),
          padding: b
        }, p);
        return b === t.RSA_NO_PADDING ? a.pkcs0unpad(g) : g;
      }
    };
  }, mu;
}
var bu, fp;
function uC() {
  if (fp)
    return bu;
  fp = 1;
  var e = _r(), t = Ah, o = Za();
  return bu = function(r, h) {
    var a = Zy()(r, h), p = o.pkcs1.makeScheme(r, h);
    return {
      encrypt: function(d, b) {
        if (b)
          return a.encrypt(d, b);
        var g = t.RSA_PKCS1_OAEP_PADDING;
        h.encryptionScheme === "pkcs1" && (g = t.RSA_PKCS1_PADDING), h.encryptionSchemeOptions && h.encryptionSchemeOptions.padding && (g = h.encryptionSchemeOptions.padding);
        var w = d;
        return g === t.RSA_NO_PADDING && (w = p.pkcs0pad(d)), e.publicEncrypt({
          key: h.rsaUtils.exportKey("public"),
          padding: g
        }, w);
      },
      decrypt: function(d, b) {
        if (b)
          return a.decrypt(d, b);
        var g = t.RSA_PKCS1_OAEP_PADDING;
        h.encryptionScheme === "pkcs1" && (g = t.RSA_PKCS1_PADDING), h.encryptionSchemeOptions && h.encryptionSchemeOptions.padding && (g = h.encryptionSchemeOptions.padding);
        var w = e.privateDecrypt({
          key: h.rsaUtils.exportKey("private"),
          padding: g
        }, d);
        return g === t.RSA_NO_PADDING ? p.pkcs0unpad(w) : w;
      }
    };
  }, bu;
}
var is = _r(), cC = {
  getEngine: function(e, t) {
    var o = Zy();
    return t.environment === "node" && typeof is.publicEncrypt == "function" && typeof is.privateDecrypt == "function" && (typeof is.privateEncrypt == "function" && typeof is.publicDecrypt == "function" ? o = oC() : o = uC()), o(e, t);
  }
}, ns = tr._;
_r();
var zt = G0, op = tr, up = Za(), hC = cC;
Bh.BigInteger = zt;
Bh.Key = function() {
  function e() {
    this.n = null, this.e = 0, this.d = null, this.p = null, this.q = null, this.dmp1 = null, this.dmq1 = null, this.coeff = null;
  }
  return e.prototype.setOptions = function(t) {
    var o = up[t.signingScheme], r = up[t.encryptionScheme];
    o === r ? this.signingScheme = this.encryptionScheme = r.makeScheme(this, t) : (this.encryptionScheme = r.makeScheme(this, t), this.signingScheme = o.makeScheme(this, t)), this.encryptEngine = hC.getEngine(this, t);
  }, e.prototype.generate = function(t, o) {
    var r = t >> 1;
    this.e = parseInt(o, 16);
    for (var h = new zt(o, 16); ; ) {
      for (; this.p = new zt(t - r, 1), !(this.p.subtract(zt.ONE).gcd(h).compareTo(zt.ONE) === 0 && this.p.isProbablePrime(10)); )
        ;
      for (; this.q = new zt(r, 1), !(this.q.subtract(zt.ONE).gcd(h).compareTo(zt.ONE) === 0 && this.q.isProbablePrime(10)); )
        ;
      if (this.p.compareTo(this.q) <= 0) {
        var a = this.p;
        this.p = this.q, this.q = a;
      }
      var p = this.p.subtract(zt.ONE), d = this.q.subtract(zt.ONE), b = p.multiply(d);
      if (b.gcd(h).compareTo(zt.ONE) === 0) {
        if (this.n = this.p.multiply(this.q), this.n.bitLength() < t)
          continue;
        this.d = h.modInverse(b), this.dmp1 = this.d.mod(p), this.dmq1 = this.d.mod(d), this.coeff = this.q.modInverse(this.p);
        break;
      }
    }
    this.$$recalculateCache();
  }, e.prototype.setPrivate = function(t, o, r, h, a, p, d, b) {
    if (t && o && r && t.length > 0 && (ns.isNumber(o) || o.length > 0) && r.length > 0)
      this.n = new zt(t), this.e = ns.isNumber(o) ? o : op.get32IntFromBuffer(o, 0), this.d = new zt(r), h && a && p && d && b && (this.p = new zt(h), this.q = new zt(a), this.dmp1 = new zt(p), this.dmq1 = new zt(d), this.coeff = new zt(b)), this.$$recalculateCache();
    else
      throw Error("Invalid RSA private key");
  }, e.prototype.setPublic = function(t, o) {
    if (t && o && t.length > 0 && (ns.isNumber(o) || o.length > 0))
      this.n = new zt(t), this.e = ns.isNumber(o) ? o : op.get32IntFromBuffer(o, 0), this.$$recalculateCache();
    else
      throw Error("Invalid RSA public key");
  }, e.prototype.$doPrivate = function(t) {
    if (this.p || this.q)
      return t.modPow(this.d, this.n);
    for (var o = t.mod(this.p).modPow(this.dmp1, this.p), r = t.mod(this.q).modPow(this.dmq1, this.q); o.compareTo(r) < 0; )
      o = o.add(this.p);
    return o.subtract(r).multiply(this.coeff).mod(this.p).multiply(this.q).add(r);
  }, e.prototype.$doPublic = function(t) {
    return t.modPowInt(this.e, this.n);
  }, e.prototype.encrypt = function(t, o) {
    var r = [], h = [], a = t.length, p = Math.ceil(a / this.maxMessageLength) || 1, d = Math.ceil(a / p || 1);
    if (p == 1)
      r.push(t);
    else
      for (var b = 0; b < p; b++)
        r.push(t.slice(b * d, (b + 1) * d));
    for (var g = 0; g < r.length; g++)
      h.push(this.encryptEngine.encrypt(r[g], o));
    return pe.Buffer.concat(h);
  }, e.prototype.decrypt = function(t, o) {
    if (t.length % this.encryptedDataLength > 0)
      throw Error("Incorrect data or key");
    for (var r = [], h = 0, a = 0, p = t.length / this.encryptedDataLength, d = 0; d < p; d++)
      h = d * this.encryptedDataLength, a = h + this.encryptedDataLength, r.push(this.encryptEngine.decrypt(t.slice(h, Math.min(a, t.length)), o));
    return pe.Buffer.concat(r);
  }, e.prototype.sign = function(t) {
    return this.signingScheme.sign.apply(this.signingScheme, arguments);
  }, e.prototype.verify = function(t, o, r) {
    return this.signingScheme.verify.apply(this.signingScheme, arguments);
  }, e.prototype.isPrivate = function() {
    return this.n && this.e && this.d && !0 || !1;
  }, e.prototype.isPublic = function(t) {
    return this.n && this.e && !(t && this.d) || !1;
  }, Object.defineProperty(e.prototype, "keySize", {
    get: function() {
      return this.cache.keyBitLength;
    }
  }), Object.defineProperty(e.prototype, "encryptedDataLength", {
    get: function() {
      return this.cache.keyByteLength;
    }
  }), Object.defineProperty(e.prototype, "maxMessageLength", {
    get: function() {
      return this.encryptionScheme.maxMessageLength();
    }
  }), e.prototype.$$recalculateCache = function() {
    this.cache = this.cache || {}, this.cache.keyBitLength = this.n.bitLength(), this.cache.keyByteLength = this.cache.keyBitLength + 6 >> 3;
  }, e;
}();
var Jy = { exports: {} }, Rh = {
  newInvalidAsn1Error: function(e) {
    var t = new Error();
    return t.name = "InvalidAsn1Error", t.message = e || "", t;
  }
}, Nh = {
  EOC: 0,
  Boolean: 1,
  Integer: 2,
  BitString: 3,
  OctetString: 4,
  Null: 5,
  OID: 6,
  ObjectDescriptor: 7,
  External: 8,
  Real: 9,
  // float
  Enumeration: 10,
  PDV: 11,
  Utf8String: 12,
  RelativeOID: 13,
  Sequence: 16,
  Set: 17,
  NumericString: 18,
  PrintableString: 19,
  T61String: 20,
  VideotexString: 21,
  IA5String: 22,
  UTCTime: 23,
  GeneralizedTime: 24,
  GraphicString: 25,
  VisibleString: 26,
  GeneralString: 28,
  UniversalString: 29,
  CharacterString: 30,
  BMPString: 31,
  Constructor: 32,
  Context: 128
}, xu = { exports: {} }, _u = {}, cp;
function e2() {
  if (cp)
    return _u;
  cp = 1;
  function e(O) {
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? e = function(N) {
      return typeof N;
    } : e = function(N) {
      return N && typeof Symbol == "function" && N.constructor === Symbol && N !== Symbol.prototype ? "symbol" : typeof N;
    }, e(O);
  }
  function t(O, N) {
    if (!(O instanceof N))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(O, N) {
    return N && (e(N) === "object" || typeof N == "function") ? N : r(O);
  }
  function r(O) {
    if (O === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return O;
  }
  function h(O) {
    return h = Object.setPrototypeOf ? Object.getPrototypeOf : function(N) {
      return N.__proto__ || Object.getPrototypeOf(N);
    }, h(O);
  }
  function a(O, N) {
    if (typeof N != "function" && N !== null)
      throw new TypeError("Super expression must either be null or a function");
    O.prototype = Object.create(N && N.prototype, { constructor: { value: O, writable: !0, configurable: !0 } }), N && p(O, N);
  }
  function p(O, N) {
    return p = Object.setPrototypeOf || function(j, U) {
      return j.__proto__ = U, j;
    }, p(O, N);
  }
  var d = {}, b, g;
  function w(O, N, j) {
    j || (j = Error);
    function U(z, ee, ne) {
      return typeof N == "string" ? N : N(z, ee, ne);
    }
    var H = /* @__PURE__ */ function(z) {
      a(ee, z);
      function ee(ne, le, Z) {
        var ie;
        return t(this, ee), ie = o(this, h(ee).call(this, U(ne, le, Z))), ie.code = O, ie;
      }
      return ee;
    }(j);
    d[O] = H;
  }
  function C(O, N) {
    if (Array.isArray(O)) {
      var j = O.length;
      return O = O.map(function(U) {
        return String(U);
      }), j > 2 ? "one of ".concat(N, " ").concat(O.slice(0, j - 1).join(", "), ", or ") + O[j - 1] : j === 2 ? "one of ".concat(N, " ").concat(O[0], " or ").concat(O[1]) : "of ".concat(N, " ").concat(O[0]);
    } else
      return "of ".concat(N, " ").concat(String(O));
  }
  function T(O, N, j) {
    return O.substr(!j || j < 0 ? 0 : +j, N.length) === N;
  }
  function k(O, N, j) {
    return (j === void 0 || j > O.length) && (j = O.length), O.substring(j - N.length, j) === N;
  }
  function q(O, N, j) {
    return typeof j != "number" && (j = 0), j + N.length > O.length ? !1 : O.indexOf(N, j) !== -1;
  }
  return w("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), w("ERR_INVALID_ARG_TYPE", function(O, N, j) {
    b === void 0 && (b = Os()), b(typeof O == "string", "'name' must be a string");
    var U;
    typeof N == "string" && T(N, "not ") ? (U = "must not be", N = N.replace(/^not /, "")) : U = "must be";
    var H;
    if (k(O, " argument"))
      H = "The ".concat(O, " ").concat(U, " ").concat(C(N, "type"));
    else {
      var z = q(O, ".") ? "property" : "argument";
      H = 'The "'.concat(O, '" ').concat(z, " ").concat(U, " ").concat(C(N, "type"));
    }
    return H += ". Received type ".concat(e(j)), H;
  }, TypeError), w("ERR_INVALID_ARG_VALUE", function(O, N) {
    var j = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
    g === void 0 && (g = wn);
    var U = g.inspect(N);
    return U.length > 128 && (U = "".concat(U.slice(0, 128), "...")), "The argument '".concat(O, "' ").concat(j, ". Received ").concat(U);
  }, TypeError), w("ERR_INVALID_RETURN_VALUE", function(O, N, j) {
    var U;
    return j && j.constructor && j.constructor.name ? U = "instance of ".concat(j.constructor.name) : U = "type ".concat(e(j)), "Expected ".concat(O, ' to be returned from the "').concat(N, '"') + " function but got ".concat(U, ".");
  }, TypeError), w("ERR_MISSING_ARGS", function() {
    for (var O = arguments.length, N = new Array(O), j = 0; j < O; j++)
      N[j] = arguments[j];
    b === void 0 && (b = Os()), b(N.length > 0, "At least one arg needs to be specified");
    var U = "The ", H = N.length;
    switch (N = N.map(function(z) {
      return '"'.concat(z, '"');
    }), H) {
      case 1:
        U += "".concat(N[0], " argument");
        break;
      case 2:
        U += "".concat(N[0], " and ").concat(N[1], " arguments");
        break;
      default:
        U += N.slice(0, H - 1).join(", "), U += ", and ".concat(N[H - 1], " arguments");
        break;
    }
    return "".concat(U, " must be specified");
  }, TypeError), _u.codes = d, _u;
}
var Eu, hp;
function lC() {
  if (hp)
    return Eu;
  hp = 1;
  function e(v) {
    for (var M = 1; M < arguments.length; M++) {
      var B = arguments[M] != null ? arguments[M] : {}, S = Object.keys(B);
      typeof Object.getOwnPropertySymbols == "function" && (S = S.concat(Object.getOwnPropertySymbols(B).filter(function(_) {
        return Object.getOwnPropertyDescriptor(B, _).enumerable;
      }))), S.forEach(function(_) {
        t(v, _, B[_]);
      });
    }
    return v;
  }
  function t(v, M, B) {
    return M in v ? Object.defineProperty(v, M, { value: B, enumerable: !0, configurable: !0, writable: !0 }) : v[M] = B, v;
  }
  function o(v, M) {
    if (!(v instanceof M))
      throw new TypeError("Cannot call a class as a function");
  }
  function r(v, M) {
    for (var B = 0; B < M.length; B++) {
      var S = M[B];
      S.enumerable = S.enumerable || !1, S.configurable = !0, "value" in S && (S.writable = !0), Object.defineProperty(v, S.key, S);
    }
  }
  function h(v, M, B) {
    return M && r(v.prototype, M), B && r(v, B), v;
  }
  function a(v, M) {
    return M && (q(M) === "object" || typeof M == "function") ? M : p(v);
  }
  function p(v) {
    if (v === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return v;
  }
  function d(v, M) {
    if (typeof M != "function" && M !== null)
      throw new TypeError("Super expression must either be null or a function");
    v.prototype = Object.create(M && M.prototype, { constructor: { value: v, writable: !0, configurable: !0 } }), M && T(v, M);
  }
  function b(v) {
    var M = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return b = function(B) {
      if (B === null || !C(B))
        return B;
      if (typeof B != "function")
        throw new TypeError("Super expression must either be null or a function");
      if (typeof M < "u") {
        if (M.has(B))
          return M.get(B);
        M.set(B, S);
      }
      function S() {
        return w(B, arguments, k(this).constructor);
      }
      return S.prototype = Object.create(B.prototype, { constructor: { value: S, enumerable: !1, writable: !0, configurable: !0 } }), T(S, B);
    }, b(v);
  }
  function g() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function w(v, M, B) {
    return g() ? w = Reflect.construct : w = function(S, _, E) {
      var m = [null];
      m.push.apply(m, _);
      var A = Function.bind.apply(S, m), $ = new A();
      return E && T($, E.prototype), $;
    }, w.apply(null, arguments);
  }
  function C(v) {
    return Function.toString.call(v).indexOf("[native code]") !== -1;
  }
  function T(v, M) {
    return T = Object.setPrototypeOf || function(B, S) {
      return B.__proto__ = S, B;
    }, T(v, M);
  }
  function k(v) {
    return k = Object.setPrototypeOf ? Object.getPrototypeOf : function(M) {
      return M.__proto__ || Object.getPrototypeOf(M);
    }, k(v);
  }
  function q(v) {
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? q = function(M) {
      return typeof M;
    } : q = function(M) {
      return M && typeof Symbol == "function" && M.constructor === Symbol && M !== Symbol.prototype ? "symbol" : typeof M;
    }, q(v);
  }
  var O = wn, N = O.inspect, j = e2(), U = j.codes.ERR_INVALID_ARG_TYPE;
  function H(v, M, B) {
    return (B === void 0 || B > v.length) && (B = v.length), v.substring(B - M.length, B) === M;
  }
  function z(v, M) {
    if (M = Math.floor(M), v.length == 0 || M == 0)
      return "";
    var B = v.length * M;
    for (M = Math.floor(Math.log(M) / Math.log(2)); M; )
      v += v, M--;
    return v += v.substring(0, B - v.length), v;
  }
  var ee = "", ne = "", le = "", Z = "", ie = {
    deepStrictEqual: "Expected values to be strictly deep-equal:",
    strictEqual: "Expected values to be strictly equal:",
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: "Expected values to be loosely deep-equal:",
    equal: "Expected values to be loosely equal:",
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notEqual: 'Expected "actual" to be loosely unequal to:',
    notIdentical: "Values identical but not reference-equal:"
  }, fe = 10;
  function I(v) {
    var M = Object.keys(v), B = Object.create(Object.getPrototypeOf(v));
    return M.forEach(function(S) {
      B[S] = v[S];
    }), Object.defineProperty(B, "message", {
      value: v.message
    }), B;
  }
  function P(v) {
    return N(v, {
      compact: !1,
      customInspect: !1,
      depth: 1e3,
      maxArrayLength: 1 / 0,
      // Assert compares only enumerable properties (with a few exceptions).
      showHidden: !1,
      // Having a long line as error is better than wrapping the line for
      // comparison for now.
      // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
      // have meta information about the inspected properties (i.e., know where
      // in what line the property starts and ends).
      breakLength: 1 / 0,
      // Assert does not detect proxies currently.
      showProxy: !1,
      sorted: !0,
      // Inspect getters as we also check them when comparing entries.
      getters: !0
    });
  }
  function f(v, M, B) {
    var S = "", _ = "", E = 0, m = "", A = !1, $ = P(v), X = $.split(`
`), oe = P(M).split(`
`), J = 0, W = "";
    if (B === "strictEqual" && q(v) === "object" && q(M) === "object" && v !== null && M !== null && (B = "strictEqualObject"), X.length === 1 && oe.length === 1 && X[0] !== oe[0]) {
      var Q = X[0].length + oe[0].length;
      if (Q <= fe) {
        if ((q(v) !== "object" || v === null) && (q(M) !== "object" || M === null) && (v !== 0 || M !== 0))
          return "".concat(ie[B], `

`) + "".concat(X[0], " !== ").concat(oe[0], `
`);
      } else if (B !== "strictEqualObject") {
        var me = Ve.stderr && Ve.stderr.isTTY ? Ve.stderr.columns : 80;
        if (Q < me) {
          for (; X[0][J] === oe[0][J]; )
            J++;
          J > 2 && (W = `
  `.concat(z(" ", J), "^"), J = 0);
        }
      }
    }
    for (var be = X[X.length - 1], Y = oe[oe.length - 1]; be === Y && (J++ < 2 ? m = `
  `.concat(be).concat(m) : S = be, X.pop(), oe.pop(), !(X.length === 0 || oe.length === 0)); )
      be = X[X.length - 1], Y = oe[oe.length - 1];
    var re = Math.max(X.length, oe.length);
    if (re === 0) {
      var de = $.split(`
`);
      if (de.length > 30)
        for (de[26] = "".concat(ee, "...").concat(Z); de.length > 27; )
          de.pop();
      return "".concat(ie.notIdentical, `

`).concat(de.join(`
`), `
`);
    }
    J > 3 && (m = `
`.concat(ee, "...").concat(Z).concat(m), A = !0), S !== "" && (m = `
  `.concat(S).concat(m), S = "");
    var Ae = 0, qe = ie[B] + `
`.concat(ne, "+ actual").concat(Z, " ").concat(le, "- expected").concat(Z), x = " ".concat(ee, "...").concat(Z, " Lines skipped");
    for (J = 0; J < re; J++) {
      var L = J - E;
      if (X.length < J + 1)
        L > 1 && J > 2 && (L > 4 ? (_ += `
`.concat(ee, "...").concat(Z), A = !0) : L > 3 && (_ += `
  `.concat(oe[J - 2]), Ae++), _ += `
  `.concat(oe[J - 1]), Ae++), E = J, S += `
`.concat(le, "-").concat(Z, " ").concat(oe[J]), Ae++;
      else if (oe.length < J + 1)
        L > 1 && J > 2 && (L > 4 ? (_ += `
`.concat(ee, "...").concat(Z), A = !0) : L > 3 && (_ += `
  `.concat(X[J - 2]), Ae++), _ += `
  `.concat(X[J - 1]), Ae++), E = J, _ += `
`.concat(ne, "+").concat(Z, " ").concat(X[J]), Ae++;
      else {
        var D = oe[J], F = X[J], ue = F !== D && (!H(F, ",") || F.slice(0, -1) !== D);
        ue && H(D, ",") && D.slice(0, -1) === F && (ue = !1, F += ","), ue ? (L > 1 && J > 2 && (L > 4 ? (_ += `
`.concat(ee, "...").concat(Z), A = !0) : L > 3 && (_ += `
  `.concat(X[J - 2]), Ae++), _ += `
  `.concat(X[J - 1]), Ae++), E = J, _ += `
`.concat(ne, "+").concat(Z, " ").concat(F), S += `
`.concat(le, "-").concat(Z, " ").concat(D), Ae += 2) : (_ += S, S = "", (L === 1 || J === 0) && (_ += `
  `.concat(F), Ae++));
      }
      if (Ae > 20 && J < re - 2)
        return "".concat(qe).concat(x, `
`).concat(_, `
`).concat(ee, "...").concat(Z).concat(S, `
`) + "".concat(ee, "...").concat(Z);
    }
    return "".concat(qe).concat(A ? x : "", `
`).concat(_).concat(S).concat(m).concat(W);
  }
  var y = /* @__PURE__ */ function(v) {
    d(M, v);
    function M(B) {
      var S;
      if (o(this, M), q(B) !== "object" || B === null)
        throw new U("options", "Object", B);
      var _ = B.message, E = B.operator, m = B.stackStartFn, A = B.actual, $ = B.expected, X = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, _ != null)
        S = a(this, k(M).call(this, String(_)));
      else if (Ve.stderr && Ve.stderr.isTTY && (Ve.stderr && Ve.stderr.getColorDepth && Ve.stderr.getColorDepth() !== 1 ? (ee = "\x1B[34m", ne = "\x1B[32m", Z = "\x1B[39m", le = "\x1B[31m") : (ee = "", ne = "", Z = "", le = "")), q(A) === "object" && A !== null && q($) === "object" && $ !== null && "stack" in A && A instanceof Error && "stack" in $ && $ instanceof Error && (A = I(A), $ = I($)), E === "deepStrictEqual" || E === "strictEqual")
        S = a(this, k(M).call(this, f(A, $, E)));
      else if (E === "notDeepStrictEqual" || E === "notStrictEqual") {
        var oe = ie[E], J = P(A).split(`
`);
        if (E === "notStrictEqual" && q(A) === "object" && A !== null && (oe = ie.notStrictEqualObject), J.length > 30)
          for (J[26] = "".concat(ee, "...").concat(Z); J.length > 27; )
            J.pop();
        J.length === 1 ? S = a(this, k(M).call(this, "".concat(oe, " ").concat(J[0]))) : S = a(this, k(M).call(this, "".concat(oe, `

`).concat(J.join(`
`), `
`)));
      } else {
        var W = P(A), Q = "", me = ie[E];
        E === "notDeepEqual" || E === "notEqual" ? (W = "".concat(ie[E], `

`).concat(W), W.length > 1024 && (W = "".concat(W.slice(0, 1021), "..."))) : (Q = "".concat(P($)), W.length > 512 && (W = "".concat(W.slice(0, 509), "...")), Q.length > 512 && (Q = "".concat(Q.slice(0, 509), "...")), E === "deepEqual" || E === "equal" ? W = "".concat(me, `

`).concat(W, `

should equal

`) : Q = " ".concat(E, " ").concat(Q)), S = a(this, k(M).call(this, "".concat(W).concat(Q)));
      }
      return Error.stackTraceLimit = X, S.generatedMessage = !_, Object.defineProperty(p(S), "name", {
        value: "AssertionError [ERR_ASSERTION]",
        enumerable: !1,
        writable: !0,
        configurable: !0
      }), S.code = "ERR_ASSERTION", S.actual = A, S.expected = $, S.operator = E, Error.captureStackTrace && Error.captureStackTrace(p(S), m), S.stack, S.name = "AssertionError", a(S);
    }
    return h(M, [{
      key: "toString",
      value: function() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      }
    }, {
      key: N.custom,
      value: function(B, S) {
        return N(this, e({}, S, {
          customInspect: !1,
          depth: 0
        }));
      }
    }]), M;
  }(b(Error));
  return Eu = y, Eu;
}
var Su, lp;
function dC() {
  if (lp)
    return Su;
  lp = 1;
  function e(o, r) {
    if (o == null)
      throw new TypeError("Cannot convert first argument to object");
    for (var h = Object(o), a = 1; a < arguments.length; a++) {
      var p = arguments[a];
      if (p != null)
        for (var d = Object.keys(Object(p)), b = 0, g = d.length; b < g; b++) {
          var w = d[b], C = Object.getOwnPropertyDescriptor(p, w);
          C !== void 0 && C.enumerable && (h[w] = p[w]);
        }
    }
    return h;
  }
  function t() {
    Object.assign || Object.defineProperty(Object, "assign", {
      enumerable: !1,
      configurable: !0,
      writable: !0,
      value: e
    });
  }
  return Su = {
    assign: e,
    polyfill: t
  }, Su;
}
var wu, dp;
function t2() {
  if (dp)
    return wu;
  dp = 1;
  var e = Object.prototype.toString;
  return wu = function(t) {
    var o = e.call(t), r = o === "[object Arguments]";
    return r || (r = o !== "[object Array]" && t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && e.call(t.callee) === "[object Function]"), r;
  }, wu;
}
var Cu, pp;
function pC() {
  if (pp)
    return Cu;
  pp = 1;
  var e;
  if (!Object.keys) {
    var t = Object.prototype.hasOwnProperty, o = Object.prototype.toString, r = t2(), h = Object.prototype.propertyIsEnumerable, a = !h.call({ toString: null }, "toString"), p = h.call(function() {
    }, "prototype"), d = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], b = function(T) {
      var k = T.constructor;
      return k && k.prototype === T;
    }, g = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, w = function() {
      if (typeof window > "u")
        return !1;
      for (var T in window)
        try {
          if (!g["$" + T] && t.call(window, T) && window[T] !== null && typeof window[T] == "object")
            try {
              b(window[T]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), C = function(T) {
      if (typeof window > "u" || !w)
        return b(T);
      try {
        return b(T);
      } catch {
        return !1;
      }
    };
    e = function(T) {
      var k = T !== null && typeof T == "object", q = o.call(T) === "[object Function]", O = r(T), N = k && o.call(T) === "[object String]", j = [];
      if (!k && !q && !O)
        throw new TypeError("Object.keys called on a non-object");
      var U = p && q;
      if (N && T.length > 0 && !t.call(T, 0))
        for (var H = 0; H < T.length; ++H)
          j.push(String(H));
      if (O && T.length > 0)
        for (var z = 0; z < T.length; ++z)
          j.push(String(z));
      else
        for (var ee in T)
          !(U && ee === "prototype") && t.call(T, ee) && j.push(String(ee));
      if (a)
        for (var ne = C(T), le = 0; le < d.length; ++le)
          !(ne && d[le] === "constructor") && t.call(T, d[le]) && j.push(d[le]);
      return j;
    };
  }
  return Cu = e, Cu;
}
var Au, vp;
function vC() {
  if (vp)
    return Au;
  vp = 1;
  var e = Array.prototype.slice, t = t2(), o = Object.keys, r = o ? function(a) {
    return o(a);
  } : pC(), h = Object.keys;
  return r.shim = function() {
    if (Object.keys) {
      var a = function() {
        var p = Object.keys(arguments);
        return p && p.length === arguments.length;
      }(1, 2);
      a || (Object.keys = function(p) {
        return t(p) ? h(e.call(p)) : h(p);
      });
    } else
      Object.keys = r;
    return Object.keys || r;
  }, Au = r, Au;
}
var Bu, yp;
function yC() {
  if (yp)
    return Bu;
  yp = 1;
  var e = Ws(), t = e("%Object.defineProperty%", !0), o = function() {
    if (t)
      try {
        return t({}, "a", { value: 1 }), !0;
      } catch {
        return !1;
      }
    return !1;
  };
  return o.hasArrayLengthDefineBug = function() {
    if (!o())
      return null;
    try {
      return t([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, Bu = o, Bu;
}
var Iu, gp;
function Rf() {
  if (gp)
    return Iu;
  gp = 1;
  var e = vC(), t = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", o = Object.prototype.toString, r = Array.prototype.concat, h = Object.defineProperty, a = function(w) {
    return typeof w == "function" && o.call(w) === "[object Function]";
  }, p = yC()(), d = h && p, b = function(w, C, T, k) {
    if (C in w) {
      if (k === !0) {
        if (w[C] === T)
          return;
      } else if (!a(k) || !k())
        return;
    }
    d ? h(w, C, {
      configurable: !0,
      enumerable: !1,
      value: T,
      writable: !0
    }) : w[C] = T;
  }, g = function(w, C) {
    var T = arguments.length > 2 ? arguments[2] : {}, k = e(C);
    t && (k = r.call(k, Object.getOwnPropertySymbols(C)));
    for (var q = 0; q < k.length; q += 1)
      b(w, k[q], C[k[q]], T[k[q]]);
  };
  return g.supportsDescriptors = !!d, Iu = g, Iu;
}
var Tu, mp;
function r2() {
  if (mp)
    return Tu;
  mp = 1;
  var e = function(t) {
    return t !== t;
  };
  return Tu = function(t, o) {
    return t === 0 && o === 0 ? 1 / t === 1 / o : !!(t === o || e(t) && e(o));
  }, Tu;
}
var Mu, bp;
function i2() {
  if (bp)
    return Mu;
  bp = 1;
  var e = r2();
  return Mu = function() {
    return typeof Object.is == "function" ? Object.is : e;
  }, Mu;
}
var Ru, xp;
function gC() {
  if (xp)
    return Ru;
  xp = 1;
  var e = i2(), t = Rf();
  return Ru = function() {
    var o = e();
    return t(Object, { is: o }, {
      is: function() {
        return Object.is !== o;
      }
    }), o;
  }, Ru;
}
var Nu, _p;
function n2() {
  if (_p)
    return Nu;
  _p = 1;
  var e = Rf(), t = Ys(), o = r2(), r = i2(), h = gC(), a = t(r(), Object);
  return e(a, {
    getPolyfill: r,
    implementation: o,
    shim: h
  }), Nu = a, Nu;
}
var Du, Ep;
function a2() {
  return Ep || (Ep = 1, Du = function(e) {
    return e !== e;
  }), Du;
}
var Ou, Sp;
function s2() {
  if (Sp)
    return Ou;
  Sp = 1;
  var e = a2();
  return Ou = function() {
    return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : e;
  }, Ou;
}
var Pu, wp;
function mC() {
  if (wp)
    return Pu;
  wp = 1;
  var e = Rf(), t = s2();
  return Pu = function() {
    var o = t();
    return e(Number, { isNaN: o }, {
      isNaN: function() {
        return Number.isNaN !== o;
      }
    }), o;
  }, Pu;
}
var Lu, Cp;
function bC() {
  if (Cp)
    return Lu;
  Cp = 1;
  var e = Ys(), t = Rf(), o = a2(), r = s2(), h = mC(), a = e(r(), Number);
  return t(a, {
    getPolyfill: r,
    implementation: o,
    shim: h
  }), Lu = a, Lu;
}
var ku, Ap;
function xC() {
  if (Ap)
    return ku;
  Ap = 1;
  function e(ce, ve) {
    return r(ce) || o(ce, ve) || t();
  }
  function t() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }
  function o(ce, ve) {
    var Re = [], ke = !0, Ce = !1, Le = void 0;
    try {
      for (var Oe = ce[Symbol.iterator](), Pe; !(ke = (Pe = Oe.next()).done) && (Re.push(Pe.value), !(ve && Re.length === ve)); ke = !0)
        ;
    } catch (et) {
      Ce = !0, Le = et;
    } finally {
      try {
        !ke && Oe.return != null && Oe.return();
      } finally {
        if (Ce)
          throw Le;
      }
    }
    return Re;
  }
  function r(ce) {
    if (Array.isArray(ce))
      return ce;
  }
  function h(ce) {
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? h = function(ve) {
      return typeof ve;
    } : h = function(ve) {
      return ve && typeof Symbol == "function" && ve.constructor === Symbol && ve !== Symbol.prototype ? "symbol" : typeof ve;
    }, h(ce);
  }
  var a = /a/g.flags !== void 0, p = function(ce) {
    var ve = [];
    return ce.forEach(function(Re) {
      return ve.push(Re);
    }), ve;
  }, d = function(ce) {
    var ve = [];
    return ce.forEach(function(Re, ke) {
      return ve.push([ke, Re]);
    }), ve;
  }, b = Object.is ? Object.is : n2(), g = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
  }, w = Number.isNaN ? Number.isNaN : bC();
  function C(ce) {
    return ce.call.bind(ce);
  }
  var T = C(Object.prototype.hasOwnProperty), k = C(Object.prototype.propertyIsEnumerable), q = C(Object.prototype.toString), O = wn.types, N = O.isAnyArrayBuffer, j = O.isArrayBufferView, U = O.isDate, H = O.isMap, z = O.isRegExp, ee = O.isSet, ne = O.isNativeError, le = O.isBoxedPrimitive, Z = O.isNumberObject, ie = O.isStringObject, fe = O.isBooleanObject, I = O.isBigIntObject, P = O.isSymbolObject, f = O.isFloat32Array, y = O.isFloat64Array;
  function v(ce) {
    if (ce.length === 0 || ce.length > 10)
      return !0;
    for (var ve = 0; ve < ce.length; ve++) {
      var Re = ce.charCodeAt(ve);
      if (Re < 48 || Re > 57)
        return !0;
    }
    return ce.length === 10 && ce >= Math.pow(2, 32);
  }
  function M(ce) {
    return Object.keys(ce).filter(v).concat(g(ce).filter(Object.prototype.propertyIsEnumerable.bind(ce)));
  }
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  function B(ce, ve) {
    if (ce === ve)
      return 0;
    for (var Re = ce.length, ke = ve.length, Ce = 0, Le = Math.min(Re, ke); Ce < Le; ++Ce)
      if (ce[Ce] !== ve[Ce]) {
        Re = ce[Ce], ke = ve[Ce];
        break;
      }
    return Re < ke ? -1 : ke < Re ? 1 : 0;
  }
  var S = !0, _ = !1, E = 0, m = 1, A = 2, $ = 3;
  function X(ce, ve) {
    return a ? ce.source === ve.source && ce.flags === ve.flags : RegExp.prototype.toString.call(ce) === RegExp.prototype.toString.call(ve);
  }
  function oe(ce, ve) {
    if (ce.byteLength !== ve.byteLength)
      return !1;
    for (var Re = 0; Re < ce.byteLength; Re++)
      if (ce[Re] !== ve[Re])
        return !1;
    return !0;
  }
  function J(ce, ve) {
    return ce.byteLength !== ve.byteLength ? !1 : B(new Uint8Array(ce.buffer, ce.byteOffset, ce.byteLength), new Uint8Array(ve.buffer, ve.byteOffset, ve.byteLength)) === 0;
  }
  function W(ce, ve) {
    return ce.byteLength === ve.byteLength && B(new Uint8Array(ce), new Uint8Array(ve)) === 0;
  }
  function Q(ce, ve) {
    return Z(ce) ? Z(ve) && b(Number.prototype.valueOf.call(ce), Number.prototype.valueOf.call(ve)) : ie(ce) ? ie(ve) && String.prototype.valueOf.call(ce) === String.prototype.valueOf.call(ve) : fe(ce) ? fe(ve) && Boolean.prototype.valueOf.call(ce) === Boolean.prototype.valueOf.call(ve) : I(ce) ? I(ve) && BigInt.prototype.valueOf.call(ce) === BigInt.prototype.valueOf.call(ve) : P(ve) && Symbol.prototype.valueOf.call(ce) === Symbol.prototype.valueOf.call(ve);
  }
  function me(ce, ve, Re, ke) {
    if (ce === ve)
      return ce !== 0 ? !0 : Re ? b(ce, ve) : !0;
    if (Re) {
      if (h(ce) !== "object")
        return typeof ce == "number" && w(ce) && w(ve);
      if (h(ve) !== "object" || ce === null || ve === null || Object.getPrototypeOf(ce) !== Object.getPrototypeOf(ve))
        return !1;
    } else {
      if (ce === null || h(ce) !== "object")
        return ve === null || h(ve) !== "object" ? ce == ve : !1;
      if (ve === null || h(ve) !== "object")
        return !1;
    }
    var Ce = q(ce), Le = q(ve);
    if (Ce !== Le)
      return !1;
    if (Array.isArray(ce)) {
      if (ce.length !== ve.length)
        return !1;
      var Oe = M(ce), Pe = M(ve);
      return Oe.length !== Pe.length ? !1 : Y(ce, ve, Re, ke, m, Oe);
    }
    if (Ce === "[object Object]" && (!H(ce) && H(ve) || !ee(ce) && ee(ve)))
      return !1;
    if (U(ce)) {
      if (!U(ve) || Date.prototype.getTime.call(ce) !== Date.prototype.getTime.call(ve))
        return !1;
    } else if (z(ce)) {
      if (!z(ve) || !X(ce, ve))
        return !1;
    } else if (ne(ce) || ce instanceof Error) {
      if (ce.message !== ve.message || ce.name !== ve.name)
        return !1;
    } else if (j(ce)) {
      if (!Re && (f(ce) || y(ce))) {
        if (!oe(ce, ve))
          return !1;
      } else if (!J(ce, ve))
        return !1;
      var et = M(ce), Ye = M(ve);
      return et.length !== Ye.length ? !1 : Y(ce, ve, Re, ke, E, et);
    } else {
      if (ee(ce))
        return !ee(ve) || ce.size !== ve.size ? !1 : Y(ce, ve, Re, ke, A);
      if (H(ce))
        return !H(ve) || ce.size !== ve.size ? !1 : Y(ce, ve, Re, ke, $);
      if (N(ce)) {
        if (!W(ce, ve))
          return !1;
      } else if (le(ce) && !Q(ce, ve))
        return !1;
    }
    return Y(ce, ve, Re, ke, E);
  }
  function be(ce, ve) {
    return ve.filter(function(Re) {
      return k(ce, Re);
    });
  }
  function Y(ce, ve, Re, ke, Ce, Le) {
    if (arguments.length === 5) {
      Le = Object.keys(ce);
      var Oe = Object.keys(ve);
      if (Le.length !== Oe.length)
        return !1;
    }
    for (var Pe = 0; Pe < Le.length; Pe++)
      if (!T(ve, Le[Pe]))
        return !1;
    if (Re && arguments.length === 5) {
      var et = g(ce);
      if (et.length !== 0) {
        var Ye = 0;
        for (Pe = 0; Pe < et.length; Pe++) {
          var Ne = et[Pe];
          if (k(ce, Ne)) {
            if (!k(ve, Ne))
              return !1;
            Le.push(Ne), Ye++;
          } else if (k(ve, Ne))
            return !1;
        }
        var Tt = g(ve);
        if (et.length !== Tt.length && be(ve, Tt).length !== Ye)
          return !1;
      } else {
        var tt = g(ve);
        if (tt.length !== 0 && be(ve, tt).length !== 0)
          return !1;
      }
    }
    if (Le.length === 0 && (Ce === E || Ce === m && ce.length === 0 || ce.size === 0))
      return !0;
    if (ke === void 0)
      ke = {
        val1: /* @__PURE__ */ new Map(),
        val2: /* @__PURE__ */ new Map(),
        position: 0
      };
    else {
      var Ue = ke.val1.get(ce);
      if (Ue !== void 0) {
        var Ct = ke.val2.get(ve);
        if (Ct !== void 0)
          return Ue === Ct;
      }
      ke.position++;
    }
    ke.val1.set(ce, ke.position), ke.val2.set(ve, ke.position);
    var rt = F(ce, ve, Re, Le, ke, Ce);
    return ke.val1.delete(ce), ke.val2.delete(ve), rt;
  }
  function re(ce, ve, Re, ke) {
    for (var Ce = p(ce), Le = 0; Le < Ce.length; Le++) {
      var Oe = Ce[Le];
      if (me(ve, Oe, Re, ke))
        return ce.delete(Oe), !0;
    }
    return !1;
  }
  function de(ce) {
    switch (h(ce)) {
      case "undefined":
        return null;
      case "object":
        return;
      case "symbol":
        return !1;
      case "string":
        ce = +ce;
      case "number":
        if (w(ce))
          return !1;
    }
    return !0;
  }
  function Ae(ce, ve, Re) {
    var ke = de(Re);
    return ke ?? (ve.has(ke) && !ce.has(ke));
  }
  function qe(ce, ve, Re, ke, Ce) {
    var Le = de(Re);
    if (Le != null)
      return Le;
    var Oe = ve.get(Le);
    return Oe === void 0 && !ve.has(Le) || !me(ke, Oe, !1, Ce) ? !1 : !ce.has(Le) && me(ke, Oe, !1, Ce);
  }
  function x(ce, ve, Re, ke) {
    for (var Ce = null, Le = p(ce), Oe = 0; Oe < Le.length; Oe++) {
      var Pe = Le[Oe];
      if (h(Pe) === "object" && Pe !== null)
        Ce === null && (Ce = /* @__PURE__ */ new Set()), Ce.add(Pe);
      else if (!ve.has(Pe)) {
        if (Re || !Ae(ce, ve, Pe))
          return !1;
        Ce === null && (Ce = /* @__PURE__ */ new Set()), Ce.add(Pe);
      }
    }
    if (Ce !== null) {
      for (var et = p(ve), Ye = 0; Ye < et.length; Ye++) {
        var Ne = et[Ye];
        if (h(Ne) === "object" && Ne !== null) {
          if (!re(Ce, Ne, Re, ke))
            return !1;
        } else if (!Re && !ce.has(Ne) && !re(Ce, Ne, Re, ke))
          return !1;
      }
      return Ce.size === 0;
    }
    return !0;
  }
  function L(ce, ve, Re, ke, Ce, Le) {
    for (var Oe = p(ce), Pe = 0; Pe < Oe.length; Pe++) {
      var et = Oe[Pe];
      if (me(Re, et, Ce, Le) && me(ke, ve.get(et), Ce, Le))
        return ce.delete(et), !0;
    }
    return !1;
  }
  function D(ce, ve, Re, ke) {
    for (var Ce = null, Le = d(ce), Oe = 0; Oe < Le.length; Oe++) {
      var Pe = e(Le[Oe], 2), et = Pe[0], Ye = Pe[1];
      if (h(et) === "object" && et !== null)
        Ce === null && (Ce = /* @__PURE__ */ new Set()), Ce.add(et);
      else {
        var Ne = ve.get(et);
        if (Ne === void 0 && !ve.has(et) || !me(Ye, Ne, Re, ke)) {
          if (Re || !qe(ce, ve, et, Ye, ke))
            return !1;
          Ce === null && (Ce = /* @__PURE__ */ new Set()), Ce.add(et);
        }
      }
    }
    if (Ce !== null) {
      for (var Tt = d(ve), tt = 0; tt < Tt.length; tt++) {
        var Ue = e(Tt[tt], 2), et = Ue[0], Ct = Ue[1];
        if (h(et) === "object" && et !== null) {
          if (!L(Ce, ce, et, Ct, Re, ke))
            return !1;
        } else if (!Re && (!ce.has(et) || !me(ce.get(et), Ct, !1, ke)) && !L(Ce, ce, et, Ct, !1, ke))
          return !1;
      }
      return Ce.size === 0;
    }
    return !0;
  }
  function F(ce, ve, Re, ke, Ce, Le) {
    var Oe = 0;
    if (Le === A) {
      if (!x(ce, ve, Re, Ce))
        return !1;
    } else if (Le === $) {
      if (!D(ce, ve, Re, Ce))
        return !1;
    } else if (Le === m)
      for (; Oe < ce.length; Oe++)
        if (T(ce, Oe)) {
          if (!T(ve, Oe) || !me(ce[Oe], ve[Oe], Re, Ce))
            return !1;
        } else {
          if (T(ve, Oe))
            return !1;
          for (var Pe = Object.keys(ce); Oe < Pe.length; Oe++) {
            var et = Pe[Oe];
            if (!T(ve, et) || !me(ce[et], ve[et], Re, Ce))
              return !1;
          }
          return Pe.length === Object.keys(ve).length;
        }
    for (Oe = 0; Oe < ke.length; Oe++) {
      var Ye = ke[Oe];
      if (!me(ce[Ye], ve[Ye], Re, Ce))
        return !1;
    }
    return !0;
  }
  function ue(ce, ve) {
    return me(ce, ve, _);
  }
  function ge(ce, ve) {
    return me(ce, ve, S);
  }
  return ku = {
    isDeepEqual: ue,
    isDeepStrictEqual: ge
  }, ku;
}
var Bp;
function Os() {
  if (Bp)
    return xu.exports;
  Bp = 1;
  function e(m) {
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? e = function(A) {
      return typeof A;
    } : e = function(A) {
      return A && typeof Symbol == "function" && A.constructor === Symbol && A !== Symbol.prototype ? "symbol" : typeof A;
    }, e(m);
  }
  function t(m, A) {
    if (!(m instanceof A))
      throw new TypeError("Cannot call a class as a function");
  }
  var o = e2(), r = o.codes, h = r.ERR_AMBIGUOUS_ARGUMENT, a = r.ERR_INVALID_ARG_TYPE, p = r.ERR_INVALID_ARG_VALUE, d = r.ERR_INVALID_RETURN_VALUE, b = r.ERR_MISSING_ARGS, g = lC(), w = wn, C = w.inspect, T = wn.types, k = T.isPromise, q = T.isRegExp, O = Object.assign ? Object.assign : dC().assign, N = Object.is ? Object.is : n2(), j, U;
  function H() {
    var m = xC();
    j = m.isDeepEqual, U = m.isDeepStrictEqual;
  }
  var z = !1, ee = xu.exports = fe, ne = {};
  function le(m) {
    throw m.message instanceof Error ? m.message : new g(m);
  }
  function Z(m, A, $, X, oe) {
    var J = arguments.length, W;
    if (J === 0)
      W = "Failed";
    else if (J === 1)
      $ = m, m = void 0;
    else {
      if (z === !1) {
        z = !0;
        var Q = Ve.emitWarning ? Ve.emitWarning : console.warn.bind(console);
        Q("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      J === 2 && (X = "!=");
    }
    if ($ instanceof Error)
      throw $;
    var me = {
      actual: m,
      expected: A,
      operator: X === void 0 ? "fail" : X,
      stackStartFn: oe || Z
    };
    $ !== void 0 && (me.message = $);
    var be = new g(me);
    throw W && (be.message = W, be.generatedMessage = !0), be;
  }
  ee.fail = Z, ee.AssertionError = g;
  function ie(m, A, $, X) {
    if (!$) {
      var oe = !1;
      if (A === 0)
        oe = !0, X = "No value argument passed to `assert.ok()`";
      else if (X instanceof Error)
        throw X;
      var J = new g({
        actual: $,
        expected: !0,
        message: X,
        operator: "==",
        stackStartFn: m
      });
      throw J.generatedMessage = oe, J;
    }
  }
  function fe() {
    for (var m = arguments.length, A = new Array(m), $ = 0; $ < m; $++)
      A[$] = arguments[$];
    ie.apply(void 0, [fe, A.length].concat(A));
  }
  ee.ok = fe, ee.equal = function m(A, $, X) {
    if (arguments.length < 2)
      throw new b("actual", "expected");
    A != $ && le({
      actual: A,
      expected: $,
      message: X,
      operator: "==",
      stackStartFn: m
    });
  }, ee.notEqual = function m(A, $, X) {
    if (arguments.length < 2)
      throw new b("actual", "expected");
    A == $ && le({
      actual: A,
      expected: $,
      message: X,
      operator: "!=",
      stackStartFn: m
    });
  }, ee.deepEqual = function m(A, $, X) {
    if (arguments.length < 2)
      throw new b("actual", "expected");
    j === void 0 && H(), j(A, $) || le({
      actual: A,
      expected: $,
      message: X,
      operator: "deepEqual",
      stackStartFn: m
    });
  }, ee.notDeepEqual = function m(A, $, X) {
    if (arguments.length < 2)
      throw new b("actual", "expected");
    j === void 0 && H(), j(A, $) && le({
      actual: A,
      expected: $,
      message: X,
      operator: "notDeepEqual",
      stackStartFn: m
    });
  }, ee.deepStrictEqual = function m(A, $, X) {
    if (arguments.length < 2)
      throw new b("actual", "expected");
    j === void 0 && H(), U(A, $) || le({
      actual: A,
      expected: $,
      message: X,
      operator: "deepStrictEqual",
      stackStartFn: m
    });
  }, ee.notDeepStrictEqual = I;
  function I(m, A, $) {
    if (arguments.length < 2)
      throw new b("actual", "expected");
    j === void 0 && H(), U(m, A) && le({
      actual: m,
      expected: A,
      message: $,
      operator: "notDeepStrictEqual",
      stackStartFn: I
    });
  }
  ee.strictEqual = function m(A, $, X) {
    if (arguments.length < 2)
      throw new b("actual", "expected");
    N(A, $) || le({
      actual: A,
      expected: $,
      message: X,
      operator: "strictEqual",
      stackStartFn: m
    });
  }, ee.notStrictEqual = function m(A, $, X) {
    if (arguments.length < 2)
      throw new b("actual", "expected");
    N(A, $) && le({
      actual: A,
      expected: $,
      message: X,
      operator: "notStrictEqual",
      stackStartFn: m
    });
  };
  var P = function m(A, $, X) {
    var oe = this;
    t(this, m), $.forEach(function(J) {
      J in A && (X !== void 0 && typeof X[J] == "string" && q(A[J]) && A[J].test(X[J]) ? oe[J] = X[J] : oe[J] = A[J]);
    });
  };
  function f(m, A, $, X, oe, J) {
    if (!($ in m) || !U(m[$], A[$])) {
      if (!X) {
        var W = new P(m, oe), Q = new P(A, oe, m), me = new g({
          actual: W,
          expected: Q,
          operator: "deepStrictEqual",
          stackStartFn: J
        });
        throw me.actual = m, me.expected = A, me.operator = J.name, me;
      }
      le({
        actual: m,
        expected: A,
        message: X,
        operator: J.name,
        stackStartFn: J
      });
    }
  }
  function y(m, A, $, X) {
    if (typeof A != "function") {
      if (q(A))
        return A.test(m);
      if (arguments.length === 2)
        throw new a("expected", ["Function", "RegExp"], A);
      if (e(m) !== "object" || m === null) {
        var oe = new g({
          actual: m,
          expected: A,
          message: $,
          operator: "deepStrictEqual",
          stackStartFn: X
        });
        throw oe.operator = X.name, oe;
      }
      var J = Object.keys(A);
      if (A instanceof Error)
        J.push("name", "message");
      else if (J.length === 0)
        throw new p("error", A, "may not be an empty object");
      return j === void 0 && H(), J.forEach(function(W) {
        typeof m[W] == "string" && q(A[W]) && A[W].test(m[W]) || f(m, A, W, $, J, X);
      }), !0;
    }
    return A.prototype !== void 0 && m instanceof A ? !0 : Error.isPrototypeOf(A) ? !1 : A.call({}, m) === !0;
  }
  function v(m) {
    if (typeof m != "function")
      throw new a("fn", "Function", m);
    try {
      m();
    } catch (A) {
      return A;
    }
    return ne;
  }
  function M(m) {
    return k(m) || m !== null && e(m) === "object" && typeof m.then == "function" && typeof m.catch == "function";
  }
  function B(m) {
    return Promise.resolve().then(function() {
      var A;
      if (typeof m == "function") {
        if (A = m(), !M(A))
          throw new d("instance of Promise", "promiseFn", A);
      } else if (M(m))
        A = m;
      else
        throw new a("promiseFn", ["Function", "Promise"], m);
      return Promise.resolve().then(function() {
        return A;
      }).then(function() {
        return ne;
      }).catch(function($) {
        return $;
      });
    });
  }
  function S(m, A, $, X) {
    if (typeof $ == "string") {
      if (arguments.length === 4)
        throw new a("error", ["Object", "Error", "Function", "RegExp"], $);
      if (e(A) === "object" && A !== null) {
        if (A.message === $)
          throw new h("error/message", 'The error message "'.concat(A.message, '" is identical to the message.'));
      } else if (A === $)
        throw new h("error/message", 'The error "'.concat(A, '" is identical to the message.'));
      X = $, $ = void 0;
    } else if ($ != null && e($) !== "object" && typeof $ != "function")
      throw new a("error", ["Object", "Error", "Function", "RegExp"], $);
    if (A === ne) {
      var oe = "";
      $ && $.name && (oe += " (".concat($.name, ")")), oe += X ? ": ".concat(X) : ".";
      var J = m.name === "rejects" ? "rejection" : "exception";
      le({
        actual: void 0,
        expected: $,
        operator: m.name,
        message: "Missing expected ".concat(J).concat(oe),
        stackStartFn: m
      });
    }
    if ($ && !y(A, $, X, m))
      throw A;
  }
  function _(m, A, $, X) {
    if (A !== ne) {
      if (typeof $ == "string" && (X = $, $ = void 0), !$ || y(A, $)) {
        var oe = X ? ": ".concat(X) : ".", J = m.name === "doesNotReject" ? "rejection" : "exception";
        le({
          actual: A,
          expected: $,
          operator: m.name,
          message: "Got unwanted ".concat(J).concat(oe, `
`) + 'Actual message: "'.concat(A && A.message, '"'),
          stackStartFn: m
        });
      }
      throw A;
    }
  }
  ee.throws = function m(A) {
    for (var $ = arguments.length, X = new Array($ > 1 ? $ - 1 : 0), oe = 1; oe < $; oe++)
      X[oe - 1] = arguments[oe];
    S.apply(void 0, [m, v(A)].concat(X));
  }, ee.rejects = function m(A) {
    for (var $ = arguments.length, X = new Array($ > 1 ? $ - 1 : 0), oe = 1; oe < $; oe++)
      X[oe - 1] = arguments[oe];
    return B(A).then(function(J) {
      return S.apply(void 0, [m, J].concat(X));
    });
  }, ee.doesNotThrow = function m(A) {
    for (var $ = arguments.length, X = new Array($ > 1 ? $ - 1 : 0), oe = 1; oe < $; oe++)
      X[oe - 1] = arguments[oe];
    _.apply(void 0, [m, v(A)].concat(X));
  }, ee.doesNotReject = function m(A) {
    for (var $ = arguments.length, X = new Array($ > 1 ? $ - 1 : 0), oe = 1; oe < $; oe++)
      X[oe - 1] = arguments[oe];
    return B(A).then(function(J) {
      return _.apply(void 0, [m, J].concat(X));
    });
  }, ee.ifError = function m(A) {
    if (A != null) {
      var $ = "ifError got unwanted exception: ";
      e(A) === "object" && typeof A.message == "string" ? A.message.length === 0 && A.constructor ? $ += A.constructor.name : $ += A.message : $ += C(A);
      var X = new g({
        actual: A,
        expected: null,
        operator: "ifError",
        message: $,
        stackStartFn: m
      }), oe = A.stack;
      if (typeof oe == "string") {
        var J = oe.split(`
`);
        J.shift();
        for (var W = X.stack.split(`
`), Q = 0; Q < J.length; Q++) {
          var me = W.indexOf(J[Q]);
          if (me !== -1) {
            W = W.slice(0, me);
            break;
          }
        }
        X.stack = "".concat(W.join(`
`), `
`).concat(J.join(`
`));
      }
      throw X;
    }
  };
  function E() {
    for (var m = arguments.length, A = new Array(m), $ = 0; $ < m; $++)
      A[$] = arguments[$];
    ie.apply(void 0, [E, A.length].concat(A));
  }
  return ee.strict = O(E, ee, {
    equal: ee.strictEqual,
    deepEqual: ee.deepStrictEqual,
    notEqual: ee.notStrictEqual,
    notDeepEqual: ee.notDeepStrictEqual
  }), ee.strict.strict = ee.strict, xu.exports;
}
var _C = Os(), f2 = $0.Buffer, z0 = Nh, EC = Rh, Oa = EC.newInvalidAsn1Error;
function Er(e) {
  if (!e || !f2.isBuffer(e))
    throw new TypeError("data must be a node Buffer");
  this._buf = e, this._size = e.length, this._len = 0, this._offset = 0;
}
Object.defineProperty(Er.prototype, "length", {
  enumerable: !0,
  get: function() {
    return this._len;
  }
});
Object.defineProperty(Er.prototype, "offset", {
  enumerable: !0,
  get: function() {
    return this._offset;
  }
});
Object.defineProperty(Er.prototype, "remain", {
  get: function() {
    return this._size - this._offset;
  }
});
Object.defineProperty(Er.prototype, "buffer", {
  get: function() {
    return this._buf.slice(this._offset);
  }
});
Er.prototype.readByte = function(e) {
  if (this._size - this._offset < 1)
    return null;
  var t = this._buf[this._offset] & 255;
  return e || (this._offset += 1), t;
};
Er.prototype.peek = function() {
  return this.readByte(!0);
};
Er.prototype.readLength = function(e) {
  if (e === void 0 && (e = this._offset), e >= this._size)
    return null;
  var t = this._buf[e++] & 255;
  if (t === null)
    return null;
  if ((t & 128) === 128) {
    if (t &= 127, t === 0)
      throw Oa("Indefinite length not supported");
    if (t > 4)
      throw Oa("encoding too long");
    if (this._size - e < t)
      return null;
    this._len = 0;
    for (var o = 0; o < t; o++)
      this._len = (this._len << 8) + (this._buf[e++] & 255);
  } else
    this._len = t;
  return e;
};
Er.prototype.readSequence = function(e) {
  var t = this.peek();
  if (t === null)
    return null;
  if (e !== void 0 && e !== t)
    throw Oa("Expected 0x" + e.toString(16) + ": got 0x" + t.toString(16));
  var o = this.readLength(this._offset + 1);
  return o === null ? null : (this._offset = o, t);
};
Er.prototype.readInt = function() {
  return this._readTag(z0.Integer);
};
Er.prototype.readBoolean = function() {
  return this._readTag(z0.Boolean) !== 0;
};
Er.prototype.readEnumeration = function() {
  return this._readTag(z0.Enumeration);
};
Er.prototype.readString = function(e, t) {
  e || (e = z0.OctetString);
  var o = this.peek();
  if (o === null)
    return null;
  if (o !== e)
    throw Oa("Expected 0x" + e.toString(16) + ": got 0x" + o.toString(16));
  var r = this.readLength(this._offset + 1);
  if (r === null || this.length > this._size - r)
    return null;
  if (this._offset = r, this.length === 0)
    return t ? f2.alloc(0) : "";
  var h = this._buf.slice(this._offset, this._offset + this.length);
  return this._offset += this.length, t ? h : h.toString("utf8");
};
Er.prototype.readOID = function(e) {
  e || (e = z0.OID);
  var t = this.readString(e, !0);
  if (t === null)
    return null;
  for (var o = [], r = 0, h = 0; h < t.length; h++) {
    var a = t[h] & 255;
    r <<= 7, r += a & 127, a & 128 || (o.push(r), r = 0);
  }
  return r = o.shift(), o.unshift(r % 40), o.unshift(r / 40 >> 0), o.join(".");
};
Er.prototype._readTag = function(e) {
  _C.ok(e !== void 0);
  var t = this.peek();
  if (t === null)
    return null;
  if (t !== e)
    throw Oa("Expected 0x" + e.toString(16) + ": got 0x" + t.toString(16));
  var o = this.readLength(this._offset + 1);
  if (o === null)
    return null;
  if (this.length > 4)
    throw Oa("Integer too long: " + this.length);
  if (this.length > this._size - o)
    return null;
  this._offset = o;
  for (var r = this._buf[this._offset], h = 0, a = 0; a < this.length; a++)
    h <<= 8, h |= this._buf[this._offset++] & 255;
  return (r & 128) === 128 && a !== 4 && (h -= 1 << a * 8), h >> 0;
};
var SC = Er, yn = Os(), Nf = $0.Buffer, An = Nh, wC = Rh, Df = wC.newInvalidAsn1Error, CC = {
  size: 1024,
  growthFactor: 8
};
function AC(e, t) {
  yn.ok(e), yn.equal(typeof e, "object"), yn.ok(t), yn.equal(typeof t, "object");
  var o = Object.getOwnPropertyNames(e);
  return o.forEach(function(r) {
    if (!t[r]) {
      var h = Object.getOwnPropertyDescriptor(e, r);
      Object.defineProperty(t, r, h);
    }
  }), t;
}
function pr(e) {
  e = AC(CC, e || {}), this._buf = Nf.alloc(e.size || 1024), this._size = this._buf.length, this._offset = 0, this._options = e, this._seq = [];
}
Object.defineProperty(pr.prototype, "buffer", {
  get: function() {
    if (this._seq.length)
      throw Df(this._seq.length + " unended sequence(s)");
    return this._buf.slice(0, this._offset);
  }
});
pr.prototype.writeByte = function(e) {
  if (typeof e != "number")
    throw new TypeError("argument must be a Number");
  this._ensure(1), this._buf[this._offset++] = e;
};
pr.prototype.writeInt = function(e, t) {
  if (typeof e != "number")
    throw new TypeError("argument must be a Number");
  typeof t != "number" && (t = An.Integer);
  for (var o = 4; (!(e & 4286578688) || (e & 4286578688) === -8388608) && o > 1; )
    o--, e <<= 8;
  if (o > 4)
    throw Df("BER ints cannot be > 0xffffffff");
  for (this._ensure(2 + o), this._buf[this._offset++] = t, this._buf[this._offset++] = o; o-- > 0; )
    this._buf[this._offset++] = (e & 4278190080) >>> 24, e <<= 8;
};
pr.prototype.writeNull = function() {
  this.writeByte(An.Null), this.writeByte(0);
};
pr.prototype.writeEnumeration = function(e, t) {
  if (typeof e != "number")
    throw new TypeError("argument must be a Number");
  return typeof t != "number" && (t = An.Enumeration), this.writeInt(e, t);
};
pr.prototype.writeBoolean = function(e, t) {
  if (typeof e != "boolean")
    throw new TypeError("argument must be a Boolean");
  typeof t != "number" && (t = An.Boolean), this._ensure(3), this._buf[this._offset++] = t, this._buf[this._offset++] = 1, this._buf[this._offset++] = e ? 255 : 0;
};
pr.prototype.writeString = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("argument must be a string (was: " + typeof e + ")");
  typeof t != "number" && (t = An.OctetString);
  var o = Nf.byteLength(e);
  this.writeByte(t), this.writeLength(o), o && (this._ensure(o), this._buf.write(e, this._offset), this._offset += o);
};
pr.prototype.writeBuffer = function(e, t) {
  if (typeof t != "number")
    throw new TypeError("tag must be a number");
  if (!Nf.isBuffer(e))
    throw new TypeError("argument must be a buffer");
  this.writeByte(t), this.writeLength(e.length), this._ensure(e.length), e.copy(this._buf, this._offset, 0, e.length), this._offset += e.length;
};
pr.prototype.writeStringArray = function(e) {
  if (!e instanceof Array)
    throw new TypeError("argument must be an Array[String]");
  var t = this;
  e.forEach(function(o) {
    t.writeString(o);
  });
};
pr.prototype.writeOID = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("argument must be a string");
  if (typeof t != "number" && (t = An.OID), !/^([0-9]+\.){3,}[0-9]+$/.test(e))
    throw new Error("argument is not a valid OID string");
  function o(p, d) {
    d < 128 ? p.push(d) : d < 16384 ? (p.push(d >>> 7 | 128), p.push(d & 127)) : d < 2097152 ? (p.push(d >>> 14 | 128), p.push((d >>> 7 | 128) & 255), p.push(d & 127)) : d < 268435456 ? (p.push(d >>> 21 | 128), p.push((d >>> 14 | 128) & 255), p.push((d >>> 7 | 128) & 255), p.push(d & 127)) : (p.push((d >>> 28 | 128) & 255), p.push((d >>> 21 | 128) & 255), p.push((d >>> 14 | 128) & 255), p.push((d >>> 7 | 128) & 255), p.push(d & 127));
  }
  var r = e.split("."), h = [];
  h.push(parseInt(r[0], 10) * 40 + parseInt(r[1], 10)), r.slice(2).forEach(function(p) {
    o(h, parseInt(p, 10));
  });
  var a = this;
  this._ensure(2 + h.length), this.writeByte(t), this.writeLength(h.length), h.forEach(function(p) {
    a.writeByte(p);
  });
};
pr.prototype.writeLength = function(e) {
  if (typeof e != "number")
    throw new TypeError("argument must be a Number");
  if (this._ensure(4), e <= 127)
    this._buf[this._offset++] = e;
  else if (e <= 255)
    this._buf[this._offset++] = 129, this._buf[this._offset++] = e;
  else if (e <= 65535)
    this._buf[this._offset++] = 130, this._buf[this._offset++] = e >> 8, this._buf[this._offset++] = e;
  else if (e <= 16777215)
    this._buf[this._offset++] = 131, this._buf[this._offset++] = e >> 16, this._buf[this._offset++] = e >> 8, this._buf[this._offset++] = e;
  else
    throw Df("Length too long (> 4 bytes)");
};
pr.prototype.startSequence = function(e) {
  typeof e != "number" && (e = An.Sequence | An.Constructor), this.writeByte(e), this._seq.push(this._offset), this._ensure(3), this._offset += 3;
};
pr.prototype.endSequence = function() {
  var e = this._seq.pop(), t = e + 3, o = this._offset - t;
  if (o <= 127)
    this._shift(t, o, -2), this._buf[e] = o;
  else if (o <= 255)
    this._shift(t, o, -1), this._buf[e] = 129, this._buf[e + 1] = o;
  else if (o <= 65535)
    this._buf[e] = 130, this._buf[e + 1] = o >> 8, this._buf[e + 2] = o;
  else if (o <= 16777215)
    this._shift(t, o, 1), this._buf[e] = 131, this._buf[e + 1] = o >> 16, this._buf[e + 2] = o >> 8, this._buf[e + 3] = o;
  else
    throw Df("Sequence too long");
};
pr.prototype._shift = function(e, t, o) {
  yn.ok(e !== void 0), yn.ok(t !== void 0), yn.ok(o), this._buf.copy(this._buf, e + o, e, e + t), this._offset += o;
};
pr.prototype._ensure = function(e) {
  if (yn.ok(e), this._size - this._offset < e) {
    var t = this._size * this._options.growthFactor;
    t - this._offset < e && (t += e);
    var o = Nf.alloc(t);
    this._buf.copy(o, 0, 0, this._offset), this._buf = o, this._size = t;
  }
};
var BC = pr;
(function(e) {
  var t = Rh, o = Nh, r = SC, h = BC;
  e.exports = {
    Reader: r,
    Writer: h
  };
  for (var a in o)
    o.hasOwnProperty(a) && (e.exports[a] = o[a]);
  for (var p in t)
    t.hasOwnProperty(p) && (e.exports[p] = t[p]);
})(Jy);
var IC = Jy.exports, Uu = IC, Dh = {
  Ber: Uu,
  BerReader: Uu.Reader,
  BerWriter: Uu.Writer
}, o2 = { exports: {} }, u2 = { exports: {} };
(function(e) {
  var t = Dh.Ber, o = tr._, r = tr;
  const h = "-----BEGIN RSA PRIVATE KEY-----", a = "-----END RSA PRIVATE KEY-----", p = "-----BEGIN RSA PUBLIC KEY-----", d = "-----END RSA PUBLIC KEY-----";
  e.exports = {
    privateExport: function(b, g) {
      g = g || {};
      var w = b.n.toBuffer(), C = b.d.toBuffer(), T = b.p.toBuffer(), k = b.q.toBuffer(), q = b.dmp1.toBuffer(), O = b.dmq1.toBuffer(), N = b.coeff.toBuffer(), j = w.length + C.length + T.length + k.length + q.length + O.length + N.length + 512, U = new t.Writer({ size: j });
      return U.startSequence(), U.writeInt(0), U.writeBuffer(w, 2), U.writeInt(b.e), U.writeBuffer(C, 2), U.writeBuffer(T, 2), U.writeBuffer(k, 2), U.writeBuffer(q, 2), U.writeBuffer(O, 2), U.writeBuffer(N, 2), U.endSequence(), g.type === "der" ? U.buffer : h + `
` + r.linebrk(U.buffer.toString("base64"), 64) + `
` + a;
    },
    privateImport: function(b, g, w) {
      w = w || {};
      var C;
      if (w.type !== "der")
        if (pe.Buffer.isBuffer(g) && (g = g.toString("utf8")), o.isString(g)) {
          var T = r.trimSurroundingText(g, h, a).replace(/\s+|\n\r|\n|\r$/gm, "");
          C = pe.Buffer.from(T, "base64");
        } else
          throw Error("Unsupported key format");
      else if (pe.Buffer.isBuffer(g))
        C = g;
      else
        throw Error("Unsupported key format");
      var k = new t.Reader(C);
      k.readSequence(), k.readString(2, !0), b.setPrivate(
        k.readString(2, !0),
        // modulus
        k.readString(2, !0),
        // publicExponent
        k.readString(2, !0),
        // privateExponent
        k.readString(2, !0),
        // prime1
        k.readString(2, !0),
        // prime2
        k.readString(2, !0),
        // exponent1 -- d mod (p1)
        k.readString(2, !0),
        // exponent2 -- d mod (q-1)
        k.readString(2, !0)
        // coefficient -- (inverse of q) mod p
      );
    },
    publicExport: function(b, g) {
      g = g || {};
      var w = b.n.toBuffer(), C = w.length + 512, T = new t.Writer({ size: C });
      return T.startSequence(), T.writeBuffer(w, 2), T.writeInt(b.e), T.endSequence(), g.type === "der" ? T.buffer : p + `
` + r.linebrk(T.buffer.toString("base64"), 64) + `
` + d;
    },
    publicImport: function(b, g, w) {
      w = w || {};
      var C;
      if (w.type !== "der") {
        if (pe.Buffer.isBuffer(g) && (g = g.toString("utf8")), o.isString(g)) {
          var T = r.trimSurroundingText(g, p, d).replace(/\s+|\n\r|\n|\r$/gm, "");
          C = pe.Buffer.from(T, "base64");
        }
      } else if (pe.Buffer.isBuffer(g))
        C = g;
      else
        throw Error("Unsupported key format");
      var k = new t.Reader(C);
      k.readSequence(), b.setPublic(
        k.readString(2, !0),
        // modulus
        k.readString(2, !0)
        // publicExponent
      );
    },
    /**
     * Trying autodetect and import key
     * @param key
     * @param data
     */
    autoImport: function(b, g) {
      return /^[\S\s]*-----BEGIN RSA PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END RSA PRIVATE KEY-----[\S\s]*$/g.test(g) ? (e.exports.privateImport(b, g), !0) : /^[\S\s]*-----BEGIN RSA PUBLIC KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END RSA PUBLIC KEY-----[\S\s]*$/g.test(g) ? (e.exports.publicImport(b, g), !0) : !1;
    }
  };
})(u2);
var TC = u2.exports, c2 = { exports: {} };
(function(e) {
  var t = Dh.Ber, o = tr._, r = "1.2.840.113549.1.1.1", h = tr;
  const a = "-----BEGIN PRIVATE KEY-----", p = "-----END PRIVATE KEY-----", d = "-----BEGIN PUBLIC KEY-----", b = "-----END PUBLIC KEY-----";
  e.exports = {
    privateExport: function(g, w) {
      w = w || {};
      var C = g.n.toBuffer(), T = g.d.toBuffer(), k = g.p.toBuffer(), q = g.q.toBuffer(), O = g.dmp1.toBuffer(), N = g.dmq1.toBuffer(), j = g.coeff.toBuffer(), U = C.length + T.length + k.length + q.length + O.length + N.length + j.length + 512, H = new t.Writer({ size: U });
      H.startSequence(), H.writeInt(0), H.writeBuffer(C, 2), H.writeInt(g.e), H.writeBuffer(T, 2), H.writeBuffer(k, 2), H.writeBuffer(q, 2), H.writeBuffer(O, 2), H.writeBuffer(N, 2), H.writeBuffer(j, 2), H.endSequence();
      var z = new t.Writer({ size: U });
      return z.startSequence(), z.writeInt(0), z.startSequence(), z.writeOID(r), z.writeNull(), z.endSequence(), z.writeBuffer(H.buffer, 4), z.endSequence(), w.type === "der" ? z.buffer : a + `
` + h.linebrk(z.buffer.toString("base64"), 64) + `
` + p;
    },
    privateImport: function(g, w, C) {
      C = C || {};
      var T;
      if (C.type !== "der")
        if (pe.Buffer.isBuffer(w) && (w = w.toString("utf8")), o.isString(w)) {
          var k = h.trimSurroundingText(w, a, p).replace("-----END PRIVATE KEY-----", "").replace(/\s+|\n\r|\n|\r$/gm, "");
          T = pe.Buffer.from(k, "base64");
        } else
          throw Error("Unsupported key format");
      else if (pe.Buffer.isBuffer(w))
        T = w;
      else
        throw Error("Unsupported key format");
      var q = new t.Reader(T);
      q.readSequence(), q.readInt(0);
      var O = new t.Reader(q.readString(48, !0));
      if (O.readOID(6, !0) !== r)
        throw Error("Invalid Public key format");
      var N = new t.Reader(q.readString(4, !0));
      N.readSequence(), N.readString(2, !0), g.setPrivate(
        N.readString(2, !0),
        // modulus
        N.readString(2, !0),
        // publicExponent
        N.readString(2, !0),
        // privateExponent
        N.readString(2, !0),
        // prime1
        N.readString(2, !0),
        // prime2
        N.readString(2, !0),
        // exponent1 -- d mod (p1)
        N.readString(2, !0),
        // exponent2 -- d mod (q-1)
        N.readString(2, !0)
        // coefficient -- (inverse of q) mod p
      );
    },
    publicExport: function(g, w) {
      w = w || {};
      var C = g.n.toBuffer(), T = C.length + 512, k = new t.Writer({ size: T });
      k.writeByte(0), k.startSequence(), k.writeBuffer(C, 2), k.writeInt(g.e), k.endSequence();
      var q = new t.Writer({ size: T });
      return q.startSequence(), q.startSequence(), q.writeOID(r), q.writeNull(), q.endSequence(), q.writeBuffer(k.buffer, 3), q.endSequence(), w.type === "der" ? q.buffer : d + `
` + h.linebrk(q.buffer.toString("base64"), 64) + `
` + b;
    },
    publicImport: function(g, w, C) {
      C = C || {};
      var T;
      if (C.type !== "der") {
        if (pe.Buffer.isBuffer(w) && (w = w.toString("utf8")), o.isString(w)) {
          var k = h.trimSurroundingText(w, d, b).replace(/\s+|\n\r|\n|\r$/gm, "");
          T = pe.Buffer.from(k, "base64");
        }
      } else if (pe.Buffer.isBuffer(w))
        T = w;
      else
        throw Error("Unsupported key format");
      var q = new t.Reader(T);
      q.readSequence();
      var O = new t.Reader(q.readString(48, !0));
      if (O.readOID(6, !0) !== r)
        throw Error("Invalid Public key format");
      var N = new t.Reader(q.readString(3, !0));
      N.readByte(), N.readSequence(), g.setPublic(
        N.readString(2, !0),
        // modulus
        N.readString(2, !0)
        // publicExponent
      );
    },
    /**
     * Trying autodetect and import key
     * @param key
     * @param data
     */
    autoImport: function(g, w) {
      return /^[\S\s]*-----BEGIN PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END PRIVATE KEY-----[\S\s]*$/g.test(w) ? (e.exports.privateImport(g, w), !0) : /^[\S\s]*-----BEGIN PUBLIC KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END PUBLIC KEY-----[\S\s]*$/g.test(w) ? (e.exports.publicImport(g, w), !0) : !1;
    }
  };
})(c2);
var MC = c2.exports, h2 = { exports: {} };
(function(e) {
  tr._, e.exports = {
    privateExport: function(t, o) {
      return {
        n: t.n.toBuffer(),
        e: t.e,
        d: t.d.toBuffer(),
        p: t.p.toBuffer(),
        q: t.q.toBuffer(),
        dmp1: t.dmp1.toBuffer(),
        dmq1: t.dmq1.toBuffer(),
        coeff: t.coeff.toBuffer()
      };
    },
    privateImport: function(t, o, r) {
      if (o.n && o.e && o.d && o.p && o.q && o.dmp1 && o.dmq1 && o.coeff)
        t.setPrivate(
          o.n,
          o.e,
          o.d,
          o.p,
          o.q,
          o.dmp1,
          o.dmq1,
          o.coeff
        );
      else
        throw Error("Invalid key data");
    },
    publicExport: function(t, o) {
      return {
        n: t.n.toBuffer(),
        e: t.e
      };
    },
    publicImport: function(t, o, r) {
      if (o.n && o.e)
        t.setPublic(
          o.n,
          o.e
        );
      else
        throw Error("Invalid key data");
    },
    /**
     * Trying autodetect and import key
     * @param key
     * @param data
     */
    autoImport: function(t, o) {
      return o.n && o.e ? o.d && o.p && o.q && o.dmp1 && o.dmq1 && o.coeff ? (e.exports.privateImport(t, o), !0) : (e.exports.publicImport(t, o), !0) : !1;
    }
  };
})(h2);
var RC = h2.exports, l2 = { exports: {} };
(function(e) {
  var t = tr._, o = tr, r = G0;
  const h = "-----BEGIN OPENSSH PRIVATE KEY-----", a = "-----END OPENSSH PRIVATE KEY-----";
  e.exports = {
    privateExport: function(b, g) {
      const w = b.n.toBuffer();
      let C = pe.Buffer.alloc(4);
      for (C.writeUInt32BE(b.e, 0); C[0] === 0; )
        C = C.slice(1);
      const T = b.d.toBuffer(), k = b.coeff.toBuffer(), q = b.p.toBuffer(), O = b.q.toBuffer();
      let N;
      typeof b.sshcomment < "u" ? N = pe.Buffer.from(b.sshcomment) : N = pe.Buffer.from([]);
      const j = 15 + C.byteLength + 4 + w.byteLength, U = 23 + w.byteLength + 4 + C.byteLength + 4 + T.byteLength + 4 + k.byteLength + 4 + q.byteLength + 4 + O.byteLength + 4 + N.byteLength;
      let H = 43 + // 32bit pubkey length
      j + 4 + //32bit private+checksum+comment+padding length
      U;
      const z = Math.ceil(U / 8) * 8 - U;
      H += z;
      const ee = pe.Buffer.alloc(H), ne = { buf: ee, off: 0 };
      ee.write("openssh-key-v1", "utf8"), ee.writeUInt8(0, 14), ne.off += 15, d(ne, pe.Buffer.from("none")), d(ne, pe.Buffer.from("none")), d(ne, pe.Buffer.from("")), ne.off = ne.buf.writeUInt32BE(1, ne.off), ne.off = ne.buf.writeUInt32BE(j, ne.off), d(ne, pe.Buffer.from("ssh-rsa")), d(ne, C), d(ne, w), ne.off = ne.buf.writeUInt32BE(
        H - 47 - j,
        ne.off
      ), ne.off += 8, d(ne, pe.Buffer.from("ssh-rsa")), d(ne, w), d(ne, C), d(ne, T), d(ne, k), d(ne, q), d(ne, O), d(ne, N);
      let le = 1;
      for (; ne.off < H; )
        ne.off = ne.buf.writeUInt8(le++, ne.off);
      return g.type === "der" ? ne.buf : h + `
` + o.linebrk(ee.toString("base64"), 70) + `
` + a + `
`;
    },
    privateImport: function(b, g, w) {
      w = w || {};
      var C;
      if (w.type !== "der")
        if (pe.Buffer.isBuffer(g) && (g = g.toString("utf8")), t.isString(g)) {
          var T = o.trimSurroundingText(g, h, a).replace(/\s+|\n\r|\n|\r$/gm, "");
          C = pe.Buffer.from(T, "base64");
        } else
          throw Error("Unsupported key format");
      else if (pe.Buffer.isBuffer(g))
        C = g;
      else
        throw Error("Unsupported key format");
      const k = { buf: C, off: 0 };
      if (C.slice(0, 14).toString("ascii") !== "openssh-key-v1")
        throw "Invalid file format.";
      if (k.off += 15, p(k).toString("ascii") !== "none" || p(k).toString("ascii") !== "none" || p(k).toString("ascii") !== "" || (k.off += 4, k.off += 4, p(k).toString("ascii") !== "ssh-rsa") || (p(k), p(k), k.off += 12, p(k).toString("ascii") !== "ssh-rsa"))
        throw Error("Unsupported key type");
      const q = p(k), O = p(k), N = p(k), j = p(k), U = p(k), H = p(k), z = new r(N), ee = new r(H), ne = new r(U), le = z.mod(ne.subtract(r.ONE)), Z = z.mod(ee.subtract(r.ONE));
      b.setPrivate(
        q,
        // modulus
        O,
        // publicExponent
        N,
        // privateExponent
        U,
        // prime1
        H,
        // prime2
        le.toBuffer(),
        // exponent1 -- d mod (p1)
        Z.toBuffer(),
        // exponent2 -- d mod (q-1)
        j
        // coefficient -- (inverse of q) mod p
      ), b.sshcomment = p(k).toString("ascii");
    },
    publicExport: function(b, g) {
      let w = pe.Buffer.alloc(4);
      for (w.writeUInt32BE(b.e, 0); w[0] === 0; )
        w = w.slice(1);
      const C = b.n.toBuffer(), T = pe.Buffer.alloc(
        w.byteLength + 4 + C.byteLength + 4 + 7 + 4
      ), k = { buf: T, off: 0 };
      d(k, pe.Buffer.from("ssh-rsa")), d(k, w), d(k, C);
      let q = b.sshcomment || "";
      return g.type === "der" ? k.buf : "ssh-rsa " + T.toString("base64") + " " + q + `
`;
    },
    publicImport: function(b, g, w) {
      w = w || {};
      var C;
      if (w.type !== "der")
        if (pe.Buffer.isBuffer(g) && (g = g.toString("utf8")), t.isString(g)) {
          if (g.substring(0, 8) !== "ssh-rsa ")
            throw Error("Unsupported key format");
          let N = g.indexOf(" ", 8);
          N === -1 ? N = g.length : b.sshcomment = g.substring(N + 1).replace(/\s+|\n\r|\n|\r$/gm, "");
          const j = g.substring(8, N).replace(/\s+|\n\r|\n|\r$/gm, "");
          C = pe.Buffer.from(j, "base64");
        } else
          throw Error("Unsupported key format");
      else if (pe.Buffer.isBuffer(g))
        C = g;
      else
        throw Error("Unsupported key format");
      const T = { buf: C, off: 0 }, k = p(T).toString("ascii");
      if (k !== "ssh-rsa")
        throw Error("Invalid key type: " + k);
      const q = p(T), O = p(T);
      b.setPublic(
        O,
        q
      );
    },
    /**
     * Trying autodetect and import key
     * @param key
     * @param data
     */
    autoImport: function(b, g) {
      return /^[\S\s]*-----BEGIN OPENSSH PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END OPENSSH PRIVATE KEY-----[\S\s]*$/g.test(g) ? (e.exports.privateImport(b, g), !0) : /^[\S\s]*ssh-rsa \s*(?=(([A-Za-z0-9+/=]+\s*)+))\1[\S\s]*$/g.test(g) ? (e.exports.publicImport(b, g), !0) : !1;
    }
  };
  function p(b) {
    const g = b.buf.readInt32BE(b.off);
    b.off += 4;
    const w = b.buf.slice(b.off, b.off + g);
    return b.off += g, w;
  }
  function d(b, g) {
    b.buf.writeInt32BE(g.byteLength, b.off), b.off += 4, b.off += g.copy(b.buf, b.off);
  }
})(l2);
var NC = l2.exports;
(function(e) {
  tr._;
  function t(o) {
    o = o.split("-");
    for (var r = "private", h = { type: "default" }, a = 1; a < o.length; a++)
      if (o[a])
        switch (o[a]) {
          case "public":
            r = o[a];
            break;
          case "private":
            r = o[a];
            break;
          case "pem":
            h.type = o[a];
            break;
          case "der":
            h.type = o[a];
            break;
        }
    return { scheme: o[0], keyType: r, keyOpt: h };
  }
  e.exports = {
    pkcs1: TC,
    pkcs8: MC,
    components: RC,
    openssh: NC,
    isPrivateExport: function(o) {
      return e.exports[o] && typeof e.exports[o].privateExport == "function";
    },
    isPrivateImport: function(o) {
      return e.exports[o] && typeof e.exports[o].privateImport == "function";
    },
    isPublicExport: function(o) {
      return e.exports[o] && typeof e.exports[o].publicExport == "function";
    },
    isPublicImport: function(o) {
      return e.exports[o] && typeof e.exports[o].publicImport == "function";
    },
    detectAndImport: function(o, r, h) {
      if (h === void 0) {
        for (var a in e.exports)
          if (typeof e.exports[a].autoImport == "function" && e.exports[a].autoImport(o, r))
            return !0;
      } else if (h) {
        var p = t(h);
        if (e.exports[p.scheme])
          p.keyType === "private" ? e.exports[p.scheme].privateImport(o, r, p.keyOpt) : e.exports[p.scheme].publicImport(o, r, p.keyOpt);
        else
          throw Error("Unsupported key format");
      }
      return !1;
    },
    detectAndExport: function(o, r) {
      if (r) {
        var h = t(r);
        if (e.exports[h.scheme])
          if (h.keyType === "private") {
            if (!o.isPrivate())
              throw Error("This is not private key");
            return e.exports[h.scheme].privateExport(o, h.keyOpt);
          } else {
            if (!o.isPublic())
              throw Error("This is not public key");
            return e.exports[h.scheme].publicExport(o, h.keyOpt);
          }
        else
          throw Error("Unsupported key format");
      }
    }
  };
})(o2);
var DC = o2.exports, OC = Bh;
_r();
var Mr = tr._, PC = tr, Ip = Za(), Tp = DC, LC = function() {
  var e = {
    node10: ["md4", "md5", "ripemd160", "sha1", "sha224", "sha256", "sha384", "sha512"],
    node: ["md4", "md5", "ripemd160", "sha1", "sha224", "sha256", "sha384", "sha512"],
    iojs: ["md4", "md5", "ripemd160", "sha1", "sha224", "sha256", "sha384", "sha512"],
    browser: ["md5", "ripemd160", "sha1", "sha256", "sha512"]
  }, t = "pkcs1_oaep", o = "pkcs1", r = "private", h = {
    private: "pkcs1-private-pem",
    "private-der": "pkcs1-private-der",
    public: "pkcs8-public-pem",
    "public-der": "pkcs8-public-der"
  };
  function a(p, d, b) {
    if (!(this instanceof a))
      return new a(p, d, b);
    Mr.isObject(d) && (b = d, d = void 0), this.$options = {
      signingScheme: o,
      signingSchemeOptions: {
        hash: "sha256",
        saltLength: null
      },
      encryptionScheme: t,
      encryptionSchemeOptions: {
        hash: "sha1",
        label: null
      },
      environment: PC.detectEnvironment(),
      rsaUtils: this
    }, this.keyPair = new OC.Key(), this.$cache = {}, pe.Buffer.isBuffer(p) || Mr.isString(p) ? this.importKey(p, d) : Mr.isObject(p) && this.generateKeyPair(p.b, p.e), this.setOptions(b);
  }
  return a.prototype.setOptions = function(p) {
    if (p = p || {}, p.environment && (this.$options.environment = p.environment), p.signingScheme) {
      if (Mr.isString(p.signingScheme)) {
        var d = p.signingScheme.toLowerCase().split("-");
        d.length == 1 ? e.node.indexOf(d[0]) > -1 ? (this.$options.signingSchemeOptions = {
          hash: d[0]
        }, this.$options.signingScheme = o) : (this.$options.signingScheme = d[0], this.$options.signingSchemeOptions = {
          hash: null
        }) : (this.$options.signingSchemeOptions = {
          hash: d[1]
        }, this.$options.signingScheme = d[0]);
      } else
        Mr.isObject(p.signingScheme) && (this.$options.signingScheme = p.signingScheme.scheme || o, this.$options.signingSchemeOptions = Mr.omit(p.signingScheme, "scheme"));
      if (!Ip.isSignature(this.$options.signingScheme))
        throw Error("Unsupported signing scheme");
      if (this.$options.signingSchemeOptions.hash && e[this.$options.environment].indexOf(this.$options.signingSchemeOptions.hash) === -1)
        throw Error("Unsupported hashing algorithm for " + this.$options.environment + " environment");
    }
    if (p.encryptionScheme) {
      if (Mr.isString(p.encryptionScheme) ? (this.$options.encryptionScheme = p.encryptionScheme.toLowerCase(), this.$options.encryptionSchemeOptions = {}) : Mr.isObject(p.encryptionScheme) && (this.$options.encryptionScheme = p.encryptionScheme.scheme || t, this.$options.encryptionSchemeOptions = Mr.omit(p.encryptionScheme, "scheme")), !Ip.isEncryption(this.$options.encryptionScheme))
        throw Error("Unsupported encryption scheme");
      if (this.$options.encryptionSchemeOptions.hash && e[this.$options.environment].indexOf(this.$options.encryptionSchemeOptions.hash) === -1)
        throw Error("Unsupported hashing algorithm for " + this.$options.environment + " environment");
    }
    this.keyPair.setOptions(this.$options);
  }, a.prototype.generateKeyPair = function(p, d) {
    if (p = p || 2048, d = d || 65537, p % 8 !== 0)
      throw Error("Key size must be a multiple of 8.");
    return this.keyPair.generate(p, d.toString(16)), this.$cache = {}, this;
  }, a.prototype.importKey = function(p, d) {
    if (!p)
      throw Error("Empty key given");
    if (d && (d = h[d] || d), !Tp.detectAndImport(this.keyPair, p, d) && d === void 0)
      throw Error("Key format must be specified");
    return this.$cache = {}, this;
  }, a.prototype.exportKey = function(p) {
    return p = p || r, p = h[p] || p, this.$cache[p] || (this.$cache[p] = Tp.detectAndExport(this.keyPair, p)), this.$cache[p];
  }, a.prototype.isPrivate = function() {
    return this.keyPair.isPrivate();
  }, a.prototype.isPublic = function(p) {
    return this.keyPair.isPublic(p);
  }, a.prototype.isEmpty = function(p) {
    return !(this.keyPair.n || this.keyPair.e || this.keyPair.d);
  }, a.prototype.encrypt = function(p, d, b) {
    return this.$$encryptKey(!1, p, d, b);
  }, a.prototype.decrypt = function(p, d) {
    return this.$$decryptKey(!1, p, d);
  }, a.prototype.encryptPrivate = function(p, d, b) {
    return this.$$encryptKey(!0, p, d, b);
  }, a.prototype.decryptPublic = function(p, d) {
    return this.$$decryptKey(!0, p, d);
  }, a.prototype.$$encryptKey = function(p, d, b, g) {
    try {
      var w = this.keyPair.encrypt(this.$getDataForEncrypt(d, g), p);
      return b == "buffer" || !b ? w : w.toString(b);
    } catch (C) {
      throw Error("Error during encryption. Original error: " + C);
    }
  }, a.prototype.$$decryptKey = function(p, d, b) {
    try {
      d = Mr.isString(d) ? pe.Buffer.from(d, "base64") : d;
      var g = this.keyPair.decrypt(d, p);
      if (g === null)
        throw Error("Key decrypt method returns null.");
      return this.$getDecryptedData(g, b);
    } catch (w) {
      throw Error("Error during decryption (probably incorrect key). Original error: " + w);
    }
  }, a.prototype.sign = function(p, d, b) {
    if (!this.isPrivate())
      throw Error("This is not private key");
    var g = this.keyPair.sign(this.$getDataForEncrypt(p, b));
    return d && d != "buffer" && (g = g.toString(d)), g;
  }, a.prototype.verify = function(p, d, b, g) {
    if (!this.isPublic())
      throw Error("This is not public key");
    return g = !g || g == "buffer" ? null : g, this.keyPair.verify(this.$getDataForEncrypt(p, b), d, g);
  }, a.prototype.getKeySize = function() {
    return this.keyPair.keySize;
  }, a.prototype.getMaxMessageSize = function() {
    return this.keyPair.maxMessageLength;
  }, a.prototype.$getDataForEncrypt = function(p, d) {
    if (Mr.isString(p) || Mr.isNumber(p))
      return pe.Buffer.from("" + p, d || "utf8");
    if (pe.Buffer.isBuffer(p))
      return p;
    if (Mr.isObject(p))
      return pe.Buffer.from(JSON.stringify(p));
    throw Error("Unexpected data type");
  }, a.prototype.$getDecryptedData = function(p, d) {
    return d = d || "buffer", d == "buffer" ? p : d == "json" ? JSON.parse(p.toString()) : p.toString(d);
  }, a;
}();
const kC = /* @__PURE__ */ Gs(LC);
var ht = {
  // default options
  options: {
    usePureJavaScript: !1
  }
}, Oh = {}, UC = Oh, Mp = {};
Oh.encode = function(e, t, o) {
  if (typeof t != "string")
    throw new TypeError('"alphabet" must be a string.');
  if (o !== void 0 && typeof o != "number")
    throw new TypeError('"maxline" must be a number.');
  var r = "";
  if (!(e instanceof Uint8Array))
    r = FC(e, t);
  else {
    var h = 0, a = t.length, p = t.charAt(0), d = [0];
    for (h = 0; h < e.length; ++h) {
      for (var b = 0, g = e[h]; b < d.length; ++b)
        g += d[b] << 8, d[b] = g % a, g = g / a | 0;
      for (; g > 0; )
        d.push(g % a), g = g / a | 0;
    }
    for (h = 0; e[h] === 0 && h < e.length - 1; ++h)
      r += p;
    for (h = d.length - 1; h >= 0; --h)
      r += t[d[h]];
  }
  if (o) {
    var w = new RegExp(".{1," + o + "}", "g");
    r = r.match(w).join(`\r
`);
  }
  return r;
};
Oh.decode = function(e, t) {
  if (typeof e != "string")
    throw new TypeError('"input" must be a string.');
  if (typeof t != "string")
    throw new TypeError('"alphabet" must be a string.');
  var o = Mp[t];
  if (!o) {
    o = Mp[t] = [];
    for (var r = 0; r < t.length; ++r)
      o[t.charCodeAt(r)] = r;
  }
  e = e.replace(/\s/g, "");
  for (var h = t.length, a = t.charAt(0), p = [0], r = 0; r < e.length; r++) {
    var d = o[e.charCodeAt(r)];
    if (d === void 0)
      return;
    for (var b = 0, g = d; b < p.length; ++b)
      g += p[b] * h, p[b] = g & 255, g >>= 8;
    for (; g > 0; )
      p.push(g & 255), g >>= 8;
  }
  for (var w = 0; e[w] === a && w < e.length - 1; ++w)
    p.push(0);
  return typeof pe.Buffer < "u" ? pe.Buffer.from(p.reverse()) : new Uint8Array(p.reverse());
};
function FC(e, t) {
  var o = 0, r = t.length, h = t.charAt(0), a = [0];
  for (o = 0; o < e.length(); ++o) {
    for (var p = 0, d = e.at(o); p < a.length; ++p)
      d += a[p] << 8, a[p] = d % r, d = d / r | 0;
    for (; d > 0; )
      a.push(d % r), d = d / r | 0;
  }
  var b = "";
  for (o = 0; e.at(o) === 0 && o < e.length() - 1; ++o)
    b += h;
  for (o = a.length - 1; o >= 0; --o)
    b += t[a[o]];
  return b;
}
var Rp = ht, Np = UC, se = Rp.util = Rp.util || {};
(function() {
  if (typeof Ve < "u" && Ve.nextTick && !Ve.browser) {
    se.nextTick = Ve.nextTick, typeof setImmediate == "function" ? se.setImmediate = setImmediate : se.setImmediate = se.nextTick;
    return;
  }
  if (typeof setImmediate == "function") {
    se.setImmediate = function() {
      return setImmediate.apply(void 0, arguments);
    }, se.nextTick = function(p) {
      return setImmediate(p);
    };
    return;
  }
  if (se.setImmediate = function(p) {
    setTimeout(p, 0);
  }, typeof window < "u" && typeof window.postMessage == "function") {
    let p = function(d) {
      if (d.source === window && d.data === e) {
        d.stopPropagation();
        var b = t.slice();
        t.length = 0, b.forEach(function(g) {
          g();
        });
      }
    };
    var e = "forge.setImmediate", t = [];
    se.setImmediate = function(d) {
      t.push(d), t.length === 1 && window.postMessage(e, "*");
    }, window.addEventListener("message", p, !0);
  }
  if (typeof MutationObserver < "u") {
    var o = Date.now(), r = !0, h = document.createElement("div"), t = [];
    new MutationObserver(function() {
      var d = t.slice();
      t.length = 0, d.forEach(function(b) {
        b();
      });
    }).observe(h, { attributes: !0 });
    var a = se.setImmediate;
    se.setImmediate = function(d) {
      Date.now() - o > 15 ? (o = Date.now(), a(d)) : (t.push(d), t.length === 1 && h.setAttribute("a", r = !r));
    };
  }
  se.nextTick = se.setImmediate;
})();
se.isNodejs = typeof Ve < "u" && Ve.versions && Ve.versions.node;
se.globalScope = function() {
  return se.isNodejs ? Me : typeof self > "u" ? window : self;
}();
se.isArray = Array.isArray || function(e) {
  return Object.prototype.toString.call(e) === "[object Array]";
};
se.isArrayBuffer = function(e) {
  return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer;
};
se.isArrayBufferView = function(e) {
  return e && se.isArrayBuffer(e.buffer) && e.byteLength !== void 0;
};
function j0(e) {
  if (!(e === 8 || e === 16 || e === 24 || e === 32))
    throw new Error("Only 8, 16, 24, or 32 bits supported: " + e);
}
se.ByteBuffer = Ph;
function Ph(e) {
  if (this.data = "", this.read = 0, typeof e == "string")
    this.data = e;
  else if (se.isArrayBuffer(e) || se.isArrayBufferView(e))
    if (typeof pe.Buffer < "u" && e instanceof pe.Buffer)
      this.data = e.toString("binary");
    else {
      var t = new Uint8Array(e);
      try {
        this.data = String.fromCharCode.apply(null, t);
      } catch {
        for (var o = 0; o < t.length; ++o)
          this.putByte(t[o]);
      }
    }
  else
    (e instanceof Ph || typeof e == "object" && typeof e.data == "string" && typeof e.read == "number") && (this.data = e.data, this.read = e.read);
  this._constructedStringLength = 0;
}
se.ByteStringBuffer = Ph;
var qC = 4096;
se.ByteStringBuffer.prototype._optimizeConstructedString = function(e) {
  this._constructedStringLength += e, this._constructedStringLength > qC && (this.data.substr(0, 1), this._constructedStringLength = 0);
};
se.ByteStringBuffer.prototype.length = function() {
  return this.data.length - this.read;
};
se.ByteStringBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};
se.ByteStringBuffer.prototype.putByte = function(e) {
  return this.putBytes(String.fromCharCode(e));
};
se.ByteStringBuffer.prototype.fillWithByte = function(e, t) {
  e = String.fromCharCode(e);
  for (var o = this.data; t > 0; )
    t & 1 && (o += e), t >>>= 1, t > 0 && (e += e);
  return this.data = o, this._optimizeConstructedString(t), this;
};
se.ByteStringBuffer.prototype.putBytes = function(e) {
  return this.data += e, this._optimizeConstructedString(e.length), this;
};
se.ByteStringBuffer.prototype.putString = function(e) {
  return this.putBytes(se.encodeUtf8(e));
};
se.ByteStringBuffer.prototype.putInt16 = function(e) {
  return this.putBytes(
    String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e & 255)
  );
};
se.ByteStringBuffer.prototype.putInt24 = function(e) {
  return this.putBytes(
    String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e & 255)
  );
};
se.ByteStringBuffer.prototype.putInt32 = function(e) {
  return this.putBytes(
    String.fromCharCode(e >> 24 & 255) + String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e & 255)
  );
};
se.ByteStringBuffer.prototype.putInt16Le = function(e) {
  return this.putBytes(
    String.fromCharCode(e & 255) + String.fromCharCode(e >> 8 & 255)
  );
};
se.ByteStringBuffer.prototype.putInt24Le = function(e) {
  return this.putBytes(
    String.fromCharCode(e & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e >> 16 & 255)
  );
};
se.ByteStringBuffer.prototype.putInt32Le = function(e) {
  return this.putBytes(
    String.fromCharCode(e & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 24 & 255)
  );
};
se.ByteStringBuffer.prototype.putInt = function(e, t) {
  j0(t);
  var o = "";
  do
    t -= 8, o += String.fromCharCode(e >> t & 255);
  while (t > 0);
  return this.putBytes(o);
};
se.ByteStringBuffer.prototype.putSignedInt = function(e, t) {
  return e < 0 && (e += 2 << t - 1), this.putInt(e, t);
};
se.ByteStringBuffer.prototype.putBuffer = function(e) {
  return this.putBytes(e.getBytes());
};
se.ByteStringBuffer.prototype.getByte = function() {
  return this.data.charCodeAt(this.read++);
};
se.ByteStringBuffer.prototype.getInt16 = function() {
  var e = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
  return this.read += 2, e;
};
se.ByteStringBuffer.prototype.getInt24 = function() {
  var e = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
  return this.read += 3, e;
};
se.ByteStringBuffer.prototype.getInt32 = function() {
  var e = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
  return this.read += 4, e;
};
se.ByteStringBuffer.prototype.getInt16Le = function() {
  var e = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
  return this.read += 2, e;
};
se.ByteStringBuffer.prototype.getInt24Le = function() {
  var e = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
  return this.read += 3, e;
};
se.ByteStringBuffer.prototype.getInt32Le = function() {
  var e = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
  return this.read += 4, e;
};
se.ByteStringBuffer.prototype.getInt = function(e) {
  j0(e);
  var t = 0;
  do
    t = (t << 8) + this.data.charCodeAt(this.read++), e -= 8;
  while (e > 0);
  return t;
};
se.ByteStringBuffer.prototype.getSignedInt = function(e) {
  var t = this.getInt(e), o = 2 << e - 2;
  return t >= o && (t -= o << 1), t;
};
se.ByteStringBuffer.prototype.getBytes = function(e) {
  var t;
  return e ? (e = Math.min(this.length(), e), t = this.data.slice(this.read, this.read + e), this.read += e) : e === 0 ? t = "" : (t = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), t;
};
se.ByteStringBuffer.prototype.bytes = function(e) {
  return typeof e > "u" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + e);
};
se.ByteStringBuffer.prototype.at = function(e) {
  return this.data.charCodeAt(this.read + e);
};
se.ByteStringBuffer.prototype.setAt = function(e, t) {
  return this.data = this.data.substr(0, this.read + e) + String.fromCharCode(t) + this.data.substr(this.read + e + 1), this;
};
se.ByteStringBuffer.prototype.last = function() {
  return this.data.charCodeAt(this.data.length - 1);
};
se.ByteStringBuffer.prototype.copy = function() {
  var e = se.createBuffer(this.data);
  return e.read = this.read, e;
};
se.ByteStringBuffer.prototype.compact = function() {
  return this.read > 0 && (this.data = this.data.slice(this.read), this.read = 0), this;
};
se.ByteStringBuffer.prototype.clear = function() {
  return this.data = "", this.read = 0, this;
};
se.ByteStringBuffer.prototype.truncate = function(e) {
  var t = Math.max(0, this.length() - e);
  return this.data = this.data.substr(this.read, t), this.read = 0, this;
};
se.ByteStringBuffer.prototype.toHex = function() {
  for (var e = "", t = this.read; t < this.data.length; ++t) {
    var o = this.data.charCodeAt(t);
    o < 16 && (e += "0"), e += o.toString(16);
  }
  return e;
};
se.ByteStringBuffer.prototype.toString = function() {
  return se.decodeUtf8(this.bytes());
};
function VC(e, t) {
  t = t || {}, this.read = t.readOffset || 0, this.growSize = t.growSize || 1024;
  var o = se.isArrayBuffer(e), r = se.isArrayBufferView(e);
  if (o || r) {
    o ? this.data = new DataView(e) : this.data = new DataView(e.buffer, e.byteOffset, e.byteLength), this.write = "writeOffset" in t ? t.writeOffset : this.data.byteLength;
    return;
  }
  this.data = new DataView(new ArrayBuffer(0)), this.write = 0, e != null && this.putBytes(e), "writeOffset" in t && (this.write = t.writeOffset);
}
se.DataBuffer = VC;
se.DataBuffer.prototype.length = function() {
  return this.write - this.read;
};
se.DataBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};
se.DataBuffer.prototype.accommodate = function(e, t) {
  if (this.length() >= e)
    return this;
  t = Math.max(t || this.growSize, e);
  var o = new Uint8Array(
    this.data.buffer,
    this.data.byteOffset,
    this.data.byteLength
  ), r = new Uint8Array(this.length() + t);
  return r.set(o), this.data = new DataView(r.buffer), this;
};
se.DataBuffer.prototype.putByte = function(e) {
  return this.accommodate(1), this.data.setUint8(this.write++, e), this;
};
se.DataBuffer.prototype.fillWithByte = function(e, t) {
  this.accommodate(t);
  for (var o = 0; o < t; ++o)
    this.data.setUint8(e);
  return this;
};
se.DataBuffer.prototype.putBytes = function(e, t) {
  if (se.isArrayBufferView(e)) {
    var o = new Uint8Array(e.buffer, e.byteOffset, e.byteLength), r = o.byteLength - o.byteOffset;
    this.accommodate(r);
    var h = new Uint8Array(this.data.buffer, this.write);
    return h.set(o), this.write += r, this;
  }
  if (se.isArrayBuffer(e)) {
    var o = new Uint8Array(e);
    this.accommodate(o.byteLength);
    var h = new Uint8Array(this.data.buffer);
    return h.set(o, this.write), this.write += o.byteLength, this;
  }
  if (e instanceof se.DataBuffer || typeof e == "object" && typeof e.read == "number" && typeof e.write == "number" && se.isArrayBufferView(e.data)) {
    var o = new Uint8Array(e.data.byteLength, e.read, e.length());
    this.accommodate(o.byteLength);
    var h = new Uint8Array(e.data.byteLength, this.write);
    return h.set(o), this.write += o.byteLength, this;
  }
  if (e instanceof se.ByteStringBuffer && (e = e.data, t = "binary"), t = t || "binary", typeof e == "string") {
    var a;
    if (t === "hex")
      return this.accommodate(Math.ceil(e.length / 2)), a = new Uint8Array(this.data.buffer, this.write), this.write += se.binary.hex.decode(e, a, this.write), this;
    if (t === "base64")
      return this.accommodate(Math.ceil(e.length / 4) * 3), a = new Uint8Array(this.data.buffer, this.write), this.write += se.binary.base64.decode(e, a, this.write), this;
    if (t === "utf8" && (e = se.encodeUtf8(e), t = "binary"), t === "binary" || t === "raw")
      return this.accommodate(e.length), a = new Uint8Array(this.data.buffer, this.write), this.write += se.binary.raw.decode(a), this;
    if (t === "utf16")
      return this.accommodate(e.length * 2), a = new Uint16Array(this.data.buffer, this.write), this.write += se.text.utf16.encode(a), this;
    throw new Error("Invalid encoding: " + t);
  }
  throw Error("Invalid parameter: " + e);
};
se.DataBuffer.prototype.putBuffer = function(e) {
  return this.putBytes(e), e.clear(), this;
};
se.DataBuffer.prototype.putString = function(e) {
  return this.putBytes(e, "utf16");
};
se.DataBuffer.prototype.putInt16 = function(e) {
  return this.accommodate(2), this.data.setInt16(this.write, e), this.write += 2, this;
};
se.DataBuffer.prototype.putInt24 = function(e) {
  return this.accommodate(3), this.data.setInt16(this.write, e >> 8 & 65535), this.data.setInt8(this.write, e >> 16 & 255), this.write += 3, this;
};
se.DataBuffer.prototype.putInt32 = function(e) {
  return this.accommodate(4), this.data.setInt32(this.write, e), this.write += 4, this;
};
se.DataBuffer.prototype.putInt16Le = function(e) {
  return this.accommodate(2), this.data.setInt16(this.write, e, !0), this.write += 2, this;
};
se.DataBuffer.prototype.putInt24Le = function(e) {
  return this.accommodate(3), this.data.setInt8(this.write, e >> 16 & 255), this.data.setInt16(this.write, e >> 8 & 65535, !0), this.write += 3, this;
};
se.DataBuffer.prototype.putInt32Le = function(e) {
  return this.accommodate(4), this.data.setInt32(this.write, e, !0), this.write += 4, this;
};
se.DataBuffer.prototype.putInt = function(e, t) {
  j0(t), this.accommodate(t / 8);
  do
    t -= 8, this.data.setInt8(this.write++, e >> t & 255);
  while (t > 0);
  return this;
};
se.DataBuffer.prototype.putSignedInt = function(e, t) {
  return j0(t), this.accommodate(t / 8), e < 0 && (e += 2 << t - 1), this.putInt(e, t);
};
se.DataBuffer.prototype.getByte = function() {
  return this.data.getInt8(this.read++);
};
se.DataBuffer.prototype.getInt16 = function() {
  var e = this.data.getInt16(this.read);
  return this.read += 2, e;
};
se.DataBuffer.prototype.getInt24 = function() {
  var e = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
  return this.read += 3, e;
};
se.DataBuffer.prototype.getInt32 = function() {
  var e = this.data.getInt32(this.read);
  return this.read += 4, e;
};
se.DataBuffer.prototype.getInt16Le = function() {
  var e = this.data.getInt16(this.read, !0);
  return this.read += 2, e;
};
se.DataBuffer.prototype.getInt24Le = function() {
  var e = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, !0) << 8;
  return this.read += 3, e;
};
se.DataBuffer.prototype.getInt32Le = function() {
  var e = this.data.getInt32(this.read, !0);
  return this.read += 4, e;
};
se.DataBuffer.prototype.getInt = function(e) {
  j0(e);
  var t = 0;
  do
    t = (t << 8) + this.data.getInt8(this.read++), e -= 8;
  while (e > 0);
  return t;
};
se.DataBuffer.prototype.getSignedInt = function(e) {
  var t = this.getInt(e), o = 2 << e - 2;
  return t >= o && (t -= o << 1), t;
};
se.DataBuffer.prototype.getBytes = function(e) {
  var t;
  return e ? (e = Math.min(this.length(), e), t = this.data.slice(this.read, this.read + e), this.read += e) : e === 0 ? t = "" : (t = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), t;
};
se.DataBuffer.prototype.bytes = function(e) {
  return typeof e > "u" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + e);
};
se.DataBuffer.prototype.at = function(e) {
  return this.data.getUint8(this.read + e);
};
se.DataBuffer.prototype.setAt = function(e, t) {
  return this.data.setUint8(e, t), this;
};
se.DataBuffer.prototype.last = function() {
  return this.data.getUint8(this.write - 1);
};
se.DataBuffer.prototype.copy = function() {
  return new se.DataBuffer(this);
};
se.DataBuffer.prototype.compact = function() {
  if (this.read > 0) {
    var e = new Uint8Array(this.data.buffer, this.read), t = new Uint8Array(e.byteLength);
    t.set(e), this.data = new DataView(t), this.write -= this.read, this.read = 0;
  }
  return this;
};
se.DataBuffer.prototype.clear = function() {
  return this.data = new DataView(new ArrayBuffer(0)), this.read = this.write = 0, this;
};
se.DataBuffer.prototype.truncate = function(e) {
  return this.write = Math.max(0, this.length() - e), this.read = Math.min(this.read, this.write), this;
};
se.DataBuffer.prototype.toHex = function() {
  for (var e = "", t = this.read; t < this.data.byteLength; ++t) {
    var o = this.data.getUint8(t);
    o < 16 && (e += "0"), e += o.toString(16);
  }
  return e;
};
se.DataBuffer.prototype.toString = function(e) {
  var t = new Uint8Array(this.data, this.read, this.length());
  if (e = e || "utf8", e === "binary" || e === "raw")
    return se.binary.raw.encode(t);
  if (e === "hex")
    return se.binary.hex.encode(t);
  if (e === "base64")
    return se.binary.base64.encode(t);
  if (e === "utf8")
    return se.text.utf8.decode(t);
  if (e === "utf16")
    return se.text.utf16.decode(t);
  throw new Error("Invalid encoding: " + e);
};
se.createBuffer = function(e, t) {
  return t = t || "raw", e !== void 0 && t === "utf8" && (e = se.encodeUtf8(e)), new se.ByteBuffer(e);
};
se.fillString = function(e, t) {
  for (var o = ""; t > 0; )
    t & 1 && (o += e), t >>>= 1, t > 0 && (e += e);
  return o;
};
se.xorBytes = function(e, t, o) {
  for (var r = "", h = "", a = "", p = 0, d = 0; o > 0; --o, ++p)
    h = e.charCodeAt(p) ^ t.charCodeAt(p), d >= 10 && (r += a, a = "", d = 0), a += String.fromCharCode(h), ++d;
  return r += a, r;
};
se.hexToBytes = function(e) {
  var t = "", o = 0;
  for (e.length & !0 && (o = 1, t += String.fromCharCode(parseInt(e[0], 16))); o < e.length; o += 2)
    t += String.fromCharCode(parseInt(e.substr(o, 2), 16));
  return t;
};
se.bytesToHex = function(e) {
  return se.createBuffer(e).toHex();
};
se.int32ToBytes = function(e) {
  return String.fromCharCode(e >> 24 & 255) + String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e & 255);
};
var gn = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", mn = [
  /*43 -43 = 0*/
  /*'+',  1,  2,  3,'/' */
  62,
  -1,
  -1,
  -1,
  63,
  /*'0','1','2','3','4','5','6','7','8','9' */
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  /*15, 16, 17,'=', 19, 20, 21 */
  -1,
  -1,
  -1,
  64,
  -1,
  -1,
  -1,
  /*65 - 43 = 22*/
  /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  /*91 - 43 = 48 */
  /*48, 49, 50, 51, 52, 53 */
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  /*97 - 43 = 54*/
  /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51
], d2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
se.encode64 = function(e, t) {
  for (var o = "", r = "", h, a, p, d = 0; d < e.length; )
    h = e.charCodeAt(d++), a = e.charCodeAt(d++), p = e.charCodeAt(d++), o += gn.charAt(h >> 2), o += gn.charAt((h & 3) << 4 | a >> 4), isNaN(a) ? o += "==" : (o += gn.charAt((a & 15) << 2 | p >> 6), o += isNaN(p) ? "=" : gn.charAt(p & 63)), t && o.length > t && (r += o.substr(0, t) + `\r
`, o = o.substr(t));
  return r += o, r;
};
se.decode64 = function(e) {
  e = e.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  for (var t = "", o, r, h, a, p = 0; p < e.length; )
    o = mn[e.charCodeAt(p++) - 43], r = mn[e.charCodeAt(p++) - 43], h = mn[e.charCodeAt(p++) - 43], a = mn[e.charCodeAt(p++) - 43], t += String.fromCharCode(o << 2 | r >> 4), h !== 64 && (t += String.fromCharCode((r & 15) << 4 | h >> 2), a !== 64 && (t += String.fromCharCode((h & 3) << 6 | a)));
  return t;
};
se.encodeUtf8 = function(e) {
  return unescape(encodeURIComponent(e));
};
se.decodeUtf8 = function(e) {
  return decodeURIComponent(escape(e));
};
se.binary = {
  raw: {},
  hex: {},
  base64: {},
  base58: {},
  baseN: {
    encode: Np.encode,
    decode: Np.decode
  }
};
se.binary.raw.encode = function(e) {
  return String.fromCharCode.apply(null, e);
};
se.binary.raw.decode = function(e, t, o) {
  var r = t;
  r || (r = new Uint8Array(e.length)), o = o || 0;
  for (var h = o, a = 0; a < e.length; ++a)
    r[h++] = e.charCodeAt(a);
  return t ? h - o : r;
};
se.binary.hex.encode = se.bytesToHex;
se.binary.hex.decode = function(e, t, o) {
  var r = t;
  r || (r = new Uint8Array(Math.ceil(e.length / 2))), o = o || 0;
  var h = 0, a = o;
  for (e.length & 1 && (h = 1, r[a++] = parseInt(e[0], 16)); h < e.length; h += 2)
    r[a++] = parseInt(e.substr(h, 2), 16);
  return t ? a - o : r;
};
se.binary.base64.encode = function(e, t) {
  for (var o = "", r = "", h, a, p, d = 0; d < e.byteLength; )
    h = e[d++], a = e[d++], p = e[d++], o += gn.charAt(h >> 2), o += gn.charAt((h & 3) << 4 | a >> 4), isNaN(a) ? o += "==" : (o += gn.charAt((a & 15) << 2 | p >> 6), o += isNaN(p) ? "=" : gn.charAt(p & 63)), t && o.length > t && (r += o.substr(0, t) + `\r
`, o = o.substr(t));
  return r += o, r;
};
se.binary.base64.decode = function(e, t, o) {
  var r = t;
  r || (r = new Uint8Array(Math.ceil(e.length / 4) * 3)), e = e.replace(/[^A-Za-z0-9\+\/\=]/g, ""), o = o || 0;
  for (var h, a, p, d, b = 0, g = o; b < e.length; )
    h = mn[e.charCodeAt(b++) - 43], a = mn[e.charCodeAt(b++) - 43], p = mn[e.charCodeAt(b++) - 43], d = mn[e.charCodeAt(b++) - 43], r[g++] = h << 2 | a >> 4, p !== 64 && (r[g++] = (a & 15) << 4 | p >> 2, d !== 64 && (r[g++] = (p & 3) << 6 | d));
  return t ? g - o : r.subarray(0, g);
};
se.binary.base58.encode = function(e, t) {
  return se.binary.baseN.encode(e, d2, t);
};
se.binary.base58.decode = function(e, t) {
  return se.binary.baseN.decode(e, d2, t);
};
se.text = {
  utf8: {},
  utf16: {}
};
se.text.utf8.encode = function(e, t, o) {
  e = se.encodeUtf8(e);
  var r = t;
  r || (r = new Uint8Array(e.length)), o = o || 0;
  for (var h = o, a = 0; a < e.length; ++a)
    r[h++] = e.charCodeAt(a);
  return t ? h - o : r;
};
se.text.utf8.decode = function(e) {
  return se.decodeUtf8(String.fromCharCode.apply(null, e));
};
se.text.utf16.encode = function(e, t, o) {
  var r = t;
  r || (r = new Uint8Array(e.length * 2));
  var h = new Uint16Array(r.buffer);
  o = o || 0;
  for (var a = o, p = o, d = 0; d < e.length; ++d)
    h[p++] = e.charCodeAt(d), a += 2;
  return t ? a - o : r;
};
se.text.utf16.decode = function(e) {
  return String.fromCharCode.apply(null, new Uint16Array(e.buffer));
};
se.deflate = function(e, t, o) {
  if (t = se.decode64(e.deflate(se.encode64(t)).rval), o) {
    var r = 2, h = t.charCodeAt(1);
    h & 32 && (r = 6), t = t.substring(r, t.length - 4);
  }
  return t;
};
se.inflate = function(e, t, o) {
  var r = e.inflate(se.encode64(t)).rval;
  return r === null ? null : se.decode64(r);
};
var Lh = function(e, t, o) {
  if (!e)
    throw new Error("WebStorage not available.");
  var r;
  if (o === null ? r = e.removeItem(t) : (o = se.encode64(JSON.stringify(o)), r = e.setItem(t, o)), typeof r < "u" && r.rval !== !0) {
    var h = new Error(r.error.message);
    throw h.id = r.error.id, h.name = r.error.name, h;
  }
}, kh = function(e, t) {
  if (!e)
    throw new Error("WebStorage not available.");
  var o = e.getItem(t);
  if (e.init)
    if (o.rval === null) {
      if (o.error) {
        var r = new Error(o.error.message);
        throw r.id = o.error.id, r.name = o.error.name, r;
      }
      o = null;
    } else
      o = o.rval;
  return o !== null && (o = JSON.parse(se.decode64(o))), o;
}, KC = function(e, t, o, r) {
  var h = kh(e, t);
  h === null && (h = {}), h[o] = r, Lh(e, t, h);
}, $C = function(e, t, o) {
  var r = kh(e, t);
  return r !== null && (r = o in r ? r[o] : null), r;
}, HC = function(e, t, o) {
  var r = kh(e, t);
  if (r !== null && o in r) {
    delete r[o];
    var h = !0;
    for (var a in r) {
      h = !1;
      break;
    }
    h && (r = null), Lh(e, t, r);
  }
}, GC = function(e, t) {
  Lh(e, t, null);
}, Of = function(e, t, o) {
  var r = null;
  typeof o > "u" && (o = ["web", "flash"]);
  var h, a = !1, p = null;
  for (var d in o) {
    h = o[d];
    try {
      if (h === "flash" || h === "both") {
        if (t[0] === null)
          throw new Error("Flash local storage not available.");
        r = e.apply(this, t), a = h === "flash";
      }
      (h === "web" || h === "both") && (t[0] = localStorage, r = e.apply(this, t), a = !0);
    } catch (b) {
      p = b;
    }
    if (a)
      break;
  }
  if (!a)
    throw p;
  return r;
};
se.setItem = function(e, t, o, r, h) {
  Of(KC, arguments, h);
};
se.getItem = function(e, t, o, r) {
  return Of($C, arguments, r);
};
se.removeItem = function(e, t, o, r) {
  Of(HC, arguments, r);
};
se.clearItems = function(e, t, o) {
  Of(GC, arguments, o);
};
se.isEmpty = function(e) {
  for (var t in e)
    if (e.hasOwnProperty(t))
      return !1;
  return !0;
};
se.format = function(e) {
  for (var t = /%./g, o, r, h = 0, a = [], p = 0; o = t.exec(e); ) {
    r = e.substring(p, t.lastIndex - 2), r.length > 0 && a.push(r), p = t.lastIndex;
    var d = o[0][1];
    switch (d) {
      case "s":
      case "o":
        h < arguments.length ? a.push(arguments[h++ + 1]) : a.push("<?>");
        break;
      case "%":
        a.push("%");
        break;
      default:
        a.push("<%" + d + "?>");
    }
  }
  return a.push(e.substring(p)), a.join("");
};
se.formatNumber = function(e, t, o, r) {
  var h = e, a = isNaN(t = Math.abs(t)) ? 2 : t, p = o === void 0 ? "," : o, d = r === void 0 ? "." : r, b = h < 0 ? "-" : "", g = parseInt(h = Math.abs(+h || 0).toFixed(a), 10) + "", w = g.length > 3 ? g.length % 3 : 0;
  return b + (w ? g.substr(0, w) + d : "") + g.substr(w).replace(/(\d{3})(?=\d)/g, "$1" + d) + (a ? p + Math.abs(h - g).toFixed(a).slice(2) : "");
};
se.formatSize = function(e) {
  return e >= 1073741824 ? e = se.formatNumber(e / 1073741824, 2, ".", "") + " GiB" : e >= 1048576 ? e = se.formatNumber(e / 1048576, 2, ".", "") + " MiB" : e >= 1024 ? e = se.formatNumber(e / 1024, 0) + " KiB" : e = se.formatNumber(e, 0) + " bytes", e;
};
se.bytesFromIP = function(e) {
  return e.indexOf(".") !== -1 ? se.bytesFromIPv4(e) : e.indexOf(":") !== -1 ? se.bytesFromIPv6(e) : null;
};
se.bytesFromIPv4 = function(e) {
  if (e = e.split("."), e.length !== 4)
    return null;
  for (var t = se.createBuffer(), o = 0; o < e.length; ++o) {
    var r = parseInt(e[o], 10);
    if (isNaN(r))
      return null;
    t.putByte(r);
  }
  return t.getBytes();
};
se.bytesFromIPv6 = function(e) {
  var t = 0;
  e = e.split(":").filter(function(p) {
    return p.length === 0 && ++t, !0;
  });
  for (var o = (8 - e.length + t) * 2, r = se.createBuffer(), h = 0; h < 8; ++h) {
    if (!e[h] || e[h].length === 0) {
      r.fillWithByte(0, o), o = 0;
      continue;
    }
    var a = se.hexToBytes(e[h]);
    a.length < 2 && r.putByte(0), r.putBytes(a);
  }
  return r.getBytes();
};
se.bytesToIP = function(e) {
  return e.length === 4 ? se.bytesToIPv4(e) : e.length === 16 ? se.bytesToIPv6(e) : null;
};
se.bytesToIPv4 = function(e) {
  if (e.length !== 4)
    return null;
  for (var t = [], o = 0; o < e.length; ++o)
    t.push(e.charCodeAt(o));
  return t.join(".");
};
se.bytesToIPv6 = function(e) {
  if (e.length !== 16)
    return null;
  for (var t = [], o = [], r = 0, h = 0; h < e.length; h += 2) {
    for (var a = se.bytesToHex(e[h] + e[h + 1]); a[0] === "0" && a !== "0"; )
      a = a.substr(1);
    if (a === "0") {
      var p = o[o.length - 1], d = t.length;
      !p || d !== p.end + 1 ? o.push({ start: d, end: d }) : (p.end = d, p.end - p.start > o[r].end - o[r].start && (r = o.length - 1));
    }
    t.push(a);
  }
  if (o.length > 0) {
    var b = o[r];
    b.end - b.start > 0 && (t.splice(b.start, b.end - b.start + 1, ""), b.start === 0 && t.unshift(""), b.end === 7 && t.push(""));
  }
  return t.join(":");
};
se.estimateCores = function(e, t) {
  if (typeof e == "function" && (t = e, e = {}), e = e || {}, "cores" in se && !e.update)
    return t(null, se.cores);
  if (typeof navigator < "u" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0)
    return se.cores = navigator.hardwareConcurrency, t(null, se.cores);
  if (typeof Worker > "u")
    return se.cores = 1, t(null, se.cores);
  if (typeof Blob > "u")
    return se.cores = 2, t(null, se.cores);
  var o = URL.createObjectURL(new Blob([
    "(",
    (function() {
      self.addEventListener("message", function(p) {
        var d = Date.now(), b = d + 4;
        self.postMessage({ st: d, et: b });
      });
    }).toString(),
    ")()"
  ], { type: "application/javascript" }));
  r([], 5, 16);
  function r(p, d, b) {
    if (d === 0) {
      var g = Math.floor(p.reduce(function(w, C) {
        return w + C;
      }, 0) / p.length);
      return se.cores = Math.max(1, g), URL.revokeObjectURL(o), t(null, se.cores);
    }
    h(b, function(w, C) {
      p.push(a(b, C)), r(p, d - 1, b);
    });
  }
  function h(p, d) {
    for (var b = [], g = [], w = 0; w < p; ++w) {
      var C = new Worker(o);
      C.addEventListener("message", function(T) {
        if (g.push(T.data), g.length === p) {
          for (var k = 0; k < p; ++k)
            b[k].terminate();
          d(null, g);
        }
      }), b.push(C);
    }
    for (var w = 0; w < p; ++w)
      b[w].postMessage(w);
  }
  function a(p, d) {
    for (var b = [], g = 0; g < p; ++g)
      for (var w = d[g], C = b[g] = [], T = 0; T < p; ++T)
        if (g !== T) {
          var k = d[T];
          (w.st > k.st && w.st < k.et || k.st > w.st && k.st < w.et) && C.push(T);
        }
    return b.reduce(function(q, O) {
      return Math.max(q, O.length);
    }, 0);
  }
};
var Jt = ht;
Jt.cipher = Jt.cipher || {};
Jt.cipher.algorithms = Jt.cipher.algorithms || {};
Jt.cipher.createCipher = function(e, t) {
  var o = e;
  if (typeof o == "string" && (o = Jt.cipher.getAlgorithm(o), o && (o = o())), !o)
    throw new Error("Unsupported algorithm: " + e);
  return new Jt.cipher.BlockCipher({
    algorithm: o,
    key: t,
    decrypt: !1
  });
};
Jt.cipher.createDecipher = function(e, t) {
  var o = e;
  if (typeof o == "string" && (o = Jt.cipher.getAlgorithm(o), o && (o = o())), !o)
    throw new Error("Unsupported algorithm: " + e);
  return new Jt.cipher.BlockCipher({
    algorithm: o,
    key: t,
    decrypt: !0
  });
};
Jt.cipher.registerAlgorithm = function(e, t) {
  e = e.toUpperCase(), Jt.cipher.algorithms[e] = t;
};
Jt.cipher.getAlgorithm = function(e) {
  return e = e.toUpperCase(), e in Jt.cipher.algorithms ? Jt.cipher.algorithms[e] : null;
};
var Uh = Jt.cipher.BlockCipher = function(e) {
  this.algorithm = e.algorithm, this.mode = this.algorithm.mode, this.blockSize = this.mode.blockSize, this._finish = !1, this._input = null, this.output = null, this._op = e.decrypt ? this.mode.decrypt : this.mode.encrypt, this._decrypt = e.decrypt, this.algorithm.initialize(e);
};
Uh.prototype.start = function(e) {
  e = e || {};
  var t = {};
  for (var o in e)
    t[o] = e[o];
  t.decrypt = this._decrypt, this._finish = !1, this._input = Jt.util.createBuffer(), this.output = e.output || Jt.util.createBuffer(), this.mode.start(t);
};
Uh.prototype.update = function(e) {
  for (e && this._input.putBuffer(e); !this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish; )
    ;
  this._input.compact();
};
Uh.prototype.finish = function(e) {
  e && (this.mode.name === "ECB" || this.mode.name === "CBC") && (this.mode.pad = function(o) {
    return e(this.blockSize, o, !1);
  }, this.mode.unpad = function(o) {
    return e(this.blockSize, o, !0);
  });
  var t = {};
  return t.decrypt = this._decrypt, t.overflow = this._input.length() % this.blockSize, !(!this._decrypt && this.mode.pad && !this.mode.pad(this._input, t) || (this._finish = !0, this.update(), this._decrypt && this.mode.unpad && !this.mode.unpad(this.output, t)) || this.mode.afterFinish && !this.mode.afterFinish(this.output, t));
};
var Qt = ht;
Qt.cipher = Qt.cipher || {};
var pt = Qt.cipher.modes = Qt.cipher.modes || {};
pt.ecb = function(e) {
  e = e || {}, this.name = "ECB", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
};
pt.ecb.prototype.start = function(e) {
};
pt.ecb.prototype.encrypt = function(e, t, o) {
  if (e.length() < this.blockSize && !(o && e.length() > 0))
    return !0;
  for (var r = 0; r < this._ints; ++r)
    this._inBlock[r] = e.getInt32();
  this.cipher.encrypt(this._inBlock, this._outBlock);
  for (var r = 0; r < this._ints; ++r)
    t.putInt32(this._outBlock[r]);
};
pt.ecb.prototype.decrypt = function(e, t, o) {
  if (e.length() < this.blockSize && !(o && e.length() > 0))
    return !0;
  for (var r = 0; r < this._ints; ++r)
    this._inBlock[r] = e.getInt32();
  this.cipher.decrypt(this._inBlock, this._outBlock);
  for (var r = 0; r < this._ints; ++r)
    t.putInt32(this._outBlock[r]);
};
pt.ecb.prototype.pad = function(e, t) {
  var o = e.length() === this.blockSize ? this.blockSize : this.blockSize - e.length();
  return e.fillWithByte(o, o), !0;
};
pt.ecb.prototype.unpad = function(e, t) {
  if (t.overflow > 0)
    return !1;
  var o = e.length(), r = e.at(o - 1);
  return r > this.blockSize << 2 ? !1 : (e.truncate(r), !0);
};
pt.cbc = function(e) {
  e = e || {}, this.name = "CBC", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
};
pt.cbc.prototype.start = function(e) {
  if (e.iv === null) {
    if (!this._prev)
      throw new Error("Invalid IV parameter.");
    this._iv = this._prev.slice(0);
  } else if ("iv" in e)
    this._iv = Pf(e.iv, this.blockSize), this._prev = this._iv.slice(0);
  else
    throw new Error("Invalid IV parameter.");
};
pt.cbc.prototype.encrypt = function(e, t, o) {
  if (e.length() < this.blockSize && !(o && e.length() > 0))
    return !0;
  for (var r = 0; r < this._ints; ++r)
    this._inBlock[r] = this._prev[r] ^ e.getInt32();
  this.cipher.encrypt(this._inBlock, this._outBlock);
  for (var r = 0; r < this._ints; ++r)
    t.putInt32(this._outBlock[r]);
  this._prev = this._outBlock;
};
pt.cbc.prototype.decrypt = function(e, t, o) {
  if (e.length() < this.blockSize && !(o && e.length() > 0))
    return !0;
  for (var r = 0; r < this._ints; ++r)
    this._inBlock[r] = e.getInt32();
  this.cipher.decrypt(this._inBlock, this._outBlock);
  for (var r = 0; r < this._ints; ++r)
    t.putInt32(this._prev[r] ^ this._outBlock[r]);
  this._prev = this._inBlock.slice(0);
};
pt.cbc.prototype.pad = function(e, t) {
  var o = e.length() === this.blockSize ? this.blockSize : this.blockSize - e.length();
  return e.fillWithByte(o, o), !0;
};
pt.cbc.prototype.unpad = function(e, t) {
  if (t.overflow > 0)
    return !1;
  var o = e.length(), r = e.at(o - 1);
  return r > this.blockSize << 2 ? !1 : (e.truncate(r), !0);
};
pt.cfb = function(e) {
  e = e || {}, this.name = "CFB", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialBlock = new Array(this._ints), this._partialOutput = Qt.util.createBuffer(), this._partialBytes = 0;
};
pt.cfb.prototype.start = function(e) {
  if (!("iv" in e))
    throw new Error("Invalid IV parameter.");
  this._iv = Pf(e.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
};
pt.cfb.prototype.encrypt = function(e, t, o) {
  var r = e.length();
  if (r === 0)
    return !0;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && r >= this.blockSize) {
    for (var h = 0; h < this._ints; ++h)
      this._inBlock[h] = e.getInt32() ^ this._outBlock[h], t.putInt32(this._inBlock[h]);
    return;
  }
  var a = (this.blockSize - r) % this.blockSize;
  a > 0 && (a = this.blockSize - a), this._partialOutput.clear();
  for (var h = 0; h < this._ints; ++h)
    this._partialBlock[h] = e.getInt32() ^ this._outBlock[h], this._partialOutput.putInt32(this._partialBlock[h]);
  if (a > 0)
    e.read -= this.blockSize;
  else
    for (var h = 0; h < this._ints; ++h)
      this._inBlock[h] = this._partialBlock[h];
  if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), a > 0 && !o)
    return t.putBytes(this._partialOutput.getBytes(
      a - this._partialBytes
    )), this._partialBytes = a, !0;
  t.putBytes(this._partialOutput.getBytes(
    r - this._partialBytes
  )), this._partialBytes = 0;
};
pt.cfb.prototype.decrypt = function(e, t, o) {
  var r = e.length();
  if (r === 0)
    return !0;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && r >= this.blockSize) {
    for (var h = 0; h < this._ints; ++h)
      this._inBlock[h] = e.getInt32(), t.putInt32(this._inBlock[h] ^ this._outBlock[h]);
    return;
  }
  var a = (this.blockSize - r) % this.blockSize;
  a > 0 && (a = this.blockSize - a), this._partialOutput.clear();
  for (var h = 0; h < this._ints; ++h)
    this._partialBlock[h] = e.getInt32(), this._partialOutput.putInt32(this._partialBlock[h] ^ this._outBlock[h]);
  if (a > 0)
    e.read -= this.blockSize;
  else
    for (var h = 0; h < this._ints; ++h)
      this._inBlock[h] = this._partialBlock[h];
  if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), a > 0 && !o)
    return t.putBytes(this._partialOutput.getBytes(
      a - this._partialBytes
    )), this._partialBytes = a, !0;
  t.putBytes(this._partialOutput.getBytes(
    r - this._partialBytes
  )), this._partialBytes = 0;
};
pt.ofb = function(e) {
  e = e || {}, this.name = "OFB", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = Qt.util.createBuffer(), this._partialBytes = 0;
};
pt.ofb.prototype.start = function(e) {
  if (!("iv" in e))
    throw new Error("Invalid IV parameter.");
  this._iv = Pf(e.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
};
pt.ofb.prototype.encrypt = function(e, t, o) {
  var r = e.length();
  if (e.length() === 0)
    return !0;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && r >= this.blockSize) {
    for (var h = 0; h < this._ints; ++h)
      t.putInt32(e.getInt32() ^ this._outBlock[h]), this._inBlock[h] = this._outBlock[h];
    return;
  }
  var a = (this.blockSize - r) % this.blockSize;
  a > 0 && (a = this.blockSize - a), this._partialOutput.clear();
  for (var h = 0; h < this._ints; ++h)
    this._partialOutput.putInt32(e.getInt32() ^ this._outBlock[h]);
  if (a > 0)
    e.read -= this.blockSize;
  else
    for (var h = 0; h < this._ints; ++h)
      this._inBlock[h] = this._outBlock[h];
  if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), a > 0 && !o)
    return t.putBytes(this._partialOutput.getBytes(
      a - this._partialBytes
    )), this._partialBytes = a, !0;
  t.putBytes(this._partialOutput.getBytes(
    r - this._partialBytes
  )), this._partialBytes = 0;
};
pt.ofb.prototype.decrypt = pt.ofb.prototype.encrypt;
pt.ctr = function(e) {
  e = e || {}, this.name = "CTR", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = Qt.util.createBuffer(), this._partialBytes = 0;
};
pt.ctr.prototype.start = function(e) {
  if (!("iv" in e))
    throw new Error("Invalid IV parameter.");
  this._iv = Pf(e.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
};
pt.ctr.prototype.encrypt = function(e, t, o) {
  var r = e.length();
  if (r === 0)
    return !0;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && r >= this.blockSize)
    for (var h = 0; h < this._ints; ++h)
      t.putInt32(e.getInt32() ^ this._outBlock[h]);
  else {
    var a = (this.blockSize - r) % this.blockSize;
    a > 0 && (a = this.blockSize - a), this._partialOutput.clear();
    for (var h = 0; h < this._ints; ++h)
      this._partialOutput.putInt32(e.getInt32() ^ this._outBlock[h]);
    if (a > 0 && (e.read -= this.blockSize), this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), a > 0 && !o)
      return t.putBytes(this._partialOutput.getBytes(
        a - this._partialBytes
      )), this._partialBytes = a, !0;
    t.putBytes(this._partialOutput.getBytes(
      r - this._partialBytes
    )), this._partialBytes = 0;
  }
  Lf(this._inBlock);
};
pt.ctr.prototype.decrypt = pt.ctr.prototype.encrypt;
pt.gcm = function(e) {
  e = e || {}, this.name = "GCM", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints), this._partialOutput = Qt.util.createBuffer(), this._partialBytes = 0, this._R = 3774873600;
};
pt.gcm.prototype.start = function(e) {
  if (!("iv" in e))
    throw new Error("Invalid IV parameter.");
  var t = Qt.util.createBuffer(e.iv);
  this._cipherLength = 0;
  var o;
  if ("additionalData" in e ? o = Qt.util.createBuffer(e.additionalData) : o = Qt.util.createBuffer(), "tagLength" in e ? this._tagLength = e.tagLength : this._tagLength = 128, this._tag = null, e.decrypt && (this._tag = Qt.util.createBuffer(e.tag).getBytes(), this._tag.length !== this._tagLength / 8))
    throw new Error("Authentication tag does not match tag length.");
  this._hashBlock = new Array(this._ints), this.tag = null, this._hashSubkey = new Array(this._ints), this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey), this.componentBits = 4, this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
  var r = t.length();
  if (r === 12)
    this._j0 = [t.getInt32(), t.getInt32(), t.getInt32(), 1];
  else {
    for (this._j0 = [0, 0, 0, 0]; t.length() > 0; )
      this._j0 = this.ghash(
        this._hashSubkey,
        this._j0,
        [t.getInt32(), t.getInt32(), t.getInt32(), t.getInt32()]
      );
    this._j0 = this.ghash(
      this._hashSubkey,
      this._j0,
      [0, 0].concat(yc(r * 8))
    );
  }
  this._inBlock = this._j0.slice(0), Lf(this._inBlock), this._partialBytes = 0, o = Qt.util.createBuffer(o), this._aDataLength = yc(o.length() * 8);
  var h = o.length() % this.blockSize;
  for (h && o.fillWithByte(0, this.blockSize - h), this._s = [0, 0, 0, 0]; o.length() > 0; )
    this._s = this.ghash(this._hashSubkey, this._s, [
      o.getInt32(),
      o.getInt32(),
      o.getInt32(),
      o.getInt32()
    ]);
};
pt.gcm.prototype.encrypt = function(e, t, o) {
  var r = e.length();
  if (r === 0)
    return !0;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && r >= this.blockSize) {
    for (var h = 0; h < this._ints; ++h)
      t.putInt32(this._outBlock[h] ^= e.getInt32());
    this._cipherLength += this.blockSize;
  } else {
    var a = (this.blockSize - r) % this.blockSize;
    a > 0 && (a = this.blockSize - a), this._partialOutput.clear();
    for (var h = 0; h < this._ints; ++h)
      this._partialOutput.putInt32(e.getInt32() ^ this._outBlock[h]);
    if (a <= 0 || o) {
      if (o) {
        var p = r % this.blockSize;
        this._cipherLength += p, this._partialOutput.truncate(this.blockSize - p);
      } else
        this._cipherLength += this.blockSize;
      for (var h = 0; h < this._ints; ++h)
        this._outBlock[h] = this._partialOutput.getInt32();
      this._partialOutput.read -= this.blockSize;
    }
    if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), a > 0 && !o)
      return e.read -= this.blockSize, t.putBytes(this._partialOutput.getBytes(
        a - this._partialBytes
      )), this._partialBytes = a, !0;
    t.putBytes(this._partialOutput.getBytes(
      r - this._partialBytes
    )), this._partialBytes = 0;
  }
  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock), Lf(this._inBlock);
};
pt.gcm.prototype.decrypt = function(e, t, o) {
  var r = e.length();
  if (r < this.blockSize && !(o && r > 0))
    return !0;
  this.cipher.encrypt(this._inBlock, this._outBlock), Lf(this._inBlock), this._hashBlock[0] = e.getInt32(), this._hashBlock[1] = e.getInt32(), this._hashBlock[2] = e.getInt32(), this._hashBlock[3] = e.getInt32(), this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
  for (var h = 0; h < this._ints; ++h)
    t.putInt32(this._outBlock[h] ^ this._hashBlock[h]);
  r < this.blockSize ? this._cipherLength += r % this.blockSize : this._cipherLength += this.blockSize;
};
pt.gcm.prototype.afterFinish = function(e, t) {
  var o = !0;
  t.decrypt && t.overflow && e.truncate(this.blockSize - t.overflow), this.tag = Qt.util.createBuffer();
  var r = this._aDataLength.concat(yc(this._cipherLength * 8));
  this._s = this.ghash(this._hashSubkey, this._s, r);
  var h = [];
  this.cipher.encrypt(this._j0, h);
  for (var a = 0; a < this._ints; ++a)
    this.tag.putInt32(this._s[a] ^ h[a]);
  return this.tag.truncate(this.tag.length() % (this._tagLength / 8)), t.decrypt && this.tag.bytes() !== this._tag && (o = !1), o;
};
pt.gcm.prototype.multiply = function(e, t) {
  for (var o = [0, 0, 0, 0], r = t.slice(0), h = 0; h < 128; ++h) {
    var a = e[h / 32 | 0] & 1 << 31 - h % 32;
    a && (o[0] ^= r[0], o[1] ^= r[1], o[2] ^= r[2], o[3] ^= r[3]), this.pow(r, r);
  }
  return o;
};
pt.gcm.prototype.pow = function(e, t) {
  for (var o = e[3] & 1, r = 3; r > 0; --r)
    t[r] = e[r] >>> 1 | (e[r - 1] & 1) << 31;
  t[0] = e[0] >>> 1, o && (t[0] ^= this._R);
};
pt.gcm.prototype.tableMultiply = function(e) {
  for (var t = [0, 0, 0, 0], o = 0; o < 32; ++o) {
    var r = o / 8 | 0, h = e[r] >>> (7 - o % 8) * 4 & 15, a = this._m[o][h];
    t[0] ^= a[0], t[1] ^= a[1], t[2] ^= a[2], t[3] ^= a[3];
  }
  return t;
};
pt.gcm.prototype.ghash = function(e, t, o) {
  return t[0] ^= o[0], t[1] ^= o[1], t[2] ^= o[2], t[3] ^= o[3], this.tableMultiply(t);
};
pt.gcm.prototype.generateHashTable = function(e, t) {
  for (var o = 8 / t, r = 4 * o, h = 16 * o, a = new Array(h), p = 0; p < h; ++p) {
    var d = [0, 0, 0, 0], b = p / r | 0, g = (r - 1 - p % r) * t;
    d[b] = 1 << t - 1 << g, a[p] = this.generateSubHashTable(this.multiply(d, e), t);
  }
  return a;
};
pt.gcm.prototype.generateSubHashTable = function(e, t) {
  var o = 1 << t, r = o >>> 1, h = new Array(o);
  h[r] = e.slice(0);
  for (var a = r >>> 1; a > 0; )
    this.pow(h[2 * a], h[a] = []), a >>= 1;
  for (a = 2; a < r; ) {
    for (var p = 1; p < a; ++p) {
      var d = h[a], b = h[p];
      h[a + p] = [
        d[0] ^ b[0],
        d[1] ^ b[1],
        d[2] ^ b[2],
        d[3] ^ b[3]
      ];
    }
    a *= 2;
  }
  for (h[0] = [0, 0, 0, 0], a = r + 1; a < o; ++a) {
    var g = h[a ^ r];
    h[a] = [e[0] ^ g[0], e[1] ^ g[1], e[2] ^ g[2], e[3] ^ g[3]];
  }
  return h;
};
function Pf(e, t) {
  if (typeof e == "string" && (e = Qt.util.createBuffer(e)), Qt.util.isArray(e) && e.length > 4) {
    var o = e;
    e = Qt.util.createBuffer();
    for (var r = 0; r < o.length; ++r)
      e.putByte(o[r]);
  }
  if (e.length() < t)
    throw new Error(
      "Invalid IV length; got " + e.length() + " bytes and expected " + t + " bytes."
    );
  if (!Qt.util.isArray(e)) {
    for (var h = [], a = t / 4, r = 0; r < a; ++r)
      h.push(e.getInt32());
    e = h;
  }
  return e;
}
function Lf(e) {
  e[e.length - 1] = e[e.length - 1] + 1 & 4294967295;
}
function yc(e) {
  return [e / 4294967296 | 0, e & 4294967295];
}
var Lt = ht;
Lt.aes = Lt.aes || {};
Lt.aes.startEncrypting = function(e, t, o, r) {
  var h = kf({
    key: e,
    output: o,
    decrypt: !1,
    mode: r
  });
  return h.start(t), h;
};
Lt.aes.createEncryptionCipher = function(e, t) {
  return kf({
    key: e,
    output: null,
    decrypt: !1,
    mode: t
  });
};
Lt.aes.startDecrypting = function(e, t, o, r) {
  var h = kf({
    key: e,
    output: o,
    decrypt: !0,
    mode: r
  });
  return h.start(t), h;
};
Lt.aes.createDecryptionCipher = function(e, t) {
  return kf({
    key: e,
    output: null,
    decrypt: !0,
    mode: t
  });
};
Lt.aes.Algorithm = function(e, t) {
  Fh || v2();
  var o = this;
  o.name = e, o.mode = new t({
    blockSize: 16,
    cipher: {
      encrypt: function(r, h) {
        return mc(o._w, r, h, !1);
      },
      decrypt: function(r, h) {
        return mc(o._w, r, h, !0);
      }
    }
  }), o._init = !1;
};
Lt.aes.Algorithm.prototype.initialize = function(e) {
  if (!this._init) {
    var t = e.key, o;
    if (typeof t == "string" && (t.length === 16 || t.length === 24 || t.length === 32))
      t = Lt.util.createBuffer(t);
    else if (Lt.util.isArray(t) && (t.length === 16 || t.length === 24 || t.length === 32)) {
      o = t, t = Lt.util.createBuffer();
      for (var r = 0; r < o.length; ++r)
        t.putByte(o[r]);
    }
    if (!Lt.util.isArray(t)) {
      o = t, t = [];
      var h = o.length();
      if (h === 16 || h === 24 || h === 32) {
        h = h >>> 2;
        for (var r = 0; r < h; ++r)
          t.push(o.getInt32());
      }
    }
    if (!Lt.util.isArray(t) || !(t.length === 4 || t.length === 6 || t.length === 8))
      throw new Error("Invalid key parameter.");
    var a = this.mode.name, p = ["CFB", "OFB", "CTR", "GCM"].indexOf(a) !== -1;
    this._w = y2(t, e.decrypt && !p), this._init = !0;
  }
};
Lt.aes._expandKey = function(e, t) {
  return Fh || v2(), y2(e, t);
};
Lt.aes._updateBlock = mc;
Ja("AES-ECB", Lt.cipher.modes.ecb);
Ja("AES-CBC", Lt.cipher.modes.cbc);
Ja("AES-CFB", Lt.cipher.modes.cfb);
Ja("AES-OFB", Lt.cipher.modes.ofb);
Ja("AES-CTR", Lt.cipher.modes.ctr);
Ja("AES-GCM", Lt.cipher.modes.gcm);
function Ja(e, t) {
  var o = function() {
    return new Lt.aes.Algorithm(e, t);
  };
  Lt.cipher.registerAlgorithm(e, o);
}
var Fh = !1, da = 4, vr, gc, p2, jn, Ei;
function v2() {
  Fh = !0, p2 = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
  for (var e = new Array(256), t = 0; t < 128; ++t)
    e[t] = t << 1, e[t + 128] = t + 128 << 1 ^ 283;
  vr = new Array(256), gc = new Array(256), jn = new Array(4), Ei = new Array(4);
  for (var t = 0; t < 4; ++t)
    jn[t] = new Array(256), Ei[t] = new Array(256);
  for (var o = 0, r = 0, h, a, p, d, b, g, w, t = 0; t < 256; ++t) {
    d = r ^ r << 1 ^ r << 2 ^ r << 3 ^ r << 4, d = d >> 8 ^ d & 255 ^ 99, vr[o] = d, gc[d] = o, b = e[d], h = e[o], a = e[h], p = e[a], g = b << 24 ^ // 2
    d << 16 ^ // 1
    d << 8 ^ // 1
    (d ^ b), w = (h ^ a ^ p) << 24 ^ // E (14)
    (o ^ p) << 16 ^ // 9
    (o ^ a ^ p) << 8 ^ // D (13)
    (o ^ h ^ p);
    for (var C = 0; C < 4; ++C)
      jn[C][o] = g, Ei[C][d] = w, g = g << 24 | g >>> 8, w = w << 24 | w >>> 8;
    o === 0 ? o = r = 1 : (o = h ^ e[e[e[h ^ p]]], r ^= e[e[r]]);
  }
}
function y2(e, t) {
  for (var o = e.slice(0), r, h = 1, a = o.length, p = a + 6 + 1, d = da * p, b = a; b < d; ++b)
    r = o[b - 1], b % a === 0 ? (r = vr[r >>> 16 & 255] << 24 ^ vr[r >>> 8 & 255] << 16 ^ vr[r & 255] << 8 ^ vr[r >>> 24] ^ p2[h] << 24, h++) : a > 6 && b % a === 4 && (r = vr[r >>> 24] << 24 ^ vr[r >>> 16 & 255] << 16 ^ vr[r >>> 8 & 255] << 8 ^ vr[r & 255]), o[b] = o[b - a] ^ r;
  if (t) {
    var g, w = Ei[0], C = Ei[1], T = Ei[2], k = Ei[3], q = o.slice(0);
    d = o.length;
    for (var b = 0, O = d - da; b < d; b += da, O -= da)
      if (b === 0 || b === d - da)
        q[b] = o[O], q[b + 1] = o[O + 3], q[b + 2] = o[O + 2], q[b + 3] = o[O + 1];
      else
        for (var N = 0; N < da; ++N)
          g = o[O + N], q[b + (3 & -N)] = w[vr[g >>> 24]] ^ C[vr[g >>> 16 & 255]] ^ T[vr[g >>> 8 & 255]] ^ k[vr[g & 255]];
    o = q;
  }
  return o;
}
function mc(e, t, o, r) {
  var h = e.length / 4 - 1, a, p, d, b, g;
  r ? (a = Ei[0], p = Ei[1], d = Ei[2], b = Ei[3], g = gc) : (a = jn[0], p = jn[1], d = jn[2], b = jn[3], g = vr);
  var w, C, T, k, q, O, N;
  w = t[0] ^ e[0], C = t[r ? 3 : 1] ^ e[1], T = t[2] ^ e[2], k = t[r ? 1 : 3] ^ e[3];
  for (var j = 3, U = 1; U < h; ++U)
    q = a[w >>> 24] ^ p[C >>> 16 & 255] ^ d[T >>> 8 & 255] ^ b[k & 255] ^ e[++j], O = a[C >>> 24] ^ p[T >>> 16 & 255] ^ d[k >>> 8 & 255] ^ b[w & 255] ^ e[++j], N = a[T >>> 24] ^ p[k >>> 16 & 255] ^ d[w >>> 8 & 255] ^ b[C & 255] ^ e[++j], k = a[k >>> 24] ^ p[w >>> 16 & 255] ^ d[C >>> 8 & 255] ^ b[T & 255] ^ e[++j], w = q, C = O, T = N;
  o[0] = g[w >>> 24] << 24 ^ g[C >>> 16 & 255] << 16 ^ g[T >>> 8 & 255] << 8 ^ g[k & 255] ^ e[++j], o[r ? 3 : 1] = g[C >>> 24] << 24 ^ g[T >>> 16 & 255] << 16 ^ g[k >>> 8 & 255] << 8 ^ g[w & 255] ^ e[++j], o[2] = g[T >>> 24] << 24 ^ g[k >>> 16 & 255] << 16 ^ g[w >>> 8 & 255] << 8 ^ g[C & 255] ^ e[++j], o[r ? 1 : 3] = g[k >>> 24] << 24 ^ g[w >>> 16 & 255] << 16 ^ g[C >>> 8 & 255] << 8 ^ g[T & 255] ^ e[++j];
}
function kf(e) {
  e = e || {};
  var t = (e.mode || "CBC").toUpperCase(), o = "AES-" + t, r;
  e.decrypt ? r = Lt.cipher.createDecipher(o, e.key) : r = Lt.cipher.createCipher(o, e.key);
  var h = r.start;
  return r.start = function(a, p) {
    var d = null;
    p instanceof Lt.util.ByteBuffer && (d = p, p = {}), p = p || {}, p.output = d, p.iv = a, h.call(r, p);
  }, r;
}
var E0 = ht;
E0.pki = E0.pki || {};
var bc = E0.pki.oids = E0.oids = E0.oids || {};
function Se(e, t) {
  bc[e] = t, bc[t] = e;
}
function wt(e, t) {
  bc[e] = t;
}
Se("1.2.840.113549.1.1.1", "rsaEncryption");
Se("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
Se("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
Se("1.2.840.113549.1.1.7", "RSAES-OAEP");
Se("1.2.840.113549.1.1.8", "mgf1");
Se("1.2.840.113549.1.1.9", "pSpecified");
Se("1.2.840.113549.1.1.10", "RSASSA-PSS");
Se("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
Se("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
Se("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
Se("1.3.101.112", "EdDSA25519");
Se("1.2.840.10040.4.3", "dsa-with-sha1");
Se("1.3.14.3.2.7", "desCBC");
Se("1.3.14.3.2.26", "sha1");
Se("1.3.14.3.2.29", "sha1WithRSASignature");
Se("2.16.840.1.101.3.4.2.1", "sha256");
Se("2.16.840.1.101.3.4.2.2", "sha384");
Se("2.16.840.1.101.3.4.2.3", "sha512");
Se("2.16.840.1.101.3.4.2.4", "sha224");
Se("2.16.840.1.101.3.4.2.5", "sha512-224");
Se("2.16.840.1.101.3.4.2.6", "sha512-256");
Se("1.2.840.113549.2.2", "md2");
Se("1.2.840.113549.2.5", "md5");
Se("1.2.840.113549.1.7.1", "data");
Se("1.2.840.113549.1.7.2", "signedData");
Se("1.2.840.113549.1.7.3", "envelopedData");
Se("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
Se("1.2.840.113549.1.7.5", "digestedData");
Se("1.2.840.113549.1.7.6", "encryptedData");
Se("1.2.840.113549.1.9.1", "emailAddress");
Se("1.2.840.113549.1.9.2", "unstructuredName");
Se("1.2.840.113549.1.9.3", "contentType");
Se("1.2.840.113549.1.9.4", "messageDigest");
Se("1.2.840.113549.1.9.5", "signingTime");
Se("1.2.840.113549.1.9.6", "counterSignature");
Se("1.2.840.113549.1.9.7", "challengePassword");
Se("1.2.840.113549.1.9.8", "unstructuredAddress");
Se("1.2.840.113549.1.9.14", "extensionRequest");
Se("1.2.840.113549.1.9.20", "friendlyName");
Se("1.2.840.113549.1.9.21", "localKeyId");
Se("1.2.840.113549.1.9.22.1", "x509Certificate");
Se("1.2.840.113549.1.12.10.1.1", "keyBag");
Se("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
Se("1.2.840.113549.1.12.10.1.3", "certBag");
Se("1.2.840.113549.1.12.10.1.4", "crlBag");
Se("1.2.840.113549.1.12.10.1.5", "secretBag");
Se("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
Se("1.2.840.113549.1.5.13", "pkcs5PBES2");
Se("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
Se("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
Se("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
Se("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
Se("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
Se("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
Se("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
Se("1.2.840.113549.2.7", "hmacWithSHA1");
Se("1.2.840.113549.2.8", "hmacWithSHA224");
Se("1.2.840.113549.2.9", "hmacWithSHA256");
Se("1.2.840.113549.2.10", "hmacWithSHA384");
Se("1.2.840.113549.2.11", "hmacWithSHA512");
Se("1.2.840.113549.3.7", "des-EDE3-CBC");
Se("2.16.840.1.101.3.4.1.2", "aes128-CBC");
Se("2.16.840.1.101.3.4.1.22", "aes192-CBC");
Se("2.16.840.1.101.3.4.1.42", "aes256-CBC");
Se("2.5.4.3", "commonName");
Se("2.5.4.4", "surname");
Se("2.5.4.5", "serialNumber");
Se("2.5.4.6", "countryName");
Se("2.5.4.7", "localityName");
Se("2.5.4.8", "stateOrProvinceName");
Se("2.5.4.9", "streetAddress");
Se("2.5.4.10", "organizationName");
Se("2.5.4.11", "organizationalUnitName");
Se("2.5.4.12", "title");
Se("2.5.4.13", "description");
Se("2.5.4.15", "businessCategory");
Se("2.5.4.17", "postalCode");
Se("2.5.4.42", "givenName");
Se("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
Se("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
Se("2.16.840.1.113730.1.1", "nsCertType");
Se("2.16.840.1.113730.1.13", "nsComment");
wt("2.5.29.1", "authorityKeyIdentifier");
wt("2.5.29.2", "keyAttributes");
wt("2.5.29.3", "certificatePolicies");
wt("2.5.29.4", "keyUsageRestriction");
wt("2.5.29.5", "policyMapping");
wt("2.5.29.6", "subtreesConstraint");
wt("2.5.29.7", "subjectAltName");
wt("2.5.29.8", "issuerAltName");
wt("2.5.29.9", "subjectDirectoryAttributes");
wt("2.5.29.10", "basicConstraints");
wt("2.5.29.11", "nameConstraints");
wt("2.5.29.12", "policyConstraints");
wt("2.5.29.13", "basicConstraints");
Se("2.5.29.14", "subjectKeyIdentifier");
Se("2.5.29.15", "keyUsage");
wt("2.5.29.16", "privateKeyUsagePeriod");
Se("2.5.29.17", "subjectAltName");
Se("2.5.29.18", "issuerAltName");
Se("2.5.29.19", "basicConstraints");
wt("2.5.29.20", "cRLNumber");
wt("2.5.29.21", "cRLReason");
wt("2.5.29.22", "expirationDate");
wt("2.5.29.23", "instructionCode");
wt("2.5.29.24", "invalidityDate");
wt("2.5.29.25", "cRLDistributionPoints");
wt("2.5.29.26", "issuingDistributionPoint");
wt("2.5.29.27", "deltaCRLIndicator");
wt("2.5.29.28", "issuingDistributionPoint");
wt("2.5.29.29", "certificateIssuer");
wt("2.5.29.30", "nameConstraints");
Se("2.5.29.31", "cRLDistributionPoints");
Se("2.5.29.32", "certificatePolicies");
wt("2.5.29.33", "policyMappings");
wt("2.5.29.34", "policyConstraints");
Se("2.5.29.35", "authorityKeyIdentifier");
wt("2.5.29.36", "policyConstraints");
Se("2.5.29.37", "extKeyUsage");
wt("2.5.29.46", "freshestCRL");
wt("2.5.29.54", "inhibitAnyPolicy");
Se("1.3.6.1.4.1.11129.2.4.2", "timestampList");
Se("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
Se("1.3.6.1.5.5.7.3.1", "serverAuth");
Se("1.3.6.1.5.5.7.3.2", "clientAuth");
Se("1.3.6.1.5.5.7.3.3", "codeSigning");
Se("1.3.6.1.5.5.7.3.4", "emailProtection");
Se("1.3.6.1.5.5.7.3.8", "timeStamping");
var Ut = ht, Ie = Ut.asn1 = Ut.asn1 || {};
Ie.Class = {
  UNIVERSAL: 0,
  APPLICATION: 64,
  CONTEXT_SPECIFIC: 128,
  PRIVATE: 192
};
Ie.Type = {
  NONE: 0,
  BOOLEAN: 1,
  INTEGER: 2,
  BITSTRING: 3,
  OCTETSTRING: 4,
  NULL: 5,
  OID: 6,
  ODESC: 7,
  EXTERNAL: 8,
  REAL: 9,
  ENUMERATED: 10,
  EMBEDDED: 11,
  UTF8: 12,
  ROID: 13,
  SEQUENCE: 16,
  SET: 17,
  PRINTABLESTRING: 19,
  IA5STRING: 22,
  UTCTIME: 23,
  GENERALIZEDTIME: 24,
  BMPSTRING: 30
};
Ie.create = function(e, t, o, r, h) {
  if (Ut.util.isArray(r)) {
    for (var a = [], p = 0; p < r.length; ++p)
      r[p] !== void 0 && a.push(r[p]);
    r = a;
  }
  var d = {
    tagClass: e,
    type: t,
    constructed: o,
    composed: o || Ut.util.isArray(r),
    value: r
  };
  return h && "bitStringContents" in h && (d.bitStringContents = h.bitStringContents, d.original = Ie.copy(d)), d;
};
Ie.copy = function(e, t) {
  var o;
  if (Ut.util.isArray(e)) {
    o = [];
    for (var r = 0; r < e.length; ++r)
      o.push(Ie.copy(e[r], t));
    return o;
  }
  return typeof e == "string" ? e : (o = {
    tagClass: e.tagClass,
    type: e.type,
    constructed: e.constructed,
    composed: e.composed,
    value: Ie.copy(e.value, t)
  }, t && !t.excludeBitStringContents && (o.bitStringContents = e.bitStringContents), o);
};
Ie.equals = function(e, t, o) {
  if (Ut.util.isArray(e)) {
    if (!Ut.util.isArray(t) || e.length !== t.length)
      return !1;
    for (var r = 0; r < e.length; ++r)
      if (!Ie.equals(e[r], t[r]))
        return !1;
    return !0;
  }
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "string")
    return e === t;
  var h = e.tagClass === t.tagClass && e.type === t.type && e.constructed === t.constructed && e.composed === t.composed && Ie.equals(e.value, t.value);
  return o && o.includeBitStringContents && (h = h && e.bitStringContents === t.bitStringContents), h;
};
Ie.getBerValueLength = function(e) {
  var t = e.getByte();
  if (t !== 128) {
    var o, r = t & 128;
    return r ? o = e.getInt((t & 127) << 3) : o = t, o;
  }
};
function b0(e, t, o) {
  if (o > t) {
    var r = new Error("Too few bytes to parse DER.");
    throw r.available = e.length(), r.remaining = t, r.requested = o, r;
  }
}
var zC = function(e, t) {
  var o = e.getByte();
  if (t--, o !== 128) {
    var r, h = o & 128;
    if (!h)
      r = o;
    else {
      var a = o & 127;
      b0(e, t, a), r = e.getInt(a << 3);
    }
    if (r < 0)
      throw new Error("Negative length: " + r);
    return r;
  }
};
Ie.fromDer = function(e, t) {
  t === void 0 && (t = {
    strict: !0,
    parseAllBytes: !0,
    decodeBitStrings: !0
  }), typeof t == "boolean" && (t = {
    strict: t,
    parseAllBytes: !0,
    decodeBitStrings: !0
  }), "strict" in t || (t.strict = !0), "parseAllBytes" in t || (t.parseAllBytes = !0), "decodeBitStrings" in t || (t.decodeBitStrings = !0), typeof e == "string" && (e = Ut.util.createBuffer(e));
  var o = e.length(), r = _s(e, e.length(), 0, t);
  if (t.parseAllBytes && e.length() !== 0) {
    var h = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
    throw h.byteCount = o, h.remaining = e.length(), h;
  }
  return r;
};
function _s(e, t, o, r) {
  var h;
  b0(e, t, 2);
  var a = e.getByte();
  t--;
  var p = a & 192, d = a & 31;
  h = e.length();
  var b = zC(e, t);
  if (t -= h - e.length(), b !== void 0 && b > t) {
    if (r.strict) {
      var g = new Error("Too few bytes to read ASN.1 value.");
      throw g.available = e.length(), g.remaining = t, g.requested = b, g;
    }
    b = t;
  }
  var w, C, T = (a & 32) === 32;
  if (T)
    if (w = [], b === void 0)
      for (; ; ) {
        if (b0(e, t, 2), e.bytes(2) === "\0\0") {
          e.getBytes(2), t -= 2;
          break;
        }
        h = e.length(), w.push(_s(e, t, o + 1, r)), t -= h - e.length();
      }
    else
      for (; b > 0; )
        h = e.length(), w.push(_s(e, b, o + 1, r)), t -= h - e.length(), b -= h - e.length();
  if (w === void 0 && p === Ie.Class.UNIVERSAL && d === Ie.Type.BITSTRING && (C = e.bytes(b)), w === void 0 && r.decodeBitStrings && p === Ie.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
  // .. other parts of forge expect to decode OCTET STRINGs manually
  d === Ie.Type.BITSTRING && b > 1) {
    var k = e.read, q = t, O = 0;
    if (d === Ie.Type.BITSTRING && (b0(e, t, 1), O = e.getByte(), t--), O === 0)
      try {
        h = e.length();
        var N = {
          // enforce strict mode to avoid parsing ASN.1 from plain data
          strict: !0,
          decodeBitStrings: !0
        }, j = _s(e, t, o + 1, N), U = h - e.length();
        t -= U, d == Ie.Type.BITSTRING && U++;
        var H = j.tagClass;
        U === b && (H === Ie.Class.UNIVERSAL || H === Ie.Class.CONTEXT_SPECIFIC) && (w = [j]);
      } catch {
      }
    w === void 0 && (e.read = k, t = q);
  }
  if (w === void 0) {
    if (b === void 0) {
      if (r.strict)
        throw new Error("Non-constructed ASN.1 object of indefinite length.");
      b = t;
    }
    if (d === Ie.Type.BMPSTRING)
      for (w = ""; b > 0; b -= 2)
        b0(e, t, 2), w += String.fromCharCode(e.getInt16()), t -= 2;
    else
      w = e.getBytes(b), t -= b;
  }
  var z = C === void 0 ? null : {
    bitStringContents: C
  };
  return Ie.create(p, d, T, w, z);
}
Ie.toDer = function(e) {
  var t = Ut.util.createBuffer(), o = e.tagClass | e.type, r = Ut.util.createBuffer(), h = !1;
  if ("bitStringContents" in e && (h = !0, e.original && (h = Ie.equals(e, e.original))), h)
    r.putBytes(e.bitStringContents);
  else if (e.composed) {
    e.constructed ? o |= 32 : r.putByte(0);
    for (var a = 0; a < e.value.length; ++a)
      e.value[a] !== void 0 && r.putBuffer(Ie.toDer(e.value[a]));
  } else if (e.type === Ie.Type.BMPSTRING)
    for (var a = 0; a < e.value.length; ++a)
      r.putInt16(e.value.charCodeAt(a));
  else
    e.type === Ie.Type.INTEGER && e.value.length > 1 && // leading 0x00 for positive integer
    (e.value.charCodeAt(0) === 0 && !(e.value.charCodeAt(1) & 128) || // leading 0xFF for negative integer
    e.value.charCodeAt(0) === 255 && (e.value.charCodeAt(1) & 128) === 128) ? r.putBytes(e.value.substr(1)) : r.putBytes(e.value);
  if (t.putByte(o), r.length() <= 127)
    t.putByte(r.length() & 127);
  else {
    var p = r.length(), d = "";
    do
      d += String.fromCharCode(p & 255), p = p >>> 8;
    while (p > 0);
    t.putByte(d.length | 128);
    for (var a = d.length - 1; a >= 0; --a)
      t.putByte(d.charCodeAt(a));
  }
  return t.putBuffer(r), t;
};
Ie.oidToDer = function(e) {
  var t = e.split("."), o = Ut.util.createBuffer();
  o.putByte(40 * parseInt(t[0], 10) + parseInt(t[1], 10));
  for (var r, h, a, p, d = 2; d < t.length; ++d) {
    r = !0, h = [], a = parseInt(t[d], 10);
    do
      p = a & 127, a = a >>> 7, r || (p |= 128), h.push(p), r = !1;
    while (a > 0);
    for (var b = h.length - 1; b >= 0; --b)
      o.putByte(h[b]);
  }
  return o;
};
Ie.derToOid = function(e) {
  var t;
  typeof e == "string" && (e = Ut.util.createBuffer(e));
  var o = e.getByte();
  t = Math.floor(o / 40) + "." + o % 40;
  for (var r = 0; e.length() > 0; )
    o = e.getByte(), r = r << 7, o & 128 ? r += o & 127 : (t += "." + (r + o), r = 0);
  return t;
};
Ie.utcTimeToDate = function(e) {
  var t = /* @__PURE__ */ new Date(), o = parseInt(e.substr(0, 2), 10);
  o = o >= 50 ? 1900 + o : 2e3 + o;
  var r = parseInt(e.substr(2, 2), 10) - 1, h = parseInt(e.substr(4, 2), 10), a = parseInt(e.substr(6, 2), 10), p = parseInt(e.substr(8, 2), 10), d = 0;
  if (e.length > 11) {
    var b = e.charAt(10), g = 10;
    b !== "+" && b !== "-" && (d = parseInt(e.substr(10, 2), 10), g += 2);
  }
  if (t.setUTCFullYear(o, r, h), t.setUTCHours(a, p, d, 0), g && (b = e.charAt(g), b === "+" || b === "-")) {
    var w = parseInt(e.substr(g + 1, 2), 10), C = parseInt(e.substr(g + 4, 2), 10), T = w * 60 + C;
    T *= 6e4, b === "+" ? t.setTime(+t - T) : t.setTime(+t + T);
  }
  return t;
};
Ie.generalizedTimeToDate = function(e) {
  var t = /* @__PURE__ */ new Date(), o = parseInt(e.substr(0, 4), 10), r = parseInt(e.substr(4, 2), 10) - 1, h = parseInt(e.substr(6, 2), 10), a = parseInt(e.substr(8, 2), 10), p = parseInt(e.substr(10, 2), 10), d = parseInt(e.substr(12, 2), 10), b = 0, g = 0, w = !1;
  e.charAt(e.length - 1) === "Z" && (w = !0);
  var C = e.length - 5, T = e.charAt(C);
  if (T === "+" || T === "-") {
    var k = parseInt(e.substr(C + 1, 2), 10), q = parseInt(e.substr(C + 4, 2), 10);
    g = k * 60 + q, g *= 6e4, T === "+" && (g *= -1), w = !0;
  }
  return e.charAt(14) === "." && (b = parseFloat(e.substr(14), 10) * 1e3), w ? (t.setUTCFullYear(o, r, h), t.setUTCHours(a, p, d, b), t.setTime(+t + g)) : (t.setFullYear(o, r, h), t.setHours(a, p, d, b)), t;
};
Ie.dateToUtcTime = function(e) {
  if (typeof e == "string")
    return e;
  var t = "", o = [];
  o.push(("" + e.getUTCFullYear()).substr(2)), o.push("" + (e.getUTCMonth() + 1)), o.push("" + e.getUTCDate()), o.push("" + e.getUTCHours()), o.push("" + e.getUTCMinutes()), o.push("" + e.getUTCSeconds());
  for (var r = 0; r < o.length; ++r)
    o[r].length < 2 && (t += "0"), t += o[r];
  return t += "Z", t;
};
Ie.dateToGeneralizedTime = function(e) {
  if (typeof e == "string")
    return e;
  var t = "", o = [];
  o.push("" + e.getUTCFullYear()), o.push("" + (e.getUTCMonth() + 1)), o.push("" + e.getUTCDate()), o.push("" + e.getUTCHours()), o.push("" + e.getUTCMinutes()), o.push("" + e.getUTCSeconds());
  for (var r = 0; r < o.length; ++r)
    o[r].length < 2 && (t += "0"), t += o[r];
  return t += "Z", t;
};
Ie.integerToDer = function(e) {
  var t = Ut.util.createBuffer();
  if (e >= -128 && e < 128)
    return t.putSignedInt(e, 8);
  if (e >= -32768 && e < 32768)
    return t.putSignedInt(e, 16);
  if (e >= -8388608 && e < 8388608)
    return t.putSignedInt(e, 24);
  if (e >= -2147483648 && e < 2147483648)
    return t.putSignedInt(e, 32);
  var o = new Error("Integer too large; max is 32-bits.");
  throw o.integer = e, o;
};
Ie.derToInteger = function(e) {
  typeof e == "string" && (e = Ut.util.createBuffer(e));
  var t = e.length() * 8;
  if (t > 32)
    throw new Error("Integer too large; max is 32-bits.");
  return e.getSignedInt(t);
};
Ie.validate = function(e, t, o, r) {
  var h = !1;
  if ((e.tagClass === t.tagClass || typeof t.tagClass > "u") && (e.type === t.type || typeof t.type > "u"))
    if (e.constructed === t.constructed || typeof t.constructed > "u") {
      if (h = !0, t.value && Ut.util.isArray(t.value))
        for (var a = 0, p = 0; h && p < t.value.length; ++p)
          h = t.value[p].optional || !1, e.value[a] && (h = Ie.validate(e.value[a], t.value[p], o, r), h ? ++a : t.value[p].optional && (h = !0)), !h && r && r.push(
            "[" + t.name + '] Tag class "' + t.tagClass + '", type "' + t.type + '" expected value length "' + t.value.length + '", got "' + e.value.length + '"'
          );
      if (h && o && (t.capture && (o[t.capture] = e.value), t.captureAsn1 && (o[t.captureAsn1] = e), t.captureBitStringContents && "bitStringContents" in e && (o[t.captureBitStringContents] = e.bitStringContents), t.captureBitStringValue && "bitStringContents" in e))
        if (e.bitStringContents.length < 2)
          o[t.captureBitStringValue] = "";
        else {
          var d = e.bitStringContents.charCodeAt(0);
          if (d !== 0)
            throw new Error(
              "captureBitStringValue only supported for zero unused bits"
            );
          o[t.captureBitStringValue] = e.bitStringContents.slice(1);
        }
    } else
      r && r.push(
        "[" + t.name + '] Expected constructed "' + t.constructed + '", got "' + e.constructed + '"'
      );
  else
    r && (e.tagClass !== t.tagClass && r.push(
      "[" + t.name + '] Expected tag class "' + t.tagClass + '", got "' + e.tagClass + '"'
    ), e.type !== t.type && r.push(
      "[" + t.name + '] Expected type "' + t.type + '", got "' + e.type + '"'
    ));
  return h;
};
var Dp = /[^\\u0000-\\u00ff]/;
Ie.prettyPrint = function(e, t, o) {
  var r = "";
  t = t || 0, o = o || 2, t > 0 && (r += `
`);
  for (var h = "", a = 0; a < t * o; ++a)
    h += " ";
  switch (r += h + "Tag: ", e.tagClass) {
    case Ie.Class.UNIVERSAL:
      r += "Universal:";
      break;
    case Ie.Class.APPLICATION:
      r += "Application:";
      break;
    case Ie.Class.CONTEXT_SPECIFIC:
      r += "Context-Specific:";
      break;
    case Ie.Class.PRIVATE:
      r += "Private:";
      break;
  }
  if (e.tagClass === Ie.Class.UNIVERSAL)
    switch (r += e.type, e.type) {
      case Ie.Type.NONE:
        r += " (None)";
        break;
      case Ie.Type.BOOLEAN:
        r += " (Boolean)";
        break;
      case Ie.Type.INTEGER:
        r += " (Integer)";
        break;
      case Ie.Type.BITSTRING:
        r += " (Bit string)";
        break;
      case Ie.Type.OCTETSTRING:
        r += " (Octet string)";
        break;
      case Ie.Type.NULL:
        r += " (Null)";
        break;
      case Ie.Type.OID:
        r += " (Object Identifier)";
        break;
      case Ie.Type.ODESC:
        r += " (Object Descriptor)";
        break;
      case Ie.Type.EXTERNAL:
        r += " (External or Instance of)";
        break;
      case Ie.Type.REAL:
        r += " (Real)";
        break;
      case Ie.Type.ENUMERATED:
        r += " (Enumerated)";
        break;
      case Ie.Type.EMBEDDED:
        r += " (Embedded PDV)";
        break;
      case Ie.Type.UTF8:
        r += " (UTF8)";
        break;
      case Ie.Type.ROID:
        r += " (Relative Object Identifier)";
        break;
      case Ie.Type.SEQUENCE:
        r += " (Sequence)";
        break;
      case Ie.Type.SET:
        r += " (Set)";
        break;
      case Ie.Type.PRINTABLESTRING:
        r += " (Printable String)";
        break;
      case Ie.Type.IA5String:
        r += " (IA5String (ASCII))";
        break;
      case Ie.Type.UTCTIME:
        r += " (UTC time)";
        break;
      case Ie.Type.GENERALIZEDTIME:
        r += " (Generalized time)";
        break;
      case Ie.Type.BMPSTRING:
        r += " (BMP String)";
        break;
    }
  else
    r += e.type;
  if (r += `
`, r += h + "Constructed: " + e.constructed + `
`, e.composed) {
    for (var p = 0, d = "", a = 0; a < e.value.length; ++a)
      e.value[a] !== void 0 && (p += 1, d += Ie.prettyPrint(e.value[a], t + 1, o), a + 1 < e.value.length && (d += ","));
    r += h + "Sub values: " + p + d;
  } else {
    if (r += h + "Value: ", e.type === Ie.Type.OID) {
      var b = Ie.derToOid(e.value);
      r += b, Ut.pki && Ut.pki.oids && b in Ut.pki.oids && (r += " (" + Ut.pki.oids[b] + ") ");
    }
    if (e.type === Ie.Type.INTEGER)
      try {
        r += Ie.derToInteger(e.value);
      } catch {
        r += "0x" + Ut.util.bytesToHex(e.value);
      }
    else if (e.type === Ie.Type.BITSTRING) {
      if (e.value.length > 1 ? r += "0x" + Ut.util.bytesToHex(e.value.slice(1)) : r += "(none)", e.value.length > 0) {
        var g = e.value.charCodeAt(0);
        g == 1 ? r += " (1 unused bit shown)" : g > 1 && (r += " (" + g + " unused bits shown)");
      }
    } else if (e.type === Ie.Type.OCTETSTRING)
      Dp.test(e.value) || (r += "(" + e.value + ") "), r += "0x" + Ut.util.bytesToHex(e.value);
    else if (e.type === Ie.Type.UTF8)
      try {
        r += Ut.util.decodeUtf8(e.value);
      } catch (w) {
        if (w.message === "URI malformed")
          r += "0x" + Ut.util.bytesToHex(e.value) + " (malformed UTF8)";
        else
          throw w;
      }
    else
      e.type === Ie.Type.PRINTABLESTRING || e.type === Ie.Type.IA5String ? r += e.value : Dp.test(e.value) ? r += "0x" + Ut.util.bytesToHex(e.value) : e.value.length === 0 ? r += "[null]" : r += e.value;
  }
  return r;
};
var Ps = ht;
Ps.md = Ps.md || {};
Ps.md.algorithms = Ps.md.algorithms || {};
var Zi = ht, jC = Zi.hmac = Zi.hmac || {};
jC.create = function() {
  var e = null, t = null, o = null, r = null, h = {};
  return h.start = function(a, p) {
    if (a !== null)
      if (typeof a == "string")
        if (a = a.toLowerCase(), a in Zi.md.algorithms)
          t = Zi.md.algorithms[a].create();
        else
          throw new Error('Unknown hash algorithm "' + a + '"');
      else
        t = a;
    if (p === null)
      p = e;
    else {
      if (typeof p == "string")
        p = Zi.util.createBuffer(p);
      else if (Zi.util.isArray(p)) {
        var d = p;
        p = Zi.util.createBuffer();
        for (var b = 0; b < d.length; ++b)
          p.putByte(d[b]);
      }
      var g = p.length();
      g > t.blockLength && (t.start(), t.update(p.bytes()), p = t.digest()), o = Zi.util.createBuffer(), r = Zi.util.createBuffer(), g = p.length();
      for (var b = 0; b < g; ++b) {
        var d = p.at(b);
        o.putByte(54 ^ d), r.putByte(92 ^ d);
      }
      if (g < t.blockLength)
        for (var d = t.blockLength - g, b = 0; b < d; ++b)
          o.putByte(54), r.putByte(92);
      e = p, o = o.bytes(), r = r.bytes();
    }
    t.start(), t.update(o);
  }, h.update = function(a) {
    t.update(a);
  }, h.getMac = function() {
    var a = t.digest().bytes();
    return t.start(), t.update(r), t.update(a), t.digest();
  }, h.digest = h.getMac, h;
};
var Li = ht, g2 = Li.md5 = Li.md5 || {};
Li.md.md5 = Li.md.algorithms.md5 = g2;
g2.create = function() {
  m2 || WC();
  var e = null, t = Li.util.createBuffer(), o = new Array(16), r = {
    algorithm: "md5",
    blockLength: 64,
    digestLength: 16,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  return r.start = function() {
    r.messageLength = 0, r.fullMessageLength = r.messageLength64 = [];
    for (var h = r.messageLengthSize / 4, a = 0; a < h; ++a)
      r.fullMessageLength.push(0);
    return t = Li.util.createBuffer(), e = {
      h0: 1732584193,
      h1: 4023233417,
      h2: 2562383102,
      h3: 271733878
    }, r;
  }, r.start(), r.update = function(h, a) {
    a === "utf8" && (h = Li.util.encodeUtf8(h));
    var p = h.length;
    r.messageLength += p, p = [p / 4294967296 >>> 0, p >>> 0];
    for (var d = r.fullMessageLength.length - 1; d >= 0; --d)
      r.fullMessageLength[d] += p[1], p[1] = p[0] + (r.fullMessageLength[d] / 4294967296 >>> 0), r.fullMessageLength[d] = r.fullMessageLength[d] >>> 0, p[0] = p[1] / 4294967296 >>> 0;
    return t.putBytes(h), Op(e, o, t), (t.read > 2048 || t.length() === 0) && t.compact(), r;
  }, r.digest = function() {
    var h = Li.util.createBuffer();
    h.putBytes(t.bytes());
    var a = r.fullMessageLength[r.fullMessageLength.length - 1] + r.messageLengthSize, p = a & r.blockLength - 1;
    h.putBytes(xc.substr(0, r.blockLength - p));
    for (var d, b = 0, g = r.fullMessageLength.length - 1; g >= 0; --g)
      d = r.fullMessageLength[g] * 8 + b, b = d / 4294967296 >>> 0, h.putInt32Le(d >>> 0);
    var w = {
      h0: e.h0,
      h1: e.h1,
      h2: e.h2,
      h3: e.h3
    };
    Op(w, o, h);
    var C = Li.util.createBuffer();
    return C.putInt32Le(w.h0), C.putInt32Le(w.h1), C.putInt32Le(w.h2), C.putInt32Le(w.h3), C;
  }, r;
};
var xc = null, Es = null, x0 = null, ga = null, m2 = !1;
function WC() {
  xc = "", xc += Li.util.fillString("\0", 64), Es = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    1,
    6,
    11,
    0,
    5,
    10,
    15,
    4,
    9,
    14,
    3,
    8,
    13,
    2,
    7,
    12,
    5,
    8,
    11,
    14,
    1,
    4,
    7,
    10,
    13,
    0,
    3,
    6,
    9,
    12,
    15,
    2,
    0,
    7,
    14,
    5,
    12,
    3,
    10,
    1,
    8,
    15,
    6,
    13,
    4,
    11,
    2,
    9
  ], x0 = [
    7,
    12,
    17,
    22,
    7,
    12,
    17,
    22,
    7,
    12,
    17,
    22,
    7,
    12,
    17,
    22,
    5,
    9,
    14,
    20,
    5,
    9,
    14,
    20,
    5,
    9,
    14,
    20,
    5,
    9,
    14,
    20,
    4,
    11,
    16,
    23,
    4,
    11,
    16,
    23,
    4,
    11,
    16,
    23,
    4,
    11,
    16,
    23,
    6,
    10,
    15,
    21,
    6,
    10,
    15,
    21,
    6,
    10,
    15,
    21,
    6,
    10,
    15,
    21
  ], ga = new Array(64);
  for (var e = 0; e < 64; ++e)
    ga[e] = Math.floor(Math.abs(Math.sin(e + 1)) * 4294967296);
  m2 = !0;
}
function Op(e, t, o) {
  for (var r, h, a, p, d, b, g, w, C = o.length(); C >= 64; ) {
    for (h = e.h0, a = e.h1, p = e.h2, d = e.h3, w = 0; w < 16; ++w)
      t[w] = o.getInt32Le(), b = d ^ a & (p ^ d), r = h + b + ga[w] + t[w], g = x0[w], h = d, d = p, p = a, a += r << g | r >>> 32 - g;
    for (; w < 32; ++w)
      b = p ^ d & (a ^ p), r = h + b + ga[w] + t[Es[w]], g = x0[w], h = d, d = p, p = a, a += r << g | r >>> 32 - g;
    for (; w < 48; ++w)
      b = a ^ p ^ d, r = h + b + ga[w] + t[Es[w]], g = x0[w], h = d, d = p, p = a, a += r << g | r >>> 32 - g;
    for (; w < 64; ++w)
      b = p ^ (a | ~d), r = h + b + ga[w] + t[Es[w]], g = x0[w], h = d, d = p, p = a, a += r << g | r >>> 32 - g;
    e.h0 = e.h0 + h | 0, e.h1 = e.h1 + a | 0, e.h2 = e.h2 + p | 0, e.h3 = e.h3 + d | 0, C -= 64;
  }
}
var Ls = ht, b2 = Ls.pem = Ls.pem || {};
b2.encode = function(e, t) {
  t = t || {};
  var o = "-----BEGIN " + e.type + `-----\r
`, r;
  if (e.procType && (r = {
    name: "Proc-Type",
    values: [String(e.procType.version), e.procType.type]
  }, o += as(r)), e.contentDomain && (r = { name: "Content-Domain", values: [e.contentDomain] }, o += as(r)), e.dekInfo && (r = { name: "DEK-Info", values: [e.dekInfo.algorithm] }, e.dekInfo.parameters && r.values.push(e.dekInfo.parameters), o += as(r)), e.headers)
    for (var h = 0; h < e.headers.length; ++h)
      o += as(e.headers[h]);
  return e.procType && (o += `\r
`), o += Ls.util.encode64(e.body, t.maxline || 64) + `\r
`, o += "-----END " + e.type + `-----\r
`, o;
};
b2.decode = function(e) {
  for (var t = [], o = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g, r = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/, h = /\r?\n/, a; a = o.exec(e), !!a; ) {
    var p = a[1];
    p === "NEW CERTIFICATE REQUEST" && (p = "CERTIFICATE REQUEST");
    var d = {
      type: p,
      procType: null,
      contentDomain: null,
      dekInfo: null,
      headers: [],
      body: Ls.util.decode64(a[3])
    };
    if (t.push(d), !!a[2]) {
      for (var b = a[2].split(h), g = 0; a && g < b.length; ) {
        for (var w = b[g].replace(/\s+$/, ""), C = g + 1; C < b.length; ++C) {
          var T = b[C];
          if (!/\s/.test(T[0]))
            break;
          w += T, g = C;
        }
        if (a = w.match(r), a) {
          for (var k = { name: a[1], values: [] }, q = a[2].split(","), O = 0; O < q.length; ++O)
            k.values.push(YC(q[O]));
          if (d.procType)
            if (!d.contentDomain && k.name === "Content-Domain")
              d.contentDomain = q[0] || "";
            else if (!d.dekInfo && k.name === "DEK-Info") {
              if (k.values.length === 0)
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              d.dekInfo = { algorithm: q[0], parameters: q[1] || null };
            } else
              d.headers.push(k);
          else {
            if (k.name !== "Proc-Type")
              throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
            if (k.values.length !== 2)
              throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
            d.procType = { version: q[0], type: q[1] };
          }
        }
        ++g;
      }
      if (d.procType === "ENCRYPTED" && !d.dekInfo)
        throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
    }
  }
  if (t.length === 0)
    throw new Error("Invalid PEM formatted message.");
  return t;
};
function as(e) {
  for (var t = e.name + ": ", o = [], r = function(b, g) {
    return " " + g;
  }, h = 0; h < e.values.length; ++h)
    o.push(e.values[h].replace(/^(\S+\r\n)/, r));
  t += o.join(",") + `\r
`;
  for (var a = 0, p = -1, h = 0; h < t.length; ++h, ++a)
    if (a > 65 && p !== -1) {
      var d = t[p];
      d === "," ? (++p, t = t.substr(0, p) + `\r
 ` + t.substr(p)) : t = t.substr(0, p) + `\r
` + d + t.substr(p + 1), a = h - p - 1, p = -1, ++h;
    } else
      (t[h] === " " || t[h] === "	" || t[h] === ",") && (p = h);
  return t;
}
function YC(e) {
  return e.replace(/^\s+/, "");
}
var qt = ht;
qt.des = qt.des || {};
qt.des.startEncrypting = function(e, t, o, r) {
  var h = Uf({
    key: e,
    output: o,
    decrypt: !1,
    mode: r || (t === null ? "ECB" : "CBC")
  });
  return h.start(t), h;
};
qt.des.createEncryptionCipher = function(e, t) {
  return Uf({
    key: e,
    output: null,
    decrypt: !1,
    mode: t
  });
};
qt.des.startDecrypting = function(e, t, o, r) {
  var h = Uf({
    key: e,
    output: o,
    decrypt: !0,
    mode: r || (t === null ? "ECB" : "CBC")
  });
  return h.start(t), h;
};
qt.des.createDecryptionCipher = function(e, t) {
  return Uf({
    key: e,
    output: null,
    decrypt: !0,
    mode: t
  });
};
qt.des.Algorithm = function(e, t) {
  var o = this;
  o.name = e, o.mode = new t({
    blockSize: 8,
    cipher: {
      encrypt: function(r, h) {
        return Pp(o._keys, r, h, !1);
      },
      decrypt: function(r, h) {
        return Pp(o._keys, r, h, !0);
      }
    }
  }), o._init = !1;
};
qt.des.Algorithm.prototype.initialize = function(e) {
  if (!this._init) {
    var t = qt.util.createBuffer(e.key);
    if (this.name.indexOf("3DES") === 0 && t.length() !== 24)
      throw new Error("Invalid Triple-DES key size: " + t.length() * 8);
    this._keys = nA(t), this._init = !0;
  }
};
Yi("DES-ECB", qt.cipher.modes.ecb);
Yi("DES-CBC", qt.cipher.modes.cbc);
Yi("DES-CFB", qt.cipher.modes.cfb);
Yi("DES-OFB", qt.cipher.modes.ofb);
Yi("DES-CTR", qt.cipher.modes.ctr);
Yi("3DES-ECB", qt.cipher.modes.ecb);
Yi("3DES-CBC", qt.cipher.modes.cbc);
Yi("3DES-CFB", qt.cipher.modes.cfb);
Yi("3DES-OFB", qt.cipher.modes.ofb);
Yi("3DES-CTR", qt.cipher.modes.ctr);
function Yi(e, t) {
  var o = function() {
    return new qt.des.Algorithm(e, t);
  };
  qt.cipher.registerAlgorithm(e, o);
}
var XC = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756], QC = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344], ZC = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584], JC = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928], eA = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080], tA = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312], rA = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154], iA = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
function nA(e) {
  for (var t = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], o = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], r = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], h = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], a = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], p = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], d = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], b = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], g = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], w = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], C = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], T = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], k = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], q = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261], O = e.length() > 8 ? 3 : 1, N = [], j = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0], U = 0, H, z = 0; z < O; z++) {
    var ee = e.getInt32(), ne = e.getInt32();
    H = (ee >>> 4 ^ ne) & 252645135, ne ^= H, ee ^= H << 4, H = (ne >>> -16 ^ ee) & 65535, ee ^= H, ne ^= H << -16, H = (ee >>> 2 ^ ne) & 858993459, ne ^= H, ee ^= H << 2, H = (ne >>> -16 ^ ee) & 65535, ee ^= H, ne ^= H << -16, H = (ee >>> 1 ^ ne) & 1431655765, ne ^= H, ee ^= H << 1, H = (ne >>> 8 ^ ee) & 16711935, ee ^= H, ne ^= H << 8, H = (ee >>> 1 ^ ne) & 1431655765, ne ^= H, ee ^= H << 1, H = ee << 8 | ne >>> 20 & 240, ee = ne << 24 | ne << 8 & 16711680 | ne >>> 8 & 65280 | ne >>> 24 & 240, ne = H;
    for (var le = 0; le < j.length; ++le) {
      j[le] ? (ee = ee << 2 | ee >>> 26, ne = ne << 2 | ne >>> 26) : (ee = ee << 1 | ee >>> 27, ne = ne << 1 | ne >>> 27), ee &= -15, ne &= -15;
      var Z = t[ee >>> 28] | o[ee >>> 24 & 15] | r[ee >>> 20 & 15] | h[ee >>> 16 & 15] | a[ee >>> 12 & 15] | p[ee >>> 8 & 15] | d[ee >>> 4 & 15], ie = b[ne >>> 28] | g[ne >>> 24 & 15] | w[ne >>> 20 & 15] | C[ne >>> 16 & 15] | T[ne >>> 12 & 15] | k[ne >>> 8 & 15] | q[ne >>> 4 & 15];
      H = (ie >>> 16 ^ Z) & 65535, N[U++] = Z ^ H, N[U++] = ie ^ H << 16;
    }
  }
  return N;
}
function Pp(e, t, o, r) {
  var h = e.length === 32 ? 3 : 9, a;
  h === 3 ? a = r ? [30, -2, -2] : [0, 32, 2] : a = r ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
  var p, d = t[0], b = t[1];
  p = (d >>> 4 ^ b) & 252645135, b ^= p, d ^= p << 4, p = (d >>> 16 ^ b) & 65535, b ^= p, d ^= p << 16, p = (b >>> 2 ^ d) & 858993459, d ^= p, b ^= p << 2, p = (b >>> 8 ^ d) & 16711935, d ^= p, b ^= p << 8, p = (d >>> 1 ^ b) & 1431655765, b ^= p, d ^= p << 1, d = d << 1 | d >>> 31, b = b << 1 | b >>> 31;
  for (var g = 0; g < h; g += 3) {
    for (var w = a[g + 1], C = a[g + 2], T = a[g]; T != w; T += C) {
      var k = b ^ e[T], q = (b >>> 4 | b << 28) ^ e[T + 1];
      p = d, d = b, b = p ^ (QC[k >>> 24 & 63] | JC[k >>> 16 & 63] | tA[k >>> 8 & 63] | iA[k & 63] | XC[q >>> 24 & 63] | ZC[q >>> 16 & 63] | eA[q >>> 8 & 63] | rA[q & 63]);
    }
    p = d, d = b, b = p;
  }
  d = d >>> 1 | d << 31, b = b >>> 1 | b << 31, p = (d >>> 1 ^ b) & 1431655765, b ^= p, d ^= p << 1, p = (b >>> 8 ^ d) & 16711935, d ^= p, b ^= p << 8, p = (b >>> 2 ^ d) & 858993459, d ^= p, b ^= p << 2, p = (d >>> 16 ^ b) & 65535, b ^= p, d ^= p << 16, p = (d >>> 4 ^ b) & 252645135, b ^= p, d ^= p << 4, o[0] = d, o[1] = b;
}
function Uf(e) {
  e = e || {};
  var t = (e.mode || "CBC").toUpperCase(), o = "DES-" + t, r;
  e.decrypt ? r = qt.cipher.createDecipher(o, e.key) : r = qt.cipher.createCipher(o, e.key);
  var h = r.start;
  return r.start = function(a, p) {
    var d = null;
    p instanceof qt.util.ByteBuffer && (d = p, p = {}), p = p || {}, p.output = d, p.iv = a, h.call(r, p);
  }, r;
}
var yr = ht, aA = yr.pkcs5 = yr.pkcs5 || {}, Qi;
yr.util.isNodejs && !yr.options.usePureJavaScript && (Qi = _r());
yr.pbkdf2 = aA.pbkdf2 = function(e, t, o, r, h, a) {
  if (typeof h == "function" && (a = h, h = null), yr.util.isNodejs && !yr.options.usePureJavaScript && Qi.pbkdf2 && (h === null || typeof h != "object") && (Qi.pbkdf2Sync.length > 4 || !h || h === "sha1"))
    return typeof h != "string" && (h = "sha1"), e = pe.Buffer.from(e, "binary"), t = pe.Buffer.from(t, "binary"), a ? Qi.pbkdf2Sync.length === 4 ? Qi.pbkdf2(e, t, o, r, function(H, z) {
      if (H)
        return a(H);
      a(null, z.toString("binary"));
    }) : Qi.pbkdf2(e, t, o, r, h, function(H, z) {
      if (H)
        return a(H);
      a(null, z.toString("binary"));
    }) : Qi.pbkdf2Sync.length === 4 ? Qi.pbkdf2Sync(e, t, o, r).toString("binary") : Qi.pbkdf2Sync(e, t, o, r, h).toString("binary");
  if ((typeof h > "u" || h === null) && (h = "sha1"), typeof h == "string") {
    if (!(h in yr.md.algorithms))
      throw new Error("Unknown hash algorithm: " + h);
    h = yr.md[h].create();
  }
  var p = h.digestLength;
  if (r > 4294967295 * p) {
    var d = new Error("Derived key is too long.");
    if (a)
      return a(d);
    throw d;
  }
  var b = Math.ceil(r / p), g = r - (b - 1) * p, w = yr.hmac.create();
  w.start(h, e);
  var C = "", T, k, q;
  if (!a) {
    for (var O = 1; O <= b; ++O) {
      w.start(null, null), w.update(t), w.update(yr.util.int32ToBytes(O)), T = q = w.digest().getBytes();
      for (var N = 2; N <= o; ++N)
        w.start(null, null), w.update(q), k = w.digest().getBytes(), T = yr.util.xorBytes(T, k, p), q = k;
      C += O < b ? T : T.substr(0, g);
    }
    return C;
  }
  var O = 1, N;
  function j() {
    if (O > b)
      return a(null, C);
    w.start(null, null), w.update(t), w.update(yr.util.int32ToBytes(O)), T = q = w.digest().getBytes(), N = 2, U();
  }
  function U() {
    if (N <= o)
      return w.start(null, null), w.update(q), k = w.digest().getBytes(), T = yr.util.xorBytes(T, k, p), q = k, ++N, yr.util.setImmediate(U);
    C += O < b ? T : T.substr(0, g), ++O, j();
  }
  j();
};
var ki = ht, x2 = ki.sha256 = ki.sha256 || {};
ki.md.sha256 = ki.md.algorithms.sha256 = x2;
x2.create = function() {
  _2 || sA();
  var e = null, t = ki.util.createBuffer(), o = new Array(64), r = {
    algorithm: "sha256",
    blockLength: 64,
    digestLength: 32,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  return r.start = function() {
    r.messageLength = 0, r.fullMessageLength = r.messageLength64 = [];
    for (var h = r.messageLengthSize / 4, a = 0; a < h; ++a)
      r.fullMessageLength.push(0);
    return t = ki.util.createBuffer(), e = {
      h0: 1779033703,
      h1: 3144134277,
      h2: 1013904242,
      h3: 2773480762,
      h4: 1359893119,
      h5: 2600822924,
      h6: 528734635,
      h7: 1541459225
    }, r;
  }, r.start(), r.update = function(h, a) {
    a === "utf8" && (h = ki.util.encodeUtf8(h));
    var p = h.length;
    r.messageLength += p, p = [p / 4294967296 >>> 0, p >>> 0];
    for (var d = r.fullMessageLength.length - 1; d >= 0; --d)
      r.fullMessageLength[d] += p[1], p[1] = p[0] + (r.fullMessageLength[d] / 4294967296 >>> 0), r.fullMessageLength[d] = r.fullMessageLength[d] >>> 0, p[0] = p[1] / 4294967296 >>> 0;
    return t.putBytes(h), Lp(e, o, t), (t.read > 2048 || t.length() === 0) && t.compact(), r;
  }, r.digest = function() {
    var h = ki.util.createBuffer();
    h.putBytes(t.bytes());
    var a = r.fullMessageLength[r.fullMessageLength.length - 1] + r.messageLengthSize, p = a & r.blockLength - 1;
    h.putBytes(_c.substr(0, r.blockLength - p));
    for (var d, b, g = r.fullMessageLength[0] * 8, w = 0; w < r.fullMessageLength.length - 1; ++w)
      d = r.fullMessageLength[w + 1] * 8, b = d / 4294967296 >>> 0, g += b, h.putInt32(g >>> 0), g = d >>> 0;
    h.putInt32(g);
    var C = {
      h0: e.h0,
      h1: e.h1,
      h2: e.h2,
      h3: e.h3,
      h4: e.h4,
      h5: e.h5,
      h6: e.h6,
      h7: e.h7
    };
    Lp(C, o, h);
    var T = ki.util.createBuffer();
    return T.putInt32(C.h0), T.putInt32(C.h1), T.putInt32(C.h2), T.putInt32(C.h3), T.putInt32(C.h4), T.putInt32(C.h5), T.putInt32(C.h6), T.putInt32(C.h7), T;
  }, r;
};
var _c = null, _2 = !1, E2 = null;
function sA() {
  _c = "", _c += ki.util.fillString("\0", 64), E2 = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], _2 = !0;
}
function Lp(e, t, o) {
  for (var r, h, a, p, d, b, g, w, C, T, k, q, O, N, j, U = o.length(); U >= 64; ) {
    for (g = 0; g < 16; ++g)
      t[g] = o.getInt32();
    for (; g < 64; ++g)
      r = t[g - 2], r = (r >>> 17 | r << 15) ^ (r >>> 19 | r << 13) ^ r >>> 10, h = t[g - 15], h = (h >>> 7 | h << 25) ^ (h >>> 18 | h << 14) ^ h >>> 3, t[g] = r + t[g - 7] + h + t[g - 16] | 0;
    for (w = e.h0, C = e.h1, T = e.h2, k = e.h3, q = e.h4, O = e.h5, N = e.h6, j = e.h7, g = 0; g < 64; ++g)
      p = (q >>> 6 | q << 26) ^ (q >>> 11 | q << 21) ^ (q >>> 25 | q << 7), d = N ^ q & (O ^ N), a = (w >>> 2 | w << 30) ^ (w >>> 13 | w << 19) ^ (w >>> 22 | w << 10), b = w & C | T & (w ^ C), r = j + p + d + E2[g] + t[g], h = a + b, j = N, N = O, O = q, q = k + r >>> 0, k = T, T = C, C = w, w = r + h >>> 0;
    e.h0 = e.h0 + w | 0, e.h1 = e.h1 + C | 0, e.h2 = e.h2 + T | 0, e.h3 = e.h3 + k | 0, e.h4 = e.h4 + q | 0, e.h5 = e.h5 + O | 0, e.h6 = e.h6 + N | 0, e.h7 = e.h7 + j | 0, U -= 64;
  }
}
var Di = ht, Ss = null;
Di.util.isNodejs && !Di.options.usePureJavaScript && !Ve.versions["node-webkit"] && (Ss = _r());
var fA = Di.prng = Di.prng || {};
fA.create = function(e) {
  for (var t = {
    plugin: e,
    key: null,
    seed: null,
    time: null,
    // number of reseeds so far
    reseeds: 0,
    // amount of data generated so far
    generated: 0,
    // no initial key bytes
    keyBytes: ""
  }, o = e.md, r = new Array(32), h = 0; h < 32; ++h)
    r[h] = o.create();
  t.pools = r, t.pool = 0, t.generate = function(g, w) {
    if (!w)
      return t.generateSync(g);
    var C = t.plugin.cipher, T = t.plugin.increment, k = t.plugin.formatKey, q = t.plugin.formatSeed, O = Di.util.createBuffer();
    t.key = null, N();
    function N(j) {
      if (j)
        return w(j);
      if (O.length() >= g)
        return w(null, O.getBytes(g));
      if (t.generated > 1048575 && (t.key = null), t.key === null)
        return Di.util.nextTick(function() {
          a(N);
        });
      var U = C(t.key, t.seed);
      t.generated += U.length, O.putBytes(U), t.key = k(C(t.key, T(t.seed))), t.seed = q(C(t.key, t.seed)), Di.util.setImmediate(N);
    }
  }, t.generateSync = function(g) {
    var w = t.plugin.cipher, C = t.plugin.increment, T = t.plugin.formatKey, k = t.plugin.formatSeed;
    t.key = null;
    for (var q = Di.util.createBuffer(); q.length() < g; ) {
      t.generated > 1048575 && (t.key = null), t.key === null && p();
      var O = w(t.key, t.seed);
      t.generated += O.length, q.putBytes(O), t.key = T(w(t.key, C(t.seed))), t.seed = k(w(t.key, t.seed));
    }
    return q.getBytes(g);
  };
  function a(g) {
    if (t.pools[0].messageLength >= 32)
      return d(), g();
    var w = 32 - t.pools[0].messageLength << 5;
    t.seedFile(w, function(C, T) {
      if (C)
        return g(C);
      t.collect(T), d(), g();
    });
  }
  function p() {
    if (t.pools[0].messageLength >= 32)
      return d();
    var g = 32 - t.pools[0].messageLength << 5;
    t.collect(t.seedFileSync(g)), d();
  }
  function d() {
    t.reseeds = t.reseeds === 4294967295 ? 0 : t.reseeds + 1;
    var g = t.plugin.md.create();
    g.update(t.keyBytes);
    for (var w = 1, C = 0; C < 32; ++C)
      t.reseeds % w === 0 && (g.update(t.pools[C].digest().getBytes()), t.pools[C].start()), w = w << 1;
    t.keyBytes = g.digest().getBytes(), g.start(), g.update(t.keyBytes);
    var T = g.digest().getBytes();
    t.key = t.plugin.formatKey(t.keyBytes), t.seed = t.plugin.formatSeed(T), t.generated = 0;
  }
  function b(g) {
    var w = null, C = Di.util.globalScope, T = C.crypto || C.msCrypto;
    T && T.getRandomValues && (w = function(ee) {
      return T.getRandomValues(ee);
    });
    var k = Di.util.createBuffer();
    if (w)
      for (; k.length() < g; ) {
        var q = Math.max(1, Math.min(g - k.length(), 65536) / 4), O = new Uint32Array(Math.floor(q));
        try {
          w(O);
          for (var N = 0; N < O.length; ++N)
            k.putInt32(O[N]);
        } catch (ee) {
          if (!(typeof QuotaExceededError < "u" && ee instanceof QuotaExceededError))
            throw ee;
        }
      }
    if (k.length() < g)
      for (var j, U, H, z = Math.floor(Math.random() * 65536); k.length() < g; ) {
        U = 16807 * (z & 65535), j = 16807 * (z >> 16), U += (j & 32767) << 16, U += j >> 15, U = (U & 2147483647) + (U >> 31), z = U & 4294967295;
        for (var N = 0; N < 3; ++N)
          H = z >>> (N << 3), H ^= Math.floor(Math.random() * 256), k.putByte(H & 255);
      }
    return k.getBytes(g);
  }
  return Ss ? (t.seedFile = function(g, w) {
    Ss.randomBytes(g, function(C, T) {
      if (C)
        return w(C);
      w(null, T.toString());
    });
  }, t.seedFileSync = function(g) {
    return Ss.randomBytes(g).toString();
  }) : (t.seedFile = function(g, w) {
    try {
      w(null, b(g));
    } catch (C) {
      w(C);
    }
  }, t.seedFileSync = b), t.collect = function(g) {
    for (var w = g.length, C = 0; C < w; ++C)
      t.pools[t.pool].update(g.substr(C, 1)), t.pool = t.pool === 31 ? 0 : t.pool + 1;
  }, t.collectInt = function(g, w) {
    for (var C = "", T = 0; T < w; T += 8)
      C += String.fromCharCode(g >> T & 255);
    t.collect(C);
  }, t.registerWorker = function(g) {
    if (g === self)
      t.seedFile = function(C, T) {
        function k(q) {
          var O = q.data;
          O.forge && O.forge.prng && (self.removeEventListener("message", k), T(O.forge.prng.err, O.forge.prng.bytes));
        }
        self.addEventListener("message", k), self.postMessage({ forge: { prng: { needed: C } } });
      };
    else {
      var w = function(C) {
        var T = C.data;
        T.forge && T.forge.prng && t.seedFile(T.forge.prng.needed, function(k, q) {
          g.postMessage({ forge: { prng: { err: k, bytes: q } } });
        });
      };
      g.addEventListener("message", w);
    }
  }, t;
};
var Yt = ht;
(function() {
  if (Yt.random && Yt.random.getBytes) {
    Yt.random;
    return;
  }
  (function(e) {
    var t = {}, o = new Array(4), r = Yt.util.createBuffer();
    t.formatKey = function(C) {
      var T = Yt.util.createBuffer(C);
      return C = new Array(4), C[0] = T.getInt32(), C[1] = T.getInt32(), C[2] = T.getInt32(), C[3] = T.getInt32(), Yt.aes._expandKey(C, !1);
    }, t.formatSeed = function(C) {
      var T = Yt.util.createBuffer(C);
      return C = new Array(4), C[0] = T.getInt32(), C[1] = T.getInt32(), C[2] = T.getInt32(), C[3] = T.getInt32(), C;
    }, t.cipher = function(C, T) {
      return Yt.aes._updateBlock(C, T, o, !1), r.putInt32(o[0]), r.putInt32(o[1]), r.putInt32(o[2]), r.putInt32(o[3]), r.getBytes();
    }, t.increment = function(C) {
      return ++C[3], C;
    }, t.md = Yt.md.sha256;
    function h() {
      var C = Yt.prng.create(t);
      return C.getBytes = function(T, k) {
        return C.generate(T, k);
      }, C.getBytesSync = function(T) {
        return C.generate(T);
      }, C;
    }
    var a = h(), p = null, d = Yt.util.globalScope, b = d.crypto || d.msCrypto;
    if (b && b.getRandomValues && (p = function(C) {
      return b.getRandomValues(C);
    }), Yt.options.usePureJavaScript || !Yt.util.isNodejs && !p) {
      if (a.collectInt(+/* @__PURE__ */ new Date(), 32), typeof navigator < "u") {
        var g = "";
        for (var w in navigator)
          try {
            typeof navigator[w] == "string" && (g += navigator[w]);
          } catch {
          }
        a.collect(g), g = null;
      }
      e && (e().mousemove(function(C) {
        a.collectInt(C.clientX, 16), a.collectInt(C.clientY, 16);
      }), e().keypress(function(C) {
        a.collectInt(C.charCode, 8);
      }));
    }
    if (!Yt.random)
      Yt.random = a;
    else
      for (var w in a)
        Yt.random[w] = a[w];
    Yt.random.createInstance = h, Yt.random;
  })(typeof jQuery < "u" ? jQuery : null);
})();
var Ar = ht, Fu = [
  217,
  120,
  249,
  196,
  25,
  221,
  181,
  237,
  40,
  233,
  253,
  121,
  74,
  160,
  216,
  157,
  198,
  126,
  55,
  131,
  43,
  118,
  83,
  142,
  98,
  76,
  100,
  136,
  68,
  139,
  251,
  162,
  23,
  154,
  89,
  245,
  135,
  179,
  79,
  19,
  97,
  69,
  109,
  141,
  9,
  129,
  125,
  50,
  189,
  143,
  64,
  235,
  134,
  183,
  123,
  11,
  240,
  149,
  33,
  34,
  92,
  107,
  78,
  130,
  84,
  214,
  101,
  147,
  206,
  96,
  178,
  28,
  115,
  86,
  192,
  20,
  167,
  140,
  241,
  220,
  18,
  117,
  202,
  31,
  59,
  190,
  228,
  209,
  66,
  61,
  212,
  48,
  163,
  60,
  182,
  38,
  111,
  191,
  14,
  218,
  70,
  105,
  7,
  87,
  39,
  242,
  29,
  155,
  188,
  148,
  67,
  3,
  248,
  17,
  199,
  246,
  144,
  239,
  62,
  231,
  6,
  195,
  213,
  47,
  200,
  102,
  30,
  215,
  8,
  232,
  234,
  222,
  128,
  82,
  238,
  247,
  132,
  170,
  114,
  172,
  53,
  77,
  106,
  42,
  150,
  26,
  210,
  113,
  90,
  21,
  73,
  116,
  75,
  159,
  208,
  94,
  4,
  24,
  164,
  236,
  194,
  224,
  65,
  110,
  15,
  81,
  203,
  204,
  36,
  145,
  175,
  80,
  161,
  244,
  112,
  57,
  153,
  124,
  58,
  133,
  35,
  184,
  180,
  122,
  252,
  2,
  54,
  91,
  37,
  85,
  151,
  49,
  45,
  93,
  250,
  152,
  227,
  138,
  146,
  174,
  5,
  223,
  41,
  16,
  103,
  108,
  186,
  201,
  211,
  0,
  230,
  207,
  225,
  158,
  168,
  44,
  99,
  22,
  1,
  63,
  88,
  226,
  137,
  169,
  13,
  56,
  52,
  27,
  171,
  51,
  255,
  176,
  187,
  72,
  12,
  95,
  185,
  177,
  205,
  46,
  197,
  243,
  219,
  71,
  229,
  165,
  156,
  119,
  10,
  166,
  32,
  104,
  254,
  127,
  193,
  173
], kp = [1, 2, 3, 5], oA = function(e, t) {
  return e << t & 65535 | (e & 65535) >> 16 - t;
}, uA = function(e, t) {
  return (e & 65535) >> t | e << 16 - t & 65535;
};
Ar.rc2 = Ar.rc2 || {};
Ar.rc2.expandKey = function(e, t) {
  typeof e == "string" && (e = Ar.util.createBuffer(e)), t = t || 128;
  var o = e, r = e.length(), h = t, a = Math.ceil(h / 8), p = 255 >> (h & 7), d;
  for (d = r; d < 128; d++)
    o.putByte(Fu[o.at(d - 1) + o.at(d - r) & 255]);
  for (o.setAt(128 - a, Fu[o.at(128 - a) & p]), d = 127 - a; d >= 0; d--)
    o.setAt(d, Fu[o.at(d + 1) ^ o.at(d + a)]);
  return o;
};
var S2 = function(e, t, o) {
  var r = !1, h = null, a = null, p = null, d, b, g, w, C = [];
  for (e = Ar.rc2.expandKey(e, t), g = 0; g < 64; g++)
    C.push(e.getInt16Le());
  o ? (d = function(q) {
    for (g = 0; g < 4; g++)
      q[g] += C[w] + (q[(g + 3) % 4] & q[(g + 2) % 4]) + (~q[(g + 3) % 4] & q[(g + 1) % 4]), q[g] = oA(q[g], kp[g]), w++;
  }, b = function(q) {
    for (g = 0; g < 4; g++)
      q[g] += C[q[(g + 3) % 4] & 63];
  }) : (d = function(q) {
    for (g = 3; g >= 0; g--)
      q[g] = uA(q[g], kp[g]), q[g] -= C[w] + (q[(g + 3) % 4] & q[(g + 2) % 4]) + (~q[(g + 3) % 4] & q[(g + 1) % 4]), w--;
  }, b = function(q) {
    for (g = 3; g >= 0; g--)
      q[g] -= C[q[(g + 3) % 4] & 63];
  });
  var T = function(q) {
    var O = [];
    for (g = 0; g < 4; g++) {
      var N = h.getInt16Le();
      p !== null && (o ? N ^= p.getInt16Le() : p.putInt16Le(N)), O.push(N & 65535);
    }
    w = o ? 0 : 63;
    for (var j = 0; j < q.length; j++)
      for (var U = 0; U < q[j][0]; U++)
        q[j][1](O);
    for (g = 0; g < 4; g++)
      p !== null && (o ? p.putInt16Le(O[g]) : O[g] ^= p.getInt16Le()), a.putInt16Le(O[g]);
  }, k = null;
  return k = {
    /**
     * Starts or restarts the encryption or decryption process, whichever
     * was previously configured.
     *
     * To use the cipher in CBC mode, iv may be given either as a string
     * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
     *
     * @param iv the initialization vector to use, null for ECB mode.
     * @param output the output the buffer to write to, null to create one.
     */
    start: function(q, O) {
      q && typeof q == "string" && (q = Ar.util.createBuffer(q)), r = !1, h = Ar.util.createBuffer(), a = O || new Ar.util.createBuffer(), p = q, k.output = a;
    },
    /**
     * Updates the next block.
     *
     * @param input the buffer to read from.
     */
    update: function(q) {
      for (r || h.putBuffer(q); h.length() >= 8; )
        T([
          [5, d],
          [1, b],
          [6, d],
          [1, b],
          [5, d]
        ]);
    },
    /**
     * Finishes encrypting or decrypting.
     *
     * @param pad a padding function to use, null for PKCS#7 padding,
     *           signature(blockSize, buffer, decrypt).
     *
     * @return true if successful, false on error.
     */
    finish: function(q) {
      var O = !0;
      if (o)
        if (q)
          O = q(8, h, !o);
        else {
          var N = h.length() === 8 ? 8 : 8 - h.length();
          h.fillWithByte(N, N);
        }
      if (O && (r = !0, k.update()), !o && (O = h.length() === 0, O))
        if (q)
          O = q(8, a, !o);
        else {
          var j = a.length(), U = a.at(j - 1);
          U > j ? O = !1 : a.truncate(U);
        }
      return O;
    }
  }, k;
};
Ar.rc2.startEncrypting = function(e, t, o) {
  var r = Ar.rc2.createEncryptionCipher(e, 128);
  return r.start(t, o), r;
};
Ar.rc2.createEncryptionCipher = function(e, t) {
  return S2(e, t, !0);
};
Ar.rc2.startDecrypting = function(e, t, o) {
  var r = Ar.rc2.createDecryptionCipher(e, 128);
  return r.start(t, o), r;
};
Ar.rc2.createDecryptionCipher = function(e, t) {
  return S2(e, t, !1);
};
var Ec = ht;
Ec.jsbn = Ec.jsbn || {};
var rn;
function _e(e, t, o) {
  this.data = [], e != null && (typeof e == "number" ? this.fromNumber(e, t, o) : t == null && typeof e != "string" ? this.fromString(e, 256) : this.fromString(e, t));
}
Ec.jsbn.BigInteger = _e;
function Et() {
  return new _e(null);
}
function cA(e, t, o, r, h, a) {
  for (; --a >= 0; ) {
    var p = t * this.data[e++] + o.data[r] + h;
    h = Math.floor(p / 67108864), o.data[r++] = p & 67108863;
  }
  return h;
}
function hA(e, t, o, r, h, a) {
  for (var p = t & 32767, d = t >> 15; --a >= 0; ) {
    var b = this.data[e] & 32767, g = this.data[e++] >> 15, w = d * b + g * p;
    b = p * b + ((w & 32767) << 15) + o.data[r] + (h & 1073741823), h = (b >>> 30) + (w >>> 15) + d * g + (h >>> 30), o.data[r++] = b & 1073741823;
  }
  return h;
}
function Up(e, t, o, r, h, a) {
  for (var p = t & 16383, d = t >> 14; --a >= 0; ) {
    var b = this.data[e] & 16383, g = this.data[e++] >> 14, w = d * b + g * p;
    b = p * b + ((w & 16383) << 14) + o.data[r] + h, h = (b >> 28) + (w >> 14) + d * g, o.data[r++] = b & 268435455;
  }
  return h;
}
typeof navigator > "u" ? (_e.prototype.am = Up, rn = 28) : navigator.appName == "Microsoft Internet Explorer" ? (_e.prototype.am = hA, rn = 30) : navigator.appName != "Netscape" ? (_e.prototype.am = cA, rn = 26) : (_e.prototype.am = Up, rn = 28);
_e.prototype.DB = rn;
_e.prototype.DM = (1 << rn) - 1;
_e.prototype.DV = 1 << rn;
var qh = 52;
_e.prototype.FV = Math.pow(2, qh);
_e.prototype.F1 = qh - rn;
_e.prototype.F2 = 2 * rn - qh;
var lA = "0123456789abcdefghijklmnopqrstuvwxyz", Ff = new Array(), e0, $r;
e0 = 48;
for ($r = 0; $r <= 9; ++$r)
  Ff[e0++] = $r;
e0 = 97;
for ($r = 10; $r < 36; ++$r)
  Ff[e0++] = $r;
e0 = 65;
for ($r = 10; $r < 36; ++$r)
  Ff[e0++] = $r;
function Fp(e) {
  return lA.charAt(e);
}
function w2(e, t) {
  var o = Ff[e.charCodeAt(t)];
  return o ?? -1;
}
function dA(e) {
  for (var t = this.t - 1; t >= 0; --t)
    e.data[t] = this.data[t];
  e.t = this.t, e.s = this.s;
}
function pA(e) {
  this.t = 1, this.s = e < 0 ? -1 : 0, e > 0 ? this.data[0] = e : e < -1 ? this.data[0] = e + this.DV : this.t = 0;
}
function bn(e) {
  var t = Et();
  return t.fromInt(e), t;
}
function vA(e, t) {
  var o;
  if (t == 16)
    o = 4;
  else if (t == 8)
    o = 3;
  else if (t == 256)
    o = 8;
  else if (t == 2)
    o = 1;
  else if (t == 32)
    o = 5;
  else if (t == 4)
    o = 2;
  else {
    this.fromRadix(e, t);
    return;
  }
  this.t = 0, this.s = 0;
  for (var r = e.length, h = !1, a = 0; --r >= 0; ) {
    var p = o == 8 ? e[r] & 255 : w2(e, r);
    if (p < 0) {
      e.charAt(r) == "-" && (h = !0);
      continue;
    }
    h = !1, a == 0 ? this.data[this.t++] = p : a + o > this.DB ? (this.data[this.t - 1] |= (p & (1 << this.DB - a) - 1) << a, this.data[this.t++] = p >> this.DB - a) : this.data[this.t - 1] |= p << a, a += o, a >= this.DB && (a -= this.DB);
  }
  o == 8 && e[0] & 128 && (this.s = -1, a > 0 && (this.data[this.t - 1] |= (1 << this.DB - a) - 1 << a)), this.clamp(), h && _e.ZERO.subTo(this, this);
}
function yA() {
  for (var e = this.s & this.DM; this.t > 0 && this.data[this.t - 1] == e; )
    --this.t;
}
function gA(e) {
  if (this.s < 0)
    return "-" + this.negate().toString(e);
  var t;
  if (e == 16)
    t = 4;
  else if (e == 8)
    t = 3;
  else if (e == 2)
    t = 1;
  else if (e == 32)
    t = 5;
  else if (e == 4)
    t = 2;
  else
    return this.toRadix(e);
  var o = (1 << t) - 1, r, h = !1, a = "", p = this.t, d = this.DB - p * this.DB % t;
  if (p-- > 0)
    for (d < this.DB && (r = this.data[p] >> d) > 0 && (h = !0, a = Fp(r)); p >= 0; )
      d < t ? (r = (this.data[p] & (1 << d) - 1) << t - d, r |= this.data[--p] >> (d += this.DB - t)) : (r = this.data[p] >> (d -= t) & o, d <= 0 && (d += this.DB, --p)), r > 0 && (h = !0), h && (a += Fp(r));
  return h ? a : "0";
}
function mA() {
  var e = Et();
  return _e.ZERO.subTo(this, e), e;
}
function bA() {
  return this.s < 0 ? this.negate() : this;
}
function xA(e) {
  var t = this.s - e.s;
  if (t != 0)
    return t;
  var o = this.t;
  if (t = o - e.t, t != 0)
    return this.s < 0 ? -t : t;
  for (; --o >= 0; )
    if ((t = this.data[o] - e.data[o]) != 0)
      return t;
  return 0;
}
function qf(e) {
  var t = 1, o;
  return (o = e >>> 16) != 0 && (e = o, t += 16), (o = e >> 8) != 0 && (e = o, t += 8), (o = e >> 4) != 0 && (e = o, t += 4), (o = e >> 2) != 0 && (e = o, t += 2), (o = e >> 1) != 0 && (e = o, t += 1), t;
}
function _A() {
  return this.t <= 0 ? 0 : this.DB * (this.t - 1) + qf(this.data[this.t - 1] ^ this.s & this.DM);
}
function EA(e, t) {
  var o;
  for (o = this.t - 1; o >= 0; --o)
    t.data[o + e] = this.data[o];
  for (o = e - 1; o >= 0; --o)
    t.data[o] = 0;
  t.t = this.t + e, t.s = this.s;
}
function SA(e, t) {
  for (var o = e; o < this.t; ++o)
    t.data[o - e] = this.data[o];
  t.t = Math.max(this.t - e, 0), t.s = this.s;
}
function wA(e, t) {
  var o = e % this.DB, r = this.DB - o, h = (1 << r) - 1, a = Math.floor(e / this.DB), p = this.s << o & this.DM, d;
  for (d = this.t - 1; d >= 0; --d)
    t.data[d + a + 1] = this.data[d] >> r | p, p = (this.data[d] & h) << o;
  for (d = a - 1; d >= 0; --d)
    t.data[d] = 0;
  t.data[a] = p, t.t = this.t + a + 1, t.s = this.s, t.clamp();
}
function CA(e, t) {
  t.s = this.s;
  var o = Math.floor(e / this.DB);
  if (o >= this.t) {
    t.t = 0;
    return;
  }
  var r = e % this.DB, h = this.DB - r, a = (1 << r) - 1;
  t.data[0] = this.data[o] >> r;
  for (var p = o + 1; p < this.t; ++p)
    t.data[p - o - 1] |= (this.data[p] & a) << h, t.data[p - o] = this.data[p] >> r;
  r > 0 && (t.data[this.t - o - 1] |= (this.s & a) << h), t.t = this.t - o, t.clamp();
}
function AA(e, t) {
  for (var o = 0, r = 0, h = Math.min(e.t, this.t); o < h; )
    r += this.data[o] - e.data[o], t.data[o++] = r & this.DM, r >>= this.DB;
  if (e.t < this.t) {
    for (r -= e.s; o < this.t; )
      r += this.data[o], t.data[o++] = r & this.DM, r >>= this.DB;
    r += this.s;
  } else {
    for (r += this.s; o < e.t; )
      r -= e.data[o], t.data[o++] = r & this.DM, r >>= this.DB;
    r -= e.s;
  }
  t.s = r < 0 ? -1 : 0, r < -1 ? t.data[o++] = this.DV + r : r > 0 && (t.data[o++] = r), t.t = o, t.clamp();
}
function BA(e, t) {
  var o = this.abs(), r = e.abs(), h = o.t;
  for (t.t = h + r.t; --h >= 0; )
    t.data[h] = 0;
  for (h = 0; h < r.t; ++h)
    t.data[h + o.t] = o.am(0, r.data[h], t, h, 0, o.t);
  t.s = 0, t.clamp(), this.s != e.s && _e.ZERO.subTo(t, t);
}
function IA(e) {
  for (var t = this.abs(), o = e.t = 2 * t.t; --o >= 0; )
    e.data[o] = 0;
  for (o = 0; o < t.t - 1; ++o) {
    var r = t.am(o, t.data[o], e, 2 * o, 0, 1);
    (e.data[o + t.t] += t.am(o + 1, 2 * t.data[o], e, 2 * o + 1, r, t.t - o - 1)) >= t.DV && (e.data[o + t.t] -= t.DV, e.data[o + t.t + 1] = 1);
  }
  e.t > 0 && (e.data[e.t - 1] += t.am(o, t.data[o], e, 2 * o, 0, 1)), e.s = 0, e.clamp();
}
function TA(e, t, o) {
  var r = e.abs();
  if (!(r.t <= 0)) {
    var h = this.abs();
    if (h.t < r.t) {
      t != null && t.fromInt(0), o != null && this.copyTo(o);
      return;
    }
    o == null && (o = Et());
    var a = Et(), p = this.s, d = e.s, b = this.DB - qf(r.data[r.t - 1]);
    b > 0 ? (r.lShiftTo(b, a), h.lShiftTo(b, o)) : (r.copyTo(a), h.copyTo(o));
    var g = a.t, w = a.data[g - 1];
    if (w != 0) {
      var C = w * (1 << this.F1) + (g > 1 ? a.data[g - 2] >> this.F2 : 0), T = this.FV / C, k = (1 << this.F1) / C, q = 1 << this.F2, O = o.t, N = O - g, j = t ?? Et();
      for (a.dlShiftTo(N, j), o.compareTo(j) >= 0 && (o.data[o.t++] = 1, o.subTo(j, o)), _e.ONE.dlShiftTo(g, j), j.subTo(a, a); a.t < g; )
        a.data[a.t++] = 0;
      for (; --N >= 0; ) {
        var U = o.data[--O] == w ? this.DM : Math.floor(o.data[O] * T + (o.data[O - 1] + q) * k);
        if ((o.data[O] += a.am(0, U, o, N, 0, g)) < U)
          for (a.dlShiftTo(N, j), o.subTo(j, o); o.data[O] < --U; )
            o.subTo(j, o);
      }
      t != null && (o.drShiftTo(g, t), p != d && _e.ZERO.subTo(t, t)), o.t = g, o.clamp(), b > 0 && o.rShiftTo(b, o), p < 0 && _e.ZERO.subTo(o, o);
    }
  }
}
function MA(e) {
  var t = Et();
  return this.abs().divRemTo(e, null, t), this.s < 0 && t.compareTo(_e.ZERO) > 0 && e.subTo(t, t), t;
}
function oa(e) {
  this.m = e;
}
function RA(e) {
  return e.s < 0 || e.compareTo(this.m) >= 0 ? e.mod(this.m) : e;
}
function NA(e) {
  return e;
}
function DA(e) {
  e.divRemTo(this.m, null, e);
}
function OA(e, t, o) {
  e.multiplyTo(t, o), this.reduce(o);
}
function PA(e, t) {
  e.squareTo(t), this.reduce(t);
}
oa.prototype.convert = RA;
oa.prototype.revert = NA;
oa.prototype.reduce = DA;
oa.prototype.mulTo = OA;
oa.prototype.sqrTo = PA;
function LA() {
  if (this.t < 1)
    return 0;
  var e = this.data[0];
  if (!(e & 1))
    return 0;
  var t = e & 3;
  return t = t * (2 - (e & 15) * t) & 15, t = t * (2 - (e & 255) * t) & 255, t = t * (2 - ((e & 65535) * t & 65535)) & 65535, t = t * (2 - e * t % this.DV) % this.DV, t > 0 ? this.DV - t : -t;
}
function ua(e) {
  this.m = e, this.mp = e.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << e.DB - 15) - 1, this.mt2 = 2 * e.t;
}
function kA(e) {
  var t = Et();
  return e.abs().dlShiftTo(this.m.t, t), t.divRemTo(this.m, null, t), e.s < 0 && t.compareTo(_e.ZERO) > 0 && this.m.subTo(t, t), t;
}
function UA(e) {
  var t = Et();
  return e.copyTo(t), this.reduce(t), t;
}
function FA(e) {
  for (; e.t <= this.mt2; )
    e.data[e.t++] = 0;
  for (var t = 0; t < this.m.t; ++t) {
    var o = e.data[t] & 32767, r = o * this.mpl + ((o * this.mph + (e.data[t] >> 15) * this.mpl & this.um) << 15) & e.DM;
    for (o = t + this.m.t, e.data[o] += this.m.am(0, r, e, t, 0, this.m.t); e.data[o] >= e.DV; )
      e.data[o] -= e.DV, e.data[++o]++;
  }
  e.clamp(), e.drShiftTo(this.m.t, e), e.compareTo(this.m) >= 0 && e.subTo(this.m, e);
}
function qA(e, t) {
  e.squareTo(t), this.reduce(t);
}
function VA(e, t, o) {
  e.multiplyTo(t, o), this.reduce(o);
}
ua.prototype.convert = kA;
ua.prototype.revert = UA;
ua.prototype.reduce = FA;
ua.prototype.mulTo = VA;
ua.prototype.sqrTo = qA;
function KA() {
  return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
}
function $A(e, t) {
  if (e > 4294967295 || e < 1)
    return _e.ONE;
  var o = Et(), r = Et(), h = t.convert(this), a = qf(e) - 1;
  for (h.copyTo(o); --a >= 0; )
    if (t.sqrTo(o, r), (e & 1 << a) > 0)
      t.mulTo(r, h, o);
    else {
      var p = o;
      o = r, r = p;
    }
  return t.revert(o);
}
function HA(e, t) {
  var o;
  return e < 256 || t.isEven() ? o = new oa(t) : o = new ua(t), this.exp(e, o);
}
_e.prototype.copyTo = dA;
_e.prototype.fromInt = pA;
_e.prototype.fromString = vA;
_e.prototype.clamp = yA;
_e.prototype.dlShiftTo = EA;
_e.prototype.drShiftTo = SA;
_e.prototype.lShiftTo = wA;
_e.prototype.rShiftTo = CA;
_e.prototype.subTo = AA;
_e.prototype.multiplyTo = BA;
_e.prototype.squareTo = IA;
_e.prototype.divRemTo = TA;
_e.prototype.invDigit = LA;
_e.prototype.isEven = KA;
_e.prototype.exp = $A;
_e.prototype.toString = gA;
_e.prototype.negate = mA;
_e.prototype.abs = bA;
_e.prototype.compareTo = xA;
_e.prototype.bitLength = _A;
_e.prototype.mod = MA;
_e.prototype.modPowInt = HA;
_e.ZERO = bn(0);
_e.ONE = bn(1);
function GA() {
  var e = Et();
  return this.copyTo(e), e;
}
function zA() {
  if (this.s < 0) {
    if (this.t == 1)
      return this.data[0] - this.DV;
    if (this.t == 0)
      return -1;
  } else {
    if (this.t == 1)
      return this.data[0];
    if (this.t == 0)
      return 0;
  }
  return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
}
function jA() {
  return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
}
function WA() {
  return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
}
function YA(e) {
  return Math.floor(Math.LN2 * this.DB / Math.log(e));
}
function XA() {
  return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this.data[0] <= 0 ? 0 : 1;
}
function QA(e) {
  if (e == null && (e = 10), this.signum() == 0 || e < 2 || e > 36)
    return "0";
  var t = this.chunkSize(e), o = Math.pow(e, t), r = bn(o), h = Et(), a = Et(), p = "";
  for (this.divRemTo(r, h, a); h.signum() > 0; )
    p = (o + a.intValue()).toString(e).substr(1) + p, h.divRemTo(r, h, a);
  return a.intValue().toString(e) + p;
}
function ZA(e, t) {
  this.fromInt(0), t == null && (t = 10);
  for (var o = this.chunkSize(t), r = Math.pow(t, o), h = !1, a = 0, p = 0, d = 0; d < e.length; ++d) {
    var b = w2(e, d);
    if (b < 0) {
      e.charAt(d) == "-" && this.signum() == 0 && (h = !0);
      continue;
    }
    p = t * p + b, ++a >= o && (this.dMultiply(r), this.dAddOffset(p, 0), a = 0, p = 0);
  }
  a > 0 && (this.dMultiply(Math.pow(t, a)), this.dAddOffset(p, 0)), h && _e.ZERO.subTo(this, this);
}
function JA(e, t, o) {
  if (typeof t == "number")
    if (e < 2)
      this.fromInt(1);
    else
      for (this.fromNumber(e, o), this.testBit(e - 1) || this.bitwiseTo(_e.ONE.shiftLeft(e - 1), Vh, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(t); )
        this.dAddOffset(2, 0), this.bitLength() > e && this.subTo(_e.ONE.shiftLeft(e - 1), this);
  else {
    var r = new Array(), h = e & 7;
    r.length = (e >> 3) + 1, t.nextBytes(r), h > 0 ? r[0] &= (1 << h) - 1 : r[0] = 0, this.fromString(r, 256);
  }
}
function eB() {
  var e = this.t, t = new Array();
  t[0] = this.s;
  var o = this.DB - e * this.DB % 8, r, h = 0;
  if (e-- > 0)
    for (o < this.DB && (r = this.data[e] >> o) != (this.s & this.DM) >> o && (t[h++] = r | this.s << this.DB - o); e >= 0; )
      o < 8 ? (r = (this.data[e] & (1 << o) - 1) << 8 - o, r |= this.data[--e] >> (o += this.DB - 8)) : (r = this.data[e] >> (o -= 8) & 255, o <= 0 && (o += this.DB, --e)), r & 128 && (r |= -256), h == 0 && (this.s & 128) != (r & 128) && ++h, (h > 0 || r != this.s) && (t[h++] = r);
  return t;
}
function tB(e) {
  return this.compareTo(e) == 0;
}
function rB(e) {
  return this.compareTo(e) < 0 ? this : e;
}
function iB(e) {
  return this.compareTo(e) > 0 ? this : e;
}
function nB(e, t, o) {
  var r, h, a = Math.min(e.t, this.t);
  for (r = 0; r < a; ++r)
    o.data[r] = t(this.data[r], e.data[r]);
  if (e.t < this.t) {
    for (h = e.s & this.DM, r = a; r < this.t; ++r)
      o.data[r] = t(this.data[r], h);
    o.t = this.t;
  } else {
    for (h = this.s & this.DM, r = a; r < e.t; ++r)
      o.data[r] = t(h, e.data[r]);
    o.t = e.t;
  }
  o.s = t(this.s, e.s), o.clamp();
}
function aB(e, t) {
  return e & t;
}
function sB(e) {
  var t = Et();
  return this.bitwiseTo(e, aB, t), t;
}
function Vh(e, t) {
  return e | t;
}
function fB(e) {
  var t = Et();
  return this.bitwiseTo(e, Vh, t), t;
}
function C2(e, t) {
  return e ^ t;
}
function oB(e) {
  var t = Et();
  return this.bitwiseTo(e, C2, t), t;
}
function A2(e, t) {
  return e & ~t;
}
function uB(e) {
  var t = Et();
  return this.bitwiseTo(e, A2, t), t;
}
function cB() {
  for (var e = Et(), t = 0; t < this.t; ++t)
    e.data[t] = this.DM & ~this.data[t];
  return e.t = this.t, e.s = ~this.s, e;
}
function hB(e) {
  var t = Et();
  return e < 0 ? this.rShiftTo(-e, t) : this.lShiftTo(e, t), t;
}
function lB(e) {
  var t = Et();
  return e < 0 ? this.lShiftTo(-e, t) : this.rShiftTo(e, t), t;
}
function dB(e) {
  if (e == 0)
    return -1;
  var t = 0;
  return e & 65535 || (e >>= 16, t += 16), e & 255 || (e >>= 8, t += 8), e & 15 || (e >>= 4, t += 4), e & 3 || (e >>= 2, t += 2), e & 1 || ++t, t;
}
function pB() {
  for (var e = 0; e < this.t; ++e)
    if (this.data[e] != 0)
      return e * this.DB + dB(this.data[e]);
  return this.s < 0 ? this.t * this.DB : -1;
}
function vB(e) {
  for (var t = 0; e != 0; )
    e &= e - 1, ++t;
  return t;
}
function yB() {
  for (var e = 0, t = this.s & this.DM, o = 0; o < this.t; ++o)
    e += vB(this.data[o] ^ t);
  return e;
}
function gB(e) {
  var t = Math.floor(e / this.DB);
  return t >= this.t ? this.s != 0 : (this.data[t] & 1 << e % this.DB) != 0;
}
function mB(e, t) {
  var o = _e.ONE.shiftLeft(e);
  return this.bitwiseTo(o, t, o), o;
}
function bB(e) {
  return this.changeBit(e, Vh);
}
function xB(e) {
  return this.changeBit(e, A2);
}
function _B(e) {
  return this.changeBit(e, C2);
}
function EB(e, t) {
  for (var o = 0, r = 0, h = Math.min(e.t, this.t); o < h; )
    r += this.data[o] + e.data[o], t.data[o++] = r & this.DM, r >>= this.DB;
  if (e.t < this.t) {
    for (r += e.s; o < this.t; )
      r += this.data[o], t.data[o++] = r & this.DM, r >>= this.DB;
    r += this.s;
  } else {
    for (r += this.s; o < e.t; )
      r += e.data[o], t.data[o++] = r & this.DM, r >>= this.DB;
    r += e.s;
  }
  t.s = r < 0 ? -1 : 0, r > 0 ? t.data[o++] = r : r < -1 && (t.data[o++] = this.DV + r), t.t = o, t.clamp();
}
function SB(e) {
  var t = Et();
  return this.addTo(e, t), t;
}
function wB(e) {
  var t = Et();
  return this.subTo(e, t), t;
}
function CB(e) {
  var t = Et();
  return this.multiplyTo(e, t), t;
}
function AB(e) {
  var t = Et();
  return this.divRemTo(e, t, null), t;
}
function BB(e) {
  var t = Et();
  return this.divRemTo(e, null, t), t;
}
function IB(e) {
  var t = Et(), o = Et();
  return this.divRemTo(e, t, o), new Array(t, o);
}
function TB(e) {
  this.data[this.t] = this.am(0, e - 1, this, 0, 0, this.t), ++this.t, this.clamp();
}
function MB(e, t) {
  if (e != 0) {
    for (; this.t <= t; )
      this.data[this.t++] = 0;
    for (this.data[t] += e; this.data[t] >= this.DV; )
      this.data[t] -= this.DV, ++t >= this.t && (this.data[this.t++] = 0), ++this.data[t];
  }
}
function W0() {
}
function B2(e) {
  return e;
}
function RB(e, t, o) {
  e.multiplyTo(t, o);
}
function NB(e, t) {
  e.squareTo(t);
}
W0.prototype.convert = B2;
W0.prototype.revert = B2;
W0.prototype.mulTo = RB;
W0.prototype.sqrTo = NB;
function DB(e) {
  return this.exp(e, new W0());
}
function OB(e, t, o) {
  var r = Math.min(this.t + e.t, t);
  for (o.s = 0, o.t = r; r > 0; )
    o.data[--r] = 0;
  var h;
  for (h = o.t - this.t; r < h; ++r)
    o.data[r + this.t] = this.am(0, e.data[r], o, r, 0, this.t);
  for (h = Math.min(e.t, t); r < h; ++r)
    this.am(0, e.data[r], o, r, 0, t - r);
  o.clamp();
}
function PB(e, t, o) {
  --t;
  var r = o.t = this.t + e.t - t;
  for (o.s = 0; --r >= 0; )
    o.data[r] = 0;
  for (r = Math.max(t - this.t, 0); r < e.t; ++r)
    o.data[this.t + r - t] = this.am(t - r, e.data[r], o, 0, 0, this.t + r - t);
  o.clamp(), o.drShiftTo(1, o);
}
function t0(e) {
  this.r2 = Et(), this.q3 = Et(), _e.ONE.dlShiftTo(2 * e.t, this.r2), this.mu = this.r2.divide(e), this.m = e;
}
function LB(e) {
  if (e.s < 0 || e.t > 2 * this.m.t)
    return e.mod(this.m);
  if (e.compareTo(this.m) < 0)
    return e;
  var t = Et();
  return e.copyTo(t), this.reduce(t), t;
}
function kB(e) {
  return e;
}
function UB(e) {
  for (e.drShiftTo(this.m.t - 1, this.r2), e.t > this.m.t + 1 && (e.t = this.m.t + 1, e.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); e.compareTo(this.r2) < 0; )
    e.dAddOffset(1, this.m.t + 1);
  for (e.subTo(this.r2, e); e.compareTo(this.m) >= 0; )
    e.subTo(this.m, e);
}
function FB(e, t) {
  e.squareTo(t), this.reduce(t);
}
function qB(e, t, o) {
  e.multiplyTo(t, o), this.reduce(o);
}
t0.prototype.convert = LB;
t0.prototype.revert = kB;
t0.prototype.reduce = UB;
t0.prototype.mulTo = qB;
t0.prototype.sqrTo = FB;
function VB(e, t) {
  var o = e.bitLength(), r, h = bn(1), a;
  if (o <= 0)
    return h;
  o < 18 ? r = 1 : o < 48 ? r = 3 : o < 144 ? r = 4 : o < 768 ? r = 5 : r = 6, o < 8 ? a = new oa(t) : t.isEven() ? a = new t0(t) : a = new ua(t);
  var p = new Array(), d = 3, b = r - 1, g = (1 << r) - 1;
  if (p[1] = a.convert(this), r > 1) {
    var w = Et();
    for (a.sqrTo(p[1], w); d <= g; )
      p[d] = Et(), a.mulTo(w, p[d - 2], p[d]), d += 2;
  }
  var C = e.t - 1, T, k = !0, q = Et(), O;
  for (o = qf(e.data[C]) - 1; C >= 0; ) {
    for (o >= b ? T = e.data[C] >> o - b & g : (T = (e.data[C] & (1 << o + 1) - 1) << b - o, C > 0 && (T |= e.data[C - 1] >> this.DB + o - b)), d = r; !(T & 1); )
      T >>= 1, --d;
    if ((o -= d) < 0 && (o += this.DB, --C), k)
      p[T].copyTo(h), k = !1;
    else {
      for (; d > 1; )
        a.sqrTo(h, q), a.sqrTo(q, h), d -= 2;
      d > 0 ? a.sqrTo(h, q) : (O = h, h = q, q = O), a.mulTo(q, p[T], h);
    }
    for (; C >= 0 && !(e.data[C] & 1 << o); )
      a.sqrTo(h, q), O = h, h = q, q = O, --o < 0 && (o = this.DB - 1, --C);
  }
  return a.revert(h);
}
function KB(e) {
  var t = this.s < 0 ? this.negate() : this.clone(), o = e.s < 0 ? e.negate() : e.clone();
  if (t.compareTo(o) < 0) {
    var r = t;
    t = o, o = r;
  }
  var h = t.getLowestSetBit(), a = o.getLowestSetBit();
  if (a < 0)
    return t;
  for (h < a && (a = h), a > 0 && (t.rShiftTo(a, t), o.rShiftTo(a, o)); t.signum() > 0; )
    (h = t.getLowestSetBit()) > 0 && t.rShiftTo(h, t), (h = o.getLowestSetBit()) > 0 && o.rShiftTo(h, o), t.compareTo(o) >= 0 ? (t.subTo(o, t), t.rShiftTo(1, t)) : (o.subTo(t, o), o.rShiftTo(1, o));
  return a > 0 && o.lShiftTo(a, o), o;
}
function $B(e) {
  if (e <= 0)
    return 0;
  var t = this.DV % e, o = this.s < 0 ? e - 1 : 0;
  if (this.t > 0)
    if (t == 0)
      o = this.data[0] % e;
    else
      for (var r = this.t - 1; r >= 0; --r)
        o = (t * o + this.data[r]) % e;
  return o;
}
function HB(e) {
  var t = e.isEven();
  if (this.isEven() && t || e.signum() == 0)
    return _e.ZERO;
  for (var o = e.clone(), r = this.clone(), h = bn(1), a = bn(0), p = bn(0), d = bn(1); o.signum() != 0; ) {
    for (; o.isEven(); )
      o.rShiftTo(1, o), t ? ((!h.isEven() || !a.isEven()) && (h.addTo(this, h), a.subTo(e, a)), h.rShiftTo(1, h)) : a.isEven() || a.subTo(e, a), a.rShiftTo(1, a);
    for (; r.isEven(); )
      r.rShiftTo(1, r), t ? ((!p.isEven() || !d.isEven()) && (p.addTo(this, p), d.subTo(e, d)), p.rShiftTo(1, p)) : d.isEven() || d.subTo(e, d), d.rShiftTo(1, d);
    o.compareTo(r) >= 0 ? (o.subTo(r, o), t && h.subTo(p, h), a.subTo(d, a)) : (r.subTo(o, r), t && p.subTo(h, p), d.subTo(a, d));
  }
  if (r.compareTo(_e.ONE) != 0)
    return _e.ZERO;
  if (d.compareTo(e) >= 0)
    return d.subtract(e);
  if (d.signum() < 0)
    d.addTo(e, d);
  else
    return d;
  return d.signum() < 0 ? d.add(e) : d;
}
var xi = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509], GB = (1 << 26) / xi[xi.length - 1];
function zB(e) {
  var t, o = this.abs();
  if (o.t == 1 && o.data[0] <= xi[xi.length - 1]) {
    for (t = 0; t < xi.length; ++t)
      if (o.data[0] == xi[t])
        return !0;
    return !1;
  }
  if (o.isEven())
    return !1;
  for (t = 1; t < xi.length; ) {
    for (var r = xi[t], h = t + 1; h < xi.length && r < GB; )
      r *= xi[h++];
    for (r = o.modInt(r); t < h; )
      if (r % xi[t++] == 0)
        return !1;
  }
  return o.millerRabin(e);
}
function jB(e) {
  var t = this.subtract(_e.ONE), o = t.getLowestSetBit();
  if (o <= 0)
    return !1;
  for (var r = t.shiftRight(o), h = WB(), a, p = 0; p < e; ++p) {
    do
      a = new _e(this.bitLength(), h);
    while (a.compareTo(_e.ONE) <= 0 || a.compareTo(t) >= 0);
    var d = a.modPow(r, this);
    if (d.compareTo(_e.ONE) != 0 && d.compareTo(t) != 0) {
      for (var b = 1; b++ < o && d.compareTo(t) != 0; )
        if (d = d.modPowInt(2, this), d.compareTo(_e.ONE) == 0)
          return !1;
      if (d.compareTo(t) != 0)
        return !1;
    }
  }
  return !0;
}
function WB() {
  return {
    // x is an array to fill with bytes
    nextBytes: function(e) {
      for (var t = 0; t < e.length; ++t)
        e[t] = Math.floor(Math.random() * 256);
    }
  };
}
_e.prototype.chunkSize = YA;
_e.prototype.toRadix = QA;
_e.prototype.fromRadix = ZA;
_e.prototype.fromNumber = JA;
_e.prototype.bitwiseTo = nB;
_e.prototype.changeBit = mB;
_e.prototype.addTo = EB;
_e.prototype.dMultiply = TB;
_e.prototype.dAddOffset = MB;
_e.prototype.multiplyLowerTo = OB;
_e.prototype.multiplyUpperTo = PB;
_e.prototype.modInt = $B;
_e.prototype.millerRabin = jB;
_e.prototype.clone = GA;
_e.prototype.intValue = zA;
_e.prototype.byteValue = jA;
_e.prototype.shortValue = WA;
_e.prototype.signum = XA;
_e.prototype.toByteArray = eB;
_e.prototype.equals = tB;
_e.prototype.min = rB;
_e.prototype.max = iB;
_e.prototype.and = sB;
_e.prototype.or = fB;
_e.prototype.xor = oB;
_e.prototype.andNot = uB;
_e.prototype.not = cB;
_e.prototype.shiftLeft = hB;
_e.prototype.shiftRight = lB;
_e.prototype.getLowestSetBit = pB;
_e.prototype.bitCount = yB;
_e.prototype.testBit = gB;
_e.prototype.setBit = bB;
_e.prototype.clearBit = xB;
_e.prototype.flipBit = _B;
_e.prototype.add = SB;
_e.prototype.subtract = wB;
_e.prototype.multiply = CB;
_e.prototype.divide = AB;
_e.prototype.remainder = BB;
_e.prototype.divideAndRemainder = IB;
_e.prototype.modPow = VB;
_e.prototype.modInverse = HB;
_e.prototype.pow = DB;
_e.prototype.gcd = KB;
_e.prototype.isProbablePrime = zB;
var Ui = ht, I2 = Ui.sha1 = Ui.sha1 || {};
Ui.md.sha1 = Ui.md.algorithms.sha1 = I2;
I2.create = function() {
  T2 || YB();
  var e = null, t = Ui.util.createBuffer(), o = new Array(80), r = {
    algorithm: "sha1",
    blockLength: 64,
    digestLength: 20,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  return r.start = function() {
    r.messageLength = 0, r.fullMessageLength = r.messageLength64 = [];
    for (var h = r.messageLengthSize / 4, a = 0; a < h; ++a)
      r.fullMessageLength.push(0);
    return t = Ui.util.createBuffer(), e = {
      h0: 1732584193,
      h1: 4023233417,
      h2: 2562383102,
      h3: 271733878,
      h4: 3285377520
    }, r;
  }, r.start(), r.update = function(h, a) {
    a === "utf8" && (h = Ui.util.encodeUtf8(h));
    var p = h.length;
    r.messageLength += p, p = [p / 4294967296 >>> 0, p >>> 0];
    for (var d = r.fullMessageLength.length - 1; d >= 0; --d)
      r.fullMessageLength[d] += p[1], p[1] = p[0] + (r.fullMessageLength[d] / 4294967296 >>> 0), r.fullMessageLength[d] = r.fullMessageLength[d] >>> 0, p[0] = p[1] / 4294967296 >>> 0;
    return t.putBytes(h), qp(e, o, t), (t.read > 2048 || t.length() === 0) && t.compact(), r;
  }, r.digest = function() {
    var h = Ui.util.createBuffer();
    h.putBytes(t.bytes());
    var a = r.fullMessageLength[r.fullMessageLength.length - 1] + r.messageLengthSize, p = a & r.blockLength - 1;
    h.putBytes(Sc.substr(0, r.blockLength - p));
    for (var d, b, g = r.fullMessageLength[0] * 8, w = 0; w < r.fullMessageLength.length - 1; ++w)
      d = r.fullMessageLength[w + 1] * 8, b = d / 4294967296 >>> 0, g += b, h.putInt32(g >>> 0), g = d >>> 0;
    h.putInt32(g);
    var C = {
      h0: e.h0,
      h1: e.h1,
      h2: e.h2,
      h3: e.h3,
      h4: e.h4
    };
    qp(C, o, h);
    var T = Ui.util.createBuffer();
    return T.putInt32(C.h0), T.putInt32(C.h1), T.putInt32(C.h2), T.putInt32(C.h3), T.putInt32(C.h4), T;
  }, r;
};
var Sc = null, T2 = !1;
function YB() {
  Sc = "", Sc += Ui.util.fillString("\0", 64), T2 = !0;
}
function qp(e, t, o) {
  for (var r, h, a, p, d, b, g, w, C = o.length(); C >= 64; ) {
    for (h = e.h0, a = e.h1, p = e.h2, d = e.h3, b = e.h4, w = 0; w < 16; ++w)
      r = o.getInt32(), t[w] = r, g = d ^ a & (p ^ d), r = (h << 5 | h >>> 27) + g + b + 1518500249 + r, b = d, d = p, p = (a << 30 | a >>> 2) >>> 0, a = h, h = r;
    for (; w < 20; ++w)
      r = t[w - 3] ^ t[w - 8] ^ t[w - 14] ^ t[w - 16], r = r << 1 | r >>> 31, t[w] = r, g = d ^ a & (p ^ d), r = (h << 5 | h >>> 27) + g + b + 1518500249 + r, b = d, d = p, p = (a << 30 | a >>> 2) >>> 0, a = h, h = r;
    for (; w < 32; ++w)
      r = t[w - 3] ^ t[w - 8] ^ t[w - 14] ^ t[w - 16], r = r << 1 | r >>> 31, t[w] = r, g = a ^ p ^ d, r = (h << 5 | h >>> 27) + g + b + 1859775393 + r, b = d, d = p, p = (a << 30 | a >>> 2) >>> 0, a = h, h = r;
    for (; w < 40; ++w)
      r = t[w - 6] ^ t[w - 16] ^ t[w - 28] ^ t[w - 32], r = r << 2 | r >>> 30, t[w] = r, g = a ^ p ^ d, r = (h << 5 | h >>> 27) + g + b + 1859775393 + r, b = d, d = p, p = (a << 30 | a >>> 2) >>> 0, a = h, h = r;
    for (; w < 60; ++w)
      r = t[w - 6] ^ t[w - 16] ^ t[w - 28] ^ t[w - 32], r = r << 2 | r >>> 30, t[w] = r, g = a & p | d & (a ^ p), r = (h << 5 | h >>> 27) + g + b + 2400959708 + r, b = d, d = p, p = (a << 30 | a >>> 2) >>> 0, a = h, h = r;
    for (; w < 80; ++w)
      r = t[w - 6] ^ t[w - 16] ^ t[w - 28] ^ t[w - 32], r = r << 2 | r >>> 30, t[w] = r, g = a ^ p ^ d, r = (h << 5 | h >>> 27) + g + b + 3395469782 + r, b = d, d = p, p = (a << 30 | a >>> 2) >>> 0, a = h, h = r;
    e.h0 = e.h0 + h | 0, e.h1 = e.h1 + a | 0, e.h2 = e.h2 + p | 0, e.h3 = e.h3 + d | 0, e.h4 = e.h4 + b | 0, C -= 64;
  }
}
var Fi = ht, M2 = Fi.pkcs1 = Fi.pkcs1 || {};
M2.encode_rsa_oaep = function(e, t, o) {
  var r, h, a, p;
  typeof o == "string" ? (r = o, h = arguments[3] || void 0, a = arguments[4] || void 0) : o && (r = o.label || void 0, h = o.seed || void 0, a = o.md || void 0, o.mgf1 && o.mgf1.md && (p = o.mgf1.md)), a ? a.start() : a = Fi.md.sha1.create(), p || (p = a);
  var d = Math.ceil(e.n.bitLength() / 8), b = d - 2 * a.digestLength - 2;
  if (t.length > b) {
    var g = new Error("RSAES-OAEP input message length is too long.");
    throw g.length = t.length, g.maxLength = b, g;
  }
  r || (r = ""), a.update(r, "raw");
  for (var w = a.digest(), C = "", T = b - t.length, k = 0; k < T; k++)
    C += "\0";
  var q = w.getBytes() + C + "" + t;
  if (!h)
    h = Fi.random.getBytes(a.digestLength);
  else if (h.length !== a.digestLength) {
    var g = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
    throw g.seedLength = h.length, g.digestLength = a.digestLength, g;
  }
  var O = ks(h, d - a.digestLength - 1, p), N = Fi.util.xorBytes(q, O, q.length), j = ks(N, a.digestLength, p), U = Fi.util.xorBytes(h, j, h.length);
  return "\0" + U + N;
};
M2.decode_rsa_oaep = function(e, t, o) {
  var r, h, a;
  typeof o == "string" ? (r = o, h = arguments[3] || void 0) : o && (r = o.label || void 0, h = o.md || void 0, o.mgf1 && o.mgf1.md && (a = o.mgf1.md));
  var p = Math.ceil(e.n.bitLength() / 8);
  if (t.length !== p) {
    var d = new Error("RSAES-OAEP encoded message length is invalid.");
    throw d.length = t.length, d.expectedLength = p, d;
  }
  if (h === void 0 ? h = Fi.md.sha1.create() : h.start(), a || (a = h), p < 2 * h.digestLength + 2)
    throw new Error("RSAES-OAEP key is too short for the hash function.");
  r || (r = ""), h.update(r, "raw");
  for (var b = h.digest().getBytes(), g = t.charAt(0), w = t.substring(1, h.digestLength + 1), C = t.substring(1 + h.digestLength), T = ks(C, h.digestLength, a), k = Fi.util.xorBytes(w, T, w.length), q = ks(k, p - h.digestLength - 1, a), O = Fi.util.xorBytes(C, q, C.length), N = O.substring(0, h.digestLength), d = g !== "\0", j = 0; j < h.digestLength; ++j)
    d |= b.charAt(j) !== N.charAt(j);
  for (var U = 1, H = h.digestLength, z = h.digestLength; z < O.length; z++) {
    var ee = O.charCodeAt(z), ne = ee & 1 ^ 1, le = U ? 65534 : 0;
    d |= ee & le, U = U & ne, H += U;
  }
  if (d || O.charCodeAt(H) !== 1)
    throw new Error("Invalid RSAES-OAEP padding.");
  return O.substring(H + 1);
};
function ks(e, t, o) {
  o || (o = Fi.md.sha1.create());
  for (var r = "", h = Math.ceil(t / o.digestLength), a = 0; a < h; ++a) {
    var p = String.fromCharCode(
      a >> 24 & 255,
      a >> 16 & 255,
      a >> 8 & 255,
      a & 255
    );
    o.start(), o.update(e + p), r += o.digest().getBytes();
  }
  return r.substring(0, t);
}
var ln = ht;
(function() {
  if (ln.prime) {
    ln.prime;
    return;
  }
  var e = ln.prime = ln.prime || {}, t = ln.jsbn.BigInteger, o = [6, 4, 2, 4, 2, 4, 6, 2], r = new t(null);
  r.fromInt(30);
  var h = function(C, T) {
    return C | T;
  };
  e.generateProbablePrime = function(C, T, k) {
    typeof T == "function" && (k = T, T = {}), T = T || {};
    var q = T.algorithm || "PRIMEINC";
    typeof q == "string" && (q = { name: q }), q.options = q.options || {};
    var O = T.prng || ln.random, N = {
      // x is an array to fill with bytes
      nextBytes: function(j) {
        for (var U = O.getBytesSync(j.length), H = 0; H < j.length; ++H)
          j[H] = U.charCodeAt(H);
      }
    };
    if (q.name === "PRIMEINC")
      return a(C, N, q.options, k);
    throw new Error("Invalid prime generation algorithm: " + q.name);
  };
  function a(C, T, k, q) {
    return "workers" in k ? b(C, T, k, q) : p(C, T, k, q);
  }
  function p(C, T, k, q) {
    var O = g(C, T), N = 0, j = w(O.bitLength());
    "millerRabinTests" in k && (j = k.millerRabinTests);
    var U = 10;
    "maxBlockTime" in k && (U = k.maxBlockTime), d(O, C, T, N, j, U, q);
  }
  function d(C, T, k, q, O, N, j) {
    var U = +/* @__PURE__ */ new Date();
    do {
      if (C.bitLength() > T && (C = g(T, k)), C.isProbablePrime(O))
        return j(null, C);
      C.dAddOffset(o[q++ % 8], 0);
    } while (N < 0 || +/* @__PURE__ */ new Date() - U < N);
    ln.util.setImmediate(function() {
      d(C, T, k, q, O, N, j);
    });
  }
  function b(C, T, k, q) {
    if (typeof Worker > "u")
      return p(C, T, k, q);
    var O = g(C, T), N = k.workers, j = k.workLoad || 100, U = j * 30 / 8, H = k.workerScript || "forge/prime.worker.js";
    if (N === -1)
      return ln.util.estimateCores(function(ee, ne) {
        ee && (ne = 2), N = ne - 1, z();
      });
    z();
    function z() {
      N = Math.max(1, N);
      for (var ee = [], ne = 0; ne < N; ++ne)
        ee[ne] = new Worker(H);
      for (var ne = 0; ne < N; ++ne)
        ee[ne].addEventListener("message", Z);
      var le = !1;
      function Z(ie) {
        if (!le) {
          var fe = ie.data;
          if (fe.found) {
            for (var I = 0; I < ee.length; ++I)
              ee[I].terminate();
            return le = !0, q(null, new t(fe.prime, 16));
          }
          O.bitLength() > C && (O = g(C, T));
          var P = O.toString(16);
          ie.target.postMessage({
            hex: P,
            workLoad: j
          }), O.dAddOffset(U, 0);
        }
      }
    }
  }
  function g(C, T) {
    var k = new t(C, T), q = C - 1;
    return k.testBit(q) || k.bitwiseTo(t.ONE.shiftLeft(q), h, k), k.dAddOffset(31 - k.mod(r).byteValue(), 0), k;
  }
  function w(C) {
    return C <= 100 ? 27 : C <= 150 ? 18 : C <= 200 ? 15 : C <= 250 ? 12 : C <= 300 ? 9 : C <= 350 ? 8 : C <= 400 ? 7 : C <= 500 ? 6 : C <= 600 ? 5 : C <= 800 ? 4 : C <= 1250 ? 3 : 2;
  }
})();
var He = ht;
if (typeof _t > "u")
  var _t = He.jsbn.BigInteger;
var wc = He.util.isNodejs ? _r() : null, he = He.asn1, Hr = He.util;
He.pki = He.pki || {};
He.pki.rsa = He.rsa = He.rsa || {};
var at = He.pki, XB = [6, 4, 2, 4, 2, 4, 6, 2], QB = {
  // PrivateKeyInfo
  name: "PrivateKeyInfo",
  tagClass: he.Class.UNIVERSAL,
  type: he.Type.SEQUENCE,
  constructed: !0,
  value: [{
    // Version (INTEGER)
    name: "PrivateKeyInfo.version",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyVersion"
  }, {
    // privateKeyAlgorithm
    name: "PrivateKeyInfo.privateKeyAlgorithm",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: he.Class.UNIVERSAL,
      type: he.Type.OID,
      constructed: !1,
      capture: "privateKeyOid"
    }]
  }, {
    // PrivateKey
    name: "PrivateKeyInfo",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.OCTETSTRING,
    constructed: !1,
    capture: "privateKey"
  }]
}, ZB = {
  // RSAPrivateKey
  name: "RSAPrivateKey",
  tagClass: he.Class.UNIVERSAL,
  type: he.Type.SEQUENCE,
  constructed: !0,
  value: [{
    // Version (INTEGER)
    name: "RSAPrivateKey.version",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyVersion"
  }, {
    // modulus (n)
    name: "RSAPrivateKey.modulus",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyModulus"
  }, {
    // publicExponent (e)
    name: "RSAPrivateKey.publicExponent",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyPublicExponent"
  }, {
    // privateExponent (d)
    name: "RSAPrivateKey.privateExponent",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyPrivateExponent"
  }, {
    // prime1 (p)
    name: "RSAPrivateKey.prime1",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyPrime1"
  }, {
    // prime2 (q)
    name: "RSAPrivateKey.prime2",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyPrime2"
  }, {
    // exponent1 (d mod (p-1))
    name: "RSAPrivateKey.exponent1",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyExponent1"
  }, {
    // exponent2 (d mod (q-1))
    name: "RSAPrivateKey.exponent2",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyExponent2"
  }, {
    // coefficient ((inverse of q) mod p)
    name: "RSAPrivateKey.coefficient",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyCoefficient"
  }]
}, JB = {
  // RSAPublicKey
  name: "RSAPublicKey",
  tagClass: he.Class.UNIVERSAL,
  type: he.Type.SEQUENCE,
  constructed: !0,
  value: [{
    // modulus (n)
    name: "RSAPublicKey.modulus",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "publicKeyModulus"
  }, {
    // publicExponent (e)
    name: "RSAPublicKey.exponent",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "publicKeyExponent"
  }]
}, eI = He.pki.rsa.publicKeyValidator = {
  name: "SubjectPublicKeyInfo",
  tagClass: he.Class.UNIVERSAL,
  type: he.Type.SEQUENCE,
  constructed: !0,
  captureAsn1: "subjectPublicKeyInfo",
  value: [{
    name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: he.Class.UNIVERSAL,
      type: he.Type.OID,
      constructed: !1,
      capture: "publicKeyOid"
    }]
  }, {
    // subjectPublicKey
    name: "SubjectPublicKeyInfo.subjectPublicKey",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.BITSTRING,
    constructed: !1,
    value: [{
      // RSAPublicKey
      name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
      tagClass: he.Class.UNIVERSAL,
      type: he.Type.SEQUENCE,
      constructed: !0,
      optional: !0,
      captureAsn1: "rsaPublicKey"
    }]
  }]
}, tI = {
  name: "DigestInfo",
  tagClass: he.Class.UNIVERSAL,
  type: he.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "DigestInfo.DigestAlgorithm",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
      tagClass: he.Class.UNIVERSAL,
      type: he.Type.OID,
      constructed: !1,
      capture: "algorithmIdentifier"
    }, {
      // NULL paramters
      name: "DigestInfo.DigestAlgorithm.parameters",
      tagClass: he.Class.UNIVERSAL,
      type: he.Type.NULL,
      // captured only to check existence for md2 and md5
      capture: "parameters",
      optional: !0,
      constructed: !1
    }]
  }, {
    // digest
    name: "DigestInfo.digest",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.OCTETSTRING,
    constructed: !1,
    capture: "digest"
  }]
}, rI = function(e) {
  var t;
  if (e.algorithm in at.oids)
    t = at.oids[e.algorithm];
  else {
    var o = new Error("Unknown message digest algorithm.");
    throw o.algorithm = e.algorithm, o;
  }
  var r = he.oidToDer(t).getBytes(), h = he.create(
    he.Class.UNIVERSAL,
    he.Type.SEQUENCE,
    !0,
    []
  ), a = he.create(
    he.Class.UNIVERSAL,
    he.Type.SEQUENCE,
    !0,
    []
  );
  a.value.push(he.create(
    he.Class.UNIVERSAL,
    he.Type.OID,
    !1,
    r
  )), a.value.push(he.create(
    he.Class.UNIVERSAL,
    he.Type.NULL,
    !1,
    ""
  ));
  var p = he.create(
    he.Class.UNIVERSAL,
    he.Type.OCTETSTRING,
    !1,
    e.digest().getBytes()
  );
  return h.value.push(a), h.value.push(p), he.toDer(h).getBytes();
}, R2 = function(e, t, o) {
  if (o)
    return e.modPow(t.e, t.n);
  if (!t.p || !t.q)
    return e.modPow(t.d, t.n);
  t.dP || (t.dP = t.d.mod(t.p.subtract(_t.ONE))), t.dQ || (t.dQ = t.d.mod(t.q.subtract(_t.ONE))), t.qInv || (t.qInv = t.q.modInverse(t.p));
  var r;
  do
    r = new _t(
      He.util.bytesToHex(He.random.getBytes(t.n.bitLength() / 8)),
      16
    );
  while (r.compareTo(t.n) >= 0 || !r.gcd(t.n).equals(_t.ONE));
  e = e.multiply(r.modPow(t.e, t.n)).mod(t.n);
  for (var h = e.mod(t.p).modPow(t.dP, t.p), a = e.mod(t.q).modPow(t.dQ, t.q); h.compareTo(a) < 0; )
    h = h.add(t.p);
  var p = h.subtract(a).multiply(t.qInv).mod(t.p).multiply(t.q).add(a);
  return p = p.multiply(r.modInverse(t.n)).mod(t.n), p;
};
at.rsa.encrypt = function(e, t, o) {
  var r = o, h, a = Math.ceil(t.n.bitLength() / 8);
  o !== !1 && o !== !0 ? (r = o === 2, h = N2(e, t, o)) : (h = He.util.createBuffer(), h.putBytes(e));
  for (var p = new _t(h.toHex(), 16), d = R2(p, t, r), b = d.toString(16), g = He.util.createBuffer(), w = a - Math.ceil(b.length / 2); w > 0; )
    g.putByte(0), --w;
  return g.putBytes(He.util.hexToBytes(b)), g.getBytes();
};
at.rsa.decrypt = function(e, t, o, r) {
  var h = Math.ceil(t.n.bitLength() / 8);
  if (e.length !== h) {
    var a = new Error("Encrypted message length is invalid.");
    throw a.length = e.length, a.expected = h, a;
  }
  var p = new _t(He.util.createBuffer(e).toHex(), 16);
  if (p.compareTo(t.n) >= 0)
    throw new Error("Encrypted message is invalid.");
  for (var d = R2(p, t, o), b = d.toString(16), g = He.util.createBuffer(), w = h - Math.ceil(b.length / 2); w > 0; )
    g.putByte(0), --w;
  return g.putBytes(He.util.hexToBytes(b)), r !== !1 ? Us(g.getBytes(), t, o) : g.getBytes();
};
at.rsa.createKeyPairGenerationState = function(e, t, o) {
  typeof e == "string" && (e = parseInt(e, 10)), e = e || 2048, o = o || {};
  var r = o.prng || He.random, h = {
    // x is an array to fill with bytes
    nextBytes: function(d) {
      for (var b = r.getBytesSync(d.length), g = 0; g < d.length; ++g)
        d[g] = b.charCodeAt(g);
    }
  }, a = o.algorithm || "PRIMEINC", p;
  if (a === "PRIMEINC")
    p = {
      algorithm: a,
      state: 0,
      bits: e,
      rng: h,
      eInt: t || 65537,
      e: new _t(null),
      p: null,
      q: null,
      qBits: e >> 1,
      pBits: e - (e >> 1),
      pqState: 0,
      num: null,
      keys: null
    }, p.e.fromInt(p.eInt);
  else
    throw new Error("Invalid key generation algorithm: " + a);
  return p;
};
at.rsa.stepKeyPairGenerationState = function(e, t) {
  "algorithm" in e || (e.algorithm = "PRIMEINC");
  var o = new _t(null);
  o.fromInt(30);
  for (var r = 0, h = function(C, T) {
    return C | T;
  }, a = +/* @__PURE__ */ new Date(), p, d = 0; e.keys === null && (t <= 0 || d < t); ) {
    if (e.state === 0) {
      var b = e.p === null ? e.pBits : e.qBits, g = b - 1;
      e.pqState === 0 ? (e.num = new _t(b, e.rng), e.num.testBit(g) || e.num.bitwiseTo(
        _t.ONE.shiftLeft(g),
        h,
        e.num
      ), e.num.dAddOffset(31 - e.num.mod(o).byteValue(), 0), r = 0, ++e.pqState) : e.pqState === 1 ? e.num.bitLength() > b ? e.pqState = 0 : e.num.isProbablePrime(
        nI(e.num.bitLength())
      ) ? ++e.pqState : e.num.dAddOffset(XB[r++ % 8], 0) : e.pqState === 2 ? e.pqState = e.num.subtract(_t.ONE).gcd(e.e).compareTo(_t.ONE) === 0 ? 3 : 0 : e.pqState === 3 && (e.pqState = 0, e.p === null ? e.p = e.num : e.q = e.num, e.p !== null && e.q !== null && ++e.state, e.num = null);
    } else if (e.state === 1)
      e.p.compareTo(e.q) < 0 && (e.num = e.p, e.p = e.q, e.q = e.num), ++e.state;
    else if (e.state === 2)
      e.p1 = e.p.subtract(_t.ONE), e.q1 = e.q.subtract(_t.ONE), e.phi = e.p1.multiply(e.q1), ++e.state;
    else if (e.state === 3)
      e.phi.gcd(e.e).compareTo(_t.ONE) === 0 ? ++e.state : (e.p = null, e.q = null, e.state = 0);
    else if (e.state === 4)
      e.n = e.p.multiply(e.q), e.n.bitLength() === e.bits ? ++e.state : (e.q = null, e.state = 0);
    else if (e.state === 5) {
      var w = e.e.modInverse(e.phi);
      e.keys = {
        privateKey: at.rsa.setPrivateKey(
          e.n,
          e.e,
          w,
          e.p,
          e.q,
          w.mod(e.p1),
          w.mod(e.q1),
          e.q.modInverse(e.p)
        ),
        publicKey: at.rsa.setPublicKey(e.n, e.e)
      };
    }
    p = +/* @__PURE__ */ new Date(), d += p - a, a = p;
  }
  return e.keys !== null;
};
at.rsa.generateKeyPair = function(e, t, o, r) {
  if (arguments.length === 1 ? typeof e == "object" ? (o = e, e = void 0) : typeof e == "function" && (r = e, e = void 0) : arguments.length === 2 ? typeof e == "number" ? typeof t == "function" ? (r = t, t = void 0) : typeof t != "number" && (o = t, t = void 0) : (o = e, r = t, e = void 0, t = void 0) : arguments.length === 3 && (typeof t == "number" ? typeof o == "function" && (r = o, o = void 0) : (r = o, o = t, t = void 0)), o = o || {}, e === void 0 && (e = o.bits || 2048), t === void 0 && (t = o.e || 65537), !He.options.usePureJavaScript && !o.prng && e >= 256 && e <= 16384 && (t === 65537 || t === 3)) {
    if (r) {
      if (Vp("generateKeyPair"))
        return wc.generateKeyPair("rsa", {
          modulusLength: e,
          publicExponent: t,
          publicKeyEncoding: {
            type: "spki",
            format: "pem"
          },
          privateKeyEncoding: {
            type: "pkcs8",
            format: "pem"
          }
        }, function(d, b, g) {
          if (d)
            return r(d);
          r(null, {
            privateKey: at.privateKeyFromPem(g),
            publicKey: at.publicKeyFromPem(b)
          });
        });
      if (Kp("generateKey") && Kp("exportKey"))
        return Hr.globalScope.crypto.subtle.generateKey({
          name: "RSASSA-PKCS1-v1_5",
          modulusLength: e,
          publicExponent: Hp(t),
          hash: { name: "SHA-256" }
        }, !0, ["sign", "verify"]).then(function(d) {
          return Hr.globalScope.crypto.subtle.exportKey(
            "pkcs8",
            d.privateKey
          );
        }).then(void 0, function(d) {
          r(d);
        }).then(function(d) {
          if (d) {
            var b = at.privateKeyFromAsn1(
              he.fromDer(He.util.createBuffer(d))
            );
            r(null, {
              privateKey: b,
              publicKey: at.setRsaPublicKey(b.n, b.e)
            });
          }
        });
      if ($p("generateKey") && $p("exportKey")) {
        var h = Hr.globalScope.msCrypto.subtle.generateKey({
          name: "RSASSA-PKCS1-v1_5",
          modulusLength: e,
          publicExponent: Hp(t),
          hash: { name: "SHA-256" }
        }, !0, ["sign", "verify"]);
        h.oncomplete = function(d) {
          var b = d.target.result, g = Hr.globalScope.msCrypto.subtle.exportKey(
            "pkcs8",
            b.privateKey
          );
          g.oncomplete = function(w) {
            var C = w.target.result, T = at.privateKeyFromAsn1(
              he.fromDer(He.util.createBuffer(C))
            );
            r(null, {
              privateKey: T,
              publicKey: at.setRsaPublicKey(T.n, T.e)
            });
          }, g.onerror = function(w) {
            r(w);
          };
        }, h.onerror = function(d) {
          r(d);
        };
        return;
      }
    } else if (Vp("generateKeyPairSync")) {
      var a = wc.generateKeyPairSync("rsa", {
        modulusLength: e,
        publicExponent: t,
        publicKeyEncoding: {
          type: "spki",
          format: "pem"
        },
        privateKeyEncoding: {
          type: "pkcs8",
          format: "pem"
        }
      });
      return {
        privateKey: at.privateKeyFromPem(a.privateKey),
        publicKey: at.publicKeyFromPem(a.publicKey)
      };
    }
  }
  var p = at.rsa.createKeyPairGenerationState(e, t, o);
  if (!r)
    return at.rsa.stepKeyPairGenerationState(p, 0), p.keys;
  iI(p, o, r);
};
at.setRsaPublicKey = at.rsa.setPublicKey = function(e, t) {
  var o = {
    n: e,
    e: t
  };
  return o.encrypt = function(r, h, a) {
    if (typeof h == "string" ? h = h.toUpperCase() : h === void 0 && (h = "RSAES-PKCS1-V1_5"), h === "RSAES-PKCS1-V1_5")
      h = {
        encode: function(d, b, g) {
          return N2(d, b, 2).getBytes();
        }
      };
    else if (h === "RSA-OAEP" || h === "RSAES-OAEP")
      h = {
        encode: function(d, b) {
          return He.pkcs1.encode_rsa_oaep(b, d, a);
        }
      };
    else if (["RAW", "NONE", "NULL", null].indexOf(h) !== -1)
      h = { encode: function(d) {
        return d;
      } };
    else if (typeof h == "string")
      throw new Error('Unsupported encryption scheme: "' + h + '".');
    var p = h.encode(r, o, !0);
    return at.rsa.encrypt(p, o, !0);
  }, o.verify = function(r, h, a, p) {
    typeof a == "string" ? a = a.toUpperCase() : a === void 0 && (a = "RSASSA-PKCS1-V1_5"), p === void 0 && (p = {
      _parseAllDigestBytes: !0
    }), "_parseAllDigestBytes" in p || (p._parseAllDigestBytes = !0), a === "RSASSA-PKCS1-V1_5" ? a = {
      verify: function(b, g) {
        g = Us(g, o, !0);
        var w = he.fromDer(g, {
          parseAllBytes: p._parseAllDigestBytes
        }), C = {}, T = [];
        if (!he.validate(w, tI, C, T)) {
          var k = new Error(
            "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
          );
          throw k.errors = T, k;
        }
        var q = he.derToOid(C.algorithmIdentifier);
        if (!(q === He.oids.md2 || q === He.oids.md5 || q === He.oids.sha1 || q === He.oids.sha224 || q === He.oids.sha256 || q === He.oids.sha384 || q === He.oids.sha512 || q === He.oids["sha512-224"] || q === He.oids["sha512-256"])) {
          var k = new Error(
            "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
          );
          throw k.oid = q, k;
        }
        if ((q === He.oids.md2 || q === He.oids.md5) && !("parameters" in C))
          throw new Error(
            "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters."
          );
        return b === C.digest;
      }
    } : (a === "NONE" || a === "NULL" || a === null) && (a = {
      verify: function(b, g) {
        return g = Us(g, o, !0), b === g;
      }
    });
    var d = at.rsa.decrypt(h, o, !0, !1);
    return a.verify(r, d, o.n.bitLength());
  }, o;
};
at.setRsaPrivateKey = at.rsa.setPrivateKey = function(e, t, o, r, h, a, p, d) {
  var b = {
    n: e,
    e: t,
    d: o,
    p: r,
    q: h,
    dP: a,
    dQ: p,
    qInv: d
  };
  return b.decrypt = function(g, w, C) {
    typeof w == "string" ? w = w.toUpperCase() : w === void 0 && (w = "RSAES-PKCS1-V1_5");
    var T = at.rsa.decrypt(g, b, !1, !1);
    if (w === "RSAES-PKCS1-V1_5")
      w = { decode: Us };
    else if (w === "RSA-OAEP" || w === "RSAES-OAEP")
      w = {
        decode: function(k, q) {
          return He.pkcs1.decode_rsa_oaep(q, k, C);
        }
      };
    else if (["RAW", "NONE", "NULL", null].indexOf(w) !== -1)
      w = { decode: function(k) {
        return k;
      } };
    else
      throw new Error('Unsupported encryption scheme: "' + w + '".');
    return w.decode(T, b, !1);
  }, b.sign = function(g, w) {
    var C = !1;
    typeof w == "string" && (w = w.toUpperCase()), w === void 0 || w === "RSASSA-PKCS1-V1_5" ? (w = { encode: rI }, C = 1) : (w === "NONE" || w === "NULL" || w === null) && (w = { encode: function() {
      return g;
    } }, C = 1);
    var T = w.encode(g, b.n.bitLength());
    return at.rsa.encrypt(T, b, C);
  }, b;
};
at.wrapRsaPrivateKey = function(e) {
  return he.create(he.Class.UNIVERSAL, he.Type.SEQUENCE, !0, [
    // version (0)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      he.integerToDer(0).getBytes()
    ),
    // privateKeyAlgorithm
    he.create(he.Class.UNIVERSAL, he.Type.SEQUENCE, !0, [
      he.create(
        he.Class.UNIVERSAL,
        he.Type.OID,
        !1,
        he.oidToDer(at.oids.rsaEncryption).getBytes()
      ),
      he.create(he.Class.UNIVERSAL, he.Type.NULL, !1, "")
    ]),
    // PrivateKey
    he.create(
      he.Class.UNIVERSAL,
      he.Type.OCTETSTRING,
      !1,
      he.toDer(e).getBytes()
    )
  ]);
};
at.privateKeyFromAsn1 = function(e) {
  var t = {}, o = [];
  if (he.validate(e, QB, t, o) && (e = he.fromDer(He.util.createBuffer(t.privateKey))), t = {}, o = [], !he.validate(e, ZB, t, o)) {
    var r = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
    throw r.errors = o, r;
  }
  var h, a, p, d, b, g, w, C;
  return h = He.util.createBuffer(t.privateKeyModulus).toHex(), a = He.util.createBuffer(t.privateKeyPublicExponent).toHex(), p = He.util.createBuffer(t.privateKeyPrivateExponent).toHex(), d = He.util.createBuffer(t.privateKeyPrime1).toHex(), b = He.util.createBuffer(t.privateKeyPrime2).toHex(), g = He.util.createBuffer(t.privateKeyExponent1).toHex(), w = He.util.createBuffer(t.privateKeyExponent2).toHex(), C = He.util.createBuffer(t.privateKeyCoefficient).toHex(), at.setRsaPrivateKey(
    new _t(h, 16),
    new _t(a, 16),
    new _t(p, 16),
    new _t(d, 16),
    new _t(b, 16),
    new _t(g, 16),
    new _t(w, 16),
    new _t(C, 16)
  );
};
at.privateKeyToAsn1 = at.privateKeyToRSAPrivateKey = function(e) {
  return he.create(he.Class.UNIVERSAL, he.Type.SEQUENCE, !0, [
    // version (0 = only 2 primes, 1 multiple primes)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      he.integerToDer(0).getBytes()
    ),
    // modulus (n)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      Mi(e.n)
    ),
    // publicExponent (e)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      Mi(e.e)
    ),
    // privateExponent (d)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      Mi(e.d)
    ),
    // privateKeyPrime1 (p)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      Mi(e.p)
    ),
    // privateKeyPrime2 (q)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      Mi(e.q)
    ),
    // privateKeyExponent1 (dP)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      Mi(e.dP)
    ),
    // privateKeyExponent2 (dQ)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      Mi(e.dQ)
    ),
    // coefficient (qInv)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      Mi(e.qInv)
    )
  ]);
};
at.publicKeyFromAsn1 = function(e) {
  var t = {}, o = [];
  if (he.validate(e, eI, t, o)) {
    var r = he.derToOid(t.publicKeyOid);
    if (r !== at.oids.rsaEncryption) {
      var h = new Error("Cannot read public key. Unknown OID.");
      throw h.oid = r, h;
    }
    e = t.rsaPublicKey;
  }
  if (o = [], !he.validate(e, JB, t, o)) {
    var h = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
    throw h.errors = o, h;
  }
  var a = He.util.createBuffer(t.publicKeyModulus).toHex(), p = He.util.createBuffer(t.publicKeyExponent).toHex();
  return at.setRsaPublicKey(
    new _t(a, 16),
    new _t(p, 16)
  );
};
at.publicKeyToAsn1 = at.publicKeyToSubjectPublicKeyInfo = function(e) {
  return he.create(he.Class.UNIVERSAL, he.Type.SEQUENCE, !0, [
    // AlgorithmIdentifier
    he.create(he.Class.UNIVERSAL, he.Type.SEQUENCE, !0, [
      // algorithm
      he.create(
        he.Class.UNIVERSAL,
        he.Type.OID,
        !1,
        he.oidToDer(at.oids.rsaEncryption).getBytes()
      ),
      // parameters (null)
      he.create(he.Class.UNIVERSAL, he.Type.NULL, !1, "")
    ]),
    // subjectPublicKey
    he.create(he.Class.UNIVERSAL, he.Type.BITSTRING, !1, [
      at.publicKeyToRSAPublicKey(e)
    ])
  ]);
};
at.publicKeyToRSAPublicKey = function(e) {
  return he.create(he.Class.UNIVERSAL, he.Type.SEQUENCE, !0, [
    // modulus (n)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      Mi(e.n)
    ),
    // publicExponent (e)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      Mi(e.e)
    )
  ]);
};
function N2(e, t, o) {
  var r = He.util.createBuffer(), h = Math.ceil(t.n.bitLength() / 8);
  if (e.length > h - 11) {
    var a = new Error("Message is too long for PKCS#1 v1.5 padding.");
    throw a.length = e.length, a.max = h - 11, a;
  }
  r.putByte(0), r.putByte(o);
  var p = h - 3 - e.length, d;
  if (o === 0 || o === 1) {
    d = o === 0 ? 0 : 255;
    for (var b = 0; b < p; ++b)
      r.putByte(d);
  } else
    for (; p > 0; ) {
      for (var g = 0, w = He.random.getBytes(p), b = 0; b < p; ++b)
        d = w.charCodeAt(b), d === 0 ? ++g : r.putByte(d);
      p = g;
    }
  return r.putByte(0), r.putBytes(e), r;
}
function Us(e, t, o, r) {
  var h = Math.ceil(t.n.bitLength() / 8), a = He.util.createBuffer(e), p = a.getByte(), d = a.getByte();
  if (p !== 0 || o && d !== 0 && d !== 1 || !o && d != 2 || o && d === 0 && typeof r > "u")
    throw new Error("Encryption block is invalid.");
  var b = 0;
  if (d === 0) {
    b = h - 3 - r;
    for (var g = 0; g < b; ++g)
      if (a.getByte() !== 0)
        throw new Error("Encryption block is invalid.");
  } else if (d === 1)
    for (b = 0; a.length() > 1; ) {
      if (a.getByte() !== 255) {
        --a.read;
        break;
      }
      ++b;
    }
  else if (d === 2)
    for (b = 0; a.length() > 1; ) {
      if (a.getByte() === 0) {
        --a.read;
        break;
      }
      ++b;
    }
  var w = a.getByte();
  if (w !== 0 || b !== h - 3 - a.length())
    throw new Error("Encryption block is invalid.");
  return a.getBytes();
}
function iI(e, t, o) {
  typeof t == "function" && (o = t, t = {}), t = t || {};
  var r = {
    algorithm: {
      name: t.algorithm || "PRIMEINC",
      options: {
        workers: t.workers || 2,
        workLoad: t.workLoad || 100,
        workerScript: t.workerScript
      }
    }
  };
  "prng" in t && (r.prng = t.prng), h();
  function h() {
    a(e.pBits, function(d, b) {
      if (d)
        return o(d);
      if (e.p = b, e.q !== null)
        return p(d, e.q);
      a(e.qBits, p);
    });
  }
  function a(d, b) {
    He.prime.generateProbablePrime(d, r, b);
  }
  function p(d, b) {
    if (d)
      return o(d);
    if (e.q = b, e.p.compareTo(e.q) < 0) {
      var g = e.p;
      e.p = e.q, e.q = g;
    }
    if (e.p.subtract(_t.ONE).gcd(e.e).compareTo(_t.ONE) !== 0) {
      e.p = null, h();
      return;
    }
    if (e.q.subtract(_t.ONE).gcd(e.e).compareTo(_t.ONE) !== 0) {
      e.q = null, a(e.qBits, p);
      return;
    }
    if (e.p1 = e.p.subtract(_t.ONE), e.q1 = e.q.subtract(_t.ONE), e.phi = e.p1.multiply(e.q1), e.phi.gcd(e.e).compareTo(_t.ONE) !== 0) {
      e.p = e.q = null, h();
      return;
    }
    if (e.n = e.p.multiply(e.q), e.n.bitLength() !== e.bits) {
      e.q = null, a(e.qBits, p);
      return;
    }
    var w = e.e.modInverse(e.phi);
    e.keys = {
      privateKey: at.rsa.setPrivateKey(
        e.n,
        e.e,
        w,
        e.p,
        e.q,
        w.mod(e.p1),
        w.mod(e.q1),
        e.q.modInverse(e.p)
      ),
      publicKey: at.rsa.setPublicKey(e.n, e.e)
    }, o(null, e.keys);
  }
}
function Mi(e) {
  var t = e.toString(16);
  t[0] >= "8" && (t = "00" + t);
  var o = He.util.hexToBytes(t);
  return o.length > 1 && // leading 0x00 for positive integer
  (o.charCodeAt(0) === 0 && !(o.charCodeAt(1) & 128) || // leading 0xFF for negative integer
  o.charCodeAt(0) === 255 && (o.charCodeAt(1) & 128) === 128) ? o.substr(1) : o;
}
function nI(e) {
  return e <= 100 ? 27 : e <= 150 ? 18 : e <= 200 ? 15 : e <= 250 ? 12 : e <= 300 ? 9 : e <= 350 ? 8 : e <= 400 ? 7 : e <= 500 ? 6 : e <= 600 ? 5 : e <= 800 ? 4 : e <= 1250 ? 3 : 2;
}
function Vp(e) {
  return He.util.isNodejs && typeof wc[e] == "function";
}
function Kp(e) {
  return typeof Hr.globalScope < "u" && typeof Hr.globalScope.crypto == "object" && typeof Hr.globalScope.crypto.subtle == "object" && typeof Hr.globalScope.crypto.subtle[e] == "function";
}
function $p(e) {
  return typeof Hr.globalScope < "u" && typeof Hr.globalScope.msCrypto == "object" && typeof Hr.globalScope.msCrypto.subtle == "object" && typeof Hr.globalScope.msCrypto.subtle[e] == "function";
}
function Hp(e) {
  for (var t = He.util.hexToBytes(e.toString(16)), o = new Uint8Array(t.length), r = 0; r < t.length; ++r)
    o[r] = t.charCodeAt(r);
  return o;
}
var De = ht;
if (typeof aI > "u")
  var aI = De.jsbn.BigInteger;
var ye = De.asn1, ft = De.pki = De.pki || {};
ft.pbe = De.pbe = De.pbe || {};
var Un = ft.oids, sI = {
  name: "EncryptedPrivateKeyInfo",
  tagClass: ye.Class.UNIVERSAL,
  type: ye.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
    tagClass: ye.Class.UNIVERSAL,
    type: ye.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: ye.Class.UNIVERSAL,
      type: ye.Type.OID,
      constructed: !1,
      capture: "encryptionOid"
    }, {
      name: "AlgorithmIdentifier.parameters",
      tagClass: ye.Class.UNIVERSAL,
      type: ye.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: "encryptionParams"
    }]
  }, {
    // encryptedData
    name: "EncryptedPrivateKeyInfo.encryptedData",
    tagClass: ye.Class.UNIVERSAL,
    type: ye.Type.OCTETSTRING,
    constructed: !1,
    capture: "encryptedData"
  }]
}, fI = {
  name: "PBES2Algorithms",
  tagClass: ye.Class.UNIVERSAL,
  type: ye.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "PBES2Algorithms.keyDerivationFunc",
    tagClass: ye.Class.UNIVERSAL,
    type: ye.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "PBES2Algorithms.keyDerivationFunc.oid",
      tagClass: ye.Class.UNIVERSAL,
      type: ye.Type.OID,
      constructed: !1,
      capture: "kdfOid"
    }, {
      name: "PBES2Algorithms.params",
      tagClass: ye.Class.UNIVERSAL,
      type: ye.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "PBES2Algorithms.params.salt",
        tagClass: ye.Class.UNIVERSAL,
        type: ye.Type.OCTETSTRING,
        constructed: !1,
        capture: "kdfSalt"
      }, {
        name: "PBES2Algorithms.params.iterationCount",
        tagClass: ye.Class.UNIVERSAL,
        type: ye.Type.INTEGER,
        constructed: !1,
        capture: "kdfIterationCount"
      }, {
        name: "PBES2Algorithms.params.keyLength",
        tagClass: ye.Class.UNIVERSAL,
        type: ye.Type.INTEGER,
        constructed: !1,
        optional: !0,
        capture: "keyLength"
      }, {
        // prf
        name: "PBES2Algorithms.params.prf",
        tagClass: ye.Class.UNIVERSAL,
        type: ye.Type.SEQUENCE,
        constructed: !0,
        optional: !0,
        value: [{
          name: "PBES2Algorithms.params.prf.algorithm",
          tagClass: ye.Class.UNIVERSAL,
          type: ye.Type.OID,
          constructed: !1,
          capture: "prfOid"
        }]
      }]
    }]
  }, {
    name: "PBES2Algorithms.encryptionScheme",
    tagClass: ye.Class.UNIVERSAL,
    type: ye.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "PBES2Algorithms.encryptionScheme.oid",
      tagClass: ye.Class.UNIVERSAL,
      type: ye.Type.OID,
      constructed: !1,
      capture: "encOid"
    }, {
      name: "PBES2Algorithms.encryptionScheme.iv",
      tagClass: ye.Class.UNIVERSAL,
      type: ye.Type.OCTETSTRING,
      constructed: !1,
      capture: "encIv"
    }]
  }]
}, oI = {
  name: "pkcs-12PbeParams",
  tagClass: ye.Class.UNIVERSAL,
  type: ye.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "pkcs-12PbeParams.salt",
    tagClass: ye.Class.UNIVERSAL,
    type: ye.Type.OCTETSTRING,
    constructed: !1,
    capture: "salt"
  }, {
    name: "pkcs-12PbeParams.iterations",
    tagClass: ye.Class.UNIVERSAL,
    type: ye.Type.INTEGER,
    constructed: !1,
    capture: "iterations"
  }]
};
ft.encryptPrivateKeyInfo = function(e, t, o) {
  o = o || {}, o.saltSize = o.saltSize || 8, o.count = o.count || 2048, o.algorithm = o.algorithm || "aes128", o.prfAlgorithm = o.prfAlgorithm || "sha1";
  var r = De.random.getBytesSync(o.saltSize), h = o.count, a = ye.integerToDer(h), p, d, b;
  if (o.algorithm.indexOf("aes") === 0 || o.algorithm === "des") {
    var g, w, C;
    switch (o.algorithm) {
      case "aes128":
        p = 16, g = 16, w = Un["aes128-CBC"], C = De.aes.createEncryptionCipher;
        break;
      case "aes192":
        p = 24, g = 16, w = Un["aes192-CBC"], C = De.aes.createEncryptionCipher;
        break;
      case "aes256":
        p = 32, g = 16, w = Un["aes256-CBC"], C = De.aes.createEncryptionCipher;
        break;
      case "des":
        p = 8, g = 8, w = Un.desCBC, C = De.des.createEncryptionCipher;
        break;
      default:
        var T = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        throw T.algorithm = o.algorithm, T;
    }
    var k = "hmacWith" + o.prfAlgorithm.toUpperCase(), q = O2(k), O = De.pkcs5.pbkdf2(t, r, h, p, q), N = De.random.getBytesSync(g), j = C(O);
    j.start(N), j.update(ye.toDer(e)), j.finish(), b = j.output.getBytes();
    var U = uI(r, a, p, k);
    d = ye.create(
      ye.Class.UNIVERSAL,
      ye.Type.SEQUENCE,
      !0,
      [
        ye.create(
          ye.Class.UNIVERSAL,
          ye.Type.OID,
          !1,
          ye.oidToDer(Un.pkcs5PBES2).getBytes()
        ),
        ye.create(ye.Class.UNIVERSAL, ye.Type.SEQUENCE, !0, [
          // keyDerivationFunc
          ye.create(ye.Class.UNIVERSAL, ye.Type.SEQUENCE, !0, [
            ye.create(
              ye.Class.UNIVERSAL,
              ye.Type.OID,
              !1,
              ye.oidToDer(Un.pkcs5PBKDF2).getBytes()
            ),
            // PBKDF2-params
            U
          ]),
          // encryptionScheme
          ye.create(ye.Class.UNIVERSAL, ye.Type.SEQUENCE, !0, [
            ye.create(
              ye.Class.UNIVERSAL,
              ye.Type.OID,
              !1,
              ye.oidToDer(w).getBytes()
            ),
            // iv
            ye.create(
              ye.Class.UNIVERSAL,
              ye.Type.OCTETSTRING,
              !1,
              N
            )
          ])
        ])
      ]
    );
  } else if (o.algorithm === "3des") {
    p = 24;
    var H = new De.util.ByteBuffer(r), O = ft.pbe.generatePkcs12Key(t, H, 1, h, p), N = ft.pbe.generatePkcs12Key(t, H, 2, h, p), j = De.des.createEncryptionCipher(O);
    j.start(N), j.update(ye.toDer(e)), j.finish(), b = j.output.getBytes(), d = ye.create(
      ye.Class.UNIVERSAL,
      ye.Type.SEQUENCE,
      !0,
      [
        ye.create(
          ye.Class.UNIVERSAL,
          ye.Type.OID,
          !1,
          ye.oidToDer(Un["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
        ),
        // pkcs-12PbeParams
        ye.create(ye.Class.UNIVERSAL, ye.Type.SEQUENCE, !0, [
          // salt
          ye.create(ye.Class.UNIVERSAL, ye.Type.OCTETSTRING, !1, r),
          // iteration count
          ye.create(
            ye.Class.UNIVERSAL,
            ye.Type.INTEGER,
            !1,
            a.getBytes()
          )
        ])
      ]
    );
  } else {
    var T = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
    throw T.algorithm = o.algorithm, T;
  }
  var z = ye.create(ye.Class.UNIVERSAL, ye.Type.SEQUENCE, !0, [
    // encryptionAlgorithm
    d,
    // encryptedData
    ye.create(
      ye.Class.UNIVERSAL,
      ye.Type.OCTETSTRING,
      !1,
      b
    )
  ]);
  return z;
};
ft.decryptPrivateKeyInfo = function(e, t) {
  var o = null, r = {}, h = [];
  if (!ye.validate(e, sI, r, h)) {
    var a = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    throw a.errors = h, a;
  }
  var p = ye.derToOid(r.encryptionOid), d = ft.pbe.getCipher(p, r.encryptionParams, t), b = De.util.createBuffer(r.encryptedData);
  return d.update(b), d.finish() && (o = ye.fromDer(d.output)), o;
};
ft.encryptedPrivateKeyToPem = function(e, t) {
  var o = {
    type: "ENCRYPTED PRIVATE KEY",
    body: ye.toDer(e).getBytes()
  };
  return De.pem.encode(o, { maxline: t });
};
ft.encryptedPrivateKeyFromPem = function(e) {
  var t = De.pem.decode(e)[0];
  if (t.type !== "ENCRYPTED PRIVATE KEY") {
    var o = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
    throw o.headerType = t.type, o;
  }
  if (t.procType && t.procType.type === "ENCRYPTED")
    throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
  return ye.fromDer(t.body);
};
ft.encryptRsaPrivateKey = function(e, t, o) {
  if (o = o || {}, !o.legacy) {
    var r = ft.wrapRsaPrivateKey(ft.privateKeyToAsn1(e));
    return r = ft.encryptPrivateKeyInfo(r, t, o), ft.encryptedPrivateKeyToPem(r);
  }
  var h, a, p, d;
  switch (o.algorithm) {
    case "aes128":
      h = "AES-128-CBC", p = 16, a = De.random.getBytesSync(16), d = De.aes.createEncryptionCipher;
      break;
    case "aes192":
      h = "AES-192-CBC", p = 24, a = De.random.getBytesSync(16), d = De.aes.createEncryptionCipher;
      break;
    case "aes256":
      h = "AES-256-CBC", p = 32, a = De.random.getBytesSync(16), d = De.aes.createEncryptionCipher;
      break;
    case "3des":
      h = "DES-EDE3-CBC", p = 24, a = De.random.getBytesSync(8), d = De.des.createEncryptionCipher;
      break;
    case "des":
      h = "DES-CBC", p = 8, a = De.random.getBytesSync(8), d = De.des.createEncryptionCipher;
      break;
    default:
      var b = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + o.algorithm + '".');
      throw b.algorithm = o.algorithm, b;
  }
  var g = De.pbe.opensslDeriveBytes(t, a.substr(0, 8), p), w = d(g);
  w.start(a), w.update(ye.toDer(ft.privateKeyToAsn1(e))), w.finish();
  var C = {
    type: "RSA PRIVATE KEY",
    procType: {
      version: "4",
      type: "ENCRYPTED"
    },
    dekInfo: {
      algorithm: h,
      parameters: De.util.bytesToHex(a).toUpperCase()
    },
    body: w.output.getBytes()
  };
  return De.pem.encode(C);
};
ft.decryptRsaPrivateKey = function(e, t) {
  var o = null, r = De.pem.decode(e)[0];
  if (r.type !== "ENCRYPTED PRIVATE KEY" && r.type !== "PRIVATE KEY" && r.type !== "RSA PRIVATE KEY") {
    var h = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
    throw h.headerType = h, h;
  }
  if (r.procType && r.procType.type === "ENCRYPTED") {
    var a, p;
    switch (r.dekInfo.algorithm) {
      case "DES-CBC":
        a = 8, p = De.des.createDecryptionCipher;
        break;
      case "DES-EDE3-CBC":
        a = 24, p = De.des.createDecryptionCipher;
        break;
      case "AES-128-CBC":
        a = 16, p = De.aes.createDecryptionCipher;
        break;
      case "AES-192-CBC":
        a = 24, p = De.aes.createDecryptionCipher;
        break;
      case "AES-256-CBC":
        a = 32, p = De.aes.createDecryptionCipher;
        break;
      case "RC2-40-CBC":
        a = 5, p = function(C) {
          return De.rc2.createDecryptionCipher(C, 40);
        };
        break;
      case "RC2-64-CBC":
        a = 8, p = function(C) {
          return De.rc2.createDecryptionCipher(C, 64);
        };
        break;
      case "RC2-128-CBC":
        a = 16, p = function(C) {
          return De.rc2.createDecryptionCipher(C, 128);
        };
        break;
      default:
        var h = new Error('Could not decrypt private key; unsupported encryption algorithm "' + r.dekInfo.algorithm + '".');
        throw h.algorithm = r.dekInfo.algorithm, h;
    }
    var d = De.util.hexToBytes(r.dekInfo.parameters), b = De.pbe.opensslDeriveBytes(t, d.substr(0, 8), a), g = p(b);
    if (g.start(d), g.update(De.util.createBuffer(r.body)), g.finish())
      o = g.output.getBytes();
    else
      return o;
  } else
    o = r.body;
  return r.type === "ENCRYPTED PRIVATE KEY" ? o = ft.decryptPrivateKeyInfo(ye.fromDer(o), t) : o = ye.fromDer(o), o !== null && (o = ft.privateKeyFromAsn1(o)), o;
};
ft.pbe.generatePkcs12Key = function(e, t, o, r, h, a) {
  var p, d;
  if (typeof a > "u" || a === null) {
    if (!("sha1" in De.md))
      throw new Error('"sha1" hash algorithm unavailable.');
    a = De.md.sha1.create();
  }
  var b = a.digestLength, g = a.blockLength, w = new De.util.ByteBuffer(), C = new De.util.ByteBuffer();
  if (e != null) {
    for (d = 0; d < e.length; d++)
      C.putInt16(e.charCodeAt(d));
    C.putInt16(0);
  }
  var T = C.length(), k = t.length(), q = new De.util.ByteBuffer();
  q.fillWithByte(o, g);
  var O = g * Math.ceil(k / g), N = new De.util.ByteBuffer();
  for (d = 0; d < O; d++)
    N.putByte(t.at(d % k));
  var j = g * Math.ceil(T / g), U = new De.util.ByteBuffer();
  for (d = 0; d < j; d++)
    U.putByte(C.at(d % T));
  var H = N;
  H.putBuffer(U);
  for (var z = Math.ceil(h / b), ee = 1; ee <= z; ee++) {
    var ne = new De.util.ByteBuffer();
    ne.putBytes(q.bytes()), ne.putBytes(H.bytes());
    for (var le = 0; le < r; le++)
      a.start(), a.update(ne.getBytes()), ne = a.digest();
    var Z = new De.util.ByteBuffer();
    for (d = 0; d < g; d++)
      Z.putByte(ne.at(d % b));
    var ie = Math.ceil(k / g) + Math.ceil(T / g), fe = new De.util.ByteBuffer();
    for (p = 0; p < ie; p++) {
      var I = new De.util.ByteBuffer(H.getBytes(g)), P = 511;
      for (d = Z.length() - 1; d >= 0; d--)
        P = P >> 8, P += Z.at(d) + I.at(d), I.setAt(d, P & 255);
      fe.putBuffer(I);
    }
    H = fe, w.putBuffer(ne);
  }
  return w.truncate(w.length() - h), w;
};
ft.pbe.getCipher = function(e, t, o) {
  switch (e) {
    case ft.oids.pkcs5PBES2:
      return ft.pbe.getCipherForPBES2(e, t, o);
    case ft.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
    case ft.oids["pbewithSHAAnd40BitRC2-CBC"]:
      return ft.pbe.getCipherForPKCS12PBE(e, t, o);
    default:
      var r = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
      throw r.oid = e, r.supportedOids = [
        "pkcs5PBES2",
        "pbeWithSHAAnd3-KeyTripleDES-CBC",
        "pbewithSHAAnd40BitRC2-CBC"
      ], r;
  }
};
ft.pbe.getCipherForPBES2 = function(e, t, o) {
  var r = {}, h = [];
  if (!ye.validate(t, fI, r, h)) {
    var a = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    throw a.errors = h, a;
  }
  if (e = ye.derToOid(r.kdfOid), e !== ft.oids.pkcs5PBKDF2) {
    var a = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
    throw a.oid = e, a.supportedOids = ["pkcs5PBKDF2"], a;
  }
  if (e = ye.derToOid(r.encOid), e !== ft.oids["aes128-CBC"] && e !== ft.oids["aes192-CBC"] && e !== ft.oids["aes256-CBC"] && e !== ft.oids["des-EDE3-CBC"] && e !== ft.oids.desCBC) {
    var a = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
    throw a.oid = e, a.supportedOids = [
      "aes128-CBC",
      "aes192-CBC",
      "aes256-CBC",
      "des-EDE3-CBC",
      "desCBC"
    ], a;
  }
  var p = r.kdfSalt, d = De.util.createBuffer(r.kdfIterationCount);
  d = d.getInt(d.length() << 3);
  var b, g;
  switch (ft.oids[e]) {
    case "aes128-CBC":
      b = 16, g = De.aes.createDecryptionCipher;
      break;
    case "aes192-CBC":
      b = 24, g = De.aes.createDecryptionCipher;
      break;
    case "aes256-CBC":
      b = 32, g = De.aes.createDecryptionCipher;
      break;
    case "des-EDE3-CBC":
      b = 24, g = De.des.createDecryptionCipher;
      break;
    case "desCBC":
      b = 8, g = De.des.createDecryptionCipher;
      break;
  }
  var w = D2(r.prfOid), C = De.pkcs5.pbkdf2(o, p, d, b, w), T = r.encIv, k = g(C);
  return k.start(T), k;
};
ft.pbe.getCipherForPKCS12PBE = function(e, t, o) {
  var r = {}, h = [];
  if (!ye.validate(t, oI, r, h)) {
    var a = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    throw a.errors = h, a;
  }
  var p = De.util.createBuffer(r.salt), d = De.util.createBuffer(r.iterations);
  d = d.getInt(d.length() << 3);
  var b, g, w;
  switch (e) {
    case ft.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
      b = 24, g = 8, w = De.des.startDecrypting;
      break;
    case ft.oids["pbewithSHAAnd40BitRC2-CBC"]:
      b = 5, g = 8, w = function(O, N) {
        var j = De.rc2.createDecryptionCipher(O, 40);
        return j.start(N, null), j;
      };
      break;
    default:
      var a = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
      throw a.oid = e, a;
  }
  var C = D2(r.prfOid), T = ft.pbe.generatePkcs12Key(o, p, 1, d, b, C);
  C.start();
  var k = ft.pbe.generatePkcs12Key(o, p, 2, d, g, C);
  return w(T, k);
};
ft.pbe.opensslDeriveBytes = function(e, t, o, r) {
  if (typeof r > "u" || r === null) {
    if (!("md5" in De.md))
      throw new Error('"md5" hash algorithm unavailable.');
    r = De.md.md5.create();
  }
  t === null && (t = "");
  for (var h = [Gp(r, e + t)], a = 16, p = 1; a < o; ++p, a += 16)
    h.push(Gp(r, h[p - 1] + e + t));
  return h.join("").substr(0, o);
};
function Gp(e, t) {
  return e.start().update(t).digest().getBytes();
}
function D2(e) {
  var t;
  if (!e)
    t = "hmacWithSHA1";
  else if (t = ft.oids[ye.derToOid(e)], !t) {
    var o = new Error("Unsupported PRF OID.");
    throw o.oid = e, o.supported = [
      "hmacWithSHA1",
      "hmacWithSHA224",
      "hmacWithSHA256",
      "hmacWithSHA384",
      "hmacWithSHA512"
    ], o;
  }
  return O2(t);
}
function O2(e) {
  var t = De.md;
  switch (e) {
    case "hmacWithSHA224":
      t = De.md.sha512;
    case "hmacWithSHA1":
    case "hmacWithSHA256":
    case "hmacWithSHA384":
    case "hmacWithSHA512":
      e = e.substr(8).toLowerCase();
      break;
    default:
      var o = new Error("Unsupported PRF algorithm.");
      throw o.algorithm = e, o.supported = [
        "hmacWithSHA1",
        "hmacWithSHA224",
        "hmacWithSHA256",
        "hmacWithSHA384",
        "hmacWithSHA512"
      ], o;
  }
  if (!t || !(e in t))
    throw new Error("Unknown hash algorithm: " + e);
  return t[e].create();
}
function uI(e, t, o, r) {
  var h = ye.create(ye.Class.UNIVERSAL, ye.Type.SEQUENCE, !0, [
    // salt
    ye.create(
      ye.Class.UNIVERSAL,
      ye.Type.OCTETSTRING,
      !1,
      e
    ),
    // iteration count
    ye.create(
      ye.Class.UNIVERSAL,
      ye.Type.INTEGER,
      !1,
      t.getBytes()
    )
  ]);
  return r !== "hmacWithSHA1" && h.value.push(
    // key length
    ye.create(
      ye.Class.UNIVERSAL,
      ye.Type.INTEGER,
      !1,
      De.util.hexToBytes(o.toString(16))
    ),
    // AlgorithmIdentifier
    ye.create(ye.Class.UNIVERSAL, ye.Type.SEQUENCE, !0, [
      // algorithm
      ye.create(
        ye.Class.UNIVERSAL,
        ye.Type.OID,
        !1,
        ye.oidToDer(ft.oids[r]).getBytes()
      ),
      // parameters (null)
      ye.create(ye.Class.UNIVERSAL, ye.Type.NULL, !1, "")
    ])
  ), h;
}
var Pa = ht, Te = Pa.asn1, r0 = Pa.pkcs7asn1 = Pa.pkcs7asn1 || {};
Pa.pkcs7 = Pa.pkcs7 || {};
Pa.pkcs7.asn1 = r0;
var P2 = {
  name: "ContentInfo",
  tagClass: Te.Class.UNIVERSAL,
  type: Te.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "ContentInfo.ContentType",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.OID,
    constructed: !1,
    capture: "contentType"
  }, {
    name: "ContentInfo.content",
    tagClass: Te.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: !0,
    optional: !0,
    captureAsn1: "content"
  }]
};
r0.contentInfoValidator = P2;
var L2 = {
  name: "EncryptedContentInfo",
  tagClass: Te.Class.UNIVERSAL,
  type: Te.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "EncryptedContentInfo.contentType",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.OID,
    constructed: !1,
    capture: "contentType"
  }, {
    name: "EncryptedContentInfo.contentEncryptionAlgorithm",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
      tagClass: Te.Class.UNIVERSAL,
      type: Te.Type.OID,
      constructed: !1,
      capture: "encAlgorithm"
    }, {
      name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
      tagClass: Te.Class.UNIVERSAL,
      captureAsn1: "encParameter"
    }]
  }, {
    name: "EncryptedContentInfo.encryptedContent",
    tagClass: Te.Class.CONTEXT_SPECIFIC,
    type: 0,
    /* The PKCS#7 structure output by OpenSSL somewhat differs from what
     * other implementations do generate.
     *
     * OpenSSL generates a structure like this:
     * SEQUENCE {
     *    ...
     *    [0]
     *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *       ...
     * }
     *
     * Whereas other implementations (and this PKCS#7 module) generate:
     * SEQUENCE {
     *    ...
     *    [0] {
     *       OCTET STRING
     *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *          ...
     *    }
     * }
     *
     * In order to support both, we just capture the context specific
     * field here.  The OCTET STRING bit is removed below.
     */
    capture: "encryptedContent",
    captureAsn1: "encryptedContentAsn1"
  }]
};
r0.envelopedDataValidator = {
  name: "EnvelopedData",
  tagClass: Te.Class.UNIVERSAL,
  type: Te.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "EnvelopedData.Version",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.INTEGER,
    constructed: !1,
    capture: "version"
  }, {
    name: "EnvelopedData.RecipientInfos",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.SET,
    constructed: !0,
    captureAsn1: "recipientInfos"
  }].concat(L2)
};
r0.encryptedDataValidator = {
  name: "EncryptedData",
  tagClass: Te.Class.UNIVERSAL,
  type: Te.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "EncryptedData.Version",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.INTEGER,
    constructed: !1,
    capture: "version"
  }].concat(L2)
};
var cI = {
  name: "SignerInfo",
  tagClass: Te.Class.UNIVERSAL,
  type: Te.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "SignerInfo.version",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.INTEGER,
    constructed: !1
  }, {
    name: "SignerInfo.issuerAndSerialNumber",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "SignerInfo.issuerAndSerialNumber.issuer",
      tagClass: Te.Class.UNIVERSAL,
      type: Te.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: "issuer"
    }, {
      name: "SignerInfo.issuerAndSerialNumber.serialNumber",
      tagClass: Te.Class.UNIVERSAL,
      type: Te.Type.INTEGER,
      constructed: !1,
      capture: "serial"
    }]
  }, {
    name: "SignerInfo.digestAlgorithm",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "SignerInfo.digestAlgorithm.algorithm",
      tagClass: Te.Class.UNIVERSAL,
      type: Te.Type.OID,
      constructed: !1,
      capture: "digestAlgorithm"
    }, {
      name: "SignerInfo.digestAlgorithm.parameter",
      tagClass: Te.Class.UNIVERSAL,
      constructed: !1,
      captureAsn1: "digestParameter",
      optional: !0
    }]
  }, {
    name: "SignerInfo.authenticatedAttributes",
    tagClass: Te.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: !0,
    optional: !0,
    capture: "authenticatedAttributes"
  }, {
    name: "SignerInfo.digestEncryptionAlgorithm",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.SEQUENCE,
    constructed: !0,
    capture: "signatureAlgorithm"
  }, {
    name: "SignerInfo.encryptedDigest",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.OCTETSTRING,
    constructed: !1,
    capture: "signature"
  }, {
    name: "SignerInfo.unauthenticatedAttributes",
    tagClass: Te.Class.CONTEXT_SPECIFIC,
    type: 1,
    constructed: !0,
    optional: !0,
    capture: "unauthenticatedAttributes"
  }]
};
r0.signedDataValidator = {
  name: "SignedData",
  tagClass: Te.Class.UNIVERSAL,
  type: Te.Type.SEQUENCE,
  constructed: !0,
  value: [
    {
      name: "SignedData.Version",
      tagClass: Te.Class.UNIVERSAL,
      type: Te.Type.INTEGER,
      constructed: !1,
      capture: "version"
    },
    {
      name: "SignedData.DigestAlgorithms",
      tagClass: Te.Class.UNIVERSAL,
      type: Te.Type.SET,
      constructed: !0,
      captureAsn1: "digestAlgorithms"
    },
    P2,
    {
      name: "SignedData.Certificates",
      tagClass: Te.Class.CONTEXT_SPECIFIC,
      type: 0,
      optional: !0,
      captureAsn1: "certificates"
    },
    {
      name: "SignedData.CertificateRevocationLists",
      tagClass: Te.Class.CONTEXT_SPECIFIC,
      type: 1,
      optional: !0,
      captureAsn1: "crls"
    },
    {
      name: "SignedData.SignerInfos",
      tagClass: Te.Class.UNIVERSAL,
      type: Te.Type.SET,
      capture: "signerInfos",
      optional: !0,
      value: [cI]
    }
  ]
};
r0.recipientInfoValidator = {
  name: "RecipientInfo",
  tagClass: Te.Class.UNIVERSAL,
  type: Te.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "RecipientInfo.version",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.INTEGER,
    constructed: !1,
    capture: "version"
  }, {
    name: "RecipientInfo.issuerAndSerial",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "RecipientInfo.issuerAndSerial.issuer",
      tagClass: Te.Class.UNIVERSAL,
      type: Te.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: "issuer"
    }, {
      name: "RecipientInfo.issuerAndSerial.serialNumber",
      tagClass: Te.Class.UNIVERSAL,
      type: Te.Type.INTEGER,
      constructed: !1,
      capture: "serial"
    }]
  }, {
    name: "RecipientInfo.keyEncryptionAlgorithm",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
      tagClass: Te.Class.UNIVERSAL,
      type: Te.Type.OID,
      constructed: !1,
      capture: "encAlgorithm"
    }, {
      name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
      tagClass: Te.Class.UNIVERSAL,
      constructed: !1,
      captureAsn1: "encParameter",
      optional: !0
    }]
  }, {
    name: "RecipientInfo.encryptedKey",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.OCTETSTRING,
    constructed: !1,
    capture: "encKey"
  }]
};
var Yn = ht;
Yn.mgf = Yn.mgf || {};
var hI = Yn.mgf.mgf1 = Yn.mgf1 = Yn.mgf1 || {};
hI.create = function(e) {
  var t = {
    /**
     * Generate mask of specified length.
     *
     * @param {String} seed The seed for mask generation.
     * @param maskLen Number of bytes to generate.
     * @return {String} The generated mask.
     */
    generate: function(o, r) {
      for (var h = new Yn.util.ByteBuffer(), a = Math.ceil(r / e.digestLength), p = 0; p < a; p++) {
        var d = new Yn.util.ByteBuffer();
        d.putInt32(p), e.start(), e.update(o + d.getBytes()), h.putBuffer(e.digest());
      }
      return h.truncate(h.length() - r), h.getBytes();
    }
  };
  return t;
};
var Fs = ht;
Fs.mgf = Fs.mgf || {};
Fs.mgf.mgf1 = Fs.mgf1;
var Vn = ht, lI = Vn.pss = Vn.pss || {};
lI.create = function(e) {
  arguments.length === 3 && (e = {
    md: arguments[0],
    mgf: arguments[1],
    saltLength: arguments[2]
  });
  var t = e.md, o = e.mgf, r = t.digestLength, h = e.salt || null;
  typeof h == "string" && (h = Vn.util.createBuffer(h));
  var a;
  if ("saltLength" in e)
    a = e.saltLength;
  else if (h !== null)
    a = h.length();
  else
    throw new Error("Salt length not specified or specific salt not given.");
  if (h !== null && h.length() !== a)
    throw new Error("Given salt length does not match length of given salt.");
  var p = e.prng || Vn.random, d = {};
  return d.encode = function(b, g) {
    var w, C = g - 1, T = Math.ceil(C / 8), k = b.digest().getBytes();
    if (T < r + a + 2)
      throw new Error("Message is too long to encrypt.");
    var q;
    h === null ? q = p.getBytesSync(a) : q = h.bytes();
    var O = new Vn.util.ByteBuffer();
    O.fillWithByte(0, 8), O.putBytes(k), O.putBytes(q), t.start(), t.update(O.getBytes());
    var N = t.digest().getBytes(), j = new Vn.util.ByteBuffer();
    j.fillWithByte(0, T - a - r - 2), j.putByte(1), j.putBytes(q);
    var U = j.getBytes(), H = T - r - 1, z = o.generate(N, H), ee = "";
    for (w = 0; w < H; w++)
      ee += String.fromCharCode(U.charCodeAt(w) ^ z.charCodeAt(w));
    var ne = 65280 >> 8 * T - C & 255;
    return ee = String.fromCharCode(ee.charCodeAt(0) & ~ne) + ee.substr(1), ee + N + "¼";
  }, d.verify = function(b, g, w) {
    var C, T = w - 1, k = Math.ceil(T / 8);
    if (g = g.substr(-k), k < r + a + 2)
      throw new Error("Inconsistent parameters to PSS signature verification.");
    if (g.charCodeAt(k - 1) !== 188)
      throw new Error("Encoded message does not end in 0xBC.");
    var q = k - r - 1, O = g.substr(0, q), N = g.substr(q, r), j = 65280 >> 8 * k - T & 255;
    if (O.charCodeAt(0) & j)
      throw new Error("Bits beyond keysize not zero as expected.");
    var U = o.generate(N, q), H = "";
    for (C = 0; C < q; C++)
      H += String.fromCharCode(O.charCodeAt(C) ^ U.charCodeAt(C));
    H = String.fromCharCode(H.charCodeAt(0) & ~j) + H.substr(1);
    var z = k - r - a - 2;
    for (C = 0; C < z; C++)
      if (H.charCodeAt(C) !== 0)
        throw new Error("Leftmost octets not zero as expected");
    if (H.charCodeAt(z) !== 1)
      throw new Error("Inconsistent PSS signature, 0x01 marker not found");
    var ee = H.substr(-a), ne = new Vn.util.ByteBuffer();
    ne.fillWithByte(0, 8), ne.putBytes(b), ne.putBytes(ee), t.start(), t.update(ne.getBytes());
    var le = t.digest().getBytes();
    return N === le;
  }, d;
};
var Ge = ht, V = Ge.asn1, we = Ge.pki = Ge.pki || {}, bt = we.oids, Kt = {};
Kt.CN = bt.commonName;
Kt.commonName = "CN";
Kt.C = bt.countryName;
Kt.countryName = "C";
Kt.L = bt.localityName;
Kt.localityName = "L";
Kt.ST = bt.stateOrProvinceName;
Kt.stateOrProvinceName = "ST";
Kt.O = bt.organizationName;
Kt.organizationName = "O";
Kt.OU = bt.organizationalUnitName;
Kt.organizationalUnitName = "OU";
Kt.E = bt.emailAddress;
Kt.emailAddress = "E";
var k2 = Ge.pki.rsa.publicKeyValidator, dI = {
  name: "Certificate",
  tagClass: V.Class.UNIVERSAL,
  type: V.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "Certificate.TBSCertificate",
    tagClass: V.Class.UNIVERSAL,
    type: V.Type.SEQUENCE,
    constructed: !0,
    captureAsn1: "tbsCertificate",
    value: [
      {
        name: "Certificate.TBSCertificate.version",
        tagClass: V.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: !0,
        optional: !0,
        value: [{
          name: "Certificate.TBSCertificate.version.integer",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.INTEGER,
          constructed: !1,
          capture: "certVersion"
        }]
      },
      {
        name: "Certificate.TBSCertificate.serialNumber",
        tagClass: V.Class.UNIVERSAL,
        type: V.Type.INTEGER,
        constructed: !1,
        capture: "certSerialNumber"
      },
      {
        name: "Certificate.TBSCertificate.signature",
        tagClass: V.Class.UNIVERSAL,
        type: V.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "Certificate.TBSCertificate.signature.algorithm",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.OID,
          constructed: !1,
          capture: "certinfoSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: V.Class.UNIVERSAL,
          optional: !0,
          captureAsn1: "certinfoSignatureParams"
        }]
      },
      {
        name: "Certificate.TBSCertificate.issuer",
        tagClass: V.Class.UNIVERSAL,
        type: V.Type.SEQUENCE,
        constructed: !0,
        captureAsn1: "certIssuer"
      },
      {
        name: "Certificate.TBSCertificate.validity",
        tagClass: V.Class.UNIVERSAL,
        type: V.Type.SEQUENCE,
        constructed: !0,
        // Note: UTC and generalized times may both appear so the capture
        // names are based on their detected order, the names used below
        // are only for the common case, which validity time really means
        // "notBefore" and which means "notAfter" will be determined by order
        value: [{
          // notBefore (Time) (UTC time case)
          name: "Certificate.TBSCertificate.validity.notBefore (utc)",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.UTCTIME,
          constructed: !1,
          optional: !0,
          capture: "certValidity1UTCTime"
        }, {
          // notBefore (Time) (generalized time case)
          name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.GENERALIZEDTIME,
          constructed: !1,
          optional: !0,
          capture: "certValidity2GeneralizedTime"
        }, {
          // notAfter (Time) (only UTC time is supported)
          name: "Certificate.TBSCertificate.validity.notAfter (utc)",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.UTCTIME,
          constructed: !1,
          optional: !0,
          capture: "certValidity3UTCTime"
        }, {
          // notAfter (Time) (only UTC time is supported)
          name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.GENERALIZEDTIME,
          constructed: !1,
          optional: !0,
          capture: "certValidity4GeneralizedTime"
        }]
      },
      {
        // Name (subject) (RDNSequence)
        name: "Certificate.TBSCertificate.subject",
        tagClass: V.Class.UNIVERSAL,
        type: V.Type.SEQUENCE,
        constructed: !0,
        captureAsn1: "certSubject"
      },
      // SubjectPublicKeyInfo
      k2,
      {
        // issuerUniqueID (optional)
        name: "Certificate.TBSCertificate.issuerUniqueID",
        tagClass: V.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: !0,
        optional: !0,
        value: [{
          name: "Certificate.TBSCertificate.issuerUniqueID.id",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.BITSTRING,
          constructed: !1,
          // TODO: support arbitrary bit length ids
          captureBitStringValue: "certIssuerUniqueId"
        }]
      },
      {
        // subjectUniqueID (optional)
        name: "Certificate.TBSCertificate.subjectUniqueID",
        tagClass: V.Class.CONTEXT_SPECIFIC,
        type: 2,
        constructed: !0,
        optional: !0,
        value: [{
          name: "Certificate.TBSCertificate.subjectUniqueID.id",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.BITSTRING,
          constructed: !1,
          // TODO: support arbitrary bit length ids
          captureBitStringValue: "certSubjectUniqueId"
        }]
      },
      {
        // Extensions (optional)
        name: "Certificate.TBSCertificate.extensions",
        tagClass: V.Class.CONTEXT_SPECIFIC,
        type: 3,
        constructed: !0,
        captureAsn1: "certExtensions",
        optional: !0
      }
    ]
  }, {
    // AlgorithmIdentifier (signature algorithm)
    name: "Certificate.signatureAlgorithm",
    tagClass: V.Class.UNIVERSAL,
    type: V.Type.SEQUENCE,
    constructed: !0,
    value: [{
      // algorithm
      name: "Certificate.signatureAlgorithm.algorithm",
      tagClass: V.Class.UNIVERSAL,
      type: V.Type.OID,
      constructed: !1,
      capture: "certSignatureOid"
    }, {
      name: "Certificate.TBSCertificate.signature.parameters",
      tagClass: V.Class.UNIVERSAL,
      optional: !0,
      captureAsn1: "certSignatureParams"
    }]
  }, {
    // SignatureValue
    name: "Certificate.signatureValue",
    tagClass: V.Class.UNIVERSAL,
    type: V.Type.BITSTRING,
    constructed: !1,
    captureBitStringValue: "certSignature"
  }]
}, pI = {
  name: "rsapss",
  tagClass: V.Class.UNIVERSAL,
  type: V.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "rsapss.hashAlgorithm",
    tagClass: V.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: !0,
    value: [{
      name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
      tagClass: V.Class.UNIVERSAL,
      type: V.Class.SEQUENCE,
      constructed: !0,
      optional: !0,
      value: [{
        name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
        tagClass: V.Class.UNIVERSAL,
        type: V.Type.OID,
        constructed: !1,
        capture: "hashOid"
        /* parameter block omitted, for SHA1 NULL anyhow. */
      }]
    }]
  }, {
    name: "rsapss.maskGenAlgorithm",
    tagClass: V.Class.CONTEXT_SPECIFIC,
    type: 1,
    constructed: !0,
    value: [{
      name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
      tagClass: V.Class.UNIVERSAL,
      type: V.Class.SEQUENCE,
      constructed: !0,
      optional: !0,
      value: [{
        name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
        tagClass: V.Class.UNIVERSAL,
        type: V.Type.OID,
        constructed: !1,
        capture: "maskGenOid"
      }, {
        name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
        tagClass: V.Class.UNIVERSAL,
        type: V.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.OID,
          constructed: !1,
          capture: "maskGenHashOid"
          /* parameter block omitted, for SHA1 NULL anyhow. */
        }]
      }]
    }]
  }, {
    name: "rsapss.saltLength",
    tagClass: V.Class.CONTEXT_SPECIFIC,
    type: 2,
    optional: !0,
    value: [{
      name: "rsapss.saltLength.saltLength",
      tagClass: V.Class.UNIVERSAL,
      type: V.Class.INTEGER,
      constructed: !1,
      capture: "saltLength"
    }]
  }, {
    name: "rsapss.trailerField",
    tagClass: V.Class.CONTEXT_SPECIFIC,
    type: 3,
    optional: !0,
    value: [{
      name: "rsapss.trailer.trailer",
      tagClass: V.Class.UNIVERSAL,
      type: V.Class.INTEGER,
      constructed: !1,
      capture: "trailer"
    }]
  }]
}, vI = {
  name: "CertificationRequestInfo",
  tagClass: V.Class.UNIVERSAL,
  type: V.Type.SEQUENCE,
  constructed: !0,
  captureAsn1: "certificationRequestInfo",
  value: [
    {
      name: "CertificationRequestInfo.integer",
      tagClass: V.Class.UNIVERSAL,
      type: V.Type.INTEGER,
      constructed: !1,
      capture: "certificationRequestInfoVersion"
    },
    {
      // Name (subject) (RDNSequence)
      name: "CertificationRequestInfo.subject",
      tagClass: V.Class.UNIVERSAL,
      type: V.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: "certificationRequestInfoSubject"
    },
    // SubjectPublicKeyInfo
    k2,
    {
      name: "CertificationRequestInfo.attributes",
      tagClass: V.Class.CONTEXT_SPECIFIC,
      type: 0,
      constructed: !0,
      optional: !0,
      capture: "certificationRequestInfoAttributes",
      value: [{
        name: "CertificationRequestInfo.attributes",
        tagClass: V.Class.UNIVERSAL,
        type: V.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "CertificationRequestInfo.attributes.type",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.OID,
          constructed: !1
        }, {
          name: "CertificationRequestInfo.attributes.value",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.SET,
          constructed: !0
        }]
      }]
    }
  ]
}, yI = {
  name: "CertificationRequest",
  tagClass: V.Class.UNIVERSAL,
  type: V.Type.SEQUENCE,
  constructed: !0,
  captureAsn1: "csr",
  value: [
    vI,
    {
      // AlgorithmIdentifier (signature algorithm)
      name: "CertificationRequest.signatureAlgorithm",
      tagClass: V.Class.UNIVERSAL,
      type: V.Type.SEQUENCE,
      constructed: !0,
      value: [{
        // algorithm
        name: "CertificationRequest.signatureAlgorithm.algorithm",
        tagClass: V.Class.UNIVERSAL,
        type: V.Type.OID,
        constructed: !1,
        capture: "csrSignatureOid"
      }, {
        name: "CertificationRequest.signatureAlgorithm.parameters",
        tagClass: V.Class.UNIVERSAL,
        optional: !0,
        captureAsn1: "csrSignatureParams"
      }]
    },
    {
      // signature
      name: "CertificationRequest.signature",
      tagClass: V.Class.UNIVERSAL,
      type: V.Type.BITSTRING,
      constructed: !1,
      captureBitStringValue: "csrSignature"
    }
  ]
};
we.RDNAttributesAsArray = function(e, t) {
  for (var o = [], r, h, a, p = 0; p < e.value.length; ++p) {
    r = e.value[p];
    for (var d = 0; d < r.value.length; ++d)
      a = {}, h = r.value[d], a.type = V.derToOid(h.value[0].value), a.value = h.value[1].value, a.valueTagClass = h.value[1].type, a.type in bt && (a.name = bt[a.type], a.name in Kt && (a.shortName = Kt[a.name])), t && (t.update(a.type), t.update(a.value)), o.push(a);
  }
  return o;
};
we.CRIAttributesAsArray = function(e) {
  for (var t = [], o = 0; o < e.length; ++o)
    for (var r = e[o], h = V.derToOid(r.value[0].value), a = r.value[1].value, p = 0; p < a.length; ++p) {
      var d = {};
      if (d.type = h, d.value = a[p].value, d.valueTagClass = a[p].type, d.type in bt && (d.name = bt[d.type], d.name in Kt && (d.shortName = Kt[d.name])), d.type === bt.extensionRequest) {
        d.extensions = [];
        for (var b = 0; b < d.value.length; ++b)
          d.extensions.push(we.certificateExtensionFromAsn1(d.value[b]));
      }
      t.push(d);
    }
  return t;
};
function Bn(e, t) {
  typeof t == "string" && (t = { shortName: t });
  for (var o = null, r, h = 0; o === null && h < e.attributes.length; ++h)
    r = e.attributes[h], (t.type && t.type === r.type || t.name && t.name === r.name || t.shortName && t.shortName === r.shortName) && (o = r);
  return o;
}
var qs = function(e, t, o) {
  var r = {};
  if (e !== bt["RSASSA-PSS"])
    return r;
  o && (r = {
    hash: {
      algorithmOid: bt.sha1
    },
    mgf: {
      algorithmOid: bt.mgf1,
      hash: {
        algorithmOid: bt.sha1
      }
    },
    saltLength: 20
  });
  var h = {}, a = [];
  if (!V.validate(t, pI, h, a)) {
    var p = new Error("Cannot read RSASSA-PSS parameter block.");
    throw p.errors = a, p;
  }
  return h.hashOid !== void 0 && (r.hash = r.hash || {}, r.hash.algorithmOid = V.derToOid(h.hashOid)), h.maskGenOid !== void 0 && (r.mgf = r.mgf || {}, r.mgf.algorithmOid = V.derToOid(h.maskGenOid), r.mgf.hash = r.mgf.hash || {}, r.mgf.hash.algorithmOid = V.derToOid(h.maskGenHashOid)), h.saltLength !== void 0 && (r.saltLength = h.saltLength.charCodeAt(0)), r;
}, Vf = function(e) {
  switch (bt[e.signatureOid]) {
    case "sha1WithRSAEncryption":
    case "sha1WithRSASignature":
      return Ge.md.sha1.create();
    case "md5WithRSAEncryption":
      return Ge.md.md5.create();
    case "sha256WithRSAEncryption":
      return Ge.md.sha256.create();
    case "sha384WithRSAEncryption":
      return Ge.md.sha384.create();
    case "sha512WithRSAEncryption":
      return Ge.md.sha512.create();
    case "RSASSA-PSS":
      return Ge.md.sha256.create();
    default:
      var t = new Error(
        "Could not compute " + e.type + " digest. Unknown signature OID."
      );
      throw t.signatureOid = e.signatureOid, t;
  }
}, U2 = function(e) {
  var t = e.certificate, o;
  switch (t.signatureOid) {
    case bt.sha1WithRSAEncryption:
    case bt.sha1WithRSASignature:
      break;
    case bt["RSASSA-PSS"]:
      var r, h;
      if (r = bt[t.signatureParameters.mgf.hash.algorithmOid], r === void 0 || Ge.md[r] === void 0) {
        var a = new Error("Unsupported MGF hash function.");
        throw a.oid = t.signatureParameters.mgf.hash.algorithmOid, a.name = r, a;
      }
      if (h = bt[t.signatureParameters.mgf.algorithmOid], h === void 0 || Ge.mgf[h] === void 0) {
        var a = new Error("Unsupported MGF function.");
        throw a.oid = t.signatureParameters.mgf.algorithmOid, a.name = h, a;
      }
      if (h = Ge.mgf[h].create(Ge.md[r].create()), r = bt[t.signatureParameters.hash.algorithmOid], r === void 0 || Ge.md[r] === void 0) {
        var a = new Error("Unsupported RSASSA-PSS hash function.");
        throw a.oid = t.signatureParameters.hash.algorithmOid, a.name = r, a;
      }
      o = Ge.pss.create(
        Ge.md[r].create(),
        h,
        t.signatureParameters.saltLength
      );
      break;
  }
  return t.publicKey.verify(
    e.md.digest().getBytes(),
    e.signature,
    o
  );
};
we.certificateFromPem = function(e, t, o) {
  var r = Ge.pem.decode(e)[0];
  if (r.type !== "CERTIFICATE" && r.type !== "X509 CERTIFICATE" && r.type !== "TRUSTED CERTIFICATE") {
    var h = new Error(
      'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
    );
    throw h.headerType = r.type, h;
  }
  if (r.procType && r.procType.type === "ENCRYPTED")
    throw new Error(
      "Could not convert certificate from PEM; PEM is encrypted."
    );
  var a = V.fromDer(r.body, o);
  return we.certificateFromAsn1(a, t);
};
we.certificateToPem = function(e, t) {
  var o = {
    type: "CERTIFICATE",
    body: V.toDer(we.certificateToAsn1(e)).getBytes()
  };
  return Ge.pem.encode(o, { maxline: t });
};
we.publicKeyFromPem = function(e) {
  var t = Ge.pem.decode(e)[0];
  if (t.type !== "PUBLIC KEY" && t.type !== "RSA PUBLIC KEY") {
    var o = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
    throw o.headerType = t.type, o;
  }
  if (t.procType && t.procType.type === "ENCRYPTED")
    throw new Error("Could not convert public key from PEM; PEM is encrypted.");
  var r = V.fromDer(t.body);
  return we.publicKeyFromAsn1(r);
};
we.publicKeyToPem = function(e, t) {
  var o = {
    type: "PUBLIC KEY",
    body: V.toDer(we.publicKeyToAsn1(e)).getBytes()
  };
  return Ge.pem.encode(o, { maxline: t });
};
we.publicKeyToRSAPublicKeyPem = function(e, t) {
  var o = {
    type: "RSA PUBLIC KEY",
    body: V.toDer(we.publicKeyToRSAPublicKey(e)).getBytes()
  };
  return Ge.pem.encode(o, { maxline: t });
};
we.getPublicKeyFingerprint = function(e, t) {
  t = t || {};
  var o = t.md || Ge.md.sha1.create(), r = t.type || "RSAPublicKey", h;
  switch (r) {
    case "RSAPublicKey":
      h = V.toDer(we.publicKeyToRSAPublicKey(e)).getBytes();
      break;
    case "SubjectPublicKeyInfo":
      h = V.toDer(we.publicKeyToAsn1(e)).getBytes();
      break;
    default:
      throw new Error('Unknown fingerprint type "' + t.type + '".');
  }
  o.start(), o.update(h);
  var a = o.digest();
  if (t.encoding === "hex") {
    var p = a.toHex();
    return t.delimiter ? p.match(/.{2}/g).join(t.delimiter) : p;
  } else {
    if (t.encoding === "binary")
      return a.getBytes();
    if (t.encoding)
      throw new Error('Unknown encoding "' + t.encoding + '".');
  }
  return a;
};
we.certificationRequestFromPem = function(e, t, o) {
  var r = Ge.pem.decode(e)[0];
  if (r.type !== "CERTIFICATE REQUEST") {
    var h = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
    throw h.headerType = r.type, h;
  }
  if (r.procType && r.procType.type === "ENCRYPTED")
    throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
  var a = V.fromDer(r.body, o);
  return we.certificationRequestFromAsn1(a, t);
};
we.certificationRequestToPem = function(e, t) {
  var o = {
    type: "CERTIFICATE REQUEST",
    body: V.toDer(we.certificationRequestToAsn1(e)).getBytes()
  };
  return Ge.pem.encode(o, { maxline: t });
};
we.createCertificate = function() {
  var e = {};
  return e.version = 2, e.serialNumber = "00", e.signatureOid = null, e.signature = null, e.siginfo = {}, e.siginfo.algorithmOid = null, e.validity = {}, e.validity.notBefore = /* @__PURE__ */ new Date(), e.validity.notAfter = /* @__PURE__ */ new Date(), e.issuer = {}, e.issuer.getField = function(t) {
    return Bn(e.issuer, t);
  }, e.issuer.addField = function(t) {
    Gr([t]), e.issuer.attributes.push(t);
  }, e.issuer.attributes = [], e.issuer.hash = null, e.subject = {}, e.subject.getField = function(t) {
    return Bn(e.subject, t);
  }, e.subject.addField = function(t) {
    Gr([t]), e.subject.attributes.push(t);
  }, e.subject.attributes = [], e.subject.hash = null, e.extensions = [], e.publicKey = null, e.md = null, e.setSubject = function(t, o) {
    Gr(t), e.subject.attributes = t, delete e.subject.uniqueId, o && (e.subject.uniqueId = o), e.subject.hash = null;
  }, e.setIssuer = function(t, o) {
    Gr(t), e.issuer.attributes = t, delete e.issuer.uniqueId, o && (e.issuer.uniqueId = o), e.issuer.hash = null;
  }, e.setExtensions = function(t) {
    for (var o = 0; o < t.length; ++o)
      F2(t[o], { cert: e });
    e.extensions = t;
  }, e.getExtension = function(t) {
    typeof t == "string" && (t = { name: t });
    for (var o = null, r, h = 0; o === null && h < e.extensions.length; ++h)
      r = e.extensions[h], (t.id && r.id === t.id || t.name && r.name === t.name) && (o = r);
    return o;
  }, e.sign = function(t, o) {
    e.md = o || Ge.md.sha1.create();
    var r = bt[e.md.algorithm + "WithRSAEncryption"];
    if (!r) {
      var h = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
      throw h.algorithm = e.md.algorithm, h;
    }
    e.signatureOid = e.siginfo.algorithmOid = r, e.tbsCertificate = we.getTBSCertificate(e);
    var a = V.toDer(e.tbsCertificate);
    e.md.update(a.getBytes()), e.signature = t.sign(e.md);
  }, e.verify = function(t) {
    var o = !1;
    if (!e.issued(t)) {
      var r = t.issuer, h = e.subject, a = new Error(
        "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
      );
      throw a.expectedIssuer = h.attributes, a.actualIssuer = r.attributes, a;
    }
    var p = t.md;
    if (p === null) {
      p = Vf({
        signatureOid: t.signatureOid,
        type: "certificate"
      });
      var d = t.tbsCertificate || we.getTBSCertificate(t), b = V.toDer(d);
      p.update(b.getBytes());
    }
    return p !== null && (o = U2({
      certificate: e,
      md: p,
      signature: t.signature
    })), o;
  }, e.isIssuer = function(t) {
    var o = !1, r = e.issuer, h = t.subject;
    if (r.hash && h.hash)
      o = r.hash === h.hash;
    else if (r.attributes.length === h.attributes.length) {
      o = !0;
      for (var a, p, d = 0; o && d < r.attributes.length; ++d)
        a = r.attributes[d], p = h.attributes[d], (a.type !== p.type || a.value !== p.value) && (o = !1);
    }
    return o;
  }, e.issued = function(t) {
    return t.isIssuer(e);
  }, e.generateSubjectKeyIdentifier = function() {
    return we.getPublicKeyFingerprint(e.publicKey, { type: "RSAPublicKey" });
  }, e.verifySubjectKeyIdentifier = function() {
    for (var t = bt.subjectKeyIdentifier, o = 0; o < e.extensions.length; ++o) {
      var r = e.extensions[o];
      if (r.id === t) {
        var h = e.generateSubjectKeyIdentifier().getBytes();
        return Ge.util.hexToBytes(r.subjectKeyIdentifier) === h;
      }
    }
    return !1;
  }, e;
};
we.certificateFromAsn1 = function(e, t) {
  var o = {}, r = [];
  if (!V.validate(e, dI, o, r)) {
    var h = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
    throw h.errors = r, h;
  }
  var a = V.derToOid(o.publicKeyOid);
  if (a !== we.oids.rsaEncryption)
    throw new Error("Cannot read public key. OID is not RSA.");
  var p = we.createCertificate();
  p.version = o.certVersion ? o.certVersion.charCodeAt(0) : 0;
  var d = Ge.util.createBuffer(o.certSerialNumber);
  p.serialNumber = d.toHex(), p.signatureOid = Ge.asn1.derToOid(o.certSignatureOid), p.signatureParameters = qs(
    p.signatureOid,
    o.certSignatureParams,
    !0
  ), p.siginfo.algorithmOid = Ge.asn1.derToOid(o.certinfoSignatureOid), p.siginfo.parameters = qs(
    p.siginfo.algorithmOid,
    o.certinfoSignatureParams,
    !1
  ), p.signature = o.certSignature;
  var b = [];
  if (o.certValidity1UTCTime !== void 0 && b.push(V.utcTimeToDate(o.certValidity1UTCTime)), o.certValidity2GeneralizedTime !== void 0 && b.push(V.generalizedTimeToDate(
    o.certValidity2GeneralizedTime
  )), o.certValidity3UTCTime !== void 0 && b.push(V.utcTimeToDate(o.certValidity3UTCTime)), o.certValidity4GeneralizedTime !== void 0 && b.push(V.generalizedTimeToDate(
    o.certValidity4GeneralizedTime
  )), b.length > 2)
    throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
  if (b.length < 2)
    throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
  if (p.validity.notBefore = b[0], p.validity.notAfter = b[1], p.tbsCertificate = o.tbsCertificate, t) {
    p.md = Vf({
      signatureOid: p.signatureOid,
      type: "certificate"
    });
    var g = V.toDer(p.tbsCertificate);
    p.md.update(g.getBytes());
  }
  var w = Ge.md.sha1.create(), C = V.toDer(o.certIssuer);
  w.update(C.getBytes()), p.issuer.getField = function(q) {
    return Bn(p.issuer, q);
  }, p.issuer.addField = function(q) {
    Gr([q]), p.issuer.attributes.push(q);
  }, p.issuer.attributes = we.RDNAttributesAsArray(o.certIssuer), o.certIssuerUniqueId && (p.issuer.uniqueId = o.certIssuerUniqueId), p.issuer.hash = w.digest().toHex();
  var T = Ge.md.sha1.create(), k = V.toDer(o.certSubject);
  return T.update(k.getBytes()), p.subject.getField = function(q) {
    return Bn(p.subject, q);
  }, p.subject.addField = function(q) {
    Gr([q]), p.subject.attributes.push(q);
  }, p.subject.attributes = we.RDNAttributesAsArray(o.certSubject), o.certSubjectUniqueId && (p.subject.uniqueId = o.certSubjectUniqueId), p.subject.hash = T.digest().toHex(), o.certExtensions ? p.extensions = we.certificateExtensionsFromAsn1(o.certExtensions) : p.extensions = [], p.publicKey = we.publicKeyFromAsn1(o.subjectPublicKeyInfo), p;
};
we.certificateExtensionsFromAsn1 = function(e) {
  for (var t = [], o = 0; o < e.value.length; ++o)
    for (var r = e.value[o], h = 0; h < r.value.length; ++h)
      t.push(we.certificateExtensionFromAsn1(r.value[h]));
  return t;
};
we.certificateExtensionFromAsn1 = function(e) {
  var t = {};
  if (t.id = V.derToOid(e.value[0].value), t.critical = !1, e.value[1].type === V.Type.BOOLEAN ? (t.critical = e.value[1].value.charCodeAt(0) !== 0, t.value = e.value[2].value) : t.value = e.value[1].value, t.id in bt) {
    if (t.name = bt[t.id], t.name === "keyUsage") {
      var o = V.fromDer(t.value), r = 0, h = 0;
      o.value.length > 1 && (r = o.value.charCodeAt(1), h = o.value.length > 2 ? o.value.charCodeAt(2) : 0), t.digitalSignature = (r & 128) === 128, t.nonRepudiation = (r & 64) === 64, t.keyEncipherment = (r & 32) === 32, t.dataEncipherment = (r & 16) === 16, t.keyAgreement = (r & 8) === 8, t.keyCertSign = (r & 4) === 4, t.cRLSign = (r & 2) === 2, t.encipherOnly = (r & 1) === 1, t.decipherOnly = (h & 128) === 128;
    } else if (t.name === "basicConstraints") {
      var o = V.fromDer(t.value);
      o.value.length > 0 && o.value[0].type === V.Type.BOOLEAN ? t.cA = o.value[0].value.charCodeAt(0) !== 0 : t.cA = !1;
      var a = null;
      o.value.length > 0 && o.value[0].type === V.Type.INTEGER ? a = o.value[0].value : o.value.length > 1 && (a = o.value[1].value), a !== null && (t.pathLenConstraint = V.derToInteger(a));
    } else if (t.name === "extKeyUsage")
      for (var o = V.fromDer(t.value), p = 0; p < o.value.length; ++p) {
        var d = V.derToOid(o.value[p].value);
        d in bt ? t[bt[d]] = !0 : t[d] = !0;
      }
    else if (t.name === "nsCertType") {
      var o = V.fromDer(t.value), r = 0;
      o.value.length > 1 && (r = o.value.charCodeAt(1)), t.client = (r & 128) === 128, t.server = (r & 64) === 64, t.email = (r & 32) === 32, t.objsign = (r & 16) === 16, t.reserved = (r & 8) === 8, t.sslCA = (r & 4) === 4, t.emailCA = (r & 2) === 2, t.objCA = (r & 1) === 1;
    } else if (t.name === "subjectAltName" || t.name === "issuerAltName") {
      t.altNames = [];
      for (var b, o = V.fromDer(t.value), g = 0; g < o.value.length; ++g) {
        b = o.value[g];
        var w = {
          type: b.type,
          value: b.value
        };
        switch (t.altNames.push(w), b.type) {
          case 1:
          case 2:
          case 6:
            break;
          case 7:
            w.ip = Ge.util.bytesToIP(b.value);
            break;
          case 8:
            w.oid = V.derToOid(b.value);
            break;
        }
      }
    } else if (t.name === "subjectKeyIdentifier") {
      var o = V.fromDer(t.value);
      t.subjectKeyIdentifier = Ge.util.bytesToHex(o.value);
    }
  }
  return t;
};
we.certificationRequestFromAsn1 = function(e, t) {
  var o = {}, r = [];
  if (!V.validate(e, yI, o, r)) {
    var h = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
    throw h.errors = r, h;
  }
  var a = V.derToOid(o.publicKeyOid);
  if (a !== we.oids.rsaEncryption)
    throw new Error("Cannot read public key. OID is not RSA.");
  var p = we.createCertificationRequest();
  if (p.version = o.csrVersion ? o.csrVersion.charCodeAt(0) : 0, p.signatureOid = Ge.asn1.derToOid(o.csrSignatureOid), p.signatureParameters = qs(
    p.signatureOid,
    o.csrSignatureParams,
    !0
  ), p.siginfo.algorithmOid = Ge.asn1.derToOid(o.csrSignatureOid), p.siginfo.parameters = qs(
    p.siginfo.algorithmOid,
    o.csrSignatureParams,
    !1
  ), p.signature = o.csrSignature, p.certificationRequestInfo = o.certificationRequestInfo, t) {
    p.md = Vf({
      signatureOid: p.signatureOid,
      type: "certification request"
    });
    var d = V.toDer(p.certificationRequestInfo);
    p.md.update(d.getBytes());
  }
  var b = Ge.md.sha1.create();
  return p.subject.getField = function(g) {
    return Bn(p.subject, g);
  }, p.subject.addField = function(g) {
    Gr([g]), p.subject.attributes.push(g);
  }, p.subject.attributes = we.RDNAttributesAsArray(
    o.certificationRequestInfoSubject,
    b
  ), p.subject.hash = b.digest().toHex(), p.publicKey = we.publicKeyFromAsn1(o.subjectPublicKeyInfo), p.getAttribute = function(g) {
    return Bn(p, g);
  }, p.addAttribute = function(g) {
    Gr([g]), p.attributes.push(g);
  }, p.attributes = we.CRIAttributesAsArray(
    o.certificationRequestInfoAttributes || []
  ), p;
};
we.createCertificationRequest = function() {
  var e = {};
  return e.version = 0, e.signatureOid = null, e.signature = null, e.siginfo = {}, e.siginfo.algorithmOid = null, e.subject = {}, e.subject.getField = function(t) {
    return Bn(e.subject, t);
  }, e.subject.addField = function(t) {
    Gr([t]), e.subject.attributes.push(t);
  }, e.subject.attributes = [], e.subject.hash = null, e.publicKey = null, e.attributes = [], e.getAttribute = function(t) {
    return Bn(e, t);
  }, e.addAttribute = function(t) {
    Gr([t]), e.attributes.push(t);
  }, e.md = null, e.setSubject = function(t) {
    Gr(t), e.subject.attributes = t, e.subject.hash = null;
  }, e.setAttributes = function(t) {
    Gr(t), e.attributes = t;
  }, e.sign = function(t, o) {
    e.md = o || Ge.md.sha1.create();
    var r = bt[e.md.algorithm + "WithRSAEncryption"];
    if (!r) {
      var h = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
      throw h.algorithm = e.md.algorithm, h;
    }
    e.signatureOid = e.siginfo.algorithmOid = r, e.certificationRequestInfo = we.getCertificationRequestInfo(e);
    var a = V.toDer(e.certificationRequestInfo);
    e.md.update(a.getBytes()), e.signature = t.sign(e.md);
  }, e.verify = function() {
    var t = !1, o = e.md;
    if (o === null) {
      o = Vf({
        signatureOid: e.signatureOid,
        type: "certification request"
      });
      var r = e.certificationRequestInfo || we.getCertificationRequestInfo(e), h = V.toDer(r);
      o.update(h.getBytes());
    }
    return o !== null && (t = U2({
      certificate: e,
      md: o,
      signature: e.signature
    })), t;
  }, e;
};
function La(e) {
  for (var t = V.create(
    V.Class.UNIVERSAL,
    V.Type.SEQUENCE,
    !0,
    []
  ), o, r, h = e.attributes, a = 0; a < h.length; ++a) {
    o = h[a];
    var p = o.value, d = V.Type.PRINTABLESTRING;
    "valueTagClass" in o && (d = o.valueTagClass, d === V.Type.UTF8 && (p = Ge.util.encodeUtf8(p))), r = V.create(V.Class.UNIVERSAL, V.Type.SET, !0, [
      V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
        // AttributeType
        V.create(
          V.Class.UNIVERSAL,
          V.Type.OID,
          !1,
          V.oidToDer(o.type).getBytes()
        ),
        // AttributeValue
        V.create(V.Class.UNIVERSAL, d, !1, p)
      ])
    ]), t.value.push(r);
  }
  return t;
}
function Gr(e) {
  for (var t, o = 0; o < e.length; ++o) {
    if (t = e[o], typeof t.name > "u" && (t.type && t.type in we.oids ? t.name = we.oids[t.type] : t.shortName && t.shortName in Kt && (t.name = we.oids[Kt[t.shortName]])), typeof t.type > "u")
      if (t.name && t.name in we.oids)
        t.type = we.oids[t.name];
      else {
        var r = new Error("Attribute type not specified.");
        throw r.attribute = t, r;
      }
    if (typeof t.shortName > "u" && t.name && t.name in Kt && (t.shortName = Kt[t.name]), t.type === bt.extensionRequest && (t.valueConstructed = !0, t.valueTagClass = V.Type.SEQUENCE, !t.value && t.extensions)) {
      t.value = [];
      for (var h = 0; h < t.extensions.length; ++h)
        t.value.push(we.certificateExtensionToAsn1(
          F2(t.extensions[h])
        ));
    }
    if (typeof t.value > "u") {
      var r = new Error("Attribute value not specified.");
      throw r.attribute = t, r;
    }
  }
}
function F2(e, t) {
  if (t = t || {}, typeof e.name > "u" && e.id && e.id in we.oids && (e.name = we.oids[e.id]), typeof e.id > "u")
    if (e.name && e.name in we.oids)
      e.id = we.oids[e.name];
    else {
      var o = new Error("Extension ID not specified.");
      throw o.extension = e, o;
    }
  if (typeof e.value < "u")
    return e;
  if (e.name === "keyUsage") {
    var r = 0, h = 0, a = 0;
    e.digitalSignature && (h |= 128, r = 7), e.nonRepudiation && (h |= 64, r = 6), e.keyEncipherment && (h |= 32, r = 5), e.dataEncipherment && (h |= 16, r = 4), e.keyAgreement && (h |= 8, r = 3), e.keyCertSign && (h |= 4, r = 2), e.cRLSign && (h |= 2, r = 1), e.encipherOnly && (h |= 1, r = 0), e.decipherOnly && (a |= 128, r = 7);
    var p = String.fromCharCode(r);
    a !== 0 ? p += String.fromCharCode(h) + String.fromCharCode(a) : h !== 0 && (p += String.fromCharCode(h)), e.value = V.create(
      V.Class.UNIVERSAL,
      V.Type.BITSTRING,
      !1,
      p
    );
  } else if (e.name === "basicConstraints")
    e.value = V.create(
      V.Class.UNIVERSAL,
      V.Type.SEQUENCE,
      !0,
      []
    ), e.cA && e.value.value.push(V.create(
      V.Class.UNIVERSAL,
      V.Type.BOOLEAN,
      !1,
      "ÿ"
    )), "pathLenConstraint" in e && e.value.value.push(V.create(
      V.Class.UNIVERSAL,
      V.Type.INTEGER,
      !1,
      V.integerToDer(e.pathLenConstraint).getBytes()
    ));
  else if (e.name === "extKeyUsage") {
    e.value = V.create(
      V.Class.UNIVERSAL,
      V.Type.SEQUENCE,
      !0,
      []
    );
    var d = e.value.value;
    for (var b in e)
      e[b] === !0 && (b in bt ? d.push(V.create(
        V.Class.UNIVERSAL,
        V.Type.OID,
        !1,
        V.oidToDer(bt[b]).getBytes()
      )) : b.indexOf(".") !== -1 && d.push(V.create(
        V.Class.UNIVERSAL,
        V.Type.OID,
        !1,
        V.oidToDer(b).getBytes()
      )));
  } else if (e.name === "nsCertType") {
    var r = 0, h = 0;
    e.client && (h |= 128, r = 7), e.server && (h |= 64, r = 6), e.email && (h |= 32, r = 5), e.objsign && (h |= 16, r = 4), e.reserved && (h |= 8, r = 3), e.sslCA && (h |= 4, r = 2), e.emailCA && (h |= 2, r = 1), e.objCA && (h |= 1, r = 0);
    var p = String.fromCharCode(r);
    h !== 0 && (p += String.fromCharCode(h)), e.value = V.create(
      V.Class.UNIVERSAL,
      V.Type.BITSTRING,
      !1,
      p
    );
  } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
    e.value = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, []);
    for (var g, w = 0; w < e.altNames.length; ++w) {
      g = e.altNames[w];
      var p = g.value;
      if (g.type === 7 && g.ip) {
        if (p = Ge.util.bytesFromIP(g.ip), p === null) {
          var o = new Error(
            'Extension "ip" value is not a valid IPv4 or IPv6 address.'
          );
          throw o.extension = e, o;
        }
      } else
        g.type === 8 && (g.oid ? p = V.oidToDer(V.oidToDer(g.oid)) : p = V.oidToDer(p));
      e.value.value.push(V.create(
        V.Class.CONTEXT_SPECIFIC,
        g.type,
        !1,
        p
      ));
    }
  } else if (e.name === "nsComment" && t.cert) {
    if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128)
      throw new Error('Invalid "nsComment" content.');
    e.value = V.create(
      V.Class.UNIVERSAL,
      V.Type.IA5STRING,
      !1,
      e.comment
    );
  } else if (e.name === "subjectKeyIdentifier" && t.cert) {
    var C = t.cert.generateSubjectKeyIdentifier();
    e.subjectKeyIdentifier = C.toHex(), e.value = V.create(
      V.Class.UNIVERSAL,
      V.Type.OCTETSTRING,
      !1,
      C.getBytes()
    );
  } else if (e.name === "authorityKeyIdentifier" && t.cert) {
    e.value = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, []);
    var d = e.value.value;
    if (e.keyIdentifier) {
      var T = e.keyIdentifier === !0 ? t.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
      d.push(
        V.create(V.Class.CONTEXT_SPECIFIC, 0, !1, T)
      );
    }
    if (e.authorityCertIssuer) {
      var k = [
        V.create(V.Class.CONTEXT_SPECIFIC, 4, !0, [
          La(e.authorityCertIssuer === !0 ? t.cert.issuer : e.authorityCertIssuer)
        ])
      ];
      d.push(
        V.create(V.Class.CONTEXT_SPECIFIC, 1, !0, k)
      );
    }
    if (e.serialNumber) {
      var q = Ge.util.hexToBytes(e.serialNumber === !0 ? t.cert.serialNumber : e.serialNumber);
      d.push(
        V.create(V.Class.CONTEXT_SPECIFIC, 2, !1, q)
      );
    }
  } else if (e.name === "cRLDistributionPoints") {
    e.value = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, []);
    for (var d = e.value.value, O = V.create(
      V.Class.UNIVERSAL,
      V.Type.SEQUENCE,
      !0,
      []
    ), N = V.create(
      V.Class.CONTEXT_SPECIFIC,
      0,
      !0,
      []
    ), g, w = 0; w < e.altNames.length; ++w) {
      g = e.altNames[w];
      var p = g.value;
      if (g.type === 7 && g.ip) {
        if (p = Ge.util.bytesFromIP(g.ip), p === null) {
          var o = new Error(
            'Extension "ip" value is not a valid IPv4 or IPv6 address.'
          );
          throw o.extension = e, o;
        }
      } else
        g.type === 8 && (g.oid ? p = V.oidToDer(V.oidToDer(g.oid)) : p = V.oidToDer(p));
      N.value.push(V.create(
        V.Class.CONTEXT_SPECIFIC,
        g.type,
        !1,
        p
      ));
    }
    O.value.push(V.create(
      V.Class.CONTEXT_SPECIFIC,
      0,
      !0,
      [N]
    )), d.push(O);
  }
  if (typeof e.value > "u") {
    var o = new Error("Extension value not specified.");
    throw o.extension = e, o;
  }
  return e;
}
function Kh(e, t) {
  switch (e) {
    case bt["RSASSA-PSS"]:
      var o = [];
      return t.hash.algorithmOid !== void 0 && o.push(V.create(V.Class.CONTEXT_SPECIFIC, 0, !0, [
        V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
          V.create(
            V.Class.UNIVERSAL,
            V.Type.OID,
            !1,
            V.oidToDer(t.hash.algorithmOid).getBytes()
          ),
          V.create(V.Class.UNIVERSAL, V.Type.NULL, !1, "")
        ])
      ])), t.mgf.algorithmOid !== void 0 && o.push(V.create(V.Class.CONTEXT_SPECIFIC, 1, !0, [
        V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
          V.create(
            V.Class.UNIVERSAL,
            V.Type.OID,
            !1,
            V.oidToDer(t.mgf.algorithmOid).getBytes()
          ),
          V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
            V.create(
              V.Class.UNIVERSAL,
              V.Type.OID,
              !1,
              V.oidToDer(t.mgf.hash.algorithmOid).getBytes()
            ),
            V.create(V.Class.UNIVERSAL, V.Type.NULL, !1, "")
          ])
        ])
      ])), t.saltLength !== void 0 && o.push(V.create(V.Class.CONTEXT_SPECIFIC, 2, !0, [
        V.create(
          V.Class.UNIVERSAL,
          V.Type.INTEGER,
          !1,
          V.integerToDer(t.saltLength).getBytes()
        )
      ])), V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, o);
    default:
      return V.create(V.Class.UNIVERSAL, V.Type.NULL, !1, "");
  }
}
function gI(e) {
  var t = V.create(V.Class.CONTEXT_SPECIFIC, 0, !0, []);
  if (e.attributes.length === 0)
    return t;
  for (var o = e.attributes, r = 0; r < o.length; ++r) {
    var h = o[r], a = h.value, p = V.Type.UTF8;
    "valueTagClass" in h && (p = h.valueTagClass), p === V.Type.UTF8 && (a = Ge.util.encodeUtf8(a));
    var d = !1;
    "valueConstructed" in h && (d = h.valueConstructed);
    var b = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
      // AttributeType
      V.create(
        V.Class.UNIVERSAL,
        V.Type.OID,
        !1,
        V.oidToDer(h.type).getBytes()
      ),
      V.create(V.Class.UNIVERSAL, V.Type.SET, !0, [
        // AttributeValue
        V.create(
          V.Class.UNIVERSAL,
          p,
          d,
          a
        )
      ])
    ]);
    t.value.push(b);
  }
  return t;
}
var mI = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z"), bI = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
function zp(e) {
  return e >= mI && e < bI ? V.create(
    V.Class.UNIVERSAL,
    V.Type.UTCTIME,
    !1,
    V.dateToUtcTime(e)
  ) : V.create(
    V.Class.UNIVERSAL,
    V.Type.GENERALIZEDTIME,
    !1,
    V.dateToGeneralizedTime(e)
  );
}
we.getTBSCertificate = function(e) {
  var t = zp(e.validity.notBefore), o = zp(e.validity.notAfter), r = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
    // version
    V.create(V.Class.CONTEXT_SPECIFIC, 0, !0, [
      // integer
      V.create(
        V.Class.UNIVERSAL,
        V.Type.INTEGER,
        !1,
        V.integerToDer(e.version).getBytes()
      )
    ]),
    // serialNumber
    V.create(
      V.Class.UNIVERSAL,
      V.Type.INTEGER,
      !1,
      Ge.util.hexToBytes(e.serialNumber)
    ),
    // signature
    V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
      // algorithm
      V.create(
        V.Class.UNIVERSAL,
        V.Type.OID,
        !1,
        V.oidToDer(e.siginfo.algorithmOid).getBytes()
      ),
      // parameters
      Kh(
        e.siginfo.algorithmOid,
        e.siginfo.parameters
      )
    ]),
    // issuer
    La(e.issuer),
    // validity
    V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
      t,
      o
    ]),
    // subject
    La(e.subject),
    // SubjectPublicKeyInfo
    we.publicKeyToAsn1(e.publicKey)
  ]);
  return e.issuer.uniqueId && r.value.push(
    V.create(V.Class.CONTEXT_SPECIFIC, 1, !0, [
      V.create(
        V.Class.UNIVERSAL,
        V.Type.BITSTRING,
        !1,
        // TODO: support arbitrary bit length ids
        "\0" + e.issuer.uniqueId
      )
    ])
  ), e.subject.uniqueId && r.value.push(
    V.create(V.Class.CONTEXT_SPECIFIC, 2, !0, [
      V.create(
        V.Class.UNIVERSAL,
        V.Type.BITSTRING,
        !1,
        // TODO: support arbitrary bit length ids
        "\0" + e.subject.uniqueId
      )
    ])
  ), e.extensions.length > 0 && r.value.push(we.certificateExtensionsToAsn1(e.extensions)), r;
};
we.getCertificationRequestInfo = function(e) {
  var t = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
    // version
    V.create(
      V.Class.UNIVERSAL,
      V.Type.INTEGER,
      !1,
      V.integerToDer(e.version).getBytes()
    ),
    // subject
    La(e.subject),
    // SubjectPublicKeyInfo
    we.publicKeyToAsn1(e.publicKey),
    // attributes
    gI(e)
  ]);
  return t;
};
we.distinguishedNameToAsn1 = function(e) {
  return La(e);
};
we.certificateToAsn1 = function(e) {
  var t = e.tbsCertificate || we.getTBSCertificate(e);
  return V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
    // TBSCertificate
    t,
    // AlgorithmIdentifier (signature algorithm)
    V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
      // algorithm
      V.create(
        V.Class.UNIVERSAL,
        V.Type.OID,
        !1,
        V.oidToDer(e.signatureOid).getBytes()
      ),
      // parameters
      Kh(e.signatureOid, e.signatureParameters)
    ]),
    // SignatureValue
    V.create(
      V.Class.UNIVERSAL,
      V.Type.BITSTRING,
      !1,
      "\0" + e.signature
    )
  ]);
};
we.certificateExtensionsToAsn1 = function(e) {
  var t = V.create(V.Class.CONTEXT_SPECIFIC, 3, !0, []), o = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, []);
  t.value.push(o);
  for (var r = 0; r < e.length; ++r)
    o.value.push(we.certificateExtensionToAsn1(e[r]));
  return t;
};
we.certificateExtensionToAsn1 = function(e) {
  var t = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, []);
  t.value.push(V.create(
    V.Class.UNIVERSAL,
    V.Type.OID,
    !1,
    V.oidToDer(e.id).getBytes()
  )), e.critical && t.value.push(V.create(
    V.Class.UNIVERSAL,
    V.Type.BOOLEAN,
    !1,
    "ÿ"
  ));
  var o = e.value;
  return typeof e.value != "string" && (o = V.toDer(o).getBytes()), t.value.push(V.create(
    V.Class.UNIVERSAL,
    V.Type.OCTETSTRING,
    !1,
    o
  )), t;
};
we.certificationRequestToAsn1 = function(e) {
  var t = e.certificationRequestInfo || we.getCertificationRequestInfo(e);
  return V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
    // CertificationRequestInfo
    t,
    // AlgorithmIdentifier (signature algorithm)
    V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
      // algorithm
      V.create(
        V.Class.UNIVERSAL,
        V.Type.OID,
        !1,
        V.oidToDer(e.signatureOid).getBytes()
      ),
      // parameters
      Kh(e.signatureOid, e.signatureParameters)
    ]),
    // signature
    V.create(
      V.Class.UNIVERSAL,
      V.Type.BITSTRING,
      !1,
      "\0" + e.signature
    )
  ]);
};
we.createCaStore = function(e) {
  var t = {
    // stored certificates
    certs: {}
  };
  t.getIssuer = function(p) {
    var d = o(p.issuer);
    return d;
  }, t.addCertificate = function(p) {
    if (typeof p == "string" && (p = Ge.pki.certificateFromPem(p)), r(p.subject), !t.hasCertificate(p))
      if (p.subject.hash in t.certs) {
        var d = t.certs[p.subject.hash];
        Ge.util.isArray(d) || (d = [d]), d.push(p), t.certs[p.subject.hash] = d;
      } else
        t.certs[p.subject.hash] = p;
  }, t.hasCertificate = function(p) {
    typeof p == "string" && (p = Ge.pki.certificateFromPem(p));
    var d = o(p.subject);
    if (!d)
      return !1;
    Ge.util.isArray(d) || (d = [d]);
    for (var b = V.toDer(we.certificateToAsn1(p)).getBytes(), g = 0; g < d.length; ++g) {
      var w = V.toDer(we.certificateToAsn1(d[g])).getBytes();
      if (b === w)
        return !0;
    }
    return !1;
  }, t.listAllCertificates = function() {
    var p = [];
    for (var d in t.certs)
      if (t.certs.hasOwnProperty(d)) {
        var b = t.certs[d];
        if (!Ge.util.isArray(b))
          p.push(b);
        else
          for (var g = 0; g < b.length; ++g)
            p.push(b[g]);
      }
    return p;
  }, t.removeCertificate = function(p) {
    var d;
    if (typeof p == "string" && (p = Ge.pki.certificateFromPem(p)), r(p.subject), !t.hasCertificate(p))
      return null;
    var b = o(p.subject);
    if (!Ge.util.isArray(b))
      return d = t.certs[p.subject.hash], delete t.certs[p.subject.hash], d;
    for (var g = V.toDer(we.certificateToAsn1(p)).getBytes(), w = 0; w < b.length; ++w) {
      var C = V.toDer(we.certificateToAsn1(b[w])).getBytes();
      g === C && (d = b[w], b.splice(w, 1));
    }
    return b.length === 0 && delete t.certs[p.subject.hash], d;
  };
  function o(p) {
    return r(p), t.certs[p.hash] || null;
  }
  function r(p) {
    if (!p.hash) {
      var d = Ge.md.sha1.create();
      p.attributes = we.RDNAttributesAsArray(La(p), d), p.hash = d.digest().toHex();
    }
  }
  if (e)
    for (var h = 0; h < e.length; ++h) {
      var a = e[h];
      t.addCertificate(a);
    }
  return t;
};
we.certificateError = {
  bad_certificate: "forge.pki.BadCertificate",
  unsupported_certificate: "forge.pki.UnsupportedCertificate",
  certificate_revoked: "forge.pki.CertificateRevoked",
  certificate_expired: "forge.pki.CertificateExpired",
  certificate_unknown: "forge.pki.CertificateUnknown",
  unknown_ca: "forge.pki.UnknownCertificateAuthority"
};
we.verifyCertificateChain = function(e, t, o) {
  typeof o == "function" && (o = { verify: o }), o = o || {}, t = t.slice(0);
  var r = t.slice(0), h = o.validityCheckDate;
  typeof h > "u" && (h = /* @__PURE__ */ new Date());
  var a = !0, p = null, d = 0;
  do {
    var b = t.shift(), g = null, w = !1;
    if (h && (h < b.validity.notBefore || h > b.validity.notAfter) && (p = {
      message: "Certificate is not valid yet or has expired.",
      error: we.certificateError.certificate_expired,
      notBefore: b.validity.notBefore,
      notAfter: b.validity.notAfter,
      // TODO: we might want to reconsider renaming 'now' to
      // 'validityCheckDate' should this API be changed in the future.
      now: h
    }), p === null) {
      if (g = t[0] || e.getIssuer(b), g === null && b.isIssuer(b) && (w = !0, g = b), g) {
        var C = g;
        Ge.util.isArray(C) || (C = [C]);
        for (var T = !1; !T && C.length > 0; ) {
          g = C.shift();
          try {
            T = g.verify(b);
          } catch {
          }
        }
        T || (p = {
          message: "Certificate signature is invalid.",
          error: we.certificateError.bad_certificate
        });
      }
      p === null && (!g || w) && !e.hasCertificate(b) && (p = {
        message: "Certificate is not trusted.",
        error: we.certificateError.unknown_ca
      });
    }
    if (p === null && g && !b.isIssuer(g) && (p = {
      message: "Certificate issuer is invalid.",
      error: we.certificateError.bad_certificate
    }), p === null)
      for (var k = {
        keyUsage: !0,
        basicConstraints: !0
      }, q = 0; p === null && q < b.extensions.length; ++q) {
        var O = b.extensions[q];
        O.critical && !(O.name in k) && (p = {
          message: "Certificate has an unsupported critical extension.",
          error: we.certificateError.unsupported_certificate
        });
      }
    if (p === null && (!a || t.length === 0 && (!g || w))) {
      var N = b.getExtension("basicConstraints"), j = b.getExtension("keyUsage");
      if (j !== null && (!j.keyCertSign || N === null) && (p = {
        message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
        error: we.certificateError.bad_certificate
      }), p === null && N !== null && !N.cA && (p = {
        message: "Certificate basicConstraints indicates the certificate is not a CA.",
        error: we.certificateError.bad_certificate
      }), p === null && j !== null && "pathLenConstraint" in N) {
        var U = d - 1;
        U > N.pathLenConstraint && (p = {
          message: "Certificate basicConstraints pathLenConstraint violated.",
          error: we.certificateError.bad_certificate
        });
      }
    }
    var H = p === null ? !0 : p.error, z = o.verify ? o.verify(H, d, r) : H;
    if (z === !0)
      p = null;
    else
      throw H === !0 && (p = {
        message: "The application rejected the certificate.",
        error: we.certificateError.bad_certificate
      }), (z || z === 0) && (typeof z == "object" && !Ge.util.isArray(z) ? (z.message && (p.message = z.message), z.error && (p.error = z.error)) : typeof z == "string" && (p.error = z)), p;
    a = !1, ++d;
  } while (t.length > 0);
  return !0;
};
var Pt = ht, te = Pt.asn1, lt = Pt.pki, T0 = Pt.pkcs12 = Pt.pkcs12 || {}, q2 = {
  name: "ContentInfo",
  tagClass: te.Class.UNIVERSAL,
  type: te.Type.SEQUENCE,
  // a ContentInfo
  constructed: !0,
  value: [{
    name: "ContentInfo.contentType",
    tagClass: te.Class.UNIVERSAL,
    type: te.Type.OID,
    constructed: !1,
    capture: "contentType"
  }, {
    name: "ContentInfo.content",
    tagClass: te.Class.CONTEXT_SPECIFIC,
    constructed: !0,
    captureAsn1: "content"
  }]
}, xI = {
  name: "PFX",
  tagClass: te.Class.UNIVERSAL,
  type: te.Type.SEQUENCE,
  constructed: !0,
  value: [
    {
      name: "PFX.version",
      tagClass: te.Class.UNIVERSAL,
      type: te.Type.INTEGER,
      constructed: !1,
      capture: "version"
    },
    q2,
    {
      name: "PFX.macData",
      tagClass: te.Class.UNIVERSAL,
      type: te.Type.SEQUENCE,
      constructed: !0,
      optional: !0,
      captureAsn1: "mac",
      value: [{
        name: "PFX.macData.mac",
        tagClass: te.Class.UNIVERSAL,
        type: te.Type.SEQUENCE,
        // DigestInfo
        constructed: !0,
        value: [{
          name: "PFX.macData.mac.digestAlgorithm",
          tagClass: te.Class.UNIVERSAL,
          type: te.Type.SEQUENCE,
          // DigestAlgorithmIdentifier
          constructed: !0,
          value: [{
            name: "PFX.macData.mac.digestAlgorithm.algorithm",
            tagClass: te.Class.UNIVERSAL,
            type: te.Type.OID,
            constructed: !1,
            capture: "macAlgorithm"
          }, {
            name: "PFX.macData.mac.digestAlgorithm.parameters",
            tagClass: te.Class.UNIVERSAL,
            captureAsn1: "macAlgorithmParameters"
          }]
        }, {
          name: "PFX.macData.mac.digest",
          tagClass: te.Class.UNIVERSAL,
          type: te.Type.OCTETSTRING,
          constructed: !1,
          capture: "macDigest"
        }]
      }, {
        name: "PFX.macData.macSalt",
        tagClass: te.Class.UNIVERSAL,
        type: te.Type.OCTETSTRING,
        constructed: !1,
        capture: "macSalt"
      }, {
        name: "PFX.macData.iterations",
        tagClass: te.Class.UNIVERSAL,
        type: te.Type.INTEGER,
        constructed: !1,
        optional: !0,
        capture: "macIterations"
      }]
    }
  ]
}, _I = {
  name: "SafeBag",
  tagClass: te.Class.UNIVERSAL,
  type: te.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "SafeBag.bagId",
    tagClass: te.Class.UNIVERSAL,
    type: te.Type.OID,
    constructed: !1,
    capture: "bagId"
  }, {
    name: "SafeBag.bagValue",
    tagClass: te.Class.CONTEXT_SPECIFIC,
    constructed: !0,
    captureAsn1: "bagValue"
  }, {
    name: "SafeBag.bagAttributes",
    tagClass: te.Class.UNIVERSAL,
    type: te.Type.SET,
    constructed: !0,
    optional: !0,
    capture: "bagAttributes"
  }]
}, EI = {
  name: "Attribute",
  tagClass: te.Class.UNIVERSAL,
  type: te.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "Attribute.attrId",
    tagClass: te.Class.UNIVERSAL,
    type: te.Type.OID,
    constructed: !1,
    capture: "oid"
  }, {
    name: "Attribute.attrValues",
    tagClass: te.Class.UNIVERSAL,
    type: te.Type.SET,
    constructed: !0,
    capture: "values"
  }]
}, SI = {
  name: "CertBag",
  tagClass: te.Class.UNIVERSAL,
  type: te.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "CertBag.certId",
    tagClass: te.Class.UNIVERSAL,
    type: te.Type.OID,
    constructed: !1,
    capture: "certId"
  }, {
    name: "CertBag.certValue",
    tagClass: te.Class.CONTEXT_SPECIFIC,
    constructed: !0,
    /* So far we only support X.509 certificates (which are wrapped in
       an OCTET STRING, hence hard code that here). */
    value: [{
      name: "CertBag.certValue[0]",
      tagClass: te.Class.UNIVERSAL,
      type: te.Class.OCTETSTRING,
      constructed: !1,
      capture: "cert"
    }]
  }]
};
function l0(e, t, o, r) {
  for (var h = [], a = 0; a < e.length; a++)
    for (var p = 0; p < e[a].safeBags.length; p++) {
      var d = e[a].safeBags[p];
      if (!(r !== void 0 && d.type !== r)) {
        if (t === null) {
          h.push(d);
          continue;
        }
        d.attributes[t] !== void 0 && d.attributes[t].indexOf(o) >= 0 && h.push(d);
      }
    }
  return h;
}
T0.pkcs12FromAsn1 = function(e, t, o) {
  typeof t == "string" ? (o = t, t = !0) : t === void 0 && (t = !0);
  var r = {}, h = [];
  if (!te.validate(e, xI, r, h)) {
    var a = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
    throw a.errors = a, a;
  }
  var p = {
    version: r.version.charCodeAt(0),
    safeContents: [],
    /**
     * Gets bags with matching attributes.
     *
     * @param filter the attributes to filter by:
     *          [localKeyId] the localKeyId to search for.
     *          [localKeyIdHex] the localKeyId in hex to search for.
     *          [friendlyName] the friendly name to search for.
     *          [bagType] bag type to narrow each attribute search by.
     *
     * @return a map of attribute type to an array of matching bags or, if no
     *           attribute was given but a bag type, the map key will be the
     *           bag type.
     */
    getBags: function(N) {
      var j = {}, U;
      return "localKeyId" in N ? U = N.localKeyId : "localKeyIdHex" in N && (U = Pt.util.hexToBytes(N.localKeyIdHex)), U === void 0 && !("friendlyName" in N) && "bagType" in N && (j[N.bagType] = l0(
        p.safeContents,
        null,
        null,
        N.bagType
      )), U !== void 0 && (j.localKeyId = l0(
        p.safeContents,
        "localKeyId",
        U,
        N.bagType
      )), "friendlyName" in N && (j.friendlyName = l0(
        p.safeContents,
        "friendlyName",
        N.friendlyName,
        N.bagType
      )), j;
    },
    /**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching friendlyName attribute.
     *
     * @param friendlyName the friendly name to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching friendlyName attribute.
     */
    getBagsByFriendlyName: function(N, j) {
      return l0(
        p.safeContents,
        "friendlyName",
        N,
        j
      );
    },
    /**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching localKeyId attribute.
     *
     * @param localKeyId the localKeyId to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching localKeyId attribute.
     */
    getBagsByLocalKeyId: function(N, j) {
      return l0(
        p.safeContents,
        "localKeyId",
        N,
        j
      );
    }
  };
  if (r.version.charCodeAt(0) !== 3) {
    var a = new Error("PKCS#12 PFX of version other than 3 not supported.");
    throw a.version = r.version.charCodeAt(0), a;
  }
  if (te.derToOid(r.contentType) !== lt.oids.data) {
    var a = new Error("Only PKCS#12 PFX in password integrity mode supported.");
    throw a.oid = te.derToOid(r.contentType), a;
  }
  var d = r.content.value[0];
  if (d.tagClass !== te.Class.UNIVERSAL || d.type !== te.Type.OCTETSTRING)
    throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
  if (d = $h(d), r.mac) {
    var b = null, g = 0, w = te.derToOid(r.macAlgorithm);
    switch (w) {
      case lt.oids.sha1:
        b = Pt.md.sha1.create(), g = 20;
        break;
      case lt.oids.sha256:
        b = Pt.md.sha256.create(), g = 32;
        break;
      case lt.oids.sha384:
        b = Pt.md.sha384.create(), g = 48;
        break;
      case lt.oids.sha512:
        b = Pt.md.sha512.create(), g = 64;
        break;
      case lt.oids.md5:
        b = Pt.md.md5.create(), g = 16;
        break;
    }
    if (b === null)
      throw new Error("PKCS#12 uses unsupported MAC algorithm: " + w);
    var C = new Pt.util.ByteBuffer(r.macSalt), T = "macIterations" in r ? parseInt(Pt.util.bytesToHex(r.macIterations), 16) : 1, k = T0.generateKey(
      o,
      C,
      3,
      T,
      g,
      b
    ), q = Pt.hmac.create();
    q.start(b, k), q.update(d.value);
    var O = q.getMac();
    if (O.getBytes() !== r.macDigest)
      throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
  }
  return wI(p, d.value, t, o), p;
};
function $h(e) {
  if (e.composed || e.constructed) {
    for (var t = Pt.util.createBuffer(), o = 0; o < e.value.length; ++o)
      t.putBytes(e.value[o].value);
    e.composed = e.constructed = !1, e.value = t.getBytes();
  }
  return e;
}
function wI(e, t, o, r) {
  if (t = te.fromDer(t, o), t.tagClass !== te.Class.UNIVERSAL || t.type !== te.Type.SEQUENCE || t.constructed !== !0)
    throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
  for (var h = 0; h < t.value.length; h++) {
    var a = t.value[h], p = {}, d = [];
    if (!te.validate(a, q2, p, d)) {
      var b = new Error("Cannot read ContentInfo.");
      throw b.errors = d, b;
    }
    var g = {
      encrypted: !1
    }, w = null, C = p.content.value[0];
    switch (te.derToOid(p.contentType)) {
      case lt.oids.data:
        if (C.tagClass !== te.Class.UNIVERSAL || C.type !== te.Type.OCTETSTRING)
          throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
        w = $h(C).value;
        break;
      case lt.oids.encryptedData:
        w = CI(C, r), g.encrypted = !0;
        break;
      default:
        var b = new Error("Unsupported PKCS#12 contentType.");
        throw b.contentType = te.derToOid(p.contentType), b;
    }
    g.safeBags = AI(w, o, r), e.safeContents.push(g);
  }
}
function CI(e, t) {
  var o = {}, r = [];
  if (!te.validate(
    e,
    Pt.pkcs7.asn1.encryptedDataValidator,
    o,
    r
  )) {
    var h = new Error("Cannot read EncryptedContentInfo.");
    throw h.errors = r, h;
  }
  var a = te.derToOid(o.contentType);
  if (a !== lt.oids.data) {
    var h = new Error(
      "PKCS#12 EncryptedContentInfo ContentType is not Data."
    );
    throw h.oid = a, h;
  }
  a = te.derToOid(o.encAlgorithm);
  var p = lt.pbe.getCipher(a, o.encParameter, t), d = $h(o.encryptedContentAsn1), b = Pt.util.createBuffer(d.value);
  if (p.update(b), !p.finish())
    throw new Error("Failed to decrypt PKCS#12 SafeContents.");
  return p.output.getBytes();
}
function AI(e, t, o) {
  if (!t && e.length === 0)
    return [];
  if (e = te.fromDer(e, t), e.tagClass !== te.Class.UNIVERSAL || e.type !== te.Type.SEQUENCE || e.constructed !== !0)
    throw new Error(
      "PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag."
    );
  for (var r = [], h = 0; h < e.value.length; h++) {
    var a = e.value[h], p = {}, d = [];
    if (!te.validate(a, _I, p, d)) {
      var b = new Error("Cannot read SafeBag.");
      throw b.errors = d, b;
    }
    var g = {
      type: te.derToOid(p.bagId),
      attributes: BI(p.bagAttributes)
    };
    r.push(g);
    var w, C, T = p.bagValue.value[0];
    switch (g.type) {
      case lt.oids.pkcs8ShroudedKeyBag:
        if (T = lt.decryptPrivateKeyInfo(T, o), T === null)
          throw new Error(
            "Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?"
          );
      case lt.oids.keyBag:
        try {
          g.key = lt.privateKeyFromAsn1(T);
        } catch {
          g.key = null, g.asn1 = T;
        }
        continue;
      case lt.oids.certBag:
        w = SI, C = function() {
          if (te.derToOid(p.certId) !== lt.oids.x509Certificate) {
            var q = new Error(
              "Unsupported certificate type, only X.509 supported."
            );
            throw q.oid = te.derToOid(p.certId), q;
          }
          var O = te.fromDer(p.cert, t);
          try {
            g.cert = lt.certificateFromAsn1(O, !0);
          } catch {
            g.cert = null, g.asn1 = O;
          }
        };
        break;
      default:
        var b = new Error("Unsupported PKCS#12 SafeBag type.");
        throw b.oid = g.type, b;
    }
    if (w !== void 0 && !te.validate(T, w, p, d)) {
      var b = new Error("Cannot read PKCS#12 " + w.name);
      throw b.errors = d, b;
    }
    C();
  }
  return r;
}
function BI(e) {
  var t = {};
  if (e !== void 0)
    for (var o = 0; o < e.length; ++o) {
      var r = {}, h = [];
      if (!te.validate(e[o], EI, r, h)) {
        var a = new Error("Cannot read PKCS#12 BagAttribute.");
        throw a.errors = h, a;
      }
      var p = te.derToOid(r.oid);
      if (lt.oids[p] !== void 0) {
        t[lt.oids[p]] = [];
        for (var d = 0; d < r.values.length; ++d)
          t[lt.oids[p]].push(r.values[d].value);
      }
    }
  return t;
}
T0.toPkcs12Asn1 = function(e, t, o, r) {
  r = r || {}, r.saltSize = r.saltSize || 8, r.count = r.count || 2048, r.algorithm = r.algorithm || r.encAlgorithm || "aes128", "useMac" in r || (r.useMac = !0), "localKeyId" in r || (r.localKeyId = null), "generateLocalKeyId" in r || (r.generateLocalKeyId = !0);
  var h = r.localKeyId, a;
  if (h !== null)
    h = Pt.util.hexToBytes(h);
  else if (r.generateLocalKeyId)
    if (t) {
      var p = Pt.util.isArray(t) ? t[0] : t;
      typeof p == "string" && (p = lt.certificateFromPem(p));
      var d = Pt.md.sha1.create();
      d.update(te.toDer(lt.certificateToAsn1(p)).getBytes()), h = d.digest().getBytes();
    } else
      h = Pt.random.getBytes(20);
  var b = [];
  h !== null && b.push(
    // localKeyID
    te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
      // attrId
      te.create(
        te.Class.UNIVERSAL,
        te.Type.OID,
        !1,
        te.oidToDer(lt.oids.localKeyId).getBytes()
      ),
      // attrValues
      te.create(te.Class.UNIVERSAL, te.Type.SET, !0, [
        te.create(
          te.Class.UNIVERSAL,
          te.Type.OCTETSTRING,
          !1,
          h
        )
      ])
    ])
  ), "friendlyName" in r && b.push(
    // friendlyName
    te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
      // attrId
      te.create(
        te.Class.UNIVERSAL,
        te.Type.OID,
        !1,
        te.oidToDer(lt.oids.friendlyName).getBytes()
      ),
      // attrValues
      te.create(te.Class.UNIVERSAL, te.Type.SET, !0, [
        te.create(
          te.Class.UNIVERSAL,
          te.Type.BMPSTRING,
          !1,
          r.friendlyName
        )
      ])
    ])
  ), b.length > 0 && (a = te.create(te.Class.UNIVERSAL, te.Type.SET, !0, b));
  var g = [], w = [];
  t !== null && (Pt.util.isArray(t) ? w = t : w = [t]);
  for (var C = [], T = 0; T < w.length; ++T) {
    t = w[T], typeof t == "string" && (t = lt.certificateFromPem(t));
    var k = T === 0 ? a : void 0, q = lt.certificateToAsn1(t), O = te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
      // bagId
      te.create(
        te.Class.UNIVERSAL,
        te.Type.OID,
        !1,
        te.oidToDer(lt.oids.certBag).getBytes()
      ),
      // bagValue
      te.create(te.Class.CONTEXT_SPECIFIC, 0, !0, [
        // CertBag
        te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
          // certId
          te.create(
            te.Class.UNIVERSAL,
            te.Type.OID,
            !1,
            te.oidToDer(lt.oids.x509Certificate).getBytes()
          ),
          // certValue (x509Certificate)
          te.create(te.Class.CONTEXT_SPECIFIC, 0, !0, [
            te.create(
              te.Class.UNIVERSAL,
              te.Type.OCTETSTRING,
              !1,
              te.toDer(q).getBytes()
            )
          ])
        ])
      ]),
      // bagAttributes (OPTIONAL)
      k
    ]);
    C.push(O);
  }
  if (C.length > 0) {
    var N = te.create(
      te.Class.UNIVERSAL,
      te.Type.SEQUENCE,
      !0,
      C
    ), j = (
      // PKCS#7 ContentInfo
      te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
        // contentType
        te.create(
          te.Class.UNIVERSAL,
          te.Type.OID,
          !1,
          // OID for the content type is 'data'
          te.oidToDer(lt.oids.data).getBytes()
        ),
        // content
        te.create(te.Class.CONTEXT_SPECIFIC, 0, !0, [
          te.create(
            te.Class.UNIVERSAL,
            te.Type.OCTETSTRING,
            !1,
            te.toDer(N).getBytes()
          )
        ])
      ])
    );
    g.push(j);
  }
  var U = null;
  if (e !== null) {
    var H = lt.wrapRsaPrivateKey(lt.privateKeyToAsn1(e));
    o === null ? U = te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
      // bagId
      te.create(
        te.Class.UNIVERSAL,
        te.Type.OID,
        !1,
        te.oidToDer(lt.oids.keyBag).getBytes()
      ),
      // bagValue
      te.create(te.Class.CONTEXT_SPECIFIC, 0, !0, [
        // PrivateKeyInfo
        H
      ]),
      // bagAttributes (OPTIONAL)
      a
    ]) : U = te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
      // bagId
      te.create(
        te.Class.UNIVERSAL,
        te.Type.OID,
        !1,
        te.oidToDer(lt.oids.pkcs8ShroudedKeyBag).getBytes()
      ),
      // bagValue
      te.create(te.Class.CONTEXT_SPECIFIC, 0, !0, [
        // EncryptedPrivateKeyInfo
        lt.encryptPrivateKeyInfo(H, o, r)
      ]),
      // bagAttributes (OPTIONAL)
      a
    ]);
    var z = te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [U]), ee = (
      // PKCS#7 ContentInfo
      te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
        // contentType
        te.create(
          te.Class.UNIVERSAL,
          te.Type.OID,
          !1,
          // OID for the content type is 'data'
          te.oidToDer(lt.oids.data).getBytes()
        ),
        // content
        te.create(te.Class.CONTEXT_SPECIFIC, 0, !0, [
          te.create(
            te.Class.UNIVERSAL,
            te.Type.OCTETSTRING,
            !1,
            te.toDer(z).getBytes()
          )
        ])
      ])
    );
    g.push(ee);
  }
  var ne = te.create(
    te.Class.UNIVERSAL,
    te.Type.SEQUENCE,
    !0,
    g
  ), le;
  if (r.useMac) {
    var d = Pt.md.sha1.create(), Z = new Pt.util.ByteBuffer(
      Pt.random.getBytes(r.saltSize)
    ), ie = r.count, e = T0.generateKey(o, Z, 3, ie, 20), fe = Pt.hmac.create();
    fe.start(d, e), fe.update(te.toDer(ne).getBytes());
    var I = fe.getMac();
    le = te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
      // mac DigestInfo
      te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
        // digestAlgorithm
        te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
          // algorithm = SHA-1
          te.create(
            te.Class.UNIVERSAL,
            te.Type.OID,
            !1,
            te.oidToDer(lt.oids.sha1).getBytes()
          ),
          // parameters = Null
          te.create(te.Class.UNIVERSAL, te.Type.NULL, !1, "")
        ]),
        // digest
        te.create(
          te.Class.UNIVERSAL,
          te.Type.OCTETSTRING,
          !1,
          I.getBytes()
        )
      ]),
      // macSalt OCTET STRING
      te.create(
        te.Class.UNIVERSAL,
        te.Type.OCTETSTRING,
        !1,
        Z.getBytes()
      ),
      // iterations INTEGER (XXX: Only support count < 65536)
      te.create(
        te.Class.UNIVERSAL,
        te.Type.INTEGER,
        !1,
        te.integerToDer(ie).getBytes()
      )
    ]);
  }
  return te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
    // version (3)
    te.create(
      te.Class.UNIVERSAL,
      te.Type.INTEGER,
      !1,
      te.integerToDer(3).getBytes()
    ),
    // PKCS#7 ContentInfo
    te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
      // contentType
      te.create(
        te.Class.UNIVERSAL,
        te.Type.OID,
        !1,
        // OID for the content type is 'data'
        te.oidToDer(lt.oids.data).getBytes()
      ),
      // content
      te.create(te.Class.CONTEXT_SPECIFIC, 0, !0, [
        te.create(
          te.Class.UNIVERSAL,
          te.Type.OCTETSTRING,
          !1,
          te.toDer(ne).getBytes()
        )
      ])
    ]),
    le
  ]);
};
T0.generateKey = Pt.pbe.generatePkcs12Key;
var In = ht, Hh = In.asn1, ka = In.pki = In.pki || {};
ka.pemToDer = function(e) {
  var t = In.pem.decode(e)[0];
  if (t.procType && t.procType.type === "ENCRYPTED")
    throw new Error("Could not convert PEM to DER; PEM is encrypted.");
  return In.util.createBuffer(t.body);
};
ka.privateKeyFromPem = function(e) {
  var t = In.pem.decode(e)[0];
  if (t.type !== "PRIVATE KEY" && t.type !== "RSA PRIVATE KEY") {
    var o = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
    throw o.headerType = t.type, o;
  }
  if (t.procType && t.procType.type === "ENCRYPTED")
    throw new Error("Could not convert private key from PEM; PEM is encrypted.");
  var r = Hh.fromDer(t.body);
  return ka.privateKeyFromAsn1(r);
};
ka.privateKeyToPem = function(e, t) {
  var o = {
    type: "RSA PRIVATE KEY",
    body: Hh.toDer(ka.privateKeyToAsn1(e)).getBytes()
  };
  return In.pem.encode(o, { maxline: t });
};
ka.privateKeyInfoToPem = function(e, t) {
  var o = {
    type: "PRIVATE KEY",
    body: Hh.toDer(e).getBytes()
  };
  return In.pem.encode(o, { maxline: t });
};
var xe = ht, Kf = function(e, t, o, r) {
  var h = xe.util.createBuffer(), a = e.length >> 1, p = a + (e.length & 1), d = e.substr(0, p), b = e.substr(a, p), g = xe.util.createBuffer(), w = xe.hmac.create();
  o = t + o;
  var C = Math.ceil(r / 16), T = Math.ceil(r / 20);
  w.start("MD5", d);
  var k = xe.util.createBuffer();
  g.putBytes(o);
  for (var q = 0; q < C; ++q)
    w.start(null, null), w.update(g.getBytes()), g.putBuffer(w.digest()), w.start(null, null), w.update(g.bytes() + o), k.putBuffer(w.digest());
  w.start("SHA1", b);
  var O = xe.util.createBuffer();
  g.clear(), g.putBytes(o);
  for (var q = 0; q < T; ++q)
    w.start(null, null), w.update(g.getBytes()), g.putBuffer(w.digest()), w.start(null, null), w.update(g.bytes() + o), O.putBuffer(w.digest());
  return h.putBytes(xe.util.xorBytes(
    k.getBytes(),
    O.getBytes(),
    r
  )), h;
}, II = function(e, t, o) {
  var r = xe.hmac.create();
  r.start("SHA1", e);
  var h = xe.util.createBuffer();
  return h.putInt32(t[0]), h.putInt32(t[1]), h.putByte(o.type), h.putByte(o.version.major), h.putByte(o.version.minor), h.putInt16(o.length), h.putBytes(o.fragment.bytes()), r.update(h.getBytes()), r.digest().getBytes();
}, TI = function(e, t, o) {
  var r = !1;
  try {
    var h = e.deflate(t.fragment.getBytes());
    t.fragment = xe.util.createBuffer(h), t.length = h.length, r = !0;
  } catch {
  }
  return r;
}, MI = function(e, t, o) {
  var r = !1;
  try {
    var h = e.inflate(t.fragment.getBytes());
    t.fragment = xe.util.createBuffer(h), t.length = h.length, r = !0;
  } catch {
  }
  return r;
}, Rr = function(e, t) {
  var o = 0;
  switch (t) {
    case 1:
      o = e.getByte();
      break;
    case 2:
      o = e.getInt16();
      break;
    case 3:
      o = e.getInt24();
      break;
    case 4:
      o = e.getInt32();
      break;
  }
  return xe.util.createBuffer(e.getBytes(o));
}, Fr = function(e, t, o) {
  e.putInt(o.length(), t << 3), e.putBuffer(o);
}, G = {};
G.Versions = {
  TLS_1_0: { major: 3, minor: 1 },
  TLS_1_1: { major: 3, minor: 2 },
  TLS_1_2: { major: 3, minor: 3 }
};
G.SupportedVersions = [
  G.Versions.TLS_1_1,
  G.Versions.TLS_1_0
];
G.Version = G.SupportedVersions[0];
G.MaxFragment = 15360;
G.ConnectionEnd = {
  server: 0,
  client: 1
};
G.PRFAlgorithm = {
  tls_prf_sha256: 0
};
G.BulkCipherAlgorithm = {
  none: null,
  rc4: 0,
  des3: 1,
  aes: 2
};
G.CipherType = {
  stream: 0,
  block: 1,
  aead: 2
};
G.MACAlgorithm = {
  none: null,
  hmac_md5: 0,
  hmac_sha1: 1,
  hmac_sha256: 2,
  hmac_sha384: 3,
  hmac_sha512: 4
};
G.CompressionMethod = {
  none: 0,
  deflate: 1
};
G.ContentType = {
  change_cipher_spec: 20,
  alert: 21,
  handshake: 22,
  application_data: 23,
  heartbeat: 24
};
G.HandshakeType = {
  hello_request: 0,
  client_hello: 1,
  server_hello: 2,
  certificate: 11,
  server_key_exchange: 12,
  certificate_request: 13,
  server_hello_done: 14,
  certificate_verify: 15,
  client_key_exchange: 16,
  finished: 20
};
G.Alert = {};
G.Alert.Level = {
  warning: 1,
  fatal: 2
};
G.Alert.Description = {
  close_notify: 0,
  unexpected_message: 10,
  bad_record_mac: 20,
  decryption_failed: 21,
  record_overflow: 22,
  decompression_failure: 30,
  handshake_failure: 40,
  bad_certificate: 42,
  unsupported_certificate: 43,
  certificate_revoked: 44,
  certificate_expired: 45,
  certificate_unknown: 46,
  illegal_parameter: 47,
  unknown_ca: 48,
  access_denied: 49,
  decode_error: 50,
  decrypt_error: 51,
  export_restriction: 60,
  protocol_version: 70,
  insufficient_security: 71,
  internal_error: 80,
  user_canceled: 90,
  no_renegotiation: 100
};
G.HeartbeatMessageType = {
  heartbeat_request: 1,
  heartbeat_response: 2
};
G.CipherSuites = {};
G.getCipherSuite = function(e) {
  var t = null;
  for (var o in G.CipherSuites) {
    var r = G.CipherSuites[o];
    if (r.id[0] === e.charCodeAt(0) && r.id[1] === e.charCodeAt(1)) {
      t = r;
      break;
    }
  }
  return t;
};
G.handleUnexpected = function(e, t) {
  var o = !e.open && e.entity === G.ConnectionEnd.client;
  o || e.error(e, {
    message: "Unexpected message. Received TLS record out of order.",
    send: !0,
    alert: {
      level: G.Alert.Level.fatal,
      description: G.Alert.Description.unexpected_message
    }
  });
};
G.handleHelloRequest = function(e, t, o) {
  !e.handshaking && e.handshakes > 0 && (G.queue(e, G.createAlert(e, {
    level: G.Alert.Level.warning,
    description: G.Alert.Description.no_renegotiation
  })), G.flush(e)), e.process();
};
G.parseHelloMessage = function(e, t, o) {
  var r = null, h = e.entity === G.ConnectionEnd.client;
  if (o < 38)
    e.error(e, {
      message: h ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.illegal_parameter
      }
    });
  else {
    var a = t.fragment, p = a.length();
    if (r = {
      version: {
        major: a.getByte(),
        minor: a.getByte()
      },
      random: xe.util.createBuffer(a.getBytes(32)),
      session_id: Rr(a, 1),
      extensions: []
    }, h ? (r.cipher_suite = a.getBytes(2), r.compression_method = a.getByte()) : (r.cipher_suites = Rr(a, 2), r.compression_methods = Rr(a, 1)), p = o - (p - a.length()), p > 0) {
      for (var d = Rr(a, 2); d.length() > 0; )
        r.extensions.push({
          type: [d.getByte(), d.getByte()],
          data: Rr(d, 2)
        });
      if (!h)
        for (var b = 0; b < r.extensions.length; ++b) {
          var g = r.extensions[b];
          if (g.type[0] === 0 && g.type[1] === 0)
            for (var w = Rr(g.data, 2); w.length() > 0; ) {
              var C = w.getByte();
              if (C !== 0)
                break;
              e.session.extensions.server_name.serverNameList.push(
                Rr(w, 2).getBytes()
              );
            }
        }
    }
    if (e.session.version && (r.version.major !== e.session.version.major || r.version.minor !== e.session.version.minor))
      return e.error(e, {
        message: "TLS version change is disallowed during renegotiation.",
        send: !0,
        alert: {
          level: G.Alert.Level.fatal,
          description: G.Alert.Description.protocol_version
        }
      });
    if (h)
      e.session.cipherSuite = G.getCipherSuite(r.cipher_suite);
    else
      for (var T = xe.util.createBuffer(r.cipher_suites.bytes()); T.length() > 0 && (e.session.cipherSuite = G.getCipherSuite(T.getBytes(2)), e.session.cipherSuite === null); )
        ;
    if (e.session.cipherSuite === null)
      return e.error(e, {
        message: "No cipher suites in common.",
        send: !0,
        alert: {
          level: G.Alert.Level.fatal,
          description: G.Alert.Description.handshake_failure
        },
        cipherSuite: xe.util.bytesToHex(r.cipher_suite)
      });
    h ? e.session.compressionMethod = r.compression_method : e.session.compressionMethod = G.CompressionMethod.none;
  }
  return r;
};
G.createSecurityParameters = function(e, t) {
  var o = e.entity === G.ConnectionEnd.client, r = t.random.bytes(), h = o ? e.session.sp.client_random : r, a = o ? r : G.createRandom().getBytes();
  e.session.sp = {
    entity: e.entity,
    prf_algorithm: G.PRFAlgorithm.tls_prf_sha256,
    bulk_cipher_algorithm: null,
    cipher_type: null,
    enc_key_length: null,
    block_length: null,
    fixed_iv_length: null,
    record_iv_length: null,
    mac_algorithm: null,
    mac_length: null,
    mac_key_length: null,
    compression_algorithm: e.session.compressionMethod,
    pre_master_secret: null,
    master_secret: null,
    client_random: h,
    server_random: a
  };
};
G.handleServerHello = function(e, t, o) {
  var r = G.parseHelloMessage(e, t, o);
  if (!e.fail) {
    if (r.version.minor <= e.version.minor)
      e.version.minor = r.version.minor;
    else
      return e.error(e, {
        message: "Incompatible TLS version.",
        send: !0,
        alert: {
          level: G.Alert.Level.fatal,
          description: G.Alert.Description.protocol_version
        }
      });
    e.session.version = e.version;
    var h = r.session_id.bytes();
    h.length > 0 && h === e.session.id ? (e.expect = V2, e.session.resuming = !0, e.session.sp.server_random = r.random.bytes()) : (e.expect = NI, e.session.resuming = !1, G.createSecurityParameters(e, r)), e.session.id = h, e.process();
  }
};
G.handleClientHello = function(e, t, o) {
  var r = G.parseHelloMessage(e, t, o);
  if (!e.fail) {
    var h = r.session_id.bytes(), a = null;
    if (e.sessionCache && (a = e.sessionCache.getSession(h), a === null ? h = "" : (a.version.major !== r.version.major || a.version.minor > r.version.minor) && (a = null, h = "")), h.length === 0 && (h = xe.random.getBytes(32)), e.session.id = h, e.session.clientHelloVersion = r.version, e.session.sp = {}, a)
      e.version = e.session.version = a.version, e.session.sp = a.sp;
    else {
      for (var p, d = 1; d < G.SupportedVersions.length && (p = G.SupportedVersions[d], !(p.minor <= r.version.minor)); ++d)
        ;
      e.version = { major: p.major, minor: p.minor }, e.session.version = e.version;
    }
    a !== null ? (e.expect = Gh, e.session.resuming = !0, e.session.sp.client_random = r.random.bytes()) : (e.expect = e.verifyClient !== !1 ? FI : Cc, e.session.resuming = !1, G.createSecurityParameters(e, r)), e.open = !0, G.queue(e, G.createRecord(e, {
      type: G.ContentType.handshake,
      data: G.createServerHello(e)
    })), e.session.resuming ? (G.queue(e, G.createRecord(e, {
      type: G.ContentType.change_cipher_spec,
      data: G.createChangeCipherSpec()
    })), e.state.pending = G.createConnectionState(e), e.state.current.write = e.state.pending.write, G.queue(e, G.createRecord(e, {
      type: G.ContentType.handshake,
      data: G.createFinished(e)
    }))) : (G.queue(e, G.createRecord(e, {
      type: G.ContentType.handshake,
      data: G.createCertificate(e)
    })), e.fail || (G.queue(e, G.createRecord(e, {
      type: G.ContentType.handshake,
      data: G.createServerKeyExchange(e)
    })), e.verifyClient !== !1 && G.queue(e, G.createRecord(e, {
      type: G.ContentType.handshake,
      data: G.createCertificateRequest(e)
    })), G.queue(e, G.createRecord(e, {
      type: G.ContentType.handshake,
      data: G.createServerHelloDone(e)
    })))), G.flush(e), e.process();
  }
};
G.handleCertificate = function(e, t, o) {
  if (o < 3)
    return e.error(e, {
      message: "Invalid Certificate message. Message too short.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.illegal_parameter
      }
    });
  var r = t.fragment, h = {
    certificate_list: Rr(r, 3)
  }, a, p, d = [];
  try {
    for (; h.certificate_list.length() > 0; )
      a = Rr(h.certificate_list, 3), p = xe.asn1.fromDer(a), a = xe.pki.certificateFromAsn1(p, !0), d.push(a);
  } catch (g) {
    return e.error(e, {
      message: "Could not parse certificate list.",
      cause: g,
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.bad_certificate
      }
    });
  }
  var b = e.entity === G.ConnectionEnd.client;
  (b || e.verifyClient === !0) && d.length === 0 ? e.error(e, {
    message: b ? "No server certificate provided." : "No client certificate provided.",
    send: !0,
    alert: {
      level: G.Alert.Level.fatal,
      description: G.Alert.Description.illegal_parameter
    }
  }) : d.length === 0 ? e.expect = b ? jp : Cc : (b ? e.session.serverCertificate = d[0] : e.session.clientCertificate = d[0], G.verifyCertificateChain(e, d) && (e.expect = b ? jp : Cc)), e.process();
};
G.handleServerKeyExchange = function(e, t, o) {
  if (o > 0)
    return e.error(e, {
      message: "Invalid key parameters. Only RSA is supported.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.unsupported_certificate
      }
    });
  e.expect = DI, e.process();
};
G.handleClientKeyExchange = function(e, t, o) {
  if (o < 48)
    return e.error(e, {
      message: "Invalid key parameters. Only RSA is supported.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.unsupported_certificate
      }
    });
  var r = t.fragment, h = {
    enc_pre_master_secret: Rr(r, 2).getBytes()
  }, a = null;
  if (e.getPrivateKey)
    try {
      a = e.getPrivateKey(e, e.session.serverCertificate), a = xe.pki.privateKeyFromPem(a);
    } catch (b) {
      e.error(e, {
        message: "Could not get private key.",
        cause: b,
        send: !0,
        alert: {
          level: G.Alert.Level.fatal,
          description: G.Alert.Description.internal_error
        }
      });
    }
  if (a === null)
    return e.error(e, {
      message: "No private key set.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.internal_error
      }
    });
  try {
    var p = e.session.sp;
    p.pre_master_secret = a.decrypt(h.enc_pre_master_secret);
    var d = e.session.clientHelloVersion;
    if (d.major !== p.pre_master_secret.charCodeAt(0) || d.minor !== p.pre_master_secret.charCodeAt(1))
      throw new Error("TLS version rollback attack detected.");
  } catch {
    p.pre_master_secret = xe.random.getBytes(48);
  }
  e.expect = Gh, e.session.clientCertificate !== null && (e.expect = qI), e.process();
};
G.handleCertificateRequest = function(e, t, o) {
  if (o < 3)
    return e.error(e, {
      message: "Invalid CertificateRequest. Message too short.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.illegal_parameter
      }
    });
  var r = t.fragment, h = {
    certificate_types: Rr(r, 1),
    certificate_authorities: Rr(r, 2)
  };
  e.session.certificateRequest = h, e.expect = OI, e.process();
};
G.handleCertificateVerify = function(e, t, o) {
  if (o < 2)
    return e.error(e, {
      message: "Invalid CertificateVerify. Message too short.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.illegal_parameter
      }
    });
  var r = t.fragment;
  r.read -= 4;
  var h = r.bytes();
  r.read += 4;
  var a = {
    signature: Rr(r, 2).getBytes()
  }, p = xe.util.createBuffer();
  p.putBuffer(e.session.md5.digest()), p.putBuffer(e.session.sha1.digest()), p = p.getBytes();
  try {
    var d = e.session.clientCertificate;
    if (!d.publicKey.verify(p, a.signature, "NONE"))
      throw new Error("CertificateVerify signature does not match.");
    e.session.md5.update(h), e.session.sha1.update(h);
  } catch {
    return e.error(e, {
      message: "Bad signature in CertificateVerify.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.handshake_failure
      }
    });
  }
  e.expect = Gh, e.process();
};
G.handleServerHelloDone = function(e, t, o) {
  if (o > 0)
    return e.error(e, {
      message: "Invalid ServerHelloDone message. Invalid length.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.record_overflow
      }
    });
  if (e.serverCertificate === null) {
    var r = {
      message: "No server certificate provided. Not enough security.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.insufficient_security
      }
    }, h = 0, a = e.verify(e, r.alert.description, h, []);
    if (a !== !0)
      return (a || a === 0) && (typeof a == "object" && !xe.util.isArray(a) ? (a.message && (r.message = a.message), a.alert && (r.alert.description = a.alert)) : typeof a == "number" && (r.alert.description = a)), e.error(e, r);
  }
  e.session.certificateRequest !== null && (t = G.createRecord(e, {
    type: G.ContentType.handshake,
    data: G.createCertificate(e)
  }), G.queue(e, t)), t = G.createRecord(e, {
    type: G.ContentType.handshake,
    data: G.createClientKeyExchange(e)
  }), G.queue(e, t), e.expect = kI;
  var p = function(d, b) {
    d.session.certificateRequest !== null && d.session.clientCertificate !== null && G.queue(d, G.createRecord(d, {
      type: G.ContentType.handshake,
      data: G.createCertificateVerify(d, b)
    })), G.queue(d, G.createRecord(d, {
      type: G.ContentType.change_cipher_spec,
      data: G.createChangeCipherSpec()
    })), d.state.pending = G.createConnectionState(d), d.state.current.write = d.state.pending.write, G.queue(d, G.createRecord(d, {
      type: G.ContentType.handshake,
      data: G.createFinished(d)
    })), d.expect = V2, G.flush(d), d.process();
  };
  if (e.session.certificateRequest === null || e.session.clientCertificate === null)
    return p(e, null);
  G.getClientSignature(e, p);
};
G.handleChangeCipherSpec = function(e, t) {
  if (t.fragment.getByte() !== 1)
    return e.error(e, {
      message: "Invalid ChangeCipherSpec message received.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.illegal_parameter
      }
    });
  var o = e.entity === G.ConnectionEnd.client;
  (e.session.resuming && o || !e.session.resuming && !o) && (e.state.pending = G.createConnectionState(e)), e.state.current.read = e.state.pending.read, (!e.session.resuming && o || e.session.resuming && !o) && (e.state.pending = null), e.expect = o ? PI : VI, e.process();
};
G.handleFinished = function(e, t, o) {
  var r = t.fragment;
  r.read -= 4;
  var h = r.bytes();
  r.read += 4;
  var a = t.fragment.getBytes();
  r = xe.util.createBuffer(), r.putBuffer(e.session.md5.digest()), r.putBuffer(e.session.sha1.digest());
  var p = e.entity === G.ConnectionEnd.client, d = p ? "server finished" : "client finished", b = e.session.sp, g = 12, w = Kf;
  if (r = w(b.master_secret, d, r.getBytes(), g), r.getBytes() !== a)
    return e.error(e, {
      message: "Invalid verify_data in Finished message.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.decrypt_error
      }
    });
  e.session.md5.update(h), e.session.sha1.update(h), (e.session.resuming && p || !e.session.resuming && !p) && (G.queue(e, G.createRecord(e, {
    type: G.ContentType.change_cipher_spec,
    data: G.createChangeCipherSpec()
  })), e.state.current.write = e.state.pending.write, e.state.pending = null, G.queue(e, G.createRecord(e, {
    type: G.ContentType.handshake,
    data: G.createFinished(e)
  }))), e.expect = p ? LI : KI, e.handshaking = !1, ++e.handshakes, e.peerCertificate = p ? e.session.serverCertificate : e.session.clientCertificate, G.flush(e), e.isConnected = !0, e.connected(e), e.process();
};
G.handleAlert = function(e, t) {
  var o = t.fragment, r = {
    level: o.getByte(),
    description: o.getByte()
  }, h;
  switch (r.description) {
    case G.Alert.Description.close_notify:
      h = "Connection closed.";
      break;
    case G.Alert.Description.unexpected_message:
      h = "Unexpected message.";
      break;
    case G.Alert.Description.bad_record_mac:
      h = "Bad record MAC.";
      break;
    case G.Alert.Description.decryption_failed:
      h = "Decryption failed.";
      break;
    case G.Alert.Description.record_overflow:
      h = "Record overflow.";
      break;
    case G.Alert.Description.decompression_failure:
      h = "Decompression failed.";
      break;
    case G.Alert.Description.handshake_failure:
      h = "Handshake failure.";
      break;
    case G.Alert.Description.bad_certificate:
      h = "Bad certificate.";
      break;
    case G.Alert.Description.unsupported_certificate:
      h = "Unsupported certificate.";
      break;
    case G.Alert.Description.certificate_revoked:
      h = "Certificate revoked.";
      break;
    case G.Alert.Description.certificate_expired:
      h = "Certificate expired.";
      break;
    case G.Alert.Description.certificate_unknown:
      h = "Certificate unknown.";
      break;
    case G.Alert.Description.illegal_parameter:
      h = "Illegal parameter.";
      break;
    case G.Alert.Description.unknown_ca:
      h = "Unknown certificate authority.";
      break;
    case G.Alert.Description.access_denied:
      h = "Access denied.";
      break;
    case G.Alert.Description.decode_error:
      h = "Decode error.";
      break;
    case G.Alert.Description.decrypt_error:
      h = "Decrypt error.";
      break;
    case G.Alert.Description.export_restriction:
      h = "Export restriction.";
      break;
    case G.Alert.Description.protocol_version:
      h = "Unsupported protocol version.";
      break;
    case G.Alert.Description.insufficient_security:
      h = "Insufficient security.";
      break;
    case G.Alert.Description.internal_error:
      h = "Internal error.";
      break;
    case G.Alert.Description.user_canceled:
      h = "User canceled.";
      break;
    case G.Alert.Description.no_renegotiation:
      h = "Renegotiation not supported.";
      break;
    default:
      h = "Unknown error.";
      break;
  }
  if (r.description === G.Alert.Description.close_notify)
    return e.close();
  e.error(e, {
    message: h,
    send: !1,
    // origin is the opposite end
    origin: e.entity === G.ConnectionEnd.client ? "server" : "client",
    alert: r
  }), e.process();
};
G.handleHandshake = function(e, t) {
  var o = t.fragment, r = o.getByte(), h = o.getInt24();
  if (h > o.length())
    return e.fragmented = t, t.fragment = xe.util.createBuffer(), o.read -= 4, e.process();
  e.fragmented = null, o.read -= 4;
  var a = o.bytes(h + 4);
  o.read += 4, r in Vs[e.entity][e.expect] ? (e.entity === G.ConnectionEnd.server && !e.open && !e.fail && (e.handshaking = !0, e.session = {
    version: null,
    extensions: {
      server_name: {
        serverNameList: []
      }
    },
    cipherSuite: null,
    compressionMethod: null,
    serverCertificate: null,
    clientCertificate: null,
    md5: xe.md.md5.create(),
    sha1: xe.md.sha1.create()
  }), r !== G.HandshakeType.hello_request && r !== G.HandshakeType.certificate_verify && r !== G.HandshakeType.finished && (e.session.md5.update(a), e.session.sha1.update(a)), Vs[e.entity][e.expect][r](e, t, h)) : G.handleUnexpected(e, t);
};
G.handleApplicationData = function(e, t) {
  e.data.putBuffer(t.fragment), e.dataReady(e), e.process();
};
G.handleHeartbeat = function(e, t) {
  var o = t.fragment, r = o.getByte(), h = o.getInt16(), a = o.getBytes(h);
  if (r === G.HeartbeatMessageType.heartbeat_request) {
    if (e.handshaking || h > a.length)
      return e.process();
    G.queue(e, G.createRecord(e, {
      type: G.ContentType.heartbeat,
      data: G.createHeartbeat(
        G.HeartbeatMessageType.heartbeat_response,
        a
      )
    })), G.flush(e);
  } else if (r === G.HeartbeatMessageType.heartbeat_response) {
    if (a !== e.expectedHeartbeatPayload)
      return e.process();
    e.heartbeatReceived && e.heartbeatReceived(e, xe.util.createBuffer(a));
  }
  e.process();
};
var RI = 0, NI = 1, jp = 2, DI = 3, OI = 4, V2 = 5, PI = 6, LI = 7, kI = 8, UI = 0, FI = 1, Cc = 2, qI = 3, Gh = 4, VI = 5, KI = 6, K = G.handleUnexpected, K2 = G.handleChangeCipherSpec, nr = G.handleAlert, mr = G.handleHandshake, $2 = G.handleApplicationData, ar = G.handleHeartbeat, zh = [];
zh[G.ConnectionEnd.client] = [
  //      CC,AL,HS,AD,HB
  /*SHE*/
  [K, nr, mr, K, ar],
  /*SCE*/
  [K, nr, mr, K, ar],
  /*SKE*/
  [K, nr, mr, K, ar],
  /*SCR*/
  [K, nr, mr, K, ar],
  /*SHD*/
  [K, nr, mr, K, ar],
  /*SCC*/
  [K2, nr, K, K, ar],
  /*SFI*/
  [K, nr, mr, K, ar],
  /*SAD*/
  [K, nr, mr, $2, ar],
  /*SER*/
  [K, nr, mr, K, ar]
];
zh[G.ConnectionEnd.server] = [
  //      CC,AL,HS,AD
  /*CHE*/
  [K, nr, mr, K, ar],
  /*CCE*/
  [K, nr, mr, K, ar],
  /*CKE*/
  [K, nr, mr, K, ar],
  /*CCV*/
  [K, nr, mr, K, ar],
  /*CCC*/
  [K2, nr, K, K, ar],
  /*CFI*/
  [K, nr, mr, K, ar],
  /*CAD*/
  [K, nr, mr, $2, ar],
  /*CER*/
  [K, nr, mr, K, ar]
];
var dn = G.handleHelloRequest, $I = G.handleServerHello, H2 = G.handleCertificate, Wp = G.handleServerKeyExchange, qu = G.handleCertificateRequest, ss = G.handleServerHelloDone, G2 = G.handleFinished, Vs = [];
Vs[G.ConnectionEnd.client] = [
  //      HR,01,SH,03,04,05,06,07,08,09,10,SC,SK,CR,HD,15,CK,17,18,19,FI
  /*SHE*/
  [K, K, $I, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K],
  /*SCE*/
  [dn, K, K, K, K, K, K, K, K, K, K, H2, Wp, qu, ss, K, K, K, K, K, K],
  /*SKE*/
  [dn, K, K, K, K, K, K, K, K, K, K, K, Wp, qu, ss, K, K, K, K, K, K],
  /*SCR*/
  [dn, K, K, K, K, K, K, K, K, K, K, K, K, qu, ss, K, K, K, K, K, K],
  /*SHD*/
  [dn, K, K, K, K, K, K, K, K, K, K, K, K, K, ss, K, K, K, K, K, K],
  /*SCC*/
  [dn, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K],
  /*SFI*/
  [dn, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, G2],
  /*SAD*/
  [dn, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K],
  /*SER*/
  [dn, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K]
];
var HI = G.handleClientHello, GI = G.handleClientKeyExchange, zI = G.handleCertificateVerify;
Vs[G.ConnectionEnd.server] = [
  //      01,CH,02,03,04,05,06,07,08,09,10,CC,12,13,14,CV,CK,17,18,19,FI
  /*CHE*/
  [K, HI, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K],
  /*CCE*/
  [K, K, K, K, K, K, K, K, K, K, K, H2, K, K, K, K, K, K, K, K, K],
  /*CKE*/
  [K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, GI, K, K, K, K],
  /*CCV*/
  [K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, zI, K, K, K, K, K],
  /*CCC*/
  [K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K],
  /*CFI*/
  [K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, G2],
  /*CAD*/
  [K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K],
  /*CER*/
  [K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K]
];
G.generateKeys = function(e, t) {
  var o = Kf, r = t.client_random + t.server_random;
  e.session.resuming || (t.master_secret = o(
    t.pre_master_secret,
    "master secret",
    r,
    48
  ).bytes(), t.pre_master_secret = null), r = t.server_random + t.client_random;
  var h = 2 * t.mac_key_length + 2 * t.enc_key_length, a = e.version.major === G.Versions.TLS_1_0.major && e.version.minor === G.Versions.TLS_1_0.minor;
  a && (h += 2 * t.fixed_iv_length);
  var p = o(t.master_secret, "key expansion", r, h), d = {
    client_write_MAC_key: p.getBytes(t.mac_key_length),
    server_write_MAC_key: p.getBytes(t.mac_key_length),
    client_write_key: p.getBytes(t.enc_key_length),
    server_write_key: p.getBytes(t.enc_key_length)
  };
  return a && (d.client_write_IV = p.getBytes(t.fixed_iv_length), d.server_write_IV = p.getBytes(t.fixed_iv_length)), d;
};
G.createConnectionState = function(e) {
  var t = e.entity === G.ConnectionEnd.client, o = function() {
    var a = {
      // two 32-bit numbers, first is most significant
      sequenceNumber: [0, 0],
      macKey: null,
      macLength: 0,
      macFunction: null,
      cipherState: null,
      cipherFunction: function(p) {
        return !0;
      },
      compressionState: null,
      compressFunction: function(p) {
        return !0;
      },
      updateSequenceNumber: function() {
        a.sequenceNumber[1] === 4294967295 ? (a.sequenceNumber[1] = 0, ++a.sequenceNumber[0]) : ++a.sequenceNumber[1];
      }
    };
    return a;
  }, r = {
    read: o(),
    write: o()
  };
  if (r.read.update = function(a, p) {
    return r.read.cipherFunction(p, r.read) ? r.read.compressFunction(a, p, r.read) || a.error(a, {
      message: "Could not decompress record.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.decompression_failure
      }
    }) : a.error(a, {
      message: "Could not decrypt record or bad MAC.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        // doesn't matter if decryption failed or MAC was
        // invalid, return the same error so as not to reveal
        // which one occurred
        description: G.Alert.Description.bad_record_mac
      }
    }), !a.fail;
  }, r.write.update = function(a, p) {
    return r.write.compressFunction(a, p, r.write) ? r.write.cipherFunction(p, r.write) || a.error(a, {
      message: "Could not encrypt record.",
      send: !1,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.internal_error
      }
    }) : a.error(a, {
      message: "Could not compress record.",
      send: !1,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.internal_error
      }
    }), !a.fail;
  }, e.session) {
    var h = e.session.sp;
    switch (e.session.cipherSuite.initSecurityParameters(h), h.keys = G.generateKeys(e, h), r.read.macKey = t ? h.keys.server_write_MAC_key : h.keys.client_write_MAC_key, r.write.macKey = t ? h.keys.client_write_MAC_key : h.keys.server_write_MAC_key, e.session.cipherSuite.initConnectionState(r, e, h), h.compression_algorithm) {
      case G.CompressionMethod.none:
        break;
      case G.CompressionMethod.deflate:
        r.read.compressFunction = MI, r.write.compressFunction = TI;
        break;
      default:
        throw new Error("Unsupported compression algorithm.");
    }
  }
  return r;
};
G.createRandom = function() {
  var e = /* @__PURE__ */ new Date(), t = +e + e.getTimezoneOffset() * 6e4, o = xe.util.createBuffer();
  return o.putInt32(t), o.putBytes(xe.random.getBytes(28)), o;
};
G.createRecord = function(e, t) {
  if (!t.data)
    return null;
  var o = {
    type: t.type,
    version: {
      major: e.version.major,
      minor: e.version.minor
    },
    length: t.data.length(),
    fragment: t.data
  };
  return o;
};
G.createAlert = function(e, t) {
  var o = xe.util.createBuffer();
  return o.putByte(t.level), o.putByte(t.description), G.createRecord(e, {
    type: G.ContentType.alert,
    data: o
  });
};
G.createClientHello = function(e) {
  e.session.clientHelloVersion = {
    major: e.version.major,
    minor: e.version.minor
  };
  for (var t = xe.util.createBuffer(), o = 0; o < e.cipherSuites.length; ++o) {
    var r = e.cipherSuites[o];
    t.putByte(r.id[0]), t.putByte(r.id[1]);
  }
  var h = t.length(), a = xe.util.createBuffer();
  a.putByte(G.CompressionMethod.none);
  var p = a.length(), d = xe.util.createBuffer();
  if (e.virtualHost) {
    var b = xe.util.createBuffer();
    b.putByte(0), b.putByte(0);
    var g = xe.util.createBuffer();
    g.putByte(0), Fr(g, 2, xe.util.createBuffer(e.virtualHost));
    var w = xe.util.createBuffer();
    Fr(w, 2, g), Fr(b, 2, w), d.putBuffer(b);
  }
  var C = d.length();
  C > 0 && (C += 2);
  var T = e.session.id, k = T.length + 1 + // session ID vector
  2 + // version (major + minor)
  4 + 28 + // random time and random bytes
  2 + h + // cipher suites vector
  1 + p + // compression methods vector
  C, q = xe.util.createBuffer();
  return q.putByte(G.HandshakeType.client_hello), q.putInt24(k), q.putByte(e.version.major), q.putByte(e.version.minor), q.putBytes(e.session.sp.client_random), Fr(q, 1, xe.util.createBuffer(T)), Fr(q, 2, t), Fr(q, 1, a), C > 0 && Fr(q, 2, d), q;
};
G.createServerHello = function(e) {
  var t = e.session.id, o = t.length + 1 + // session ID vector
  2 + // version (major + minor)
  4 + 28 + // random time and random bytes
  2 + // chosen cipher suite
  1, r = xe.util.createBuffer();
  return r.putByte(G.HandshakeType.server_hello), r.putInt24(o), r.putByte(e.version.major), r.putByte(e.version.minor), r.putBytes(e.session.sp.server_random), Fr(r, 1, xe.util.createBuffer(t)), r.putByte(e.session.cipherSuite.id[0]), r.putByte(e.session.cipherSuite.id[1]), r.putByte(e.session.compressionMethod), r;
};
G.createCertificate = function(e) {
  var t = e.entity === G.ConnectionEnd.client, o = null;
  if (e.getCertificate) {
    var r;
    t ? r = e.session.certificateRequest : r = e.session.extensions.server_name.serverNameList, o = e.getCertificate(e, r);
  }
  var h = xe.util.createBuffer();
  if (o !== null)
    try {
      xe.util.isArray(o) || (o = [o]);
      for (var a = null, p = 0; p < o.length; ++p) {
        var d = xe.pem.decode(o[p])[0];
        if (d.type !== "CERTIFICATE" && d.type !== "X509 CERTIFICATE" && d.type !== "TRUSTED CERTIFICATE") {
          var b = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
          throw b.headerType = d.type, b;
        }
        if (d.procType && d.procType.type === "ENCRYPTED")
          throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
        var g = xe.util.createBuffer(d.body);
        a === null && (a = xe.asn1.fromDer(g.bytes(), !1));
        var w = xe.util.createBuffer();
        Fr(w, 3, g), h.putBuffer(w);
      }
      o = xe.pki.certificateFromAsn1(a), t ? e.session.clientCertificate = o : e.session.serverCertificate = o;
    } catch (k) {
      return e.error(e, {
        message: "Could not send certificate list.",
        cause: k,
        send: !0,
        alert: {
          level: G.Alert.Level.fatal,
          description: G.Alert.Description.bad_certificate
        }
      });
    }
  var C = 3 + h.length(), T = xe.util.createBuffer();
  return T.putByte(G.HandshakeType.certificate), T.putInt24(C), Fr(T, 3, h), T;
};
G.createClientKeyExchange = function(e) {
  var t = xe.util.createBuffer();
  t.putByte(e.session.clientHelloVersion.major), t.putByte(e.session.clientHelloVersion.minor), t.putBytes(xe.random.getBytes(46));
  var o = e.session.sp;
  o.pre_master_secret = t.getBytes();
  var r = e.session.serverCertificate.publicKey;
  t = r.encrypt(o.pre_master_secret);
  var h = t.length + 2, a = xe.util.createBuffer();
  return a.putByte(G.HandshakeType.client_key_exchange), a.putInt24(h), a.putInt16(t.length), a.putBytes(t), a;
};
G.createServerKeyExchange = function(e) {
  var t = xe.util.createBuffer();
  return t;
};
G.getClientSignature = function(e, t) {
  var o = xe.util.createBuffer();
  o.putBuffer(e.session.md5.digest()), o.putBuffer(e.session.sha1.digest()), o = o.getBytes(), e.getSignature = e.getSignature || function(r, h, a) {
    var p = null;
    if (r.getPrivateKey)
      try {
        p = r.getPrivateKey(r, r.session.clientCertificate), p = xe.pki.privateKeyFromPem(p);
      } catch (d) {
        r.error(r, {
          message: "Could not get private key.",
          cause: d,
          send: !0,
          alert: {
            level: G.Alert.Level.fatal,
            description: G.Alert.Description.internal_error
          }
        });
      }
    p === null ? r.error(r, {
      message: "No private key set.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.internal_error
      }
    }) : h = p.sign(h, null), a(r, h);
  }, e.getSignature(e, o, t);
};
G.createCertificateVerify = function(e, t) {
  var o = t.length + 2, r = xe.util.createBuffer();
  return r.putByte(G.HandshakeType.certificate_verify), r.putInt24(o), r.putInt16(t.length), r.putBytes(t), r;
};
G.createCertificateRequest = function(e) {
  var t = xe.util.createBuffer();
  t.putByte(1);
  var o = xe.util.createBuffer();
  for (var r in e.caStore.certs) {
    var h = e.caStore.certs[r], a = xe.pki.distinguishedNameToAsn1(h.subject), p = xe.asn1.toDer(a);
    o.putInt16(p.length()), o.putBuffer(p);
  }
  var d = 1 + t.length() + 2 + o.length(), b = xe.util.createBuffer();
  return b.putByte(G.HandshakeType.certificate_request), b.putInt24(d), Fr(b, 1, t), Fr(b, 2, o), b;
};
G.createServerHelloDone = function(e) {
  var t = xe.util.createBuffer();
  return t.putByte(G.HandshakeType.server_hello_done), t.putInt24(0), t;
};
G.createChangeCipherSpec = function() {
  var e = xe.util.createBuffer();
  return e.putByte(1), e;
};
G.createFinished = function(e) {
  var t = xe.util.createBuffer();
  t.putBuffer(e.session.md5.digest()), t.putBuffer(e.session.sha1.digest());
  var o = e.entity === G.ConnectionEnd.client, r = e.session.sp, h = 12, a = Kf, p = o ? "client finished" : "server finished";
  t = a(r.master_secret, p, t.getBytes(), h);
  var d = xe.util.createBuffer();
  return d.putByte(G.HandshakeType.finished), d.putInt24(t.length()), d.putBuffer(t), d;
};
G.createHeartbeat = function(e, t, o) {
  typeof o > "u" && (o = t.length);
  var r = xe.util.createBuffer();
  r.putByte(e), r.putInt16(o), r.putBytes(t);
  var h = r.length(), a = Math.max(16, h - o - 3);
  return r.putBytes(xe.random.getBytes(a)), r;
};
G.queue = function(e, t) {
  if (t && !(t.fragment.length() === 0 && (t.type === G.ContentType.handshake || t.type === G.ContentType.alert || t.type === G.ContentType.change_cipher_spec))) {
    if (t.type === G.ContentType.handshake) {
      var o = t.fragment.bytes();
      e.session.md5.update(o), e.session.sha1.update(o), o = null;
    }
    var r;
    if (t.fragment.length() <= G.MaxFragment)
      r = [t];
    else {
      r = [];
      for (var h = t.fragment.bytes(); h.length > G.MaxFragment; )
        r.push(G.createRecord(e, {
          type: t.type,
          data: xe.util.createBuffer(h.slice(0, G.MaxFragment))
        })), h = h.slice(G.MaxFragment);
      h.length > 0 && r.push(G.createRecord(e, {
        type: t.type,
        data: xe.util.createBuffer(h)
      }));
    }
    for (var a = 0; a < r.length && !e.fail; ++a) {
      var p = r[a], d = e.state.current.write;
      d.update(e, p) && e.records.push(p);
    }
  }
};
G.flush = function(e) {
  for (var t = 0; t < e.records.length; ++t) {
    var o = e.records[t];
    e.tlsData.putByte(o.type), e.tlsData.putByte(o.version.major), e.tlsData.putByte(o.version.minor), e.tlsData.putInt16(o.fragment.length()), e.tlsData.putBuffer(e.records[t].fragment);
  }
  return e.records = [], e.tlsDataReady(e);
};
var Vu = function(e) {
  switch (e) {
    case !0:
      return !0;
    case xe.pki.certificateError.bad_certificate:
      return G.Alert.Description.bad_certificate;
    case xe.pki.certificateError.unsupported_certificate:
      return G.Alert.Description.unsupported_certificate;
    case xe.pki.certificateError.certificate_revoked:
      return G.Alert.Description.certificate_revoked;
    case xe.pki.certificateError.certificate_expired:
      return G.Alert.Description.certificate_expired;
    case xe.pki.certificateError.certificate_unknown:
      return G.Alert.Description.certificate_unknown;
    case xe.pki.certificateError.unknown_ca:
      return G.Alert.Description.unknown_ca;
    default:
      return G.Alert.Description.bad_certificate;
  }
}, jI = function(e) {
  switch (e) {
    case !0:
      return !0;
    case G.Alert.Description.bad_certificate:
      return xe.pki.certificateError.bad_certificate;
    case G.Alert.Description.unsupported_certificate:
      return xe.pki.certificateError.unsupported_certificate;
    case G.Alert.Description.certificate_revoked:
      return xe.pki.certificateError.certificate_revoked;
    case G.Alert.Description.certificate_expired:
      return xe.pki.certificateError.certificate_expired;
    case G.Alert.Description.certificate_unknown:
      return xe.pki.certificateError.certificate_unknown;
    case G.Alert.Description.unknown_ca:
      return xe.pki.certificateError.unknown_ca;
    default:
      return xe.pki.certificateError.bad_certificate;
  }
};
G.verifyCertificateChain = function(e, t) {
  try {
    var o = {};
    for (var r in e.verifyOptions)
      o[r] = e.verifyOptions[r];
    o.verify = function(a, p, d) {
      var b = Vu(a), g = e.verify(e, a, p, d);
      if (g !== !0) {
        if (typeof g == "object" && !xe.util.isArray(g)) {
          var w = new Error("The application rejected the certificate.");
          throw w.send = !0, w.alert = {
            level: G.Alert.Level.fatal,
            description: G.Alert.Description.bad_certificate
          }, g.message && (w.message = g.message), g.alert && (w.alert.description = g.alert), w;
        }
        g !== a && (g = jI(g));
      }
      return g;
    }, xe.pki.verifyCertificateChain(e.caStore, t, o);
  } catch (a) {
    var h = a;
    (typeof h != "object" || xe.util.isArray(h)) && (h = {
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: Vu(a)
      }
    }), "send" in h || (h.send = !0), "alert" in h || (h.alert = {
      level: G.Alert.Level.fatal,
      description: Vu(h.error)
    }), e.error(e, h);
  }
  return !e.fail;
};
G.createSessionCache = function(e, t) {
  var o = null;
  if (e && e.getSession && e.setSession && e.order)
    o = e;
  else {
    o = {}, o.cache = e || {}, o.capacity = Math.max(t || 100, 1), o.order = [];
    for (var r in e)
      o.order.length <= t ? o.order.push(r) : delete e[r];
    o.getSession = function(h) {
      var a = null, p = null;
      if (h ? p = xe.util.bytesToHex(h) : o.order.length > 0 && (p = o.order[0]), p !== null && p in o.cache) {
        a = o.cache[p], delete o.cache[p];
        for (var d in o.order)
          if (o.order[d] === p) {
            o.order.splice(d, 1);
            break;
          }
      }
      return a;
    }, o.setSession = function(h, a) {
      if (o.order.length === o.capacity) {
        var p = o.order.shift();
        delete o.cache[p];
      }
      var p = xe.util.bytesToHex(h);
      o.order.push(p), o.cache[p] = a;
    };
  }
  return o;
};
G.createConnection = function(e) {
  var t = null;
  e.caStore ? xe.util.isArray(e.caStore) ? t = xe.pki.createCaStore(e.caStore) : t = e.caStore : t = xe.pki.createCaStore();
  var o = e.cipherSuites || null;
  if (o === null) {
    o = [];
    for (var r in G.CipherSuites)
      o.push(G.CipherSuites[r]);
  }
  var h = e.server ? G.ConnectionEnd.server : G.ConnectionEnd.client, a = e.sessionCache ? G.createSessionCache(e.sessionCache) : null, p = {
    version: { major: G.Version.major, minor: G.Version.minor },
    entity: h,
    sessionId: e.sessionId,
    caStore: t,
    sessionCache: a,
    cipherSuites: o,
    connected: e.connected,
    virtualHost: e.virtualHost || null,
    verifyClient: e.verifyClient || !1,
    verify: e.verify || function(w, C, T, k) {
      return C;
    },
    verifyOptions: e.verifyOptions || {},
    getCertificate: e.getCertificate || null,
    getPrivateKey: e.getPrivateKey || null,
    getSignature: e.getSignature || null,
    input: xe.util.createBuffer(),
    tlsData: xe.util.createBuffer(),
    data: xe.util.createBuffer(),
    tlsDataReady: e.tlsDataReady,
    dataReady: e.dataReady,
    heartbeatReceived: e.heartbeatReceived,
    closed: e.closed,
    error: function(w, C) {
      C.origin = C.origin || (w.entity === G.ConnectionEnd.client ? "client" : "server"), C.send && (G.queue(w, G.createAlert(w, C.alert)), G.flush(w));
      var T = C.fatal !== !1;
      T && (w.fail = !0), e.error(w, C), T && w.close(!1);
    },
    deflate: e.deflate || null,
    inflate: e.inflate || null
  };
  p.reset = function(w) {
    p.version = { major: G.Version.major, minor: G.Version.minor }, p.record = null, p.session = null, p.peerCertificate = null, p.state = {
      pending: null,
      current: null
    }, p.expect = p.entity === G.ConnectionEnd.client ? RI : UI, p.fragmented = null, p.records = [], p.open = !1, p.handshakes = 0, p.handshaking = !1, p.isConnected = !1, p.fail = !(w || typeof w > "u"), p.input.clear(), p.tlsData.clear(), p.data.clear(), p.state.current = G.createConnectionState(p);
  }, p.reset();
  var d = function(w, C) {
    var T = C.type - G.ContentType.change_cipher_spec, k = zh[w.entity][w.expect];
    T in k ? k[T](w, C) : G.handleUnexpected(w, C);
  }, b = function(w) {
    var C = 0, T = w.input, k = T.length();
    if (k < 5)
      C = 5 - k;
    else {
      w.record = {
        type: T.getByte(),
        version: {
          major: T.getByte(),
          minor: T.getByte()
        },
        length: T.getInt16(),
        fragment: xe.util.createBuffer(),
        ready: !1
      };
      var q = w.record.version.major === w.version.major;
      q && w.session && w.session.version && (q = w.record.version.minor === w.version.minor), q || w.error(w, {
        message: "Incompatible TLS version.",
        send: !0,
        alert: {
          level: G.Alert.Level.fatal,
          description: G.Alert.Description.protocol_version
        }
      });
    }
    return C;
  }, g = function(w) {
    var C = 0, T = w.input, k = T.length();
    if (k < w.record.length)
      C = w.record.length - k;
    else {
      w.record.fragment.putBytes(T.getBytes(w.record.length)), T.compact();
      var q = w.state.current.read;
      q.update(w, w.record) && (w.fragmented !== null && (w.fragmented.type === w.record.type ? (w.fragmented.fragment.putBuffer(w.record.fragment), w.record = w.fragmented) : w.error(w, {
        message: "Invalid fragmented record.",
        send: !0,
        alert: {
          level: G.Alert.Level.fatal,
          description: G.Alert.Description.unexpected_message
        }
      })), w.record.ready = !0);
    }
    return C;
  };
  return p.handshake = function(w) {
    if (p.entity !== G.ConnectionEnd.client)
      p.error(p, {
        message: "Cannot initiate handshake as a server.",
        fatal: !1
      });
    else if (p.handshaking)
      p.error(p, {
        message: "Handshake already in progress.",
        fatal: !1
      });
    else {
      p.fail && !p.open && p.handshakes === 0 && (p.fail = !1), p.handshaking = !0, w = w || "";
      var C = null;
      w.length > 0 && (p.sessionCache && (C = p.sessionCache.getSession(w)), C === null && (w = "")), w.length === 0 && p.sessionCache && (C = p.sessionCache.getSession(), C !== null && (w = C.id)), p.session = {
        id: w,
        version: null,
        cipherSuite: null,
        compressionMethod: null,
        serverCertificate: null,
        certificateRequest: null,
        clientCertificate: null,
        sp: {},
        md5: xe.md.md5.create(),
        sha1: xe.md.sha1.create()
      }, C && (p.version = C.version, p.session.sp = C.sp), p.session.sp.client_random = G.createRandom().getBytes(), p.open = !0, G.queue(p, G.createRecord(p, {
        type: G.ContentType.handshake,
        data: G.createClientHello(p)
      })), G.flush(p);
    }
  }, p.process = function(w) {
    var C = 0;
    return w && p.input.putBytes(w), p.fail || (p.record !== null && p.record.ready && p.record.fragment.isEmpty() && (p.record = null), p.record === null && (C = b(p)), !p.fail && p.record !== null && !p.record.ready && (C = g(p)), !p.fail && p.record !== null && p.record.ready && d(p, p.record)), C;
  }, p.prepare = function(w) {
    return G.queue(p, G.createRecord(p, {
      type: G.ContentType.application_data,
      data: xe.util.createBuffer(w)
    })), G.flush(p);
  }, p.prepareHeartbeatRequest = function(w, C) {
    return w instanceof xe.util.ByteBuffer && (w = w.bytes()), typeof C > "u" && (C = w.length), p.expectedHeartbeatPayload = w, G.queue(p, G.createRecord(p, {
      type: G.ContentType.heartbeat,
      data: G.createHeartbeat(
        G.HeartbeatMessageType.heartbeat_request,
        w,
        C
      )
    })), G.flush(p);
  }, p.close = function(w) {
    if (!p.fail && p.sessionCache && p.session) {
      var C = {
        id: p.session.id,
        version: p.session.version,
        sp: p.session.sp
      };
      C.sp.keys = null, p.sessionCache.setSession(C.id, C);
    }
    p.open && (p.open = !1, p.input.clear(), (p.isConnected || p.handshaking) && (p.isConnected = p.handshaking = !1, G.queue(p, G.createAlert(p, {
      level: G.Alert.Level.warning,
      description: G.Alert.Description.close_notify
    })), G.flush(p)), p.closed(p)), p.reset(w);
  }, p;
};
xe.tls = xe.tls || {};
for (var Ku in G)
  typeof G[Ku] != "function" && (xe.tls[Ku] = G[Ku]);
xe.tls.prf_tls1 = Kf;
xe.tls.hmac_sha1 = II;
xe.tls.createSessionCache = G.createSessionCache;
xe.tls.createConnection = G.createConnection;
var Sn = ht, zr = Sn.tls;
zr.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA = {
  id: [0, 47],
  name: "TLS_RSA_WITH_AES_128_CBC_SHA",
  initSecurityParameters: function(e) {
    e.bulk_cipher_algorithm = zr.BulkCipherAlgorithm.aes, e.cipher_type = zr.CipherType.block, e.enc_key_length = 16, e.block_length = 16, e.fixed_iv_length = 16, e.record_iv_length = 16, e.mac_algorithm = zr.MACAlgorithm.hmac_sha1, e.mac_length = 20, e.mac_key_length = 20;
  },
  initConnectionState: z2
};
zr.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA = {
  id: [0, 53],
  name: "TLS_RSA_WITH_AES_256_CBC_SHA",
  initSecurityParameters: function(e) {
    e.bulk_cipher_algorithm = zr.BulkCipherAlgorithm.aes, e.cipher_type = zr.CipherType.block, e.enc_key_length = 32, e.block_length = 16, e.fixed_iv_length = 16, e.record_iv_length = 16, e.mac_algorithm = zr.MACAlgorithm.hmac_sha1, e.mac_length = 20, e.mac_key_length = 20;
  },
  initConnectionState: z2
};
function z2(e, t, o) {
  var r = t.entity === Sn.tls.ConnectionEnd.client;
  e.read.cipherState = {
    init: !1,
    cipher: Sn.cipher.createDecipher("AES-CBC", r ? o.keys.server_write_key : o.keys.client_write_key),
    iv: r ? o.keys.server_write_IV : o.keys.client_write_IV
  }, e.write.cipherState = {
    init: !1,
    cipher: Sn.cipher.createCipher("AES-CBC", r ? o.keys.client_write_key : o.keys.server_write_key),
    iv: r ? o.keys.client_write_IV : o.keys.server_write_IV
  }, e.read.cipherFunction = QI, e.write.cipherFunction = WI, e.read.macLength = e.write.macLength = o.mac_length, e.read.macFunction = e.write.macFunction = zr.hmac_sha1;
}
function WI(e, t) {
  var o = !1, r = t.macFunction(t.macKey, t.sequenceNumber, e);
  e.fragment.putBytes(r), t.updateSequenceNumber();
  var h;
  e.version.minor === zr.Versions.TLS_1_0.minor ? h = t.cipherState.init ? null : t.cipherState.iv : h = Sn.random.getBytesSync(16), t.cipherState.init = !0;
  var a = t.cipherState.cipher;
  return a.start({ iv: h }), e.version.minor >= zr.Versions.TLS_1_1.minor && a.output.putBytes(h), a.update(e.fragment), a.finish(YI) && (e.fragment = a.output, e.length = e.fragment.length(), o = !0), o;
}
function YI(e, t, o) {
  if (!o) {
    var r = e - t.length() % e;
    t.fillWithByte(r - 1, r);
  }
  return !0;
}
function XI(e, t, o) {
  var r = !0;
  if (o) {
    for (var h = t.length(), a = t.last(), p = h - 1 - a; p < h - 1; ++p)
      r = r && t.at(p) == a;
    r && t.truncate(a + 1);
  }
  return r;
}
function QI(e, t) {
  var o = !1, r;
  e.version.minor === zr.Versions.TLS_1_0.minor ? r = t.cipherState.init ? null : t.cipherState.iv : r = e.fragment.getBytes(16), t.cipherState.init = !0;
  var h = t.cipherState.cipher;
  h.start({ iv: r }), h.update(e.fragment), o = h.finish(XI);
  var a = t.macLength, p = Sn.random.getBytesSync(a), d = h.output.length();
  d >= a ? (e.fragment = h.output.getBytes(d - a), p = h.output.getBytes(a)) : e.fragment = h.output.getBytes(), e.fragment = Sn.util.createBuffer(e.fragment), e.length = e.fragment.length();
  var b = t.macFunction(t.macKey, t.sequenceNumber, e);
  return t.updateSequenceNumber(), o = ZI(t.macKey, p, b) && o, o;
}
function ZI(e, t, o) {
  var r = Sn.hmac.create();
  return r.start("SHA1", e), r.update(t), t = r.digest().getBytes(), r.start(null, null), r.update(o), o = r.digest().getBytes(), t === o;
}
var Ft = ht, Y0 = Ft.sha512 = Ft.sha512 || {};
Ft.md.sha512 = Ft.md.algorithms.sha512 = Y0;
var j2 = Ft.sha384 = Ft.sha512.sha384 = Ft.sha512.sha384 || {};
j2.create = function() {
  return Y0.create("SHA-384");
};
Ft.md.sha384 = Ft.md.algorithms.sha384 = j2;
Ft.sha512.sha256 = Ft.sha512.sha256 || {
  create: function() {
    return Y0.create("SHA-512/256");
  }
};
Ft.md["sha512/256"] = Ft.md.algorithms["sha512/256"] = Ft.sha512.sha256;
Ft.sha512.sha224 = Ft.sha512.sha224 || {
  create: function() {
    return Y0.create("SHA-512/224");
  }
};
Ft.md["sha512/224"] = Ft.md.algorithms["sha512/224"] = Ft.sha512.sha224;
Y0.create = function(e) {
  if (W2 || JI(), typeof e > "u" && (e = "SHA-512"), !(e in Kn))
    throw new Error("Invalid SHA-512 algorithm: " + e);
  for (var t = Kn[e], o = null, r = Ft.util.createBuffer(), h = new Array(80), a = 0; a < 80; ++a)
    h[a] = new Array(2);
  var p = 64;
  switch (e) {
    case "SHA-384":
      p = 48;
      break;
    case "SHA-512/256":
      p = 32;
      break;
    case "SHA-512/224":
      p = 28;
      break;
  }
  var d = {
    // SHA-512 => sha512
    algorithm: e.replace("-", "").toLowerCase(),
    blockLength: 128,
    digestLength: p,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 16
  };
  return d.start = function() {
    d.messageLength = 0, d.fullMessageLength = d.messageLength128 = [];
    for (var b = d.messageLengthSize / 4, g = 0; g < b; ++g)
      d.fullMessageLength.push(0);
    r = Ft.util.createBuffer(), o = new Array(t.length);
    for (var g = 0; g < t.length; ++g)
      o[g] = t[g].slice(0);
    return d;
  }, d.start(), d.update = function(b, g) {
    g === "utf8" && (b = Ft.util.encodeUtf8(b));
    var w = b.length;
    d.messageLength += w, w = [w / 4294967296 >>> 0, w >>> 0];
    for (var C = d.fullMessageLength.length - 1; C >= 0; --C)
      d.fullMessageLength[C] += w[1], w[1] = w[0] + (d.fullMessageLength[C] / 4294967296 >>> 0), d.fullMessageLength[C] = d.fullMessageLength[C] >>> 0, w[0] = w[1] / 4294967296 >>> 0;
    return r.putBytes(b), Yp(o, h, r), (r.read > 2048 || r.length() === 0) && r.compact(), d;
  }, d.digest = function() {
    var b = Ft.util.createBuffer();
    b.putBytes(r.bytes());
    var g = d.fullMessageLength[d.fullMessageLength.length - 1] + d.messageLengthSize, w = g & d.blockLength - 1;
    b.putBytes(Ac.substr(0, d.blockLength - w));
    for (var C, T, k = d.fullMessageLength[0] * 8, q = 0; q < d.fullMessageLength.length - 1; ++q)
      C = d.fullMessageLength[q + 1] * 8, T = C / 4294967296 >>> 0, k += T, b.putInt32(k >>> 0), k = C >>> 0;
    b.putInt32(k);
    for (var O = new Array(o.length), q = 0; q < o.length; ++q)
      O[q] = o[q].slice(0);
    Yp(O, h, b);
    var N = Ft.util.createBuffer(), j;
    e === "SHA-512" ? j = O.length : e === "SHA-384" ? j = O.length - 2 : j = O.length - 4;
    for (var q = 0; q < j; ++q)
      N.putInt32(O[q][0]), (q !== j - 1 || e !== "SHA-512/224") && N.putInt32(O[q][1]);
    return N;
  }, d;
};
var Ac = null, W2 = !1, Bc = null, Kn = null;
function JI() {
  Ac = "", Ac += Ft.util.fillString("\0", 128), Bc = [
    [1116352408, 3609767458],
    [1899447441, 602891725],
    [3049323471, 3964484399],
    [3921009573, 2173295548],
    [961987163, 4081628472],
    [1508970993, 3053834265],
    [2453635748, 2937671579],
    [2870763221, 3664609560],
    [3624381080, 2734883394],
    [310598401, 1164996542],
    [607225278, 1323610764],
    [1426881987, 3590304994],
    [1925078388, 4068182383],
    [2162078206, 991336113],
    [2614888103, 633803317],
    [3248222580, 3479774868],
    [3835390401, 2666613458],
    [4022224774, 944711139],
    [264347078, 2341262773],
    [604807628, 2007800933],
    [770255983, 1495990901],
    [1249150122, 1856431235],
    [1555081692, 3175218132],
    [1996064986, 2198950837],
    [2554220882, 3999719339],
    [2821834349, 766784016],
    [2952996808, 2566594879],
    [3210313671, 3203337956],
    [3336571891, 1034457026],
    [3584528711, 2466948901],
    [113926993, 3758326383],
    [338241895, 168717936],
    [666307205, 1188179964],
    [773529912, 1546045734],
    [1294757372, 1522805485],
    [1396182291, 2643833823],
    [1695183700, 2343527390],
    [1986661051, 1014477480],
    [2177026350, 1206759142],
    [2456956037, 344077627],
    [2730485921, 1290863460],
    [2820302411, 3158454273],
    [3259730800, 3505952657],
    [3345764771, 106217008],
    [3516065817, 3606008344],
    [3600352804, 1432725776],
    [4094571909, 1467031594],
    [275423344, 851169720],
    [430227734, 3100823752],
    [506948616, 1363258195],
    [659060556, 3750685593],
    [883997877, 3785050280],
    [958139571, 3318307427],
    [1322822218, 3812723403],
    [1537002063, 2003034995],
    [1747873779, 3602036899],
    [1955562222, 1575990012],
    [2024104815, 1125592928],
    [2227730452, 2716904306],
    [2361852424, 442776044],
    [2428436474, 593698344],
    [2756734187, 3733110249],
    [3204031479, 2999351573],
    [3329325298, 3815920427],
    [3391569614, 3928383900],
    [3515267271, 566280711],
    [3940187606, 3454069534],
    [4118630271, 4000239992],
    [116418474, 1914138554],
    [174292421, 2731055270],
    [289380356, 3203993006],
    [460393269, 320620315],
    [685471733, 587496836],
    [852142971, 1086792851],
    [1017036298, 365543100],
    [1126000580, 2618297676],
    [1288033470, 3409855158],
    [1501505948, 4234509866],
    [1607167915, 987167468],
    [1816402316, 1246189591]
  ], Kn = {}, Kn["SHA-512"] = [
    [1779033703, 4089235720],
    [3144134277, 2227873595],
    [1013904242, 4271175723],
    [2773480762, 1595750129],
    [1359893119, 2917565137],
    [2600822924, 725511199],
    [528734635, 4215389547],
    [1541459225, 327033209]
  ], Kn["SHA-384"] = [
    [3418070365, 3238371032],
    [1654270250, 914150663],
    [2438529370, 812702999],
    [355462360, 4144912697],
    [1731405415, 4290775857],
    [2394180231, 1750603025],
    [3675008525, 1694076839],
    [1203062813, 3204075428]
  ], Kn["SHA-512/256"] = [
    [573645204, 4230739756],
    [2673172387, 3360449730],
    [596883563, 1867755857],
    [2520282905, 1497426621],
    [2519219938, 2827943907],
    [3193839141, 1401305490],
    [721525244, 746961066],
    [246885852, 2177182882]
  ], Kn["SHA-512/224"] = [
    [2352822216, 424955298],
    [1944164710, 2312950998],
    [502970286, 855612546],
    [1738396948, 1479516111],
    [258812777, 2077511080],
    [2011393907, 79989058],
    [1067287976, 1780299464],
    [286451373, 2446758561]
  ], W2 = !0;
}
function Yp(e, t, o) {
  for (var r, h, a, p, d, b, g, w, C, T, k, q, O, N, j, U, H, z, ee, ne, le, Z, ie, fe, I, P, f, y, v, M, B, S, _, E, m, A = o.length(); A >= 128; ) {
    for (v = 0; v < 16; ++v)
      t[v][0] = o.getInt32() >>> 0, t[v][1] = o.getInt32() >>> 0;
    for (; v < 80; ++v)
      S = t[v - 2], M = S[0], B = S[1], r = ((M >>> 19 | B << 13) ^ // ROTR 19
      (B >>> 29 | M << 3) ^ // ROTR 61/(swap + ROTR 29)
      M >>> 6) >>> 0, h = ((M << 13 | B >>> 19) ^ // ROTR 19
      (B << 3 | M >>> 29) ^ // ROTR 61/(swap + ROTR 29)
      (M << 26 | B >>> 6)) >>> 0, E = t[v - 15], M = E[0], B = E[1], a = ((M >>> 1 | B << 31) ^ // ROTR 1
      (M >>> 8 | B << 24) ^ // ROTR 8
      M >>> 7) >>> 0, p = ((M << 31 | B >>> 1) ^ // ROTR 1
      (M << 24 | B >>> 8) ^ // ROTR 8
      (M << 25 | B >>> 7)) >>> 0, _ = t[v - 7], m = t[v - 16], B = h + _[1] + p + m[1], t[v][0] = r + _[0] + a + m[0] + (B / 4294967296 >>> 0) >>> 0, t[v][1] = B >>> 0;
    for (O = e[0][0], N = e[0][1], j = e[1][0], U = e[1][1], H = e[2][0], z = e[2][1], ee = e[3][0], ne = e[3][1], le = e[4][0], Z = e[4][1], ie = e[5][0], fe = e[5][1], I = e[6][0], P = e[6][1], f = e[7][0], y = e[7][1], v = 0; v < 80; ++v)
      g = ((le >>> 14 | Z << 18) ^ // ROTR 14
      (le >>> 18 | Z << 14) ^ // ROTR 18
      (Z >>> 9 | le << 23)) >>> 0, w = ((le << 18 | Z >>> 14) ^ // ROTR 14
      (le << 14 | Z >>> 18) ^ // ROTR 18
      (Z << 23 | le >>> 9)) >>> 0, C = (I ^ le & (ie ^ I)) >>> 0, T = (P ^ Z & (fe ^ P)) >>> 0, d = ((O >>> 28 | N << 4) ^ // ROTR 28
      (N >>> 2 | O << 30) ^ // ROTR 34/(swap + ROTR 2)
      (N >>> 7 | O << 25)) >>> 0, b = ((O << 4 | N >>> 28) ^ // ROTR 28
      (N << 30 | O >>> 2) ^ // ROTR 34/(swap + ROTR 2)
      (N << 25 | O >>> 7)) >>> 0, k = (O & j | H & (O ^ j)) >>> 0, q = (N & U | z & (N ^ U)) >>> 0, B = y + w + T + Bc[v][1] + t[v][1], r = f + g + C + Bc[v][0] + t[v][0] + (B / 4294967296 >>> 0) >>> 0, h = B >>> 0, B = b + q, a = d + k + (B / 4294967296 >>> 0) >>> 0, p = B >>> 0, f = I, y = P, I = ie, P = fe, ie = le, fe = Z, B = ne + h, le = ee + r + (B / 4294967296 >>> 0) >>> 0, Z = B >>> 0, ee = H, ne = z, H = j, z = U, j = O, U = N, B = h + p, O = r + a + (B / 4294967296 >>> 0) >>> 0, N = B >>> 0;
    B = e[0][1] + N, e[0][0] = e[0][0] + O + (B / 4294967296 >>> 0) >>> 0, e[0][1] = B >>> 0, B = e[1][1] + U, e[1][0] = e[1][0] + j + (B / 4294967296 >>> 0) >>> 0, e[1][1] = B >>> 0, B = e[2][1] + z, e[2][0] = e[2][0] + H + (B / 4294967296 >>> 0) >>> 0, e[2][1] = B >>> 0, B = e[3][1] + ne, e[3][0] = e[3][0] + ee + (B / 4294967296 >>> 0) >>> 0, e[3][1] = B >>> 0, B = e[4][1] + Z, e[4][0] = e[4][0] + le + (B / 4294967296 >>> 0) >>> 0, e[4][1] = B >>> 0, B = e[5][1] + fe, e[5][0] = e[5][0] + ie + (B / 4294967296 >>> 0) >>> 0, e[5][1] = B >>> 0, B = e[6][1] + P, e[6][0] = e[6][0] + I + (B / 4294967296 >>> 0) >>> 0, e[6][1] = B >>> 0, B = e[7][1] + y, e[7][0] = e[7][0] + f + (B / 4294967296 >>> 0) >>> 0, e[7][1] = B >>> 0, A -= 128;
  }
}
var jh = {}, eT = ht, Xt = eT.asn1;
jh.privateKeyValidator = {
  // PrivateKeyInfo
  name: "PrivateKeyInfo",
  tagClass: Xt.Class.UNIVERSAL,
  type: Xt.Type.SEQUENCE,
  constructed: !0,
  value: [{
    // Version (INTEGER)
    name: "PrivateKeyInfo.version",
    tagClass: Xt.Class.UNIVERSAL,
    type: Xt.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyVersion"
  }, {
    // privateKeyAlgorithm
    name: "PrivateKeyInfo.privateKeyAlgorithm",
    tagClass: Xt.Class.UNIVERSAL,
    type: Xt.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: Xt.Class.UNIVERSAL,
      type: Xt.Type.OID,
      constructed: !1,
      capture: "privateKeyOid"
    }]
  }, {
    // PrivateKey
    name: "PrivateKeyInfo",
    tagClass: Xt.Class.UNIVERSAL,
    type: Xt.Type.OCTETSTRING,
    constructed: !1,
    capture: "privateKey"
  }]
};
jh.publicKeyValidator = {
  name: "SubjectPublicKeyInfo",
  tagClass: Xt.Class.UNIVERSAL,
  type: Xt.Type.SEQUENCE,
  constructed: !0,
  captureAsn1: "subjectPublicKeyInfo",
  value: [
    {
      name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
      tagClass: Xt.Class.UNIVERSAL,
      type: Xt.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: Xt.Class.UNIVERSAL,
        type: Xt.Type.OID,
        constructed: !1,
        capture: "publicKeyOid"
      }]
    },
    // capture group for ed25519PublicKey
    {
      tagClass: Xt.Class.UNIVERSAL,
      type: Xt.Type.BITSTRING,
      constructed: !1,
      composed: !0,
      captureBitStringValue: "ed25519PublicKey"
    }
    // FIXME: this is capture group for rsaPublicKey, use it in this API or
    // discard?
    /* {
      // subjectPublicKey
      name: 'SubjectPublicKeyInfo.subjectPublicKey',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.BITSTRING,
      constructed: false,
      value: [{
        // RSAPublicKey
        name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        optional: true,
        captureAsn1: 'rsaPublicKey'
      }]
    } */
  ]
};
var sr = ht, Y2 = jh, tT = Y2.publicKeyValidator, rT = Y2.privateKeyValidator;
if (typeof iT > "u")
  var iT = sr.jsbn.BigInteger;
var Ic = sr.util.ByteBuffer, Tr = typeof pe.Buffer > "u" ? Uint8Array : pe.Buffer;
sr.pki = sr.pki || {};
sr.pki.ed25519 = sr.ed25519 = sr.ed25519 || {};
var dt = sr.ed25519;
dt.constants = {};
dt.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
dt.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
dt.constants.SEED_BYTE_LENGTH = 32;
dt.constants.SIGN_BYTE_LENGTH = 64;
dt.constants.HASH_BYTE_LENGTH = 64;
dt.generateKeyPair = function(e) {
  e = e || {};
  var t = e.seed;
  if (t === void 0)
    t = sr.random.getBytesSync(dt.constants.SEED_BYTE_LENGTH);
  else if (typeof t == "string") {
    if (t.length !== dt.constants.SEED_BYTE_LENGTH)
      throw new TypeError(
        '"seed" must be ' + dt.constants.SEED_BYTE_LENGTH + " bytes in length."
      );
  } else if (!(t instanceof Uint8Array))
    throw new TypeError(
      '"seed" must be a node.js Buffer, Uint8Array, or a binary string.'
    );
  t = an({ message: t, encoding: "binary" });
  for (var o = new Tr(dt.constants.PUBLIC_KEY_BYTE_LENGTH), r = new Tr(dt.constants.PRIVATE_KEY_BYTE_LENGTH), h = 0; h < 32; ++h)
    r[h] = t[h];
  return fT(o, r), { publicKey: o, privateKey: r };
};
dt.privateKeyFromAsn1 = function(e) {
  var t = {}, o = [], r = sr.asn1.validate(e, rT, t, o);
  if (!r) {
    var h = new Error("Invalid Key.");
    throw h.errors = o, h;
  }
  var a = sr.asn1.derToOid(t.privateKeyOid), p = sr.oids.EdDSA25519;
  if (a !== p)
    throw new Error('Invalid OID "' + a + '"; OID must be "' + p + '".');
  var d = t.privateKey, b = an({
    message: sr.asn1.fromDer(d).value,
    encoding: "binary"
  });
  return { privateKeyBytes: b };
};
dt.publicKeyFromAsn1 = function(e) {
  var t = {}, o = [], r = sr.asn1.validate(e, tT, t, o);
  if (!r) {
    var h = new Error("Invalid Key.");
    throw h.errors = o, h;
  }
  var a = sr.asn1.derToOid(t.publicKeyOid), p = sr.oids.EdDSA25519;
  if (a !== p)
    throw new Error('Invalid OID "' + a + '"; OID must be "' + p + '".');
  var d = t.ed25519PublicKey;
  if (d.length !== dt.constants.PUBLIC_KEY_BYTE_LENGTH)
    throw new Error("Key length is invalid.");
  return an({
    message: d,
    encoding: "binary"
  });
};
dt.publicKeyFromPrivateKey = function(e) {
  e = e || {};
  var t = an({
    message: e.privateKey,
    encoding: "binary"
  });
  if (t.length !== dt.constants.PRIVATE_KEY_BYTE_LENGTH)
    throw new TypeError(
      '"options.privateKey" must have a byte length of ' + dt.constants.PRIVATE_KEY_BYTE_LENGTH
    );
  for (var o = new Tr(dt.constants.PUBLIC_KEY_BYTE_LENGTH), r = 0; r < o.length; ++r)
    o[r] = t[32 + r];
  return o;
};
dt.sign = function(e) {
  e = e || {};
  var t = an(e), o = an({
    message: e.privateKey,
    encoding: "binary"
  });
  if (o.length === dt.constants.SEED_BYTE_LENGTH) {
    var r = dt.generateKeyPair({ seed: o });
    o = r.privateKey;
  } else if (o.length !== dt.constants.PRIVATE_KEY_BYTE_LENGTH)
    throw new TypeError(
      '"options.privateKey" must have a byte length of ' + dt.constants.SEED_BYTE_LENGTH + " or " + dt.constants.PRIVATE_KEY_BYTE_LENGTH
    );
  var h = new Tr(
    dt.constants.SIGN_BYTE_LENGTH + t.length
  );
  oT(h, t, t.length, o);
  for (var a = new Tr(dt.constants.SIGN_BYTE_LENGTH), p = 0; p < a.length; ++p)
    a[p] = h[p];
  return a;
};
dt.verify = function(e) {
  e = e || {};
  var t = an(e);
  if (e.signature === void 0)
    throw new TypeError(
      '"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'
    );
  var o = an({
    message: e.signature,
    encoding: "binary"
  });
  if (o.length !== dt.constants.SIGN_BYTE_LENGTH)
    throw new TypeError(
      '"options.signature" must have a byte length of ' + dt.constants.SIGN_BYTE_LENGTH
    );
  var r = an({
    message: e.publicKey,
    encoding: "binary"
  });
  if (r.length !== dt.constants.PUBLIC_KEY_BYTE_LENGTH)
    throw new TypeError(
      '"options.publicKey" must have a byte length of ' + dt.constants.PUBLIC_KEY_BYTE_LENGTH
    );
  var h = new Tr(dt.constants.SIGN_BYTE_LENGTH + t.length), a = new Tr(dt.constants.SIGN_BYTE_LENGTH + t.length), p;
  for (p = 0; p < dt.constants.SIGN_BYTE_LENGTH; ++p)
    h[p] = o[p];
  for (p = 0; p < t.length; ++p)
    h[p + dt.constants.SIGN_BYTE_LENGTH] = t[p];
  return uT(a, h, h.length, r) >= 0;
};
function an(e) {
  var t = e.message;
  if (t instanceof Uint8Array || t instanceof Tr)
    return t;
  var o = e.encoding;
  if (t === void 0)
    if (e.md)
      t = e.md.digest().getBytes(), o = "binary";
    else
      throw new TypeError('"options.message" or "options.md" not specified.');
  if (typeof t == "string" && !o)
    throw new TypeError('"options.encoding" must be "binary" or "utf8".');
  if (typeof t == "string") {
    if (typeof pe.Buffer < "u")
      return pe.Buffer.from(t, o);
    t = new Ic(t, o);
  } else if (!(t instanceof Ic))
    throw new TypeError(
      '"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.'
    );
  for (var r = new Tr(t.length()), h = 0; h < r.length; ++h)
    r[h] = t.at(h);
  return r;
}
var Tc = We(), Ks = We([1]), nT = We([
  30883,
  4953,
  19914,
  30187,
  55467,
  16705,
  2637,
  112,
  59544,
  30585,
  16505,
  36039,
  65139,
  11119,
  27886,
  20995
]), aT = We([
  61785,
  9906,
  39828,
  60374,
  45398,
  33411,
  5274,
  224,
  53552,
  61171,
  33010,
  6542,
  64743,
  22239,
  55772,
  9222
]), Xp = We([
  54554,
  36645,
  11616,
  51542,
  42930,
  38181,
  51040,
  26924,
  56412,
  64982,
  57905,
  49316,
  21502,
  52590,
  14035,
  8553
]), Qp = We([
  26200,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214
]), $u = new Float64Array([
  237,
  211,
  245,
  92,
  26,
  99,
  18,
  88,
  214,
  156,
  247,
  162,
  222,
  249,
  222,
  20,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  16
]), sT = We([
  41136,
  18958,
  6951,
  50414,
  58488,
  44335,
  6150,
  12099,
  55207,
  15867,
  153,
  11085,
  57099,
  20417,
  9344,
  11139
]);
function S0(e, t) {
  var o = sr.md.sha512.create(), r = new Ic(e);
  o.update(r.getBytes(t), "binary");
  var h = o.digest().getBytes();
  if (typeof pe.Buffer < "u")
    return pe.Buffer.from(h, "binary");
  for (var a = new Tr(dt.constants.HASH_BYTE_LENGTH), p = 0; p < 64; ++p)
    a[p] = h.charCodeAt(p);
  return a;
}
function fT(e, t) {
  var o = [We(), We(), We(), We()], r, h = S0(t, 32);
  for (h[0] &= 248, h[31] &= 127, h[31] |= 64, Yh(o, h), Wh(e, o), r = 0; r < 32; ++r)
    t[r + 32] = e[r];
  return 0;
}
function oT(e, t, o, r) {
  var h, a, p = new Float64Array(64), d = [We(), We(), We(), We()], b = S0(r, 32);
  b[0] &= 248, b[31] &= 127, b[31] |= 64;
  var g = o + 64;
  for (h = 0; h < o; ++h)
    e[64 + h] = t[h];
  for (h = 0; h < 32; ++h)
    e[32 + h] = b[32 + h];
  var w = S0(e.subarray(32), o + 32);
  for (Mc(w), Yh(d, w), Wh(e, d), h = 32; h < 64; ++h)
    e[h] = r[h];
  var C = S0(e, o + 64);
  for (Mc(C), h = 32; h < 64; ++h)
    p[h] = 0;
  for (h = 0; h < 32; ++h)
    p[h] = w[h];
  for (h = 0; h < 32; ++h)
    for (a = 0; a < 32; a++)
      p[h + a] += C[h] * b[a];
  return X2(e.subarray(32), p), g;
}
function uT(e, t, o, r) {
  var h, a, p = new Tr(32), d = [We(), We(), We(), We()], b = [We(), We(), We(), We()];
  if (a = -1, o < 64 || cT(b, r))
    return -1;
  for (h = 0; h < o; ++h)
    e[h] = t[h];
  for (h = 0; h < 32; ++h)
    e[h + 32] = r[h];
  var g = S0(e, o);
  if (Mc(g), J2(d, b, g), Yh(b, t.subarray(32)), Rc(d, b), Wh(p, d), o -= 64, Q2(t, 0, p, 0)) {
    for (h = 0; h < o; ++h)
      e[h] = 0;
    return -1;
  }
  for (h = 0; h < o; ++h)
    e[h] = t[h + 64];
  return a = o, a;
}
function X2(e, t) {
  var o, r, h, a;
  for (r = 63; r >= 32; --r) {
    for (o = 0, h = r - 32, a = r - 12; h < a; ++h)
      t[h] += o - 16 * t[r] * $u[h - (r - 32)], o = t[h] + 128 >> 8, t[h] -= o * 256;
    t[h] += o, t[r] = 0;
  }
  for (o = 0, h = 0; h < 32; ++h)
    t[h] += o - (t[31] >> 4) * $u[h], o = t[h] >> 8, t[h] &= 255;
  for (h = 0; h < 32; ++h)
    t[h] -= o * $u[h];
  for (r = 0; r < 32; ++r)
    t[r + 1] += t[r] >> 8, e[r] = t[r] & 255;
}
function Mc(e) {
  for (var t = new Float64Array(64), o = 0; o < 64; ++o)
    t[o] = e[o], e[o] = 0;
  X2(e, t);
}
function Rc(e, t) {
  var o = We(), r = We(), h = We(), a = We(), p = We(), d = We(), b = We(), g = We(), w = We();
  ma(o, e[1], e[0]), ma(w, t[1], t[0]), Nt(o, o, w), pa(r, e[0], e[1]), pa(w, t[0], t[1]), Nt(r, r, w), Nt(h, e[3], t[3]), Nt(h, h, aT), Nt(a, e[2], t[2]), pa(a, a, a), ma(p, r, o), ma(d, a, h), pa(b, a, h), pa(g, r, o), Nt(e[0], p, d), Nt(e[1], g, b), Nt(e[2], b, d), Nt(e[3], p, g);
}
function Zp(e, t, o) {
  for (var r = 0; r < 4; ++r)
    eg(e[r], t[r], o);
}
function Wh(e, t) {
  var o = We(), r = We(), h = We();
  pT(h, t[2]), Nt(o, t[0], h), Nt(r, t[1], h), $s(e, r), e[31] ^= Z2(o) << 7;
}
function $s(e, t) {
  var o, r, h, a = We(), p = We();
  for (o = 0; o < 16; ++o)
    p[o] = t[o];
  for (Hu(p), Hu(p), Hu(p), r = 0; r < 2; ++r) {
    for (a[0] = p[0] - 65517, o = 1; o < 15; ++o)
      a[o] = p[o] - 65535 - (a[o - 1] >> 16 & 1), a[o - 1] &= 65535;
    a[15] = p[15] - 32767 - (a[14] >> 16 & 1), h = a[15] >> 16 & 1, a[14] &= 65535, eg(p, a, 1 - h);
  }
  for (o = 0; o < 16; o++)
    e[2 * o] = p[o] & 255, e[2 * o + 1] = p[o] >> 8;
}
function cT(e, t) {
  var o = We(), r = We(), h = We(), a = We(), p = We(), d = We(), b = We();
  return xn(e[2], Ks), hT(e[1], t), $n(h, e[1]), Nt(a, h, nT), ma(h, h, e[2]), pa(a, e[2], a), $n(p, a), $n(d, p), Nt(b, d, p), Nt(o, b, h), Nt(o, o, a), lT(o, o), Nt(o, o, h), Nt(o, o, a), Nt(o, o, a), Nt(e[0], o, a), $n(r, e[0]), Nt(r, r, a), Jp(r, h) && Nt(e[0], e[0], sT), $n(r, e[0]), Nt(r, r, a), Jp(r, h) ? -1 : (Z2(e[0]) === t[31] >> 7 && ma(e[0], Tc, e[0]), Nt(e[3], e[0], e[1]), 0);
}
function hT(e, t) {
  var o;
  for (o = 0; o < 16; ++o)
    e[o] = t[2 * o] + (t[2 * o + 1] << 8);
  e[15] &= 32767;
}
function lT(e, t) {
  var o = We(), r;
  for (r = 0; r < 16; ++r)
    o[r] = t[r];
  for (r = 250; r >= 0; --r)
    $n(o, o), r !== 1 && Nt(o, o, t);
  for (r = 0; r < 16; ++r)
    e[r] = o[r];
}
function Jp(e, t) {
  var o = new Tr(32), r = new Tr(32);
  return $s(o, e), $s(r, t), Q2(o, 0, r, 0);
}
function Q2(e, t, o, r) {
  return dT(e, t, o, r, 32);
}
function dT(e, t, o, r, h) {
  var a, p = 0;
  for (a = 0; a < h; ++a)
    p |= e[t + a] ^ o[r + a];
  return (1 & p - 1 >>> 8) - 1;
}
function Z2(e) {
  var t = new Tr(32);
  return $s(t, e), t[0] & 1;
}
function J2(e, t, o) {
  var r, h;
  for (xn(e[0], Tc), xn(e[1], Ks), xn(e[2], Ks), xn(e[3], Tc), h = 255; h >= 0; --h)
    r = o[h / 8 | 0] >> (h & 7) & 1, Zp(e, t, r), Rc(t, e), Rc(e, e), Zp(e, t, r);
}
function Yh(e, t) {
  var o = [We(), We(), We(), We()];
  xn(o[0], Xp), xn(o[1], Qp), xn(o[2], Ks), Nt(o[3], Xp, Qp), J2(e, o, t);
}
function xn(e, t) {
  var o;
  for (o = 0; o < 16; o++)
    e[o] = t[o] | 0;
}
function pT(e, t) {
  var o = We(), r;
  for (r = 0; r < 16; ++r)
    o[r] = t[r];
  for (r = 253; r >= 0; --r)
    $n(o, o), r !== 2 && r !== 4 && Nt(o, o, t);
  for (r = 0; r < 16; ++r)
    e[r] = o[r];
}
function Hu(e) {
  var t, o, r = 1;
  for (t = 0; t < 16; ++t)
    o = e[t] + r + 65535, r = Math.floor(o / 65536), e[t] = o - r * 65536;
  e[0] += r - 1 + 37 * (r - 1);
}
function eg(e, t, o) {
  for (var r, h = ~(o - 1), a = 0; a < 16; ++a)
    r = h & (e[a] ^ t[a]), e[a] ^= r, t[a] ^= r;
}
function We(e) {
  var t, o = new Float64Array(16);
  if (e)
    for (t = 0; t < e.length; ++t)
      o[t] = e[t];
  return o;
}
function pa(e, t, o) {
  for (var r = 0; r < 16; ++r)
    e[r] = t[r] + o[r];
}
function ma(e, t, o) {
  for (var r = 0; r < 16; ++r)
    e[r] = t[r] - o[r];
}
function $n(e, t) {
  Nt(e, t, t);
}
function Nt(e, t, o) {
  var r, h, a = 0, p = 0, d = 0, b = 0, g = 0, w = 0, C = 0, T = 0, k = 0, q = 0, O = 0, N = 0, j = 0, U = 0, H = 0, z = 0, ee = 0, ne = 0, le = 0, Z = 0, ie = 0, fe = 0, I = 0, P = 0, f = 0, y = 0, v = 0, M = 0, B = 0, S = 0, _ = 0, E = o[0], m = o[1], A = o[2], $ = o[3], X = o[4], oe = o[5], J = o[6], W = o[7], Q = o[8], me = o[9], be = o[10], Y = o[11], re = o[12], de = o[13], Ae = o[14], qe = o[15];
  r = t[0], a += r * E, p += r * m, d += r * A, b += r * $, g += r * X, w += r * oe, C += r * J, T += r * W, k += r * Q, q += r * me, O += r * be, N += r * Y, j += r * re, U += r * de, H += r * Ae, z += r * qe, r = t[1], p += r * E, d += r * m, b += r * A, g += r * $, w += r * X, C += r * oe, T += r * J, k += r * W, q += r * Q, O += r * me, N += r * be, j += r * Y, U += r * re, H += r * de, z += r * Ae, ee += r * qe, r = t[2], d += r * E, b += r * m, g += r * A, w += r * $, C += r * X, T += r * oe, k += r * J, q += r * W, O += r * Q, N += r * me, j += r * be, U += r * Y, H += r * re, z += r * de, ee += r * Ae, ne += r * qe, r = t[3], b += r * E, g += r * m, w += r * A, C += r * $, T += r * X, k += r * oe, q += r * J, O += r * W, N += r * Q, j += r * me, U += r * be, H += r * Y, z += r * re, ee += r * de, ne += r * Ae, le += r * qe, r = t[4], g += r * E, w += r * m, C += r * A, T += r * $, k += r * X, q += r * oe, O += r * J, N += r * W, j += r * Q, U += r * me, H += r * be, z += r * Y, ee += r * re, ne += r * de, le += r * Ae, Z += r * qe, r = t[5], w += r * E, C += r * m, T += r * A, k += r * $, q += r * X, O += r * oe, N += r * J, j += r * W, U += r * Q, H += r * me, z += r * be, ee += r * Y, ne += r * re, le += r * de, Z += r * Ae, ie += r * qe, r = t[6], C += r * E, T += r * m, k += r * A, q += r * $, O += r * X, N += r * oe, j += r * J, U += r * W, H += r * Q, z += r * me, ee += r * be, ne += r * Y, le += r * re, Z += r * de, ie += r * Ae, fe += r * qe, r = t[7], T += r * E, k += r * m, q += r * A, O += r * $, N += r * X, j += r * oe, U += r * J, H += r * W, z += r * Q, ee += r * me, ne += r * be, le += r * Y, Z += r * re, ie += r * de, fe += r * Ae, I += r * qe, r = t[8], k += r * E, q += r * m, O += r * A, N += r * $, j += r * X, U += r * oe, H += r * J, z += r * W, ee += r * Q, ne += r * me, le += r * be, Z += r * Y, ie += r * re, fe += r * de, I += r * Ae, P += r * qe, r = t[9], q += r * E, O += r * m, N += r * A, j += r * $, U += r * X, H += r * oe, z += r * J, ee += r * W, ne += r * Q, le += r * me, Z += r * be, ie += r * Y, fe += r * re, I += r * de, P += r * Ae, f += r * qe, r = t[10], O += r * E, N += r * m, j += r * A, U += r * $, H += r * X, z += r * oe, ee += r * J, ne += r * W, le += r * Q, Z += r * me, ie += r * be, fe += r * Y, I += r * re, P += r * de, f += r * Ae, y += r * qe, r = t[11], N += r * E, j += r * m, U += r * A, H += r * $, z += r * X, ee += r * oe, ne += r * J, le += r * W, Z += r * Q, ie += r * me, fe += r * be, I += r * Y, P += r * re, f += r * de, y += r * Ae, v += r * qe, r = t[12], j += r * E, U += r * m, H += r * A, z += r * $, ee += r * X, ne += r * oe, le += r * J, Z += r * W, ie += r * Q, fe += r * me, I += r * be, P += r * Y, f += r * re, y += r * de, v += r * Ae, M += r * qe, r = t[13], U += r * E, H += r * m, z += r * A, ee += r * $, ne += r * X, le += r * oe, Z += r * J, ie += r * W, fe += r * Q, I += r * me, P += r * be, f += r * Y, y += r * re, v += r * de, M += r * Ae, B += r * qe, r = t[14], H += r * E, z += r * m, ee += r * A, ne += r * $, le += r * X, Z += r * oe, ie += r * J, fe += r * W, I += r * Q, P += r * me, f += r * be, y += r * Y, v += r * re, M += r * de, B += r * Ae, S += r * qe, r = t[15], z += r * E, ee += r * m, ne += r * A, le += r * $, Z += r * X, ie += r * oe, fe += r * J, I += r * W, P += r * Q, f += r * me, y += r * be, v += r * Y, M += r * re, B += r * de, S += r * Ae, _ += r * qe, a += 38 * ee, p += 38 * ne, d += 38 * le, b += 38 * Z, g += 38 * ie, w += 38 * fe, C += 38 * I, T += 38 * P, k += 38 * f, q += 38 * y, O += 38 * v, N += 38 * M, j += 38 * B, U += 38 * S, H += 38 * _, h = 1, r = a + h + 65535, h = Math.floor(r / 65536), a = r - h * 65536, r = p + h + 65535, h = Math.floor(r / 65536), p = r - h * 65536, r = d + h + 65535, h = Math.floor(r / 65536), d = r - h * 65536, r = b + h + 65535, h = Math.floor(r / 65536), b = r - h * 65536, r = g + h + 65535, h = Math.floor(r / 65536), g = r - h * 65536, r = w + h + 65535, h = Math.floor(r / 65536), w = r - h * 65536, r = C + h + 65535, h = Math.floor(r / 65536), C = r - h * 65536, r = T + h + 65535, h = Math.floor(r / 65536), T = r - h * 65536, r = k + h + 65535, h = Math.floor(r / 65536), k = r - h * 65536, r = q + h + 65535, h = Math.floor(r / 65536), q = r - h * 65536, r = O + h + 65535, h = Math.floor(r / 65536), O = r - h * 65536, r = N + h + 65535, h = Math.floor(r / 65536), N = r - h * 65536, r = j + h + 65535, h = Math.floor(r / 65536), j = r - h * 65536, r = U + h + 65535, h = Math.floor(r / 65536), U = r - h * 65536, r = H + h + 65535, h = Math.floor(r / 65536), H = r - h * 65536, r = z + h + 65535, h = Math.floor(r / 65536), z = r - h * 65536, a += h - 1 + 37 * (h - 1), h = 1, r = a + h + 65535, h = Math.floor(r / 65536), a = r - h * 65536, r = p + h + 65535, h = Math.floor(r / 65536), p = r - h * 65536, r = d + h + 65535, h = Math.floor(r / 65536), d = r - h * 65536, r = b + h + 65535, h = Math.floor(r / 65536), b = r - h * 65536, r = g + h + 65535, h = Math.floor(r / 65536), g = r - h * 65536, r = w + h + 65535, h = Math.floor(r / 65536), w = r - h * 65536, r = C + h + 65535, h = Math.floor(r / 65536), C = r - h * 65536, r = T + h + 65535, h = Math.floor(r / 65536), T = r - h * 65536, r = k + h + 65535, h = Math.floor(r / 65536), k = r - h * 65536, r = q + h + 65535, h = Math.floor(r / 65536), q = r - h * 65536, r = O + h + 65535, h = Math.floor(r / 65536), O = r - h * 65536, r = N + h + 65535, h = Math.floor(r / 65536), N = r - h * 65536, r = j + h + 65535, h = Math.floor(r / 65536), j = r - h * 65536, r = U + h + 65535, h = Math.floor(r / 65536), U = r - h * 65536, r = H + h + 65535, h = Math.floor(r / 65536), H = r - h * 65536, r = z + h + 65535, h = Math.floor(r / 65536), z = r - h * 65536, a += h - 1 + 37 * (h - 1), e[0] = a, e[1] = p, e[2] = d, e[3] = b, e[4] = g, e[5] = w, e[6] = C, e[7] = T, e[8] = k, e[9] = q, e[10] = O, e[11] = N, e[12] = j, e[13] = U, e[14] = H, e[15] = z;
}
var Nr = ht;
Nr.kem = Nr.kem || {};
var e1 = Nr.jsbn.BigInteger;
Nr.kem.rsa = {};
Nr.kem.rsa.create = function(e, t) {
  t = t || {};
  var o = t.prng || Nr.random, r = {};
  return r.encrypt = function(h, a) {
    var p = Math.ceil(h.n.bitLength() / 8), d;
    do
      d = new e1(
        Nr.util.bytesToHex(o.getBytesSync(p)),
        16
      ).mod(h.n);
    while (d.compareTo(e1.ONE) <= 0);
    d = Nr.util.hexToBytes(d.toString(16));
    var b = p - d.length;
    b > 0 && (d = Nr.util.fillString("\0", b) + d);
    var g = h.encrypt(d, "NONE"), w = e.generate(d, a);
    return { encapsulation: g, key: w };
  }, r.decrypt = function(h, a, p) {
    var d = h.decrypt(a, "NONE");
    return e.generate(d, p);
  }, r;
};
Nr.kem.kdf1 = function(e, t) {
  tg(this, e, 0, t || e.digestLength);
};
Nr.kem.kdf2 = function(e, t) {
  tg(this, e, 1, t || e.digestLength);
};
function tg(e, t, o, r) {
  e.generate = function(h, a) {
    for (var p = new Nr.util.ByteBuffer(), d = Math.ceil(a / r) + o, b = new Nr.util.ByteBuffer(), g = o; g < d; ++g) {
      b.putInt32(g), t.start(), t.update(h + b.getBytes());
      var w = t.digest();
      p.putBytes(w.getBytes(r));
    }
    return p.truncate(p.length() - a), p.getBytes();
  };
}
var yt = ht;
yt.log = yt.log || {};
yt.log.levels = [
  "none",
  "error",
  "warning",
  "info",
  "debug",
  "verbose",
  "max"
];
var Hs = {}, Nc = [], w0 = null;
yt.log.LEVEL_LOCKED = 2;
yt.log.NO_LEVEL_CHECK = 4;
yt.log.INTERPOLATE = 8;
for (var _n = 0; _n < yt.log.levels.length; ++_n) {
  var t1 = yt.log.levels[_n];
  Hs[t1] = {
    index: _n,
    name: t1.toUpperCase()
  };
}
yt.log.logMessage = function(e) {
  for (var t = Hs[e.level].index, o = 0; o < Nc.length; ++o) {
    var r = Nc[o];
    if (r.flags & yt.log.NO_LEVEL_CHECK)
      r.f(e);
    else {
      var h = Hs[r.level].index;
      t <= h && r.f(r, e);
    }
  }
};
yt.log.prepareStandard = function(e) {
  "standard" in e || (e.standard = Hs[e.level].name + //' ' + +message.timestamp +
  " [" + e.category + "] " + e.message);
};
yt.log.prepareFull = function(e) {
  if (!("full" in e)) {
    var t = [e.message];
    t = t.concat([]), e.full = yt.util.format.apply(this, t);
  }
};
yt.log.prepareStandardFull = function(e) {
  "standardFull" in e || (yt.log.prepareStandard(e), e.standardFull = e.standard);
};
for (var r1 = ["error", "warning", "info", "debug", "verbose"], _n = 0; _n < r1.length; ++_n)
  (function(t) {
    yt.log[t] = function(o, r) {
      var h = Array.prototype.slice.call(arguments).slice(2), a = {
        timestamp: /* @__PURE__ */ new Date(),
        level: t,
        category: o,
        message: r,
        arguments: h
        /*standard*/
        /*full*/
        /*fullMessage*/
      };
      yt.log.logMessage(a);
    };
  })(r1[_n]);
yt.log.makeLogger = function(e) {
  var t = {
    flags: 0,
    f: e
  };
  return yt.log.setLevel(t, "none"), t;
};
yt.log.setLevel = function(e, t) {
  var o = !1;
  if (e && !(e.flags & yt.log.LEVEL_LOCKED))
    for (var r = 0; r < yt.log.levels.length; ++r) {
      var h = yt.log.levels[r];
      if (t == h) {
        e.level = t, o = !0;
        break;
      }
    }
  return o;
};
yt.log.lock = function(e, t) {
  typeof t > "u" || t ? e.flags |= yt.log.LEVEL_LOCKED : e.flags &= ~yt.log.LEVEL_LOCKED;
};
yt.log.addLogger = function(e) {
  Nc.push(e);
};
if (typeof console < "u" && "log" in console) {
  var d0;
  if (console.error && console.warn && console.info && console.debug) {
    var vT = {
      error: console.error,
      warning: console.warn,
      info: console.info,
      debug: console.debug,
      verbose: console.debug
    }, Xh = function(e, t) {
      yt.log.prepareStandard(t);
      var o = vT[t.level], r = [t.standard];
      r = r.concat(t.arguments.slice()), o.apply(console, r);
    };
    d0 = yt.log.makeLogger(Xh);
  } else {
    var Xh = function(t, o) {
      yt.log.prepareStandardFull(o), console.log(o.standardFull);
    };
    d0 = yt.log.makeLogger(Xh);
  }
  yt.log.setLevel(d0, "debug"), yt.log.addLogger(d0), w0 = d0;
} else
  console = {
    log: function() {
    }
  };
if (w0 !== null && typeof window < "u" && window.location) {
  var fs = new URL(window.location.href).searchParams;
  if (fs.has("console.level") && yt.log.setLevel(
    w0,
    fs.get("console.level").slice(-1)[0]
  ), fs.has("console.lock")) {
    var yT = fs.get("console.lock").slice(-1)[0];
    yT == "true" && yt.log.lock(w0);
  }
}
yt.log.consoleLogger = w0;
var Be = ht, ae = Be.asn1, br = Be.pkcs7 = Be.pkcs7 || {};
br.messageFromPem = function(e) {
  var t = Be.pem.decode(e)[0];
  if (t.type !== "PKCS7") {
    var o = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
    throw o.headerType = t.type, o;
  }
  if (t.procType && t.procType.type === "ENCRYPTED")
    throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
  var r = ae.fromDer(t.body);
  return br.messageFromAsn1(r);
};
br.messageToPem = function(e, t) {
  var o = {
    type: "PKCS7",
    body: ae.toDer(e.toAsn1()).getBytes()
  };
  return Be.pem.encode(o, { maxline: t });
};
br.messageFromAsn1 = function(e) {
  var t = {}, o = [];
  if (!ae.validate(e, br.asn1.contentInfoValidator, t, o)) {
    var r = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
    throw r.errors = o, r;
  }
  var h = ae.derToOid(t.contentType), a;
  switch (h) {
    case Be.pki.oids.envelopedData:
      a = br.createEnvelopedData();
      break;
    case Be.pki.oids.encryptedData:
      a = br.createEncryptedData();
      break;
    case Be.pki.oids.signedData:
      a = br.createSignedData();
      break;
    default:
      throw new Error("Cannot read PKCS#7 message. ContentType with OID " + h + " is not (yet) supported.");
  }
  return a.fromAsn1(t.content.value[0]), a;
};
br.createSignedData = function() {
  var e = null;
  return e = {
    type: Be.pki.oids.signedData,
    version: 1,
    certificates: [],
    crls: [],
    // TODO: add json-formatted signer stuff here?
    signers: [],
    // populated during sign()
    digestAlgorithmIdentifiers: [],
    contentInfo: null,
    signerInfos: [],
    fromAsn1: function(r) {
      if (Qh(e, r, br.asn1.signedDataValidator), e.certificates = [], e.crls = [], e.digestAlgorithmIdentifiers = [], e.contentInfo = null, e.signerInfos = [], e.rawCapture.certificates)
        for (var h = e.rawCapture.certificates.value, a = 0; a < h.length; ++a)
          e.certificates.push(Be.pki.certificateFromAsn1(h[a]));
    },
    toAsn1: function() {
      e.contentInfo || e.sign();
      for (var r = [], h = 0; h < e.certificates.length; ++h)
        r.push(Be.pki.certificateToAsn1(e.certificates[h]));
      var a = [], p = ae.create(ae.Class.CONTEXT_SPECIFIC, 0, !0, [
        ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
          // Version
          ae.create(
            ae.Class.UNIVERSAL,
            ae.Type.INTEGER,
            !1,
            ae.integerToDer(e.version).getBytes()
          ),
          // DigestAlgorithmIdentifiers
          ae.create(
            ae.Class.UNIVERSAL,
            ae.Type.SET,
            !0,
            e.digestAlgorithmIdentifiers
          ),
          // ContentInfo
          e.contentInfo
        ])
      ]);
      return r.length > 0 && p.value[0].value.push(
        ae.create(ae.Class.CONTEXT_SPECIFIC, 0, !0, r)
      ), a.length > 0 && p.value[0].value.push(
        ae.create(ae.Class.CONTEXT_SPECIFIC, 1, !0, a)
      ), p.value[0].value.push(
        ae.create(
          ae.Class.UNIVERSAL,
          ae.Type.SET,
          !0,
          e.signerInfos
        )
      ), ae.create(
        ae.Class.UNIVERSAL,
        ae.Type.SEQUENCE,
        !0,
        [
          // ContentType
          ae.create(
            ae.Class.UNIVERSAL,
            ae.Type.OID,
            !1,
            ae.oidToDer(e.type).getBytes()
          ),
          // [0] SignedData
          p
        ]
      );
    },
    /**
     * Add (another) entity to list of signers.
     *
     * Note: If authenticatedAttributes are provided, then, per RFC 2315,
     * they must include at least two attributes: content type and
     * message digest. The message digest attribute value will be
     * auto-calculated during signing and will be ignored if provided.
     *
     * Here's an example of providing these two attributes:
     *
     * forge.pkcs7.createSignedData();
     * p7.addSigner({
     *   issuer: cert.issuer.attributes,
     *   serialNumber: cert.serialNumber,
     *   key: privateKey,
     *   digestAlgorithm: forge.pki.oids.sha1,
     *   authenticatedAttributes: [{
     *     type: forge.pki.oids.contentType,
     *     value: forge.pki.oids.data
     *   }, {
     *     type: forge.pki.oids.messageDigest
     *   }]
     * });
     *
     * TODO: Support [subjectKeyIdentifier] as signer's ID.
     *
     * @param signer the signer information:
     *          key the signer's private key.
     *          [certificate] a certificate containing the public key
     *            associated with the signer's private key; use this option as
     *            an alternative to specifying signer.issuer and
     *            signer.serialNumber.
     *          [issuer] the issuer attributes (eg: cert.issuer.attributes).
     *          [serialNumber] the signer's certificate's serial number in
     *           hexadecimal (eg: cert.serialNumber).
     *          [digestAlgorithm] the message digest OID, as a string, to use
     *            (eg: forge.pki.oids.sha1).
     *          [authenticatedAttributes] an optional array of attributes
     *            to also sign along with the content.
     */
    addSigner: function(r) {
      var h = r.issuer, a = r.serialNumber;
      if (r.certificate) {
        var p = r.certificate;
        typeof p == "string" && (p = Be.pki.certificateFromPem(p)), h = p.issuer.attributes, a = p.serialNumber;
      }
      var d = r.key;
      if (!d)
        throw new Error(
          "Could not add PKCS#7 signer; no private key specified."
        );
      typeof d == "string" && (d = Be.pki.privateKeyFromPem(d));
      var b = r.digestAlgorithm || Be.pki.oids.sha1;
      switch (b) {
        case Be.pki.oids.sha1:
        case Be.pki.oids.sha256:
        case Be.pki.oids.sha384:
        case Be.pki.oids.sha512:
        case Be.pki.oids.md5:
          break;
        default:
          throw new Error(
            "Could not add PKCS#7 signer; unknown message digest algorithm: " + b
          );
      }
      var g = r.authenticatedAttributes || [];
      if (g.length > 0) {
        for (var w = !1, C = !1, T = 0; T < g.length; ++T) {
          var k = g[T];
          if (!w && k.type === Be.pki.oids.contentType) {
            if (w = !0, C)
              break;
            continue;
          }
          if (!C && k.type === Be.pki.oids.messageDigest) {
            if (C = !0, w)
              break;
            continue;
          }
        }
        if (!w || !C)
          throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
      }
      e.signers.push({
        key: d,
        version: 1,
        issuer: h,
        serialNumber: a,
        digestAlgorithm: b,
        signatureAlgorithm: Be.pki.oids.rsaEncryption,
        signature: null,
        authenticatedAttributes: g,
        unauthenticatedAttributes: []
      });
    },
    /**
     * Signs the content.
     * @param options Options to apply when signing:
     *    [detached] boolean. If signing should be done in detached mode. Defaults to false.
     */
    sign: function(r) {
      if (r = r || {}, (typeof e.content != "object" || e.contentInfo === null) && (e.contentInfo = ae.create(
        ae.Class.UNIVERSAL,
        ae.Type.SEQUENCE,
        !0,
        [
          // ContentType
          ae.create(
            ae.Class.UNIVERSAL,
            ae.Type.OID,
            !1,
            ae.oidToDer(Be.pki.oids.data).getBytes()
          )
        ]
      ), "content" in e)) {
        var h;
        e.content instanceof Be.util.ByteBuffer ? h = e.content.bytes() : typeof e.content == "string" && (h = Be.util.encodeUtf8(e.content)), r.detached ? e.detachedContent = ae.create(ae.Class.UNIVERSAL, ae.Type.OCTETSTRING, !1, h) : e.contentInfo.value.push(
          // [0] EXPLICIT content
          ae.create(ae.Class.CONTEXT_SPECIFIC, 0, !0, [
            ae.create(
              ae.Class.UNIVERSAL,
              ae.Type.OCTETSTRING,
              !1,
              h
            )
          ])
        );
      }
      if (e.signers.length !== 0) {
        var a = t();
        o(a);
      }
    },
    verify: function() {
      throw new Error("PKCS#7 signature verification not yet implemented.");
    },
    /**
     * Add a certificate.
     *
     * @param cert the certificate to add.
     */
    addCertificate: function(r) {
      typeof r == "string" && (r = Be.pki.certificateFromPem(r)), e.certificates.push(r);
    },
    /**
     * Add a certificate revokation list.
     *
     * @param crl the certificate revokation list to add.
     */
    addCertificateRevokationList: function(r) {
      throw new Error("PKCS#7 CRL support not yet implemented.");
    }
  }, e;
  function t() {
    for (var r = {}, h = 0; h < e.signers.length; ++h) {
      var a = e.signers[h], p = a.digestAlgorithm;
      p in r || (r[p] = Be.md[Be.pki.oids[p]].create()), a.authenticatedAttributes.length === 0 ? a.md = r[p] : a.md = Be.md[Be.pki.oids[p]].create();
    }
    e.digestAlgorithmIdentifiers = [];
    for (var p in r)
      e.digestAlgorithmIdentifiers.push(
        // AlgorithmIdentifier
        ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
          // algorithm
          ae.create(
            ae.Class.UNIVERSAL,
            ae.Type.OID,
            !1,
            ae.oidToDer(p).getBytes()
          ),
          // parameters (null)
          ae.create(ae.Class.UNIVERSAL, ae.Type.NULL, !1, "")
        ])
      );
    return r;
  }
  function o(r) {
    var h;
    if (e.detachedContent ? h = e.detachedContent : (h = e.contentInfo.value[1], h = h.value[0]), !h)
      throw new Error(
        "Could not sign PKCS#7 message; there is no content to sign."
      );
    var a = ae.derToOid(e.contentInfo.value[0].value), p = ae.toDer(h);
    p.getByte(), ae.getBerValueLength(p), p = p.getBytes();
    for (var d in r)
      r[d].start().update(p);
    for (var b = /* @__PURE__ */ new Date(), g = 0; g < e.signers.length; ++g) {
      var w = e.signers[g];
      if (w.authenticatedAttributes.length === 0) {
        if (a !== Be.pki.oids.data)
          throw new Error(
            "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data."
          );
      } else {
        w.authenticatedAttributesAsn1 = ae.create(
          ae.Class.CONTEXT_SPECIFIC,
          0,
          !0,
          []
        );
        for (var C = ae.create(
          ae.Class.UNIVERSAL,
          ae.Type.SET,
          !0,
          []
        ), T = 0; T < w.authenticatedAttributes.length; ++T) {
          var k = w.authenticatedAttributes[T];
          k.type === Be.pki.oids.messageDigest ? k.value = r[w.digestAlgorithm].digest() : k.type === Be.pki.oids.signingTime && (k.value || (k.value = b)), C.value.push(Dc(k)), w.authenticatedAttributesAsn1.value.push(Dc(k));
        }
        p = ae.toDer(C).getBytes(), w.md.start().update(p);
      }
      w.signature = w.key.sign(w.md, "RSASSA-PKCS1-V1_5");
    }
    e.signerInfos = ET(e.signers);
  }
};
br.createEncryptedData = function() {
  var e = null;
  return e = {
    type: Be.pki.oids.encryptedData,
    version: 0,
    encryptedContent: {
      algorithm: Be.pki.oids["aes256-CBC"]
    },
    /**
     * Reads an EncryptedData content block (in ASN.1 format)
     *
     * @param obj The ASN.1 representation of the EncryptedData content block
     */
    fromAsn1: function(t) {
      Qh(e, t, br.asn1.encryptedDataValidator);
    },
    /**
     * Decrypt encrypted content
     *
     * @param key The (symmetric) key as a byte buffer
     */
    decrypt: function(t) {
      t !== void 0 && (e.encryptedContent.key = t), rg(e);
    }
  }, e;
};
br.createEnvelopedData = function() {
  var e = null;
  return e = {
    type: Be.pki.oids.envelopedData,
    version: 0,
    recipients: [],
    encryptedContent: {
      algorithm: Be.pki.oids["aes256-CBC"]
    },
    /**
     * Reads an EnvelopedData content block (in ASN.1 format)
     *
     * @param obj the ASN.1 representation of the EnvelopedData content block.
     */
    fromAsn1: function(t) {
      var o = Qh(e, t, br.asn1.envelopedDataValidator);
      e.recipients = bT(o.recipientInfos.value);
    },
    toAsn1: function() {
      return ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
        // ContentType
        ae.create(
          ae.Class.UNIVERSAL,
          ae.Type.OID,
          !1,
          ae.oidToDer(e.type).getBytes()
        ),
        // [0] EnvelopedData
        ae.create(ae.Class.CONTEXT_SPECIFIC, 0, !0, [
          ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
            // Version
            ae.create(
              ae.Class.UNIVERSAL,
              ae.Type.INTEGER,
              !1,
              ae.integerToDer(e.version).getBytes()
            ),
            // RecipientInfos
            ae.create(
              ae.Class.UNIVERSAL,
              ae.Type.SET,
              !0,
              xT(e.recipients)
            ),
            // EncryptedContentInfo
            ae.create(
              ae.Class.UNIVERSAL,
              ae.Type.SEQUENCE,
              !0,
              ST(e.encryptedContent)
            )
          ])
        ])
      ]);
    },
    /**
     * Find recipient by X.509 certificate's issuer.
     *
     * @param cert the certificate with the issuer to look for.
     *
     * @return the recipient object.
     */
    findRecipient: function(t) {
      for (var o = t.issuer.attributes, r = 0; r < e.recipients.length; ++r) {
        var h = e.recipients[r], a = h.issuer;
        if (h.serialNumber === t.serialNumber && a.length === o.length) {
          for (var p = !0, d = 0; d < o.length; ++d)
            if (a[d].type !== o[d].type || a[d].value !== o[d].value) {
              p = !1;
              break;
            }
          if (p)
            return h;
        }
      }
      return null;
    },
    /**
     * Decrypt enveloped content
     *
     * @param recipient The recipient object related to the private key
     * @param privKey The (RSA) private key object
     */
    decrypt: function(t, o) {
      if (e.encryptedContent.key === void 0 && t !== void 0 && o !== void 0)
        switch (t.encryptedContent.algorithm) {
          case Be.pki.oids.rsaEncryption:
          case Be.pki.oids.desCBC:
            var r = o.decrypt(t.encryptedContent.content);
            e.encryptedContent.key = Be.util.createBuffer(r);
            break;
          default:
            throw new Error("Unsupported asymmetric cipher, OID " + t.encryptedContent.algorithm);
        }
      rg(e);
    },
    /**
     * Add (another) entity to list of recipients.
     *
     * @param cert The certificate of the entity to add.
     */
    addRecipient: function(t) {
      e.recipients.push({
        version: 0,
        issuer: t.issuer.attributes,
        serialNumber: t.serialNumber,
        encryptedContent: {
          // We simply assume rsaEncryption here, since forge.pki only
          // supports RSA so far.  If the PKI module supports other
          // ciphers one day, we need to modify this one as well.
          algorithm: Be.pki.oids.rsaEncryption,
          key: t.publicKey
        }
      });
    },
    /**
     * Encrypt enveloped content.
     *
     * This function supports two optional arguments, cipher and key, which
     * can be used to influence symmetric encryption.  Unless cipher is
     * provided, the cipher specified in encryptedContent.algorithm is used
     * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key
     * is (re-)used.  If that one's not set, a random key will be generated
     * automatically.
     *
     * @param [key] The key to be used for symmetric encryption.
     * @param [cipher] The OID of the symmetric cipher to use.
     */
    encrypt: function(t, o) {
      if (e.encryptedContent.content === void 0) {
        o = o || e.encryptedContent.algorithm, t = t || e.encryptedContent.key;
        var r, h, a;
        switch (o) {
          case Be.pki.oids["aes128-CBC"]:
            r = 16, h = 16, a = Be.aes.createEncryptionCipher;
            break;
          case Be.pki.oids["aes192-CBC"]:
            r = 24, h = 16, a = Be.aes.createEncryptionCipher;
            break;
          case Be.pki.oids["aes256-CBC"]:
            r = 32, h = 16, a = Be.aes.createEncryptionCipher;
            break;
          case Be.pki.oids["des-EDE3-CBC"]:
            r = 24, h = 8, a = Be.des.createEncryptionCipher;
            break;
          default:
            throw new Error("Unsupported symmetric cipher, OID " + o);
        }
        if (t === void 0)
          t = Be.util.createBuffer(Be.random.getBytes(r));
        else if (t.length() != r)
          throw new Error("Symmetric key has wrong length; got " + t.length() + " bytes, expected " + r + ".");
        e.encryptedContent.algorithm = o, e.encryptedContent.key = t, e.encryptedContent.parameter = Be.util.createBuffer(
          Be.random.getBytes(h)
        );
        var p = a(t);
        if (p.start(e.encryptedContent.parameter.copy()), p.update(e.content), !p.finish())
          throw new Error("Symmetric encryption failed.");
        e.encryptedContent.content = p.output;
      }
      for (var d = 0; d < e.recipients.length; ++d) {
        var b = e.recipients[d];
        if (b.encryptedContent.content === void 0)
          switch (b.encryptedContent.algorithm) {
            case Be.pki.oids.rsaEncryption:
              b.encryptedContent.content = b.encryptedContent.key.encrypt(
                e.encryptedContent.key.data
              );
              break;
            default:
              throw new Error("Unsupported asymmetric cipher, OID " + b.encryptedContent.algorithm);
          }
      }
    }
  }, e;
};
function gT(e) {
  var t = {}, o = [];
  if (!ae.validate(e, br.asn1.recipientInfoValidator, t, o)) {
    var r = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
    throw r.errors = o, r;
  }
  return {
    version: t.version.charCodeAt(0),
    issuer: Be.pki.RDNAttributesAsArray(t.issuer),
    serialNumber: Be.util.createBuffer(t.serial).toHex(),
    encryptedContent: {
      algorithm: ae.derToOid(t.encAlgorithm),
      parameter: t.encParameter ? t.encParameter.value : void 0,
      content: t.encKey
    }
  };
}
function mT(e) {
  return ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
    // Version
    ae.create(
      ae.Class.UNIVERSAL,
      ae.Type.INTEGER,
      !1,
      ae.integerToDer(e.version).getBytes()
    ),
    // IssuerAndSerialNumber
    ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
      // Name
      Be.pki.distinguishedNameToAsn1({ attributes: e.issuer }),
      // Serial
      ae.create(
        ae.Class.UNIVERSAL,
        ae.Type.INTEGER,
        !1,
        Be.util.hexToBytes(e.serialNumber)
      )
    ]),
    // KeyEncryptionAlgorithmIdentifier
    ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
      // Algorithm
      ae.create(
        ae.Class.UNIVERSAL,
        ae.Type.OID,
        !1,
        ae.oidToDer(e.encryptedContent.algorithm).getBytes()
      ),
      // Parameter, force NULL, only RSA supported for now.
      ae.create(ae.Class.UNIVERSAL, ae.Type.NULL, !1, "")
    ]),
    // EncryptedKey
    ae.create(
      ae.Class.UNIVERSAL,
      ae.Type.OCTETSTRING,
      !1,
      e.encryptedContent.content
    )
  ]);
}
function bT(e) {
  for (var t = [], o = 0; o < e.length; ++o)
    t.push(gT(e[o]));
  return t;
}
function xT(e) {
  for (var t = [], o = 0; o < e.length; ++o)
    t.push(mT(e[o]));
  return t;
}
function _T(e) {
  var t = ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
    // version
    ae.create(
      ae.Class.UNIVERSAL,
      ae.Type.INTEGER,
      !1,
      ae.integerToDer(e.version).getBytes()
    ),
    // issuerAndSerialNumber
    ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
      // name
      Be.pki.distinguishedNameToAsn1({ attributes: e.issuer }),
      // serial
      ae.create(
        ae.Class.UNIVERSAL,
        ae.Type.INTEGER,
        !1,
        Be.util.hexToBytes(e.serialNumber)
      )
    ]),
    // digestAlgorithm
    ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
      // algorithm
      ae.create(
        ae.Class.UNIVERSAL,
        ae.Type.OID,
        !1,
        ae.oidToDer(e.digestAlgorithm).getBytes()
      ),
      // parameters (null)
      ae.create(ae.Class.UNIVERSAL, ae.Type.NULL, !1, "")
    ])
  ]);
  if (e.authenticatedAttributesAsn1 && t.value.push(e.authenticatedAttributesAsn1), t.value.push(ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
    // algorithm
    ae.create(
      ae.Class.UNIVERSAL,
      ae.Type.OID,
      !1,
      ae.oidToDer(e.signatureAlgorithm).getBytes()
    ),
    // parameters (null)
    ae.create(ae.Class.UNIVERSAL, ae.Type.NULL, !1, "")
  ])), t.value.push(ae.create(
    ae.Class.UNIVERSAL,
    ae.Type.OCTETSTRING,
    !1,
    e.signature
  )), e.unauthenticatedAttributes.length > 0) {
    for (var o = ae.create(ae.Class.CONTEXT_SPECIFIC, 1, !0, []), r = 0; r < e.unauthenticatedAttributes.length; ++r) {
      var h = e.unauthenticatedAttributes[r];
      o.values.push(Dc(h));
    }
    t.value.push(o);
  }
  return t;
}
function ET(e) {
  for (var t = [], o = 0; o < e.length; ++o)
    t.push(_T(e[o]));
  return t;
}
function Dc(e) {
  var t;
  if (e.type === Be.pki.oids.contentType)
    t = ae.create(
      ae.Class.UNIVERSAL,
      ae.Type.OID,
      !1,
      ae.oidToDer(e.value).getBytes()
    );
  else if (e.type === Be.pki.oids.messageDigest)
    t = ae.create(
      ae.Class.UNIVERSAL,
      ae.Type.OCTETSTRING,
      !1,
      e.value.bytes()
    );
  else if (e.type === Be.pki.oids.signingTime) {
    var o = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z"), r = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z"), h = e.value;
    if (typeof h == "string") {
      var a = Date.parse(h);
      isNaN(a) ? h.length === 13 ? h = ae.utcTimeToDate(h) : h = ae.generalizedTimeToDate(h) : h = new Date(a);
    }
    h >= o && h < r ? t = ae.create(
      ae.Class.UNIVERSAL,
      ae.Type.UTCTIME,
      !1,
      ae.dateToUtcTime(h)
    ) : t = ae.create(
      ae.Class.UNIVERSAL,
      ae.Type.GENERALIZEDTIME,
      !1,
      ae.dateToGeneralizedTime(h)
    );
  }
  return ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
    // AttributeType
    ae.create(
      ae.Class.UNIVERSAL,
      ae.Type.OID,
      !1,
      ae.oidToDer(e.type).getBytes()
    ),
    ae.create(ae.Class.UNIVERSAL, ae.Type.SET, !0, [
      // AttributeValue
      t
    ])
  ]);
}
function ST(e) {
  return [
    // ContentType, always Data for the moment
    ae.create(
      ae.Class.UNIVERSAL,
      ae.Type.OID,
      !1,
      ae.oidToDer(Be.pki.oids.data).getBytes()
    ),
    // ContentEncryptionAlgorithmIdentifier
    ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
      // Algorithm
      ae.create(
        ae.Class.UNIVERSAL,
        ae.Type.OID,
        !1,
        ae.oidToDer(e.algorithm).getBytes()
      ),
      // Parameters (IV)
      e.parameter ? ae.create(
        ae.Class.UNIVERSAL,
        ae.Type.OCTETSTRING,
        !1,
        e.parameter.getBytes()
      ) : void 0
    ]),
    // [0] EncryptedContent
    ae.create(ae.Class.CONTEXT_SPECIFIC, 0, !0, [
      ae.create(
        ae.Class.UNIVERSAL,
        ae.Type.OCTETSTRING,
        !1,
        e.content.getBytes()
      )
    ])
  ];
}
function Qh(e, t, o) {
  var r = {}, h = [];
  if (!ae.validate(t, o, r, h)) {
    var a = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
    throw a.errors = a, a;
  }
  var p = ae.derToOid(r.contentType);
  if (p !== Be.pki.oids.data)
    throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
  if (r.encryptedContent) {
    var d = "";
    if (Be.util.isArray(r.encryptedContent))
      for (var b = 0; b < r.encryptedContent.length; ++b) {
        if (r.encryptedContent[b].type !== ae.Type.OCTETSTRING)
          throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
        d += r.encryptedContent[b].value;
      }
    else
      d = r.encryptedContent;
    e.encryptedContent = {
      algorithm: ae.derToOid(r.encAlgorithm),
      parameter: Be.util.createBuffer(r.encParameter.value),
      content: Be.util.createBuffer(d)
    };
  }
  if (r.content) {
    var d = "";
    if (Be.util.isArray(r.content))
      for (var b = 0; b < r.content.length; ++b) {
        if (r.content[b].type !== ae.Type.OCTETSTRING)
          throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
        d += r.content[b].value;
      }
    else
      d = r.content;
    e.content = Be.util.createBuffer(d);
  }
  return e.version = r.version.charCodeAt(0), e.rawCapture = r, r;
}
function rg(e) {
  if (e.encryptedContent.key === void 0)
    throw new Error("Symmetric key not available.");
  if (e.content === void 0) {
    var t;
    switch (e.encryptedContent.algorithm) {
      case Be.pki.oids["aes128-CBC"]:
      case Be.pki.oids["aes192-CBC"]:
      case Be.pki.oids["aes256-CBC"]:
        t = Be.aes.createDecryptionCipher(e.encryptedContent.key);
        break;
      case Be.pki.oids.desCBC:
      case Be.pki.oids["des-EDE3-CBC"]:
        t = Be.des.createDecryptionCipher(e.encryptedContent.key);
        break;
      default:
        throw new Error("Unsupported symmetric cipher, OID " + e.encryptedContent.algorithm);
    }
    if (t.start(e.encryptedContent.parameter), t.update(e.encryptedContent.content), !t.finish())
      throw new Error("Symmetric decryption failed.");
    e.content = t.output;
  }
}
var Gt = ht, $f = Gt.ssh = Gt.ssh || {};
$f.privateKeyToPutty = function(e, t, o) {
  o = o || "", t = t || "";
  var r = "ssh-rsa", h = t === "" ? "none" : "aes256-cbc", a = "PuTTY-User-Key-File-2: " + r + `\r
`;
  a += "Encryption: " + h + `\r
`, a += "Comment: " + o + `\r
`;
  var p = Gt.util.createBuffer();
  ba(p, r), Oi(p, e.e), Oi(p, e.n);
  var d = Gt.util.encode64(p.bytes(), 64), b = Math.floor(d.length / 66) + 1;
  a += "Public-Lines: " + b + `\r
`, a += d;
  var g = Gt.util.createBuffer();
  Oi(g, e.d), Oi(g, e.p), Oi(g, e.q), Oi(g, e.qInv);
  var w;
  if (!t)
    w = Gt.util.encode64(g.bytes(), 64);
  else {
    var C = g.length() + 16 - 1;
    C -= C % 16;
    var T = os(g.bytes());
    T.truncate(T.length() - C + g.length()), g.putBuffer(T);
    var k = Gt.util.createBuffer();
    k.putBuffer(os("\0\0\0\0", t)), k.putBuffer(os("\0\0\0", t));
    var q = Gt.aes.createEncryptionCipher(k.truncate(8), "CBC");
    q.start(Gt.util.createBuffer().fillWithByte(0, 16)), q.update(g.copy()), q.finish();
    var O = q.output;
    O.truncate(16), w = Gt.util.encode64(O.bytes(), 64);
  }
  b = Math.floor(w.length / 66) + 1, a += `\r
Private-Lines: ` + b + `\r
`, a += w;
  var N = os("putty-private-key-file-mac-key", t), j = Gt.util.createBuffer();
  ba(j, r), ba(j, h), ba(j, o), j.putInt32(p.length()), j.putBuffer(p), j.putInt32(g.length()), j.putBuffer(g);
  var U = Gt.hmac.create();
  return U.start("sha1", N), U.update(j.bytes()), a += `\r
Private-MAC: ` + U.digest().toHex() + `\r
`, a;
};
$f.publicKeyToOpenSSH = function(e, t) {
  var o = "ssh-rsa";
  t = t || "";
  var r = Gt.util.createBuffer();
  return ba(r, o), Oi(r, e.e), Oi(r, e.n), o + " " + Gt.util.encode64(r.bytes()) + " " + t;
};
$f.privateKeyToOpenSSH = function(e, t) {
  return t ? Gt.pki.encryptRsaPrivateKey(
    e,
    t,
    { legacy: !0, algorithm: "aes128" }
  ) : Gt.pki.privateKeyToPem(e);
};
$f.getPublicKeyFingerprint = function(e, t) {
  t = t || {};
  var o = t.md || Gt.md.md5.create(), r = "ssh-rsa", h = Gt.util.createBuffer();
  ba(h, r), Oi(h, e.e), Oi(h, e.n), o.start(), o.update(h.getBytes());
  var a = o.digest();
  if (t.encoding === "hex") {
    var p = a.toHex();
    return t.delimiter ? p.match(/.{2}/g).join(t.delimiter) : p;
  } else {
    if (t.encoding === "binary")
      return a.getBytes();
    if (t.encoding)
      throw new Error('Unknown encoding "' + t.encoding + '".');
  }
  return a;
};
function Oi(e, t) {
  var o = t.toString(16);
  o[0] >= "8" && (o = "00" + o);
  var r = Gt.util.hexToBytes(o);
  e.putInt32(r.length), e.putBytes(r);
}
function ba(e, t) {
  e.putInt32(t.length), e.putString(t);
}
function os() {
  for (var e = Gt.md.sha1.create(), t = arguments.length, o = 0; o < t; ++o)
    e.update(arguments[o]);
  return e.digest();
}
var wT = ht;
const Fn = /* @__PURE__ */ Gs(wT), CT = "LS0tLS1CRUdJTiBSU0EgUFVCTElDIEtFWS0tLS0tCk1JSUJDZ0tDQVFFQXNobjY4alc0REFsQlFnWTd6SDJXQkJvVlU4NUpEZWpwRDluOW44Rm9zWkZZR2U5Yk1KLy8KUkpFLzNnZklEcWI4eitUbTBUb3BLdTFjRUlwQ21zcGtvc1ZldFFFWGFJWHJRQUhvWExOK2FLZjc1MEV5RDhMTQprOXRia21EMnlkWnFWZVFWQUxLNmVaVit4akZqNm4rTXVqTWZadTVldnQ2ekdBY1FyZ2xtaXZEYkc2Y2l6SlF2ClV2WDZ5NXlxVDQvSkhJKzErM0xXT3ZJRnhKSW4vWHRyY2lRUTZZcmZsQWlSZzNWM1lMMTF2Ykc4dnAzZG4xSjEKRk1XOVRDUElwTStvRkRIc3hGcW1hbHltNXl1K2ZGSmRwYnIxLzUxMmRISkJSUW9UNUtLNXhOWVJ0eVQxNWttSgpLNXlWdjJUTDhrQS9QeUZ0SmJHVXVTeml5NmhxeHBtWVd3SURBUUFCCi0tLS0tRU5EIFJTQSBQVUJMSUMgS0VZLS0tLS0K", p0 = ["IoTrust Root", "KR", "Seoul", "GangNam", "IoTrust"], v0 = ["Wepin", "KR", "Seoul", "GangNam", "IoTrust"], ig = {
  ...Cr.pad
};
function AT(e, t, o, r) {
  const h = Cr.enc.Hex.parse(e), a = Cr.enc.Hex.parse(t);
  return Cr.AES.encrypt(o, h, {
    iv: a,
    mode: Cr.mode.CBC,
    padding: ig[r]
  }).toString();
}
function BT(e, t, o, r) {
  const h = Cr.enc.Hex.parse(e), a = Cr.enc.Hex.parse(t);
  return Cr.AES.decrypt(o, h, {
    iv: a,
    mode: Cr.mode.CBC,
    padding: ig[r]
  }).toString(Cr.enc.Utf8);
}
function IT(e) {
  return Cr.lib.WordArray.random(e).toString(Cr.enc.Hex);
}
function TT(e, t) {
  const o = new kC();
  return e.includes("BEGIN RSA PUBLIC KEY") ? o.importKey(e, "pkcs1-public-pem") : o.importKey(e, "pkcs8-public-pem"), o.encrypt(t, "base64");
}
function ng(e) {
  const t = MT(e), o = IT(32), r = TT(t, o);
  return {
    DEK: o,
    encryptedDEK: r
  };
}
function i1() {
  return new Error("invalid certificate");
}
function MT(e) {
  const t = pe.Buffer.from(e, "base64").toString("utf8");
  if (t.includes("BEGIN RSA PUBLIC KEY"))
    return t;
  const o = t.split(/(?=-----BEGIN CERTIFICATE-----)/).filter((g) => g.trim()).map((g) => g.trim() + `
`), r = [];
  r.push(Fn.pki.certificateFromPem(o[0])), r.push(Fn.pki.certificateFromPem(o[1]));
  for (let g = o.length - 1; g > 0; g--)
    if (!r[g].verify(r[g - 1]))
      throw i1();
  const h = r[0], a = r[o.length - 1], p = Fn.pki.publicKeyFromPem(Fn.util.decode64(CT)), d = Fn.md.sha256.create();
  d.update(Fn.asn1.toDer(a.tbsCertificate).getBytes());
  const b = d.digest().getBytes();
  if (!p.verify(b, a.signature) || JSON.stringify(p) !== JSON.stringify(a.publicKey) || a.subject.attributes[0].value !== p0[0] || a.subject.attributes[1].value !== p0[1] || a.subject.attributes[2].value !== p0[2] || a.subject.attributes[3].value !== p0[3] || a.subject.attributes[4].value !== p0[4] || h.subject.attributes[0].value !== v0[0] || h.subject.attributes[1].value !== v0[1] || h.subject.attributes[2].value !== v0[2] || h.subject.attributes[3].value !== v0[3] || h.subject.attributes[4].value !== v0[4])
    throw i1();
  return Fn.pki.publicKeyToPem(h.publicKey);
}
const ag = {
  pin: "Pkcs7",
  mnemonic: "Iso97971"
}, sg = "00000000000000000000000000000000";
function Hf(e, t, o) {
  return AT(e, sg, t, ag[o]);
}
function RT(e, t) {
  return Hf(e, JSON.stringify(t), "pin");
}
function NT(e, t) {
  return Hf(e, t, "mnemonic");
}
function fg(e, t, o) {
  return BT(e, sg, t, ag[o]);
}
function DT(e, t) {
  return fg(e, t, "mnemonic");
}
async function OT(e, t) {
  const { DEK: o, encryptedDEK: r } = ng(e), h = Hf(o, JSON.stringify(t), "pin");
  return {
    b64SKey: r,
    b64Data: h
  };
}
function PT(e) {
  if (!/^\d{6,8}$/.test(e))
    throw new Error("Invalid UVD. UVD must be 6-8 digits.");
  return Cr.SHA256(e).toString(Cr.enc.Hex);
}
function LT(e) {
  let t = "";
  for (let o = 0; o < e.length; o++)
    o === 0 ? t += e[0] : o === 4 ? t += e[4] : t += "*";
  return {
    version: 1,
    length: pe.Buffer.from(e.length.toString(10), "utf8").toString("base64"),
    data: pe.Buffer.from(t, "utf8").toString("base64")
  };
}
const kT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createDataEncryptionKey: ng,
  decryptData: fg,
  decryptMnemonic: DT,
  encryptData: Hf,
  encryptMnemonic: NT,
  encryptUVD: RT,
  getEncUVD: OT,
  makeHint: LT,
  makeUVD: PT
}, Symbol.toStringTag, { value: "Module" })), VERIFY_CREATE = "create", VERIFY_PIN = "verify", getUVD = async (e, t, o) => {
  const r = kT.makeUVD(e);
  if (!r)
    throw new Error("Cannot make uvd");
  try {
    if ((o == null ? void 0 : o.type) === VERIFY_CREATE) {
      const b = await t.wepinApi.user.fetchKey();
      if (isErrorResponse(b))
        throw new Error("Cannot fetch key");
      const g = b.pubKey;
      if (!g)
        throw new Error("Cannot get pub key");
      return {
        UVD: await kT.getEncUVD(g, {
          nonce: 0,
          UVD: r
        }),
        hint: kT.makeHint(e)
      };
    }
    const h = await t.wepinApi.wallet.getWalletKeyInfo(
      {
        walletId: o == null ? void 0 : o.walletId
      },
      {
        userId: o == null ? void 0 : o.userId
      }
    );
    if (isErrorResponse(h))
      throw new Error("Cannot get wallet key info");
    if (Number.isNaN(Number(h == null ? void 0 : h.nonce)))
      throw new Error("Cannot get wallet key info");
    const a = h.b64PubKey, p = await kT.getEncUVD(a, {
      nonce: h.nonce,
      UVD: r
    }), d = await kT.getEncUVD(a, {
      nonce: h.nonce + 1,
      UVD: r
    });
    return { UVD: p, nextUVD: d };
  } catch (h) {
    throw new Error("Error occurred while getUVD" + h);
  }
}, NFTScheme = ["ERC721", "ERC1155"], NFTContentType = ["image", "video "];
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(e) {
  var t, o, r, h = U.prototype = { constructor: U, toString: null, valueOf: null }, a = new U(1), p = 20, d = 4, b = -7, g = 21, w = -1e7, C = 1e7, T = !1, k = 1, q = 0, O = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: " ",
    // non-breaking space
    suffix: ""
  }, N = "0123456789abcdefghijklmnopqrstuvwxyz", j = !0;
  function U(Z, ie) {
    var fe, I, P, f, y, v, M, B, S = this;
    if (!(S instanceof U))
      return new U(Z, ie);
    if (ie == null) {
      if (Z && Z._isBigNumber === !0) {
        S.s = Z.s, !Z.c || Z.e > C ? S.c = S.e = null : Z.e < w ? S.c = [S.e = 0] : (S.e = Z.e, S.c = Z.c.slice());
        return;
      }
      if ((v = typeof Z == "number") && Z * 0 == 0) {
        if (S.s = 1 / Z < 0 ? (Z = -Z, -1) : 1, Z === ~~Z) {
          for (f = 0, y = Z; y >= 10; y /= 10, f++)
            ;
          f > C ? S.c = S.e = null : (S.e = f, S.c = [Z]);
          return;
        }
        B = String(Z);
      } else {
        if (!isNumeric.test(B = String(Z)))
          return r(S, B, v);
        S.s = B.charCodeAt(0) == 45 ? (B = B.slice(1), -1) : 1;
      }
      (f = B.indexOf(".")) > -1 && (B = B.replace(".", "")), (y = B.search(/e/i)) > 0 ? (f < 0 && (f = y), f += +B.slice(y + 1), B = B.substring(0, y)) : f < 0 && (f = B.length);
    } else {
      if (intCheck(ie, 2, N.length, "Base"), ie == 10 && j)
        return S = new U(Z), ne(S, p + S.e + 1, d);
      if (B = String(Z), v = typeof Z == "number") {
        if (Z * 0 != 0)
          return r(S, B, v, ie);
        if (S.s = 1 / Z < 0 ? (B = B.slice(1), -1) : 1, U.DEBUG && B.replace(/^0\.0*|\./, "").length > 15)
          throw Error(tooManyDigits + Z);
      } else
        S.s = B.charCodeAt(0) === 45 ? (B = B.slice(1), -1) : 1;
      for (fe = N.slice(0, ie), f = y = 0, M = B.length; y < M; y++)
        if (fe.indexOf(I = B.charAt(y)) < 0) {
          if (I == ".") {
            if (y > f) {
              f = M;
              continue;
            }
          } else if (!P && (B == B.toUpperCase() && (B = B.toLowerCase()) || B == B.toLowerCase() && (B = B.toUpperCase()))) {
            P = !0, y = -1, f = 0;
            continue;
          }
          return r(S, String(Z), v, ie);
        }
      v = !1, B = o(B, ie, 10, S.s), (f = B.indexOf(".")) > -1 ? B = B.replace(".", "") : f = B.length;
    }
    for (y = 0; B.charCodeAt(y) === 48; y++)
      ;
    for (M = B.length; B.charCodeAt(--M) === 48; )
      ;
    if (B = B.slice(y, ++M)) {
      if (M -= y, v && U.DEBUG && M > 15 && (Z > MAX_SAFE_INTEGER || Z !== mathfloor(Z)))
        throw Error(tooManyDigits + S.s * Z);
      if ((f = f - y - 1) > C)
        S.c = S.e = null;
      else if (f < w)
        S.c = [S.e = 0];
      else {
        if (S.e = f, S.c = [], y = (f + 1) % LOG_BASE, f < 0 && (y += LOG_BASE), y < M) {
          for (y && S.c.push(+B.slice(0, y)), M -= LOG_BASE; y < M; )
            S.c.push(+B.slice(y, y += LOG_BASE));
          y = LOG_BASE - (B = B.slice(y)).length;
        } else
          y -= M;
        for (; y--; B += "0")
          ;
        S.c.push(+B);
      }
    } else
      S.c = [S.e = 0];
  }
  U.clone = clone, U.ROUND_UP = 0, U.ROUND_DOWN = 1, U.ROUND_CEIL = 2, U.ROUND_FLOOR = 3, U.ROUND_HALF_UP = 4, U.ROUND_HALF_DOWN = 5, U.ROUND_HALF_EVEN = 6, U.ROUND_HALF_CEIL = 7, U.ROUND_HALF_FLOOR = 8, U.EUCLID = 9, U.config = U.set = function(Z) {
    var ie, fe;
    if (Z != null)
      if (typeof Z == "object") {
        if (Z.hasOwnProperty(ie = "DECIMAL_PLACES") && (fe = Z[ie], intCheck(fe, 0, MAX, ie), p = fe), Z.hasOwnProperty(ie = "ROUNDING_MODE") && (fe = Z[ie], intCheck(fe, 0, 8, ie), d = fe), Z.hasOwnProperty(ie = "EXPONENTIAL_AT") && (fe = Z[ie], fe && fe.pop ? (intCheck(fe[0], -MAX, 0, ie), intCheck(fe[1], 0, MAX, ie), b = fe[0], g = fe[1]) : (intCheck(fe, -MAX, MAX, ie), b = -(g = fe < 0 ? -fe : fe))), Z.hasOwnProperty(ie = "RANGE"))
          if (fe = Z[ie], fe && fe.pop)
            intCheck(fe[0], -MAX, -1, ie), intCheck(fe[1], 1, MAX, ie), w = fe[0], C = fe[1];
          else if (intCheck(fe, -MAX, MAX, ie), fe)
            w = -(C = fe < 0 ? -fe : fe);
          else
            throw Error(bignumberError + ie + " cannot be zero: " + fe);
        if (Z.hasOwnProperty(ie = "CRYPTO"))
          if (fe = Z[ie], fe === !!fe)
            if (fe)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                T = fe;
              else
                throw T = !fe, Error(bignumberError + "crypto unavailable");
            else
              T = fe;
          else
            throw Error(bignumberError + ie + " not true or false: " + fe);
        if (Z.hasOwnProperty(ie = "MODULO_MODE") && (fe = Z[ie], intCheck(fe, 0, 9, ie), k = fe), Z.hasOwnProperty(ie = "POW_PRECISION") && (fe = Z[ie], intCheck(fe, 0, MAX, ie), q = fe), Z.hasOwnProperty(ie = "FORMAT"))
          if (fe = Z[ie], typeof fe == "object")
            O = fe;
          else
            throw Error(bignumberError + ie + " not an object: " + fe);
        if (Z.hasOwnProperty(ie = "ALPHABET"))
          if (fe = Z[ie], typeof fe == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(fe))
            j = fe.slice(0, 10) == "0123456789", N = fe;
          else
            throw Error(bignumberError + ie + " invalid: " + fe);
      } else
        throw Error(bignumberError + "Object expected: " + Z);
    return {
      DECIMAL_PLACES: p,
      ROUNDING_MODE: d,
      EXPONENTIAL_AT: [b, g],
      RANGE: [w, C],
      CRYPTO: T,
      MODULO_MODE: k,
      POW_PRECISION: q,
      FORMAT: O,
      ALPHABET: N
    };
  }, U.isBigNumber = function(Z) {
    if (!Z || Z._isBigNumber !== !0)
      return !1;
    if (!U.DEBUG)
      return !0;
    var ie, fe, I = Z.c, P = Z.e, f = Z.s;
    e:
      if ({}.toString.call(I) == "[object Array]") {
        if ((f === 1 || f === -1) && P >= -MAX && P <= MAX && P === mathfloor(P)) {
          if (I[0] === 0) {
            if (P === 0 && I.length === 1)
              return !0;
            break e;
          }
          if (ie = (P + 1) % LOG_BASE, ie < 1 && (ie += LOG_BASE), String(I[0]).length == ie) {
            for (ie = 0; ie < I.length; ie++)
              if (fe = I[ie], fe < 0 || fe >= BASE || fe !== mathfloor(fe))
                break e;
            if (fe !== 0)
              return !0;
          }
        }
      } else if (I === null && P === null && (f === null || f === 1 || f === -1))
        return !0;
    throw Error(bignumberError + "Invalid BigNumber: " + Z);
  }, U.maximum = U.max = function() {
    return z(arguments, -1);
  }, U.minimum = U.min = function() {
    return z(arguments, 1);
  }, U.random = function() {
    var Z = 9007199254740992, ie = Math.random() * Z & 2097151 ? function() {
      return mathfloor(Math.random() * Z);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function(fe) {
      var I, P, f, y, v, M = 0, B = [], S = new U(a);
      if (fe == null ? fe = p : intCheck(fe, 0, MAX), y = mathceil(fe / LOG_BASE), T)
        if (crypto.getRandomValues) {
          for (I = crypto.getRandomValues(new Uint32Array(y *= 2)); M < y; )
            v = I[M] * 131072 + (I[M + 1] >>> 11), v >= 9e15 ? (P = crypto.getRandomValues(new Uint32Array(2)), I[M] = P[0], I[M + 1] = P[1]) : (B.push(v % 1e14), M += 2);
          M = y / 2;
        } else if (crypto.randomBytes) {
          for (I = crypto.randomBytes(y *= 7); M < y; )
            v = (I[M] & 31) * 281474976710656 + I[M + 1] * 1099511627776 + I[M + 2] * 4294967296 + I[M + 3] * 16777216 + (I[M + 4] << 16) + (I[M + 5] << 8) + I[M + 6], v >= 9e15 ? crypto.randomBytes(7).copy(I, M) : (B.push(v % 1e14), M += 7);
          M = y / 7;
        } else
          throw T = !1, Error(bignumberError + "crypto unavailable");
      if (!T)
        for (; M < y; )
          v = ie(), v < 9e15 && (B[M++] = v % 1e14);
      for (y = B[--M], fe %= LOG_BASE, y && fe && (v = POWS_TEN[LOG_BASE - fe], B[M] = mathfloor(y / v) * v); B[M] === 0; B.pop(), M--)
        ;
      if (M < 0)
        B = [f = 0];
      else {
        for (f = -1; B[0] === 0; B.splice(0, 1), f -= LOG_BASE)
          ;
        for (M = 1, v = B[0]; v >= 10; v /= 10, M++)
          ;
        M < LOG_BASE && (f -= LOG_BASE - M);
      }
      return S.e = f, S.c = B, S;
    };
  }(), U.sum = function() {
    for (var Z = 1, ie = arguments, fe = new U(ie[0]); Z < ie.length; )
      fe = fe.plus(ie[Z++]);
    return fe;
  }, o = /* @__PURE__ */ function() {
    var Z = "0123456789";
    function ie(fe, I, P, f) {
      for (var y, v = [0], M, B = 0, S = fe.length; B < S; ) {
        for (M = v.length; M--; v[M] *= I)
          ;
        for (v[0] += f.indexOf(fe.charAt(B++)), y = 0; y < v.length; y++)
          v[y] > P - 1 && (v[y + 1] == null && (v[y + 1] = 0), v[y + 1] += v[y] / P | 0, v[y] %= P);
      }
      return v.reverse();
    }
    return function(fe, I, P, f, y) {
      var v, M, B, S, _, E, m, A, $ = fe.indexOf("."), X = p, oe = d;
      for ($ >= 0 && (S = q, q = 0, fe = fe.replace(".", ""), A = new U(I), E = A.pow(fe.length - $), q = S, A.c = ie(
        toFixedPoint(coeffToString(E.c), E.e, "0"),
        10,
        P,
        Z
      ), A.e = A.c.length), m = ie(fe, I, P, y ? (v = N, Z) : (v = Z, N)), B = S = m.length; m[--S] == 0; m.pop())
        ;
      if (!m[0])
        return v.charAt(0);
      if ($ < 0 ? --B : (E.c = m, E.e = B, E.s = f, E = t(E, A, X, oe, P), m = E.c, _ = E.r, B = E.e), M = B + X + 1, $ = m[M], S = P / 2, _ = _ || M < 0 || m[M + 1] != null, _ = oe < 4 ? ($ != null || _) && (oe == 0 || oe == (E.s < 0 ? 3 : 2)) : $ > S || $ == S && (oe == 4 || _ || oe == 6 && m[M - 1] & 1 || oe == (E.s < 0 ? 8 : 7)), M < 1 || !m[0])
        fe = _ ? toFixedPoint(v.charAt(1), -X, v.charAt(0)) : v.charAt(0);
      else {
        if (m.length = M, _)
          for (--P; ++m[--M] > P; )
            m[M] = 0, M || (++B, m = [1].concat(m));
        for (S = m.length; !m[--S]; )
          ;
        for ($ = 0, fe = ""; $ <= S; fe += v.charAt(m[$++]))
          ;
        fe = toFixedPoint(fe, B, v.charAt(0));
      }
      return fe;
    };
  }(), t = /* @__PURE__ */ function() {
    function Z(I, P, f) {
      var y, v, M, B, S = 0, _ = I.length, E = P % SQRT_BASE, m = P / SQRT_BASE | 0;
      for (I = I.slice(); _--; )
        M = I[_] % SQRT_BASE, B = I[_] / SQRT_BASE | 0, y = m * M + B * E, v = E * M + y % SQRT_BASE * SQRT_BASE + S, S = (v / f | 0) + (y / SQRT_BASE | 0) + m * B, I[_] = v % f;
      return S && (I = [S].concat(I)), I;
    }
    function ie(I, P, f, y) {
      var v, M;
      if (f != y)
        M = f > y ? 1 : -1;
      else
        for (v = M = 0; v < f; v++)
          if (I[v] != P[v]) {
            M = I[v] > P[v] ? 1 : -1;
            break;
          }
      return M;
    }
    function fe(I, P, f, y) {
      for (var v = 0; f--; )
        I[f] -= v, v = I[f] < P[f] ? 1 : 0, I[f] = v * y + I[f] - P[f];
      for (; !I[0] && I.length > 1; I.splice(0, 1))
        ;
    }
    return function(I, P, f, y, v) {
      var M, B, S, _, E, m, A, $, X, oe, J, W, Q, me, be, Y, re, de = I.s == P.s ? 1 : -1, Ae = I.c, qe = P.c;
      if (!Ae || !Ae[0] || !qe || !qe[0])
        return new U(
          // Return NaN if either NaN, or both Infinity or 0.
          !I.s || !P.s || (Ae ? qe && Ae[0] == qe[0] : !qe) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            Ae && Ae[0] == 0 || !qe ? de * 0 : de / 0
          )
        );
      for ($ = new U(de), X = $.c = [], B = I.e - P.e, de = f + B + 1, v || (v = BASE, B = bitFloor(I.e / LOG_BASE) - bitFloor(P.e / LOG_BASE), de = de / LOG_BASE | 0), S = 0; qe[S] == (Ae[S] || 0); S++)
        ;
      if (qe[S] > (Ae[S] || 0) && B--, de < 0)
        X.push(1), _ = !0;
      else {
        for (me = Ae.length, Y = qe.length, S = 0, de += 2, E = mathfloor(v / (qe[0] + 1)), E > 1 && (qe = Z(qe, E, v), Ae = Z(Ae, E, v), Y = qe.length, me = Ae.length), Q = Y, oe = Ae.slice(0, Y), J = oe.length; J < Y; oe[J++] = 0)
          ;
        re = qe.slice(), re = [0].concat(re), be = qe[0], qe[1] >= v / 2 && be++;
        do {
          if (E = 0, M = ie(qe, oe, Y, J), M < 0) {
            if (W = oe[0], Y != J && (W = W * v + (oe[1] || 0)), E = mathfloor(W / be), E > 1)
              for (E >= v && (E = v - 1), m = Z(qe, E, v), A = m.length, J = oe.length; ie(m, oe, A, J) == 1; )
                E--, fe(m, Y < A ? re : qe, A, v), A = m.length, M = 1;
            else
              E == 0 && (M = E = 1), m = qe.slice(), A = m.length;
            if (A < J && (m = [0].concat(m)), fe(oe, m, J, v), J = oe.length, M == -1)
              for (; ie(qe, oe, Y, J) < 1; )
                E++, fe(oe, Y < J ? re : qe, J, v), J = oe.length;
          } else
            M === 0 && (E++, oe = [0]);
          X[S++] = E, oe[0] ? oe[J++] = Ae[Q] || 0 : (oe = [Ae[Q]], J = 1);
        } while ((Q++ < me || oe[0] != null) && de--);
        _ = oe[0] != null, X[0] || X.splice(0, 1);
      }
      if (v == BASE) {
        for (S = 1, de = X[0]; de >= 10; de /= 10, S++)
          ;
        ne($, f + ($.e = S + B * LOG_BASE - 1) + 1, y, _);
      } else
        $.e = B, $.r = +_;
      return $;
    };
  }();
  function H(Z, ie, fe, I) {
    var P, f, y, v, M;
    if (fe == null ? fe = d : intCheck(fe, 0, 8), !Z.c)
      return Z.toString();
    if (P = Z.c[0], y = Z.e, ie == null)
      M = coeffToString(Z.c), M = I == 1 || I == 2 && (y <= b || y >= g) ? toExponential(M, y) : toFixedPoint(M, y, "0");
    else if (Z = ne(new U(Z), ie, fe), f = Z.e, M = coeffToString(Z.c), v = M.length, I == 1 || I == 2 && (ie <= f || f <= b)) {
      for (; v < ie; M += "0", v++)
        ;
      M = toExponential(M, f);
    } else if (ie -= y, M = toFixedPoint(M, f, "0"), f + 1 > v) {
      if (--ie > 0)
        for (M += "."; ie--; M += "0")
          ;
    } else if (ie += f - v, ie > 0)
      for (f + 1 == v && (M += "."); ie--; M += "0")
        ;
    return Z.s < 0 && P ? "-" + M : M;
  }
  function z(Z, ie) {
    for (var fe, I, P = 1, f = new U(Z[0]); P < Z.length; P++)
      I = new U(Z[P]), (!I.s || (fe = compare(f, I)) === ie || fe === 0 && f.s === ie) && (f = I);
    return f;
  }
  function ee(Z, ie, fe) {
    for (var I = 1, P = ie.length; !ie[--P]; ie.pop())
      ;
    for (P = ie[0]; P >= 10; P /= 10, I++)
      ;
    return (fe = I + fe * LOG_BASE - 1) > C ? Z.c = Z.e = null : fe < w ? Z.c = [Z.e = 0] : (Z.e = fe, Z.c = ie), Z;
  }
  r = /* @__PURE__ */ function() {
    var Z = /^(-?)0([xbo])(?=\w[\w.]*$)/i, ie = /^([^.]+)\.$/, fe = /^\.([^.]+)$/, I = /^-?(Infinity|NaN)$/, P = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(f, y, v, M) {
      var B, S = v ? y : y.replace(P, "");
      if (I.test(S))
        f.s = isNaN(S) ? null : S < 0 ? -1 : 1;
      else {
        if (!v && (S = S.replace(Z, function(_, E, m) {
          return B = (m = m.toLowerCase()) == "x" ? 16 : m == "b" ? 2 : 8, !M || M == B ? E : _;
        }), M && (B = M, S = S.replace(ie, "$1").replace(fe, "0.$1")), y != S))
          return new U(S, B);
        if (U.DEBUG)
          throw Error(bignumberError + "Not a" + (M ? " base " + M : "") + " number: " + y);
        f.s = null;
      }
      f.c = f.e = null;
    };
  }();
  function ne(Z, ie, fe, I) {
    var P, f, y, v, M, B, S, _ = Z.c, E = POWS_TEN;
    if (_) {
      e: {
        for (P = 1, v = _[0]; v >= 10; v /= 10, P++)
          ;
        if (f = ie - P, f < 0)
          f += LOG_BASE, y = ie, M = _[B = 0], S = mathfloor(M / E[P - y - 1] % 10);
        else if (B = mathceil((f + 1) / LOG_BASE), B >= _.length)
          if (I) {
            for (; _.length <= B; _.push(0))
              ;
            M = S = 0, P = 1, f %= LOG_BASE, y = f - LOG_BASE + 1;
          } else
            break e;
        else {
          for (M = v = _[B], P = 1; v >= 10; v /= 10, P++)
            ;
          f %= LOG_BASE, y = f - LOG_BASE + P, S = y < 0 ? 0 : mathfloor(M / E[P - y - 1] % 10);
        }
        if (I = I || ie < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        _[B + 1] != null || (y < 0 ? M : M % E[P - y - 1]), I = fe < 4 ? (S || I) && (fe == 0 || fe == (Z.s < 0 ? 3 : 2)) : S > 5 || S == 5 && (fe == 4 || I || fe == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (f > 0 ? y > 0 ? M / E[P - y] : 0 : _[B - 1]) % 10 & 1 || fe == (Z.s < 0 ? 8 : 7)), ie < 1 || !_[0])
          return _.length = 0, I ? (ie -= Z.e + 1, _[0] = E[(LOG_BASE - ie % LOG_BASE) % LOG_BASE], Z.e = -ie || 0) : _[0] = Z.e = 0, Z;
        if (f == 0 ? (_.length = B, v = 1, B--) : (_.length = B + 1, v = E[LOG_BASE - f], _[B] = y > 0 ? mathfloor(M / E[P - y] % E[y]) * v : 0), I)
          for (; ; )
            if (B == 0) {
              for (f = 1, y = _[0]; y >= 10; y /= 10, f++)
                ;
              for (y = _[0] += v, v = 1; y >= 10; y /= 10, v++)
                ;
              f != v && (Z.e++, _[0] == BASE && (_[0] = 1));
              break;
            } else {
              if (_[B] += v, _[B] != BASE)
                break;
              _[B--] = 0, v = 1;
            }
        for (f = _.length; _[--f] === 0; _.pop())
          ;
      }
      Z.e > C ? Z.c = Z.e = null : Z.e < w && (Z.c = [Z.e = 0]);
    }
    return Z;
  }
  function le(Z) {
    var ie, fe = Z.e;
    return fe === null ? Z.toString() : (ie = coeffToString(Z.c), ie = fe <= b || fe >= g ? toExponential(ie, fe) : toFixedPoint(ie, fe, "0"), Z.s < 0 ? "-" + ie : ie);
  }
  return h.absoluteValue = h.abs = function() {
    var Z = new U(this);
    return Z.s < 0 && (Z.s = 1), Z;
  }, h.comparedTo = function(Z, ie) {
    return compare(this, new U(Z, ie));
  }, h.decimalPlaces = h.dp = function(Z, ie) {
    var fe, I, P, f = this;
    if (Z != null)
      return intCheck(Z, 0, MAX), ie == null ? ie = d : intCheck(ie, 0, 8), ne(new U(f), Z + f.e + 1, ie);
    if (!(fe = f.c))
      return null;
    if (I = ((P = fe.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE, P = fe[P])
      for (; P % 10 == 0; P /= 10, I--)
        ;
    return I < 0 && (I = 0), I;
  }, h.dividedBy = h.div = function(Z, ie) {
    return t(this, new U(Z, ie), p, d);
  }, h.dividedToIntegerBy = h.idiv = function(Z, ie) {
    return t(this, new U(Z, ie), 0, 1);
  }, h.exponentiatedBy = h.pow = function(Z, ie) {
    var fe, I, P, f, y, v, M, B, S, _ = this;
    if (Z = new U(Z), Z.c && !Z.isInteger())
      throw Error(bignumberError + "Exponent not an integer: " + le(Z));
    if (ie != null && (ie = new U(ie)), v = Z.e > 14, !_.c || !_.c[0] || _.c[0] == 1 && !_.e && _.c.length == 1 || !Z.c || !Z.c[0])
      return S = new U(Math.pow(+le(_), v ? Z.s * (2 - isOdd(Z)) : +le(Z))), ie ? S.mod(ie) : S;
    if (M = Z.s < 0, ie) {
      if (ie.c ? !ie.c[0] : !ie.s)
        return new U(NaN);
      I = !M && _.isInteger() && ie.isInteger(), I && (_ = _.mod(ie));
    } else {
      if (Z.e > 9 && (_.e > 0 || _.e < -1 || (_.e == 0 ? _.c[0] > 1 || v && _.c[1] >= 24e7 : _.c[0] < 8e13 || v && _.c[0] <= 9999975e7)))
        return f = _.s < 0 && isOdd(Z) ? -0 : 0, _.e > -1 && (f = 1 / f), new U(M ? 1 / f : f);
      q && (f = mathceil(q / LOG_BASE + 2));
    }
    for (v ? (fe = new U(0.5), M && (Z.s = 1), B = isOdd(Z)) : (P = Math.abs(+le(Z)), B = P % 2), S = new U(a); ; ) {
      if (B) {
        if (S = S.times(_), !S.c)
          break;
        f ? S.c.length > f && (S.c.length = f) : I && (S = S.mod(ie));
      }
      if (P) {
        if (P = mathfloor(P / 2), P === 0)
          break;
        B = P % 2;
      } else if (Z = Z.times(fe), ne(Z, Z.e + 1, 1), Z.e > 14)
        B = isOdd(Z);
      else {
        if (P = +le(Z), P === 0)
          break;
        B = P % 2;
      }
      _ = _.times(_), f ? _.c && _.c.length > f && (_.c.length = f) : I && (_ = _.mod(ie));
    }
    return I ? S : (M && (S = a.div(S)), ie ? S.mod(ie) : f ? ne(S, q, d, y) : S);
  }, h.integerValue = function(Z) {
    var ie = new U(this);
    return Z == null ? Z = d : intCheck(Z, 0, 8), ne(ie, ie.e + 1, Z);
  }, h.isEqualTo = h.eq = function(Z, ie) {
    return compare(this, new U(Z, ie)) === 0;
  }, h.isFinite = function() {
    return !!this.c;
  }, h.isGreaterThan = h.gt = function(Z, ie) {
    return compare(this, new U(Z, ie)) > 0;
  }, h.isGreaterThanOrEqualTo = h.gte = function(Z, ie) {
    return (ie = compare(this, new U(Z, ie))) === 1 || ie === 0;
  }, h.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  }, h.isLessThan = h.lt = function(Z, ie) {
    return compare(this, new U(Z, ie)) < 0;
  }, h.isLessThanOrEqualTo = h.lte = function(Z, ie) {
    return (ie = compare(this, new U(Z, ie))) === -1 || ie === 0;
  }, h.isNaN = function() {
    return !this.s;
  }, h.isNegative = function() {
    return this.s < 0;
  }, h.isPositive = function() {
    return this.s > 0;
  }, h.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, h.minus = function(Z, ie) {
    var fe, I, P, f, y = this, v = y.s;
    if (Z = new U(Z, ie), ie = Z.s, !v || !ie)
      return new U(NaN);
    if (v != ie)
      return Z.s = -ie, y.plus(Z);
    var M = y.e / LOG_BASE, B = Z.e / LOG_BASE, S = y.c, _ = Z.c;
    if (!M || !B) {
      if (!S || !_)
        return S ? (Z.s = -ie, Z) : new U(_ ? y : NaN);
      if (!S[0] || !_[0])
        return _[0] ? (Z.s = -ie, Z) : new U(S[0] ? y : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          d == 3 ? -0 : 0
        ));
    }
    if (M = bitFloor(M), B = bitFloor(B), S = S.slice(), v = M - B) {
      for ((f = v < 0) ? (v = -v, P = S) : (B = M, P = _), P.reverse(), ie = v; ie--; P.push(0))
        ;
      P.reverse();
    } else
      for (I = (f = (v = S.length) < (ie = _.length)) ? v : ie, v = ie = 0; ie < I; ie++)
        if (S[ie] != _[ie]) {
          f = S[ie] < _[ie];
          break;
        }
    if (f && (P = S, S = _, _ = P, Z.s = -Z.s), ie = (I = _.length) - (fe = S.length), ie > 0)
      for (; ie--; S[fe++] = 0)
        ;
    for (ie = BASE - 1; I > v; ) {
      if (S[--I] < _[I]) {
        for (fe = I; fe && !S[--fe]; S[fe] = ie)
          ;
        --S[fe], S[I] += BASE;
      }
      S[I] -= _[I];
    }
    for (; S[0] == 0; S.splice(0, 1), --B)
      ;
    return S[0] ? ee(Z, S, B) : (Z.s = d == 3 ? -1 : 1, Z.c = [Z.e = 0], Z);
  }, h.modulo = h.mod = function(Z, ie) {
    var fe, I, P = this;
    return Z = new U(Z, ie), !P.c || !Z.s || Z.c && !Z.c[0] ? new U(NaN) : !Z.c || P.c && !P.c[0] ? new U(P) : (k == 9 ? (I = Z.s, Z.s = 1, fe = t(P, Z, 0, 3), Z.s = I, fe.s *= I) : fe = t(P, Z, 0, k), Z = P.minus(fe.times(Z)), !Z.c[0] && k == 1 && (Z.s = P.s), Z);
  }, h.multipliedBy = h.times = function(Z, ie) {
    var fe, I, P, f, y, v, M, B, S, _, E, m, A, $, X, oe = this, J = oe.c, W = (Z = new U(Z, ie)).c;
    if (!J || !W || !J[0] || !W[0])
      return !oe.s || !Z.s || J && !J[0] && !W || W && !W[0] && !J ? Z.c = Z.e = Z.s = null : (Z.s *= oe.s, !J || !W ? Z.c = Z.e = null : (Z.c = [0], Z.e = 0)), Z;
    for (I = bitFloor(oe.e / LOG_BASE) + bitFloor(Z.e / LOG_BASE), Z.s *= oe.s, M = J.length, _ = W.length, M < _ && (A = J, J = W, W = A, P = M, M = _, _ = P), P = M + _, A = []; P--; A.push(0))
      ;
    for ($ = BASE, X = SQRT_BASE, P = _; --P >= 0; ) {
      for (fe = 0, E = W[P] % X, m = W[P] / X | 0, y = M, f = P + y; f > P; )
        B = J[--y] % X, S = J[y] / X | 0, v = m * B + S * E, B = E * B + v % X * X + A[f] + fe, fe = (B / $ | 0) + (v / X | 0) + m * S, A[f--] = B % $;
      A[f] = fe;
    }
    return fe ? ++I : A.splice(0, 1), ee(Z, A, I);
  }, h.negated = function() {
    var Z = new U(this);
    return Z.s = -Z.s || null, Z;
  }, h.plus = function(Z, ie) {
    var fe, I = this, P = I.s;
    if (Z = new U(Z, ie), ie = Z.s, !P || !ie)
      return new U(NaN);
    if (P != ie)
      return Z.s = -ie, I.minus(Z);
    var f = I.e / LOG_BASE, y = Z.e / LOG_BASE, v = I.c, M = Z.c;
    if (!f || !y) {
      if (!v || !M)
        return new U(P / 0);
      if (!v[0] || !M[0])
        return M[0] ? Z : new U(v[0] ? I : P * 0);
    }
    if (f = bitFloor(f), y = bitFloor(y), v = v.slice(), P = f - y) {
      for (P > 0 ? (y = f, fe = M) : (P = -P, fe = v), fe.reverse(); P--; fe.push(0))
        ;
      fe.reverse();
    }
    for (P = v.length, ie = M.length, P - ie < 0 && (fe = M, M = v, v = fe, ie = P), P = 0; ie; )
      P = (v[--ie] = v[ie] + M[ie] + P) / BASE | 0, v[ie] = BASE === v[ie] ? 0 : v[ie] % BASE;
    return P && (v = [P].concat(v), ++y), ee(Z, v, y);
  }, h.precision = h.sd = function(Z, ie) {
    var fe, I, P, f = this;
    if (Z != null && Z !== !!Z)
      return intCheck(Z, 1, MAX), ie == null ? ie = d : intCheck(ie, 0, 8), ne(new U(f), Z, ie);
    if (!(fe = f.c))
      return null;
    if (P = fe.length - 1, I = P * LOG_BASE + 1, P = fe[P]) {
      for (; P % 10 == 0; P /= 10, I--)
        ;
      for (P = fe[0]; P >= 10; P /= 10, I++)
        ;
    }
    return Z && f.e + 1 > I && (I = f.e + 1), I;
  }, h.shiftedBy = function(Z) {
    return intCheck(Z, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER), this.times("1e" + Z);
  }, h.squareRoot = h.sqrt = function() {
    var Z, ie, fe, I, P, f = this, y = f.c, v = f.s, M = f.e, B = p + 4, S = new U("0.5");
    if (v !== 1 || !y || !y[0])
      return new U(!v || v < 0 && (!y || y[0]) ? NaN : y ? f : 1 / 0);
    if (v = Math.sqrt(+le(f)), v == 0 || v == 1 / 0 ? (ie = coeffToString(y), (ie.length + M) % 2 == 0 && (ie += "0"), v = Math.sqrt(+ie), M = bitFloor((M + 1) / 2) - (M < 0 || M % 2), v == 1 / 0 ? ie = "5e" + M : (ie = v.toExponential(), ie = ie.slice(0, ie.indexOf("e") + 1) + M), fe = new U(ie)) : fe = new U(v + ""), fe.c[0]) {
      for (M = fe.e, v = M + B, v < 3 && (v = 0); ; )
        if (P = fe, fe = S.times(P.plus(t(f, P, B, 1))), coeffToString(P.c).slice(0, v) === (ie = coeffToString(fe.c)).slice(0, v))
          if (fe.e < M && --v, ie = ie.slice(v - 3, v + 1), ie == "9999" || !I && ie == "4999") {
            if (!I && (ne(P, P.e + p + 2, 0), P.times(P).eq(f))) {
              fe = P;
              break;
            }
            B += 4, v += 4, I = 1;
          } else {
            (!+ie || !+ie.slice(1) && ie.charAt(0) == "5") && (ne(fe, fe.e + p + 2, 1), Z = !fe.times(fe).eq(f));
            break;
          }
    }
    return ne(fe, fe.e + p + 1, d, Z);
  }, h.toExponential = function(Z, ie) {
    return Z != null && (intCheck(Z, 0, MAX), Z++), H(this, Z, ie, 1);
  }, h.toFixed = function(Z, ie) {
    return Z != null && (intCheck(Z, 0, MAX), Z = Z + this.e + 1), H(this, Z, ie);
  }, h.toFormat = function(Z, ie, fe) {
    var I, P = this;
    if (fe == null)
      Z != null && ie && typeof ie == "object" ? (fe = ie, ie = null) : Z && typeof Z == "object" ? (fe = Z, Z = ie = null) : fe = O;
    else if (typeof fe != "object")
      throw Error(bignumberError + "Argument not an object: " + fe);
    if (I = P.toFixed(Z, ie), P.c) {
      var f, y = I.split("."), v = +fe.groupSize, M = +fe.secondaryGroupSize, B = fe.groupSeparator || "", S = y[0], _ = y[1], E = P.s < 0, m = E ? S.slice(1) : S, A = m.length;
      if (M && (f = v, v = M, M = f, A -= f), v > 0 && A > 0) {
        for (f = A % v || v, S = m.substr(0, f); f < A; f += v)
          S += B + m.substr(f, v);
        M > 0 && (S += B + m.slice(f)), E && (S = "-" + S);
      }
      I = _ ? S + (fe.decimalSeparator || "") + ((M = +fe.fractionGroupSize) ? _.replace(
        new RegExp("\\d{" + M + "}\\B", "g"),
        "$&" + (fe.fractionGroupSeparator || "")
      ) : _) : S;
    }
    return (fe.prefix || "") + I + (fe.suffix || "");
  }, h.toFraction = function(Z) {
    var ie, fe, I, P, f, y, v, M, B, S, _, E, m = this, A = m.c;
    if (Z != null && (v = new U(Z), !v.isInteger() && (v.c || v.s !== 1) || v.lt(a)))
      throw Error(bignumberError + "Argument " + (v.isInteger() ? "out of range: " : "not an integer: ") + le(v));
    if (!A)
      return new U(m);
    for (ie = new U(a), B = fe = new U(a), I = M = new U(a), E = coeffToString(A), f = ie.e = E.length - m.e - 1, ie.c[0] = POWS_TEN[(y = f % LOG_BASE) < 0 ? LOG_BASE + y : y], Z = !Z || v.comparedTo(ie) > 0 ? f > 0 ? ie : B : v, y = C, C = 1 / 0, v = new U(E), M.c[0] = 0; S = t(v, ie, 0, 1), P = fe.plus(S.times(I)), P.comparedTo(Z) != 1; )
      fe = I, I = P, B = M.plus(S.times(P = B)), M = P, ie = v.minus(S.times(P = ie)), v = P;
    return P = t(Z.minus(fe), I, 0, 1), M = M.plus(P.times(B)), fe = fe.plus(P.times(I)), M.s = B.s = m.s, f = f * 2, _ = t(B, I, f, d).minus(m).abs().comparedTo(
      t(M, fe, f, d).minus(m).abs()
    ) < 1 ? [B, I] : [M, fe], C = y, _;
  }, h.toNumber = function() {
    return +le(this);
  }, h.toPrecision = function(Z, ie) {
    return Z != null && intCheck(Z, 1, MAX), H(this, Z, ie, 2);
  }, h.toString = function(Z) {
    var ie, fe = this, I = fe.s, P = fe.e;
    return P === null ? I ? (ie = "Infinity", I < 0 && (ie = "-" + ie)) : ie = "NaN" : (Z == null ? ie = P <= b || P >= g ? toExponential(coeffToString(fe.c), P) : toFixedPoint(coeffToString(fe.c), P, "0") : Z === 10 && j ? (fe = ne(new U(fe), p + P + 1, d), ie = toFixedPoint(coeffToString(fe.c), fe.e, "0")) : (intCheck(Z, 2, N.length, "Base"), ie = o(toFixedPoint(coeffToString(fe.c), P, "0"), 10, Z, I, !0)), I < 0 && fe.c[0] && (ie = "-" + ie)), ie;
  }, h.valueOf = h.toJSON = function() {
    return le(this);
  }, h._isBigNumber = !0, h[Symbol.toStringTag] = "BigNumber", h[Symbol.for("nodejs.util.inspect.custom")] = h.valueOf, e != null && U.set(e), U;
}
function bitFloor(e) {
  var t = e | 0;
  return e > 0 || e === t ? t : t - 1;
}
function coeffToString(e) {
  for (var t, o, r = 1, h = e.length, a = e[0] + ""; r < h; ) {
    for (t = e[r++] + "", o = LOG_BASE - t.length; o--; t = "0" + t)
      ;
    a += t;
  }
  for (h = a.length; a.charCodeAt(--h) === 48; )
    ;
  return a.slice(0, h + 1 || 1);
}
function compare(e, t) {
  var o, r, h = e.c, a = t.c, p = e.s, d = t.s, b = e.e, g = t.e;
  if (!p || !d)
    return null;
  if (o = h && !h[0], r = a && !a[0], o || r)
    return o ? r ? 0 : -d : p;
  if (p != d)
    return p;
  if (o = p < 0, r = b == g, !h || !a)
    return r ? 0 : !h ^ o ? 1 : -1;
  if (!r)
    return b > g ^ o ? 1 : -1;
  for (d = (b = h.length) < (g = a.length) ? b : g, p = 0; p < d; p++)
    if (h[p] != a[p])
      return h[p] > a[p] ^ o ? 1 : -1;
  return b == g ? 0 : b > g ^ o ? 1 : -1;
}
function intCheck(e, t, o, r) {
  if (e < t || e > o || e !== mathfloor(e))
    throw Error(bignumberError + (r || "Argument") + (typeof e == "number" ? e < t || e > o ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e));
}
function isOdd(e) {
  var t = e.c.length - 1;
  return bitFloor(e.e / LOG_BASE) == t && e.c[t] % 2 != 0;
}
function toExponential(e, t) {
  return (e.length > 1 ? e.charAt(0) + "." + e.slice(1) : e) + (t < 0 ? "e" : "e+") + t;
}
function toFixedPoint(e, t, o) {
  var r, h;
  if (t < 0) {
    for (h = o + "."; ++t; h += o)
      ;
    e = h + e;
  } else if (r = e.length, ++t > r) {
    for (h = o, t -= r; --t; h += o)
      ;
    e += h;
  } else
    t < r && (e = e.slice(0, t) + "." + e.slice(t));
  return e;
}
var BigNumber = clone();
const filterAccountBalance = (e, t, o) => {
  const r = e.filter(
    (a) => a.accountId === t.accountId && a.accountTokenId
  ), h = o.tokens.length ? o.tokens.filter(
    (a) => r.find((p) => p.contract === a.contract)
  ).map((a) => {
    const p = { ...a };
    return delete p.tokenId, delete p.decimals, p.balance = getBalanceWithDecimal(a.balance, a.decimals), p;
  }) : [];
  return {
    network: t.network,
    address: t.address,
    balance: getBalanceWithDecimal(o.balance, o.decimals),
    symbol: t.symbol,
    tokens: h
  };
}, getBalanceWithDecimal = (e, t) => {
  if (!t || !e)
    return "0";
  const o = new BigNumber(e).shiftedBy(-t).toFixed();
  return o === "NaN" ? "0" : o;
}, aM = class aM {
  static isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
      navigator.userAgent
    );
  }
  static uuidv4() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
      /[xy]/g,
      function(t) {
        const o = Math.random() * 16 | 0;
        return (t == "x" ? o : o & 3 | 8).toString(16);
      }
    );
  }
};
aM.checkSameNumber = (t, o, r) => {
  if (r)
    return !1;
  const h = [...Array(10)].map(Number.prototype.valueOf, 0);
  let a = !1;
  return [...t].forEach((d) => {
    if (h[Number(d)]++, h[Number(d)] >= o) {
      a = !0;
      return;
    }
  }), a;
}, aM.checkError = (t) => {
  if (isErrorResponse(t))
    throw t.statusCode === 403 ? new Error(
      JSON.stringify({
        message: "invalid pin",
        resetPinTryCnt: t == null ? void 0 : t.remainPinTryCnt
      })
    ) : t.statusCode === 412 ? new Error(
      JSON.stringify({
        message: "invalid otp code"
      })
    ) : new Error(t.message);
};
let Utils = aM;
const pinRegExp = /^\d{6,8}$/;
class WepinAPI extends SafeEventEmitter {
  constructor({
    appId: t,
    appKey: o,
    options: r
  }) {
    super(), this.version = PackageJson.version, console.log(`WepinWeb SDK v${this.version}`), this._isInitialized = !1, this._wepinLifeCycle = "not_initialized", this._wepinAppId = t, this._wepinAppKey = o, this.wepinDomain = window != null && window.location ? window.location.origin : r.domain, this._isInitialized = !1, this._wepinStorage = (r == null ? void 0 : r.storage) ?? c, this.type = this._wepinStorage.platform, this.setModeByAppKey(o);
  }
  setModeByAppKey(t) {
    if (t.slice(0, 8) === "ak_live_") {
      this._modeByAppKey = "production";
      return;
    } else if (t.slice(0, 8) === "ak_test_") {
      this._modeByAppKey = "test";
      return;
    } else if (t.slice(0, 7) === "ak_dev_") {
      this._modeByAppKey = "development";
      return;
    } else if (t.slice(0, 13) === "local_ak_dev_")
      this._modeByAppKey = "local";
    else
      throw new Error("Wepin.setModeByAppKey: Invalid appKey");
  }
  get modeByAppKey() {
    if (this._modeByAppKey === void 0)
      throw new Error("Wepin.modeByAppKey: wepin widget has to be initialized");
    return this._modeByAppKey;
  }
  toJSON() {
    return "";
  }
  /**
   * Initialize Wepin Object.
   * @returns
   */
  async init() {
    if (this._isInitialized)
      throw new Error("Wepin is already initialized!");
    this._wepinLifeCycle = "initializing", this._wepinFetch = new WepinFetch({
      appId: this._wepinAppId,
      appKey: this._wepinAppKey,
      domain: this.wepinDomain,
      sdk: { version: this.version, type: `${this.type}-api` },
      storage: this._wepinStorage
    }), await this._wepinFetch.init();
    const t = await this.getAppInfo(!1);
    if (isErrorResponse(t))
      throw new Error(t.message);
    this._wepinAppId = this._wepinFetch.appId = t.appInfo.id;
    const o = this._wepinStorage.getLocalStorage(
      this._wepinAppId,
      "wepin:connectUser"
    );
    o && this._wepinFetch.setToken(o), this._isInitialized = !0, await this.checkExpiredToken() ? this._wepinLifeCycle = "initialized" : this._wepinLifeCycle = "login";
  }
  setInitialized(t) {
    this._isInitialized = t;
  }
  /**
   * Check if wepin is initialized.
   *
   * @returns
   */
  isInitialized() {
    return !!this._isInitialized;
  }
  setToken(t) {
    this._wepinFetch.setToken(t);
  }
  async checkExpiredToken() {
    try {
      const t = this._wepinStorage.getLocalStorage(
        this._wepinAppId,
        "wepin:connectUser"
      );
      if (!t)
        return !0;
      if (jwtDecode(t.accessToken).exp < Math.floor(Date.now() / 1e3) + 60) {
        this._wepinFetch.setToken(t);
        const r = await this._wepinFetch.wepinApi.user.refreshToken();
        return isErrorResponse(r) ? !0 : (t.accessToken = r.token, this._wepinStorage.setLocalStorage(
          this._wepinAppId,
          "wepin:connectUser",
          t
        ), !1);
      } else
        return !1;
    } catch {
      return !0;
    }
  }
  async getAppInfo(t) {
    const o = await this._wepinFetch.wepinApi.app.getAppInfo({
      platform: ProjectPlatformKind[this.type],
      withNetwork: t ?? !1
    });
    if (isErrorResponse(o))
      throw new Error(o.message);
    return o;
  }
  async getAppCoins(t) {
    if (!this._isInitialized)
      throw new Error(
        "Wepin.getAppCoins: wepin api has to be initialized"
      );
    const o = await this._wepinFetch.wepinApi.app.getAppCoins({
      localeId: t === "ko" ? 1 : 2
    });
    if (isErrorResponse(o))
      throw new Error(o.message);
    return o;
  }
  async getAppSupportedNFTs() {
    if (!this._isInitialized)
      throw new Error(
        "Wepin.getAppSupportedNFTs: wepin api has to be initialized"
      );
    const t = await this._wepinFetch.wepinApi.nft.getSupportingNetworkList();
    if (isErrorResponse(t))
      throw new Error(t.message);
    return t;
  }
  async register(t) {
    if (!this._isInitialized)
      throw new Error("Wepin.register: wepin api has to be initialized");
    if (!t)
      throw new Error("Wepin.register: pin is required");
    if (!pinRegExp.test(t))
      throw new Error("Wepin.register: The PIN must be a string composed of 6 to 8 digits.");
    if (await this.getStatus() !== "login_before_register")
      throw new Error("Wepin.register: wepin api LifeCycle has to be login_before_register");
    const o = this._wepinStorage.getLocalStorage(this._wepinAppId, "user_id"), r = this._wepinStorage.getLocalStorage(this._wepinAppId, "wallet_id"), h = this._wepinStorage.getLocalStorage(
      this._wepinAppId,
      "user_status"
    );
    let a;
    if ((h == null ? void 0 : h.loginStatus) === "registerRequired" && !(h != null && h.pinRequired))
      a = await this._wepinFetch.wepinApi.app.register({
        appId: this._wepinAppId,
        userId: o,
        walletId: r,
        loginStatus: h.loginStatus
      });
    else {
      const d = (h == null ? void 0 : h.loginStatus) === "pinRequired" ? VERIFY_CREATE : VERIFY_PIN, b = await getUVD(t, this._wepinFetch, {
        type: d,
        userId: o,
        walletId: r
      });
      a = await this._wepinFetch.wepinApi.app.register({
        appId: this._wepinAppId,
        userId: o,
        walletId: r,
        loginStatus: h.loginStatus,
        UVD: b.UVD,
        hint: b == null ? void 0 : b.hint
      });
    }
    if (isErrorResponse(a)) {
      Utils.checkError(a);
      return;
    }
    const p = await this._wepinFetch.wepinApi.user.updateTermsAccepted(
      { userId: o },
      {
        termsAccepted: {
          termsOfService: !0,
          privacyPolicy: !0
        }
      }
    );
    if (isErrorResponse(p) || !Object.values(p.termsAccepted).every((d) => d === !0))
      throw new Error("unknown/updateTermsAccepted");
    if (this._wepinStorage.setLocalStorage(this._wepinAppId, "user_status", {
      loginStatus: "complete"
    }), a.walletId) {
      this._wepinStorage.setLocalStorage(
        this._wepinAppId,
        "wallet_id",
        a.walletId
      );
      const d = this._wepinStorage.getLocalStorage(
        this._wepinAppId,
        "user_info"
      );
      d.walletId = this._userInfo.walletId = a.walletId, this._wepinStorage.setLocalStorage(
        this._wepinAppId,
        "user_info",
        d
      );
    }
    return this._wepinLifeCycle = "login", this._userInfo;
  }
  async refreshSession() {
    if (!this._isInitialized)
      throw new Error("Wepin.refresh  : wepin api has to be initialized");
    const t = this._wepinStorage.getLocalStorage(
      this._wepinAppId,
      "wepin:connectUser"
    ), o = await this._wepinFetch.wepinApi.user.refreshToken();
    if (isErrorResponse(o))
      throw new Error(o.message);
    return this.setToken({
      accessToken: o.token,
      refreshToken: t.refreshToken
    }), !0;
  }
  /**
   * Function to handle user logout.
   *
   * @returns {Promise<void>}
   */
  async logout() {
    if (!this._isInitialized && await this.getStatus() !== "login")
      throw new Error(
        "Wepin.logout: wepin api has to be initialized and logged in"
      );
    this._wepinStorage.clearAllLocalStorage(this._wepinAppId), this._wepinLifeCycle = "initialized", this._detailAccount = void 0, this._userInfo = void 0, this._accountInfo = void 0;
  }
  /**
   * Returns available account list. It can be only usable after login.
   * It returns all the accounts once parameter is empty.
   *
   * @param options
   *    - locale: 'ko' | 'en'
   *    - networks: list of network wanted to get return
   *    - withEoa: If AA accounts are included, whether to include EOA accounts
   *    - force: refresh account list
   * @returns
   */
  async getAccounts(t) {
    if (!this._isInitialized)
      throw new Error(
        "Wepin.getAccounts: wepin api has to be initialized"
      );
    if (await this.getStatus() !== "login")
      throw new Error(
        "Wepin.getAccounts: You can get accounts only if you are logged in to the wepin."
      );
    const o = this._wepinStorage.getLocalStorage(this._wepinAppId, "user_id"), r = this._wepinStorage.getLocalStorage(this._wepinAppId, "wallet_id");
    if (!this._accountInfo || this._accountInfo.length === 0 || (t == null ? void 0 : t.force) === !0) {
      const h = await this._wepinFetch.wepinApi.account.getAppAccountList({
        userId: o,
        walletId: r,
        localeId: (t == null ? void 0 : t.locale) === "ko" ? 1 : 2
      });
      if (isErrorResponse(h))
        throw new Error(h.message);
      this._detailAccount = filterAccountList(h, t == null ? void 0 : t.withEoa), this._accountInfo = getAccountSDK(this._detailAccount);
    }
    return (t == null ? void 0 : t.networks) !== void 0 && (t == null ? void 0 : t.networks.length) > 0 ? this._accountInfo.filter(
      (a) => (t == null ? void 0 : t.networks.findIndex((p) => p === a.network)) >= 0
    ) : this._accountInfo;
  }
  /**
   * Returns available nft list. It can be only usable after login.
   * It returns all the nft once networks parameter is empty.
   *
   * @param options
   *    - networks: list of network wanted to get return
   *    - force: refresh nft list
   * @returns Promise<NFTInfo[]>
   * @example
   * ```typescript
   * const nftList = await wepin.getNfts()
   * console.log(nftList)
   * ```
   */
  async getNfts(t) {
    var h;
    if (!this._isInitialized)
      throw new Error("Wepin.getNfts: wepin api has to be initialized");
    if (await this.getStatus() !== "login")
      throw new Error(
        "Wepin.getNfts: You can get accounts only if you are logged in to the wepin."
      );
    const o = this._wepinStorage.getLocalStorage(this._wepinAppId, "user_id"), r = this._wepinStorage.getLocalStorage(this._wepinAppId, "wallet_id");
    if (!this._nftInfo || t.force) {
      const a = await this._wepinFetch.wepinApi.nft.getAppNFTList({
        userId: o,
        walletId: r
      });
      if (isErrorResponse(a))
        throw new Error(a.message);
      const p = await this._wepinFetch.wepinApi.nft.refreshAppNFTList({
        userId: o,
        walletId: r
      });
      if (isErrorResponse(p))
        throw new Error(p.message);
      await this.getAccounts();
      const d = [];
      this._detailNft = p.nfts, (h = p.nfts) == null || h.forEach((b) => {
        const g = this._detailAccount.find(
          (w) => w.accountId === b.accountId
        );
        g && d.push({
          network: g.network,
          address: g.address,
          contract: {
            address: b.contract.address,
            scheme: NFTScheme[b.contract.scheme - 1]
            // ??
            // nft.contract.scheme.toString(),
          },
          name: b.name,
          description: b.description,
          externalLink: b.externalLink,
          imageUrl: b.imageUrl,
          contentUrl: b.contentUrl,
          quantity: b.quantity,
          contentType: NFTContentType[b.contentType - 1]
        });
      }), this._nftInfo = d;
    }
    return (t == null ? void 0 : t.networks) !== void 0 && (t == null ? void 0 : t.networks.length) > 0 ? this._nftInfo.filter(
      (p) => (t == null ? void 0 : t.networks.findIndex((d) => d === p.network)) >= 0
    ) : this._nftInfo;
  }
  /**
   * Returns balance info of account. It can be only usable after login.
   * It returns all the nft once networks parameter is empty.
   *
   * @param account
   * @returns Promise<AccountBalanceInfo>
   */
  async getBalance(t) {
    if (!this._isInitialized)
      throw new Error(
        "Wepin.getBalance: wepin api has to be initialized"
      );
    if (await this.getStatus() !== "login")
      throw new Error(
        "Wepin.getBalance: You can get accounts only if you are logged in to the wepin."
      );
    const o = !t || t.length === 0, r = [];
    if (await this.getAccounts(), o) {
      for (const h of this._detailAccount)
        if (t && t.findIndex(
          (a) => a.network === h.network && a.address === h.address
        ) >= 0) {
          const a = await this._wepinFetch.wepinApi.balance.getAccountBalance({
            accountId: h.accountId
          });
          if (isErrorResponse(a))
            throw new Error(a.message);
          r.push(
            filterAccountBalance(this._detailAccount, h, a)
          );
        }
    } else
      for (const h of t) {
        const a = this._detailAccount.find(
          (d) => h.network === d.network && h.address === d.address
        );
        if (!a)
          throw new Error("Account not found");
        const p = await this._wepinFetch.wepinApi.balance.getAccountBalance({
          accountId: a.accountId
        });
        if (isErrorResponse(p))
          throw new Error(p.message);
        r.push(
          filterAccountBalance(this._detailAccount, a, p)
        );
      }
    if (!r.length)
      throw new Error("Account not found");
    return r;
  }
  isNftInfo(t) {
    var o, r;
    return ((o = t.contract) == null ? void 0 : o.scheme) !== void 0 && ((r = t.contract) == null ? void 0 : r.address) !== void 0 && t.name !== void 0 && t.description !== void 0 && t.imageUrl !== void 0;
  }
  async checkAddressValidation({
    account: t,
    address: o
  }) {
    if (!this._isInitialized)
      throw new Error(
        "Wepin.checkAddressValidation: wepin api has to be initialized"
      );
    if (await this.getStatus() !== "login")
      throw new Error(
        "Wepin.checkAddressValidation: You can get accounts only if you are logged in to the wepin."
      );
    const r = this._wepinStorage.getLocalStorage(this._wepinAppId, "user_id");
    await this.getAccounts();
    const h = this._detailAccount.find(
      (p) => p.network === t.network && p.address === t.address
    );
    if (!h)
      throw new Error("Account not found");
    const a = await this._wepinFetch.wepinApi.transaction.checkAddressValidation({
      userId: r,
      coinId: h.coinId,
      address: o
    });
    if (isErrorResponse(a))
      throw new Error(a.message);
    return a.result;
  }
  async getPrepareParams(t, o) {
    if (this.isNftInfo(t)) {
      await this.getNfts({ force: !0 });
      const r = this._detailNft.find(
        (h) => h.accountId === o.accountId && h.contract.address === t.contract.address && NFTScheme[h.contract.scheme - 1] === t.contract.scheme
      );
      if (!r)
        throw new Error("NFT not found");
      return {
        accountId: r.accountId,
        contract: r.contract.address,
        tokenId: r.tokenId,
        isNft: NFTScheme[r.contract.scheme - 1]
      };
    } else
      return {
        accountId: o.accountId,
        contract: o.contract ?? "",
        tokenId: o.accountTokenId ?? ""
      };
  }
  isEvmAccount(t) {
    return t.network.toLowerCase().startsWith("evm") || t.network.toLowerCase() === "klaytn" || t.network.toLowerCase() === "klaytn-testnet";
  }
  async prepareTransaction({
    account: t,
    to: o,
    amount: r,
    data: h
  }) {
    if (!this._isInitialized)
      throw new Error(
        "Wepin.prepareTransaction: wepin api has to be initialized"
      );
    if (await this.getStatus() !== "login")
      throw new Error(
        "Wepin.prepareTransaction: You can get accounts only if you are logged in to the wepin."
      );
    if (!t)
      throw new Error("Account is required");
    if (!this.isEvmAccount(t))
      throw new Error("Wepin.prepareTransaction: not supported network");
    if (!await this.checkAddressValidation({
      account: t,
      address: o
    }))
      throw new Error("Invalid to address");
    const p = this._wepinStorage.getLocalStorage(this._wepinAppId, "user_id"), d = { to: o, amount: r, data: h ?? "0x", userId: p };
    await this.getAccounts();
    const b = this._detailAccount.find(
      (C) => C.network === t.network && C.address === t.address && this.isNftInfo(t) ? !0 : (C == null ? void 0 : C.contract) === (t == null ? void 0 : t.contract)
    );
    if (!b)
      throw new Error("Account not found");
    const g = await this.getPrepareParams(t, b), w = await this._wepinFetch.wepinApi.transaction.prepareTransaction(
      Object.assign(d, g)
    );
    if (isErrorResponse(w))
      throw new Error(w.message);
    return w.detail;
  }
  async signAndBroadcast({
    account: t,
    txData: o,
    pin: r,
    otpCode: h
  }) {
    if (!this._isInitialized)
      throw new Error(
        "Wepin.signAndBroadcast: wepin api has to be initialized"
      );
    if (await this.getStatus() !== "login")
      throw new Error(
        "Wepin.signAndBroadcast: You can get accounts only if you are logged in to the wepin."
      );
    if (!this.isEvmAccount(t))
      throw new Error("Wepin.signAndBroadcast: not supported network");
    const a = this._wepinStorage.getLocalStorage(this._wepinAppId, "user_id"), p = this._wepinStorage.getLocalStorage(this._wepinAppId, "wallet_id");
    await this.getAccounts();
    const d = this._detailAccount.find(
      (w) => w.network === t.network && w.address === t.address
    );
    if (!d)
      throw new Error("Account not found");
    const b = await getUVD(r, this._wepinFetch, {
      type: VERIFY_PIN,
      userId: a,
      walletId: p
    }), g = await this._wepinFetch.wepinApi.transaction.broadCast({
      type: "transaction",
      accountId: d.accountId,
      pin: b.UVD,
      otpCode: h,
      txData: {
        amount: o.amount,
        to: o.to,
        nonce: o.nonce,
        data: (o == null ? void 0 : o.data) ?? "0x",
        gasLimit: o.gasLimit,
        gasPrice: o.gasPrice
      },
      userId: a,
      walletId: p
    });
    if (isErrorResponse(g)) {
      Utils.checkError(g);
      return;
    }
    return { txId: g.txid };
  }
  async sign({
    account: t,
    signData: o,
    pin: r,
    otpCode: h
  }) {
    if (!this._isInitialized)
      throw new Error("Wepin.sign: wepin api has to be initialized");
    if (await this.getStatus() !== "login")
      throw new Error(
        "Wepin.sign: You can get accounts only if you are logged in to the wepin."
      );
    if (!this.isEvmAccount(t))
      throw new Error("Wepin.signAndBroadcast: not supported network");
    const a = this._wepinStorage.getLocalStorage(this._wepinAppId, "user_id"), p = this._wepinStorage.getLocalStorage(this._wepinAppId, "wallet_id");
    await this.getAccounts();
    const d = this._detailAccount.find(
      (w) => w.network === t.network && w.address === t.address
    );
    if (!d)
      throw new Error("Account not found");
    const b = await getUVD(r, this._wepinFetch, {
      type: VERIFY_PIN,
      userId: a,
      walletId: p
    }), g = await this._wepinFetch.wepinApi.transaction.sign(
      Object.assign(
        {
          accountId: d.accountId,
          pin: b.UVD,
          otpCode: h,
          userId: a,
          walletId: p
        },
        o
      )
    );
    if (isErrorResponse(g)) {
      Utils.checkError(g);
      return;
    }
    return { signatureResult: g.signatureResult };
  }
  async resetPINRetryCount() {
    if (!this._isInitialized)
      throw new Error(
        "Wepin.resetPINRetryCount: wepin api has to be initialized"
      );
    if (await this.getStatus() !== "login")
      throw new Error(
        "Wepin.resetPINRetryCount: You can get accounts only if you are logged in to the wepin."
      );
    const t = this._wepinStorage.getLocalStorage(this._wepinAppId, "user_id"), o = this._wepinStorage.getLocalStorage(this._wepinAppId, "wallet_id"), r = await this._wepinFetch.wepinApi.wallet.resetPinTryCount(
      { walletId: o },
      {
        userId: t
      }
    );
    if (isErrorResponse(r))
      throw new Error(r.message);
    return r;
  }
  async verifyPIN(t) {
    if (!this._isInitialized)
      throw new Error(
        "Wepin.resetPINrequired: wepin api has to be initialized"
      );
    if (await this.getStatus() !== "login")
      throw new Error(
        "Wepin.resetPINrequired: You can get accounts only if you are logged in to the wepin."
      );
    const o = this._wepinStorage.getLocalStorage(this._wepinAppId, "user_id"), r = this._wepinStorage.getLocalStorage(this._wepinAppId, "wallet_id"), h = await getUVD(t, this._wepinFetch, {
      type: VERIFY_PIN,
      userId: o,
      walletId: r
    }), a = await this._wepinFetch.wepinApi.wallet.verifyPin({
      userId: o,
      walletId: r,
      UVD: h.UVD
    });
    if (isErrorResponse(a)) {
      Utils.checkError(a);
      return;
    }
    return a.pinVerified;
  }
  /**
   * Returns lifecycle of wepin.
   * The lifecycle of the wepin is defined as follows.
   *  - 'not_initialized': if wepin is not initialized
   *  - 'initializing': if wepin is initializing
   *  - 'initialized': if wepin is initialized
   *  - 'before_login': if wepin is initialized but the user is not logged in
   *  - 'login': if the user is logged in
   *  - 'login_before_register': if the user is email logged in but the user is NOT registered in wepin
   *
   * @returns Promise<WepinLifeCycle>
   */
  async getStatus() {
    if (await this.checkExpiredToken())
      this._wepinLifeCycle = "initialized";
    else {
      const t = this._wepinStorage.getLocalStorage(
        this._wepinAppId,
        "user_status"
      ), o = this._wepinStorage.getLocalStorage(
        this._wepinAppId,
        "user_info"
      );
      this._userInfo = o, t.loginStatus === "registerRequired" || t.loginStatus === "pinRequired" ? this._wepinLifeCycle : this._wepinLifeCycle = "login";
    }
    return this._wepinLifeCycle;
  }
  finalize() {
    this._wepinStorage.clearAllLocalStorage(this._wepinAppId), this._isInitialized = !1, this._wepinLifeCycle = "not_initialized", this._detailAccount = void 0, this._userInfo = void 0, this._accountInfo = void 0;
  }
}
export {
  WepinAPI
};
