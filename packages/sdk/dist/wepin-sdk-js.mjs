var events$1 = { exports: {} }, R = typeof Reflect == "object" ? Reflect : null, ReflectApply = R && typeof R.apply == "function" ? R.apply : function(t, h, o) {
  return Function.prototype.apply.call(t, h, o);
}, ReflectOwnKeys;
R && typeof R.ownKeys == "function" ? ReflectOwnKeys = R.ownKeys : Object.getOwnPropertySymbols ? ReflectOwnKeys = function(t) {
  return Object.getOwnPropertyNames(t).concat(Object.getOwnPropertySymbols(t));
} : ReflectOwnKeys = function(t) {
  return Object.getOwnPropertyNames(t);
};
function ProcessEmitWarning(e) {
  console && console.warn && console.warn(e);
}
var NumberIsNaN = Number.isNaN || function(t) {
  return t !== t;
};
function EventEmitter$1() {
  EventEmitter$1.init.call(this);
}
events$1.exports = EventEmitter$1;
events$1.exports.once = once;
EventEmitter$1.EventEmitter = EventEmitter$1;
EventEmitter$1.prototype._events = void 0;
EventEmitter$1.prototype._eventsCount = 0;
EventEmitter$1.prototype._maxListeners = void 0;
var defaultMaxListeners = 10;
function checkListener(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(EventEmitter$1, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || NumberIsNaN(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    defaultMaxListeners = e;
  }
});
EventEmitter$1.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
EventEmitter$1.prototype.setMaxListeners = function(t) {
  if (typeof t != "number" || t < 0 || NumberIsNaN(t))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + t + ".");
  return this._maxListeners = t, this;
};
function _getMaxListeners(e) {
  return e._maxListeners === void 0 ? EventEmitter$1.defaultMaxListeners : e._maxListeners;
}
EventEmitter$1.prototype.getMaxListeners = function() {
  return _getMaxListeners(this);
};
EventEmitter$1.prototype.emit = function(t) {
  for (var h = [], o = 1; o < arguments.length; o++)
    h.push(arguments[o]);
  var S = t === "error", g = this._events;
  if (g !== void 0)
    S = S && g.error === void 0;
  else if (!S)
    return !1;
  if (S) {
    var B;
    if (h.length > 0 && (B = h[0]), B instanceof Error)
      throw B;
    var M = new Error("Unhandled error." + (B ? " (" + B.message + ")" : ""));
    throw M.context = B, M;
  }
  var O = g[t];
  if (O === void 0)
    return !1;
  if (typeof O == "function")
    ReflectApply(O, this, h);
  else
    for (var P = O.length, D = arrayClone$1(O, P), o = 0; o < P; ++o)
      ReflectApply(D[o], this, h);
  return !0;
};
function _addListener(e, t, h, o) {
  var S, g, B;
  if (checkListener(h), g = e._events, g === void 0 ? (g = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (g.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    h.listener ? h.listener : h
  ), g = e._events), B = g[t]), B === void 0)
    B = g[t] = h, ++e._eventsCount;
  else if (typeof B == "function" ? B = g[t] = o ? [h, B] : [B, h] : o ? B.unshift(h) : B.push(h), S = _getMaxListeners(e), S > 0 && B.length > S && !B.warned) {
    B.warned = !0;
    var M = new Error("Possible EventEmitter memory leak detected. " + B.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    M.name = "MaxListenersExceededWarning", M.emitter = e, M.type = t, M.count = B.length, ProcessEmitWarning(M);
  }
  return e;
}
EventEmitter$1.prototype.addListener = function(t, h) {
  return _addListener(this, t, h, !1);
};
EventEmitter$1.prototype.on = EventEmitter$1.prototype.addListener;
EventEmitter$1.prototype.prependListener = function(t, h) {
  return _addListener(this, t, h, !0);
};
function onceWrapper() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function _onceWrap(e, t, h) {
  var o = { fired: !1, wrapFn: void 0, target: e, type: t, listener: h }, S = onceWrapper.bind(o);
  return S.listener = h, o.wrapFn = S, S;
}
EventEmitter$1.prototype.once = function(t, h) {
  return checkListener(h), this.on(t, _onceWrap(this, t, h)), this;
};
EventEmitter$1.prototype.prependOnceListener = function(t, h) {
  return checkListener(h), this.prependListener(t, _onceWrap(this, t, h)), this;
};
EventEmitter$1.prototype.removeListener = function(t, h) {
  var o, S, g, B, M;
  if (checkListener(h), S = this._events, S === void 0)
    return this;
  if (o = S[t], o === void 0)
    return this;
  if (o === h || o.listener === h)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete S[t], S.removeListener && this.emit("removeListener", t, o.listener || h));
  else if (typeof o != "function") {
    for (g = -1, B = o.length - 1; B >= 0; B--)
      if (o[B] === h || o[B].listener === h) {
        M = o[B].listener, g = B;
        break;
      }
    if (g < 0)
      return this;
    g === 0 ? o.shift() : spliceOne(o, g), o.length === 1 && (S[t] = o[0]), S.removeListener !== void 0 && this.emit("removeListener", t, M || h);
  }
  return this;
};
EventEmitter$1.prototype.off = EventEmitter$1.prototype.removeListener;
EventEmitter$1.prototype.removeAllListeners = function(t) {
  var h, o, S;
  if (o = this._events, o === void 0)
    return this;
  if (o.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : o[t] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete o[t]), this;
  if (arguments.length === 0) {
    var g = Object.keys(o), B;
    for (S = 0; S < g.length; ++S)
      B = g[S], B !== "removeListener" && this.removeAllListeners(B);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (h = o[t], typeof h == "function")
    this.removeListener(t, h);
  else if (h !== void 0)
    for (S = h.length - 1; S >= 0; S--)
      this.removeListener(t, h[S]);
  return this;
};
function _listeners(e, t, h) {
  var o = e._events;
  if (o === void 0)
    return [];
  var S = o[t];
  return S === void 0 ? [] : typeof S == "function" ? h ? [S.listener || S] : [S] : h ? unwrapListeners(S) : arrayClone$1(S, S.length);
}
EventEmitter$1.prototype.listeners = function(t) {
  return _listeners(this, t, !0);
};
EventEmitter$1.prototype.rawListeners = function(t) {
  return _listeners(this, t, !1);
};
EventEmitter$1.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : listenerCount.call(e, t);
};
EventEmitter$1.prototype.listenerCount = listenerCount;
function listenerCount(e) {
  var t = this._events;
  if (t !== void 0) {
    var h = t[e];
    if (typeof h == "function")
      return 1;
    if (h !== void 0)
      return h.length;
  }
  return 0;
}
EventEmitter$1.prototype.eventNames = function() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};
function arrayClone$1(e, t) {
  for (var h = new Array(t), o = 0; o < t; ++o)
    h[o] = e[o];
  return h;
}
function spliceOne(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function unwrapListeners(e) {
  for (var t = new Array(e.length), h = 0; h < t.length; ++h)
    t[h] = e[h].listener || e[h];
  return t;
}
function once(e, t) {
  return new Promise(function(h, o) {
    function S(B) {
      e.removeListener(t, g), o(B);
    }
    function g() {
      typeof e.removeListener == "function" && e.removeListener("error", S), h([].slice.call(arguments));
    }
    eventTargetAgnosticAddListener(e, t, g, { once: !0 }), t !== "error" && addErrorHandlerIfEventEmitter(e, S, { once: !0 });
  });
}
function addErrorHandlerIfEventEmitter(e, t, h) {
  typeof e.on == "function" && eventTargetAgnosticAddListener(e, "error", t, h);
}
function eventTargetAgnosticAddListener(e, t, h, o) {
  if (typeof e.on == "function")
    o.once ? e.once(t, h) : e.on(t, h);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function S(g) {
      o.once && e.removeEventListener(t, S), h(g);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var eventsExports = events$1.exports;
function safeApply(e, t, h) {
  try {
    Reflect.apply(e, t, h);
  } catch (o) {
    setTimeout(() => {
      throw o;
    });
  }
}
function arrayClone(e) {
  const t = e.length, h = new Array(t);
  for (let o = 0; o < t; o += 1)
    h[o] = e[o];
  return h;
}
class SafeEventEmitter extends eventsExports.EventEmitter {
  emit(t, ...h) {
    let o = t === "error";
    const S = this._events;
    if (S !== void 0)
      o = o && S.error === void 0;
    else if (!o)
      return !1;
    if (o) {
      let B;
      if (h.length > 0 && ([B] = h), B instanceof Error)
        throw B;
      const M = new Error(`Unhandled error.${B ? ` (${B.message})` : ""}`);
      throw M.context = B, M;
    }
    const g = S[t];
    if (g === void 0)
      return !1;
    if (typeof g == "function")
      safeApply(g, this, h);
    else {
      const B = g.length, M = arrayClone(g);
      for (let O = 0; O < B; O += 1)
        safeApply(M[O], this, h);
    }
    return !0;
  }
}
const name$2 = "@wepin/sdk-js", version$2 = "0.0.1", description$2 = "Wepin Widget Javascript SDK for Web", author$2 = "IoTrust, Co., Ltd.", homepage$1 = "https://github.com/WepinWallet/wepin-web-sdk-v1/", license$2 = "MIT", main$2 = "./dist/wepin-sdk-js.mjs", jsdelivr = "./dist/wepin-sdk-js.umd.js", types$2 = "./dist/src/index.d.ts", files$2 = [
  "dist"
], scripts$2 = {
  build: "vite build --mode production",
  dev: "vite build --mode development",
  watch: "vite build --watch",
  lint: "eslint . --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts --fix --ignore-path .gitignore"
}, keywords$2 = [
  "wepin",
  "wepinwallet",
  "wallet"
], dependencies$2 = {
  "@wepin/fetch-js": "link:../fetch",
  "@wepin/modal-js": "link:../modal",
  "@wepin/storage-js": "link:../storage",
  "@wepin/utils": "^1.0.3",
  events: "^3.3.0",
  "jwt-decode": "^4.0.0"
}, devDependencies$2 = {
  "@types/events": "^3.0.3"
}, PackageJson = {
  name: name$2,
  version: version$2,
  description: description$2,
  author: author$2,
  homepage: homepage$1,
  license: license$2,
  main: main$2,
  jsdelivr,
  types: types$2,
  files: files$2,
  scripts: scripts$2,
  keywords: keywords$2,
  dependencies: dependencies$2,
  devDependencies: devDependencies$2
}, WEPIN_DEFAULT_LANG = "ko", WEPIN_DEFAULT_CURRENCY = "krw", BM = class BM {
};
BM.test = console.warn.bind(window.console, "[SDK][test] "), BM.warn = console.warn.bind(window.console, "[SDK][warn] "), BM.error = console.error.bind(window.console, "[SDK][error] "), BM.todo = console.warn.bind(window.console, "[SDK][todo] "), BM.assert = console.assert.bind(window.console), BM.debug = () => {
};
let LOG = BM;
const CM = class CM {
  static isMobile() {
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
      navigator.userAgent
    );
  }
  static messages(t) {
    return {
      hasValidOrigin: (h) => h.origin === CM.getUrls(t).wepinWebview
      // hasCorrectCorrelationID(message: MessageEvent,
      //                         correlationID: string | undefined) {
      //     return correlationID && message.data && message.data.correlationID === correlationID;
      // }
    };
  }
  static getUrls(t) {
    switch (t) {
      case "production":
        return {
          wepinWebview: "https://v1-widget.wepin.io"
        };
      case "test":
        return {
          wepinWebview: "https://stage-v1-widget.wepin.io"
        };
      case "development":
        return {
          // wepinWebview: `https://localhost:8989`,
          wepinWebview: "https://dev-v1-widget.wepin.io"
        };
      case "local":
        return {
          wepinWebview: "https://local-widget.wepin.io"
        };
      default:
        throw new Error("Utils.getUrls: invalid mode");
    }
  }
  static uuidv4() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(
      /[xy]/g,
      function(t) {
        const h = Math.random() * 16 | 0;
        return (t == "x" ? h : h & 3 | 8).toString(16);
      }
    );
  }
};
CM.checkSameNumber = (t, h, o) => {
  if (o)
    return !1;
  const S = [...Array(10)].map(Number.prototype.valueOf, 0);
  let g = !1;
  return [...t].forEach((M) => {
    if (S[Number(M)]++, S[Number(M)] >= h) {
      g = !0;
      return;
    }
  }), g;
};
let Utils = CM;
const w = class {
  static closeOverlay(t) {
    const h = document.querySelector(`#${t}`);
    h && h.parentNode && h.parentNode.removeChild(h);
  }
  static openOverlay(t) {
    const h = document.createElement("div");
    h.id = t, h.classList.add(this.CONST.overlayClassName), h.style.zIndex = "2147483647", h.style.display = "flex", h.style.alignItems = "center", h.style.justifyContent = "center", h.style.textAlign = "center", h.style.position = "fixed", h.style.left = "0px", h.style.right = "0px", h.style.top = "0px", h.style.bottom = "0px", h.style.left = "0px", h.style.background = "rgba(0,0,0,0.6)", h.style.color = "white", h.style.border = "2px solid #f1f1f1";
    const o = document.getElementsByClassName(
      this.CONST.overlayClassName
    );
    for (let S = 0; S < o.length; S++) {
      const g = o.item(S);
      g && g.remove();
    }
    document.body.appendChild(h);
  }
};
w.CONST = {
  overlayClassName: "wepin-widget__overlay"
};
let p = w;
const y = (e) => {
  const t = (e == null ? void 0 : e.width) || 375, h = (e == null ? void 0 : e.height) || 604, o = e != null && e.sLeft ? e == null ? void 0 : e.sLeft : window.screenLeft ? window.screenLeft : window.screenX ? window.screenX : 0, S = e != null && e.sTop ? e == null ? void 0 : e.sTop : window.screenTop ? window.screenTop : window.screenY ? window.screenY : 0, g = screen.width / 2 - t / 2 + o, B = screen.height / 2 - h / 2 + S;
  return `width=${t}, height=${h}, left=${g}, top=${B}scrollbars=yes, resizable=1, menubar=no, toolbar=no`;
}, m = (e) => {
  const t = document.createElement("iframe");
  return t.classList.add("wepin-sdk-widget-iframe"), t.setAttribute("frameborder", "0"), t.setAttribute("marginwidth", "0"), t.setAttribute("marginheight", "0"), t.style.width = "100%", e && e != null && e.isHide ? t.style.height = "0" : t.style.height = "100%", t.style.maxHeight = "100%", t.style.position = "fixed", t.style.bottom = "0", t.style.left = "0", t.style.zIndex = "408888000000", t.title = "wepin sdk webview", t.allow = "accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; camera; clipboard-read", t.allowFullscreen = !0, t;
}, v = () => "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(e) {
  const t = Math.random() * 16 | 0;
  return (e == "x" ? t : t & 3 | 8).toString(16);
}), r = class IM extends p {
  constructor(t, h, o, S, g) {
    super(), this.isWidgetReady = !1, this.url = t, this.id = `id-${v()}`, this.isHide = g, g || IM.openOverlay(this.id), IM._webview[this.id] = h, this.type = o, this.EL = S, window.addEventListener("message", this.EL), this._open = !0;
  }
  get isOpen() {
    return this._open;
  }
  // For communicating with the Wepin instance
  // private _wepin: Wepin
  // public get Wepin() {
  //   return this._wepin
  // }
  // For communicating with the Webview
  // private _webview: HTMLIFrameElement
  static getWebview(t) {
    return IM._webview[t];
  }
  static clearWebview(t) {
    delete IM._webview[t];
  }
  static clearAllWebview() {
    this._webview = {};
  }
  close() {
    this.isHide || IM.closeOverlay(this.id), window.removeEventListener("message", this.EL), this._open = !1, this.isWidgetReady = !1, this._closeWebview();
  }
  response(t) {
    try {
      this._post(t);
    } catch (h) {
      console.error("Can not response message to the webview", h);
    }
  }
  request(t) {
    try {
      this._post(t);
    } catch (h) {
      console.error("Can not send message to the webview", h);
    }
  }
};
r._webview = {};
let l$2 = r;
class a extends l$2 {
  // is it necessary ?
  constructor({
    url: t,
    // wepin,
    frame: h,
    EL: o,
    isHide: S
  }) {
    super(t, h, "Frame", o, S), h.src = t, h.id = this.id;
    const g = document.querySelector("body");
    a.scrollPosition = window.pageYOffset, g.style.overflow = "hidden", g.style.position = "fixed", g.style.top = `-${a.scrollPosition}px`, g.style.width = "100%", document.body.appendChild(h);
  }
  static async openNew({
    url: t,
    EL: h,
    widgetOptions: o
  }) {
    const S = m({ isHide: o == null ? void 0 : o.isHide });
    return new a({
      url: t,
      // wepin,
      frame: S,
      EL: h,
      isHide: o == null ? void 0 : o.isHide
    });
  }
  expand() {
    const t = l$2.getWebview(this.id);
    t.style.height = "100%", t.style.borderRadius = "0";
  }
  shrink() {
    const t = l$2.getWebview(this.id);
    t.style.height = "604px", t.style.borderRadius = "12px 12px 0 0 ";
  }
  _closeWebview() {
    const t = setTimeout(() => {
      const h = l$2.getWebview(this.id), o = document.querySelector("body");
      o.style.removeProperty("overflow"), o.style.removeProperty("position"), o.style.removeProperty("top"), o.style.removeProperty("width"), window.scrollTo(0, a.scrollPosition), h && document.body.removeChild(h), l$2.clearWebview(this.id), clearTimeout(t);
    }, 500);
  }
  _post(t) {
    l$2.getWebview(this.id).contentWindow.postMessage(t, this.url);
  }
}
class d extends l$2 {
  constructor({
    url: t,
    webview: h,
    EL: o
  }) {
    super(t, h, "Window", o, !1);
  }
  //: NodeJS.Timer | number
  static async openNew({
    url: t,
    EL: h,
    widgetFeatures: o
  }) {
    const S = y(o), g = window.open(t, "Wepin_Widget", S), B = new d({
      url: t,
      webview: g,
      EL: h
    });
    if (!g)
      throw B.close(), new Error("popup window blocked");
    return this.timer = setInterval(() => {
      try {
        g && g.closed && (clearInterval(this.timer), B.close());
      } catch {
        clearInterval(this.timer), B.close();
      }
    }, 200), B;
  }
  expand() {
  }
  shrink() {
  }
  _closeWebview() {
    d.timer && (clearInterval(d.timer), d.timer = void 0);
    const t = l$2.getWebview(this.id);
    t && t.close(), l$2.clearWebview(this.id);
  }
  _post(t) {
    l$2.getWebview(this.id).postMessage(t, this.url);
  }
}
const x = "@wepin/modal-js", b = "0.0.1", f = "wepin widget modal", u$2 = "IoTrust, Co., Ltd.", W = "MIT", C = "./dist/wepin-modal-js.mjs", T = "dist/wepin-modal-js.umd.js", L = "./dist/src/index.d.ts", N = [
  "dist"
], _ = {
  build: "vite build --mode production",
  dev: "vite build --mode development",
  watch: "vite build --watch",
  lint: "eslint . --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts --fix --ignore-path .gitignore"
}, j = [
  "wepin",
  "wepinwallet",
  "wallet",
  "wepin-modal"
], E = {
  name: x,
  version: b,
  description: f,
  author: u$2,
  license: W,
  main: C,
  jsdelivr: T,
  types: L,
  files: N,
  scripts: _,
  keywords: j
};
class k {
  //   constructor(appKey: string, appId: string) {
  constructor() {
    this.platformType = "web", this._modalWindow = null, this._modalFrame = null, console.log(`WepinModal v${E.version}`), this.domain = window.location.origin;
  }
  //   async init() {
  //     // getAppInfo수행해보고기..
  //     this._appId
  //     this._appKey
  //     this._isInitialized = true
  //     return this._isInitialized
  //   }
  async openAuthBrowser(t, h) {
    return this._modalWindow = await d.openNew({
      url: t,
      EL: h
    }), this._modalWindow;
  }
  async openModal(t, h, o) {
    return this._modalFrame = await a.openNew({
      url: t,
      EL: h,
      widgetOptions: o
    }), this._modalFrame;
  }
  async closeAuthBrowser() {
    this._modalWindow && this._modalWindow.close();
  }
  async closeModal() {
    this._modalFrame && this._modalFrame.close();
  }
}
const proxyToObject = (e) => {
  if (typeof e != "object" || e === null)
    return e;
  if (Array.isArray(e))
    return e.map(proxyToObject);
  const t = {};
  for (const h of Object.keys(e))
    t[h] = proxyToObject(e[h]);
  return t;
};
var Platform = /* @__PURE__ */ ((e) => (e[e.web = 1] = "web", e[e.android = 2] = "android", e[e.ios = 3] = "ios", e))(Platform || {});
const WebviewRequestHandler = (e, t, h) => {
  var g, B;
  const o = {
    header: {
      response_from: "web",
      response_to: "wepin_widget",
      id: e.header.id
    }
  };
  let S = h.appKey;
  switch (h.appKey.slice(0, 13) === "local_ak_dev_" ? S = h.appKey.slice(6) : S = h.appKey, e.body.command) {
    case "ready_to_widget":
      {
        LOG.debug("ready_to_widget");
        const M = Object.assign({}, t.wepinAppAttributes), O = (g = t.wepinAppAttributes.loginProviders) != null && g.length ? Array.from(t.wepinAppAttributes.loginProviders) : void 0;
        M.loginProviders = O, o.body = {
          command: "ready_to_widget",
          state: "SUCCESS",
          data: {
            appKey: S,
            appId: h.appId,
            domain: t.wepinDomain,
            platform: Platform[t.type],
            attributes: M,
            //Object.assign({}, wepinSDK.wepinAppAttributes),
            version: t.version.includes("-alpha") ? t.version.substring(0, t.version.indexOf("-")) : t.version,
            type: `${t.type}-sdk`,
            localDate: t.wepinStorage.getAllLocalStorage(h.appId) ?? {}
          }
        };
      }
      break;
    case "close_wepin_widget":
      {
        t.wepinWidget && (t.wepinWidget.close(), t.wepinWidget = void 0);
        const M = t.wepinStorage.getLocalStorage(
          h.appId,
          "user_info"
        );
        M ? t.setUserInfo(M, !0) : t.setUserInfo({ status: "fail" }, !0), t.removeAllListeners(), t.specifiedEmail = void 0;
      }
      break;
    case "set_local_storage":
      t.wepinStorage.setAllLocalStorage(
        h.appId,
        e.body.parameter.data
      ), e.body.parameter.data && e.body.parameter.data.user_info && t.setUserInfo(e.body.parameter.data.user_info, !0), e.body.parameter.data && e.body.parameter.data["wepin:connectUser"] && t.setToken(e.body.parameter.data["wepin:connectUser"]), o.body = {
        command: "set_local_storage",
        state: "SUCCESS",
        data: ""
      };
      break;
    case "set_user_email":
      o.body = {
        command: "set_user_email",
        state: "SUCCESS",
        data: {
          email: t.specifiedEmail
        }
      };
      break;
    case "get_sdk_request":
      LOG.debug("get_sdk_request", t.getSDKRequest() ?? "No request"), o.body = {
        command: "get_sdk_request",
        state: "SUCCESS",
        data: proxyToObject(t.getSDKRequest()) ?? "No request"
      };
      break;
    default:
      throw new Error(`Command ${e.body.command} is not supported.`);
  }
  (B = t.wepinWidget) != null && B.isOpen && t.wepinWidget.response(o);
}, WebviewResponseHandler = (e, t) => {
  LOG.debug("Got Response from webview =>", e), t.emit(e.header.id.toString(), e);
}, getEventListener = (e, t) => {
  const h = (o) => !(!(e.wepinWidget.url.includes("/wepin-sdk-login") || e.wepinWidget.url.includes(o.origin)) && o.origin !== e.wepinWidget.url || !Object.prototype.hasOwnProperty.call(o.data, "header") || !Object.prototype.hasOwnProperty.call(o.data, "body"));
  return (o) => {
    h(o) && handleMessage(
      o.data,
      e,
      t
    );
  };
}, handleMessage = (e, t, h) => {
  e.header.request_to === "web" ? WebviewRequestHandler(e, t, h) : e.header.response_to === "web" ? WebviewResponseHandler(e, t) : LOG.error("Failed to handle message:", e);
}, emailRegExp = /^[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*@[0-9a-zA-Z]([-_.]?[0-9a-zA-Z])*\.[a-zA-Z]{2,3}$/, pinRegExp = /^\d{6,8}$/;
var buffer$2 = {}, base64Js$1 = {};
base64Js$1.byteLength = byteLength;
base64Js$1.toByteArray = toByteArray;
base64Js$1.fromByteArray = fromByteArray;
var lookup = [], revLookup = [], Arr = typeof Uint8Array < "u" ? Uint8Array : Array, code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var i$2 = 0, len = code.length; i$2 < len; ++i$2)
  lookup[i$2] = code[i$2], revLookup[code.charCodeAt(i$2)] = i$2;
revLookup[45] = 62;
revLookup[95] = 63;
function getLens(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var h = e.indexOf("=");
  h === -1 && (h = t);
  var o = h === t ? 0 : 4 - h % 4;
  return [h, o];
}
function byteLength(e) {
  var t = getLens(e), h = t[0], o = t[1];
  return (h + o) * 3 / 4 - o;
}
function _byteLength(e, t, h) {
  return (t + h) * 3 / 4 - h;
}
function toByteArray(e) {
  var t, h = getLens(e), o = h[0], S = h[1], g = new Arr(_byteLength(e, o, S)), B = 0, M = S > 0 ? o - 4 : o, O;
  for (O = 0; O < M; O += 4)
    t = revLookup[e.charCodeAt(O)] << 18 | revLookup[e.charCodeAt(O + 1)] << 12 | revLookup[e.charCodeAt(O + 2)] << 6 | revLookup[e.charCodeAt(O + 3)], g[B++] = t >> 16 & 255, g[B++] = t >> 8 & 255, g[B++] = t & 255;
  return S === 2 && (t = revLookup[e.charCodeAt(O)] << 2 | revLookup[e.charCodeAt(O + 1)] >> 4, g[B++] = t & 255), S === 1 && (t = revLookup[e.charCodeAt(O)] << 10 | revLookup[e.charCodeAt(O + 1)] << 4 | revLookup[e.charCodeAt(O + 2)] >> 2, g[B++] = t >> 8 & 255, g[B++] = t & 255), g;
}
function tripletToBase64(e) {
  return lookup[e >> 18 & 63] + lookup[e >> 12 & 63] + lookup[e >> 6 & 63] + lookup[e & 63];
}
function encodeChunk(e, t, h) {
  for (var o, S = [], g = t; g < h; g += 3)
    o = (e[g] << 16 & 16711680) + (e[g + 1] << 8 & 65280) + (e[g + 2] & 255), S.push(tripletToBase64(o));
  return S.join("");
}
function fromByteArray(e) {
  for (var t, h = e.length, o = h % 3, S = [], g = 16383, B = 0, M = h - o; B < M; B += g)
    S.push(encodeChunk(e, B, B + g > M ? M : B + g));
  return o === 1 ? (t = e[h - 1], S.push(
    lookup[t >> 2] + lookup[t << 4 & 63] + "=="
  )) : o === 2 && (t = (e[h - 2] << 8) + e[h - 1], S.push(
    lookup[t >> 10] + lookup[t >> 4 & 63] + lookup[t << 2 & 63] + "="
  )), S.join("");
}
var ieee754$1 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
ieee754$1.read = function(e, t, h, o, S) {
  var g, B, M = S * 8 - o - 1, O = (1 << M) - 1, P = O >> 1, D = -7, Z = h ? S - 1 : 0, Y = h ? -1 : 1, ee = e[t + Z];
  for (Z += Y, g = ee & (1 << -D) - 1, ee >>= -D, D += M; D > 0; g = g * 256 + e[t + Z], Z += Y, D -= 8)
    ;
  for (B = g & (1 << -D) - 1, g >>= -D, D += o; D > 0; B = B * 256 + e[t + Z], Z += Y, D -= 8)
    ;
  if (g === 0)
    g = 1 - P;
  else {
    if (g === O)
      return B ? NaN : (ee ? -1 : 1) * (1 / 0);
    B = B + Math.pow(2, o), g = g - P;
  }
  return (ee ? -1 : 1) * B * Math.pow(2, g - o);
};
ieee754$1.write = function(e, t, h, o, S, g) {
  var B, M, O, P = g * 8 - S - 1, D = (1 << P) - 1, Z = D >> 1, Y = S === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ee = o ? 0 : g - 1, ie = o ? 1 : -1, ue = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (M = isNaN(t) ? 1 : 0, B = D) : (B = Math.floor(Math.log(t) / Math.LN2), t * (O = Math.pow(2, -B)) < 1 && (B--, O *= 2), B + Z >= 1 ? t += Y / O : t += Y * Math.pow(2, 1 - Z), t * O >= 2 && (B++, O /= 2), B + Z >= D ? (M = 0, B = D) : B + Z >= 1 ? (M = (t * O - 1) * Math.pow(2, S), B = B + Z) : (M = t * Math.pow(2, Z - 1) * Math.pow(2, S), B = 0)); S >= 8; e[h + ee] = M & 255, ee += ie, M /= 256, S -= 8)
    ;
  for (B = B << S | M, P += S; P > 0; e[h + ee] = B & 255, ee += ie, B /= 256, P -= 8)
    ;
  e[h + ee - ie] |= ue * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  var t = base64Js$1, h = ieee754$1, o = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = M, e.SlowBuffer = ce, e.INSPECT_MAX_BYTES = 50;
  var S = 2147483647;
  e.kMaxLength = S, M.TYPED_ARRAY_SUPPORT = g(), !M.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function g() {
    try {
      var re = new Uint8Array(1), oe = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(oe, Uint8Array.prototype), Object.setPrototypeOf(re, oe), re.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(M.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (M.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(M.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (M.isBuffer(this))
        return this.byteOffset;
    }
  });
  function B(re) {
    if (re > S)
      throw new RangeError('The value "' + re + '" is invalid for option "size"');
    var oe = new Uint8Array(re);
    return Object.setPrototypeOf(oe, M.prototype), oe;
  }
  function M(re, oe, le) {
    if (typeof re == "number") {
      if (typeof oe == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return Z(re);
    }
    return O(re, oe, le);
  }
  M.poolSize = 8192;
  function O(re, oe, le) {
    if (typeof re == "string")
      return Y(re, oe);
    if (ArrayBuffer.isView(re))
      return ie(re);
    if (re == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof re
      );
    if (Xe(re, ArrayBuffer) || re && Xe(re.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Xe(re, SharedArrayBuffer) || re && Xe(re.buffer, SharedArrayBuffer)))
      return ue(re, oe, le);
    if (typeof re == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    var ge = re.valueOf && re.valueOf();
    if (ge != null && ge !== re)
      return M.from(ge, oe, le);
    var Ke = fe(re);
    if (Ke)
      return Ke;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof re[Symbol.toPrimitive] == "function")
      return M.from(
        re[Symbol.toPrimitive]("string"),
        oe,
        le
      );
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof re
    );
  }
  M.from = function(re, oe, le) {
    return O(re, oe, le);
  }, Object.setPrototypeOf(M.prototype, Uint8Array.prototype), Object.setPrototypeOf(M, Uint8Array);
  function P(re) {
    if (typeof re != "number")
      throw new TypeError('"size" argument must be of type number');
    if (re < 0)
      throw new RangeError('The value "' + re + '" is invalid for option "size"');
  }
  function D(re, oe, le) {
    return P(re), re <= 0 ? B(re) : oe !== void 0 ? typeof le == "string" ? B(re).fill(oe, le) : B(re).fill(oe) : B(re);
  }
  M.alloc = function(re, oe, le) {
    return D(re, oe, le);
  };
  function Z(re) {
    return P(re), B(re < 0 ? 0 : de(re) | 0);
  }
  M.allocUnsafe = function(re) {
    return Z(re);
  }, M.allocUnsafeSlow = function(re) {
    return Z(re);
  };
  function Y(re, oe) {
    if ((typeof oe != "string" || oe === "") && (oe = "utf8"), !M.isEncoding(oe))
      throw new TypeError("Unknown encoding: " + oe);
    var le = be(re, oe) | 0, ge = B(le), Ke = ge.write(re, oe);
    return Ke !== le && (ge = ge.slice(0, Ke)), ge;
  }
  function ee(re) {
    for (var oe = re.length < 0 ? 0 : de(re.length) | 0, le = B(oe), ge = 0; ge < oe; ge += 1)
      le[ge] = re[ge] & 255;
    return le;
  }
  function ie(re) {
    if (Xe(re, Uint8Array)) {
      var oe = new Uint8Array(re);
      return ue(oe.buffer, oe.byteOffset, oe.byteLength);
    }
    return ee(re);
  }
  function ue(re, oe, le) {
    if (oe < 0 || re.byteLength < oe)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (re.byteLength < oe + (le || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var ge;
    return oe === void 0 && le === void 0 ? ge = new Uint8Array(re) : le === void 0 ? ge = new Uint8Array(re, oe) : ge = new Uint8Array(re, oe, le), Object.setPrototypeOf(ge, M.prototype), ge;
  }
  function fe(re) {
    if (M.isBuffer(re)) {
      var oe = de(re.length) | 0, le = B(oe);
      return le.length === 0 || re.copy(le, 0, 0, oe), le;
    }
    if (re.length !== void 0)
      return typeof re.length != "number" || et(re.length) ? B(0) : ee(re);
    if (re.type === "Buffer" && Array.isArray(re.data))
      return ee(re.data);
  }
  function de(re) {
    if (re >= S)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + S.toString(16) + " bytes");
    return re | 0;
  }
  function ce(re) {
    return +re != re && (re = 0), M.alloc(+re);
  }
  M.isBuffer = function(oe) {
    return oe != null && oe._isBuffer === !0 && oe !== M.prototype;
  }, M.compare = function(oe, le) {
    if (Xe(oe, Uint8Array) && (oe = M.from(oe, oe.offset, oe.byteLength)), Xe(le, Uint8Array) && (le = M.from(le, le.offset, le.byteLength)), !M.isBuffer(oe) || !M.isBuffer(le))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (oe === le)
      return 0;
    for (var ge = oe.length, Ke = le.length, Je = 0, Fe = Math.min(ge, Ke); Je < Fe; ++Je)
      if (oe[Je] !== le[Je]) {
        ge = oe[Je], Ke = le[Je];
        break;
      }
    return ge < Ke ? -1 : Ke < ge ? 1 : 0;
  }, M.isEncoding = function(oe) {
    switch (String(oe).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, M.concat = function(oe, le) {
    if (!Array.isArray(oe))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (oe.length === 0)
      return M.alloc(0);
    var ge;
    if (le === void 0)
      for (le = 0, ge = 0; ge < oe.length; ++ge)
        le += oe[ge].length;
    var Ke = M.allocUnsafe(le), Je = 0;
    for (ge = 0; ge < oe.length; ++ge) {
      var Fe = oe[ge];
      if (Xe(Fe, Uint8Array))
        Je + Fe.length > Ke.length ? M.from(Fe).copy(Ke, Je) : Uint8Array.prototype.set.call(
          Ke,
          Fe,
          Je
        );
      else if (M.isBuffer(Fe))
        Fe.copy(Ke, Je);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      Je += Fe.length;
    }
    return Ke;
  };
  function be(re, oe) {
    if (M.isBuffer(re))
      return re.length;
    if (ArrayBuffer.isView(re) || Xe(re, ArrayBuffer))
      return re.byteLength;
    if (typeof re != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof re
      );
    var le = re.length, ge = arguments.length > 2 && arguments[2] === !0;
    if (!ge && le === 0)
      return 0;
    for (var Ke = !1; ; )
      switch (oe) {
        case "ascii":
        case "latin1":
        case "binary":
          return le;
        case "utf8":
        case "utf-8":
          return ke(re).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return le * 2;
        case "hex":
          return le >>> 1;
        case "base64":
          return qe(re).length;
        default:
          if (Ke)
            return ge ? -1 : ke(re).length;
          oe = ("" + oe).toLowerCase(), Ke = !0;
      }
  }
  M.byteLength = be;
  function ve(re, oe, le) {
    var ge = !1;
    if ((oe === void 0 || oe < 0) && (oe = 0), oe > this.length || ((le === void 0 || le > this.length) && (le = this.length), le <= 0) || (le >>>= 0, oe >>>= 0, le <= oe))
      return "";
    for (re || (re = "utf8"); ; )
      switch (re) {
        case "hex":
          return $(this, oe, le);
        case "utf8":
        case "utf-8":
          return I(this, oe, le);
        case "ascii":
          return Q(this, oe, le);
        case "latin1":
        case "binary":
          return F(this, oe, le);
        case "base64":
          return A(this, oe, le);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return H(this, oe, le);
        default:
          if (ge)
            throw new TypeError("Unknown encoding: " + re);
          re = (re + "").toLowerCase(), ge = !0;
      }
  }
  M.prototype._isBuffer = !0;
  function Pe(re, oe, le) {
    var ge = re[oe];
    re[oe] = re[le], re[le] = ge;
  }
  M.prototype.swap16 = function() {
    var oe = this.length;
    if (oe % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var le = 0; le < oe; le += 2)
      Pe(this, le, le + 1);
    return this;
  }, M.prototype.swap32 = function() {
    var oe = this.length;
    if (oe % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var le = 0; le < oe; le += 4)
      Pe(this, le, le + 3), Pe(this, le + 1, le + 2);
    return this;
  }, M.prototype.swap64 = function() {
    var oe = this.length;
    if (oe % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var le = 0; le < oe; le += 8)
      Pe(this, le, le + 7), Pe(this, le + 1, le + 6), Pe(this, le + 2, le + 5), Pe(this, le + 3, le + 4);
    return this;
  }, M.prototype.toString = function() {
    var oe = this.length;
    return oe === 0 ? "" : arguments.length === 0 ? I(this, 0, oe) : ve.apply(this, arguments);
  }, M.prototype.toLocaleString = M.prototype.toString, M.prototype.equals = function(oe) {
    if (!M.isBuffer(oe))
      throw new TypeError("Argument must be a Buffer");
    return this === oe ? !0 : M.compare(this, oe) === 0;
  }, M.prototype.inspect = function() {
    var oe = "", le = e.INSPECT_MAX_BYTES;
    return oe = this.toString("hex", 0, le).replace(/(.{2})/g, "$1 ").trim(), this.length > le && (oe += " ... "), "<Buffer " + oe + ">";
  }, o && (M.prototype[o] = M.prototype.inspect), M.prototype.compare = function(oe, le, ge, Ke, Je) {
    if (Xe(oe, Uint8Array) && (oe = M.from(oe, oe.offset, oe.byteLength)), !M.isBuffer(oe))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof oe
      );
    if (le === void 0 && (le = 0), ge === void 0 && (ge = oe ? oe.length : 0), Ke === void 0 && (Ke = 0), Je === void 0 && (Je = this.length), le < 0 || ge > oe.length || Ke < 0 || Je > this.length)
      throw new RangeError("out of range index");
    if (Ke >= Je && le >= ge)
      return 0;
    if (Ke >= Je)
      return -1;
    if (le >= ge)
      return 1;
    if (le >>>= 0, ge >>>= 0, Ke >>>= 0, Je >>>= 0, this === oe)
      return 0;
    for (var Fe = Je - Ke, Ye = ge - le, it = Math.min(Fe, Ye), rt = this.slice(Ke, Je), tt = oe.slice(le, ge), vt = 0; vt < it; ++vt)
      if (rt[vt] !== tt[vt]) {
        Fe = rt[vt], Ye = tt[vt];
        break;
      }
    return Fe < Ye ? -1 : Ye < Fe ? 1 : 0;
  };
  function Ue(re, oe, le, ge, Ke) {
    if (re.length === 0)
      return -1;
    if (typeof le == "string" ? (ge = le, le = 0) : le > 2147483647 ? le = 2147483647 : le < -2147483648 && (le = -2147483648), le = +le, et(le) && (le = Ke ? 0 : re.length - 1), le < 0 && (le = re.length + le), le >= re.length) {
      if (Ke)
        return -1;
      le = re.length - 1;
    } else if (le < 0)
      if (Ke)
        le = 0;
      else
        return -1;
    if (typeof oe == "string" && (oe = M.from(oe, ge)), M.isBuffer(oe))
      return oe.length === 0 ? -1 : ze(re, oe, le, ge, Ke);
    if (typeof oe == "number")
      return oe = oe & 255, typeof Uint8Array.prototype.indexOf == "function" ? Ke ? Uint8Array.prototype.indexOf.call(re, oe, le) : Uint8Array.prototype.lastIndexOf.call(re, oe, le) : ze(re, [oe], le, ge, Ke);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ze(re, oe, le, ge, Ke) {
    var Je = 1, Fe = re.length, Ye = oe.length;
    if (ge !== void 0 && (ge = String(ge).toLowerCase(), ge === "ucs2" || ge === "ucs-2" || ge === "utf16le" || ge === "utf-16le")) {
      if (re.length < 2 || oe.length < 2)
        return -1;
      Je = 2, Fe /= 2, Ye /= 2, le /= 2;
    }
    function it(ot, si) {
      return Je === 1 ? ot[si] : ot.readUInt16BE(si * Je);
    }
    var rt;
    if (Ke) {
      var tt = -1;
      for (rt = le; rt < Fe; rt++)
        if (it(re, rt) === it(oe, tt === -1 ? 0 : rt - tt)) {
          if (tt === -1 && (tt = rt), rt - tt + 1 === Ye)
            return tt * Je;
        } else
          tt !== -1 && (rt -= rt - tt), tt = -1;
    } else
      for (le + Ye > Fe && (le = Fe - Ye), rt = le; rt >= 0; rt--) {
        for (var vt = !0, St = 0; St < Ye; St++)
          if (it(re, rt + St) !== it(oe, St)) {
            vt = !1;
            break;
          }
        if (vt)
          return rt;
      }
    return -1;
  }
  M.prototype.includes = function(oe, le, ge) {
    return this.indexOf(oe, le, ge) !== -1;
  }, M.prototype.indexOf = function(oe, le, ge) {
    return Ue(this, oe, le, ge, !0);
  }, M.prototype.lastIndexOf = function(oe, le, ge) {
    return Ue(this, oe, le, ge, !1);
  };
  function Le(re, oe, le, ge) {
    le = Number(le) || 0;
    var Ke = re.length - le;
    ge ? (ge = Number(ge), ge > Ke && (ge = Ke)) : ge = Ke;
    var Je = oe.length;
    ge > Je / 2 && (ge = Je / 2);
    for (var Fe = 0; Fe < ge; ++Fe) {
      var Ye = parseInt(oe.substr(Fe * 2, 2), 16);
      if (et(Ye))
        return Fe;
      re[le + Fe] = Ye;
    }
    return Fe;
  }
  function Ne(re, oe, le, ge) {
    return Oe(ke(oe, re.length - le), re, le, ge);
  }
  function $e(re, oe, le, ge) {
    return Oe(Qe(oe), re, le, ge);
  }
  function J(re, oe, le, ge) {
    return Oe(qe(oe), re, le, ge);
  }
  function ne(re, oe, le, ge) {
    return Oe(Ze(oe, re.length - le), re, le, ge);
  }
  M.prototype.write = function(oe, le, ge, Ke) {
    if (le === void 0)
      Ke = "utf8", ge = this.length, le = 0;
    else if (ge === void 0 && typeof le == "string")
      Ke = le, ge = this.length, le = 0;
    else if (isFinite(le))
      le = le >>> 0, isFinite(ge) ? (ge = ge >>> 0, Ke === void 0 && (Ke = "utf8")) : (Ke = ge, ge = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    var Je = this.length - le;
    if ((ge === void 0 || ge > Je) && (ge = Je), oe.length > 0 && (ge < 0 || le < 0) || le > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    Ke || (Ke = "utf8");
    for (var Fe = !1; ; )
      switch (Ke) {
        case "hex":
          return Le(this, oe, le, ge);
        case "utf8":
        case "utf-8":
          return Ne(this, oe, le, ge);
        case "ascii":
        case "latin1":
        case "binary":
          return $e(this, oe, le, ge);
        case "base64":
          return J(this, oe, le, ge);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ne(this, oe, le, ge);
        default:
          if (Fe)
            throw new TypeError("Unknown encoding: " + Ke);
          Ke = ("" + Ke).toLowerCase(), Fe = !0;
      }
  }, M.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function A(re, oe, le) {
    return oe === 0 && le === re.length ? t.fromByteArray(re) : t.fromByteArray(re.slice(oe, le));
  }
  function I(re, oe, le) {
    le = Math.min(re.length, le);
    for (var ge = [], Ke = oe; Ke < le; ) {
      var Je = re[Ke], Fe = null, Ye = Je > 239 ? 4 : Je > 223 ? 3 : Je > 191 ? 2 : 1;
      if (Ke + Ye <= le) {
        var it, rt, tt, vt;
        switch (Ye) {
          case 1:
            Je < 128 && (Fe = Je);
            break;
          case 2:
            it = re[Ke + 1], (it & 192) === 128 && (vt = (Je & 31) << 6 | it & 63, vt > 127 && (Fe = vt));
            break;
          case 3:
            it = re[Ke + 1], rt = re[Ke + 2], (it & 192) === 128 && (rt & 192) === 128 && (vt = (Je & 15) << 12 | (it & 63) << 6 | rt & 63, vt > 2047 && (vt < 55296 || vt > 57343) && (Fe = vt));
            break;
          case 4:
            it = re[Ke + 1], rt = re[Ke + 2], tt = re[Ke + 3], (it & 192) === 128 && (rt & 192) === 128 && (tt & 192) === 128 && (vt = (Je & 15) << 18 | (it & 63) << 12 | (rt & 63) << 6 | tt & 63, vt > 65535 && vt < 1114112 && (Fe = vt));
        }
      }
      Fe === null ? (Fe = 65533, Ye = 1) : Fe > 65535 && (Fe -= 65536, ge.push(Fe >>> 10 & 1023 | 55296), Fe = 56320 | Fe & 1023), ge.push(Fe), Ke += Ye;
    }
    return X(ge);
  }
  var U = 4096;
  function X(re) {
    var oe = re.length;
    if (oe <= U)
      return String.fromCharCode.apply(String, re);
    for (var le = "", ge = 0; ge < oe; )
      le += String.fromCharCode.apply(
        String,
        re.slice(ge, ge += U)
      );
    return le;
  }
  function Q(re, oe, le) {
    var ge = "";
    le = Math.min(re.length, le);
    for (var Ke = oe; Ke < le; ++Ke)
      ge += String.fromCharCode(re[Ke] & 127);
    return ge;
  }
  function F(re, oe, le) {
    var ge = "";
    le = Math.min(re.length, le);
    for (var Ke = oe; Ke < le; ++Ke)
      ge += String.fromCharCode(re[Ke]);
    return ge;
  }
  function $(re, oe, le) {
    var ge = re.length;
    (!oe || oe < 0) && (oe = 0), (!le || le < 0 || le > ge) && (le = ge);
    for (var Ke = "", Je = oe; Je < le; ++Je)
      Ke += nt[re[Je]];
    return Ke;
  }
  function H(re, oe, le) {
    for (var ge = re.slice(oe, le), Ke = "", Je = 0; Je < ge.length - 1; Je += 2)
      Ke += String.fromCharCode(ge[Je] + ge[Je + 1] * 256);
    return Ke;
  }
  M.prototype.slice = function(oe, le) {
    var ge = this.length;
    oe = ~~oe, le = le === void 0 ? ge : ~~le, oe < 0 ? (oe += ge, oe < 0 && (oe = 0)) : oe > ge && (oe = ge), le < 0 ? (le += ge, le < 0 && (le = 0)) : le > ge && (le = ge), le < oe && (le = oe);
    var Ke = this.subarray(oe, le);
    return Object.setPrototypeOf(Ke, M.prototype), Ke;
  };
  function q(re, oe, le) {
    if (re % 1 !== 0 || re < 0)
      throw new RangeError("offset is not uint");
    if (re + oe > le)
      throw new RangeError("Trying to access beyond buffer length");
  }
  M.prototype.readUintLE = M.prototype.readUIntLE = function(oe, le, ge) {
    oe = oe >>> 0, le = le >>> 0, ge || q(oe, le, this.length);
    for (var Ke = this[oe], Je = 1, Fe = 0; ++Fe < le && (Je *= 256); )
      Ke += this[oe + Fe] * Je;
    return Ke;
  }, M.prototype.readUintBE = M.prototype.readUIntBE = function(oe, le, ge) {
    oe = oe >>> 0, le = le >>> 0, ge || q(oe, le, this.length);
    for (var Ke = this[oe + --le], Je = 1; le > 0 && (Je *= 256); )
      Ke += this[oe + --le] * Je;
    return Ke;
  }, M.prototype.readUint8 = M.prototype.readUInt8 = function(oe, le) {
    return oe = oe >>> 0, le || q(oe, 1, this.length), this[oe];
  }, M.prototype.readUint16LE = M.prototype.readUInt16LE = function(oe, le) {
    return oe = oe >>> 0, le || q(oe, 2, this.length), this[oe] | this[oe + 1] << 8;
  }, M.prototype.readUint16BE = M.prototype.readUInt16BE = function(oe, le) {
    return oe = oe >>> 0, le || q(oe, 2, this.length), this[oe] << 8 | this[oe + 1];
  }, M.prototype.readUint32LE = M.prototype.readUInt32LE = function(oe, le) {
    return oe = oe >>> 0, le || q(oe, 4, this.length), (this[oe] | this[oe + 1] << 8 | this[oe + 2] << 16) + this[oe + 3] * 16777216;
  }, M.prototype.readUint32BE = M.prototype.readUInt32BE = function(oe, le) {
    return oe = oe >>> 0, le || q(oe, 4, this.length), this[oe] * 16777216 + (this[oe + 1] << 16 | this[oe + 2] << 8 | this[oe + 3]);
  }, M.prototype.readIntLE = function(oe, le, ge) {
    oe = oe >>> 0, le = le >>> 0, ge || q(oe, le, this.length);
    for (var Ke = this[oe], Je = 1, Fe = 0; ++Fe < le && (Je *= 256); )
      Ke += this[oe + Fe] * Je;
    return Je *= 128, Ke >= Je && (Ke -= Math.pow(2, 8 * le)), Ke;
  }, M.prototype.readIntBE = function(oe, le, ge) {
    oe = oe >>> 0, le = le >>> 0, ge || q(oe, le, this.length);
    for (var Ke = le, Je = 1, Fe = this[oe + --Ke]; Ke > 0 && (Je *= 256); )
      Fe += this[oe + --Ke] * Je;
    return Je *= 128, Fe >= Je && (Fe -= Math.pow(2, 8 * le)), Fe;
  }, M.prototype.readInt8 = function(oe, le) {
    return oe = oe >>> 0, le || q(oe, 1, this.length), this[oe] & 128 ? (255 - this[oe] + 1) * -1 : this[oe];
  }, M.prototype.readInt16LE = function(oe, le) {
    oe = oe >>> 0, le || q(oe, 2, this.length);
    var ge = this[oe] | this[oe + 1] << 8;
    return ge & 32768 ? ge | 4294901760 : ge;
  }, M.prototype.readInt16BE = function(oe, le) {
    oe = oe >>> 0, le || q(oe, 2, this.length);
    var ge = this[oe + 1] | this[oe] << 8;
    return ge & 32768 ? ge | 4294901760 : ge;
  }, M.prototype.readInt32LE = function(oe, le) {
    return oe = oe >>> 0, le || q(oe, 4, this.length), this[oe] | this[oe + 1] << 8 | this[oe + 2] << 16 | this[oe + 3] << 24;
  }, M.prototype.readInt32BE = function(oe, le) {
    return oe = oe >>> 0, le || q(oe, 4, this.length), this[oe] << 24 | this[oe + 1] << 16 | this[oe + 2] << 8 | this[oe + 3];
  }, M.prototype.readFloatLE = function(oe, le) {
    return oe = oe >>> 0, le || q(oe, 4, this.length), h.read(this, oe, !0, 23, 4);
  }, M.prototype.readFloatBE = function(oe, le) {
    return oe = oe >>> 0, le || q(oe, 4, this.length), h.read(this, oe, !1, 23, 4);
  }, M.prototype.readDoubleLE = function(oe, le) {
    return oe = oe >>> 0, le || q(oe, 8, this.length), h.read(this, oe, !0, 52, 8);
  }, M.prototype.readDoubleBE = function(oe, le) {
    return oe = oe >>> 0, le || q(oe, 8, this.length), h.read(this, oe, !1, 52, 8);
  };
  function z(re, oe, le, ge, Ke, Je) {
    if (!M.isBuffer(re))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (oe > Ke || oe < Je)
      throw new RangeError('"value" argument is out of bounds');
    if (le + ge > re.length)
      throw new RangeError("Index out of range");
  }
  M.prototype.writeUintLE = M.prototype.writeUIntLE = function(oe, le, ge, Ke) {
    if (oe = +oe, le = le >>> 0, ge = ge >>> 0, !Ke) {
      var Je = Math.pow(2, 8 * ge) - 1;
      z(this, oe, le, ge, Je, 0);
    }
    var Fe = 1, Ye = 0;
    for (this[le] = oe & 255; ++Ye < ge && (Fe *= 256); )
      this[le + Ye] = oe / Fe & 255;
    return le + ge;
  }, M.prototype.writeUintBE = M.prototype.writeUIntBE = function(oe, le, ge, Ke) {
    if (oe = +oe, le = le >>> 0, ge = ge >>> 0, !Ke) {
      var Je = Math.pow(2, 8 * ge) - 1;
      z(this, oe, le, ge, Je, 0);
    }
    var Fe = ge - 1, Ye = 1;
    for (this[le + Fe] = oe & 255; --Fe >= 0 && (Ye *= 256); )
      this[le + Fe] = oe / Ye & 255;
    return le + ge;
  }, M.prototype.writeUint8 = M.prototype.writeUInt8 = function(oe, le, ge) {
    return oe = +oe, le = le >>> 0, ge || z(this, oe, le, 1, 255, 0), this[le] = oe & 255, le + 1;
  }, M.prototype.writeUint16LE = M.prototype.writeUInt16LE = function(oe, le, ge) {
    return oe = +oe, le = le >>> 0, ge || z(this, oe, le, 2, 65535, 0), this[le] = oe & 255, this[le + 1] = oe >>> 8, le + 2;
  }, M.prototype.writeUint16BE = M.prototype.writeUInt16BE = function(oe, le, ge) {
    return oe = +oe, le = le >>> 0, ge || z(this, oe, le, 2, 65535, 0), this[le] = oe >>> 8, this[le + 1] = oe & 255, le + 2;
  }, M.prototype.writeUint32LE = M.prototype.writeUInt32LE = function(oe, le, ge) {
    return oe = +oe, le = le >>> 0, ge || z(this, oe, le, 4, 4294967295, 0), this[le + 3] = oe >>> 24, this[le + 2] = oe >>> 16, this[le + 1] = oe >>> 8, this[le] = oe & 255, le + 4;
  }, M.prototype.writeUint32BE = M.prototype.writeUInt32BE = function(oe, le, ge) {
    return oe = +oe, le = le >>> 0, ge || z(this, oe, le, 4, 4294967295, 0), this[le] = oe >>> 24, this[le + 1] = oe >>> 16, this[le + 2] = oe >>> 8, this[le + 3] = oe & 255, le + 4;
  }, M.prototype.writeIntLE = function(oe, le, ge, Ke) {
    if (oe = +oe, le = le >>> 0, !Ke) {
      var Je = Math.pow(2, 8 * ge - 1);
      z(this, oe, le, ge, Je - 1, -Je);
    }
    var Fe = 0, Ye = 1, it = 0;
    for (this[le] = oe & 255; ++Fe < ge && (Ye *= 256); )
      oe < 0 && it === 0 && this[le + Fe - 1] !== 0 && (it = 1), this[le + Fe] = (oe / Ye >> 0) - it & 255;
    return le + ge;
  }, M.prototype.writeIntBE = function(oe, le, ge, Ke) {
    if (oe = +oe, le = le >>> 0, !Ke) {
      var Je = Math.pow(2, 8 * ge - 1);
      z(this, oe, le, ge, Je - 1, -Je);
    }
    var Fe = ge - 1, Ye = 1, it = 0;
    for (this[le + Fe] = oe & 255; --Fe >= 0 && (Ye *= 256); )
      oe < 0 && it === 0 && this[le + Fe + 1] !== 0 && (it = 1), this[le + Fe] = (oe / Ye >> 0) - it & 255;
    return le + ge;
  }, M.prototype.writeInt8 = function(oe, le, ge) {
    return oe = +oe, le = le >>> 0, ge || z(this, oe, le, 1, 127, -128), oe < 0 && (oe = 255 + oe + 1), this[le] = oe & 255, le + 1;
  }, M.prototype.writeInt16LE = function(oe, le, ge) {
    return oe = +oe, le = le >>> 0, ge || z(this, oe, le, 2, 32767, -32768), this[le] = oe & 255, this[le + 1] = oe >>> 8, le + 2;
  }, M.prototype.writeInt16BE = function(oe, le, ge) {
    return oe = +oe, le = le >>> 0, ge || z(this, oe, le, 2, 32767, -32768), this[le] = oe >>> 8, this[le + 1] = oe & 255, le + 2;
  }, M.prototype.writeInt32LE = function(oe, le, ge) {
    return oe = +oe, le = le >>> 0, ge || z(this, oe, le, 4, 2147483647, -2147483648), this[le] = oe & 255, this[le + 1] = oe >>> 8, this[le + 2] = oe >>> 16, this[le + 3] = oe >>> 24, le + 4;
  }, M.prototype.writeInt32BE = function(oe, le, ge) {
    return oe = +oe, le = le >>> 0, ge || z(this, oe, le, 4, 2147483647, -2147483648), oe < 0 && (oe = 4294967295 + oe + 1), this[le] = oe >>> 24, this[le + 1] = oe >>> 16, this[le + 2] = oe >>> 8, this[le + 3] = oe & 255, le + 4;
  };
  function me(re, oe, le, ge, Ke, Je) {
    if (le + ge > re.length)
      throw new RangeError("Index out of range");
    if (le < 0)
      throw new RangeError("Index out of range");
  }
  function Ce(re, oe, le, ge, Ke) {
    return oe = +oe, le = le >>> 0, Ke || me(re, oe, le, 4), h.write(re, oe, le, ge, 23, 4), le + 4;
  }
  M.prototype.writeFloatLE = function(oe, le, ge) {
    return Ce(this, oe, le, !0, ge);
  }, M.prototype.writeFloatBE = function(oe, le, ge) {
    return Ce(this, oe, le, !1, ge);
  };
  function je(re, oe, le, ge, Ke) {
    return oe = +oe, le = le >>> 0, Ke || me(re, oe, le, 8), h.write(re, oe, le, ge, 52, 8), le + 8;
  }
  M.prototype.writeDoubleLE = function(oe, le, ge) {
    return je(this, oe, le, !0, ge);
  }, M.prototype.writeDoubleBE = function(oe, le, ge) {
    return je(this, oe, le, !1, ge);
  }, M.prototype.copy = function(oe, le, ge, Ke) {
    if (!M.isBuffer(oe))
      throw new TypeError("argument should be a Buffer");
    if (ge || (ge = 0), !Ke && Ke !== 0 && (Ke = this.length), le >= oe.length && (le = oe.length), le || (le = 0), Ke > 0 && Ke < ge && (Ke = ge), Ke === ge || oe.length === 0 || this.length === 0)
      return 0;
    if (le < 0)
      throw new RangeError("targetStart out of bounds");
    if (ge < 0 || ge >= this.length)
      throw new RangeError("Index out of range");
    if (Ke < 0)
      throw new RangeError("sourceEnd out of bounds");
    Ke > this.length && (Ke = this.length), oe.length - le < Ke - ge && (Ke = oe.length - le + ge);
    var Je = Ke - ge;
    return this === oe && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(le, ge, Ke) : Uint8Array.prototype.set.call(
      oe,
      this.subarray(ge, Ke),
      le
    ), Je;
  }, M.prototype.fill = function(oe, le, ge, Ke) {
    if (typeof oe == "string") {
      if (typeof le == "string" ? (Ke = le, le = 0, ge = this.length) : typeof ge == "string" && (Ke = ge, ge = this.length), Ke !== void 0 && typeof Ke != "string")
        throw new TypeError("encoding must be a string");
      if (typeof Ke == "string" && !M.isEncoding(Ke))
        throw new TypeError("Unknown encoding: " + Ke);
      if (oe.length === 1) {
        var Je = oe.charCodeAt(0);
        (Ke === "utf8" && Je < 128 || Ke === "latin1") && (oe = Je);
      }
    } else
      typeof oe == "number" ? oe = oe & 255 : typeof oe == "boolean" && (oe = Number(oe));
    if (le < 0 || this.length < le || this.length < ge)
      throw new RangeError("Out of range index");
    if (ge <= le)
      return this;
    le = le >>> 0, ge = ge === void 0 ? this.length : ge >>> 0, oe || (oe = 0);
    var Fe;
    if (typeof oe == "number")
      for (Fe = le; Fe < ge; ++Fe)
        this[Fe] = oe;
    else {
      var Ye = M.isBuffer(oe) ? oe : M.from(oe, Ke), it = Ye.length;
      if (it === 0)
        throw new TypeError('The value "' + oe + '" is invalid for argument "value"');
      for (Fe = 0; Fe < ge - le; ++Fe)
        this[Fe + le] = Ye[Fe % it];
    }
    return this;
  };
  var Re = /[^+/0-9A-Za-z-_]/g;
  function Ae(re) {
    if (re = re.split("=")[0], re = re.trim().replace(Re, ""), re.length < 2)
      return "";
    for (; re.length % 4 !== 0; )
      re = re + "=";
    return re;
  }
  function ke(re, oe) {
    oe = oe || 1 / 0;
    for (var le, ge = re.length, Ke = null, Je = [], Fe = 0; Fe < ge; ++Fe) {
      if (le = re.charCodeAt(Fe), le > 55295 && le < 57344) {
        if (!Ke) {
          if (le > 56319) {
            (oe -= 3) > -1 && Je.push(239, 191, 189);
            continue;
          } else if (Fe + 1 === ge) {
            (oe -= 3) > -1 && Je.push(239, 191, 189);
            continue;
          }
          Ke = le;
          continue;
        }
        if (le < 56320) {
          (oe -= 3) > -1 && Je.push(239, 191, 189), Ke = le;
          continue;
        }
        le = (Ke - 55296 << 10 | le - 56320) + 65536;
      } else
        Ke && (oe -= 3) > -1 && Je.push(239, 191, 189);
      if (Ke = null, le < 128) {
        if ((oe -= 1) < 0)
          break;
        Je.push(le);
      } else if (le < 2048) {
        if ((oe -= 2) < 0)
          break;
        Je.push(
          le >> 6 | 192,
          le & 63 | 128
        );
      } else if (le < 65536) {
        if ((oe -= 3) < 0)
          break;
        Je.push(
          le >> 12 | 224,
          le >> 6 & 63 | 128,
          le & 63 | 128
        );
      } else if (le < 1114112) {
        if ((oe -= 4) < 0)
          break;
        Je.push(
          le >> 18 | 240,
          le >> 12 & 63 | 128,
          le >> 6 & 63 | 128,
          le & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return Je;
  }
  function Qe(re) {
    for (var oe = [], le = 0; le < re.length; ++le)
      oe.push(re.charCodeAt(le) & 255);
    return oe;
  }
  function Ze(re, oe) {
    for (var le, ge, Ke, Je = [], Fe = 0; Fe < re.length && !((oe -= 2) < 0); ++Fe)
      le = re.charCodeAt(Fe), ge = le >> 8, Ke = le % 256, Je.push(Ke), Je.push(ge);
    return Je;
  }
  function qe(re) {
    return t.toByteArray(Ae(re));
  }
  function Oe(re, oe, le, ge) {
    for (var Ke = 0; Ke < ge && !(Ke + le >= oe.length || Ke >= re.length); ++Ke)
      oe[Ke + le] = re[Ke];
    return Ke;
  }
  function Xe(re, oe) {
    return re instanceof oe || re != null && re.constructor != null && re.constructor.name != null && re.constructor.name === oe.name;
  }
  function et(re) {
    return re !== re;
  }
  var nt = function() {
    for (var re = "0123456789abcdef", oe = new Array(256), le = 0; le < 16; ++le)
      for (var ge = le * 16, Ke = 0; Ke < 16; ++Ke)
        oe[ge + Ke] = re[le] + re[Ke];
    return oe;
  }();
})(buffer$2);
var process$2 = {}, cachedSetTimeout$1, cachedClearTimeout$1;
function defaultSetTimout$1() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout$1() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout$1 = setTimeout : cachedSetTimeout$1 = defaultSetTimout$1;
  } catch {
    cachedSetTimeout$1 = defaultSetTimout$1;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout$1 = clearTimeout : cachedClearTimeout$1 = defaultClearTimeout$1;
  } catch {
    cachedClearTimeout$1 = defaultClearTimeout$1;
  }
})();
function runTimeout$1(e) {
  if (cachedSetTimeout$1 === setTimeout)
    return setTimeout(e, 0);
  if ((cachedSetTimeout$1 === defaultSetTimout$1 || !cachedSetTimeout$1) && setTimeout)
    return cachedSetTimeout$1 = setTimeout, setTimeout(e, 0);
  try {
    return cachedSetTimeout$1(e, 0);
  } catch {
    try {
      return cachedSetTimeout$1.call(null, e, 0);
    } catch {
      return cachedSetTimeout$1.call(this, e, 0);
    }
  }
}
function runClearTimeout$1(e) {
  if (cachedClearTimeout$1 === clearTimeout)
    return clearTimeout(e);
  if ((cachedClearTimeout$1 === defaultClearTimeout$1 || !cachedClearTimeout$1) && clearTimeout)
    return cachedClearTimeout$1 = clearTimeout, clearTimeout(e);
  try {
    return cachedClearTimeout$1(e);
  } catch {
    try {
      return cachedClearTimeout$1.call(null, e);
    } catch {
      return cachedClearTimeout$1.call(this, e);
    }
  }
}
var queue$1 = [], draining$1 = !1, currentQueue$1, queueIndex$1 = -1;
function cleanUpNextTick$1() {
  !draining$1 || !currentQueue$1 || (draining$1 = !1, currentQueue$1.length ? queue$1 = currentQueue$1.concat(queue$1) : queueIndex$1 = -1, queue$1.length && drainQueue$1());
}
function drainQueue$1() {
  if (!draining$1) {
    var e = runTimeout$1(cleanUpNextTick$1);
    draining$1 = !0;
    for (var t = queue$1.length; t; ) {
      for (currentQueue$1 = queue$1, queue$1 = []; ++queueIndex$1 < t; )
        currentQueue$1 && currentQueue$1[queueIndex$1].run();
      queueIndex$1 = -1, t = queue$1.length;
    }
    currentQueue$1 = null, draining$1 = !1, runClearTimeout$1(e);
  }
}
process$2.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var h = 1; h < arguments.length; h++)
      t[h - 1] = arguments[h];
  queue$1.push(new Item$1(e, t)), queue$1.length === 1 && !draining$1 && runTimeout$1(drainQueue$1);
};
function Item$1(e, t) {
  this.fun = e, this.array = t;
}
Item$1.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process$2.title = "browser";
process$2.browser = !0;
process$2.env = {};
process$2.argv = [];
process$2.version = "";
process$2.versions = {};
function noop$1() {
}
process$2.on = noop$1;
process$2.addListener = noop$1;
process$2.once = noop$1;
process$2.off = noop$1;
process$2.removeListener = noop$1;
process$2.removeAllListeners = noop$1;
process$2.emit = noop$1;
process$2.prependListener = noop$1;
process$2.prependOnceListener = noop$1;
process$2.listeners = function(e) {
  return [];
};
process$2.binding = function(e) {
  throw new Error("process.binding is not supported");
};
process$2.cwd = function() {
  return "/";
};
process$2.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
process$2.umask = function() {
  return 0;
};
var _globalThis = function(e) {
  function t() {
    var o = this || self;
    return delete e.prototype.__magic__, o;
  }
  if (typeof globalThis == "object")
    return globalThis;
  if (this)
    return t();
  e.defineProperty(e.prototype, "__magic__", {
    configurable: !0,
    get: t
  });
  var h = __magic__;
  return h;
}(Object), _global = _globalThis;
const name$1 = "@wepin/fetch-js", version$1 = "0.0.1", description$1 = "Wepin fetch library for Web", author$1 = "IoTrust, Co., Ltd.", license$1 = "MIT", main$1 = "./dist/wepin-fetch-js.mjs", types$1 = "./dist/src/index.d.ts", files$1 = [
  "dist"
], scripts$1 = {
  build: "vite build --mode production",
  dev: "vite build --mode development",
  watch: "vite build --watch",
  lint: "eslint . --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts --fix --ignore-path .gitignore"
}, dependencies$1 = {
  "@wepin/storage-js": "link:../storage",
  bcryptjs: "^2.4.3",
  eventemitter2: "^6.4.9",
  "jwt-decode": "^4.0.0"
}, devDependencies$1 = {
  "@types/bcryptjs": "^2.4.6"
}, keywords$1 = [
  "wepin",
  "wepinwallet",
  "wallet",
  "wepin-fetch"
], packageJson = {
  name: name$1,
  version: version$1,
  description: description$1,
  author: author$1,
  license: license$1,
  main: main$1,
  types: types$1,
  files: files$1,
  scripts: scripts$1,
  dependencies: dependencies$1,
  devDependencies: devDependencies$1,
  keywords: keywords$1
};
class APIResponse {
  constructor({
    data: t,
    status: h,
    headers: o,
    request: S
  }) {
    this.data = t, this.status = h, this.headers = o, this.request = S;
  }
}
var commonjsGlobal = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof _global < "u" ? _global : typeof self < "u" ? self : {};
function getDefaultExportFromCjs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var buffer$1 = {}, base64Js = {}, hasRequiredBase64Js;
function requireBase64Js() {
  if (hasRequiredBase64Js)
    return base64Js;
  hasRequiredBase64Js = 1, base64Js.byteLength = M, base64Js.toByteArray = P, base64Js.fromByteArray = Y;
  for (var e = [], t = [], h = typeof Uint8Array < "u" ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", S = 0, g = o.length; S < g; ++S)
    e[S] = o[S], t[o.charCodeAt(S)] = S;
  t[45] = 62, t[95] = 63;
  function B(ee) {
    var ie = ee.length;
    if (ie % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    var ue = ee.indexOf("=");
    ue === -1 && (ue = ie);
    var fe = ue === ie ? 0 : 4 - ue % 4;
    return [ue, fe];
  }
  function M(ee) {
    var ie = B(ee), ue = ie[0], fe = ie[1];
    return (ue + fe) * 3 / 4 - fe;
  }
  function O(ee, ie, ue) {
    return (ie + ue) * 3 / 4 - ue;
  }
  function P(ee) {
    var ie, ue = B(ee), fe = ue[0], de = ue[1], ce = new h(O(ee, fe, de)), be = 0, ve = de > 0 ? fe - 4 : fe, Pe;
    for (Pe = 0; Pe < ve; Pe += 4)
      ie = t[ee.charCodeAt(Pe)] << 18 | t[ee.charCodeAt(Pe + 1)] << 12 | t[ee.charCodeAt(Pe + 2)] << 6 | t[ee.charCodeAt(Pe + 3)], ce[be++] = ie >> 16 & 255, ce[be++] = ie >> 8 & 255, ce[be++] = ie & 255;
    return de === 2 && (ie = t[ee.charCodeAt(Pe)] << 2 | t[ee.charCodeAt(Pe + 1)] >> 4, ce[be++] = ie & 255), de === 1 && (ie = t[ee.charCodeAt(Pe)] << 10 | t[ee.charCodeAt(Pe + 1)] << 4 | t[ee.charCodeAt(Pe + 2)] >> 2, ce[be++] = ie >> 8 & 255, ce[be++] = ie & 255), ce;
  }
  function D(ee) {
    return e[ee >> 18 & 63] + e[ee >> 12 & 63] + e[ee >> 6 & 63] + e[ee & 63];
  }
  function Z(ee, ie, ue) {
    for (var fe, de = [], ce = ie; ce < ue; ce += 3)
      fe = (ee[ce] << 16 & 16711680) + (ee[ce + 1] << 8 & 65280) + (ee[ce + 2] & 255), de.push(D(fe));
    return de.join("");
  }
  function Y(ee) {
    for (var ie, ue = ee.length, fe = ue % 3, de = [], ce = 16383, be = 0, ve = ue - fe; be < ve; be += ce)
      de.push(Z(ee, be, be + ce > ve ? ve : be + ce));
    return fe === 1 ? (ie = ee[ue - 1], de.push(
      e[ie >> 2] + e[ie << 4 & 63] + "=="
    )) : fe === 2 && (ie = (ee[ue - 2] << 8) + ee[ue - 1], de.push(
      e[ie >> 10] + e[ie >> 4 & 63] + e[ie << 2 & 63] + "="
    )), de.join("");
  }
  return base64Js;
}
var ieee754 = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredIeee754;
function requireIeee754() {
  return hasRequiredIeee754 || (hasRequiredIeee754 = 1, ieee754.read = function(e, t, h, o, S) {
    var g, B, M = S * 8 - o - 1, O = (1 << M) - 1, P = O >> 1, D = -7, Z = h ? S - 1 : 0, Y = h ? -1 : 1, ee = e[t + Z];
    for (Z += Y, g = ee & (1 << -D) - 1, ee >>= -D, D += M; D > 0; g = g * 256 + e[t + Z], Z += Y, D -= 8)
      ;
    for (B = g & (1 << -D) - 1, g >>= -D, D += o; D > 0; B = B * 256 + e[t + Z], Z += Y, D -= 8)
      ;
    if (g === 0)
      g = 1 - P;
    else {
      if (g === O)
        return B ? NaN : (ee ? -1 : 1) * (1 / 0);
      B = B + Math.pow(2, o), g = g - P;
    }
    return (ee ? -1 : 1) * B * Math.pow(2, g - o);
  }, ieee754.write = function(e, t, h, o, S, g) {
    var B, M, O, P = g * 8 - S - 1, D = (1 << P) - 1, Z = D >> 1, Y = S === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ee = o ? 0 : g - 1, ie = o ? 1 : -1, ue = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
    for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (M = isNaN(t) ? 1 : 0, B = D) : (B = Math.floor(Math.log(t) / Math.LN2), t * (O = Math.pow(2, -B)) < 1 && (B--, O *= 2), B + Z >= 1 ? t += Y / O : t += Y * Math.pow(2, 1 - Z), t * O >= 2 && (B++, O /= 2), B + Z >= D ? (M = 0, B = D) : B + Z >= 1 ? (M = (t * O - 1) * Math.pow(2, S), B = B + Z) : (M = t * Math.pow(2, Z - 1) * Math.pow(2, S), B = 0)); S >= 8; e[h + ee] = M & 255, ee += ie, M /= 256, S -= 8)
      ;
    for (B = B << S | M, P += S; P > 0; e[h + ee] = B & 255, ee += ie, B /= 256, P -= 8)
      ;
    e[h + ee - ie] |= ue * 128;
  }), ieee754;
}
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
var hasRequiredBuffer$1;
function requireBuffer$1() {
  return hasRequiredBuffer$1 || (hasRequiredBuffer$1 = 1, function(e) {
    var t = requireBase64Js(), h = requireIeee754(), o = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
    e.Buffer = M, e.SlowBuffer = ce, e.INSPECT_MAX_BYTES = 50;
    var S = 2147483647;
    e.kMaxLength = S, M.TYPED_ARRAY_SUPPORT = g(), !M.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
      "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
    );
    function g() {
      try {
        var re = new Uint8Array(1), oe = { foo: function() {
          return 42;
        } };
        return Object.setPrototypeOf(oe, Uint8Array.prototype), Object.setPrototypeOf(re, oe), re.foo() === 42;
      } catch {
        return !1;
      }
    }
    Object.defineProperty(M.prototype, "parent", {
      enumerable: !0,
      get: function() {
        if (M.isBuffer(this))
          return this.buffer;
      }
    }), Object.defineProperty(M.prototype, "offset", {
      enumerable: !0,
      get: function() {
        if (M.isBuffer(this))
          return this.byteOffset;
      }
    });
    function B(re) {
      if (re > S)
        throw new RangeError('The value "' + re + '" is invalid for option "size"');
      var oe = new Uint8Array(re);
      return Object.setPrototypeOf(oe, M.prototype), oe;
    }
    function M(re, oe, le) {
      if (typeof re == "number") {
        if (typeof oe == "string")
          throw new TypeError(
            'The "string" argument must be of type string. Received type number'
          );
        return Z(re);
      }
      return O(re, oe, le);
    }
    M.poolSize = 8192;
    function O(re, oe, le) {
      if (typeof re == "string")
        return Y(re, oe);
      if (ArrayBuffer.isView(re))
        return ie(re);
      if (re == null)
        throw new TypeError(
          "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof re
        );
      if (Xe(re, ArrayBuffer) || re && Xe(re.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Xe(re, SharedArrayBuffer) || re && Xe(re.buffer, SharedArrayBuffer)))
        return ue(re, oe, le);
      if (typeof re == "number")
        throw new TypeError(
          'The "value" argument must not be of type number. Received type number'
        );
      var ge = re.valueOf && re.valueOf();
      if (ge != null && ge !== re)
        return M.from(ge, oe, le);
      var Ke = fe(re);
      if (Ke)
        return Ke;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof re[Symbol.toPrimitive] == "function")
        return M.from(
          re[Symbol.toPrimitive]("string"),
          oe,
          le
        );
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof re
      );
    }
    M.from = function(re, oe, le) {
      return O(re, oe, le);
    }, Object.setPrototypeOf(M.prototype, Uint8Array.prototype), Object.setPrototypeOf(M, Uint8Array);
    function P(re) {
      if (typeof re != "number")
        throw new TypeError('"size" argument must be of type number');
      if (re < 0)
        throw new RangeError('The value "' + re + '" is invalid for option "size"');
    }
    function D(re, oe, le) {
      return P(re), re <= 0 ? B(re) : oe !== void 0 ? typeof le == "string" ? B(re).fill(oe, le) : B(re).fill(oe) : B(re);
    }
    M.alloc = function(re, oe, le) {
      return D(re, oe, le);
    };
    function Z(re) {
      return P(re), B(re < 0 ? 0 : de(re) | 0);
    }
    M.allocUnsafe = function(re) {
      return Z(re);
    }, M.allocUnsafeSlow = function(re) {
      return Z(re);
    };
    function Y(re, oe) {
      if ((typeof oe != "string" || oe === "") && (oe = "utf8"), !M.isEncoding(oe))
        throw new TypeError("Unknown encoding: " + oe);
      var le = be(re, oe) | 0, ge = B(le), Ke = ge.write(re, oe);
      return Ke !== le && (ge = ge.slice(0, Ke)), ge;
    }
    function ee(re) {
      for (var oe = re.length < 0 ? 0 : de(re.length) | 0, le = B(oe), ge = 0; ge < oe; ge += 1)
        le[ge] = re[ge] & 255;
      return le;
    }
    function ie(re) {
      if (Xe(re, Uint8Array)) {
        var oe = new Uint8Array(re);
        return ue(oe.buffer, oe.byteOffset, oe.byteLength);
      }
      return ee(re);
    }
    function ue(re, oe, le) {
      if (oe < 0 || re.byteLength < oe)
        throw new RangeError('"offset" is outside of buffer bounds');
      if (re.byteLength < oe + (le || 0))
        throw new RangeError('"length" is outside of buffer bounds');
      var ge;
      return oe === void 0 && le === void 0 ? ge = new Uint8Array(re) : le === void 0 ? ge = new Uint8Array(re, oe) : ge = new Uint8Array(re, oe, le), Object.setPrototypeOf(ge, M.prototype), ge;
    }
    function fe(re) {
      if (M.isBuffer(re)) {
        var oe = de(re.length) | 0, le = B(oe);
        return le.length === 0 || re.copy(le, 0, 0, oe), le;
      }
      if (re.length !== void 0)
        return typeof re.length != "number" || et(re.length) ? B(0) : ee(re);
      if (re.type === "Buffer" && Array.isArray(re.data))
        return ee(re.data);
    }
    function de(re) {
      if (re >= S)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + S.toString(16) + " bytes");
      return re | 0;
    }
    function ce(re) {
      return +re != re && (re = 0), M.alloc(+re);
    }
    M.isBuffer = function(re) {
      return re != null && re._isBuffer === !0 && re !== M.prototype;
    }, M.compare = function(re, oe) {
      if (Xe(re, Uint8Array) && (re = M.from(re, re.offset, re.byteLength)), Xe(oe, Uint8Array) && (oe = M.from(oe, oe.offset, oe.byteLength)), !M.isBuffer(re) || !M.isBuffer(oe))
        throw new TypeError(
          'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
        );
      if (re === oe)
        return 0;
      for (var le = re.length, ge = oe.length, Ke = 0, Je = Math.min(le, ge); Ke < Je; ++Ke)
        if (re[Ke] !== oe[Ke]) {
          le = re[Ke], ge = oe[Ke];
          break;
        }
      return le < ge ? -1 : ge < le ? 1 : 0;
    }, M.isEncoding = function(re) {
      switch (String(re).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, M.concat = function(re, oe) {
      if (!Array.isArray(re))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (re.length === 0)
        return M.alloc(0);
      var le;
      if (oe === void 0)
        for (oe = 0, le = 0; le < re.length; ++le)
          oe += re[le].length;
      var ge = M.allocUnsafe(oe), Ke = 0;
      for (le = 0; le < re.length; ++le) {
        var Je = re[le];
        if (Xe(Je, Uint8Array))
          Ke + Je.length > ge.length ? M.from(Je).copy(ge, Ke) : Uint8Array.prototype.set.call(
            ge,
            Je,
            Ke
          );
        else if (M.isBuffer(Je))
          Je.copy(ge, Ke);
        else
          throw new TypeError('"list" argument must be an Array of Buffers');
        Ke += Je.length;
      }
      return ge;
    };
    function be(re, oe) {
      if (M.isBuffer(re))
        return re.length;
      if (ArrayBuffer.isView(re) || Xe(re, ArrayBuffer))
        return re.byteLength;
      if (typeof re != "string")
        throw new TypeError(
          'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof re
        );
      var le = re.length, ge = arguments.length > 2 && arguments[2] === !0;
      if (!ge && le === 0)
        return 0;
      for (var Ke = !1; ; )
        switch (oe) {
          case "ascii":
          case "latin1":
          case "binary":
            return le;
          case "utf8":
          case "utf-8":
            return ke(re).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return le * 2;
          case "hex":
            return le >>> 1;
          case "base64":
            return qe(re).length;
          default:
            if (Ke)
              return ge ? -1 : ke(re).length;
            oe = ("" + oe).toLowerCase(), Ke = !0;
        }
    }
    M.byteLength = be;
    function ve(re, oe, le) {
      var ge = !1;
      if ((oe === void 0 || oe < 0) && (oe = 0), oe > this.length || ((le === void 0 || le > this.length) && (le = this.length), le <= 0) || (le >>>= 0, oe >>>= 0, le <= oe))
        return "";
      for (re || (re = "utf8"); ; )
        switch (re) {
          case "hex":
            return $(this, oe, le);
          case "utf8":
          case "utf-8":
            return I(this, oe, le);
          case "ascii":
            return Q(this, oe, le);
          case "latin1":
          case "binary":
            return F(this, oe, le);
          case "base64":
            return A(this, oe, le);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return H(this, oe, le);
          default:
            if (ge)
              throw new TypeError("Unknown encoding: " + re);
            re = (re + "").toLowerCase(), ge = !0;
        }
    }
    M.prototype._isBuffer = !0;
    function Pe(re, oe, le) {
      var ge = re[oe];
      re[oe] = re[le], re[le] = ge;
    }
    M.prototype.swap16 = function() {
      var re = this.length;
      if (re % 2 !== 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var oe = 0; oe < re; oe += 2)
        Pe(this, oe, oe + 1);
      return this;
    }, M.prototype.swap32 = function() {
      var re = this.length;
      if (re % 4 !== 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var oe = 0; oe < re; oe += 4)
        Pe(this, oe, oe + 3), Pe(this, oe + 1, oe + 2);
      return this;
    }, M.prototype.swap64 = function() {
      var re = this.length;
      if (re % 8 !== 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var oe = 0; oe < re; oe += 8)
        Pe(this, oe, oe + 7), Pe(this, oe + 1, oe + 6), Pe(this, oe + 2, oe + 5), Pe(this, oe + 3, oe + 4);
      return this;
    }, M.prototype.toString = function() {
      var re = this.length;
      return re === 0 ? "" : arguments.length === 0 ? I(this, 0, re) : ve.apply(this, arguments);
    }, M.prototype.toLocaleString = M.prototype.toString, M.prototype.equals = function(re) {
      if (!M.isBuffer(re))
        throw new TypeError("Argument must be a Buffer");
      return this === re ? !0 : M.compare(this, re) === 0;
    }, M.prototype.inspect = function() {
      var re = "", oe = e.INSPECT_MAX_BYTES;
      return re = this.toString("hex", 0, oe).replace(/(.{2})/g, "$1 ").trim(), this.length > oe && (re += " ... "), "<Buffer " + re + ">";
    }, o && (M.prototype[o] = M.prototype.inspect), M.prototype.compare = function(re, oe, le, ge, Ke) {
      if (Xe(re, Uint8Array) && (re = M.from(re, re.offset, re.byteLength)), !M.isBuffer(re))
        throw new TypeError(
          'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof re
        );
      if (oe === void 0 && (oe = 0), le === void 0 && (le = re ? re.length : 0), ge === void 0 && (ge = 0), Ke === void 0 && (Ke = this.length), oe < 0 || le > re.length || ge < 0 || Ke > this.length)
        throw new RangeError("out of range index");
      if (ge >= Ke && oe >= le)
        return 0;
      if (ge >= Ke)
        return -1;
      if (oe >= le)
        return 1;
      if (oe >>>= 0, le >>>= 0, ge >>>= 0, Ke >>>= 0, this === re)
        return 0;
      for (var Je = Ke - ge, Fe = le - oe, Ye = Math.min(Je, Fe), it = this.slice(ge, Ke), rt = re.slice(oe, le), tt = 0; tt < Ye; ++tt)
        if (it[tt] !== rt[tt]) {
          Je = it[tt], Fe = rt[tt];
          break;
        }
      return Je < Fe ? -1 : Fe < Je ? 1 : 0;
    };
    function Ue(re, oe, le, ge, Ke) {
      if (re.length === 0)
        return -1;
      if (typeof le == "string" ? (ge = le, le = 0) : le > 2147483647 ? le = 2147483647 : le < -2147483648 && (le = -2147483648), le = +le, et(le) && (le = Ke ? 0 : re.length - 1), le < 0 && (le = re.length + le), le >= re.length) {
        if (Ke)
          return -1;
        le = re.length - 1;
      } else if (le < 0)
        if (Ke)
          le = 0;
        else
          return -1;
      if (typeof oe == "string" && (oe = M.from(oe, ge)), M.isBuffer(oe))
        return oe.length === 0 ? -1 : ze(re, oe, le, ge, Ke);
      if (typeof oe == "number")
        return oe = oe & 255, typeof Uint8Array.prototype.indexOf == "function" ? Ke ? Uint8Array.prototype.indexOf.call(re, oe, le) : Uint8Array.prototype.lastIndexOf.call(re, oe, le) : ze(re, [oe], le, ge, Ke);
      throw new TypeError("val must be string, number or Buffer");
    }
    function ze(re, oe, le, ge, Ke) {
      var Je = 1, Fe = re.length, Ye = oe.length;
      if (ge !== void 0 && (ge = String(ge).toLowerCase(), ge === "ucs2" || ge === "ucs-2" || ge === "utf16le" || ge === "utf-16le")) {
        if (re.length < 2 || oe.length < 2)
          return -1;
        Je = 2, Fe /= 2, Ye /= 2, le /= 2;
      }
      function it(ot, si) {
        return Je === 1 ? ot[si] : ot.readUInt16BE(si * Je);
      }
      var rt;
      if (Ke) {
        var tt = -1;
        for (rt = le; rt < Fe; rt++)
          if (it(re, rt) === it(oe, tt === -1 ? 0 : rt - tt)) {
            if (tt === -1 && (tt = rt), rt - tt + 1 === Ye)
              return tt * Je;
          } else
            tt !== -1 && (rt -= rt - tt), tt = -1;
      } else
        for (le + Ye > Fe && (le = Fe - Ye), rt = le; rt >= 0; rt--) {
          for (var vt = !0, St = 0; St < Ye; St++)
            if (it(re, rt + St) !== it(oe, St)) {
              vt = !1;
              break;
            }
          if (vt)
            return rt;
        }
      return -1;
    }
    M.prototype.includes = function(re, oe, le) {
      return this.indexOf(re, oe, le) !== -1;
    }, M.prototype.indexOf = function(re, oe, le) {
      return Ue(this, re, oe, le, !0);
    }, M.prototype.lastIndexOf = function(re, oe, le) {
      return Ue(this, re, oe, le, !1);
    };
    function Le(re, oe, le, ge) {
      le = Number(le) || 0;
      var Ke = re.length - le;
      ge ? (ge = Number(ge), ge > Ke && (ge = Ke)) : ge = Ke;
      var Je = oe.length;
      ge > Je / 2 && (ge = Je / 2);
      for (var Fe = 0; Fe < ge; ++Fe) {
        var Ye = parseInt(oe.substr(Fe * 2, 2), 16);
        if (et(Ye))
          return Fe;
        re[le + Fe] = Ye;
      }
      return Fe;
    }
    function Ne(re, oe, le, ge) {
      return Oe(ke(oe, re.length - le), re, le, ge);
    }
    function $e(re, oe, le, ge) {
      return Oe(Qe(oe), re, le, ge);
    }
    function J(re, oe, le, ge) {
      return Oe(qe(oe), re, le, ge);
    }
    function ne(re, oe, le, ge) {
      return Oe(Ze(oe, re.length - le), re, le, ge);
    }
    M.prototype.write = function(re, oe, le, ge) {
      if (oe === void 0)
        ge = "utf8", le = this.length, oe = 0;
      else if (le === void 0 && typeof oe == "string")
        ge = oe, le = this.length, oe = 0;
      else if (isFinite(oe))
        oe = oe >>> 0, isFinite(le) ? (le = le >>> 0, ge === void 0 && (ge = "utf8")) : (ge = le, le = void 0);
      else
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      var Ke = this.length - oe;
      if ((le === void 0 || le > Ke) && (le = Ke), re.length > 0 && (le < 0 || oe < 0) || oe > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      ge || (ge = "utf8");
      for (var Je = !1; ; )
        switch (ge) {
          case "hex":
            return Le(this, re, oe, le);
          case "utf8":
          case "utf-8":
            return Ne(this, re, oe, le);
          case "ascii":
          case "latin1":
          case "binary":
            return $e(this, re, oe, le);
          case "base64":
            return J(this, re, oe, le);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return ne(this, re, oe, le);
          default:
            if (Je)
              throw new TypeError("Unknown encoding: " + ge);
            ge = ("" + ge).toLowerCase(), Je = !0;
        }
    }, M.prototype.toJSON = function() {
      return {
        type: "Buffer",
        data: Array.prototype.slice.call(this._arr || this, 0)
      };
    };
    function A(re, oe, le) {
      return oe === 0 && le === re.length ? t.fromByteArray(re) : t.fromByteArray(re.slice(oe, le));
    }
    function I(re, oe, le) {
      le = Math.min(re.length, le);
      for (var ge = [], Ke = oe; Ke < le; ) {
        var Je = re[Ke], Fe = null, Ye = Je > 239 ? 4 : Je > 223 ? 3 : Je > 191 ? 2 : 1;
        if (Ke + Ye <= le) {
          var it, rt, tt, vt;
          switch (Ye) {
            case 1:
              Je < 128 && (Fe = Je);
              break;
            case 2:
              it = re[Ke + 1], (it & 192) === 128 && (vt = (Je & 31) << 6 | it & 63, vt > 127 && (Fe = vt));
              break;
            case 3:
              it = re[Ke + 1], rt = re[Ke + 2], (it & 192) === 128 && (rt & 192) === 128 && (vt = (Je & 15) << 12 | (it & 63) << 6 | rt & 63, vt > 2047 && (vt < 55296 || vt > 57343) && (Fe = vt));
              break;
            case 4:
              it = re[Ke + 1], rt = re[Ke + 2], tt = re[Ke + 3], (it & 192) === 128 && (rt & 192) === 128 && (tt & 192) === 128 && (vt = (Je & 15) << 18 | (it & 63) << 12 | (rt & 63) << 6 | tt & 63, vt > 65535 && vt < 1114112 && (Fe = vt));
          }
        }
        Fe === null ? (Fe = 65533, Ye = 1) : Fe > 65535 && (Fe -= 65536, ge.push(Fe >>> 10 & 1023 | 55296), Fe = 56320 | Fe & 1023), ge.push(Fe), Ke += Ye;
      }
      return X(ge);
    }
    var U = 4096;
    function X(re) {
      var oe = re.length;
      if (oe <= U)
        return String.fromCharCode.apply(String, re);
      for (var le = "", ge = 0; ge < oe; )
        le += String.fromCharCode.apply(
          String,
          re.slice(ge, ge += U)
        );
      return le;
    }
    function Q(re, oe, le) {
      var ge = "";
      le = Math.min(re.length, le);
      for (var Ke = oe; Ke < le; ++Ke)
        ge += String.fromCharCode(re[Ke] & 127);
      return ge;
    }
    function F(re, oe, le) {
      var ge = "";
      le = Math.min(re.length, le);
      for (var Ke = oe; Ke < le; ++Ke)
        ge += String.fromCharCode(re[Ke]);
      return ge;
    }
    function $(re, oe, le) {
      var ge = re.length;
      (!oe || oe < 0) && (oe = 0), (!le || le < 0 || le > ge) && (le = ge);
      for (var Ke = "", Je = oe; Je < le; ++Je)
        Ke += nt[re[Je]];
      return Ke;
    }
    function H(re, oe, le) {
      for (var ge = re.slice(oe, le), Ke = "", Je = 0; Je < ge.length - 1; Je += 2)
        Ke += String.fromCharCode(ge[Je] + ge[Je + 1] * 256);
      return Ke;
    }
    M.prototype.slice = function(re, oe) {
      var le = this.length;
      re = ~~re, oe = oe === void 0 ? le : ~~oe, re < 0 ? (re += le, re < 0 && (re = 0)) : re > le && (re = le), oe < 0 ? (oe += le, oe < 0 && (oe = 0)) : oe > le && (oe = le), oe < re && (oe = re);
      var ge = this.subarray(re, oe);
      return Object.setPrototypeOf(ge, M.prototype), ge;
    };
    function q(re, oe, le) {
      if (re % 1 !== 0 || re < 0)
        throw new RangeError("offset is not uint");
      if (re + oe > le)
        throw new RangeError("Trying to access beyond buffer length");
    }
    M.prototype.readUintLE = M.prototype.readUIntLE = function(re, oe, le) {
      re = re >>> 0, oe = oe >>> 0, le || q(re, oe, this.length);
      for (var ge = this[re], Ke = 1, Je = 0; ++Je < oe && (Ke *= 256); )
        ge += this[re + Je] * Ke;
      return ge;
    }, M.prototype.readUintBE = M.prototype.readUIntBE = function(re, oe, le) {
      re = re >>> 0, oe = oe >>> 0, le || q(re, oe, this.length);
      for (var ge = this[re + --oe], Ke = 1; oe > 0 && (Ke *= 256); )
        ge += this[re + --oe] * Ke;
      return ge;
    }, M.prototype.readUint8 = M.prototype.readUInt8 = function(re, oe) {
      return re = re >>> 0, oe || q(re, 1, this.length), this[re];
    }, M.prototype.readUint16LE = M.prototype.readUInt16LE = function(re, oe) {
      return re = re >>> 0, oe || q(re, 2, this.length), this[re] | this[re + 1] << 8;
    }, M.prototype.readUint16BE = M.prototype.readUInt16BE = function(re, oe) {
      return re = re >>> 0, oe || q(re, 2, this.length), this[re] << 8 | this[re + 1];
    }, M.prototype.readUint32LE = M.prototype.readUInt32LE = function(re, oe) {
      return re = re >>> 0, oe || q(re, 4, this.length), (this[re] | this[re + 1] << 8 | this[re + 2] << 16) + this[re + 3] * 16777216;
    }, M.prototype.readUint32BE = M.prototype.readUInt32BE = function(re, oe) {
      return re = re >>> 0, oe || q(re, 4, this.length), this[re] * 16777216 + (this[re + 1] << 16 | this[re + 2] << 8 | this[re + 3]);
    }, M.prototype.readIntLE = function(re, oe, le) {
      re = re >>> 0, oe = oe >>> 0, le || q(re, oe, this.length);
      for (var ge = this[re], Ke = 1, Je = 0; ++Je < oe && (Ke *= 256); )
        ge += this[re + Je] * Ke;
      return Ke *= 128, ge >= Ke && (ge -= Math.pow(2, 8 * oe)), ge;
    }, M.prototype.readIntBE = function(re, oe, le) {
      re = re >>> 0, oe = oe >>> 0, le || q(re, oe, this.length);
      for (var ge = oe, Ke = 1, Je = this[re + --ge]; ge > 0 && (Ke *= 256); )
        Je += this[re + --ge] * Ke;
      return Ke *= 128, Je >= Ke && (Je -= Math.pow(2, 8 * oe)), Je;
    }, M.prototype.readInt8 = function(re, oe) {
      return re = re >>> 0, oe || q(re, 1, this.length), this[re] & 128 ? (255 - this[re] + 1) * -1 : this[re];
    }, M.prototype.readInt16LE = function(re, oe) {
      re = re >>> 0, oe || q(re, 2, this.length);
      var le = this[re] | this[re + 1] << 8;
      return le & 32768 ? le | 4294901760 : le;
    }, M.prototype.readInt16BE = function(re, oe) {
      re = re >>> 0, oe || q(re, 2, this.length);
      var le = this[re + 1] | this[re] << 8;
      return le & 32768 ? le | 4294901760 : le;
    }, M.prototype.readInt32LE = function(re, oe) {
      return re = re >>> 0, oe || q(re, 4, this.length), this[re] | this[re + 1] << 8 | this[re + 2] << 16 | this[re + 3] << 24;
    }, M.prototype.readInt32BE = function(re, oe) {
      return re = re >>> 0, oe || q(re, 4, this.length), this[re] << 24 | this[re + 1] << 16 | this[re + 2] << 8 | this[re + 3];
    }, M.prototype.readFloatLE = function(re, oe) {
      return re = re >>> 0, oe || q(re, 4, this.length), h.read(this, re, !0, 23, 4);
    }, M.prototype.readFloatBE = function(re, oe) {
      return re = re >>> 0, oe || q(re, 4, this.length), h.read(this, re, !1, 23, 4);
    }, M.prototype.readDoubleLE = function(re, oe) {
      return re = re >>> 0, oe || q(re, 8, this.length), h.read(this, re, !0, 52, 8);
    }, M.prototype.readDoubleBE = function(re, oe) {
      return re = re >>> 0, oe || q(re, 8, this.length), h.read(this, re, !1, 52, 8);
    };
    function z(re, oe, le, ge, Ke, Je) {
      if (!M.isBuffer(re))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (oe > Ke || oe < Je)
        throw new RangeError('"value" argument is out of bounds');
      if (le + ge > re.length)
        throw new RangeError("Index out of range");
    }
    M.prototype.writeUintLE = M.prototype.writeUIntLE = function(re, oe, le, ge) {
      if (re = +re, oe = oe >>> 0, le = le >>> 0, !ge) {
        var Ke = Math.pow(2, 8 * le) - 1;
        z(this, re, oe, le, Ke, 0);
      }
      var Je = 1, Fe = 0;
      for (this[oe] = re & 255; ++Fe < le && (Je *= 256); )
        this[oe + Fe] = re / Je & 255;
      return oe + le;
    }, M.prototype.writeUintBE = M.prototype.writeUIntBE = function(re, oe, le, ge) {
      if (re = +re, oe = oe >>> 0, le = le >>> 0, !ge) {
        var Ke = Math.pow(2, 8 * le) - 1;
        z(this, re, oe, le, Ke, 0);
      }
      var Je = le - 1, Fe = 1;
      for (this[oe + Je] = re & 255; --Je >= 0 && (Fe *= 256); )
        this[oe + Je] = re / Fe & 255;
      return oe + le;
    }, M.prototype.writeUint8 = M.prototype.writeUInt8 = function(re, oe, le) {
      return re = +re, oe = oe >>> 0, le || z(this, re, oe, 1, 255, 0), this[oe] = re & 255, oe + 1;
    }, M.prototype.writeUint16LE = M.prototype.writeUInt16LE = function(re, oe, le) {
      return re = +re, oe = oe >>> 0, le || z(this, re, oe, 2, 65535, 0), this[oe] = re & 255, this[oe + 1] = re >>> 8, oe + 2;
    }, M.prototype.writeUint16BE = M.prototype.writeUInt16BE = function(re, oe, le) {
      return re = +re, oe = oe >>> 0, le || z(this, re, oe, 2, 65535, 0), this[oe] = re >>> 8, this[oe + 1] = re & 255, oe + 2;
    }, M.prototype.writeUint32LE = M.prototype.writeUInt32LE = function(re, oe, le) {
      return re = +re, oe = oe >>> 0, le || z(this, re, oe, 4, 4294967295, 0), this[oe + 3] = re >>> 24, this[oe + 2] = re >>> 16, this[oe + 1] = re >>> 8, this[oe] = re & 255, oe + 4;
    }, M.prototype.writeUint32BE = M.prototype.writeUInt32BE = function(re, oe, le) {
      return re = +re, oe = oe >>> 0, le || z(this, re, oe, 4, 4294967295, 0), this[oe] = re >>> 24, this[oe + 1] = re >>> 16, this[oe + 2] = re >>> 8, this[oe + 3] = re & 255, oe + 4;
    }, M.prototype.writeIntLE = function(re, oe, le, ge) {
      if (re = +re, oe = oe >>> 0, !ge) {
        var Ke = Math.pow(2, 8 * le - 1);
        z(this, re, oe, le, Ke - 1, -Ke);
      }
      var Je = 0, Fe = 1, Ye = 0;
      for (this[oe] = re & 255; ++Je < le && (Fe *= 256); )
        re < 0 && Ye === 0 && this[oe + Je - 1] !== 0 && (Ye = 1), this[oe + Je] = (re / Fe >> 0) - Ye & 255;
      return oe + le;
    }, M.prototype.writeIntBE = function(re, oe, le, ge) {
      if (re = +re, oe = oe >>> 0, !ge) {
        var Ke = Math.pow(2, 8 * le - 1);
        z(this, re, oe, le, Ke - 1, -Ke);
      }
      var Je = le - 1, Fe = 1, Ye = 0;
      for (this[oe + Je] = re & 255; --Je >= 0 && (Fe *= 256); )
        re < 0 && Ye === 0 && this[oe + Je + 1] !== 0 && (Ye = 1), this[oe + Je] = (re / Fe >> 0) - Ye & 255;
      return oe + le;
    }, M.prototype.writeInt8 = function(re, oe, le) {
      return re = +re, oe = oe >>> 0, le || z(this, re, oe, 1, 127, -128), re < 0 && (re = 255 + re + 1), this[oe] = re & 255, oe + 1;
    }, M.prototype.writeInt16LE = function(re, oe, le) {
      return re = +re, oe = oe >>> 0, le || z(this, re, oe, 2, 32767, -32768), this[oe] = re & 255, this[oe + 1] = re >>> 8, oe + 2;
    }, M.prototype.writeInt16BE = function(re, oe, le) {
      return re = +re, oe = oe >>> 0, le || z(this, re, oe, 2, 32767, -32768), this[oe] = re >>> 8, this[oe + 1] = re & 255, oe + 2;
    }, M.prototype.writeInt32LE = function(re, oe, le) {
      return re = +re, oe = oe >>> 0, le || z(this, re, oe, 4, 2147483647, -2147483648), this[oe] = re & 255, this[oe + 1] = re >>> 8, this[oe + 2] = re >>> 16, this[oe + 3] = re >>> 24, oe + 4;
    }, M.prototype.writeInt32BE = function(re, oe, le) {
      return re = +re, oe = oe >>> 0, le || z(this, re, oe, 4, 2147483647, -2147483648), re < 0 && (re = 4294967295 + re + 1), this[oe] = re >>> 24, this[oe + 1] = re >>> 16, this[oe + 2] = re >>> 8, this[oe + 3] = re & 255, oe + 4;
    };
    function me(re, oe, le, ge, Ke, Je) {
      if (le + ge > re.length)
        throw new RangeError("Index out of range");
      if (le < 0)
        throw new RangeError("Index out of range");
    }
    function Ce(re, oe, le, ge, Ke) {
      return oe = +oe, le = le >>> 0, Ke || me(re, oe, le, 4), h.write(re, oe, le, ge, 23, 4), le + 4;
    }
    M.prototype.writeFloatLE = function(re, oe, le) {
      return Ce(this, re, oe, !0, le);
    }, M.prototype.writeFloatBE = function(re, oe, le) {
      return Ce(this, re, oe, !1, le);
    };
    function je(re, oe, le, ge, Ke) {
      return oe = +oe, le = le >>> 0, Ke || me(re, oe, le, 8), h.write(re, oe, le, ge, 52, 8), le + 8;
    }
    M.prototype.writeDoubleLE = function(re, oe, le) {
      return je(this, re, oe, !0, le);
    }, M.prototype.writeDoubleBE = function(re, oe, le) {
      return je(this, re, oe, !1, le);
    }, M.prototype.copy = function(re, oe, le, ge) {
      if (!M.isBuffer(re))
        throw new TypeError("argument should be a Buffer");
      if (le || (le = 0), !ge && ge !== 0 && (ge = this.length), oe >= re.length && (oe = re.length), oe || (oe = 0), ge > 0 && ge < le && (ge = le), ge === le || re.length === 0 || this.length === 0)
        return 0;
      if (oe < 0)
        throw new RangeError("targetStart out of bounds");
      if (le < 0 || le >= this.length)
        throw new RangeError("Index out of range");
      if (ge < 0)
        throw new RangeError("sourceEnd out of bounds");
      ge > this.length && (ge = this.length), re.length - oe < ge - le && (ge = re.length - oe + le);
      var Ke = ge - le;
      return this === re && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(oe, le, ge) : Uint8Array.prototype.set.call(
        re,
        this.subarray(le, ge),
        oe
      ), Ke;
    }, M.prototype.fill = function(re, oe, le, ge) {
      if (typeof re == "string") {
        if (typeof oe == "string" ? (ge = oe, oe = 0, le = this.length) : typeof le == "string" && (ge = le, le = this.length), ge !== void 0 && typeof ge != "string")
          throw new TypeError("encoding must be a string");
        if (typeof ge == "string" && !M.isEncoding(ge))
          throw new TypeError("Unknown encoding: " + ge);
        if (re.length === 1) {
          var Ke = re.charCodeAt(0);
          (ge === "utf8" && Ke < 128 || ge === "latin1") && (re = Ke);
        }
      } else
        typeof re == "number" ? re = re & 255 : typeof re == "boolean" && (re = Number(re));
      if (oe < 0 || this.length < oe || this.length < le)
        throw new RangeError("Out of range index");
      if (le <= oe)
        return this;
      oe = oe >>> 0, le = le === void 0 ? this.length : le >>> 0, re || (re = 0);
      var Je;
      if (typeof re == "number")
        for (Je = oe; Je < le; ++Je)
          this[Je] = re;
      else {
        var Fe = M.isBuffer(re) ? re : M.from(re, ge), Ye = Fe.length;
        if (Ye === 0)
          throw new TypeError('The value "' + re + '" is invalid for argument "value"');
        for (Je = 0; Je < le - oe; ++Je)
          this[Je + oe] = Fe[Je % Ye];
      }
      return this;
    };
    var Re = /[^+/0-9A-Za-z-_]/g;
    function Ae(re) {
      if (re = re.split("=")[0], re = re.trim().replace(Re, ""), re.length < 2)
        return "";
      for (; re.length % 4 !== 0; )
        re = re + "=";
      return re;
    }
    function ke(re, oe) {
      oe = oe || 1 / 0;
      for (var le, ge = re.length, Ke = null, Je = [], Fe = 0; Fe < ge; ++Fe) {
        if (le = re.charCodeAt(Fe), le > 55295 && le < 57344) {
          if (!Ke) {
            if (le > 56319) {
              (oe -= 3) > -1 && Je.push(239, 191, 189);
              continue;
            } else if (Fe + 1 === ge) {
              (oe -= 3) > -1 && Je.push(239, 191, 189);
              continue;
            }
            Ke = le;
            continue;
          }
          if (le < 56320) {
            (oe -= 3) > -1 && Je.push(239, 191, 189), Ke = le;
            continue;
          }
          le = (Ke - 55296 << 10 | le - 56320) + 65536;
        } else
          Ke && (oe -= 3) > -1 && Je.push(239, 191, 189);
        if (Ke = null, le < 128) {
          if ((oe -= 1) < 0)
            break;
          Je.push(le);
        } else if (le < 2048) {
          if ((oe -= 2) < 0)
            break;
          Je.push(
            le >> 6 | 192,
            le & 63 | 128
          );
        } else if (le < 65536) {
          if ((oe -= 3) < 0)
            break;
          Je.push(
            le >> 12 | 224,
            le >> 6 & 63 | 128,
            le & 63 | 128
          );
        } else if (le < 1114112) {
          if ((oe -= 4) < 0)
            break;
          Je.push(
            le >> 18 | 240,
            le >> 12 & 63 | 128,
            le >> 6 & 63 | 128,
            le & 63 | 128
          );
        } else
          throw new Error("Invalid code point");
      }
      return Je;
    }
    function Qe(re) {
      for (var oe = [], le = 0; le < re.length; ++le)
        oe.push(re.charCodeAt(le) & 255);
      return oe;
    }
    function Ze(re, oe) {
      for (var le, ge, Ke, Je = [], Fe = 0; Fe < re.length && !((oe -= 2) < 0); ++Fe)
        le = re.charCodeAt(Fe), ge = le >> 8, Ke = le % 256, Je.push(Ke), Je.push(ge);
      return Je;
    }
    function qe(re) {
      return t.toByteArray(Ae(re));
    }
    function Oe(re, oe, le, ge) {
      for (var Ke = 0; Ke < ge && !(Ke + le >= oe.length || Ke >= re.length); ++Ke)
        oe[Ke + le] = re[Ke];
      return Ke;
    }
    function Xe(re, oe) {
      return re instanceof oe || re != null && re.constructor != null && re.constructor.name != null && re.constructor.name === oe.name;
    }
    function et(re) {
      return re !== re;
    }
    var nt = function() {
      for (var re = "0123456789abcdef", oe = new Array(256), le = 0; le < 16; ++le)
        for (var ge = le * 16, Ke = 0; Ke < 16; ++Ke)
          oe[ge + Ke] = re[le] + re[Ke];
      return oe;
    }();
  }(buffer$1)), buffer$1;
}
var bufferExports = requireBuffer$1(), browser$c = { exports: {} }, process = browser$c.exports = {}, cachedSetTimeout, cachedClearTimeout;
function defaultSetTimout() {
  throw new Error("setTimeout has not been defined");
}
function defaultClearTimeout() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? cachedSetTimeout = setTimeout : cachedSetTimeout = defaultSetTimout;
  } catch {
    cachedSetTimeout = defaultSetTimout;
  }
  try {
    typeof clearTimeout == "function" ? cachedClearTimeout = clearTimeout : cachedClearTimeout = defaultClearTimeout;
  } catch {
    cachedClearTimeout = defaultClearTimeout;
  }
})();
function runTimeout(e) {
  if (cachedSetTimeout === setTimeout)
    return setTimeout(e, 0);
  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout)
    return cachedSetTimeout = setTimeout, setTimeout(e, 0);
  try {
    return cachedSetTimeout(e, 0);
  } catch {
    try {
      return cachedSetTimeout.call(null, e, 0);
    } catch {
      return cachedSetTimeout.call(this, e, 0);
    }
  }
}
function runClearTimeout(e) {
  if (cachedClearTimeout === clearTimeout)
    return clearTimeout(e);
  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout)
    return cachedClearTimeout = clearTimeout, clearTimeout(e);
  try {
    return cachedClearTimeout(e);
  } catch {
    try {
      return cachedClearTimeout.call(null, e);
    } catch {
      return cachedClearTimeout.call(this, e);
    }
  }
}
var queue = [], draining = !1, currentQueue, queueIndex = -1;
function cleanUpNextTick() {
  !draining || !currentQueue || (draining = !1, currentQueue.length ? queue = currentQueue.concat(queue) : queueIndex = -1, queue.length && drainQueue());
}
function drainQueue() {
  if (!draining) {
    var e = runTimeout(cleanUpNextTick);
    draining = !0;
    for (var t = queue.length; t; ) {
      for (currentQueue = queue, queue = []; ++queueIndex < t; )
        currentQueue && currentQueue[queueIndex].run();
      queueIndex = -1, t = queue.length;
    }
    currentQueue = null, draining = !1, runClearTimeout(e);
  }
}
process.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var h = 1; h < arguments.length; h++)
      t[h - 1] = arguments[h];
  queue.push(new Item(e, t)), queue.length === 1 && !draining && runTimeout(drainQueue);
};
function Item(e, t) {
  this.fun = e, this.array = t;
}
Item.prototype.run = function() {
  this.fun.apply(null, this.array);
};
process.title = "browser";
process.browser = !0;
process.env = {};
process.argv = [];
process.version = "";
process.versions = {};
function noop() {
}
process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;
process.listeners = function(e) {
  return [];
};
process.binding = function(e) {
  throw new Error("process.binding is not supported");
};
process.cwd = function() {
  return "/";
};
process.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
process.umask = function() {
  return 0;
};
var browserExports = browser$c.exports;
const process$1 = /* @__PURE__ */ getDefaultExportFromCjs(browserExports);
(function(e) {
  function t() {
    var o = this || self;
    return delete e.prototype.__magic__, o;
  }
  if (typeof globalThis == "object")
    return globalThis;
  if (this)
    return t();
  e.defineProperty(e.prototype, "__magic__", {
    configurable: !0,
    get: t
  });
  var h = __magic__;
  return h;
})(Object);
var eventemitter2 = { exports: {} };
(function(e, t) {
  (function(h) {
    var o = Object.hasOwnProperty, S = Array.isArray ? Array.isArray : function(F) {
      return Object.prototype.toString.call(F) === "[object Array]";
    }, g = 10, B = typeof process$1 == "object" && typeof process$1.nextTick == "function", M = typeof Symbol == "function", O = typeof Reflect == "object", P = typeof setImmediate == "function", D = P ? setImmediate : setTimeout, Z = M ? O && typeof Reflect.ownKeys == "function" ? Reflect.ownKeys : function(F) {
      var $ = Object.getOwnPropertyNames(F);
      return $.push.apply($, Object.getOwnPropertySymbols(F)), $;
    } : Object.keys;
    function Y() {
      this._events = {}, this._conf && ee.call(this, this._conf);
    }
    function ee(F) {
      F && (this._conf = F, F.delimiter && (this.delimiter = F.delimiter), F.maxListeners !== h && (this._maxListeners = F.maxListeners), F.wildcard && (this.wildcard = F.wildcard), F.newListener && (this._newListener = F.newListener), F.removeListener && (this._removeListener = F.removeListener), F.verboseMemoryLeak && (this.verboseMemoryLeak = F.verboseMemoryLeak), F.ignoreErrors && (this.ignoreErrors = F.ignoreErrors), this.wildcard && (this.listenerTree = {}));
    }
    function ie(F, $) {
      var H = "(node) warning: possible EventEmitter memory leak detected. " + F + " listeners added. Use emitter.setMaxListeners() to increase limit.";
      if (this.verboseMemoryLeak && (H += " Event name: " + $ + "."), typeof process$1 < "u" && process$1.emitWarning) {
        var q = new Error(H);
        q.name = "MaxListenersExceededWarning", q.emitter = this, q.count = F, process$1.emitWarning(q);
      } else
        console.error(H), console.trace && console.trace();
    }
    var ue = function(F, $, H) {
      var q = arguments.length;
      switch (q) {
        case 0:
          return [];
        case 1:
          return [F];
        case 2:
          return [F, $];
        case 3:
          return [F, $, H];
        default:
          for (var z = new Array(q); q--; )
            z[q] = arguments[q];
          return z;
      }
    };
    function fe(F, $) {
      for (var H = {}, q, z = F.length, me = $ ? $.length : 0, Ce = 0; Ce < z; Ce++)
        q = F[Ce], H[q] = Ce < me ? $[Ce] : h;
      return H;
    }
    function de(F, $, H) {
      this._emitter = F, this._target = $, this._listeners = {}, this._listenersCount = 0;
      var q, z;
      if ((H.on || H.off) && (q = H.on, z = H.off), $.addEventListener ? (q = $.addEventListener, z = $.removeEventListener) : $.addListener ? (q = $.addListener, z = $.removeListener) : $.on && (q = $.on, z = $.off), !q && !z)
        throw Error("target does not implement any known event API");
      if (typeof q != "function")
        throw TypeError("on method must be a function");
      if (typeof z != "function")
        throw TypeError("off method must be a function");
      this._on = q, this._off = z;
      var me = F._observers;
      me ? me.push(this) : F._observers = [this];
    }
    Object.assign(de.prototype, {
      subscribe: function(F, $, H) {
        var q = this, z = this._target, me = this._emitter, Ce = this._listeners, je = function() {
          var Re = ue.apply(null, arguments), Ae = {
            data: Re,
            name: $,
            original: F
          };
          if (H) {
            var ke = H.call(z, Ae);
            ke !== !1 && me.emit.apply(me, [Ae.name].concat(Re));
            return;
          }
          me.emit.apply(me, [$].concat(Re));
        };
        if (Ce[F])
          throw Error("Event '" + F + "' is already listening");
        this._listenersCount++, me._newListener && me._removeListener && !q._onNewListener ? (this._onNewListener = function(Re) {
          Re === $ && Ce[F] === null && (Ce[F] = je, q._on.call(z, F, je));
        }, me.on("newListener", this._onNewListener), this._onRemoveListener = function(Re) {
          Re === $ && !me.hasListeners(Re) && Ce[F] && (Ce[F] = null, q._off.call(z, F, je));
        }, Ce[F] = null, me.on("removeListener", this._onRemoveListener)) : (Ce[F] = je, q._on.call(z, F, je));
      },
      unsubscribe: function(F) {
        var $ = this, H = this._listeners, q = this._emitter, z, me, Ce = this._off, je = this._target, Re;
        if (F && typeof F != "string")
          throw TypeError("event must be a string");
        function Ae() {
          $._onNewListener && (q.off("newListener", $._onNewListener), q.off("removeListener", $._onRemoveListener), $._onNewListener = null, $._onRemoveListener = null);
          var ke = Le.call(q, $);
          q._observers.splice(ke, 1);
        }
        if (F) {
          if (z = H[F], !z)
            return;
          Ce.call(je, F, z), delete H[F], --this._listenersCount || Ae();
        } else {
          for (me = Z(H), Re = me.length; Re-- > 0; )
            F = me[Re], Ce.call(je, F, H[F]);
          this._listeners = {}, this._listenersCount = 0, Ae();
        }
      }
    });
    function ce(F, $, H, q) {
      var z = Object.assign({}, $);
      if (!F)
        return z;
      if (typeof F != "object")
        throw TypeError("options must be an object");
      var me = Object.keys(F), Ce = me.length, je, Re, Ae;
      function ke(Ze) {
        throw Error('Invalid "' + je + '" option value' + (Ze ? ". Reason: " + Ze : ""));
      }
      for (var Qe = 0; Qe < Ce; Qe++) {
        if (je = me[Qe], !q && !o.call($, je))
          throw Error('Unknown "' + je + '" option');
        Re = F[je], Re !== h && (Ae = H[je], z[je] = Ae ? Ae(Re, ke) : Re);
      }
      return z;
    }
    function be(F, $) {
      return (typeof F != "function" || !F.hasOwnProperty("prototype")) && $("value must be a constructor"), F;
    }
    function ve(F) {
      var $ = "value must be type of " + F.join("|"), H = F.length, q = F[0], z = F[1];
      return H === 1 ? function(me, Ce) {
        if (typeof me === q)
          return me;
        Ce($);
      } : H === 2 ? function(me, Ce) {
        var je = typeof me;
        if (je === q || je === z)
          return me;
        Ce($);
      } : function(me, Ce) {
        for (var je = typeof me, Re = H; Re-- > 0; )
          if (je === F[Re])
            return me;
        Ce($);
      };
    }
    var Pe = ve(["function"]), Ue = ve(["object", "function"]);
    function ze(F, $, H) {
      var q, z, me = 0, Ce, je = new F(function(Re, Ae, ke) {
        H = ce(H, {
          timeout: 0,
          overload: !1
        }, {
          timeout: function(Oe, Xe) {
            return Oe *= 1, (typeof Oe != "number" || Oe < 0 || !Number.isFinite(Oe)) && Xe("timeout must be a positive number"), Oe;
          }
        }), q = !H.overload && typeof F.prototype.cancel == "function" && typeof ke == "function";
        function Qe() {
          z && (z = null), me && (clearTimeout(me), me = 0);
        }
        var Ze = function(Oe) {
          Qe(), Re(Oe);
        }, qe = function(Oe) {
          Qe(), Ae(Oe);
        };
        q ? $(Ze, qe, ke) : (z = [function(Oe) {
          qe(Oe || Error("canceled"));
        }], $(Ze, qe, function(Oe) {
          if (Ce)
            throw Error("Unable to subscribe on cancel event asynchronously");
          if (typeof Oe != "function")
            throw TypeError("onCancel callback must be a function");
          z.push(Oe);
        }), Ce = !0), H.timeout > 0 && (me = setTimeout(function() {
          var Oe = Error("timeout");
          Oe.code = "ETIMEDOUT", me = 0, je.cancel(Oe), Ae(Oe);
        }, H.timeout));
      });
      return q || (je.cancel = function(Re) {
        if (z) {
          for (var Ae = z.length, ke = 1; ke < Ae; ke++)
            z[ke](Re);
          z[0](Re), z = null;
        }
      }), je;
    }
    function Le(F) {
      var $ = this._observers;
      if (!$)
        return -1;
      for (var H = $.length, q = 0; q < H; q++)
        if ($[q]._target === F)
          return q;
      return -1;
    }
    function Ne(F, $, H, q, z) {
      if (!H)
        return null;
      if (q === 0) {
        var me = typeof $;
        if (me === "string") {
          var Ce, je, Re = 0, Ae = 0, ke = this.delimiter, Qe = ke.length;
          if ((je = $.indexOf(ke)) !== -1) {
            Ce = new Array(5);
            do
              Ce[Re++] = $.slice(Ae, je), Ae = je + Qe;
            while ((je = $.indexOf(ke, Ae)) !== -1);
            Ce[Re++] = $.slice(Ae), $ = Ce, z = Re;
          } else
            $ = [$], z = 1;
        } else
          me === "object" ? z = $.length : ($ = [$], z = 1);
      }
      var Ze = null, qe, Oe, Xe, et, nt, re = $[q], oe = $[q + 1], le, ge;
      if (q === z)
        H._listeners && (typeof H._listeners == "function" ? (F && F.push(H._listeners), Ze = [H]) : (F && F.push.apply(F, H._listeners), Ze = [H]));
      else if (re === "*") {
        for (le = Z(H), je = le.length; je-- > 0; )
          qe = le[je], qe !== "_listeners" && (ge = Ne(F, $, H[qe], q + 1, z), ge && (Ze ? Ze.push.apply(Ze, ge) : Ze = ge));
        return Ze;
      } else if (re === "**") {
        for (nt = q + 1 === z || q + 2 === z && oe === "*", nt && H._listeners && (Ze = Ne(F, $, H, z, z)), le = Z(H), je = le.length; je-- > 0; )
          qe = le[je], qe !== "_listeners" && (qe === "*" || qe === "**" ? (H[qe]._listeners && !nt && (ge = Ne(F, $, H[qe], z, z), ge && (Ze ? Ze.push.apply(Ze, ge) : Ze = ge)), ge = Ne(F, $, H[qe], q, z)) : qe === oe ? ge = Ne(F, $, H[qe], q + 2, z) : ge = Ne(F, $, H[qe], q, z), ge && (Ze ? Ze.push.apply(Ze, ge) : Ze = ge));
        return Ze;
      } else
        H[re] && (Ze = Ne(F, $, H[re], q + 1, z));
      if (Oe = H["*"], Oe && Ne(F, $, Oe, q + 1, z), Xe = H["**"], Xe)
        if (q < z)
          for (Xe._listeners && Ne(F, $, Xe, z, z), le = Z(Xe), je = le.length; je-- > 0; )
            qe = le[je], qe !== "_listeners" && (qe === oe ? Ne(F, $, Xe[qe], q + 2, z) : qe === re ? Ne(F, $, Xe[qe], q + 1, z) : (et = {}, et[qe] = Xe[qe], Ne(F, $, { "**": et }, q + 1, z)));
        else
          Xe._listeners ? Ne(F, $, Xe, z, z) : Xe["*"] && Xe["*"]._listeners && Ne(F, $, Xe["*"], z, z);
      return Ze;
    }
    function $e(F, $, H) {
      var q = 0, z = 0, me, Ce = this.delimiter, je = Ce.length, Re;
      if (typeof F == "string")
        if ((me = F.indexOf(Ce)) !== -1) {
          Re = new Array(5);
          do
            Re[q++] = F.slice(z, me), z = me + je;
          while ((me = F.indexOf(Ce, z)) !== -1);
          Re[q++] = F.slice(z);
        } else
          Re = [F], q = 1;
      else
        Re = F, q = F.length;
      if (q > 1) {
        for (me = 0; me + 1 < q; me++)
          if (Re[me] === "**" && Re[me + 1] === "**")
            return;
      }
      var Ae = this.listenerTree, ke;
      for (me = 0; me < q; me++)
        if (ke = Re[me], Ae = Ae[ke] || (Ae[ke] = {}), me === q - 1)
          return Ae._listeners ? (typeof Ae._listeners == "function" && (Ae._listeners = [Ae._listeners]), H ? Ae._listeners.unshift($) : Ae._listeners.push($), !Ae._listeners.warned && this._maxListeners > 0 && Ae._listeners.length > this._maxListeners && (Ae._listeners.warned = !0, ie.call(this, Ae._listeners.length, ke))) : Ae._listeners = $, !0;
      return !0;
    }
    function J(F, $, H, q) {
      for (var z = Z(F), me = z.length, Ce, je, Re, Ae = F._listeners, ke; me-- > 0; )
        je = z[me], Ce = F[je], je === "_listeners" ? Re = H : Re = H ? H.concat(je) : [je], ke = q || typeof je == "symbol", Ae && $.push(ke ? Re : Re.join(this.delimiter)), typeof Ce == "object" && J.call(this, Ce, $, Re, ke);
      return $;
    }
    function ne(F) {
      for (var $ = Z(F), H = $.length, q, z, me; H-- > 0; )
        z = $[H], q = F[z], q && (me = !0, z !== "_listeners" && !ne(q) && delete F[z]);
      return me;
    }
    function A(F, $, H) {
      this.emitter = F, this.event = $, this.listener = H;
    }
    A.prototype.off = function() {
      return this.emitter.off(this.event, this.listener), this;
    };
    function I(F, $, H) {
      if (H === !0)
        z = !0;
      else if (H === !1)
        q = !0;
      else {
        if (!H || typeof H != "object")
          throw TypeError("options should be an object or true");
        var q = H.async, z = H.promisify, me = H.nextTick, Ce = H.objectify;
      }
      if (q || me || z) {
        var je = $, Re = $._origin || $;
        if (me && !B)
          throw Error("process.nextTick is not supported");
        z === h && (z = $.constructor.name === "AsyncFunction"), $ = function() {
          var Ae = arguments, ke = this, Qe = this.event;
          return z ? me ? Promise.resolve() : new Promise(function(Ze) {
            D(Ze);
          }).then(function() {
            return ke.event = Qe, je.apply(ke, Ae);
          }) : (me ? process$1.nextTick : D)(function() {
            ke.event = Qe, je.apply(ke, Ae);
          });
        }, $._async = !0, $._origin = Re;
      }
      return [$, Ce ? new A(this, F, $) : this];
    }
    function U(F) {
      this._events = {}, this._newListener = !1, this._removeListener = !1, this.verboseMemoryLeak = !1, ee.call(this, F);
    }
    U.EventEmitter2 = U, U.prototype.listenTo = function(F, $, H) {
      if (typeof F != "object")
        throw TypeError("target musts be an object");
      var q = this;
      H = ce(H, {
        on: h,
        off: h,
        reducers: h
      }, {
        on: Pe,
        off: Pe,
        reducers: Ue
      });
      function z(me) {
        if (typeof me != "object")
          throw TypeError("events must be an object");
        var Ce = H.reducers, je = Le.call(q, F), Re;
        je === -1 ? Re = new de(q, F, H) : Re = q._observers[je];
        for (var Ae = Z(me), ke = Ae.length, Qe, Ze = typeof Ce == "function", qe = 0; qe < ke; qe++)
          Qe = Ae[qe], Re.subscribe(
            Qe,
            me[Qe] || Qe,
            Ze ? Ce : Ce && Ce[Qe]
          );
      }
      return S($) ? z(fe($)) : z(typeof $ == "string" ? fe($.split(/\s+/)) : $), this;
    }, U.prototype.stopListeningTo = function(F, $) {
      var H = this._observers;
      if (!H)
        return !1;
      var q = H.length, z, me = !1;
      if (F && typeof F != "object")
        throw TypeError("target should be an object");
      for (; q-- > 0; )
        z = H[q], (!F || z._target === F) && (z.unsubscribe($), me = !0);
      return me;
    }, U.prototype.delimiter = ".", U.prototype.setMaxListeners = function(F) {
      F !== h && (this._maxListeners = F, this._conf || (this._conf = {}), this._conf.maxListeners = F);
    }, U.prototype.getMaxListeners = function() {
      return this._maxListeners;
    }, U.prototype.event = "", U.prototype.once = function(F, $, H) {
      return this._once(F, $, !1, H);
    }, U.prototype.prependOnceListener = function(F, $, H) {
      return this._once(F, $, !0, H);
    }, U.prototype._once = function(F, $, H, q) {
      return this._many(F, 1, $, H, q);
    }, U.prototype.many = function(F, $, H, q) {
      return this._many(F, $, H, !1, q);
    }, U.prototype.prependMany = function(F, $, H, q) {
      return this._many(F, $, H, !0, q);
    }, U.prototype._many = function(F, $, H, q, z) {
      var me = this;
      if (typeof H != "function")
        throw new Error("many only accepts instances of Function");
      function Ce() {
        return --$ === 0 && me.off(F, Ce), H.apply(this, arguments);
      }
      return Ce._origin = H, this._on(F, Ce, q, z);
    }, U.prototype.emit = function() {
      if (!this._events && !this._all)
        return !1;
      this._events || Y.call(this);
      var F = arguments[0], $, H = this.wildcard, q, z, me, Ce, je;
      if (F === "newListener" && !this._newListener && !this._events.newListener)
        return !1;
      if (H && ($ = F, F !== "newListener" && F !== "removeListener" && typeof F == "object")) {
        if (z = F.length, M) {
          for (me = 0; me < z; me++)
            if (typeof F[me] == "symbol") {
              je = !0;
              break;
            }
        }
        je || (F = F.join(this.delimiter));
      }
      var Re = arguments.length, Ae;
      if (this._all && this._all.length)
        for (Ae = this._all.slice(), me = 0, z = Ae.length; me < z; me++)
          switch (this.event = F, Re) {
            case 1:
              Ae[me].call(this, F);
              break;
            case 2:
              Ae[me].call(this, F, arguments[1]);
              break;
            case 3:
              Ae[me].call(this, F, arguments[1], arguments[2]);
              break;
            default:
              Ae[me].apply(this, arguments);
          }
      if (H)
        Ae = [], Ne.call(this, Ae, $, this.listenerTree, 0, z);
      else if (Ae = this._events[F], typeof Ae == "function") {
        switch (this.event = F, Re) {
          case 1:
            Ae.call(this);
            break;
          case 2:
            Ae.call(this, arguments[1]);
            break;
          case 3:
            Ae.call(this, arguments[1], arguments[2]);
            break;
          default:
            for (q = new Array(Re - 1), Ce = 1; Ce < Re; Ce++)
              q[Ce - 1] = arguments[Ce];
            Ae.apply(this, q);
        }
        return !0;
      } else
        Ae && (Ae = Ae.slice());
      if (Ae && Ae.length) {
        if (Re > 3)
          for (q = new Array(Re - 1), Ce = 1; Ce < Re; Ce++)
            q[Ce - 1] = arguments[Ce];
        for (me = 0, z = Ae.length; me < z; me++)
          switch (this.event = F, Re) {
            case 1:
              Ae[me].call(this);
              break;
            case 2:
              Ae[me].call(this, arguments[1]);
              break;
            case 3:
              Ae[me].call(this, arguments[1], arguments[2]);
              break;
            default:
              Ae[me].apply(this, q);
          }
        return !0;
      } else if (!this.ignoreErrors && !this._all && F === "error")
        throw arguments[1] instanceof Error ? arguments[1] : new Error("Uncaught, unspecified 'error' event.");
      return !!this._all;
    }, U.prototype.emitAsync = function() {
      if (!this._events && !this._all)
        return !1;
      this._events || Y.call(this);
      var F = arguments[0], $ = this.wildcard, H, q, z, me, Ce, je;
      if (F === "newListener" && !this._newListener && !this._events.newListener)
        return Promise.resolve([!1]);
      if ($ && (H = F, F !== "newListener" && F !== "removeListener" && typeof F == "object")) {
        if (me = F.length, M) {
          for (Ce = 0; Ce < me; Ce++)
            if (typeof F[Ce] == "symbol") {
              q = !0;
              break;
            }
        }
        q || (F = F.join(this.delimiter));
      }
      var Re = [], Ae = arguments.length, ke;
      if (this._all)
        for (Ce = 0, me = this._all.length; Ce < me; Ce++)
          switch (this.event = F, Ae) {
            case 1:
              Re.push(this._all[Ce].call(this, F));
              break;
            case 2:
              Re.push(this._all[Ce].call(this, F, arguments[1]));
              break;
            case 3:
              Re.push(this._all[Ce].call(this, F, arguments[1], arguments[2]));
              break;
            default:
              Re.push(this._all[Ce].apply(this, arguments));
          }
      if ($ ? (ke = [], Ne.call(this, ke, H, this.listenerTree, 0)) : ke = this._events[F], typeof ke == "function")
        switch (this.event = F, Ae) {
          case 1:
            Re.push(ke.call(this));
            break;
          case 2:
            Re.push(ke.call(this, arguments[1]));
            break;
          case 3:
            Re.push(ke.call(this, arguments[1], arguments[2]));
            break;
          default:
            for (z = new Array(Ae - 1), je = 1; je < Ae; je++)
              z[je - 1] = arguments[je];
            Re.push(ke.apply(this, z));
        }
      else if (ke && ke.length) {
        if (ke = ke.slice(), Ae > 3)
          for (z = new Array(Ae - 1), je = 1; je < Ae; je++)
            z[je - 1] = arguments[je];
        for (Ce = 0, me = ke.length; Ce < me; Ce++)
          switch (this.event = F, Ae) {
            case 1:
              Re.push(ke[Ce].call(this));
              break;
            case 2:
              Re.push(ke[Ce].call(this, arguments[1]));
              break;
            case 3:
              Re.push(ke[Ce].call(this, arguments[1], arguments[2]));
              break;
            default:
              Re.push(ke[Ce].apply(this, z));
          }
      } else if (!this.ignoreErrors && !this._all && F === "error")
        return arguments[1] instanceof Error ? Promise.reject(arguments[1]) : Promise.reject("Uncaught, unspecified 'error' event.");
      return Promise.all(Re);
    }, U.prototype.on = function(F, $, H) {
      return this._on(F, $, !1, H);
    }, U.prototype.prependListener = function(F, $, H) {
      return this._on(F, $, !0, H);
    }, U.prototype.onAny = function(F) {
      return this._onAny(F, !1);
    }, U.prototype.prependAny = function(F) {
      return this._onAny(F, !0);
    }, U.prototype.addListener = U.prototype.on, U.prototype._onAny = function(F, $) {
      if (typeof F != "function")
        throw new Error("onAny only accepts instances of Function");
      return this._all || (this._all = []), $ ? this._all.unshift(F) : this._all.push(F), this;
    }, U.prototype._on = function(F, $, H, q) {
      if (typeof F == "function")
        return this._onAny(F, $), this;
      if (typeof $ != "function")
        throw new Error("on only accepts instances of Function");
      this._events || Y.call(this);
      var z = this, me;
      return q !== h && (me = I.call(this, F, $, q), $ = me[0], z = me[1]), this._newListener && this.emit("newListener", F, $), this.wildcard ? ($e.call(this, F, $, H), z) : (this._events[F] ? (typeof this._events[F] == "function" && (this._events[F] = [this._events[F]]), H ? this._events[F].unshift($) : this._events[F].push($), !this._events[F].warned && this._maxListeners > 0 && this._events[F].length > this._maxListeners && (this._events[F].warned = !0, ie.call(this, this._events[F].length, F))) : this._events[F] = $, z);
    }, U.prototype.off = function(F, $) {
      if (typeof $ != "function")
        throw new Error("removeListener only takes instances of Function");
      var H, q = [];
      if (this.wildcard) {
        var z = typeof F == "string" ? F.split(this.delimiter) : F.slice();
        if (q = Ne.call(this, null, z, this.listenerTree, 0), !q)
          return this;
      } else {
        if (!this._events[F])
          return this;
        H = this._events[F], q.push({ _listeners: H });
      }
      for (var me = 0; me < q.length; me++) {
        var Ce = q[me];
        if (H = Ce._listeners, S(H)) {
          for (var je = -1, Re = 0, Ae = H.length; Re < Ae; Re++)
            if (H[Re] === $ || H[Re].listener && H[Re].listener === $ || H[Re]._origin && H[Re]._origin === $) {
              je = Re;
              break;
            }
          if (je < 0)
            continue;
          return this.wildcard ? Ce._listeners.splice(je, 1) : this._events[F].splice(je, 1), H.length === 0 && (this.wildcard ? delete Ce._listeners : delete this._events[F]), this._removeListener && this.emit("removeListener", F, $), this;
        } else
          (H === $ || H.listener && H.listener === $ || H._origin && H._origin === $) && (this.wildcard ? delete Ce._listeners : delete this._events[F], this._removeListener && this.emit("removeListener", F, $));
      }
      return this.listenerTree && ne(this.listenerTree), this;
    }, U.prototype.offAny = function(F) {
      var $ = 0, H = 0, q;
      if (F && this._all && this._all.length > 0) {
        for (q = this._all, $ = 0, H = q.length; $ < H; $++)
          if (F === q[$])
            return q.splice($, 1), this._removeListener && this.emit("removeListenerAny", F), this;
      } else {
        if (q = this._all, this._removeListener)
          for ($ = 0, H = q.length; $ < H; $++)
            this.emit("removeListenerAny", q[$]);
        this._all = [];
      }
      return this;
    }, U.prototype.removeListener = U.prototype.off, U.prototype.removeAllListeners = function(F) {
      if (F === h)
        return !this._events || Y.call(this), this;
      if (this.wildcard) {
        var $ = Ne.call(this, null, F, this.listenerTree, 0), H, q;
        if (!$)
          return this;
        for (q = 0; q < $.length; q++)
          H = $[q], H._listeners = null;
        this.listenerTree && ne(this.listenerTree);
      } else
        this._events && (this._events[F] = null);
      return this;
    }, U.prototype.listeners = function(F) {
      var $ = this._events, H, q, z, me, Ce;
      if (F === h) {
        if (this.wildcard)
          throw Error("event name required for wildcard emitter");
        if (!$)
          return [];
        for (H = Z($), me = H.length, z = []; me-- > 0; )
          q = $[H[me]], typeof q == "function" ? z.push(q) : z.push.apply(z, q);
        return z;
      } else {
        if (this.wildcard) {
          if (Ce = this.listenerTree, !Ce)
            return [];
          var je = [], Re = typeof F == "string" ? F.split(this.delimiter) : F.slice();
          return Ne.call(this, je, Re, Ce, 0), je;
        }
        return $ ? (q = $[F], q ? typeof q == "function" ? [q] : q : []) : [];
      }
    }, U.prototype.eventNames = function(F) {
      var $ = this._events;
      return this.wildcard ? J.call(this, this.listenerTree, [], null, F) : $ ? Z($) : [];
    }, U.prototype.listenerCount = function(F) {
      return this.listeners(F).length;
    }, U.prototype.hasListeners = function(F) {
      if (this.wildcard) {
        var $ = [], H = typeof F == "string" ? F.split(this.delimiter) : F.slice();
        return Ne.call(this, $, H, this.listenerTree, 0), $.length > 0;
      }
      var q = this._events, z = this._all;
      return !!(z && z.length || q && (F === h ? Z(q).length : q[F]));
    }, U.prototype.listenersAny = function() {
      return this._all ? this._all : [];
    }, U.prototype.waitFor = function(F, $) {
      var H = this, q = typeof $;
      return q === "number" ? $ = { timeout: $ } : q === "function" && ($ = { filter: $ }), $ = ce($, {
        timeout: 0,
        filter: h,
        handleError: !1,
        Promise,
        overload: !1
      }, {
        filter: Pe,
        Promise: be
      }), ze($.Promise, function(z, me, Ce) {
        function je() {
          var Re = $.filter;
          if (!(Re && !Re.apply(H, arguments)))
            if (H.off(F, je), $.handleError) {
              var Ae = arguments[0];
              Ae ? me(Ae) : z(ue.apply(null, arguments).slice(1));
            } else
              z(ue.apply(null, arguments));
        }
        Ce(function() {
          H.off(F, je);
        }), H._on(F, je, !1);
      }, {
        timeout: $.timeout,
        overload: $.overload
      });
    };
    function X(F, $, H) {
      H = ce(H, {
        Promise,
        timeout: 0,
        overload: !1
      }, {
        Promise: be
      });
      var q = H.Promise;
      return ze(q, function(z, me, Ce) {
        var je;
        if (typeof F.addEventListener == "function") {
          je = function() {
            z(ue.apply(null, arguments));
          }, Ce(function() {
            F.removeEventListener($, je);
          }), F.addEventListener(
            $,
            je,
            { once: !0 }
          );
          return;
        }
        var Re = function() {
          Ae && F.removeListener("error", Ae), z(ue.apply(null, arguments));
        }, Ae;
        $ !== "error" && (Ae = function(ke) {
          F.removeListener($, Re), me(ke);
        }, F.once("error", Ae)), Ce(function() {
          Ae && F.removeListener("error", Ae), F.removeListener($, Re);
        }), F.once($, Re);
      }, {
        timeout: H.timeout,
        overload: H.overload
      });
    }
    var Q = U.prototype;
    Object.defineProperties(U, {
      defaultMaxListeners: {
        get: function() {
          return Q._maxListeners;
        },
        set: function(F) {
          if (typeof F != "number" || F < 0 || Number.isNaN(F))
            throw TypeError("n must be a non-negative number");
          Q._maxListeners = F;
        },
        enumerable: !0
      },
      once: {
        value: X,
        writable: !0,
        configurable: !0
      }
    }), Object.defineProperties(Q, {
      _maxListeners: {
        value: g,
        writable: !0,
        configurable: !0
      },
      _observers: { value: null, writable: !0, configurable: !0 }
    }), typeof h == "function" && h.amd ? h(function() {
      return U;
    }) : e.exports = U;
  })();
})(eventemitter2);
var eventemitter2Exports = eventemitter2.exports;
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter2Exports);
class FetchAPI extends EventEmitter {
  constructor(t) {
    super(), this.baseUrl = t;
  }
  async send(t, h) {
    const { url: o, query: S, method: g, data: B, headers: M } = t, [O, P] = B instanceof FormData ? [B, {}] : [
      typeof B != "string" ? JSON.stringify(B) : B,
      {
        "Content-Type": "application/json"
      }
    ], D = this.baseUrl + o, Z = this.getUrlWithParams(D, S), Y = await fetch(Z, {
      method: g,
      headers: Object.assign(M || {}, P),
      body: O,
      credentials: t.withCredentials ? "include" : "same-origin"
    }), ee = await Y.json(), ie = this.convertHeadersToPlainObject(Y.headers);
    return new APIResponse({
      data: ee,
      status: Y.status,
      headers: ie,
      request: t
    });
  }
  getUrlWithParams(t, h) {
    if (!h)
      return t;
    const o = new URL(t);
    return Object.entries(h).forEach(
      ([S, g]) => {
        o.searchParams.append(S, g);
      }
    ), o.toString();
  }
  convertHeadersToPlainObject(t) {
    const h = {};
    for (const o of Object.keys(t))
      h[o] = t.get(o);
    return h;
  }
  // type override 를 위해서 구현 class 에서 메서드들을 재정의 해줘야함..
  addListener(t, h) {
    return super.addListener(t, h);
  }
  on(t, h, o) {
    return super.on(t, h, o);
  }
  prependListener(t, h, o) {
    return super.prependListener(t, h, o);
  }
  once(t, h, o) {
    return super.once(t, h, o);
  }
  emit(t, ...h) {
    return super.emit(t, ...h);
  }
  emitAsync(t, ...h) {
    return super.emitAsync(t, ...h);
  }
}
function commonjsRequire(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var bcrypt$1 = { exports: {} }, cryptoBrowserify = {}, browser$b = { exports: {} }, safeBuffer$1 = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
var hasRequiredSafeBuffer$1;
function requireSafeBuffer$1() {
  return hasRequiredSafeBuffer$1 || (hasRequiredSafeBuffer$1 = 1, function(e, t) {
    var h = requireBuffer$1(), o = h.Buffer;
    function S(B, M) {
      for (var O in B)
        M[O] = B[O];
    }
    o.from && o.alloc && o.allocUnsafe && o.allocUnsafeSlow ? e.exports = h : (S(h, t), t.Buffer = g);
    function g(B, M, O) {
      return o(B, M, O);
    }
    g.prototype = Object.create(o.prototype), S(o, g), g.from = function(B, M, O) {
      if (typeof B == "number")
        throw new TypeError("Argument must not be a number");
      return o(B, M, O);
    }, g.alloc = function(B, M, O) {
      if (typeof B != "number")
        throw new TypeError("Argument must be a number");
      var P = o(B);
      return M !== void 0 ? typeof O == "string" ? P.fill(M, O) : P.fill(M) : P.fill(0), P;
    }, g.allocUnsafe = function(B) {
      if (typeof B != "number")
        throw new TypeError("Argument must be a number");
      return o(B);
    }, g.allocUnsafeSlow = function(B) {
      if (typeof B != "number")
        throw new TypeError("Argument must be a number");
      return h.SlowBuffer(B);
    };
  }(safeBuffer$1, safeBuffer$1.exports)), safeBuffer$1.exports;
}
var hasRequiredBrowser$b;
function requireBrowser$b() {
  if (hasRequiredBrowser$b)
    return browser$b.exports;
  hasRequiredBrowser$b = 1;
  var e = 65536, t = 4294967295;
  function h() {
    throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
  }
  var o = requireSafeBuffer$1().Buffer, S = commonjsGlobal.crypto || commonjsGlobal.msCrypto;
  S && S.getRandomValues ? browser$b.exports = g : browser$b.exports = h;
  function g(B, M) {
    if (B > t)
      throw new RangeError("requested too many random bytes");
    var O = o.allocUnsafe(B);
    if (B > 0)
      if (B > e)
        for (var P = 0; P < B; P += e)
          S.getRandomValues(O.slice(P, P + e));
      else
        S.getRandomValues(O);
    return typeof M == "function" ? process$1.nextTick(function() {
      M(null, O);
    }) : O;
  }
  return browser$b.exports;
}
var inherits_browser = { exports: {} }, hasRequiredInherits_browser;
function requireInherits_browser() {
  return hasRequiredInherits_browser || (hasRequiredInherits_browser = 1, typeof Object.create == "function" ? inherits_browser.exports = function(e, t) {
    t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
      constructor: {
        value: e,
        enumerable: !1,
        writable: !0,
        configurable: !0
      }
    }));
  } : inherits_browser.exports = function(e, t) {
    if (t) {
      e.super_ = t;
      var h = function() {
      };
      h.prototype = t.prototype, e.prototype = new h(), e.prototype.constructor = e;
    }
  }), inherits_browser.exports;
}
var readableBrowser$1 = { exports: {} }, events = { exports: {} }, hasRequiredEvents;
function requireEvents() {
  if (hasRequiredEvents)
    return events.exports;
  hasRequiredEvents = 1;
  var e = typeof Reflect == "object" ? Reflect : null, t = e && typeof e.apply == "function" ? e.apply : function(ve, Pe, Ue) {
    return Function.prototype.apply.call(ve, Pe, Ue);
  }, h;
  e && typeof e.ownKeys == "function" ? h = e.ownKeys : Object.getOwnPropertySymbols ? h = function(ve) {
    return Object.getOwnPropertyNames(ve).concat(Object.getOwnPropertySymbols(ve));
  } : h = function(ve) {
    return Object.getOwnPropertyNames(ve);
  };
  function o(ve) {
    console && console.warn && console.warn(ve);
  }
  var S = Number.isNaN || function(ve) {
    return ve !== ve;
  };
  function g() {
    g.init.call(this);
  }
  events.exports = g, events.exports.once = de, g.EventEmitter = g, g.prototype._events = void 0, g.prototype._eventsCount = 0, g.prototype._maxListeners = void 0;
  var B = 10;
  function M(ve) {
    if (typeof ve != "function")
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof ve);
  }
  Object.defineProperty(g, "defaultMaxListeners", {
    enumerable: !0,
    get: function() {
      return B;
    },
    set: function(ve) {
      if (typeof ve != "number" || ve < 0 || S(ve))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + ve + ".");
      B = ve;
    }
  }), g.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  }, g.prototype.setMaxListeners = function(ve) {
    if (typeof ve != "number" || ve < 0 || S(ve))
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + ve + ".");
    return this._maxListeners = ve, this;
  };
  function O(ve) {
    return ve._maxListeners === void 0 ? g.defaultMaxListeners : ve._maxListeners;
  }
  g.prototype.getMaxListeners = function() {
    return O(this);
  }, g.prototype.emit = function(ve) {
    for (var Pe = [], Ue = 1; Ue < arguments.length; Ue++)
      Pe.push(arguments[Ue]);
    var ze = ve === "error", Le = this._events;
    if (Le !== void 0)
      ze = ze && Le.error === void 0;
    else if (!ze)
      return !1;
    if (ze) {
      var Ne;
      if (Pe.length > 0 && (Ne = Pe[0]), Ne instanceof Error)
        throw Ne;
      var $e = new Error("Unhandled error." + (Ne ? " (" + Ne.message + ")" : ""));
      throw $e.context = Ne, $e;
    }
    var J = Le[ve];
    if (J === void 0)
      return !1;
    if (typeof J == "function")
      t(J, this, Pe);
    else
      for (var ne = J.length, A = ie(J, ne), Ue = 0; Ue < ne; ++Ue)
        t(A[Ue], this, Pe);
    return !0;
  };
  function P(ve, Pe, Ue, ze) {
    var Le, Ne, $e;
    if (M(Ue), Ne = ve._events, Ne === void 0 ? (Ne = ve._events = /* @__PURE__ */ Object.create(null), ve._eventsCount = 0) : (Ne.newListener !== void 0 && (ve.emit(
      "newListener",
      Pe,
      Ue.listener ? Ue.listener : Ue
    ), Ne = ve._events), $e = Ne[Pe]), $e === void 0)
      $e = Ne[Pe] = Ue, ++ve._eventsCount;
    else if (typeof $e == "function" ? $e = Ne[Pe] = ze ? [Ue, $e] : [$e, Ue] : ze ? $e.unshift(Ue) : $e.push(Ue), Le = O(ve), Le > 0 && $e.length > Le && !$e.warned) {
      $e.warned = !0;
      var J = new Error("Possible EventEmitter memory leak detected. " + $e.length + " " + String(Pe) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      J.name = "MaxListenersExceededWarning", J.emitter = ve, J.type = Pe, J.count = $e.length, o(J);
    }
    return ve;
  }
  g.prototype.addListener = function(ve, Pe) {
    return P(this, ve, Pe, !1);
  }, g.prototype.on = g.prototype.addListener, g.prototype.prependListener = function(ve, Pe) {
    return P(this, ve, Pe, !0);
  };
  function D() {
    if (!this.fired)
      return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  function Z(ve, Pe, Ue) {
    var ze = { fired: !1, wrapFn: void 0, target: ve, type: Pe, listener: Ue }, Le = D.bind(ze);
    return Le.listener = Ue, ze.wrapFn = Le, Le;
  }
  g.prototype.once = function(ve, Pe) {
    return M(Pe), this.on(ve, Z(this, ve, Pe)), this;
  }, g.prototype.prependOnceListener = function(ve, Pe) {
    return M(Pe), this.prependListener(ve, Z(this, ve, Pe)), this;
  }, g.prototype.removeListener = function(ve, Pe) {
    var Ue, ze, Le, Ne, $e;
    if (M(Pe), ze = this._events, ze === void 0)
      return this;
    if (Ue = ze[ve], Ue === void 0)
      return this;
    if (Ue === Pe || Ue.listener === Pe)
      --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete ze[ve], ze.removeListener && this.emit("removeListener", ve, Ue.listener || Pe));
    else if (typeof Ue != "function") {
      for (Le = -1, Ne = Ue.length - 1; Ne >= 0; Ne--)
        if (Ue[Ne] === Pe || Ue[Ne].listener === Pe) {
          $e = Ue[Ne].listener, Le = Ne;
          break;
        }
      if (Le < 0)
        return this;
      Le === 0 ? Ue.shift() : ue(Ue, Le), Ue.length === 1 && (ze[ve] = Ue[0]), ze.removeListener !== void 0 && this.emit("removeListener", ve, $e || Pe);
    }
    return this;
  }, g.prototype.off = g.prototype.removeListener, g.prototype.removeAllListeners = function(ve) {
    var Pe, Ue, ze;
    if (Ue = this._events, Ue === void 0)
      return this;
    if (Ue.removeListener === void 0)
      return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : Ue[ve] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete Ue[ve]), this;
    if (arguments.length === 0) {
      var Le = Object.keys(Ue), Ne;
      for (ze = 0; ze < Le.length; ++ze)
        Ne = Le[ze], Ne !== "removeListener" && this.removeAllListeners(Ne);
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (Pe = Ue[ve], typeof Pe == "function")
      this.removeListener(ve, Pe);
    else if (Pe !== void 0)
      for (ze = Pe.length - 1; ze >= 0; ze--)
        this.removeListener(ve, Pe[ze]);
    return this;
  };
  function Y(ve, Pe, Ue) {
    var ze = ve._events;
    if (ze === void 0)
      return [];
    var Le = ze[Pe];
    return Le === void 0 ? [] : typeof Le == "function" ? Ue ? [Le.listener || Le] : [Le] : Ue ? fe(Le) : ie(Le, Le.length);
  }
  g.prototype.listeners = function(ve) {
    return Y(this, ve, !0);
  }, g.prototype.rawListeners = function(ve) {
    return Y(this, ve, !1);
  }, g.listenerCount = function(ve, Pe) {
    return typeof ve.listenerCount == "function" ? ve.listenerCount(Pe) : ee.call(ve, Pe);
  }, g.prototype.listenerCount = ee;
  function ee(ve) {
    var Pe = this._events;
    if (Pe !== void 0) {
      var Ue = Pe[ve];
      if (typeof Ue == "function")
        return 1;
      if (Ue !== void 0)
        return Ue.length;
    }
    return 0;
  }
  g.prototype.eventNames = function() {
    return this._eventsCount > 0 ? h(this._events) : [];
  };
  function ie(ve, Pe) {
    for (var Ue = new Array(Pe), ze = 0; ze < Pe; ++ze)
      Ue[ze] = ve[ze];
    return Ue;
  }
  function ue(ve, Pe) {
    for (; Pe + 1 < ve.length; Pe++)
      ve[Pe] = ve[Pe + 1];
    ve.pop();
  }
  function fe(ve) {
    for (var Pe = new Array(ve.length), Ue = 0; Ue < Pe.length; ++Ue)
      Pe[Ue] = ve[Ue].listener || ve[Ue];
    return Pe;
  }
  function de(ve, Pe) {
    return new Promise(function(Ue, ze) {
      function Le($e) {
        ve.removeListener(Pe, Ne), ze($e);
      }
      function Ne() {
        typeof ve.removeListener == "function" && ve.removeListener("error", Le), Ue([].slice.call(arguments));
      }
      be(ve, Pe, Ne, { once: !0 }), Pe !== "error" && ce(ve, Le, { once: !0 });
    });
  }
  function ce(ve, Pe, Ue) {
    typeof ve.on == "function" && be(ve, "error", Pe, Ue);
  }
  function be(ve, Pe, Ue, ze) {
    if (typeof ve.on == "function")
      ze.once ? ve.once(Pe, Ue) : ve.on(Pe, Ue);
    else if (typeof ve.addEventListener == "function")
      ve.addEventListener(Pe, function Le(Ne) {
        ze.once && ve.removeEventListener(Pe, Le), Ue(Ne);
      });
    else
      throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof ve);
  }
  return events.exports;
}
var streamBrowser$1, hasRequiredStreamBrowser$1;
function requireStreamBrowser$1() {
  return hasRequiredStreamBrowser$1 || (hasRequiredStreamBrowser$1 = 1, streamBrowser$1 = requireEvents().EventEmitter), streamBrowser$1;
}
var util$1 = {}, types = {}, shams$1, hasRequiredShams$1;
function requireShams$1() {
  return hasRequiredShams$1 || (hasRequiredShams$1 = 1, shams$1 = function() {
    if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
      return !1;
    if (typeof Symbol.iterator == "symbol")
      return !0;
    var e = {}, t = Symbol("test"), h = Object(t);
    if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(h) !== "[object Symbol]")
      return !1;
    var o = 42;
    e[t] = o;
    for (t in e)
      return !1;
    if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
      return !1;
    var S = Object.getOwnPropertySymbols(e);
    if (S.length !== 1 || S[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t))
      return !1;
    if (typeof Object.getOwnPropertyDescriptor == "function") {
      var g = Object.getOwnPropertyDescriptor(e, t);
      if (g.value !== o || g.enumerable !== !0)
        return !1;
    }
    return !0;
  }), shams$1;
}
var shams, hasRequiredShams;
function requireShams() {
  if (hasRequiredShams)
    return shams;
  hasRequiredShams = 1;
  var e = requireShams$1();
  return shams = function() {
    return e() && !!Symbol.toStringTag;
  }, shams;
}
var esErrors, hasRequiredEsErrors;
function requireEsErrors() {
  return hasRequiredEsErrors || (hasRequiredEsErrors = 1, esErrors = Error), esErrors;
}
var _eval, hasRequired_eval;
function require_eval() {
  return hasRequired_eval || (hasRequired_eval = 1, _eval = EvalError), _eval;
}
var range, hasRequiredRange;
function requireRange() {
  return hasRequiredRange || (hasRequiredRange = 1, range = RangeError), range;
}
var ref, hasRequiredRef;
function requireRef() {
  return hasRequiredRef || (hasRequiredRef = 1, ref = ReferenceError), ref;
}
var syntax, hasRequiredSyntax;
function requireSyntax() {
  return hasRequiredSyntax || (hasRequiredSyntax = 1, syntax = SyntaxError), syntax;
}
var type, hasRequiredType;
function requireType() {
  return hasRequiredType || (hasRequiredType = 1, type = TypeError), type;
}
var uri, hasRequiredUri;
function requireUri() {
  return hasRequiredUri || (hasRequiredUri = 1, uri = URIError), uri;
}
var hasSymbols, hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols)
    return hasSymbols;
  hasRequiredHasSymbols = 1;
  var e = typeof Symbol < "u" && Symbol, t = requireShams$1();
  return hasSymbols = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, hasSymbols;
}
var hasProto, hasRequiredHasProto;
function requireHasProto() {
  if (hasRequiredHasProto)
    return hasProto;
  hasRequiredHasProto = 1;
  var e = {
    __proto__: null,
    foo: {}
  }, t = Object;
  return hasProto = function() {
    return { __proto__: e }.foo === e.foo && !(e instanceof t);
  }, hasProto;
}
var implementation, hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation)
    return implementation;
  hasRequiredImplementation = 1;
  var e = "Function.prototype.bind called on incompatible ", t = Object.prototype.toString, h = Math.max, o = "[object Function]", S = function(M, O) {
    for (var P = [], D = 0; D < M.length; D += 1)
      P[D] = M[D];
    for (var Z = 0; Z < O.length; Z += 1)
      P[Z + M.length] = O[Z];
    return P;
  }, g = function(M, O) {
    for (var P = [], D = O || 0, Z = 0; D < M.length; D += 1, Z += 1)
      P[Z] = M[D];
    return P;
  }, B = function(M, O) {
    for (var P = "", D = 0; D < M.length; D += 1)
      P += M[D], D + 1 < M.length && (P += O);
    return P;
  };
  return implementation = function(M) {
    var O = this;
    if (typeof O != "function" || t.apply(O) !== o)
      throw new TypeError(e + O);
    for (var P = g(arguments, 1), D, Z = function() {
      if (this instanceof D) {
        var fe = O.apply(
          this,
          S(P, arguments)
        );
        return Object(fe) === fe ? fe : this;
      }
      return O.apply(
        M,
        S(P, arguments)
      );
    }, Y = h(0, O.length - P.length), ee = [], ie = 0; ie < Y; ie++)
      ee[ie] = "$" + ie;
    if (D = Function("binder", "return function (" + B(ee, ",") + "){ return binder.apply(this,arguments); }")(Z), O.prototype) {
      var ue = function() {
      };
      ue.prototype = O.prototype, D.prototype = new ue(), ue.prototype = null;
    }
    return D;
  }, implementation;
}
var functionBind, hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind)
    return functionBind;
  hasRequiredFunctionBind = 1;
  var e = requireImplementation();
  return functionBind = Function.prototype.bind || e, functionBind;
}
var hasown, hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown)
    return hasown;
  hasRequiredHasown = 1;
  var e = Function.prototype.call, t = Object.prototype.hasOwnProperty, h = requireFunctionBind();
  return hasown = h.call(e, t), hasown;
}
var getIntrinsic, hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic)
    return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var e, t = requireEsErrors(), h = require_eval(), o = requireRange(), S = requireRef(), g = requireSyntax(), B = requireType(), M = requireUri(), O = Function, P = function(Q) {
    try {
      return O('"use strict"; return (' + Q + ").constructor;")();
    } catch {
    }
  }, D = Object.getOwnPropertyDescriptor;
  if (D)
    try {
      D({}, "");
    } catch {
      D = null;
    }
  var Z = function() {
    throw new B();
  }, Y = D ? function() {
    try {
      return arguments.callee, Z;
    } catch {
      try {
        return D(arguments, "callee").get;
      } catch {
        return Z;
      }
    }
  }() : Z, ee = requireHasSymbols()(), ie = requireHasProto()(), ue = Object.getPrototypeOf || (ie ? function(Q) {
    return Q.__proto__;
  } : null), fe = {}, de = typeof Uint8Array > "u" || !ue ? e : ue(Uint8Array), ce = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? e : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? e : ArrayBuffer,
    "%ArrayIteratorPrototype%": ee && ue ? ue([][Symbol.iterator]()) : e,
    "%AsyncFromSyncIteratorPrototype%": e,
    "%AsyncFunction%": fe,
    "%AsyncGenerator%": fe,
    "%AsyncGeneratorFunction%": fe,
    "%AsyncIteratorPrototype%": fe,
    "%Atomics%": typeof Atomics > "u" ? e : Atomics,
    "%BigInt%": typeof BigInt > "u" ? e : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? e : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? e : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? e : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": t,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": h,
    "%Float32Array%": typeof Float32Array > "u" ? e : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? e : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? e : FinalizationRegistry,
    "%Function%": O,
    "%GeneratorFunction%": fe,
    "%Int8Array%": typeof Int8Array > "u" ? e : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? e : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? e : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": ee && ue ? ue(ue([][Symbol.iterator]())) : e,
    "%JSON%": typeof JSON == "object" ? JSON : e,
    "%Map%": typeof Map > "u" ? e : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !ee || !ue ? e : ue((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? e : Promise,
    "%Proxy%": typeof Proxy > "u" ? e : Proxy,
    "%RangeError%": o,
    "%ReferenceError%": S,
    "%Reflect%": typeof Reflect > "u" ? e : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? e : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !ee || !ue ? e : ue((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? e : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": ee && ue ? ue(""[Symbol.iterator]()) : e,
    "%Symbol%": ee ? Symbol : e,
    "%SyntaxError%": g,
    "%ThrowTypeError%": Y,
    "%TypedArray%": de,
    "%TypeError%": B,
    "%Uint8Array%": typeof Uint8Array > "u" ? e : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? e : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? e : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? e : Uint32Array,
    "%URIError%": M,
    "%WeakMap%": typeof WeakMap > "u" ? e : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? e : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? e : WeakSet
  };
  if (ue)
    try {
      null.error;
    } catch (Q) {
      var be = ue(ue(Q));
      ce["%Error.prototype%"] = be;
    }
  var ve = function Q(F) {
    var $;
    if (F === "%AsyncFunction%")
      $ = P("async function () {}");
    else if (F === "%GeneratorFunction%")
      $ = P("function* () {}");
    else if (F === "%AsyncGeneratorFunction%")
      $ = P("async function* () {}");
    else if (F === "%AsyncGenerator%") {
      var H = Q("%AsyncGeneratorFunction%");
      H && ($ = H.prototype);
    } else if (F === "%AsyncIteratorPrototype%") {
      var q = Q("%AsyncGenerator%");
      q && ue && ($ = ue(q.prototype));
    }
    return ce[F] = $, $;
  }, Pe = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, Ue = requireFunctionBind(), ze = requireHasown(), Le = Ue.call(Function.call, Array.prototype.concat), Ne = Ue.call(Function.apply, Array.prototype.splice), $e = Ue.call(Function.call, String.prototype.replace), J = Ue.call(Function.call, String.prototype.slice), ne = Ue.call(Function.call, RegExp.prototype.exec), A = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, I = /\\(\\)?/g, U = function(Q) {
    var F = J(Q, 0, 1), $ = J(Q, -1);
    if (F === "%" && $ !== "%")
      throw new g("invalid intrinsic syntax, expected closing `%`");
    if ($ === "%" && F !== "%")
      throw new g("invalid intrinsic syntax, expected opening `%`");
    var H = [];
    return $e(Q, A, function(q, z, me, Ce) {
      H[H.length] = me ? $e(Ce, I, "$1") : z || q;
    }), H;
  }, X = function(Q, F) {
    var $ = Q, H;
    if (ze(Pe, $) && (H = Pe[$], $ = "%" + H[0] + "%"), ze(ce, $)) {
      var q = ce[$];
      if (q === fe && (q = ve($)), typeof q > "u" && !F)
        throw new B("intrinsic " + Q + " exists, but is not available. Please file an issue!");
      return {
        alias: H,
        name: $,
        value: q
      };
    }
    throw new g("intrinsic " + Q + " does not exist!");
  };
  return getIntrinsic = function(Q, F) {
    if (typeof Q != "string" || Q.length === 0)
      throw new B("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof F != "boolean")
      throw new B('"allowMissing" argument must be a boolean');
    if (ne(/^%?[^%]*%?$/, Q) === null)
      throw new g("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var $ = U(Q), H = $.length > 0 ? $[0] : "", q = X("%" + H + "%", F), z = q.name, me = q.value, Ce = !1, je = q.alias;
    je && (H = je[0], Ne($, Le([0, 1], je)));
    for (var Re = 1, Ae = !0; Re < $.length; Re += 1) {
      var ke = $[Re], Qe = J(ke, 0, 1), Ze = J(ke, -1);
      if ((Qe === '"' || Qe === "'" || Qe === "`" || Ze === '"' || Ze === "'" || Ze === "`") && Qe !== Ze)
        throw new g("property names with quotes must have matching quotes");
      if ((ke === "constructor" || !Ae) && (Ce = !0), H += "." + ke, z = "%" + H + "%", ze(ce, z))
        me = ce[z];
      else if (me != null) {
        if (!(ke in me)) {
          if (!F)
            throw new B("base intrinsic for " + Q + " exists, but the property is not available.");
          return;
        }
        if (D && Re + 1 >= $.length) {
          var qe = D(me, ke);
          Ae = !!qe, Ae && "get" in qe && !("originalValue" in qe.get) ? me = qe.get : me = me[ke];
        } else
          Ae = ze(me, ke), me = me[ke];
        Ae && !Ce && (ce[z] = me);
      }
    }
    return me;
  }, getIntrinsic;
}
var callBind = { exports: {} }, esDefineProperty, hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty)
    return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var e = requireGetIntrinsic(), t = e("%Object.defineProperty%", !0) || !1;
  if (t)
    try {
      t({}, "a", { value: 1 });
    } catch {
      t = !1;
    }
  return esDefineProperty = t, esDefineProperty;
}
var gopd, hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd)
    return gopd;
  hasRequiredGopd = 1;
  var e = requireGetIntrinsic(), t = e("%Object.getOwnPropertyDescriptor%", !0);
  if (t)
    try {
      t([], "length");
    } catch {
      t = null;
    }
  return gopd = t, gopd;
}
var defineDataProperty, hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty)
    return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var e = requireEsDefineProperty(), t = requireSyntax(), h = requireType(), o = requireGopd();
  return defineDataProperty = function(S, g, B) {
    if (!S || typeof S != "object" && typeof S != "function")
      throw new h("`obj` must be an object or a function`");
    if (typeof g != "string" && typeof g != "symbol")
      throw new h("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
      throw new h("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
      throw new h("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
      throw new h("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
      throw new h("`loose`, if provided, must be a boolean");
    var M = arguments.length > 3 ? arguments[3] : null, O = arguments.length > 4 ? arguments[4] : null, P = arguments.length > 5 ? arguments[5] : null, D = arguments.length > 6 ? arguments[6] : !1, Z = !!o && o(S, g);
    if (e)
      e(S, g, {
        configurable: P === null && Z ? Z.configurable : !P,
        enumerable: M === null && Z ? Z.enumerable : !M,
        value: B,
        writable: O === null && Z ? Z.writable : !O
      });
    else if (D || !M && !O && !P)
      S[g] = B;
    else
      throw new t("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
  }, defineDataProperty;
}
var hasPropertyDescriptors_1, hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors)
    return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var e = requireEsDefineProperty(), t = function() {
    return !!e;
  };
  return t.hasArrayLengthDefineBug = function() {
    if (!e)
      return null;
    try {
      return e([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, hasPropertyDescriptors_1 = t, hasPropertyDescriptors_1;
}
var setFunctionLength, hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength)
    return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var e = requireGetIntrinsic(), t = requireDefineDataProperty(), h = requireHasPropertyDescriptors()(), o = requireGopd(), S = requireType(), g = e("%Math.floor%");
  return setFunctionLength = function(B, M) {
    if (typeof B != "function")
      throw new S("`fn` is not a function");
    if (typeof M != "number" || M < 0 || M > 4294967295 || g(M) !== M)
      throw new S("`length` must be a positive 32-bit integer");
    var O = arguments.length > 2 && !!arguments[2], P = !0, D = !0;
    if ("length" in B && o) {
      var Z = o(B, "length");
      Z && !Z.configurable && (P = !1), Z && !Z.writable && (D = !1);
    }
    return (P || D || !O) && (h ? t(
      /** @type {Parameters<define>[0]} */
      B,
      "length",
      M,
      !0,
      !0
    ) : t(
      /** @type {Parameters<define>[0]} */
      B,
      "length",
      M
    )), B;
  }, setFunctionLength;
}
var hasRequiredCallBind;
function requireCallBind() {
  return hasRequiredCallBind || (hasRequiredCallBind = 1, function(e) {
    var t = requireFunctionBind(), h = requireGetIntrinsic(), o = requireSetFunctionLength(), S = requireType(), g = h("%Function.prototype.apply%"), B = h("%Function.prototype.call%"), M = h("%Reflect.apply%", !0) || t.call(B, g), O = requireEsDefineProperty(), P = h("%Math.max%");
    e.exports = function(Z) {
      if (typeof Z != "function")
        throw new S("a function is required");
      var Y = M(t, B, arguments);
      return o(
        Y,
        1 + P(0, Z.length - (arguments.length - 1)),
        !0
      );
    };
    var D = function() {
      return M(t, g, arguments);
    };
    O ? O(e.exports, "apply", { value: D }) : e.exports.apply = D;
  }(callBind)), callBind.exports;
}
var callBound, hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound)
    return callBound;
  hasRequiredCallBound = 1;
  var e = requireGetIntrinsic(), t = requireCallBind(), h = t(e("String.prototype.indexOf"));
  return callBound = function(o, S) {
    var g = e(o, !!S);
    return typeof g == "function" && h(o, ".prototype.") > -1 ? t(g) : g;
  }, callBound;
}
var isArguments, hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments)
    return isArguments;
  hasRequiredIsArguments = 1;
  var e = requireShams()(), t = requireCallBound(), h = t("Object.prototype.toString"), o = function(B) {
    return e && B && typeof B == "object" && Symbol.toStringTag in B ? !1 : h(B) === "[object Arguments]";
  }, S = function(B) {
    return o(B) ? !0 : B !== null && typeof B == "object" && typeof B.length == "number" && B.length >= 0 && h(B) !== "[object Array]" && h(B.callee) === "[object Function]";
  }, g = function() {
    return o(arguments);
  }();
  return o.isLegacyArguments = S, isArguments = g ? o : S, isArguments;
}
var isGeneratorFunction, hasRequiredIsGeneratorFunction;
function requireIsGeneratorFunction() {
  if (hasRequiredIsGeneratorFunction)
    return isGeneratorFunction;
  hasRequiredIsGeneratorFunction = 1;
  var e = Object.prototype.toString, t = Function.prototype.toString, h = /^\s*(?:function)?\*/, o = requireShams()(), S = Object.getPrototypeOf, g = function() {
    if (!o)
      return !1;
    try {
      return Function("return function*() {}")();
    } catch {
    }
  }, B;
  return isGeneratorFunction = function(M) {
    if (typeof M != "function")
      return !1;
    if (h.test(t.call(M)))
      return !0;
    if (!o) {
      var O = e.call(M);
      return O === "[object GeneratorFunction]";
    }
    if (!S)
      return !1;
    if (typeof B > "u") {
      var P = g();
      B = P ? S(P) : !1;
    }
    return S(M) === B;
  }, isGeneratorFunction;
}
var isCallable, hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable)
    return isCallable;
  hasRequiredIsCallable = 1;
  var e = Function.prototype.toString, t = typeof Reflect == "object" && Reflect !== null && Reflect.apply, h, o;
  if (typeof t == "function" && typeof Object.defineProperty == "function")
    try {
      h = Object.defineProperty({}, "length", {
        get: function() {
          throw o;
        }
      }), o = {}, t(function() {
        throw 42;
      }, null, h);
    } catch (ce) {
      ce !== o && (t = null);
    }
  else
    t = null;
  var S = /^\s*class\b/, g = function(ce) {
    try {
      var be = e.call(ce);
      return S.test(be);
    } catch {
      return !1;
    }
  }, B = function(ce) {
    try {
      return g(ce) ? !1 : (e.call(ce), !0);
    } catch {
      return !1;
    }
  }, M = Object.prototype.toString, O = "[object Object]", P = "[object Function]", D = "[object GeneratorFunction]", Z = "[object HTMLAllCollection]", Y = "[object HTML document.all class]", ee = "[object HTMLCollection]", ie = typeof Symbol == "function" && !!Symbol.toStringTag, ue = !(0 in [,]), fe = function() {
    return !1;
  };
  if (typeof document == "object") {
    var de = document.all;
    M.call(de) === M.call(document.all) && (fe = function(ce) {
      if ((ue || !ce) && (typeof ce > "u" || typeof ce == "object"))
        try {
          var be = M.call(ce);
          return (be === Z || be === Y || be === ee || be === O) && ce("") == null;
        } catch {
        }
      return !1;
    });
  }
  return isCallable = t ? function(ce) {
    if (fe(ce))
      return !0;
    if (!ce || typeof ce != "function" && typeof ce != "object")
      return !1;
    try {
      t(ce, null, h);
    } catch (be) {
      if (be !== o)
        return !1;
    }
    return !g(ce) && B(ce);
  } : function(ce) {
    if (fe(ce))
      return !0;
    if (!ce || typeof ce != "function" && typeof ce != "object")
      return !1;
    if (ie)
      return B(ce);
    if (g(ce))
      return !1;
    var be = M.call(ce);
    return be !== P && be !== D && !/^\[object HTML/.test(be) ? !1 : B(ce);
  }, isCallable;
}
var forEach_1, hasRequiredForEach;
function requireForEach() {
  if (hasRequiredForEach)
    return forEach_1;
  hasRequiredForEach = 1;
  var e = requireIsCallable(), t = Object.prototype.toString, h = Object.prototype.hasOwnProperty, o = function(M, O, P) {
    for (var D = 0, Z = M.length; D < Z; D++)
      h.call(M, D) && (P == null ? O(M[D], D, M) : O.call(P, M[D], D, M));
  }, S = function(M, O, P) {
    for (var D = 0, Z = M.length; D < Z; D++)
      P == null ? O(M.charAt(D), D, M) : O.call(P, M.charAt(D), D, M);
  }, g = function(M, O, P) {
    for (var D in M)
      h.call(M, D) && (P == null ? O(M[D], D, M) : O.call(P, M[D], D, M));
  }, B = function(M, O, P) {
    if (!e(O))
      throw new TypeError("iterator must be a function");
    var D;
    arguments.length >= 3 && (D = P), t.call(M) === "[object Array]" ? o(M, O, D) : typeof M == "string" ? S(M, O, D) : g(M, O, D);
  };
  return forEach_1 = B, forEach_1;
}
var possibleTypedArrayNames, hasRequiredPossibleTypedArrayNames;
function requirePossibleTypedArrayNames() {
  return hasRequiredPossibleTypedArrayNames || (hasRequiredPossibleTypedArrayNames = 1, possibleTypedArrayNames = [
    "Float32Array",
    "Float64Array",
    "Int8Array",
    "Int16Array",
    "Int32Array",
    "Uint8Array",
    "Uint8ClampedArray",
    "Uint16Array",
    "Uint32Array",
    "BigInt64Array",
    "BigUint64Array"
  ]), possibleTypedArrayNames;
}
var availableTypedArrays, hasRequiredAvailableTypedArrays;
function requireAvailableTypedArrays() {
  if (hasRequiredAvailableTypedArrays)
    return availableTypedArrays;
  hasRequiredAvailableTypedArrays = 1;
  var e = requirePossibleTypedArrayNames(), t = typeof globalThis > "u" ? commonjsGlobal : globalThis;
  return availableTypedArrays = function() {
    for (var h = [], o = 0; o < e.length; o++)
      typeof t[e[o]] == "function" && (h[h.length] = e[o]);
    return h;
  }, availableTypedArrays;
}
var whichTypedArray, hasRequiredWhichTypedArray;
function requireWhichTypedArray() {
  if (hasRequiredWhichTypedArray)
    return whichTypedArray;
  hasRequiredWhichTypedArray = 1;
  var e = requireForEach(), t = requireAvailableTypedArrays(), h = requireCallBind(), o = requireCallBound(), S = requireGopd(), g = o("Object.prototype.toString"), B = requireShams()(), M = typeof globalThis > "u" ? commonjsGlobal : globalThis, O = t(), P = o("String.prototype.slice"), D = Object.getPrototypeOf, Z = o("Array.prototype.indexOf", !0) || function(ue, fe) {
    for (var de = 0; de < ue.length; de += 1)
      if (ue[de] === fe)
        return de;
    return -1;
  }, Y = { __proto__: null };
  B && S && D ? e(O, function(ue) {
    var fe = new M[ue]();
    if (Symbol.toStringTag in fe) {
      var de = D(fe), ce = S(de, Symbol.toStringTag);
      if (!ce) {
        var be = D(de);
        ce = S(be, Symbol.toStringTag);
      }
      Y["$" + ue] = h(ce.get);
    }
  }) : e(O, function(ue) {
    var fe = new M[ue](), de = fe.slice || fe.set;
    de && (Y["$" + ue] = h(de));
  });
  var ee = function(ue) {
    var fe = !1;
    return e(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      Y,
      /** @type {(getter: Getter, name: `\$${import('.').TypedArrayName}`) => void} */
      function(de, ce) {
        if (!fe)
          try {
            "$" + de(ue) === ce && (fe = P(ce, 1));
          } catch {
          }
      }
    ), fe;
  }, ie = function(ue) {
    var fe = !1;
    return e(
      // eslint-disable-next-line no-extra-parens
      /** @type {Record<`\$${TypedArrayName}`, Getter>} */
      /** @type {any} */
      Y,
      /** @type {(getter: typeof cache, name: `\$${import('.').TypedArrayName}`) => void} */
      function(de, ce) {
        if (!fe)
          try {
            de(ue), fe = P(ce, 1);
          } catch {
          }
      }
    ), fe;
  };
  return whichTypedArray = function(ue) {
    if (!ue || typeof ue != "object")
      return !1;
    if (!B) {
      var fe = P(g(ue), 8, -1);
      return Z(O, fe) > -1 ? fe : fe !== "Object" ? !1 : ie(ue);
    }
    return S ? ee(ue) : null;
  }, whichTypedArray;
}
var isTypedArray, hasRequiredIsTypedArray;
function requireIsTypedArray() {
  if (hasRequiredIsTypedArray)
    return isTypedArray;
  hasRequiredIsTypedArray = 1;
  var e = requireWhichTypedArray();
  return isTypedArray = function(t) {
    return !!e(t);
  }, isTypedArray;
}
var hasRequiredTypes;
function requireTypes() {
  return hasRequiredTypes || (hasRequiredTypes = 1, function(e) {
    var t = requireIsArguments(), h = requireIsGeneratorFunction(), o = requireWhichTypedArray(), S = requireIsTypedArray();
    function g(ge) {
      return ge.call.bind(ge);
    }
    var B = typeof BigInt < "u", M = typeof Symbol < "u", O = g(Object.prototype.toString), P = g(Number.prototype.valueOf), D = g(String.prototype.valueOf), Z = g(Boolean.prototype.valueOf);
    if (B)
      var Y = g(BigInt.prototype.valueOf);
    if (M)
      var ee = g(Symbol.prototype.valueOf);
    function ie(ge, Ke) {
      if (typeof ge != "object")
        return !1;
      try {
        return Ke(ge), !0;
      } catch {
        return !1;
      }
    }
    e.isArgumentsObject = t, e.isGeneratorFunction = h, e.isTypedArray = S;
    function ue(ge) {
      return typeof Promise < "u" && ge instanceof Promise || ge !== null && typeof ge == "object" && typeof ge.then == "function" && typeof ge.catch == "function";
    }
    e.isPromise = ue;
    function fe(ge) {
      return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(ge) : S(ge) || me(ge);
    }
    e.isArrayBufferView = fe;
    function de(ge) {
      return o(ge) === "Uint8Array";
    }
    e.isUint8Array = de;
    function ce(ge) {
      return o(ge) === "Uint8ClampedArray";
    }
    e.isUint8ClampedArray = ce;
    function be(ge) {
      return o(ge) === "Uint16Array";
    }
    e.isUint16Array = be;
    function ve(ge) {
      return o(ge) === "Uint32Array";
    }
    e.isUint32Array = ve;
    function Pe(ge) {
      return o(ge) === "Int8Array";
    }
    e.isInt8Array = Pe;
    function Ue(ge) {
      return o(ge) === "Int16Array";
    }
    e.isInt16Array = Ue;
    function ze(ge) {
      return o(ge) === "Int32Array";
    }
    e.isInt32Array = ze;
    function Le(ge) {
      return o(ge) === "Float32Array";
    }
    e.isFloat32Array = Le;
    function Ne(ge) {
      return o(ge) === "Float64Array";
    }
    e.isFloat64Array = Ne;
    function $e(ge) {
      return o(ge) === "BigInt64Array";
    }
    e.isBigInt64Array = $e;
    function J(ge) {
      return o(ge) === "BigUint64Array";
    }
    e.isBigUint64Array = J;
    function ne(ge) {
      return O(ge) === "[object Map]";
    }
    ne.working = typeof Map < "u" && ne(/* @__PURE__ */ new Map());
    function A(ge) {
      return typeof Map > "u" ? !1 : ne.working ? ne(ge) : ge instanceof Map;
    }
    e.isMap = A;
    function I(ge) {
      return O(ge) === "[object Set]";
    }
    I.working = typeof Set < "u" && I(/* @__PURE__ */ new Set());
    function U(ge) {
      return typeof Set > "u" ? !1 : I.working ? I(ge) : ge instanceof Set;
    }
    e.isSet = U;
    function X(ge) {
      return O(ge) === "[object WeakMap]";
    }
    X.working = typeof WeakMap < "u" && X(/* @__PURE__ */ new WeakMap());
    function Q(ge) {
      return typeof WeakMap > "u" ? !1 : X.working ? X(ge) : ge instanceof WeakMap;
    }
    e.isWeakMap = Q;
    function F(ge) {
      return O(ge) === "[object WeakSet]";
    }
    F.working = typeof WeakSet < "u" && F(/* @__PURE__ */ new WeakSet());
    function $(ge) {
      return F(ge);
    }
    e.isWeakSet = $;
    function H(ge) {
      return O(ge) === "[object ArrayBuffer]";
    }
    H.working = typeof ArrayBuffer < "u" && H(new ArrayBuffer());
    function q(ge) {
      return typeof ArrayBuffer > "u" ? !1 : H.working ? H(ge) : ge instanceof ArrayBuffer;
    }
    e.isArrayBuffer = q;
    function z(ge) {
      return O(ge) === "[object DataView]";
    }
    z.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && z(new DataView(new ArrayBuffer(1), 0, 1));
    function me(ge) {
      return typeof DataView > "u" ? !1 : z.working ? z(ge) : ge instanceof DataView;
    }
    e.isDataView = me;
    var Ce = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
    function je(ge) {
      return O(ge) === "[object SharedArrayBuffer]";
    }
    function Re(ge) {
      return typeof Ce > "u" ? !1 : (typeof je.working > "u" && (je.working = je(new Ce())), je.working ? je(ge) : ge instanceof Ce);
    }
    e.isSharedArrayBuffer = Re;
    function Ae(ge) {
      return O(ge) === "[object AsyncFunction]";
    }
    e.isAsyncFunction = Ae;
    function ke(ge) {
      return O(ge) === "[object Map Iterator]";
    }
    e.isMapIterator = ke;
    function Qe(ge) {
      return O(ge) === "[object Set Iterator]";
    }
    e.isSetIterator = Qe;
    function Ze(ge) {
      return O(ge) === "[object Generator]";
    }
    e.isGeneratorObject = Ze;
    function qe(ge) {
      return O(ge) === "[object WebAssembly.Module]";
    }
    e.isWebAssemblyCompiledModule = qe;
    function Oe(ge) {
      return ie(ge, P);
    }
    e.isNumberObject = Oe;
    function Xe(ge) {
      return ie(ge, D);
    }
    e.isStringObject = Xe;
    function et(ge) {
      return ie(ge, Z);
    }
    e.isBooleanObject = et;
    function nt(ge) {
      return B && ie(ge, Y);
    }
    e.isBigIntObject = nt;
    function re(ge) {
      return M && ie(ge, ee);
    }
    e.isSymbolObject = re;
    function oe(ge) {
      return Oe(ge) || Xe(ge) || et(ge) || nt(ge) || re(ge);
    }
    e.isBoxedPrimitive = oe;
    function le(ge) {
      return typeof Uint8Array < "u" && (q(ge) || Re(ge));
    }
    e.isAnyArrayBuffer = le, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(ge) {
      Object.defineProperty(e, ge, {
        enumerable: !1,
        value: function() {
          throw new Error(ge + " is not supported in userland");
        }
      });
    });
  }(types)), types;
}
var isBufferBrowser, hasRequiredIsBufferBrowser;
function requireIsBufferBrowser() {
  return hasRequiredIsBufferBrowser || (hasRequiredIsBufferBrowser = 1, isBufferBrowser = function(e) {
    return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
  }), isBufferBrowser;
}
var hasRequiredUtil$1;
function requireUtil$1() {
  return hasRequiredUtil$1 || (hasRequiredUtil$1 = 1, function(e) {
    var t = Object.getOwnPropertyDescriptors || function(z) {
      for (var me = Object.keys(z), Ce = {}, je = 0; je < me.length; je++)
        Ce[me[je]] = Object.getOwnPropertyDescriptor(z, me[je]);
      return Ce;
    }, h = /%[sdj%]/g;
    e.format = function(z) {
      if (!Pe(z)) {
        for (var me = [], Ce = 0; Ce < arguments.length; Ce++)
          me.push(B(arguments[Ce]));
        return me.join(" ");
      }
      for (var Ce = 1, je = arguments, Re = je.length, Ae = String(z).replace(h, function(Ze) {
        if (Ze === "%%")
          return "%";
        if (Ce >= Re)
          return Ze;
        switch (Ze) {
          case "%s":
            return String(je[Ce++]);
          case "%d":
            return Number(je[Ce++]);
          case "%j":
            try {
              return JSON.stringify(je[Ce++]);
            } catch {
              return "[Circular]";
            }
          default:
            return Ze;
        }
      }), ke = je[Ce]; Ce < Re; ke = je[++Ce])
        ce(ke) || !Ne(ke) ? Ae += " " + ke : Ae += " " + B(ke);
      return Ae;
    }, e.deprecate = function(z, me) {
      if (typeof process$1 < "u" && process$1.noDeprecation === !0)
        return z;
      if (typeof process$1 > "u")
        return function() {
          return e.deprecate(z, me).apply(this, arguments);
        };
      var Ce = !1;
      function je() {
        if (!Ce) {
          if (process$1.throwDeprecation)
            throw new Error(me);
          process$1.traceDeprecation ? console.trace(me) : console.error(me), Ce = !0;
        }
        return z.apply(this, arguments);
      }
      return je;
    };
    var o = {}, S = /^$/;
    if (process$1.env.NODE_DEBUG) {
      var g = process$1.env.NODE_DEBUG;
      g = g.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), S = new RegExp("^" + g + "$", "i");
    }
    e.debuglog = function(z) {
      if (z = z.toUpperCase(), !o[z])
        if (S.test(z)) {
          var me = process$1.pid;
          o[z] = function() {
            var Ce = e.format.apply(e, arguments);
            console.error("%s %d: %s", z, me, Ce);
          };
        } else
          o[z] = function() {
          };
      return o[z];
    };
    function B(z, me) {
      var Ce = {
        seen: [],
        stylize: O
      };
      return arguments.length >= 3 && (Ce.depth = arguments[2]), arguments.length >= 4 && (Ce.colors = arguments[3]), de(me) ? Ce.showHidden = me : me && e._extend(Ce, me), ze(Ce.showHidden) && (Ce.showHidden = !1), ze(Ce.depth) && (Ce.depth = 2), ze(Ce.colors) && (Ce.colors = !1), ze(Ce.customInspect) && (Ce.customInspect = !0), Ce.colors && (Ce.stylize = M), D(Ce, z, Ce.depth);
    }
    e.inspect = B, B.colors = {
      bold: [1, 22],
      italic: [3, 23],
      underline: [4, 24],
      inverse: [7, 27],
      white: [37, 39],
      grey: [90, 39],
      black: [30, 39],
      blue: [34, 39],
      cyan: [36, 39],
      green: [32, 39],
      magenta: [35, 39],
      red: [31, 39],
      yellow: [33, 39]
    }, B.styles = {
      special: "cyan",
      number: "yellow",
      boolean: "yellow",
      undefined: "grey",
      null: "bold",
      string: "green",
      date: "magenta",
      // "name": intentionally not styling
      regexp: "red"
    };
    function M(z, me) {
      var Ce = B.styles[me];
      return Ce ? "\x1B[" + B.colors[Ce][0] + "m" + z + "\x1B[" + B.colors[Ce][1] + "m" : z;
    }
    function O(z, me) {
      return z;
    }
    function P(z) {
      var me = {};
      return z.forEach(function(Ce, je) {
        me[Ce] = !0;
      }), me;
    }
    function D(z, me, Ce) {
      if (z.customInspect && me && ne(me.inspect) && // Filter out the util module, it's inspect function is special
      me.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
      !(me.constructor && me.constructor.prototype === me)) {
        var je = me.inspect(Ce, z);
        return Pe(je) || (je = D(z, je, Ce)), je;
      }
      var Re = Z(z, me);
      if (Re)
        return Re;
      var Ae = Object.keys(me), ke = P(Ae);
      if (z.showHidden && (Ae = Object.getOwnPropertyNames(me)), J(me) && (Ae.indexOf("message") >= 0 || Ae.indexOf("description") >= 0))
        return Y(me);
      if (Ae.length === 0) {
        if (ne(me)) {
          var Qe = me.name ? ": " + me.name : "";
          return z.stylize("[Function" + Qe + "]", "special");
        }
        if (Le(me))
          return z.stylize(RegExp.prototype.toString.call(me), "regexp");
        if ($e(me))
          return z.stylize(Date.prototype.toString.call(me), "date");
        if (J(me))
          return Y(me);
      }
      var Ze = "", qe = !1, Oe = ["{", "}"];
      if (fe(me) && (qe = !0, Oe = ["[", "]"]), ne(me)) {
        var Xe = me.name ? ": " + me.name : "";
        Ze = " [Function" + Xe + "]";
      }
      if (Le(me) && (Ze = " " + RegExp.prototype.toString.call(me)), $e(me) && (Ze = " " + Date.prototype.toUTCString.call(me)), J(me) && (Ze = " " + Y(me)), Ae.length === 0 && (!qe || me.length == 0))
        return Oe[0] + Ze + Oe[1];
      if (Ce < 0)
        return Le(me) ? z.stylize(RegExp.prototype.toString.call(me), "regexp") : z.stylize("[Object]", "special");
      z.seen.push(me);
      var et;
      return qe ? et = ee(z, me, Ce, ke, Ae) : et = Ae.map(function(nt) {
        return ie(z, me, Ce, ke, nt, qe);
      }), z.seen.pop(), ue(et, Ze, Oe);
    }
    function Z(z, me) {
      if (ze(me))
        return z.stylize("undefined", "undefined");
      if (Pe(me)) {
        var Ce = "'" + JSON.stringify(me).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
        return z.stylize(Ce, "string");
      }
      if (ve(me))
        return z.stylize("" + me, "number");
      if (de(me))
        return z.stylize("" + me, "boolean");
      if (ce(me))
        return z.stylize("null", "null");
    }
    function Y(z) {
      return "[" + Error.prototype.toString.call(z) + "]";
    }
    function ee(z, me, Ce, je, Re) {
      for (var Ae = [], ke = 0, Qe = me.length; ke < Qe; ++ke)
        F(me, String(ke)) ? Ae.push(ie(
          z,
          me,
          Ce,
          je,
          String(ke),
          !0
        )) : Ae.push("");
      return Re.forEach(function(Ze) {
        Ze.match(/^\d+$/) || Ae.push(ie(
          z,
          me,
          Ce,
          je,
          Ze,
          !0
        ));
      }), Ae;
    }
    function ie(z, me, Ce, je, Re, Ae) {
      var ke, Qe, Ze;
      if (Ze = Object.getOwnPropertyDescriptor(me, Re) || { value: me[Re] }, Ze.get ? Ze.set ? Qe = z.stylize("[Getter/Setter]", "special") : Qe = z.stylize("[Getter]", "special") : Ze.set && (Qe = z.stylize("[Setter]", "special")), F(je, Re) || (ke = "[" + Re + "]"), Qe || (z.seen.indexOf(Ze.value) < 0 ? (ce(Ce) ? Qe = D(z, Ze.value, null) : Qe = D(z, Ze.value, Ce - 1), Qe.indexOf(`
`) > -1 && (Ae ? Qe = Qe.split(`
`).map(function(qe) {
        return "  " + qe;
      }).join(`
`).slice(2) : Qe = `
` + Qe.split(`
`).map(function(qe) {
        return "   " + qe;
      }).join(`
`))) : Qe = z.stylize("[Circular]", "special")), ze(ke)) {
        if (Ae && Re.match(/^\d+$/))
          return Qe;
        ke = JSON.stringify("" + Re), ke.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (ke = ke.slice(1, -1), ke = z.stylize(ke, "name")) : (ke = ke.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), ke = z.stylize(ke, "string"));
      }
      return ke + ": " + Qe;
    }
    function ue(z, me, Ce) {
      var je = z.reduce(function(Re, Ae) {
        return Ae.indexOf(`
`) >= 0, Re + Ae.replace(/\u001b\[\d\d?m/g, "").length + 1;
      }, 0);
      return je > 60 ? Ce[0] + (me === "" ? "" : me + `
 `) + " " + z.join(`,
  `) + " " + Ce[1] : Ce[0] + me + " " + z.join(", ") + " " + Ce[1];
    }
    e.types = requireTypes();
    function fe(z) {
      return Array.isArray(z);
    }
    e.isArray = fe;
    function de(z) {
      return typeof z == "boolean";
    }
    e.isBoolean = de;
    function ce(z) {
      return z === null;
    }
    e.isNull = ce;
    function be(z) {
      return z == null;
    }
    e.isNullOrUndefined = be;
    function ve(z) {
      return typeof z == "number";
    }
    e.isNumber = ve;
    function Pe(z) {
      return typeof z == "string";
    }
    e.isString = Pe;
    function Ue(z) {
      return typeof z == "symbol";
    }
    e.isSymbol = Ue;
    function ze(z) {
      return z === void 0;
    }
    e.isUndefined = ze;
    function Le(z) {
      return Ne(z) && I(z) === "[object RegExp]";
    }
    e.isRegExp = Le, e.types.isRegExp = Le;
    function Ne(z) {
      return typeof z == "object" && z !== null;
    }
    e.isObject = Ne;
    function $e(z) {
      return Ne(z) && I(z) === "[object Date]";
    }
    e.isDate = $e, e.types.isDate = $e;
    function J(z) {
      return Ne(z) && (I(z) === "[object Error]" || z instanceof Error);
    }
    e.isError = J, e.types.isNativeError = J;
    function ne(z) {
      return typeof z == "function";
    }
    e.isFunction = ne;
    function A(z) {
      return z === null || typeof z == "boolean" || typeof z == "number" || typeof z == "string" || typeof z == "symbol" || // ES6 symbol
      typeof z > "u";
    }
    e.isPrimitive = A, e.isBuffer = requireIsBufferBrowser();
    function I(z) {
      return Object.prototype.toString.call(z);
    }
    function U(z) {
      return z < 10 ? "0" + z.toString(10) : z.toString(10);
    }
    var X = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    function Q() {
      var z = /* @__PURE__ */ new Date(), me = [
        U(z.getHours()),
        U(z.getMinutes()),
        U(z.getSeconds())
      ].join(":");
      return [z.getDate(), X[z.getMonth()], me].join(" ");
    }
    e.log = function() {
      console.log("%s - %s", Q(), e.format.apply(e, arguments));
    }, e.inherits = requireInherits_browser(), e._extend = function(z, me) {
      if (!me || !Ne(me))
        return z;
      for (var Ce = Object.keys(me), je = Ce.length; je--; )
        z[Ce[je]] = me[Ce[je]];
      return z;
    };
    function F(z, me) {
      return Object.prototype.hasOwnProperty.call(z, me);
    }
    var $ = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
    e.promisify = function(z) {
      if (typeof z != "function")
        throw new TypeError('The "original" argument must be of type Function');
      if ($ && z[$]) {
        var me = z[$];
        if (typeof me != "function")
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        return Object.defineProperty(me, $, {
          value: me,
          enumerable: !1,
          writable: !1,
          configurable: !0
        }), me;
      }
      function me() {
        for (var Ce, je, Re = new Promise(function(Qe, Ze) {
          Ce = Qe, je = Ze;
        }), Ae = [], ke = 0; ke < arguments.length; ke++)
          Ae.push(arguments[ke]);
        Ae.push(function(Qe, Ze) {
          Qe ? je(Qe) : Ce(Ze);
        });
        try {
          z.apply(this, Ae);
        } catch (Qe) {
          je(Qe);
        }
        return Re;
      }
      return Object.setPrototypeOf(me, Object.getPrototypeOf(z)), $ && Object.defineProperty(me, $, {
        value: me,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), Object.defineProperties(
        me,
        t(z)
      );
    }, e.promisify.custom = $;
    function H(z, me) {
      if (!z) {
        var Ce = new Error("Promise was rejected with a falsy value");
        Ce.reason = z, z = Ce;
      }
      return me(z);
    }
    function q(z) {
      if (typeof z != "function")
        throw new TypeError('The "original" argument must be of type Function');
      function me() {
        for (var Ce = [], je = 0; je < arguments.length; je++)
          Ce.push(arguments[je]);
        var Re = Ce.pop();
        if (typeof Re != "function")
          throw new TypeError("The last argument must be of type Function");
        var Ae = this, ke = function() {
          return Re.apply(Ae, arguments);
        };
        z.apply(this, Ce).then(
          function(Qe) {
            process$1.nextTick(ke.bind(null, null, Qe));
          },
          function(Qe) {
            process$1.nextTick(H.bind(null, Qe, ke));
          }
        );
      }
      return Object.setPrototypeOf(me, Object.getPrototypeOf(z)), Object.defineProperties(
        me,
        t(z)
      ), me;
    }
    e.callbackify = q;
  }(util$1)), util$1;
}
var buffer_list, hasRequiredBuffer_list;
function requireBuffer_list() {
  if (hasRequiredBuffer_list)
    return buffer_list;
  hasRequiredBuffer_list = 1;
  function e(ie, ue) {
    var fe = Object.keys(ie);
    if (Object.getOwnPropertySymbols) {
      var de = Object.getOwnPropertySymbols(ie);
      ue && (de = de.filter(function(ce) {
        return Object.getOwnPropertyDescriptor(ie, ce).enumerable;
      })), fe.push.apply(fe, de);
    }
    return fe;
  }
  function t(ie) {
    for (var ue = 1; ue < arguments.length; ue++) {
      var fe = arguments[ue] != null ? arguments[ue] : {};
      ue % 2 ? e(Object(fe), !0).forEach(function(de) {
        h(ie, de, fe[de]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(ie, Object.getOwnPropertyDescriptors(fe)) : e(Object(fe)).forEach(function(de) {
        Object.defineProperty(ie, de, Object.getOwnPropertyDescriptor(fe, de));
      });
    }
    return ie;
  }
  function h(ie, ue, fe) {
    return ue = B(ue), ue in ie ? Object.defineProperty(ie, ue, { value: fe, enumerable: !0, configurable: !0, writable: !0 }) : ie[ue] = fe, ie;
  }
  function o(ie, ue) {
    if (!(ie instanceof ue))
      throw new TypeError("Cannot call a class as a function");
  }
  function S(ie, ue) {
    for (var fe = 0; fe < ue.length; fe++) {
      var de = ue[fe];
      de.enumerable = de.enumerable || !1, de.configurable = !0, "value" in de && (de.writable = !0), Object.defineProperty(ie, B(de.key), de);
    }
  }
  function g(ie, ue, fe) {
    return ue && S(ie.prototype, ue), fe && S(ie, fe), Object.defineProperty(ie, "prototype", { writable: !1 }), ie;
  }
  function B(ie) {
    var ue = M(ie, "string");
    return typeof ue == "symbol" ? ue : String(ue);
  }
  function M(ie, ue) {
    if (typeof ie != "object" || ie === null)
      return ie;
    var fe = ie[Symbol.toPrimitive];
    if (fe !== void 0) {
      var de = fe.call(ie, ue || "default");
      if (typeof de != "object")
        return de;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (ue === "string" ? String : Number)(ie);
  }
  var O = requireBuffer$1(), P = O.Buffer, D = requireUtil$1(), Z = D.inspect, Y = Z && Z.custom || "inspect";
  function ee(ie, ue, fe) {
    P.prototype.copy.call(ie, ue, fe);
  }
  return buffer_list = /* @__PURE__ */ function() {
    function ie() {
      o(this, ie), this.head = null, this.tail = null, this.length = 0;
    }
    return g(ie, [{
      key: "push",
      value: function(ue) {
        var fe = {
          data: ue,
          next: null
        };
        this.length > 0 ? this.tail.next = fe : this.head = fe, this.tail = fe, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(ue) {
        var fe = {
          data: ue,
          next: this.head
        };
        this.length === 0 && (this.tail = fe), this.head = fe, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var ue = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ue;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(ue) {
        if (this.length === 0)
          return "";
        for (var fe = this.head, de = "" + fe.data; fe = fe.next; )
          de += ue + fe.data;
        return de;
      }
    }, {
      key: "concat",
      value: function(ue) {
        if (this.length === 0)
          return P.alloc(0);
        for (var fe = P.allocUnsafe(ue >>> 0), de = this.head, ce = 0; de; )
          ee(de.data, fe, ce), ce += de.data.length, de = de.next;
        return fe;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(ue, fe) {
        var de;
        return ue < this.head.data.length ? (de = this.head.data.slice(0, ue), this.head.data = this.head.data.slice(ue)) : ue === this.head.data.length ? de = this.shift() : de = fe ? this._getString(ue) : this._getBuffer(ue), de;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(ue) {
        var fe = this.head, de = 1, ce = fe.data;
        for (ue -= ce.length; fe = fe.next; ) {
          var be = fe.data, ve = ue > be.length ? be.length : ue;
          if (ve === be.length ? ce += be : ce += be.slice(0, ue), ue -= ve, ue === 0) {
            ve === be.length ? (++de, fe.next ? this.head = fe.next : this.head = this.tail = null) : (this.head = fe, fe.data = be.slice(ve));
            break;
          }
          ++de;
        }
        return this.length -= de, ce;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(ue) {
        var fe = P.allocUnsafe(ue), de = this.head, ce = 1;
        for (de.data.copy(fe), ue -= de.data.length; de = de.next; ) {
          var be = de.data, ve = ue > be.length ? be.length : ue;
          if (be.copy(fe, fe.length - ue, 0, ve), ue -= ve, ue === 0) {
            ve === be.length ? (++ce, de.next ? this.head = de.next : this.head = this.tail = null) : (this.head = de, de.data = be.slice(ve));
            break;
          }
          ++ce;
        }
        return this.length -= ce, fe;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: Y,
      value: function(ue, fe) {
        return Z(this, t(t({}, fe), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), ie;
  }(), buffer_list;
}
var destroy_1$1, hasRequiredDestroy$1;
function requireDestroy$1() {
  if (hasRequiredDestroy$1)
    return destroy_1$1;
  hasRequiredDestroy$1 = 1;
  function e(B, M) {
    var O = this, P = this._readableState && this._readableState.destroyed, D = this._writableState && this._writableState.destroyed;
    return P || D ? (M ? M(B) : B && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, process$1.nextTick(S, this, B)) : process$1.nextTick(S, this, B)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(B || null, function(Z) {
      !M && Z ? O._writableState ? O._writableState.errorEmitted ? process$1.nextTick(h, O) : (O._writableState.errorEmitted = !0, process$1.nextTick(t, O, Z)) : process$1.nextTick(t, O, Z) : M ? (process$1.nextTick(h, O), M(Z)) : process$1.nextTick(h, O);
    }), this);
  }
  function t(B, M) {
    S(B, M), h(B);
  }
  function h(B) {
    B._writableState && !B._writableState.emitClose || B._readableState && !B._readableState.emitClose || B.emit("close");
  }
  function o() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function S(B, M) {
    B.emit("error", M);
  }
  function g(B, M) {
    var O = B._readableState, P = B._writableState;
    O && O.autoDestroy || P && P.autoDestroy ? B.destroy(M) : B.emit("error", M);
  }
  return destroy_1$1 = {
    destroy: e,
    undestroy: o,
    errorOrDestroy: g
  }, destroy_1$1;
}
var errorsBrowser = {}, hasRequiredErrorsBrowser;
function requireErrorsBrowser() {
  if (hasRequiredErrorsBrowser)
    return errorsBrowser;
  hasRequiredErrorsBrowser = 1;
  function e(M, O) {
    M.prototype = Object.create(O.prototype), M.prototype.constructor = M, M.__proto__ = O;
  }
  var t = {};
  function h(M, O, P) {
    P || (P = Error);
    function D(Y, ee, ie) {
      return typeof O == "string" ? O : O(Y, ee, ie);
    }
    var Z = /* @__PURE__ */ function(Y) {
      e(ee, Y);
      function ee(ie, ue, fe) {
        return Y.call(this, D(ie, ue, fe)) || this;
      }
      return ee;
    }(P);
    Z.prototype.name = P.name, Z.prototype.code = M, t[M] = Z;
  }
  function o(M, O) {
    if (Array.isArray(M)) {
      var P = M.length;
      return M = M.map(function(D) {
        return String(D);
      }), P > 2 ? "one of ".concat(O, " ").concat(M.slice(0, P - 1).join(", "), ", or ") + M[P - 1] : P === 2 ? "one of ".concat(O, " ").concat(M[0], " or ").concat(M[1]) : "of ".concat(O, " ").concat(M[0]);
    } else
      return "of ".concat(O, " ").concat(String(M));
  }
  function S(M, O, P) {
    return M.substr(!P || P < 0 ? 0 : +P, O.length) === O;
  }
  function g(M, O, P) {
    return (P === void 0 || P > M.length) && (P = M.length), M.substring(P - O.length, P) === O;
  }
  function B(M, O, P) {
    return typeof P != "number" && (P = 0), P + O.length > M.length ? !1 : M.indexOf(O, P) !== -1;
  }
  return h("ERR_INVALID_OPT_VALUE", function(M, O) {
    return 'The value "' + O + '" is invalid for option "' + M + '"';
  }, TypeError), h("ERR_INVALID_ARG_TYPE", function(M, O, P) {
    var D;
    typeof O == "string" && S(O, "not ") ? (D = "must not be", O = O.replace(/^not /, "")) : D = "must be";
    var Z;
    if (g(M, " argument"))
      Z = "The ".concat(M, " ").concat(D, " ").concat(o(O, "type"));
    else {
      var Y = B(M, ".") ? "property" : "argument";
      Z = 'The "'.concat(M, '" ').concat(Y, " ").concat(D, " ").concat(o(O, "type"));
    }
    return Z += ". Received type ".concat(typeof P), Z;
  }, TypeError), h("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), h("ERR_METHOD_NOT_IMPLEMENTED", function(M) {
    return "The " + M + " method is not implemented";
  }), h("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), h("ERR_STREAM_DESTROYED", function(M) {
    return "Cannot call " + M + " after a stream was destroyed";
  }), h("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), h("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), h("ERR_STREAM_WRITE_AFTER_END", "write after end"), h("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), h("ERR_UNKNOWN_ENCODING", function(M) {
    return "Unknown encoding: " + M;
  }, TypeError), h("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), errorsBrowser.codes = t, errorsBrowser;
}
var state, hasRequiredState;
function requireState() {
  if (hasRequiredState)
    return state;
  hasRequiredState = 1;
  var e = requireErrorsBrowser().codes.ERR_INVALID_OPT_VALUE;
  function t(o, S, g) {
    return o.highWaterMark != null ? o.highWaterMark : S ? o[g] : null;
  }
  function h(o, S, g, B) {
    var M = t(S, B, g);
    if (M != null) {
      if (!(isFinite(M) && Math.floor(M) === M) || M < 0) {
        var O = B ? g : "highWaterMark";
        throw new e(O, M);
      }
      return Math.floor(M);
    }
    return o.objectMode ? 16 : 16 * 1024;
  }
  return state = {
    getHighWaterMark: h
  }, state;
}
var browser$a, hasRequiredBrowser$a;
function requireBrowser$a() {
  if (hasRequiredBrowser$a)
    return browser$a;
  hasRequiredBrowser$a = 1, browser$a = e;
  function e(h, o) {
    if (t("noDeprecation"))
      return h;
    var S = !1;
    function g() {
      if (!S) {
        if (t("throwDeprecation"))
          throw new Error(o);
        t("traceDeprecation") ? console.trace(o) : console.warn(o), S = !0;
      }
      return h.apply(this, arguments);
    }
    return g;
  }
  function t(h) {
    try {
      if (!commonjsGlobal.localStorage)
        return !1;
    } catch {
      return !1;
    }
    var o = commonjsGlobal.localStorage[h];
    return o == null ? !1 : String(o).toLowerCase() === "true";
  }
  return browser$a;
}
var _stream_writable$1, hasRequired_stream_writable$1;
function require_stream_writable$1() {
  if (hasRequired_stream_writable$1)
    return _stream_writable$1;
  hasRequired_stream_writable$1 = 1, _stream_writable$1 = Le;
  function e(Re) {
    var Ae = this;
    this.next = null, this.entry = null, this.finish = function() {
      je(Ae, Re);
    };
  }
  var t;
  Le.WritableState = Ue;
  var h = {
    deprecate: requireBrowser$a()
  }, o = requireStreamBrowser$1(), S = requireBuffer$1().Buffer, g = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function B(Re) {
    return S.from(Re);
  }
  function M(Re) {
    return S.isBuffer(Re) || Re instanceof g;
  }
  var O = requireDestroy$1(), P = requireState(), D = P.getHighWaterMark, Z = requireErrorsBrowser().codes, Y = Z.ERR_INVALID_ARG_TYPE, ee = Z.ERR_METHOD_NOT_IMPLEMENTED, ie = Z.ERR_MULTIPLE_CALLBACK, ue = Z.ERR_STREAM_CANNOT_PIPE, fe = Z.ERR_STREAM_DESTROYED, de = Z.ERR_STREAM_NULL_VALUES, ce = Z.ERR_STREAM_WRITE_AFTER_END, be = Z.ERR_UNKNOWN_ENCODING, ve = O.errorOrDestroy;
  requireInherits_browser()(Le, o);
  function Pe() {
  }
  function Ue(Re, Ae, ke) {
    t = t || require_stream_duplex$1(), Re = Re || {}, typeof ke != "boolean" && (ke = Ae instanceof t), this.objectMode = !!Re.objectMode, ke && (this.objectMode = this.objectMode || !!Re.writableObjectMode), this.highWaterMark = D(this, Re, "writableHighWaterMark", ke), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Qe = Re.decodeStrings === !1;
    this.decodeStrings = !Qe, this.defaultEncoding = Re.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Ze) {
      X(Ae, Ze);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Re.emitClose !== !1, this.autoDestroy = !!Re.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  Ue.prototype.getBuffer = function() {
    for (var Re = this.bufferedRequest, Ae = []; Re; )
      Ae.push(Re), Re = Re.next;
    return Ae;
  }, function() {
    try {
      Object.defineProperty(Ue.prototype, "buffer", {
        get: h.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var ze;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ze = Function.prototype[Symbol.hasInstance], Object.defineProperty(Le, Symbol.hasInstance, {
    value: function(Re) {
      return ze.call(this, Re) ? !0 : this !== Le ? !1 : Re && Re._writableState instanceof Ue;
    }
  })) : ze = function(Re) {
    return Re instanceof this;
  };
  function Le(Re) {
    t = t || require_stream_duplex$1();
    var Ae = this instanceof t;
    if (!Ae && !ze.call(Le, this))
      return new Le(Re);
    this._writableState = new Ue(Re, this, Ae), this.writable = !0, Re && (typeof Re.write == "function" && (this._write = Re.write), typeof Re.writev == "function" && (this._writev = Re.writev), typeof Re.destroy == "function" && (this._destroy = Re.destroy), typeof Re.final == "function" && (this._final = Re.final)), o.call(this);
  }
  Le.prototype.pipe = function() {
    ve(this, new ue());
  };
  function Ne(Re, Ae) {
    var ke = new ce();
    ve(Re, ke), process$1.nextTick(Ae, ke);
  }
  function $e(Re, Ae, ke, Qe) {
    var Ze;
    return ke === null ? Ze = new de() : typeof ke != "string" && !Ae.objectMode && (Ze = new Y("chunk", ["string", "Buffer"], ke)), Ze ? (ve(Re, Ze), process$1.nextTick(Qe, Ze), !1) : !0;
  }
  Le.prototype.write = function(Re, Ae, ke) {
    var Qe = this._writableState, Ze = !1, qe = !Qe.objectMode && M(Re);
    return qe && !S.isBuffer(Re) && (Re = B(Re)), typeof Ae == "function" && (ke = Ae, Ae = null), qe ? Ae = "buffer" : Ae || (Ae = Qe.defaultEncoding), typeof ke != "function" && (ke = Pe), Qe.ending ? Ne(this, ke) : (qe || $e(this, Qe, Re, ke)) && (Qe.pendingcb++, Ze = ne(this, Qe, qe, Re, Ae, ke)), Ze;
  }, Le.prototype.cork = function() {
    this._writableState.corked++;
  }, Le.prototype.uncork = function() {
    var Re = this._writableState;
    Re.corked && (Re.corked--, !Re.writing && !Re.corked && !Re.bufferProcessing && Re.bufferedRequest && $(this, Re));
  }, Le.prototype.setDefaultEncoding = function(Re) {
    if (typeof Re == "string" && (Re = Re.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Re + "").toLowerCase()) > -1))
      throw new be(Re);
    return this._writableState.defaultEncoding = Re, this;
  }, Object.defineProperty(Le.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function J(Re, Ae, ke) {
    return !Re.objectMode && Re.decodeStrings !== !1 && typeof Ae == "string" && (Ae = S.from(Ae, ke)), Ae;
  }
  Object.defineProperty(Le.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function ne(Re, Ae, ke, Qe, Ze, qe) {
    if (!ke) {
      var Oe = J(Ae, Qe, Ze);
      Qe !== Oe && (ke = !0, Ze = "buffer", Qe = Oe);
    }
    var Xe = Ae.objectMode ? 1 : Qe.length;
    Ae.length += Xe;
    var et = Ae.length < Ae.highWaterMark;
    if (et || (Ae.needDrain = !0), Ae.writing || Ae.corked) {
      var nt = Ae.lastBufferedRequest;
      Ae.lastBufferedRequest = {
        chunk: Qe,
        encoding: Ze,
        isBuf: ke,
        callback: qe,
        next: null
      }, nt ? nt.next = Ae.lastBufferedRequest : Ae.bufferedRequest = Ae.lastBufferedRequest, Ae.bufferedRequestCount += 1;
    } else
      A(Re, Ae, !1, Xe, Qe, Ze, qe);
    return et;
  }
  function A(Re, Ae, ke, Qe, Ze, qe, Oe) {
    Ae.writelen = Qe, Ae.writecb = Oe, Ae.writing = !0, Ae.sync = !0, Ae.destroyed ? Ae.onwrite(new fe("write")) : ke ? Re._writev(Ze, Ae.onwrite) : Re._write(Ze, qe, Ae.onwrite), Ae.sync = !1;
  }
  function I(Re, Ae, ke, Qe, Ze) {
    --Ae.pendingcb, ke ? (process$1.nextTick(Ze, Qe), process$1.nextTick(me, Re, Ae), Re._writableState.errorEmitted = !0, ve(Re, Qe)) : (Ze(Qe), Re._writableState.errorEmitted = !0, ve(Re, Qe), me(Re, Ae));
  }
  function U(Re) {
    Re.writing = !1, Re.writecb = null, Re.length -= Re.writelen, Re.writelen = 0;
  }
  function X(Re, Ae) {
    var ke = Re._writableState, Qe = ke.sync, Ze = ke.writecb;
    if (typeof Ze != "function")
      throw new ie();
    if (U(ke), Ae)
      I(Re, ke, Qe, Ae, Ze);
    else {
      var qe = H(ke) || Re.destroyed;
      !qe && !ke.corked && !ke.bufferProcessing && ke.bufferedRequest && $(Re, ke), Qe ? process$1.nextTick(Q, Re, ke, qe, Ze) : Q(Re, ke, qe, Ze);
    }
  }
  function Q(Re, Ae, ke, Qe) {
    ke || F(Re, Ae), Ae.pendingcb--, Qe(), me(Re, Ae);
  }
  function F(Re, Ae) {
    Ae.length === 0 && Ae.needDrain && (Ae.needDrain = !1, Re.emit("drain"));
  }
  function $(Re, Ae) {
    Ae.bufferProcessing = !0;
    var ke = Ae.bufferedRequest;
    if (Re._writev && ke && ke.next) {
      var Qe = Ae.bufferedRequestCount, Ze = new Array(Qe), qe = Ae.corkedRequestsFree;
      qe.entry = ke;
      for (var Oe = 0, Xe = !0; ke; )
        Ze[Oe] = ke, ke.isBuf || (Xe = !1), ke = ke.next, Oe += 1;
      Ze.allBuffers = Xe, A(Re, Ae, !0, Ae.length, Ze, "", qe.finish), Ae.pendingcb++, Ae.lastBufferedRequest = null, qe.next ? (Ae.corkedRequestsFree = qe.next, qe.next = null) : Ae.corkedRequestsFree = new e(Ae), Ae.bufferedRequestCount = 0;
    } else {
      for (; ke; ) {
        var et = ke.chunk, nt = ke.encoding, re = ke.callback, oe = Ae.objectMode ? 1 : et.length;
        if (A(Re, Ae, !1, oe, et, nt, re), ke = ke.next, Ae.bufferedRequestCount--, Ae.writing)
          break;
      }
      ke === null && (Ae.lastBufferedRequest = null);
    }
    Ae.bufferedRequest = ke, Ae.bufferProcessing = !1;
  }
  Le.prototype._write = function(Re, Ae, ke) {
    ke(new ee("_write()"));
  }, Le.prototype._writev = null, Le.prototype.end = function(Re, Ae, ke) {
    var Qe = this._writableState;
    return typeof Re == "function" ? (ke = Re, Re = null, Ae = null) : typeof Ae == "function" && (ke = Ae, Ae = null), Re != null && this.write(Re, Ae), Qe.corked && (Qe.corked = 1, this.uncork()), Qe.ending || Ce(this, Qe, ke), this;
  }, Object.defineProperty(Le.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function H(Re) {
    return Re.ending && Re.length === 0 && Re.bufferedRequest === null && !Re.finished && !Re.writing;
  }
  function q(Re, Ae) {
    Re._final(function(ke) {
      Ae.pendingcb--, ke && ve(Re, ke), Ae.prefinished = !0, Re.emit("prefinish"), me(Re, Ae);
    });
  }
  function z(Re, Ae) {
    !Ae.prefinished && !Ae.finalCalled && (typeof Re._final == "function" && !Ae.destroyed ? (Ae.pendingcb++, Ae.finalCalled = !0, process$1.nextTick(q, Re, Ae)) : (Ae.prefinished = !0, Re.emit("prefinish")));
  }
  function me(Re, Ae) {
    var ke = H(Ae);
    if (ke && (z(Re, Ae), Ae.pendingcb === 0 && (Ae.finished = !0, Re.emit("finish"), Ae.autoDestroy))) {
      var Qe = Re._readableState;
      (!Qe || Qe.autoDestroy && Qe.endEmitted) && Re.destroy();
    }
    return ke;
  }
  function Ce(Re, Ae, ke) {
    Ae.ending = !0, me(Re, Ae), ke && (Ae.finished ? process$1.nextTick(ke) : Re.once("finish", ke)), Ae.ended = !0, Re.writable = !1;
  }
  function je(Re, Ae, ke) {
    var Qe = Re.entry;
    for (Re.entry = null; Qe; ) {
      var Ze = Qe.callback;
      Ae.pendingcb--, Ze(ke), Qe = Qe.next;
    }
    Ae.corkedRequestsFree.next = Re;
  }
  return Object.defineProperty(Le.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Re) {
      this._writableState && (this._writableState.destroyed = Re);
    }
  }), Le.prototype.destroy = O.destroy, Le.prototype._undestroy = O.undestroy, Le.prototype._destroy = function(Re, Ae) {
    Ae(Re);
  }, _stream_writable$1;
}
var _stream_duplex$1, hasRequired_stream_duplex$1;
function require_stream_duplex$1() {
  if (hasRequired_stream_duplex$1)
    return _stream_duplex$1;
  hasRequired_stream_duplex$1 = 1;
  var e = Object.keys || function(P) {
    var D = [];
    for (var Z in P)
      D.push(Z);
    return D;
  };
  _stream_duplex$1 = B;
  var t = require_stream_readable$1(), h = require_stream_writable$1();
  requireInherits_browser()(B, t);
  for (var o = e(h.prototype), S = 0; S < o.length; S++) {
    var g = o[S];
    B.prototype[g] || (B.prototype[g] = h.prototype[g]);
  }
  function B(P) {
    if (!(this instanceof B))
      return new B(P);
    t.call(this, P), h.call(this, P), this.allowHalfOpen = !0, P && (P.readable === !1 && (this.readable = !1), P.writable === !1 && (this.writable = !1), P.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", M)));
  }
  Object.defineProperty(B.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(B.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(B.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function M() {
    this._writableState.ended || process$1.nextTick(O, this);
  }
  function O(P) {
    P.end();
  }
  return Object.defineProperty(B.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(P) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = P, this._writableState.destroyed = P);
    }
  }), _stream_duplex$1;
}
var string_decoder = {}, hasRequiredString_decoder;
function requireString_decoder() {
  if (hasRequiredString_decoder)
    return string_decoder;
  hasRequiredString_decoder = 1;
  var e = requireSafeBuffer$1().Buffer, t = e.isEncoding || function(de) {
    switch (de = "" + de, de && de.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return !0;
      default:
        return !1;
    }
  };
  function h(de) {
    if (!de)
      return "utf8";
    for (var ce; ; )
      switch (de) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return de;
        default:
          if (ce)
            return;
          de = ("" + de).toLowerCase(), ce = !0;
      }
  }
  function o(de) {
    var ce = h(de);
    if (typeof ce != "string" && (e.isEncoding === t || !t(de)))
      throw new Error("Unknown encoding: " + de);
    return ce || de;
  }
  string_decoder.StringDecoder = S;
  function S(de) {
    this.encoding = o(de);
    var ce;
    switch (this.encoding) {
      case "utf16le":
        this.text = Z, this.end = Y, ce = 4;
        break;
      case "utf8":
        this.fillLast = O, ce = 4;
        break;
      case "base64":
        this.text = ee, this.end = ie, ce = 3;
        break;
      default:
        this.write = ue, this.end = fe;
        return;
    }
    this.lastNeed = 0, this.lastTotal = 0, this.lastChar = e.allocUnsafe(ce);
  }
  S.prototype.write = function(de) {
    if (de.length === 0)
      return "";
    var ce, be;
    if (this.lastNeed) {
      if (ce = this.fillLast(de), ce === void 0)
        return "";
      be = this.lastNeed, this.lastNeed = 0;
    } else
      be = 0;
    return be < de.length ? ce ? ce + this.text(de, be) : this.text(de, be) : ce || "";
  }, S.prototype.end = D, S.prototype.text = P, S.prototype.fillLast = function(de) {
    if (this.lastNeed <= de.length)
      return de.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    de.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, de.length), this.lastNeed -= de.length;
  };
  function g(de) {
    return de <= 127 ? 0 : de >> 5 === 6 ? 2 : de >> 4 === 14 ? 3 : de >> 3 === 30 ? 4 : de >> 6 === 2 ? -1 : -2;
  }
  function B(de, ce, be) {
    var ve = ce.length - 1;
    if (ve < be)
      return 0;
    var Pe = g(ce[ve]);
    return Pe >= 0 ? (Pe > 0 && (de.lastNeed = Pe - 1), Pe) : --ve < be || Pe === -2 ? 0 : (Pe = g(ce[ve]), Pe >= 0 ? (Pe > 0 && (de.lastNeed = Pe - 2), Pe) : --ve < be || Pe === -2 ? 0 : (Pe = g(ce[ve]), Pe >= 0 ? (Pe > 0 && (Pe === 2 ? Pe = 0 : de.lastNeed = Pe - 3), Pe) : 0));
  }
  function M(de, ce, be) {
    if ((ce[0] & 192) !== 128)
      return de.lastNeed = 0, "�";
    if (de.lastNeed > 1 && ce.length > 1) {
      if ((ce[1] & 192) !== 128)
        return de.lastNeed = 1, "�";
      if (de.lastNeed > 2 && ce.length > 2 && (ce[2] & 192) !== 128)
        return de.lastNeed = 2, "�";
    }
  }
  function O(de) {
    var ce = this.lastTotal - this.lastNeed, be = M(this, de);
    if (be !== void 0)
      return be;
    if (this.lastNeed <= de.length)
      return de.copy(this.lastChar, ce, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
    de.copy(this.lastChar, ce, 0, de.length), this.lastNeed -= de.length;
  }
  function P(de, ce) {
    var be = B(this, de, ce);
    if (!this.lastNeed)
      return de.toString("utf8", ce);
    this.lastTotal = be;
    var ve = de.length - (be - this.lastNeed);
    return de.copy(this.lastChar, 0, ve), de.toString("utf8", ce, ve);
  }
  function D(de) {
    var ce = de && de.length ? this.write(de) : "";
    return this.lastNeed ? ce + "�" : ce;
  }
  function Z(de, ce) {
    if ((de.length - ce) % 2 === 0) {
      var be = de.toString("utf16le", ce);
      if (be) {
        var ve = be.charCodeAt(be.length - 1);
        if (ve >= 55296 && ve <= 56319)
          return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = de[de.length - 2], this.lastChar[1] = de[de.length - 1], be.slice(0, -1);
      }
      return be;
    }
    return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = de[de.length - 1], de.toString("utf16le", ce, de.length - 1);
  }
  function Y(de) {
    var ce = de && de.length ? this.write(de) : "";
    if (this.lastNeed) {
      var be = this.lastTotal - this.lastNeed;
      return ce + this.lastChar.toString("utf16le", 0, be);
    }
    return ce;
  }
  function ee(de, ce) {
    var be = (de.length - ce) % 3;
    return be === 0 ? de.toString("base64", ce) : (this.lastNeed = 3 - be, this.lastTotal = 3, be === 1 ? this.lastChar[0] = de[de.length - 1] : (this.lastChar[0] = de[de.length - 2], this.lastChar[1] = de[de.length - 1]), de.toString("base64", ce, de.length - be));
  }
  function ie(de) {
    var ce = de && de.length ? this.write(de) : "";
    return this.lastNeed ? ce + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : ce;
  }
  function ue(de) {
    return de.toString(this.encoding);
  }
  function fe(de) {
    return de && de.length ? this.write(de) : "";
  }
  return string_decoder;
}
var endOfStream, hasRequiredEndOfStream;
function requireEndOfStream() {
  if (hasRequiredEndOfStream)
    return endOfStream;
  hasRequiredEndOfStream = 1;
  var e = requireErrorsBrowser().codes.ERR_STREAM_PREMATURE_CLOSE;
  function t(g) {
    var B = !1;
    return function() {
      if (!B) {
        B = !0;
        for (var M = arguments.length, O = new Array(M), P = 0; P < M; P++)
          O[P] = arguments[P];
        g.apply(this, O);
      }
    };
  }
  function h() {
  }
  function o(g) {
    return g.setHeader && typeof g.abort == "function";
  }
  function S(g, B, M) {
    if (typeof B == "function")
      return S(g, null, B);
    B || (B = {}), M = t(M || h);
    var O = B.readable || B.readable !== !1 && g.readable, P = B.writable || B.writable !== !1 && g.writable, D = function() {
      g.writable || Y();
    }, Z = g._writableState && g._writableState.finished, Y = function() {
      P = !1, Z = !0, O || M.call(g);
    }, ee = g._readableState && g._readableState.endEmitted, ie = function() {
      O = !1, ee = !0, P || M.call(g);
    }, ue = function(ce) {
      M.call(g, ce);
    }, fe = function() {
      var ce;
      if (O && !ee)
        return (!g._readableState || !g._readableState.ended) && (ce = new e()), M.call(g, ce);
      if (P && !Z)
        return (!g._writableState || !g._writableState.ended) && (ce = new e()), M.call(g, ce);
    }, de = function() {
      g.req.on("finish", Y);
    };
    return o(g) ? (g.on("complete", Y), g.on("abort", fe), g.req ? de() : g.on("request", de)) : P && !g._writableState && (g.on("end", D), g.on("close", D)), g.on("end", ie), g.on("finish", Y), B.error !== !1 && g.on("error", ue), g.on("close", fe), function() {
      g.removeListener("complete", Y), g.removeListener("abort", fe), g.removeListener("request", de), g.req && g.req.removeListener("finish", Y), g.removeListener("end", D), g.removeListener("close", D), g.removeListener("finish", Y), g.removeListener("end", ie), g.removeListener("error", ue), g.removeListener("close", fe);
    };
  }
  return endOfStream = S, endOfStream;
}
var async_iterator, hasRequiredAsync_iterator;
function requireAsync_iterator() {
  if (hasRequiredAsync_iterator)
    return async_iterator;
  hasRequiredAsync_iterator = 1;
  var e;
  function t(be, ve, Pe) {
    return ve = h(ve), ve in be ? Object.defineProperty(be, ve, { value: Pe, enumerable: !0, configurable: !0, writable: !0 }) : be[ve] = Pe, be;
  }
  function h(be) {
    var ve = o(be, "string");
    return typeof ve == "symbol" ? ve : String(ve);
  }
  function o(be, ve) {
    if (typeof be != "object" || be === null)
      return be;
    var Pe = be[Symbol.toPrimitive];
    if (Pe !== void 0) {
      var Ue = Pe.call(be, ve || "default");
      if (typeof Ue != "object")
        return Ue;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (ve === "string" ? String : Number)(be);
  }
  var S = requireEndOfStream(), g = Symbol("lastResolve"), B = Symbol("lastReject"), M = Symbol("error"), O = Symbol("ended"), P = Symbol("lastPromise"), D = Symbol("handlePromise"), Z = Symbol("stream");
  function Y(be, ve) {
    return {
      value: be,
      done: ve
    };
  }
  function ee(be) {
    var ve = be[g];
    if (ve !== null) {
      var Pe = be[Z].read();
      Pe !== null && (be[P] = null, be[g] = null, be[B] = null, ve(Y(Pe, !1)));
    }
  }
  function ie(be) {
    process$1.nextTick(ee, be);
  }
  function ue(be, ve) {
    return function(Pe, Ue) {
      be.then(function() {
        if (ve[O]) {
          Pe(Y(void 0, !0));
          return;
        }
        ve[D](Pe, Ue);
      }, Ue);
    };
  }
  var fe = Object.getPrototypeOf(function() {
  }), de = Object.setPrototypeOf((e = {
    get stream() {
      return this[Z];
    },
    next: function() {
      var be = this, ve = this[M];
      if (ve !== null)
        return Promise.reject(ve);
      if (this[O])
        return Promise.resolve(Y(void 0, !0));
      if (this[Z].destroyed)
        return new Promise(function(Le, Ne) {
          process$1.nextTick(function() {
            be[M] ? Ne(be[M]) : Le(Y(void 0, !0));
          });
        });
      var Pe = this[P], Ue;
      if (Pe)
        Ue = new Promise(ue(Pe, this));
      else {
        var ze = this[Z].read();
        if (ze !== null)
          return Promise.resolve(Y(ze, !1));
        Ue = new Promise(this[D]);
      }
      return this[P] = Ue, Ue;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var be = this;
    return new Promise(function(ve, Pe) {
      be[Z].destroy(null, function(Ue) {
        if (Ue) {
          Pe(Ue);
          return;
        }
        ve(Y(void 0, !0));
      });
    });
  }), e), fe), ce = function(be) {
    var ve, Pe = Object.create(de, (ve = {}, t(ve, Z, {
      value: be,
      writable: !0
    }), t(ve, g, {
      value: null,
      writable: !0
    }), t(ve, B, {
      value: null,
      writable: !0
    }), t(ve, M, {
      value: null,
      writable: !0
    }), t(ve, O, {
      value: be._readableState.endEmitted,
      writable: !0
    }), t(ve, D, {
      value: function(Ue, ze) {
        var Le = Pe[Z].read();
        Le ? (Pe[P] = null, Pe[g] = null, Pe[B] = null, Ue(Y(Le, !1))) : (Pe[g] = Ue, Pe[B] = ze);
      },
      writable: !0
    }), ve));
    return Pe[P] = null, S(be, function(Ue) {
      if (Ue && Ue.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var ze = Pe[B];
        ze !== null && (Pe[P] = null, Pe[g] = null, Pe[B] = null, ze(Ue)), Pe[M] = Ue;
        return;
      }
      var Le = Pe[g];
      Le !== null && (Pe[P] = null, Pe[g] = null, Pe[B] = null, Le(Y(void 0, !0))), Pe[O] = !0;
    }), be.on("readable", ie.bind(null, Pe)), Pe;
  };
  return async_iterator = ce, async_iterator;
}
var fromBrowser, hasRequiredFromBrowser;
function requireFromBrowser() {
  return hasRequiredFromBrowser || (hasRequiredFromBrowser = 1, fromBrowser = function() {
    throw new Error("Readable.from is not available in the browser");
  }), fromBrowser;
}
var _stream_readable$1, hasRequired_stream_readable$1;
function require_stream_readable$1() {
  if (hasRequired_stream_readable$1)
    return _stream_readable$1;
  hasRequired_stream_readable$1 = 1, _stream_readable$1 = Ne;
  var e;
  Ne.ReadableState = Le, requireEvents().EventEmitter;
  var t = function(qe, Oe) {
    return qe.listeners(Oe).length;
  }, h = requireStreamBrowser$1(), o = requireBuffer$1().Buffer, S = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function g(qe) {
    return o.from(qe);
  }
  function B(qe) {
    return o.isBuffer(qe) || qe instanceof S;
  }
  var M = requireUtil$1(), O;
  M && M.debuglog ? O = M.debuglog("stream") : O = function() {
  };
  var P = requireBuffer_list(), D = requireDestroy$1(), Z = requireState(), Y = Z.getHighWaterMark, ee = requireErrorsBrowser().codes, ie = ee.ERR_INVALID_ARG_TYPE, ue = ee.ERR_STREAM_PUSH_AFTER_EOF, fe = ee.ERR_METHOD_NOT_IMPLEMENTED, de = ee.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, ce, be, ve;
  requireInherits_browser()(Ne, h);
  var Pe = D.errorOrDestroy, Ue = ["error", "close", "destroy", "pause", "resume"];
  function ze(qe, Oe, Xe) {
    if (typeof qe.prependListener == "function")
      return qe.prependListener(Oe, Xe);
    !qe._events || !qe._events[Oe] ? qe.on(Oe, Xe) : Array.isArray(qe._events[Oe]) ? qe._events[Oe].unshift(Xe) : qe._events[Oe] = [Xe, qe._events[Oe]];
  }
  function Le(qe, Oe, Xe) {
    e = e || require_stream_duplex$1(), qe = qe || {}, typeof Xe != "boolean" && (Xe = Oe instanceof e), this.objectMode = !!qe.objectMode, Xe && (this.objectMode = this.objectMode || !!qe.readableObjectMode), this.highWaterMark = Y(this, qe, "readableHighWaterMark", Xe), this.buffer = new P(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = qe.emitClose !== !1, this.autoDestroy = !!qe.autoDestroy, this.destroyed = !1, this.defaultEncoding = qe.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, qe.encoding && (ce || (ce = requireString_decoder().StringDecoder), this.decoder = new ce(qe.encoding), this.encoding = qe.encoding);
  }
  function Ne(qe) {
    if (e = e || require_stream_duplex$1(), !(this instanceof Ne))
      return new Ne(qe);
    var Oe = this instanceof e;
    this._readableState = new Le(qe, this, Oe), this.readable = !0, qe && (typeof qe.read == "function" && (this._read = qe.read), typeof qe.destroy == "function" && (this._destroy = qe.destroy)), h.call(this);
  }
  Object.defineProperty(Ne.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(qe) {
      this._readableState && (this._readableState.destroyed = qe);
    }
  }), Ne.prototype.destroy = D.destroy, Ne.prototype._undestroy = D.undestroy, Ne.prototype._destroy = function(qe, Oe) {
    Oe(qe);
  }, Ne.prototype.push = function(qe, Oe) {
    var Xe = this._readableState, et;
    return Xe.objectMode ? et = !0 : typeof qe == "string" && (Oe = Oe || Xe.defaultEncoding, Oe !== Xe.encoding && (qe = o.from(qe, Oe), Oe = ""), et = !0), $e(this, qe, Oe, !1, et);
  }, Ne.prototype.unshift = function(qe) {
    return $e(this, qe, null, !0, !1);
  };
  function $e(qe, Oe, Xe, et, nt) {
    O("readableAddChunk", Oe);
    var re = qe._readableState;
    if (Oe === null)
      re.reading = !1, X(qe, re);
    else {
      var oe;
      if (nt || (oe = ne(re, Oe)), oe)
        Pe(qe, oe);
      else if (re.objectMode || Oe && Oe.length > 0)
        if (typeof Oe != "string" && !re.objectMode && Object.getPrototypeOf(Oe) !== o.prototype && (Oe = g(Oe)), et)
          re.endEmitted ? Pe(qe, new de()) : J(qe, re, Oe, !0);
        else if (re.ended)
          Pe(qe, new ue());
        else {
          if (re.destroyed)
            return !1;
          re.reading = !1, re.decoder && !Xe ? (Oe = re.decoder.write(Oe), re.objectMode || Oe.length !== 0 ? J(qe, re, Oe, !1) : $(qe, re)) : J(qe, re, Oe, !1);
        }
      else
        et || (re.reading = !1, $(qe, re));
    }
    return !re.ended && (re.length < re.highWaterMark || re.length === 0);
  }
  function J(qe, Oe, Xe, et) {
    Oe.flowing && Oe.length === 0 && !Oe.sync ? (Oe.awaitDrain = 0, qe.emit("data", Xe)) : (Oe.length += Oe.objectMode ? 1 : Xe.length, et ? Oe.buffer.unshift(Xe) : Oe.buffer.push(Xe), Oe.needReadable && Q(qe)), $(qe, Oe);
  }
  function ne(qe, Oe) {
    var Xe;
    return !B(Oe) && typeof Oe != "string" && Oe !== void 0 && !qe.objectMode && (Xe = new ie("chunk", ["string", "Buffer", "Uint8Array"], Oe)), Xe;
  }
  Ne.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Ne.prototype.setEncoding = function(qe) {
    ce || (ce = requireString_decoder().StringDecoder);
    var Oe = new ce(qe);
    this._readableState.decoder = Oe, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Xe = this._readableState.buffer.head, et = ""; Xe !== null; )
      et += Oe.write(Xe.data), Xe = Xe.next;
    return this._readableState.buffer.clear(), et !== "" && this._readableState.buffer.push(et), this._readableState.length = et.length, this;
  };
  var A = 1073741824;
  function I(qe) {
    return qe >= A ? qe = A : (qe--, qe |= qe >>> 1, qe |= qe >>> 2, qe |= qe >>> 4, qe |= qe >>> 8, qe |= qe >>> 16, qe++), qe;
  }
  function U(qe, Oe) {
    return qe <= 0 || Oe.length === 0 && Oe.ended ? 0 : Oe.objectMode ? 1 : qe !== qe ? Oe.flowing && Oe.length ? Oe.buffer.head.data.length : Oe.length : (qe > Oe.highWaterMark && (Oe.highWaterMark = I(qe)), qe <= Oe.length ? qe : Oe.ended ? Oe.length : (Oe.needReadable = !0, 0));
  }
  Ne.prototype.read = function(qe) {
    O("read", qe), qe = parseInt(qe, 10);
    var Oe = this._readableState, Xe = qe;
    if (qe !== 0 && (Oe.emittedReadable = !1), qe === 0 && Oe.needReadable && ((Oe.highWaterMark !== 0 ? Oe.length >= Oe.highWaterMark : Oe.length > 0) || Oe.ended))
      return O("read: emitReadable", Oe.length, Oe.ended), Oe.length === 0 && Oe.ended ? ke(this) : Q(this), null;
    if (qe = U(qe, Oe), qe === 0 && Oe.ended)
      return Oe.length === 0 && ke(this), null;
    var et = Oe.needReadable;
    O("need readable", et), (Oe.length === 0 || Oe.length - qe < Oe.highWaterMark) && (et = !0, O("length less than watermark", et)), Oe.ended || Oe.reading ? (et = !1, O("reading or ended", et)) : et && (O("do read"), Oe.reading = !0, Oe.sync = !0, Oe.length === 0 && (Oe.needReadable = !0), this._read(Oe.highWaterMark), Oe.sync = !1, Oe.reading || (qe = U(Xe, Oe)));
    var nt;
    return qe > 0 ? nt = Ae(qe, Oe) : nt = null, nt === null ? (Oe.needReadable = Oe.length <= Oe.highWaterMark, qe = 0) : (Oe.length -= qe, Oe.awaitDrain = 0), Oe.length === 0 && (Oe.ended || (Oe.needReadable = !0), Xe !== qe && Oe.ended && ke(this)), nt !== null && this.emit("data", nt), nt;
  };
  function X(qe, Oe) {
    if (O("onEofChunk"), !Oe.ended) {
      if (Oe.decoder) {
        var Xe = Oe.decoder.end();
        Xe && Xe.length && (Oe.buffer.push(Xe), Oe.length += Oe.objectMode ? 1 : Xe.length);
      }
      Oe.ended = !0, Oe.sync ? Q(qe) : (Oe.needReadable = !1, Oe.emittedReadable || (Oe.emittedReadable = !0, F(qe)));
    }
  }
  function Q(qe) {
    var Oe = qe._readableState;
    O("emitReadable", Oe.needReadable, Oe.emittedReadable), Oe.needReadable = !1, Oe.emittedReadable || (O("emitReadable", Oe.flowing), Oe.emittedReadable = !0, process$1.nextTick(F, qe));
  }
  function F(qe) {
    var Oe = qe._readableState;
    O("emitReadable_", Oe.destroyed, Oe.length, Oe.ended), !Oe.destroyed && (Oe.length || Oe.ended) && (qe.emit("readable"), Oe.emittedReadable = !1), Oe.needReadable = !Oe.flowing && !Oe.ended && Oe.length <= Oe.highWaterMark, Re(qe);
  }
  function $(qe, Oe) {
    Oe.readingMore || (Oe.readingMore = !0, process$1.nextTick(H, qe, Oe));
  }
  function H(qe, Oe) {
    for (; !Oe.reading && !Oe.ended && (Oe.length < Oe.highWaterMark || Oe.flowing && Oe.length === 0); ) {
      var Xe = Oe.length;
      if (O("maybeReadMore read 0"), qe.read(0), Xe === Oe.length)
        break;
    }
    Oe.readingMore = !1;
  }
  Ne.prototype._read = function(qe) {
    Pe(this, new fe("_read()"));
  }, Ne.prototype.pipe = function(qe, Oe) {
    var Xe = this, et = this._readableState;
    switch (et.pipesCount) {
      case 0:
        et.pipes = qe;
        break;
      case 1:
        et.pipes = [et.pipes, qe];
        break;
      default:
        et.pipes.push(qe);
        break;
    }
    et.pipesCount += 1, O("pipe count=%d opts=%j", et.pipesCount, Oe);
    var nt = (!Oe || Oe.end !== !1) && qe !== process$1.stdout && qe !== process$1.stderr, re = nt ? le : tt;
    et.endEmitted ? process$1.nextTick(re) : Xe.once("end", re), qe.on("unpipe", oe);
    function oe(vt, St) {
      O("onunpipe"), vt === Xe && St && St.hasUnpiped === !1 && (St.hasUnpiped = !0, Je());
    }
    function le() {
      O("onend"), qe.end();
    }
    var ge = q(Xe);
    qe.on("drain", ge);
    var Ke = !1;
    function Je() {
      O("cleanup"), qe.removeListener("close", it), qe.removeListener("finish", rt), qe.removeListener("drain", ge), qe.removeListener("error", Ye), qe.removeListener("unpipe", oe), Xe.removeListener("end", le), Xe.removeListener("end", tt), Xe.removeListener("data", Fe), Ke = !0, et.awaitDrain && (!qe._writableState || qe._writableState.needDrain) && ge();
    }
    Xe.on("data", Fe);
    function Fe(vt) {
      O("ondata");
      var St = qe.write(vt);
      O("dest.write", St), St === !1 && ((et.pipesCount === 1 && et.pipes === qe || et.pipesCount > 1 && Ze(et.pipes, qe) !== -1) && !Ke && (O("false write response, pause", et.awaitDrain), et.awaitDrain++), Xe.pause());
    }
    function Ye(vt) {
      O("onerror", vt), tt(), qe.removeListener("error", Ye), t(qe, "error") === 0 && Pe(qe, vt);
    }
    ze(qe, "error", Ye);
    function it() {
      qe.removeListener("finish", rt), tt();
    }
    qe.once("close", it);
    function rt() {
      O("onfinish"), qe.removeListener("close", it), tt();
    }
    qe.once("finish", rt);
    function tt() {
      O("unpipe"), Xe.unpipe(qe);
    }
    return qe.emit("pipe", Xe), et.flowing || (O("pipe resume"), Xe.resume()), qe;
  };
  function q(qe) {
    return function() {
      var Oe = qe._readableState;
      O("pipeOnDrain", Oe.awaitDrain), Oe.awaitDrain && Oe.awaitDrain--, Oe.awaitDrain === 0 && t(qe, "data") && (Oe.flowing = !0, Re(qe));
    };
  }
  Ne.prototype.unpipe = function(qe) {
    var Oe = this._readableState, Xe = {
      hasUnpiped: !1
    };
    if (Oe.pipesCount === 0)
      return this;
    if (Oe.pipesCount === 1)
      return qe && qe !== Oe.pipes ? this : (qe || (qe = Oe.pipes), Oe.pipes = null, Oe.pipesCount = 0, Oe.flowing = !1, qe && qe.emit("unpipe", this, Xe), this);
    if (!qe) {
      var et = Oe.pipes, nt = Oe.pipesCount;
      Oe.pipes = null, Oe.pipesCount = 0, Oe.flowing = !1;
      for (var re = 0; re < nt; re++)
        et[re].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var oe = Ze(Oe.pipes, qe);
    return oe === -1 ? this : (Oe.pipes.splice(oe, 1), Oe.pipesCount -= 1, Oe.pipesCount === 1 && (Oe.pipes = Oe.pipes[0]), qe.emit("unpipe", this, Xe), this);
  }, Ne.prototype.on = function(qe, Oe) {
    var Xe = h.prototype.on.call(this, qe, Oe), et = this._readableState;
    return qe === "data" ? (et.readableListening = this.listenerCount("readable") > 0, et.flowing !== !1 && this.resume()) : qe === "readable" && !et.endEmitted && !et.readableListening && (et.readableListening = et.needReadable = !0, et.flowing = !1, et.emittedReadable = !1, O("on readable", et.length, et.reading), et.length ? Q(this) : et.reading || process$1.nextTick(me, this)), Xe;
  }, Ne.prototype.addListener = Ne.prototype.on, Ne.prototype.removeListener = function(qe, Oe) {
    var Xe = h.prototype.removeListener.call(this, qe, Oe);
    return qe === "readable" && process$1.nextTick(z, this), Xe;
  }, Ne.prototype.removeAllListeners = function(qe) {
    var Oe = h.prototype.removeAllListeners.apply(this, arguments);
    return (qe === "readable" || qe === void 0) && process$1.nextTick(z, this), Oe;
  };
  function z(qe) {
    var Oe = qe._readableState;
    Oe.readableListening = qe.listenerCount("readable") > 0, Oe.resumeScheduled && !Oe.paused ? Oe.flowing = !0 : qe.listenerCount("data") > 0 && qe.resume();
  }
  function me(qe) {
    O("readable nexttick read 0"), qe.read(0);
  }
  Ne.prototype.resume = function() {
    var qe = this._readableState;
    return qe.flowing || (O("resume"), qe.flowing = !qe.readableListening, Ce(this, qe)), qe.paused = !1, this;
  };
  function Ce(qe, Oe) {
    Oe.resumeScheduled || (Oe.resumeScheduled = !0, process$1.nextTick(je, qe, Oe));
  }
  function je(qe, Oe) {
    O("resume", Oe.reading), Oe.reading || qe.read(0), Oe.resumeScheduled = !1, qe.emit("resume"), Re(qe), Oe.flowing && !Oe.reading && qe.read(0);
  }
  Ne.prototype.pause = function() {
    return O("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (O("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function Re(qe) {
    var Oe = qe._readableState;
    for (O("flow", Oe.flowing); Oe.flowing && qe.read() !== null; )
      ;
  }
  Ne.prototype.wrap = function(qe) {
    var Oe = this, Xe = this._readableState, et = !1;
    qe.on("end", function() {
      if (O("wrapped end"), Xe.decoder && !Xe.ended) {
        var oe = Xe.decoder.end();
        oe && oe.length && Oe.push(oe);
      }
      Oe.push(null);
    }), qe.on("data", function(oe) {
      if (O("wrapped data"), Xe.decoder && (oe = Xe.decoder.write(oe)), !(Xe.objectMode && oe == null) && !(!Xe.objectMode && (!oe || !oe.length))) {
        var le = Oe.push(oe);
        le || (et = !0, qe.pause());
      }
    });
    for (var nt in qe)
      this[nt] === void 0 && typeof qe[nt] == "function" && (this[nt] = /* @__PURE__ */ function(oe) {
        return function() {
          return qe[oe].apply(qe, arguments);
        };
      }(nt));
    for (var re = 0; re < Ue.length; re++)
      qe.on(Ue[re], this.emit.bind(this, Ue[re]));
    return this._read = function(oe) {
      O("wrapped _read", oe), et && (et = !1, qe.resume());
    }, this;
  }, typeof Symbol == "function" && (Ne.prototype[Symbol.asyncIterator] = function() {
    return be === void 0 && (be = requireAsync_iterator()), be(this);
  }), Object.defineProperty(Ne.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(Ne.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(Ne.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(qe) {
      this._readableState && (this._readableState.flowing = qe);
    }
  }), Ne._fromList = Ae, Object.defineProperty(Ne.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function Ae(qe, Oe) {
    if (Oe.length === 0)
      return null;
    var Xe;
    return Oe.objectMode ? Xe = Oe.buffer.shift() : !qe || qe >= Oe.length ? (Oe.decoder ? Xe = Oe.buffer.join("") : Oe.buffer.length === 1 ? Xe = Oe.buffer.first() : Xe = Oe.buffer.concat(Oe.length), Oe.buffer.clear()) : Xe = Oe.buffer.consume(qe, Oe.decoder), Xe;
  }
  function ke(qe) {
    var Oe = qe._readableState;
    O("endReadable", Oe.endEmitted), Oe.endEmitted || (Oe.ended = !0, process$1.nextTick(Qe, Oe, qe));
  }
  function Qe(qe, Oe) {
    if (O("endReadableNT", qe.endEmitted, qe.length), !qe.endEmitted && qe.length === 0 && (qe.endEmitted = !0, Oe.readable = !1, Oe.emit("end"), qe.autoDestroy)) {
      var Xe = Oe._writableState;
      (!Xe || Xe.autoDestroy && Xe.finished) && Oe.destroy();
    }
  }
  typeof Symbol == "function" && (Ne.from = function(qe, Oe) {
    return ve === void 0 && (ve = requireFromBrowser()), ve(Ne, qe, Oe);
  });
  function Ze(qe, Oe) {
    for (var Xe = 0, et = qe.length; Xe < et; Xe++)
      if (qe[Xe] === Oe)
        return Xe;
    return -1;
  }
  return _stream_readable$1;
}
var _stream_transform$1, hasRequired_stream_transform$1;
function require_stream_transform$1() {
  if (hasRequired_stream_transform$1)
    return _stream_transform$1;
  hasRequired_stream_transform$1 = 1, _stream_transform$1 = M;
  var e = requireErrorsBrowser().codes, t = e.ERR_METHOD_NOT_IMPLEMENTED, h = e.ERR_MULTIPLE_CALLBACK, o = e.ERR_TRANSFORM_ALREADY_TRANSFORMING, S = e.ERR_TRANSFORM_WITH_LENGTH_0, g = require_stream_duplex$1();
  requireInherits_browser()(M, g);
  function B(D, Z) {
    var Y = this._transformState;
    Y.transforming = !1;
    var ee = Y.writecb;
    if (ee === null)
      return this.emit("error", new h());
    Y.writechunk = null, Y.writecb = null, Z != null && this.push(Z), ee(D);
    var ie = this._readableState;
    ie.reading = !1, (ie.needReadable || ie.length < ie.highWaterMark) && this._read(ie.highWaterMark);
  }
  function M(D) {
    if (!(this instanceof M))
      return new M(D);
    g.call(this, D), this._transformState = {
      afterTransform: B.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, D && (typeof D.transform == "function" && (this._transform = D.transform), typeof D.flush == "function" && (this._flush = D.flush)), this.on("prefinish", O);
  }
  function O() {
    var D = this;
    typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(Z, Y) {
      P(D, Z, Y);
    }) : P(this, null, null);
  }
  M.prototype.push = function(D, Z) {
    return this._transformState.needTransform = !1, g.prototype.push.call(this, D, Z);
  }, M.prototype._transform = function(D, Z, Y) {
    Y(new t("_transform()"));
  }, M.prototype._write = function(D, Z, Y) {
    var ee = this._transformState;
    if (ee.writecb = Y, ee.writechunk = D, ee.writeencoding = Z, !ee.transforming) {
      var ie = this._readableState;
      (ee.needTransform || ie.needReadable || ie.length < ie.highWaterMark) && this._read(ie.highWaterMark);
    }
  }, M.prototype._read = function(D) {
    var Z = this._transformState;
    Z.writechunk !== null && !Z.transforming ? (Z.transforming = !0, this._transform(Z.writechunk, Z.writeencoding, Z.afterTransform)) : Z.needTransform = !0;
  }, M.prototype._destroy = function(D, Z) {
    g.prototype._destroy.call(this, D, function(Y) {
      Z(Y);
    });
  };
  function P(D, Z, Y) {
    if (Z)
      return D.emit("error", Z);
    if (Y != null && D.push(Y), D._writableState.length)
      throw new S();
    if (D._transformState.transforming)
      throw new o();
    return D.push(null);
  }
  return _stream_transform$1;
}
var _stream_passthrough$1, hasRequired_stream_passthrough$1;
function require_stream_passthrough$1() {
  if (hasRequired_stream_passthrough$1)
    return _stream_passthrough$1;
  hasRequired_stream_passthrough$1 = 1, _stream_passthrough$1 = t;
  var e = require_stream_transform$1();
  requireInherits_browser()(t, e);
  function t(h) {
    if (!(this instanceof t))
      return new t(h);
    e.call(this, h);
  }
  return t.prototype._transform = function(h, o, S) {
    S(null, h);
  }, _stream_passthrough$1;
}
var pipeline_1, hasRequiredPipeline;
function requirePipeline() {
  if (hasRequiredPipeline)
    return pipeline_1;
  hasRequiredPipeline = 1;
  var e;
  function t(Y) {
    var ee = !1;
    return function() {
      ee || (ee = !0, Y.apply(void 0, arguments));
    };
  }
  var h = requireErrorsBrowser().codes, o = h.ERR_MISSING_ARGS, S = h.ERR_STREAM_DESTROYED;
  function g(Y) {
    if (Y)
      throw Y;
  }
  function B(Y) {
    return Y.setHeader && typeof Y.abort == "function";
  }
  function M(Y, ee, ie, ue) {
    ue = t(ue);
    var fe = !1;
    Y.on("close", function() {
      fe = !0;
    }), e === void 0 && (e = requireEndOfStream()), e(Y, {
      readable: ee,
      writable: ie
    }, function(ce) {
      if (ce)
        return ue(ce);
      fe = !0, ue();
    });
    var de = !1;
    return function(ce) {
      if (!fe && !de) {
        if (de = !0, B(Y))
          return Y.abort();
        if (typeof Y.destroy == "function")
          return Y.destroy();
        ue(ce || new S("pipe"));
      }
    };
  }
  function O(Y) {
    Y();
  }
  function P(Y, ee) {
    return Y.pipe(ee);
  }
  function D(Y) {
    return !Y.length || typeof Y[Y.length - 1] != "function" ? g : Y.pop();
  }
  function Z() {
    for (var Y = arguments.length, ee = new Array(Y), ie = 0; ie < Y; ie++)
      ee[ie] = arguments[ie];
    var ue = D(ee);
    if (Array.isArray(ee[0]) && (ee = ee[0]), ee.length < 2)
      throw new o("streams");
    var fe, de = ee.map(function(ce, be) {
      var ve = be < ee.length - 1, Pe = be > 0;
      return M(ce, ve, Pe, function(Ue) {
        fe || (fe = Ue), Ue && de.forEach(O), !ve && (de.forEach(O), ue(fe));
      });
    });
    return ee.reduce(P);
  }
  return pipeline_1 = Z, pipeline_1;
}
var hasRequiredReadableBrowser$1;
function requireReadableBrowser$1() {
  return hasRequiredReadableBrowser$1 || (hasRequiredReadableBrowser$1 = 1, function(e, t) {
    t = e.exports = require_stream_readable$1(), t.Stream = t, t.Readable = t, t.Writable = require_stream_writable$1(), t.Duplex = require_stream_duplex$1(), t.Transform = require_stream_transform$1(), t.PassThrough = require_stream_passthrough$1(), t.finished = requireEndOfStream(), t.pipeline = requirePipeline();
  }(readableBrowser$1, readableBrowser$1.exports)), readableBrowser$1.exports;
}
var hashBase$1, hasRequiredHashBase$1;
function requireHashBase$1() {
  if (hasRequiredHashBase$1)
    return hashBase$1;
  hasRequiredHashBase$1 = 1;
  var e = requireSafeBuffer$1().Buffer, t = requireReadableBrowser$1().Transform, h = requireInherits_browser();
  function o(g, B) {
    if (!e.isBuffer(g) && typeof g != "string")
      throw new TypeError(B + " must be a string or a buffer");
  }
  function S(g) {
    t.call(this), this._block = e.allocUnsafe(g), this._blockSize = g, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return h(S, t), S.prototype._transform = function(g, B, M) {
    var O = null;
    try {
      this.update(g, B);
    } catch (P) {
      O = P;
    }
    M(O);
  }, S.prototype._flush = function(g) {
    var B = null;
    try {
      this.push(this.digest());
    } catch (M) {
      B = M;
    }
    g(B);
  }, S.prototype.update = function(g, B) {
    if (o(g, "Data"), this._finalized)
      throw new Error("Digest already called");
    e.isBuffer(g) || (g = e.from(g, B));
    for (var M = this._block, O = 0; this._blockOffset + g.length - O >= this._blockSize; ) {
      for (var P = this._blockOffset; P < this._blockSize; )
        M[P++] = g[O++];
      this._update(), this._blockOffset = 0;
    }
    for (; O < g.length; )
      M[this._blockOffset++] = g[O++];
    for (var D = 0, Z = g.length * 8; Z > 0; ++D)
      this._length[D] += Z, Z = this._length[D] / 4294967296 | 0, Z > 0 && (this._length[D] -= 4294967296 * Z);
    return this;
  }, S.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, S.prototype.digest = function(g) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = !0;
    var B = this._digest();
    g !== void 0 && (B = B.toString(g)), this._block.fill(0), this._blockOffset = 0;
    for (var M = 0; M < 4; ++M)
      this._length[M] = 0;
    return B;
  }, S.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase$1 = S, hashBase$1;
}
var md5_js, hasRequiredMd5_js;
function requireMd5_js() {
  if (hasRequiredMd5_js)
    return md5_js;
  hasRequiredMd5_js = 1;
  var e = requireInherits_browser(), t = requireHashBase$1(), h = requireSafeBuffer$1().Buffer, o = new Array(16);
  function S() {
    t.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
  }
  e(S, t), S.prototype._update = function() {
    for (var D = o, Z = 0; Z < 16; ++Z)
      D[Z] = this._block.readInt32LE(Z * 4);
    var Y = this._a, ee = this._b, ie = this._c, ue = this._d;
    Y = B(Y, ee, ie, ue, D[0], 3614090360, 7), ue = B(ue, Y, ee, ie, D[1], 3905402710, 12), ie = B(ie, ue, Y, ee, D[2], 606105819, 17), ee = B(ee, ie, ue, Y, D[3], 3250441966, 22), Y = B(Y, ee, ie, ue, D[4], 4118548399, 7), ue = B(ue, Y, ee, ie, D[5], 1200080426, 12), ie = B(ie, ue, Y, ee, D[6], 2821735955, 17), ee = B(ee, ie, ue, Y, D[7], 4249261313, 22), Y = B(Y, ee, ie, ue, D[8], 1770035416, 7), ue = B(ue, Y, ee, ie, D[9], 2336552879, 12), ie = B(ie, ue, Y, ee, D[10], 4294925233, 17), ee = B(ee, ie, ue, Y, D[11], 2304563134, 22), Y = B(Y, ee, ie, ue, D[12], 1804603682, 7), ue = B(ue, Y, ee, ie, D[13], 4254626195, 12), ie = B(ie, ue, Y, ee, D[14], 2792965006, 17), ee = B(ee, ie, ue, Y, D[15], 1236535329, 22), Y = M(Y, ee, ie, ue, D[1], 4129170786, 5), ue = M(ue, Y, ee, ie, D[6], 3225465664, 9), ie = M(ie, ue, Y, ee, D[11], 643717713, 14), ee = M(ee, ie, ue, Y, D[0], 3921069994, 20), Y = M(Y, ee, ie, ue, D[5], 3593408605, 5), ue = M(ue, Y, ee, ie, D[10], 38016083, 9), ie = M(ie, ue, Y, ee, D[15], 3634488961, 14), ee = M(ee, ie, ue, Y, D[4], 3889429448, 20), Y = M(Y, ee, ie, ue, D[9], 568446438, 5), ue = M(ue, Y, ee, ie, D[14], 3275163606, 9), ie = M(ie, ue, Y, ee, D[3], 4107603335, 14), ee = M(ee, ie, ue, Y, D[8], 1163531501, 20), Y = M(Y, ee, ie, ue, D[13], 2850285829, 5), ue = M(ue, Y, ee, ie, D[2], 4243563512, 9), ie = M(ie, ue, Y, ee, D[7], 1735328473, 14), ee = M(ee, ie, ue, Y, D[12], 2368359562, 20), Y = O(Y, ee, ie, ue, D[5], 4294588738, 4), ue = O(ue, Y, ee, ie, D[8], 2272392833, 11), ie = O(ie, ue, Y, ee, D[11], 1839030562, 16), ee = O(ee, ie, ue, Y, D[14], 4259657740, 23), Y = O(Y, ee, ie, ue, D[1], 2763975236, 4), ue = O(ue, Y, ee, ie, D[4], 1272893353, 11), ie = O(ie, ue, Y, ee, D[7], 4139469664, 16), ee = O(ee, ie, ue, Y, D[10], 3200236656, 23), Y = O(Y, ee, ie, ue, D[13], 681279174, 4), ue = O(ue, Y, ee, ie, D[0], 3936430074, 11), ie = O(ie, ue, Y, ee, D[3], 3572445317, 16), ee = O(ee, ie, ue, Y, D[6], 76029189, 23), Y = O(Y, ee, ie, ue, D[9], 3654602809, 4), ue = O(ue, Y, ee, ie, D[12], 3873151461, 11), ie = O(ie, ue, Y, ee, D[15], 530742520, 16), ee = O(ee, ie, ue, Y, D[2], 3299628645, 23), Y = P(Y, ee, ie, ue, D[0], 4096336452, 6), ue = P(ue, Y, ee, ie, D[7], 1126891415, 10), ie = P(ie, ue, Y, ee, D[14], 2878612391, 15), ee = P(ee, ie, ue, Y, D[5], 4237533241, 21), Y = P(Y, ee, ie, ue, D[12], 1700485571, 6), ue = P(ue, Y, ee, ie, D[3], 2399980690, 10), ie = P(ie, ue, Y, ee, D[10], 4293915773, 15), ee = P(ee, ie, ue, Y, D[1], 2240044497, 21), Y = P(Y, ee, ie, ue, D[8], 1873313359, 6), ue = P(ue, Y, ee, ie, D[15], 4264355552, 10), ie = P(ie, ue, Y, ee, D[6], 2734768916, 15), ee = P(ee, ie, ue, Y, D[13], 1309151649, 21), Y = P(Y, ee, ie, ue, D[4], 4149444226, 6), ue = P(ue, Y, ee, ie, D[11], 3174756917, 10), ie = P(ie, ue, Y, ee, D[2], 718787259, 15), ee = P(ee, ie, ue, Y, D[9], 3951481745, 21), this._a = this._a + Y | 0, this._b = this._b + ee | 0, this._c = this._c + ie | 0, this._d = this._d + ue | 0;
  }, S.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var D = h.allocUnsafe(16);
    return D.writeInt32LE(this._a, 0), D.writeInt32LE(this._b, 4), D.writeInt32LE(this._c, 8), D.writeInt32LE(this._d, 12), D;
  };
  function g(D, Z) {
    return D << Z | D >>> 32 - Z;
  }
  function B(D, Z, Y, ee, ie, ue, fe) {
    return g(D + (Z & Y | ~Z & ee) + ie + ue | 0, fe) + Z | 0;
  }
  function M(D, Z, Y, ee, ie, ue, fe) {
    return g(D + (Z & ee | Y & ~ee) + ie + ue | 0, fe) + Z | 0;
  }
  function O(D, Z, Y, ee, ie, ue, fe) {
    return g(D + (Z ^ Y ^ ee) + ie + ue | 0, fe) + Z | 0;
  }
  function P(D, Z, Y, ee, ie, ue, fe) {
    return g(D + (Y ^ (Z | ~ee)) + ie + ue | 0, fe) + Z | 0;
  }
  return md5_js = S, md5_js;
}
var hashBase, hasRequiredHashBase;
function requireHashBase() {
  if (hasRequiredHashBase)
    return hashBase;
  hasRequiredHashBase = 1;
  var e = requireSafeBuffer$1().Buffer, t = requireReadableBrowser$1().Transform, h = requireInherits_browser();
  function o(g, B) {
    if (!e.isBuffer(g) && typeof g != "string")
      throw new TypeError(B + " must be a string or a buffer");
  }
  function S(g) {
    t.call(this), this._block = e.allocUnsafe(g), this._blockSize = g, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
  }
  return h(S, t), S.prototype._transform = function(g, B, M) {
    var O = null;
    try {
      this.update(g, B);
    } catch (P) {
      O = P;
    }
    M(O);
  }, S.prototype._flush = function(g) {
    var B = null;
    try {
      this.push(this.digest());
    } catch (M) {
      B = M;
    }
    g(B);
  }, S.prototype.update = function(g, B) {
    if (o(g, "Data"), this._finalized)
      throw new Error("Digest already called");
    e.isBuffer(g) || (g = e.from(g, B));
    for (var M = this._block, O = 0; this._blockOffset + g.length - O >= this._blockSize; ) {
      for (var P = this._blockOffset; P < this._blockSize; )
        M[P++] = g[O++];
      this._update(), this._blockOffset = 0;
    }
    for (; O < g.length; )
      M[this._blockOffset++] = g[O++];
    for (var D = 0, Z = g.length * 8; Z > 0; ++D)
      this._length[D] += Z, Z = this._length[D] / 4294967296 | 0, Z > 0 && (this._length[D] -= 4294967296 * Z);
    return this;
  }, S.prototype._update = function() {
    throw new Error("_update is not implemented");
  }, S.prototype.digest = function(g) {
    if (this._finalized)
      throw new Error("Digest already called");
    this._finalized = !0;
    var B = this._digest();
    g !== void 0 && (B = B.toString(g)), this._block.fill(0), this._blockOffset = 0;
    for (var M = 0; M < 4; ++M)
      this._length[M] = 0;
    return B;
  }, S.prototype._digest = function() {
    throw new Error("_digest is not implemented");
  }, hashBase = S, hashBase;
}
var ripemd160, hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160)
    return ripemd160;
  hasRequiredRipemd160 = 1;
  var e = requireBuffer$1().Buffer, t = requireInherits_browser(), h = requireHashBase(), o = new Array(16), S = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], g = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], B = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], M = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ], O = [0, 1518500249, 1859775393, 2400959708, 2840853838], P = [1352829926, 1548603684, 1836072691, 2053994217, 0];
  function D() {
    h.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
  }
  t(D, h), D.prototype._update = function() {
    for (var de = o, ce = 0; ce < 16; ++ce)
      de[ce] = this._block.readInt32LE(ce * 4);
    for (var be = this._a | 0, ve = this._b | 0, Pe = this._c | 0, Ue = this._d | 0, ze = this._e | 0, Le = this._a | 0, Ne = this._b | 0, $e = this._c | 0, J = this._d | 0, ne = this._e | 0, A = 0; A < 80; A += 1) {
      var I, U;
      A < 16 ? (I = Y(be, ve, Pe, Ue, ze, de[S[A]], O[0], B[A]), U = fe(Le, Ne, $e, J, ne, de[g[A]], P[0], M[A])) : A < 32 ? (I = ee(be, ve, Pe, Ue, ze, de[S[A]], O[1], B[A]), U = ue(Le, Ne, $e, J, ne, de[g[A]], P[1], M[A])) : A < 48 ? (I = ie(be, ve, Pe, Ue, ze, de[S[A]], O[2], B[A]), U = ie(Le, Ne, $e, J, ne, de[g[A]], P[2], M[A])) : A < 64 ? (I = ue(be, ve, Pe, Ue, ze, de[S[A]], O[3], B[A]), U = ee(Le, Ne, $e, J, ne, de[g[A]], P[3], M[A])) : (I = fe(be, ve, Pe, Ue, ze, de[S[A]], O[4], B[A]), U = Y(Le, Ne, $e, J, ne, de[g[A]], P[4], M[A])), be = ze, ze = Ue, Ue = Z(Pe, 10), Pe = ve, ve = I, Le = ne, ne = J, J = Z($e, 10), $e = Ne, Ne = U;
    }
    var X = this._b + Pe + J | 0;
    this._b = this._c + Ue + ne | 0, this._c = this._d + ze + Le | 0, this._d = this._e + be + Ne | 0, this._e = this._a + ve + $e | 0, this._a = X;
  }, D.prototype._digest = function() {
    this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
    var de = e.alloc ? e.alloc(20) : new e(20);
    return de.writeInt32LE(this._a, 0), de.writeInt32LE(this._b, 4), de.writeInt32LE(this._c, 8), de.writeInt32LE(this._d, 12), de.writeInt32LE(this._e, 16), de;
  };
  function Z(de, ce) {
    return de << ce | de >>> 32 - ce;
  }
  function Y(de, ce, be, ve, Pe, Ue, ze, Le) {
    return Z(de + (ce ^ be ^ ve) + Ue + ze | 0, Le) + Pe | 0;
  }
  function ee(de, ce, be, ve, Pe, Ue, ze, Le) {
    return Z(de + (ce & be | ~ce & ve) + Ue + ze | 0, Le) + Pe | 0;
  }
  function ie(de, ce, be, ve, Pe, Ue, ze, Le) {
    return Z(de + ((ce | ~be) ^ ve) + Ue + ze | 0, Le) + Pe | 0;
  }
  function ue(de, ce, be, ve, Pe, Ue, ze, Le) {
    return Z(de + (ce & ve | be & ~ve) + Ue + ze | 0, Le) + Pe | 0;
  }
  function fe(de, ce, be, ve, Pe, Ue, ze, Le) {
    return Z(de + (ce ^ (be | ~ve)) + Ue + ze | 0, Le) + Pe | 0;
  }
  return ripemd160 = D, ripemd160;
}
var sha_js = { exports: {} }, hash$1, hasRequiredHash$1;
function requireHash$1() {
  if (hasRequiredHash$1)
    return hash$1;
  hasRequiredHash$1 = 1;
  var e = requireSafeBuffer$1().Buffer;
  function t(h, o) {
    this._block = e.alloc(h), this._finalSize = o, this._blockSize = h, this._len = 0;
  }
  return t.prototype.update = function(h, o) {
    typeof h == "string" && (o = o || "utf8", h = e.from(h, o));
    for (var S = this._block, g = this._blockSize, B = h.length, M = this._len, O = 0; O < B; ) {
      for (var P = M % g, D = Math.min(B - O, g - P), Z = 0; Z < D; Z++)
        S[P + Z] = h[O + Z];
      M += D, O += D, M % g === 0 && this._update(S);
    }
    return this._len += B, this;
  }, t.prototype.digest = function(h) {
    var o = this._len % this._blockSize;
    this._block[o] = 128, this._block.fill(0, o + 1), o >= this._finalSize && (this._update(this._block), this._block.fill(0));
    var S = this._len * 8;
    if (S <= 4294967295)
      this._block.writeUInt32BE(S, this._blockSize - 4);
    else {
      var g = (S & 4294967295) >>> 0, B = (S - g) / 4294967296;
      this._block.writeUInt32BE(B, this._blockSize - 8), this._block.writeUInt32BE(g, this._blockSize - 4);
    }
    this._update(this._block);
    var M = this._hash();
    return h ? M.toString(h) : M;
  }, t.prototype._update = function() {
    throw new Error("_update must be implemented by subclass");
  }, hash$1 = t, hash$1;
}
var sha$1, hasRequiredSha$1;
function requireSha$1() {
  if (hasRequiredSha$1)
    return sha$1;
  hasRequiredSha$1 = 1;
  var e = requireInherits_browser(), t = requireHash$1(), h = requireSafeBuffer$1().Buffer, o = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], S = new Array(80);
  function g() {
    this.init(), this._w = S, t.call(this, 64, 56);
  }
  e(g, t), g.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function B(P) {
    return P << 5 | P >>> 27;
  }
  function M(P) {
    return P << 30 | P >>> 2;
  }
  function O(P, D, Z, Y) {
    return P === 0 ? D & Z | ~D & Y : P === 2 ? D & Z | D & Y | Z & Y : D ^ Z ^ Y;
  }
  return g.prototype._update = function(P) {
    for (var D = this._w, Z = this._a | 0, Y = this._b | 0, ee = this._c | 0, ie = this._d | 0, ue = this._e | 0, fe = 0; fe < 16; ++fe)
      D[fe] = P.readInt32BE(fe * 4);
    for (; fe < 80; ++fe)
      D[fe] = D[fe - 3] ^ D[fe - 8] ^ D[fe - 14] ^ D[fe - 16];
    for (var de = 0; de < 80; ++de) {
      var ce = ~~(de / 20), be = B(Z) + O(ce, Y, ee, ie) + ue + D[de] + o[ce] | 0;
      ue = ie, ie = ee, ee = M(Y), Y = Z, Z = be;
    }
    this._a = Z + this._a | 0, this._b = Y + this._b | 0, this._c = ee + this._c | 0, this._d = ie + this._d | 0, this._e = ue + this._e | 0;
  }, g.prototype._hash = function() {
    var P = h.allocUnsafe(20);
    return P.writeInt32BE(this._a | 0, 0), P.writeInt32BE(this._b | 0, 4), P.writeInt32BE(this._c | 0, 8), P.writeInt32BE(this._d | 0, 12), P.writeInt32BE(this._e | 0, 16), P;
  }, sha$1 = g, sha$1;
}
var sha1, hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1)
    return sha1;
  hasRequiredSha1 = 1;
  var e = requireInherits_browser(), t = requireHash$1(), h = requireSafeBuffer$1().Buffer, o = [
    1518500249,
    1859775393,
    -1894007588,
    -899497514
  ], S = new Array(80);
  function g() {
    this.init(), this._w = S, t.call(this, 64, 56);
  }
  e(g, t), g.prototype.init = function() {
    return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
  };
  function B(D) {
    return D << 1 | D >>> 31;
  }
  function M(D) {
    return D << 5 | D >>> 27;
  }
  function O(D) {
    return D << 30 | D >>> 2;
  }
  function P(D, Z, Y, ee) {
    return D === 0 ? Z & Y | ~Z & ee : D === 2 ? Z & Y | Z & ee | Y & ee : Z ^ Y ^ ee;
  }
  return g.prototype._update = function(D) {
    for (var Z = this._w, Y = this._a | 0, ee = this._b | 0, ie = this._c | 0, ue = this._d | 0, fe = this._e | 0, de = 0; de < 16; ++de)
      Z[de] = D.readInt32BE(de * 4);
    for (; de < 80; ++de)
      Z[de] = B(Z[de - 3] ^ Z[de - 8] ^ Z[de - 14] ^ Z[de - 16]);
    for (var ce = 0; ce < 80; ++ce) {
      var be = ~~(ce / 20), ve = M(Y) + P(be, ee, ie, ue) + fe + Z[ce] + o[be] | 0;
      fe = ue, ue = ie, ie = O(ee), ee = Y, Y = ve;
    }
    this._a = Y + this._a | 0, this._b = ee + this._b | 0, this._c = ie + this._c | 0, this._d = ue + this._d | 0, this._e = fe + this._e | 0;
  }, g.prototype._hash = function() {
    var D = h.allocUnsafe(20);
    return D.writeInt32BE(this._a | 0, 0), D.writeInt32BE(this._b | 0, 4), D.writeInt32BE(this._c | 0, 8), D.writeInt32BE(this._d | 0, 12), D.writeInt32BE(this._e | 0, 16), D;
  }, sha1 = g, sha1;
}
var sha256$1, hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256)
    return sha256$1;
  hasRequiredSha256 = 1;
  var e = requireInherits_browser(), t = requireHash$1(), h = requireSafeBuffer$1().Buffer, o = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], S = new Array(64);
  function g() {
    this.init(), this._w = S, t.call(this, 64, 56);
  }
  e(g, t), g.prototype.init = function() {
    return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
  };
  function B(Y, ee, ie) {
    return ie ^ Y & (ee ^ ie);
  }
  function M(Y, ee, ie) {
    return Y & ee | ie & (Y | ee);
  }
  function O(Y) {
    return (Y >>> 2 | Y << 30) ^ (Y >>> 13 | Y << 19) ^ (Y >>> 22 | Y << 10);
  }
  function P(Y) {
    return (Y >>> 6 | Y << 26) ^ (Y >>> 11 | Y << 21) ^ (Y >>> 25 | Y << 7);
  }
  function D(Y) {
    return (Y >>> 7 | Y << 25) ^ (Y >>> 18 | Y << 14) ^ Y >>> 3;
  }
  function Z(Y) {
    return (Y >>> 17 | Y << 15) ^ (Y >>> 19 | Y << 13) ^ Y >>> 10;
  }
  return g.prototype._update = function(Y) {
    for (var ee = this._w, ie = this._a | 0, ue = this._b | 0, fe = this._c | 0, de = this._d | 0, ce = this._e | 0, be = this._f | 0, ve = this._g | 0, Pe = this._h | 0, Ue = 0; Ue < 16; ++Ue)
      ee[Ue] = Y.readInt32BE(Ue * 4);
    for (; Ue < 64; ++Ue)
      ee[Ue] = Z(ee[Ue - 2]) + ee[Ue - 7] + D(ee[Ue - 15]) + ee[Ue - 16] | 0;
    for (var ze = 0; ze < 64; ++ze) {
      var Le = Pe + P(ce) + B(ce, be, ve) + o[ze] + ee[ze] | 0, Ne = O(ie) + M(ie, ue, fe) | 0;
      Pe = ve, ve = be, be = ce, ce = de + Le | 0, de = fe, fe = ue, ue = ie, ie = Le + Ne | 0;
    }
    this._a = ie + this._a | 0, this._b = ue + this._b | 0, this._c = fe + this._c | 0, this._d = de + this._d | 0, this._e = ce + this._e | 0, this._f = be + this._f | 0, this._g = ve + this._g | 0, this._h = Pe + this._h | 0;
  }, g.prototype._hash = function() {
    var Y = h.allocUnsafe(32);
    return Y.writeInt32BE(this._a, 0), Y.writeInt32BE(this._b, 4), Y.writeInt32BE(this._c, 8), Y.writeInt32BE(this._d, 12), Y.writeInt32BE(this._e, 16), Y.writeInt32BE(this._f, 20), Y.writeInt32BE(this._g, 24), Y.writeInt32BE(this._h, 28), Y;
  }, sha256$1 = g, sha256$1;
}
var sha224$1, hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224)
    return sha224$1;
  hasRequiredSha224 = 1;
  var e = requireInherits_browser(), t = requireSha256(), h = requireHash$1(), o = requireSafeBuffer$1().Buffer, S = new Array(64);
  function g() {
    this.init(), this._w = S, h.call(this, 64, 56);
  }
  return e(g, t), g.prototype.init = function() {
    return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
  }, g.prototype._hash = function() {
    var B = o.allocUnsafe(28);
    return B.writeInt32BE(this._a, 0), B.writeInt32BE(this._b, 4), B.writeInt32BE(this._c, 8), B.writeInt32BE(this._d, 12), B.writeInt32BE(this._e, 16), B.writeInt32BE(this._f, 20), B.writeInt32BE(this._g, 24), B;
  }, sha224$1 = g, sha224$1;
}
var sha512$1, hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512)
    return sha512$1;
  hasRequiredSha512 = 1;
  var e = requireInherits_browser(), t = requireHash$1(), h = requireSafeBuffer$1().Buffer, o = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ], S = new Array(160);
  function g() {
    this.init(), this._w = S, t.call(this, 128, 112);
  }
  e(g, t), g.prototype.init = function() {
    return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
  };
  function B(ue, fe, de) {
    return de ^ ue & (fe ^ de);
  }
  function M(ue, fe, de) {
    return ue & fe | de & (ue | fe);
  }
  function O(ue, fe) {
    return (ue >>> 28 | fe << 4) ^ (fe >>> 2 | ue << 30) ^ (fe >>> 7 | ue << 25);
  }
  function P(ue, fe) {
    return (ue >>> 14 | fe << 18) ^ (ue >>> 18 | fe << 14) ^ (fe >>> 9 | ue << 23);
  }
  function D(ue, fe) {
    return (ue >>> 1 | fe << 31) ^ (ue >>> 8 | fe << 24) ^ ue >>> 7;
  }
  function Z(ue, fe) {
    return (ue >>> 1 | fe << 31) ^ (ue >>> 8 | fe << 24) ^ (ue >>> 7 | fe << 25);
  }
  function Y(ue, fe) {
    return (ue >>> 19 | fe << 13) ^ (fe >>> 29 | ue << 3) ^ ue >>> 6;
  }
  function ee(ue, fe) {
    return (ue >>> 19 | fe << 13) ^ (fe >>> 29 | ue << 3) ^ (ue >>> 6 | fe << 26);
  }
  function ie(ue, fe) {
    return ue >>> 0 < fe >>> 0 ? 1 : 0;
  }
  return g.prototype._update = function(ue) {
    for (var fe = this._w, de = this._ah | 0, ce = this._bh | 0, be = this._ch | 0, ve = this._dh | 0, Pe = this._eh | 0, Ue = this._fh | 0, ze = this._gh | 0, Le = this._hh | 0, Ne = this._al | 0, $e = this._bl | 0, J = this._cl | 0, ne = this._dl | 0, A = this._el | 0, I = this._fl | 0, U = this._gl | 0, X = this._hl | 0, Q = 0; Q < 32; Q += 2)
      fe[Q] = ue.readInt32BE(Q * 4), fe[Q + 1] = ue.readInt32BE(Q * 4 + 4);
    for (; Q < 160; Q += 2) {
      var F = fe[Q - 30], $ = fe[Q - 15 * 2 + 1], H = D(F, $), q = Z($, F);
      F = fe[Q - 2 * 2], $ = fe[Q - 2 * 2 + 1];
      var z = Y(F, $), me = ee($, F), Ce = fe[Q - 7 * 2], je = fe[Q - 7 * 2 + 1], Re = fe[Q - 16 * 2], Ae = fe[Q - 16 * 2 + 1], ke = q + je | 0, Qe = H + Ce + ie(ke, q) | 0;
      ke = ke + me | 0, Qe = Qe + z + ie(ke, me) | 0, ke = ke + Ae | 0, Qe = Qe + Re + ie(ke, Ae) | 0, fe[Q] = Qe, fe[Q + 1] = ke;
    }
    for (var Ze = 0; Ze < 160; Ze += 2) {
      Qe = fe[Ze], ke = fe[Ze + 1];
      var qe = M(de, ce, be), Oe = M(Ne, $e, J), Xe = O(de, Ne), et = O(Ne, de), nt = P(Pe, A), re = P(A, Pe), oe = o[Ze], le = o[Ze + 1], ge = B(Pe, Ue, ze), Ke = B(A, I, U), Je = X + re | 0, Fe = Le + nt + ie(Je, X) | 0;
      Je = Je + Ke | 0, Fe = Fe + ge + ie(Je, Ke) | 0, Je = Je + le | 0, Fe = Fe + oe + ie(Je, le) | 0, Je = Je + ke | 0, Fe = Fe + Qe + ie(Je, ke) | 0;
      var Ye = et + Oe | 0, it = Xe + qe + ie(Ye, et) | 0;
      Le = ze, X = U, ze = Ue, U = I, Ue = Pe, I = A, A = ne + Je | 0, Pe = ve + Fe + ie(A, ne) | 0, ve = be, ne = J, be = ce, J = $e, ce = de, $e = Ne, Ne = Je + Ye | 0, de = Fe + it + ie(Ne, Je) | 0;
    }
    this._al = this._al + Ne | 0, this._bl = this._bl + $e | 0, this._cl = this._cl + J | 0, this._dl = this._dl + ne | 0, this._el = this._el + A | 0, this._fl = this._fl + I | 0, this._gl = this._gl + U | 0, this._hl = this._hl + X | 0, this._ah = this._ah + de + ie(this._al, Ne) | 0, this._bh = this._bh + ce + ie(this._bl, $e) | 0, this._ch = this._ch + be + ie(this._cl, J) | 0, this._dh = this._dh + ve + ie(this._dl, ne) | 0, this._eh = this._eh + Pe + ie(this._el, A) | 0, this._fh = this._fh + Ue + ie(this._fl, I) | 0, this._gh = this._gh + ze + ie(this._gl, U) | 0, this._hh = this._hh + Le + ie(this._hl, X) | 0;
  }, g.prototype._hash = function() {
    var ue = h.allocUnsafe(64);
    function fe(de, ce, be) {
      ue.writeInt32BE(de, be), ue.writeInt32BE(ce, be + 4);
    }
    return fe(this._ah, this._al, 0), fe(this._bh, this._bl, 8), fe(this._ch, this._cl, 16), fe(this._dh, this._dl, 24), fe(this._eh, this._el, 32), fe(this._fh, this._fl, 40), fe(this._gh, this._gl, 48), fe(this._hh, this._hl, 56), ue;
  }, sha512$1 = g, sha512$1;
}
var sha384$1, hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384)
    return sha384$1;
  hasRequiredSha384 = 1;
  var e = requireInherits_browser(), t = requireSha512(), h = requireHash$1(), o = requireSafeBuffer$1().Buffer, S = new Array(160);
  function g() {
    this.init(), this._w = S, h.call(this, 128, 112);
  }
  return e(g, t), g.prototype.init = function() {
    return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
  }, g.prototype._hash = function() {
    var B = o.allocUnsafe(48);
    function M(O, P, D) {
      B.writeInt32BE(O, D), B.writeInt32BE(P, D + 4);
    }
    return M(this._ah, this._al, 0), M(this._bh, this._bl, 8), M(this._ch, this._cl, 16), M(this._dh, this._dl, 24), M(this._eh, this._el, 32), M(this._fh, this._fl, 40), B;
  }, sha384$1 = g, sha384$1;
}
var hasRequiredSha_js;
function requireSha_js() {
  if (hasRequiredSha_js)
    return sha_js.exports;
  hasRequiredSha_js = 1;
  var e = sha_js.exports = function(t) {
    t = t.toLowerCase();
    var h = e[t];
    if (!h)
      throw new Error(t + " is not supported (we accept pull requests)");
    return new h();
  };
  return e.sha = requireSha$1(), e.sha1 = requireSha1(), e.sha224 = requireSha224(), e.sha256 = requireSha256(), e.sha384 = requireSha384(), e.sha512 = requireSha512(), sha_js.exports;
}
var streamBrowserify, hasRequiredStreamBrowserify;
function requireStreamBrowserify() {
  if (hasRequiredStreamBrowserify)
    return streamBrowserify;
  hasRequiredStreamBrowserify = 1, streamBrowserify = h;
  var e = requireEvents().EventEmitter, t = requireInherits_browser();
  t(h, e), h.Readable = require_stream_readable$1(), h.Writable = require_stream_writable$1(), h.Duplex = require_stream_duplex$1(), h.Transform = require_stream_transform$1(), h.PassThrough = require_stream_passthrough$1(), h.finished = requireEndOfStream(), h.pipeline = requirePipeline(), h.Stream = h;
  function h() {
    e.call(this);
  }
  return h.prototype.pipe = function(o, S) {
    var g = this;
    function B(ee) {
      o.writable && o.write(ee) === !1 && g.pause && g.pause();
    }
    g.on("data", B);
    function M() {
      g.readable && g.resume && g.resume();
    }
    o.on("drain", M), !o._isStdio && (!S || S.end !== !1) && (g.on("end", P), g.on("close", D));
    var O = !1;
    function P() {
      O || (O = !0, o.end());
    }
    function D() {
      O || (O = !0, typeof o.destroy == "function" && o.destroy());
    }
    function Z(ee) {
      if (Y(), e.listenerCount(this, "error") === 0)
        throw ee;
    }
    g.on("error", Z), o.on("error", Z);
    function Y() {
      g.removeListener("data", B), o.removeListener("drain", M), g.removeListener("end", P), g.removeListener("close", D), g.removeListener("error", Z), o.removeListener("error", Z), g.removeListener("end", Y), g.removeListener("close", Y), o.removeListener("close", Y);
    }
    return g.on("end", Y), g.on("close", Y), o.on("close", Y), o.emit("pipe", g), o;
  }, streamBrowserify;
}
var cipherBase, hasRequiredCipherBase;
function requireCipherBase() {
  if (hasRequiredCipherBase)
    return cipherBase;
  hasRequiredCipherBase = 1;
  var e = requireSafeBuffer$1().Buffer, t = requireStreamBrowserify().Transform, h = requireString_decoder().StringDecoder, o = requireInherits_browser();
  function S(g) {
    t.call(this), this.hashMode = typeof g == "string", this.hashMode ? this[g] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
  }
  return o(S, t), S.prototype.update = function(g, B, M) {
    typeof g == "string" && (g = e.from(g, B));
    var O = this._update(g);
    return this.hashMode ? this : (M && (O = this._toString(O, M)), O);
  }, S.prototype.setAutoPadding = function() {
  }, S.prototype.getAuthTag = function() {
    throw new Error("trying to get auth tag in unsupported state");
  }, S.prototype.setAuthTag = function() {
    throw new Error("trying to set auth tag in unsupported state");
  }, S.prototype.setAAD = function() {
    throw new Error("trying to set aad in unsupported state");
  }, S.prototype._transform = function(g, B, M) {
    var O;
    try {
      this.hashMode ? this._update(g) : this.push(this._update(g));
    } catch (P) {
      O = P;
    } finally {
      M(O);
    }
  }, S.prototype._flush = function(g) {
    var B;
    try {
      this.push(this.__final());
    } catch (M) {
      B = M;
    }
    g(B);
  }, S.prototype._finalOrDigest = function(g) {
    var B = this.__final() || e.alloc(0);
    return g && (B = this._toString(B, g, !0)), B;
  }, S.prototype._toString = function(g, B, M) {
    if (this._decoder || (this._decoder = new h(B), this._encoding = B), this._encoding !== B)
      throw new Error("can't switch encodings");
    var O = this._decoder.write(g);
    return M && (O += this._decoder.end()), O;
  }, cipherBase = S, cipherBase;
}
var browser$9, hasRequiredBrowser$9;
function requireBrowser$9() {
  if (hasRequiredBrowser$9)
    return browser$9;
  hasRequiredBrowser$9 = 1;
  var e = requireInherits_browser(), t = requireMd5_js(), h = requireRipemd160(), o = requireSha_js(), S = requireCipherBase();
  function g(B) {
    S.call(this, "digest"), this._hash = B;
  }
  return e(g, S), g.prototype._update = function(B) {
    this._hash.update(B);
  }, g.prototype._final = function() {
    return this._hash.digest();
  }, browser$9 = function(B) {
    return B = B.toLowerCase(), B === "md5" ? new t() : B === "rmd160" || B === "ripemd160" ? new h() : new g(o(B));
  }, browser$9;
}
var legacy, hasRequiredLegacy;
function requireLegacy() {
  if (hasRequiredLegacy)
    return legacy;
  hasRequiredLegacy = 1;
  var e = requireInherits_browser(), t = requireSafeBuffer$1().Buffer, h = requireCipherBase(), o = t.alloc(128), S = 64;
  function g(B, M) {
    h.call(this, "digest"), typeof M == "string" && (M = t.from(M)), this._alg = B, this._key = M, M.length > S ? M = B(M) : M.length < S && (M = t.concat([M, o], S));
    for (var O = this._ipad = t.allocUnsafe(S), P = this._opad = t.allocUnsafe(S), D = 0; D < S; D++)
      O[D] = M[D] ^ 54, P[D] = M[D] ^ 92;
    this._hash = [O];
  }
  return e(g, h), g.prototype._update = function(B) {
    this._hash.push(B);
  }, g.prototype._final = function() {
    var B = this._alg(t.concat(this._hash));
    return this._alg(t.concat([this._opad, B]));
  }, legacy = g, legacy;
}
var md5, hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5)
    return md5;
  hasRequiredMd5 = 1;
  var e = requireMd5_js();
  return md5 = function(t) {
    return new e().update(t).digest();
  }, md5;
}
var browser$8, hasRequiredBrowser$8;
function requireBrowser$8() {
  if (hasRequiredBrowser$8)
    return browser$8;
  hasRequiredBrowser$8 = 1;
  var e = requireInherits_browser(), t = requireLegacy(), h = requireCipherBase(), o = requireSafeBuffer$1().Buffer, S = requireMd5(), g = requireRipemd160(), B = requireSha_js(), M = o.alloc(128);
  function O(P, D) {
    h.call(this, "digest"), typeof D == "string" && (D = o.from(D));
    var Z = P === "sha512" || P === "sha384" ? 128 : 64;
    if (this._alg = P, this._key = D, D.length > Z) {
      var Y = P === "rmd160" ? new g() : B(P);
      D = Y.update(D).digest();
    } else
      D.length < Z && (D = o.concat([D, M], Z));
    for (var ee = this._ipad = o.allocUnsafe(Z), ie = this._opad = o.allocUnsafe(Z), ue = 0; ue < Z; ue++)
      ee[ue] = D[ue] ^ 54, ie[ue] = D[ue] ^ 92;
    this._hash = P === "rmd160" ? new g() : B(P), this._hash.update(ee);
  }
  return e(O, h), O.prototype._update = function(P) {
    this._hash.update(P);
  }, O.prototype._final = function() {
    var P = this._hash.digest(), D = this._alg === "rmd160" ? new g() : B(this._alg);
    return D.update(this._opad).update(P).digest();
  }, browser$8 = function(P, D) {
    return P = P.toLowerCase(), P === "rmd160" || P === "ripemd160" ? new O("rmd160", D) : P === "md5" ? new t(S, D) : new O(P, D);
  }, browser$8;
}
const sha224WithRSAEncryption = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, sha256WithRSAEncryption = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, sha384WithRSAEncryption = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, sha512WithRSAEncryption = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, sha256 = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, sha224 = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, sha384 = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, sha512 = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, DSA = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, ripemd160WithRSA = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, md5WithRSAEncryption = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, require$$6 = {
  sha224WithRSAEncryption,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256,
  sha224,
  sha384,
  sha512,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var algos, hasRequiredAlgos;
function requireAlgos() {
  return hasRequiredAlgos || (hasRequiredAlgos = 1, algos = require$$6), algos;
}
var browser$7 = {}, precondition, hasRequiredPrecondition;
function requirePrecondition() {
  if (hasRequiredPrecondition)
    return precondition;
  hasRequiredPrecondition = 1;
  var e = Math.pow(2, 30) - 1;
  return precondition = function(t, h) {
    if (typeof t != "number")
      throw new TypeError("Iterations not a number");
    if (t < 0)
      throw new TypeError("Bad iterations");
    if (typeof h != "number")
      throw new TypeError("Key length not a number");
    if (h < 0 || h > e || h !== h)
      throw new TypeError("Bad key length");
  }, precondition;
}
var defaultEncoding_1, hasRequiredDefaultEncoding;
function requireDefaultEncoding() {
  if (hasRequiredDefaultEncoding)
    return defaultEncoding_1;
  hasRequiredDefaultEncoding = 1;
  var e;
  if (commonjsGlobal.process && commonjsGlobal.process.browser)
    e = "utf-8";
  else if (commonjsGlobal.process && commonjsGlobal.process.version) {
    var t = parseInt(process$1.version.split(".")[0].slice(1), 10);
    e = t >= 6 ? "utf-8" : "binary";
  } else
    e = "utf-8";
  return defaultEncoding_1 = e, defaultEncoding_1;
}
var toBuffer, hasRequiredToBuffer;
function requireToBuffer() {
  if (hasRequiredToBuffer)
    return toBuffer;
  hasRequiredToBuffer = 1;
  var e = requireSafeBuffer$1().Buffer;
  return toBuffer = function(t, h, o) {
    if (e.isBuffer(t))
      return t;
    if (typeof t == "string")
      return e.from(t, h);
    if (ArrayBuffer.isView(t))
      return e.from(t.buffer);
    throw new TypeError(o + " must be a string, a Buffer, a typed array or a DataView");
  }, toBuffer;
}
var syncBrowser, hasRequiredSyncBrowser;
function requireSyncBrowser() {
  if (hasRequiredSyncBrowser)
    return syncBrowser;
  hasRequiredSyncBrowser = 1;
  var e = requireMd5(), t = requireRipemd160(), h = requireSha_js(), o = requireSafeBuffer$1().Buffer, S = requirePrecondition(), g = requireDefaultEncoding(), B = requireToBuffer(), M = o.alloc(128), O = {
    md5: 16,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64,
    rmd160: 20,
    ripemd160: 20
  };
  function P(Y, ee, ie) {
    var ue = D(Y), fe = Y === "sha512" || Y === "sha384" ? 128 : 64;
    ee.length > fe ? ee = ue(ee) : ee.length < fe && (ee = o.concat([ee, M], fe));
    for (var de = o.allocUnsafe(fe + O[Y]), ce = o.allocUnsafe(fe + O[Y]), be = 0; be < fe; be++)
      de[be] = ee[be] ^ 54, ce[be] = ee[be] ^ 92;
    var ve = o.allocUnsafe(fe + ie + 4);
    de.copy(ve, 0, 0, fe), this.ipad1 = ve, this.ipad2 = de, this.opad = ce, this.alg = Y, this.blocksize = fe, this.hash = ue, this.size = O[Y];
  }
  P.prototype.run = function(Y, ee) {
    Y.copy(ee, this.blocksize);
    var ie = this.hash(ee);
    return ie.copy(this.opad, this.blocksize), this.hash(this.opad);
  };
  function D(Y) {
    function ee(ue) {
      return h(Y).update(ue).digest();
    }
    function ie(ue) {
      return new t().update(ue).digest();
    }
    return Y === "rmd160" || Y === "ripemd160" ? ie : Y === "md5" ? e : ee;
  }
  function Z(Y, ee, ie, ue, fe) {
    S(ie, ue), Y = B(Y, g, "Password"), ee = B(ee, g, "Salt"), fe = fe || "sha1";
    var de = new P(fe, Y, ee.length), ce = o.allocUnsafe(ue), be = o.allocUnsafe(ee.length + 4);
    ee.copy(be, 0, 0, ee.length);
    for (var ve = 0, Pe = O[fe], Ue = Math.ceil(ue / Pe), ze = 1; ze <= Ue; ze++) {
      be.writeUInt32BE(ze, ee.length);
      for (var Le = de.run(be, de.ipad1), Ne = Le, $e = 1; $e < ie; $e++) {
        Ne = de.run(Ne, de.ipad2);
        for (var J = 0; J < Pe; J++)
          Le[J] ^= Ne[J];
      }
      Le.copy(ce, ve), ve += Pe;
    }
    return ce;
  }
  return syncBrowser = Z, syncBrowser;
}
var async, hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync)
    return async;
  hasRequiredAsync = 1;
  var e = requireSafeBuffer$1().Buffer, t = requirePrecondition(), h = requireDefaultEncoding(), o = requireSyncBrowser(), S = requireToBuffer(), g, B = commonjsGlobal.crypto && commonjsGlobal.crypto.subtle, M = {
    sha: "SHA-1",
    "sha-1": "SHA-1",
    sha1: "SHA-1",
    sha256: "SHA-256",
    "sha-256": "SHA-256",
    sha384: "SHA-384",
    "sha-384": "SHA-384",
    "sha-512": "SHA-512",
    sha512: "SHA-512"
  }, O = [];
  function P(ie) {
    if (commonjsGlobal.process && !commonjsGlobal.process.browser || !B || !B.importKey || !B.deriveBits)
      return Promise.resolve(!1);
    if (O[ie] !== void 0)
      return O[ie];
    g = g || e.alloc(8);
    var ue = Y(g, g, 10, 128, ie).then(function() {
      return !0;
    }).catch(function() {
      return !1;
    });
    return O[ie] = ue, ue;
  }
  var D;
  function Z() {
    return D || (commonjsGlobal.process && commonjsGlobal.process.nextTick ? D = commonjsGlobal.process.nextTick : commonjsGlobal.queueMicrotask ? D = commonjsGlobal.queueMicrotask : commonjsGlobal.setImmediate ? D = commonjsGlobal.setImmediate : D = commonjsGlobal.setTimeout, D);
  }
  function Y(ie, ue, fe, de, ce) {
    return B.importKey(
      "raw",
      ie,
      { name: "PBKDF2" },
      !1,
      ["deriveBits"]
    ).then(function(be) {
      return B.deriveBits({
        name: "PBKDF2",
        salt: ue,
        iterations: fe,
        hash: {
          name: ce
        }
      }, be, de << 3);
    }).then(function(be) {
      return e.from(be);
    });
  }
  function ee(ie, ue) {
    ie.then(function(fe) {
      Z()(function() {
        ue(null, fe);
      });
    }, function(fe) {
      Z()(function() {
        ue(fe);
      });
    });
  }
  return async = function(ie, ue, fe, de, ce, be) {
    typeof ce == "function" && (be = ce, ce = void 0), ce = ce || "sha1";
    var ve = M[ce.toLowerCase()];
    if (!ve || typeof commonjsGlobal.Promise != "function") {
      Z()(function() {
        var Pe;
        try {
          Pe = o(ie, ue, fe, de, ce);
        } catch (Ue) {
          return be(Ue);
        }
        be(null, Pe);
      });
      return;
    }
    if (t(fe, de), ie = S(ie, h, "Password"), ue = S(ue, h, "Salt"), typeof be != "function")
      throw new Error("No callback provided to pbkdf2");
    ee(P(ve).then(function(Pe) {
      return Pe ? Y(ie, ue, fe, de, ve) : o(ie, ue, fe, de, ce);
    }), be);
  }, async;
}
var hasRequiredBrowser$7;
function requireBrowser$7() {
  return hasRequiredBrowser$7 || (hasRequiredBrowser$7 = 1, browser$7.pbkdf2 = requireAsync(), browser$7.pbkdf2Sync = requireSyncBrowser()), browser$7;
}
var browser$6 = {}, des$1 = {}, utils$3 = {}, hasRequiredUtils$3;
function requireUtils$3() {
  if (hasRequiredUtils$3)
    return utils$3;
  hasRequiredUtils$3 = 1, utils$3.readUInt32BE = function(o, S) {
    var g = o[0 + S] << 24 | o[1 + S] << 16 | o[2 + S] << 8 | o[3 + S];
    return g >>> 0;
  }, utils$3.writeUInt32BE = function(o, S, g) {
    o[0 + g] = S >>> 24, o[1 + g] = S >>> 16 & 255, o[2 + g] = S >>> 8 & 255, o[3 + g] = S & 255;
  }, utils$3.ip = function(o, S, g, B) {
    for (var M = 0, O = 0, P = 6; P >= 0; P -= 2) {
      for (var D = 0; D <= 24; D += 8)
        M <<= 1, M |= S >>> D + P & 1;
      for (var D = 0; D <= 24; D += 8)
        M <<= 1, M |= o >>> D + P & 1;
    }
    for (var P = 6; P >= 0; P -= 2) {
      for (var D = 1; D <= 25; D += 8)
        O <<= 1, O |= S >>> D + P & 1;
      for (var D = 1; D <= 25; D += 8)
        O <<= 1, O |= o >>> D + P & 1;
    }
    g[B + 0] = M >>> 0, g[B + 1] = O >>> 0;
  }, utils$3.rip = function(o, S, g, B) {
    for (var M = 0, O = 0, P = 0; P < 4; P++)
      for (var D = 24; D >= 0; D -= 8)
        M <<= 1, M |= S >>> D + P & 1, M <<= 1, M |= o >>> D + P & 1;
    for (var P = 4; P < 8; P++)
      for (var D = 24; D >= 0; D -= 8)
        O <<= 1, O |= S >>> D + P & 1, O <<= 1, O |= o >>> D + P & 1;
    g[B + 0] = M >>> 0, g[B + 1] = O >>> 0;
  }, utils$3.pc1 = function(o, S, g, B) {
    for (var M = 0, O = 0, P = 7; P >= 5; P--) {
      for (var D = 0; D <= 24; D += 8)
        M <<= 1, M |= S >> D + P & 1;
      for (var D = 0; D <= 24; D += 8)
        M <<= 1, M |= o >> D + P & 1;
    }
    for (var D = 0; D <= 24; D += 8)
      M <<= 1, M |= S >> D + P & 1;
    for (var P = 1; P <= 3; P++) {
      for (var D = 0; D <= 24; D += 8)
        O <<= 1, O |= S >> D + P & 1;
      for (var D = 0; D <= 24; D += 8)
        O <<= 1, O |= o >> D + P & 1;
    }
    for (var D = 0; D <= 24; D += 8)
      O <<= 1, O |= o >> D + P & 1;
    g[B + 0] = M >>> 0, g[B + 1] = O >>> 0;
  }, utils$3.r28shl = function(o, S) {
    return o << S & 268435455 | o >>> 28 - S;
  };
  var e = [
    // inL => outL
    14,
    11,
    17,
    4,
    27,
    23,
    25,
    0,
    13,
    22,
    7,
    18,
    5,
    9,
    16,
    24,
    2,
    20,
    12,
    21,
    1,
    8,
    15,
    26,
    // inR => outR
    15,
    4,
    25,
    19,
    9,
    1,
    26,
    16,
    5,
    11,
    23,
    8,
    12,
    7,
    17,
    0,
    22,
    3,
    10,
    14,
    6,
    20,
    27,
    24
  ];
  utils$3.pc2 = function(o, S, g, B) {
    for (var M = 0, O = 0, P = e.length >>> 1, D = 0; D < P; D++)
      M <<= 1, M |= o >>> e[D] & 1;
    for (var D = P; D < e.length; D++)
      O <<= 1, O |= S >>> e[D] & 1;
    g[B + 0] = M >>> 0, g[B + 1] = O >>> 0;
  }, utils$3.expand = function(o, S, g) {
    var B = 0, M = 0;
    B = (o & 1) << 5 | o >>> 27;
    for (var O = 23; O >= 15; O -= 4)
      B <<= 6, B |= o >>> O & 63;
    for (var O = 11; O >= 3; O -= 4)
      M |= o >>> O & 63, M <<= 6;
    M |= (o & 31) << 1 | o >>> 31, S[g + 0] = B >>> 0, S[g + 1] = M >>> 0;
  };
  var t = [
    14,
    0,
    4,
    15,
    13,
    7,
    1,
    4,
    2,
    14,
    15,
    2,
    11,
    13,
    8,
    1,
    3,
    10,
    10,
    6,
    6,
    12,
    12,
    11,
    5,
    9,
    9,
    5,
    0,
    3,
    7,
    8,
    4,
    15,
    1,
    12,
    14,
    8,
    8,
    2,
    13,
    4,
    6,
    9,
    2,
    1,
    11,
    7,
    15,
    5,
    12,
    11,
    9,
    3,
    7,
    14,
    3,
    10,
    10,
    0,
    5,
    6,
    0,
    13,
    15,
    3,
    1,
    13,
    8,
    4,
    14,
    7,
    6,
    15,
    11,
    2,
    3,
    8,
    4,
    14,
    9,
    12,
    7,
    0,
    2,
    1,
    13,
    10,
    12,
    6,
    0,
    9,
    5,
    11,
    10,
    5,
    0,
    13,
    14,
    8,
    7,
    10,
    11,
    1,
    10,
    3,
    4,
    15,
    13,
    4,
    1,
    2,
    5,
    11,
    8,
    6,
    12,
    7,
    6,
    12,
    9,
    0,
    3,
    5,
    2,
    14,
    15,
    9,
    10,
    13,
    0,
    7,
    9,
    0,
    14,
    9,
    6,
    3,
    3,
    4,
    15,
    6,
    5,
    10,
    1,
    2,
    13,
    8,
    12,
    5,
    7,
    14,
    11,
    12,
    4,
    11,
    2,
    15,
    8,
    1,
    13,
    1,
    6,
    10,
    4,
    13,
    9,
    0,
    8,
    6,
    15,
    9,
    3,
    8,
    0,
    7,
    11,
    4,
    1,
    15,
    2,
    14,
    12,
    3,
    5,
    11,
    10,
    5,
    14,
    2,
    7,
    12,
    7,
    13,
    13,
    8,
    14,
    11,
    3,
    5,
    0,
    6,
    6,
    15,
    9,
    0,
    10,
    3,
    1,
    4,
    2,
    7,
    8,
    2,
    5,
    12,
    11,
    1,
    12,
    10,
    4,
    14,
    15,
    9,
    10,
    3,
    6,
    15,
    9,
    0,
    0,
    6,
    12,
    10,
    11,
    1,
    7,
    13,
    13,
    8,
    15,
    9,
    1,
    4,
    3,
    5,
    14,
    11,
    5,
    12,
    2,
    7,
    8,
    2,
    4,
    14,
    2,
    14,
    12,
    11,
    4,
    2,
    1,
    12,
    7,
    4,
    10,
    7,
    11,
    13,
    6,
    1,
    8,
    5,
    5,
    0,
    3,
    15,
    15,
    10,
    13,
    3,
    0,
    9,
    14,
    8,
    9,
    6,
    4,
    11,
    2,
    8,
    1,
    12,
    11,
    7,
    10,
    1,
    13,
    14,
    7,
    2,
    8,
    13,
    15,
    6,
    9,
    15,
    12,
    0,
    5,
    9,
    6,
    10,
    3,
    4,
    0,
    5,
    14,
    3,
    12,
    10,
    1,
    15,
    10,
    4,
    15,
    2,
    9,
    7,
    2,
    12,
    6,
    9,
    8,
    5,
    0,
    6,
    13,
    1,
    3,
    13,
    4,
    14,
    14,
    0,
    7,
    11,
    5,
    3,
    11,
    8,
    9,
    4,
    14,
    3,
    15,
    2,
    5,
    12,
    2,
    9,
    8,
    5,
    12,
    15,
    3,
    10,
    7,
    11,
    0,
    14,
    4,
    1,
    10,
    7,
    1,
    6,
    13,
    0,
    11,
    8,
    6,
    13,
    4,
    13,
    11,
    0,
    2,
    11,
    14,
    7,
    15,
    4,
    0,
    9,
    8,
    1,
    13,
    10,
    3,
    14,
    12,
    3,
    9,
    5,
    7,
    12,
    5,
    2,
    10,
    15,
    6,
    8,
    1,
    6,
    1,
    6,
    4,
    11,
    11,
    13,
    13,
    8,
    12,
    1,
    3,
    4,
    7,
    10,
    14,
    7,
    10,
    9,
    15,
    5,
    6,
    0,
    8,
    15,
    0,
    14,
    5,
    2,
    9,
    3,
    2,
    12,
    13,
    1,
    2,
    15,
    8,
    13,
    4,
    8,
    6,
    10,
    15,
    3,
    11,
    7,
    1,
    4,
    10,
    12,
    9,
    5,
    3,
    6,
    14,
    11,
    5,
    0,
    0,
    14,
    12,
    9,
    7,
    2,
    7,
    2,
    11,
    1,
    4,
    14,
    1,
    7,
    9,
    4,
    12,
    10,
    14,
    8,
    2,
    13,
    0,
    15,
    6,
    12,
    10,
    9,
    13,
    0,
    15,
    3,
    3,
    5,
    5,
    6,
    8,
    11
  ];
  utils$3.substitute = function(o, S) {
    for (var g = 0, B = 0; B < 4; B++) {
      var M = o >>> 18 - B * 6 & 63, O = t[B * 64 + M];
      g <<= 4, g |= O;
    }
    for (var B = 0; B < 4; B++) {
      var M = S >>> 18 - B * 6 & 63, O = t[4 * 64 + B * 64 + M];
      g <<= 4, g |= O;
    }
    return g >>> 0;
  };
  var h = [
    16,
    25,
    12,
    11,
    3,
    20,
    4,
    15,
    31,
    17,
    9,
    6,
    27,
    14,
    1,
    22,
    30,
    24,
    8,
    18,
    0,
    5,
    29,
    23,
    13,
    19,
    2,
    26,
    10,
    21,
    28,
    7
  ];
  return utils$3.permute = function(o) {
    for (var S = 0, g = 0; g < h.length; g++)
      S <<= 1, S |= o >>> h[g] & 1;
    return S >>> 0;
  }, utils$3.padSplit = function(o, S, g) {
    for (var B = o.toString(2); B.length < S; )
      B = "0" + B;
    for (var M = [], O = 0; O < S; O += g)
      M.push(B.slice(O, O + g));
    return M.join(" ");
  }, utils$3;
}
var minimalisticAssert, hasRequiredMinimalisticAssert;
function requireMinimalisticAssert() {
  if (hasRequiredMinimalisticAssert)
    return minimalisticAssert;
  hasRequiredMinimalisticAssert = 1, minimalisticAssert = e;
  function e(t, h) {
    if (!t)
      throw new Error(h || "Assertion failed");
  }
  return e.equal = function(t, h, o) {
    if (t != h)
      throw new Error(o || "Assertion failed: " + t + " != " + h);
  }, minimalisticAssert;
}
var cipher, hasRequiredCipher;
function requireCipher() {
  if (hasRequiredCipher)
    return cipher;
  hasRequiredCipher = 1;
  var e = requireMinimalisticAssert();
  function t(h) {
    this.options = h, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = h.padding !== !1;
  }
  return cipher = t, t.prototype._init = function() {
  }, t.prototype.update = function(h) {
    return h.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(h) : this._updateEncrypt(h);
  }, t.prototype._buffer = function(h, o) {
    for (var S = Math.min(this.buffer.length - this.bufferOff, h.length - o), g = 0; g < S; g++)
      this.buffer[this.bufferOff + g] = h[o + g];
    return this.bufferOff += S, S;
  }, t.prototype._flushBuffer = function(h, o) {
    return this._update(this.buffer, 0, h, o), this.bufferOff = 0, this.blockSize;
  }, t.prototype._updateEncrypt = function(h) {
    var o = 0, S = 0, g = (this.bufferOff + h.length) / this.blockSize | 0, B = new Array(g * this.blockSize);
    this.bufferOff !== 0 && (o += this._buffer(h, o), this.bufferOff === this.buffer.length && (S += this._flushBuffer(B, S)));
    for (var M = h.length - (h.length - o) % this.blockSize; o < M; o += this.blockSize)
      this._update(h, o, B, S), S += this.blockSize;
    for (; o < h.length; o++, this.bufferOff++)
      this.buffer[this.bufferOff] = h[o];
    return B;
  }, t.prototype._updateDecrypt = function(h) {
    for (var o = 0, S = 0, g = Math.ceil((this.bufferOff + h.length) / this.blockSize) - 1, B = new Array(g * this.blockSize); g > 0; g--)
      o += this._buffer(h, o), S += this._flushBuffer(B, S);
    return o += this._buffer(h, o), B;
  }, t.prototype.final = function(h) {
    var o;
    h && (o = this.update(h));
    var S;
    return this.type === "encrypt" ? S = this._finalEncrypt() : S = this._finalDecrypt(), o ? o.concat(S) : S;
  }, t.prototype._pad = function(h, o) {
    if (o === 0)
      return !1;
    for (; o < h.length; )
      h[o++] = 0;
    return !0;
  }, t.prototype._finalEncrypt = function() {
    if (!this._pad(this.buffer, this.bufferOff))
      return [];
    var h = new Array(this.blockSize);
    return this._update(this.buffer, 0, h, 0), h;
  }, t.prototype._unpad = function(h) {
    return h;
  }, t.prototype._finalDecrypt = function() {
    e.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
    var h = new Array(this.blockSize);
    return this._flushBuffer(h, 0), this._unpad(h);
  }, cipher;
}
var des, hasRequiredDes$1;
function requireDes$1() {
  if (hasRequiredDes$1)
    return des;
  hasRequiredDes$1 = 1;
  var e = requireMinimalisticAssert(), t = requireInherits_browser(), h = requireUtils$3(), o = requireCipher();
  function S() {
    this.tmp = new Array(2), this.keys = null;
  }
  function g(M) {
    o.call(this, M);
    var O = new S();
    this._desState = O, this.deriveKeys(O, M.key);
  }
  t(g, o), des = g, g.create = function(M) {
    return new g(M);
  };
  var B = [
    1,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1,
    2,
    2,
    2,
    2,
    2,
    2,
    1
  ];
  return g.prototype.deriveKeys = function(M, O) {
    M.keys = new Array(16 * 2), e.equal(O.length, this.blockSize, "Invalid key length");
    var P = h.readUInt32BE(O, 0), D = h.readUInt32BE(O, 4);
    h.pc1(P, D, M.tmp, 0), P = M.tmp[0], D = M.tmp[1];
    for (var Z = 0; Z < M.keys.length; Z += 2) {
      var Y = B[Z >>> 1];
      P = h.r28shl(P, Y), D = h.r28shl(D, Y), h.pc2(P, D, M.keys, Z);
    }
  }, g.prototype._update = function(M, O, P, D) {
    var Z = this._desState, Y = h.readUInt32BE(M, O), ee = h.readUInt32BE(M, O + 4);
    h.ip(Y, ee, Z.tmp, 0), Y = Z.tmp[0], ee = Z.tmp[1], this.type === "encrypt" ? this._encrypt(Z, Y, ee, Z.tmp, 0) : this._decrypt(Z, Y, ee, Z.tmp, 0), Y = Z.tmp[0], ee = Z.tmp[1], h.writeUInt32BE(P, Y, D), h.writeUInt32BE(P, ee, D + 4);
  }, g.prototype._pad = function(M, O) {
    if (this.padding === !1)
      return !1;
    for (var P = M.length - O, D = O; D < M.length; D++)
      M[D] = P;
    return !0;
  }, g.prototype._unpad = function(M) {
    if (this.padding === !1)
      return M;
    for (var O = M[M.length - 1], P = M.length - O; P < M.length; P++)
      e.equal(M[P], O);
    return M.slice(0, M.length - O);
  }, g.prototype._encrypt = function(M, O, P, D, Z) {
    for (var Y = O, ee = P, ie = 0; ie < M.keys.length; ie += 2) {
      var ue = M.keys[ie], fe = M.keys[ie + 1];
      h.expand(ee, M.tmp, 0), ue ^= M.tmp[0], fe ^= M.tmp[1];
      var de = h.substitute(ue, fe), ce = h.permute(de), be = ee;
      ee = (Y ^ ce) >>> 0, Y = be;
    }
    h.rip(ee, Y, D, Z);
  }, g.prototype._decrypt = function(M, O, P, D, Z) {
    for (var Y = P, ee = O, ie = M.keys.length - 2; ie >= 0; ie -= 2) {
      var ue = M.keys[ie], fe = M.keys[ie + 1];
      h.expand(Y, M.tmp, 0), ue ^= M.tmp[0], fe ^= M.tmp[1];
      var de = h.substitute(ue, fe), ce = h.permute(de), be = Y;
      Y = (ee ^ ce) >>> 0, ee = be;
    }
    h.rip(Y, ee, D, Z);
  }, des;
}
var cbc$1 = {}, hasRequiredCbc$1;
function requireCbc$1() {
  if (hasRequiredCbc$1)
    return cbc$1;
  hasRequiredCbc$1 = 1;
  var e = requireMinimalisticAssert(), t = requireInherits_browser(), h = {};
  function o(g) {
    e.equal(g.length, 8, "Invalid IV length"), this.iv = new Array(8);
    for (var B = 0; B < this.iv.length; B++)
      this.iv[B] = g[B];
  }
  function S(g) {
    function B(D) {
      g.call(this, D), this._cbcInit();
    }
    t(B, g);
    for (var M = Object.keys(h), O = 0; O < M.length; O++) {
      var P = M[O];
      B.prototype[P] = h[P];
    }
    return B.create = function(D) {
      return new B(D);
    }, B;
  }
  return cbc$1.instantiate = S, h._cbcInit = function() {
    var g = new o(this.options.iv);
    this._cbcState = g;
  }, h._update = function(g, B, M, O) {
    var P = this._cbcState, D = this.constructor.super_.prototype, Z = P.iv;
    if (this.type === "encrypt") {
      for (var Y = 0; Y < this.blockSize; Y++)
        Z[Y] ^= g[B + Y];
      D._update.call(this, Z, 0, M, O);
      for (var Y = 0; Y < this.blockSize; Y++)
        Z[Y] = M[O + Y];
    } else {
      D._update.call(this, g, B, M, O);
      for (var Y = 0; Y < this.blockSize; Y++)
        M[O + Y] ^= Z[Y];
      for (var Y = 0; Y < this.blockSize; Y++)
        Z[Y] = g[B + Y];
    }
  }, cbc$1;
}
var ede, hasRequiredEde;
function requireEde() {
  if (hasRequiredEde)
    return ede;
  hasRequiredEde = 1;
  var e = requireMinimalisticAssert(), t = requireInherits_browser(), h = requireCipher(), o = requireDes$1();
  function S(B, M) {
    e.equal(M.length, 24, "Invalid key length");
    var O = M.slice(0, 8), P = M.slice(8, 16), D = M.slice(16, 24);
    B === "encrypt" ? this.ciphers = [
      o.create({ type: "encrypt", key: O }),
      o.create({ type: "decrypt", key: P }),
      o.create({ type: "encrypt", key: D })
    ] : this.ciphers = [
      o.create({ type: "decrypt", key: D }),
      o.create({ type: "encrypt", key: P }),
      o.create({ type: "decrypt", key: O })
    ];
  }
  function g(B) {
    h.call(this, B);
    var M = new S(this.type, this.options.key);
    this._edeState = M;
  }
  return t(g, h), ede = g, g.create = function(B) {
    return new g(B);
  }, g.prototype._update = function(B, M, O, P) {
    var D = this._edeState;
    D.ciphers[0]._update(B, M, O, P), D.ciphers[1]._update(O, P, O, P), D.ciphers[2]._update(O, P, O, P);
  }, g.prototype._pad = o.prototype._pad, g.prototype._unpad = o.prototype._unpad, ede;
}
var hasRequiredDes;
function requireDes() {
  return hasRequiredDes || (hasRequiredDes = 1, des$1.utils = requireUtils$3(), des$1.Cipher = requireCipher(), des$1.DES = requireDes$1(), des$1.CBC = requireCbc$1(), des$1.EDE = requireEde()), des$1;
}
var browserifyDes, hasRequiredBrowserifyDes;
function requireBrowserifyDes() {
  if (hasRequiredBrowserifyDes)
    return browserifyDes;
  hasRequiredBrowserifyDes = 1;
  var e = requireCipherBase(), t = requireDes(), h = requireInherits_browser(), o = requireSafeBuffer$1().Buffer, S = {
    "des-ede3-cbc": t.CBC.instantiate(t.EDE),
    "des-ede3": t.EDE,
    "des-ede-cbc": t.CBC.instantiate(t.EDE),
    "des-ede": t.EDE,
    "des-cbc": t.CBC.instantiate(t.DES),
    "des-ecb": t.DES
  };
  S.des = S["des-cbc"], S.des3 = S["des-ede3-cbc"], browserifyDes = g, h(g, e);
  function g(B) {
    e.call(this);
    var M = B.mode.toLowerCase(), O = S[M], P;
    B.decrypt ? P = "decrypt" : P = "encrypt";
    var D = B.key;
    o.isBuffer(D) || (D = o.from(D)), (M === "des-ede" || M === "des-ede-cbc") && (D = o.concat([D, D.slice(0, 8)]));
    var Z = B.iv;
    o.isBuffer(Z) || (Z = o.from(Z)), this._des = O.create({
      key: D,
      iv: Z,
      type: P
    });
  }
  return g.prototype._update = function(B) {
    return o.from(this._des.update(B));
  }, g.prototype._final = function() {
    return o.from(this._des.final());
  }, browserifyDes;
}
var browser$5 = {}, encrypter = {}, ecb = {}, hasRequiredEcb;
function requireEcb() {
  return hasRequiredEcb || (hasRequiredEcb = 1, ecb.encrypt = function(e, t) {
    return e._cipher.encryptBlock(t);
  }, ecb.decrypt = function(e, t) {
    return e._cipher.decryptBlock(t);
  }), ecb;
}
var cbc = {}, bufferXor, hasRequiredBufferXor;
function requireBufferXor() {
  return hasRequiredBufferXor || (hasRequiredBufferXor = 1, bufferXor = function(e, t) {
    for (var h = Math.min(e.length, t.length), o = new bufferExports.Buffer(h), S = 0; S < h; ++S)
      o[S] = e[S] ^ t[S];
    return o;
  }), bufferXor;
}
var hasRequiredCbc;
function requireCbc() {
  if (hasRequiredCbc)
    return cbc;
  hasRequiredCbc = 1;
  var e = requireBufferXor();
  return cbc.encrypt = function(t, h) {
    var o = e(h, t._prev);
    return t._prev = t._cipher.encryptBlock(o), t._prev;
  }, cbc.decrypt = function(t, h) {
    var o = t._prev;
    t._prev = h;
    var S = t._cipher.decryptBlock(h);
    return e(S, o);
  }, cbc;
}
var cfb = {}, hasRequiredCfb;
function requireCfb() {
  if (hasRequiredCfb)
    return cfb;
  hasRequiredCfb = 1;
  var e = requireSafeBuffer$1().Buffer, t = requireBufferXor();
  function h(o, S, g) {
    var B = S.length, M = t(S, o._cache);
    return o._cache = o._cache.slice(B), o._prev = e.concat([o._prev, g ? S : M]), M;
  }
  return cfb.encrypt = function(o, S, g) {
    for (var B = e.allocUnsafe(0), M; S.length; )
      if (o._cache.length === 0 && (o._cache = o._cipher.encryptBlock(o._prev), o._prev = e.allocUnsafe(0)), o._cache.length <= S.length)
        M = o._cache.length, B = e.concat([B, h(o, S.slice(0, M), g)]), S = S.slice(M);
      else {
        B = e.concat([B, h(o, S, g)]);
        break;
      }
    return B;
  }, cfb;
}
var cfb8 = {}, hasRequiredCfb8;
function requireCfb8() {
  if (hasRequiredCfb8)
    return cfb8;
  hasRequiredCfb8 = 1;
  var e = requireSafeBuffer$1().Buffer;
  function t(h, o, S) {
    var g = h._cipher.encryptBlock(h._prev), B = g[0] ^ o;
    return h._prev = e.concat([
      h._prev.slice(1),
      e.from([S ? o : B])
    ]), B;
  }
  return cfb8.encrypt = function(h, o, S) {
    for (var g = o.length, B = e.allocUnsafe(g), M = -1; ++M < g; )
      B[M] = t(h, o[M], S);
    return B;
  }, cfb8;
}
var cfb1 = {}, hasRequiredCfb1;
function requireCfb1() {
  if (hasRequiredCfb1)
    return cfb1;
  hasRequiredCfb1 = 1;
  var e = requireSafeBuffer$1().Buffer;
  function t(o, S, g) {
    for (var B, M = -1, O = 8, P = 0, D, Z; ++M < O; )
      B = o._cipher.encryptBlock(o._prev), D = S & 1 << 7 - M ? 128 : 0, Z = B[0] ^ D, P += (Z & 128) >> M % 8, o._prev = h(o._prev, g ? D : Z);
    return P;
  }
  function h(o, S) {
    var g = o.length, B = -1, M = e.allocUnsafe(o.length);
    for (o = e.concat([o, e.from([S])]); ++B < g; )
      M[B] = o[B] << 1 | o[B + 1] >> 7;
    return M;
  }
  return cfb1.encrypt = function(o, S, g) {
    for (var B = S.length, M = e.allocUnsafe(B), O = -1; ++O < B; )
      M[O] = t(o, S[O], g);
    return M;
  }, cfb1;
}
var ofb = {}, hasRequiredOfb;
function requireOfb() {
  if (hasRequiredOfb)
    return ofb;
  hasRequiredOfb = 1;
  var e = requireBufferXor();
  function t(h) {
    return h._prev = h._cipher.encryptBlock(h._prev), h._prev;
  }
  return ofb.encrypt = function(h, o) {
    for (; h._cache.length < o.length; )
      h._cache = bufferExports.Buffer.concat([h._cache, t(h)]);
    var S = h._cache.slice(0, o.length);
    return h._cache = h._cache.slice(o.length), e(o, S);
  }, ofb;
}
var ctr = {}, incr32_1, hasRequiredIncr32;
function requireIncr32() {
  if (hasRequiredIncr32)
    return incr32_1;
  hasRequiredIncr32 = 1;
  function e(t) {
    for (var h = t.length, o; h--; )
      if (o = t.readUInt8(h), o === 255)
        t.writeUInt8(0, h);
      else {
        o++, t.writeUInt8(o, h);
        break;
      }
  }
  return incr32_1 = e, incr32_1;
}
var hasRequiredCtr;
function requireCtr() {
  if (hasRequiredCtr)
    return ctr;
  hasRequiredCtr = 1;
  var e = requireBufferXor(), t = requireSafeBuffer$1().Buffer, h = requireIncr32();
  function o(g) {
    var B = g._cipher.encryptBlockRaw(g._prev);
    return h(g._prev), B;
  }
  var S = 16;
  return ctr.encrypt = function(g, B) {
    var M = Math.ceil(B.length / S), O = g._cache.length;
    g._cache = t.concat([
      g._cache,
      t.allocUnsafe(M * S)
    ]);
    for (var P = 0; P < M; P++) {
      var D = o(g), Z = O + P * S;
      g._cache.writeUInt32BE(D[0], Z + 0), g._cache.writeUInt32BE(D[1], Z + 4), g._cache.writeUInt32BE(D[2], Z + 8), g._cache.writeUInt32BE(D[3], Z + 12);
    }
    var Y = g._cache.slice(0, B.length);
    return g._cache = g._cache.slice(B.length), e(B, Y);
  }, ctr;
}
const aes128 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes192 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, aes256 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, require$$2 = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128,
  aes192,
  aes256,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var modes_1, hasRequiredModes$1;
function requireModes$1() {
  if (hasRequiredModes$1)
    return modes_1;
  hasRequiredModes$1 = 1;
  var e = {
    ECB: requireEcb(),
    CBC: requireCbc(),
    CFB: requireCfb(),
    CFB8: requireCfb8(),
    CFB1: requireCfb1(),
    OFB: requireOfb(),
    CTR: requireCtr(),
    GCM: requireCtr()
  }, t = require$$2;
  for (var h in t)
    t[h].module = e[t[h].mode];
  return modes_1 = t, modes_1;
}
var aes = {}, hasRequiredAes;
function requireAes() {
  if (hasRequiredAes)
    return aes;
  hasRequiredAes = 1;
  var e = requireSafeBuffer$1().Buffer;
  function t(M) {
    e.isBuffer(M) || (M = e.from(M));
    for (var O = M.length / 4 | 0, P = new Array(O), D = 0; D < O; D++)
      P[D] = M.readUInt32BE(D * 4);
    return P;
  }
  function h(M) {
    for (var O = 0; O < M.length; M++)
      M[O] = 0;
  }
  function o(M, O, P, D, Z) {
    for (var Y = P[0], ee = P[1], ie = P[2], ue = P[3], fe = M[0] ^ O[0], de = M[1] ^ O[1], ce = M[2] ^ O[2], be = M[3] ^ O[3], ve, Pe, Ue, ze, Le = 4, Ne = 1; Ne < Z; Ne++)
      ve = Y[fe >>> 24] ^ ee[de >>> 16 & 255] ^ ie[ce >>> 8 & 255] ^ ue[be & 255] ^ O[Le++], Pe = Y[de >>> 24] ^ ee[ce >>> 16 & 255] ^ ie[be >>> 8 & 255] ^ ue[fe & 255] ^ O[Le++], Ue = Y[ce >>> 24] ^ ee[be >>> 16 & 255] ^ ie[fe >>> 8 & 255] ^ ue[de & 255] ^ O[Le++], ze = Y[be >>> 24] ^ ee[fe >>> 16 & 255] ^ ie[de >>> 8 & 255] ^ ue[ce & 255] ^ O[Le++], fe = ve, de = Pe, ce = Ue, be = ze;
    return ve = (D[fe >>> 24] << 24 | D[de >>> 16 & 255] << 16 | D[ce >>> 8 & 255] << 8 | D[be & 255]) ^ O[Le++], Pe = (D[de >>> 24] << 24 | D[ce >>> 16 & 255] << 16 | D[be >>> 8 & 255] << 8 | D[fe & 255]) ^ O[Le++], Ue = (D[ce >>> 24] << 24 | D[be >>> 16 & 255] << 16 | D[fe >>> 8 & 255] << 8 | D[de & 255]) ^ O[Le++], ze = (D[be >>> 24] << 24 | D[fe >>> 16 & 255] << 16 | D[de >>> 8 & 255] << 8 | D[ce & 255]) ^ O[Le++], ve = ve >>> 0, Pe = Pe >>> 0, Ue = Ue >>> 0, ze = ze >>> 0, [ve, Pe, Ue, ze];
  }
  var S = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], g = function() {
    for (var M = new Array(256), O = 0; O < 256; O++)
      O < 128 ? M[O] = O << 1 : M[O] = O << 1 ^ 283;
    for (var P = [], D = [], Z = [[], [], [], []], Y = [[], [], [], []], ee = 0, ie = 0, ue = 0; ue < 256; ++ue) {
      var fe = ie ^ ie << 1 ^ ie << 2 ^ ie << 3 ^ ie << 4;
      fe = fe >>> 8 ^ fe & 255 ^ 99, P[ee] = fe, D[fe] = ee;
      var de = M[ee], ce = M[de], be = M[ce], ve = M[fe] * 257 ^ fe * 16843008;
      Z[0][ee] = ve << 24 | ve >>> 8, Z[1][ee] = ve << 16 | ve >>> 16, Z[2][ee] = ve << 8 | ve >>> 24, Z[3][ee] = ve, ve = be * 16843009 ^ ce * 65537 ^ de * 257 ^ ee * 16843008, Y[0][fe] = ve << 24 | ve >>> 8, Y[1][fe] = ve << 16 | ve >>> 16, Y[2][fe] = ve << 8 | ve >>> 24, Y[3][fe] = ve, ee === 0 ? ee = ie = 1 : (ee = de ^ M[M[M[be ^ de]]], ie ^= M[M[ie]]);
    }
    return {
      SBOX: P,
      INV_SBOX: D,
      SUB_MIX: Z,
      INV_SUB_MIX: Y
    };
  }();
  function B(M) {
    this._key = t(M), this._reset();
  }
  return B.blockSize = 4 * 4, B.keySize = 256 / 8, B.prototype.blockSize = B.blockSize, B.prototype.keySize = B.keySize, B.prototype._reset = function() {
    for (var M = this._key, O = M.length, P = O + 6, D = (P + 1) * 4, Z = [], Y = 0; Y < O; Y++)
      Z[Y] = M[Y];
    for (Y = O; Y < D; Y++) {
      var ee = Z[Y - 1];
      Y % O === 0 ? (ee = ee << 8 | ee >>> 24, ee = g.SBOX[ee >>> 24] << 24 | g.SBOX[ee >>> 16 & 255] << 16 | g.SBOX[ee >>> 8 & 255] << 8 | g.SBOX[ee & 255], ee ^= S[Y / O | 0] << 24) : O > 6 && Y % O === 4 && (ee = g.SBOX[ee >>> 24] << 24 | g.SBOX[ee >>> 16 & 255] << 16 | g.SBOX[ee >>> 8 & 255] << 8 | g.SBOX[ee & 255]), Z[Y] = Z[Y - O] ^ ee;
    }
    for (var ie = [], ue = 0; ue < D; ue++) {
      var fe = D - ue, de = Z[fe - (ue % 4 ? 0 : 4)];
      ue < 4 || fe <= 4 ? ie[ue] = de : ie[ue] = g.INV_SUB_MIX[0][g.SBOX[de >>> 24]] ^ g.INV_SUB_MIX[1][g.SBOX[de >>> 16 & 255]] ^ g.INV_SUB_MIX[2][g.SBOX[de >>> 8 & 255]] ^ g.INV_SUB_MIX[3][g.SBOX[de & 255]];
    }
    this._nRounds = P, this._keySchedule = Z, this._invKeySchedule = ie;
  }, B.prototype.encryptBlockRaw = function(M) {
    return M = t(M), o(M, this._keySchedule, g.SUB_MIX, g.SBOX, this._nRounds);
  }, B.prototype.encryptBlock = function(M) {
    var O = this.encryptBlockRaw(M), P = e.allocUnsafe(16);
    return P.writeUInt32BE(O[0], 0), P.writeUInt32BE(O[1], 4), P.writeUInt32BE(O[2], 8), P.writeUInt32BE(O[3], 12), P;
  }, B.prototype.decryptBlock = function(M) {
    M = t(M);
    var O = M[1];
    M[1] = M[3], M[3] = O;
    var P = o(M, this._invKeySchedule, g.INV_SUB_MIX, g.INV_SBOX, this._nRounds), D = e.allocUnsafe(16);
    return D.writeUInt32BE(P[0], 0), D.writeUInt32BE(P[3], 4), D.writeUInt32BE(P[2], 8), D.writeUInt32BE(P[1], 12), D;
  }, B.prototype.scrub = function() {
    h(this._keySchedule), h(this._invKeySchedule), h(this._key);
  }, aes.AES = B, aes;
}
var ghash, hasRequiredGhash;
function requireGhash() {
  if (hasRequiredGhash)
    return ghash;
  hasRequiredGhash = 1;
  var e = requireSafeBuffer$1().Buffer, t = e.alloc(16, 0);
  function h(g) {
    return [
      g.readUInt32BE(0),
      g.readUInt32BE(4),
      g.readUInt32BE(8),
      g.readUInt32BE(12)
    ];
  }
  function o(g) {
    var B = e.allocUnsafe(16);
    return B.writeUInt32BE(g[0] >>> 0, 0), B.writeUInt32BE(g[1] >>> 0, 4), B.writeUInt32BE(g[2] >>> 0, 8), B.writeUInt32BE(g[3] >>> 0, 12), B;
  }
  function S(g) {
    this.h = g, this.state = e.alloc(16, 0), this.cache = e.allocUnsafe(0);
  }
  return S.prototype.ghash = function(g) {
    for (var B = -1; ++B < g.length; )
      this.state[B] ^= g[B];
    this._multiply();
  }, S.prototype._multiply = function() {
    for (var g = h(this.h), B = [0, 0, 0, 0], M, O, P, D = -1; ++D < 128; ) {
      for (O = (this.state[~~(D / 8)] & 1 << 7 - D % 8) !== 0, O && (B[0] ^= g[0], B[1] ^= g[1], B[2] ^= g[2], B[3] ^= g[3]), P = (g[3] & 1) !== 0, M = 3; M > 0; M--)
        g[M] = g[M] >>> 1 | (g[M - 1] & 1) << 31;
      g[0] = g[0] >>> 1, P && (g[0] = g[0] ^ 225 << 24);
    }
    this.state = o(B);
  }, S.prototype.update = function(g) {
    this.cache = e.concat([this.cache, g]);
    for (var B; this.cache.length >= 16; )
      B = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(B);
  }, S.prototype.final = function(g, B) {
    return this.cache.length && this.ghash(e.concat([this.cache, t], 16)), this.ghash(o([0, g, 0, B])), this.state;
  }, ghash = S, ghash;
}
var authCipher, hasRequiredAuthCipher;
function requireAuthCipher() {
  if (hasRequiredAuthCipher)
    return authCipher;
  hasRequiredAuthCipher = 1;
  var e = requireAes(), t = requireSafeBuffer$1().Buffer, h = requireCipherBase(), o = requireInherits_browser(), S = requireGhash(), g = requireBufferXor(), B = requireIncr32();
  function M(D, Z) {
    var Y = 0;
    D.length !== Z.length && Y++;
    for (var ee = Math.min(D.length, Z.length), ie = 0; ie < ee; ++ie)
      Y += D[ie] ^ Z[ie];
    return Y;
  }
  function O(D, Z, Y) {
    if (Z.length === 12)
      return D._finID = t.concat([Z, t.from([0, 0, 0, 1])]), t.concat([Z, t.from([0, 0, 0, 2])]);
    var ee = new S(Y), ie = Z.length, ue = ie % 16;
    ee.update(Z), ue && (ue = 16 - ue, ee.update(t.alloc(ue, 0))), ee.update(t.alloc(8, 0));
    var fe = ie * 8, de = t.alloc(8);
    de.writeUIntBE(fe, 0, 8), ee.update(de), D._finID = ee.state;
    var ce = t.from(D._finID);
    return B(ce), ce;
  }
  function P(D, Z, Y, ee) {
    h.call(this);
    var ie = t.alloc(4, 0);
    this._cipher = new e.AES(Z);
    var ue = this._cipher.encryptBlock(ie);
    this._ghash = new S(ue), Y = O(this, Y, ue), this._prev = t.from(Y), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = ee, this._alen = 0, this._len = 0, this._mode = D, this._authTag = null, this._called = !1;
  }
  return o(P, h), P.prototype._update = function(D) {
    if (!this._called && this._alen) {
      var Z = 16 - this._alen % 16;
      Z < 16 && (Z = t.alloc(Z, 0), this._ghash.update(Z));
    }
    this._called = !0;
    var Y = this._mode.encrypt(this, D);
    return this._decrypt ? this._ghash.update(D) : this._ghash.update(Y), this._len += D.length, Y;
  }, P.prototype._final = function() {
    if (this._decrypt && !this._authTag)
      throw new Error("Unsupported state or unable to authenticate data");
    var D = g(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
    if (this._decrypt && M(D, this._authTag))
      throw new Error("Unsupported state or unable to authenticate data");
    this._authTag = D, this._cipher.scrub();
  }, P.prototype.getAuthTag = function() {
    if (this._decrypt || !t.isBuffer(this._authTag))
      throw new Error("Attempting to get auth tag in unsupported state");
    return this._authTag;
  }, P.prototype.setAuthTag = function(D) {
    if (!this._decrypt)
      throw new Error("Attempting to set auth tag in unsupported state");
    this._authTag = D;
  }, P.prototype.setAAD = function(D) {
    if (this._called)
      throw new Error("Attempting to set AAD in unsupported state");
    this._ghash.update(D), this._alen += D.length;
  }, authCipher = P, authCipher;
}
var streamCipher, hasRequiredStreamCipher;
function requireStreamCipher() {
  if (hasRequiredStreamCipher)
    return streamCipher;
  hasRequiredStreamCipher = 1;
  var e = requireAes(), t = requireSafeBuffer$1().Buffer, h = requireCipherBase(), o = requireInherits_browser();
  function S(g, B, M, O) {
    h.call(this), this._cipher = new e.AES(B), this._prev = t.from(M), this._cache = t.allocUnsafe(0), this._secCache = t.allocUnsafe(0), this._decrypt = O, this._mode = g;
  }
  return o(S, h), S.prototype._update = function(g) {
    return this._mode.encrypt(this, g, this._decrypt);
  }, S.prototype._final = function() {
    this._cipher.scrub();
  }, streamCipher = S, streamCipher;
}
var evp_bytestokey, hasRequiredEvp_bytestokey;
function requireEvp_bytestokey() {
  if (hasRequiredEvp_bytestokey)
    return evp_bytestokey;
  hasRequiredEvp_bytestokey = 1;
  var e = requireSafeBuffer$1().Buffer, t = requireMd5_js();
  function h(o, S, g, B) {
    if (e.isBuffer(o) || (o = e.from(o, "binary")), S && (e.isBuffer(S) || (S = e.from(S, "binary")), S.length !== 8))
      throw new RangeError("salt should be Buffer with 8 byte length");
    for (var M = g / 8, O = e.alloc(M), P = e.alloc(B || 0), D = e.alloc(0); M > 0 || B > 0; ) {
      var Z = new t();
      Z.update(D), Z.update(o), S && Z.update(S), D = Z.digest();
      var Y = 0;
      if (M > 0) {
        var ee = O.length - M;
        Y = Math.min(M, D.length), D.copy(O, ee, 0, Y), M -= Y;
      }
      if (Y < D.length && B > 0) {
        var ie = P.length - B, ue = Math.min(B, D.length - Y);
        D.copy(P, ie, Y, Y + ue), B -= ue;
      }
    }
    return D.fill(0), { key: O, iv: P };
  }
  return evp_bytestokey = h, evp_bytestokey;
}
var hasRequiredEncrypter;
function requireEncrypter() {
  if (hasRequiredEncrypter)
    return encrypter;
  hasRequiredEncrypter = 1;
  var e = requireModes$1(), t = requireAuthCipher(), h = requireSafeBuffer$1().Buffer, o = requireStreamCipher(), S = requireCipherBase(), g = requireAes(), B = requireEvp_bytestokey(), M = requireInherits_browser();
  function O(ee, ie, ue) {
    S.call(this), this._cache = new D(), this._cipher = new g.AES(ie), this._prev = h.from(ue), this._mode = ee, this._autopadding = !0;
  }
  M(O, S), O.prototype._update = function(ee) {
    this._cache.add(ee);
    for (var ie, ue, fe = []; ie = this._cache.get(); )
      ue = this._mode.encrypt(this, ie), fe.push(ue);
    return h.concat(fe);
  };
  var P = h.alloc(16, 16);
  O.prototype._final = function() {
    var ee = this._cache.flush();
    if (this._autopadding)
      return ee = this._mode.encrypt(this, ee), this._cipher.scrub(), ee;
    if (!ee.equals(P))
      throw this._cipher.scrub(), new Error("data not multiple of block length");
  }, O.prototype.setAutoPadding = function(ee) {
    return this._autopadding = !!ee, this;
  };
  function D() {
    this.cache = h.allocUnsafe(0);
  }
  D.prototype.add = function(ee) {
    this.cache = h.concat([this.cache, ee]);
  }, D.prototype.get = function() {
    if (this.cache.length > 15) {
      var ee = this.cache.slice(0, 16);
      return this.cache = this.cache.slice(16), ee;
    }
    return null;
  }, D.prototype.flush = function() {
    for (var ee = 16 - this.cache.length, ie = h.allocUnsafe(ee), ue = -1; ++ue < ee; )
      ie.writeUInt8(ee, ue);
    return h.concat([this.cache, ie]);
  };
  function Z(ee, ie, ue) {
    var fe = e[ee.toLowerCase()];
    if (!fe)
      throw new TypeError("invalid suite type");
    if (typeof ie == "string" && (ie = h.from(ie)), ie.length !== fe.key / 8)
      throw new TypeError("invalid key length " + ie.length);
    if (typeof ue == "string" && (ue = h.from(ue)), fe.mode !== "GCM" && ue.length !== fe.iv)
      throw new TypeError("invalid iv length " + ue.length);
    return fe.type === "stream" ? new o(fe.module, ie, ue) : fe.type === "auth" ? new t(fe.module, ie, ue) : new O(fe.module, ie, ue);
  }
  function Y(ee, ie) {
    var ue = e[ee.toLowerCase()];
    if (!ue)
      throw new TypeError("invalid suite type");
    var fe = B(ie, !1, ue.key, ue.iv);
    return Z(ee, fe.key, fe.iv);
  }
  return encrypter.createCipheriv = Z, encrypter.createCipher = Y, encrypter;
}
var decrypter = {}, hasRequiredDecrypter;
function requireDecrypter() {
  if (hasRequiredDecrypter)
    return decrypter;
  hasRequiredDecrypter = 1;
  var e = requireAuthCipher(), t = requireSafeBuffer$1().Buffer, h = requireModes$1(), o = requireStreamCipher(), S = requireCipherBase(), g = requireAes(), B = requireEvp_bytestokey(), M = requireInherits_browser();
  function O(ee, ie, ue) {
    S.call(this), this._cache = new P(), this._last = void 0, this._cipher = new g.AES(ie), this._prev = t.from(ue), this._mode = ee, this._autopadding = !0;
  }
  M(O, S), O.prototype._update = function(ee) {
    this._cache.add(ee);
    for (var ie, ue, fe = []; ie = this._cache.get(this._autopadding); )
      ue = this._mode.decrypt(this, ie), fe.push(ue);
    return t.concat(fe);
  }, O.prototype._final = function() {
    var ee = this._cache.flush();
    if (this._autopadding)
      return D(this._mode.decrypt(this, ee));
    if (ee)
      throw new Error("data not multiple of block length");
  }, O.prototype.setAutoPadding = function(ee) {
    return this._autopadding = !!ee, this;
  };
  function P() {
    this.cache = t.allocUnsafe(0);
  }
  P.prototype.add = function(ee) {
    this.cache = t.concat([this.cache, ee]);
  }, P.prototype.get = function(ee) {
    var ie;
    if (ee) {
      if (this.cache.length > 16)
        return ie = this.cache.slice(0, 16), this.cache = this.cache.slice(16), ie;
    } else if (this.cache.length >= 16)
      return ie = this.cache.slice(0, 16), this.cache = this.cache.slice(16), ie;
    return null;
  }, P.prototype.flush = function() {
    if (this.cache.length)
      return this.cache;
  };
  function D(ee) {
    var ie = ee[15];
    if (ie < 1 || ie > 16)
      throw new Error("unable to decrypt data");
    for (var ue = -1; ++ue < ie; )
      if (ee[ue + (16 - ie)] !== ie)
        throw new Error("unable to decrypt data");
    if (ie !== 16)
      return ee.slice(0, 16 - ie);
  }
  function Z(ee, ie, ue) {
    var fe = h[ee.toLowerCase()];
    if (!fe)
      throw new TypeError("invalid suite type");
    if (typeof ue == "string" && (ue = t.from(ue)), fe.mode !== "GCM" && ue.length !== fe.iv)
      throw new TypeError("invalid iv length " + ue.length);
    if (typeof ie == "string" && (ie = t.from(ie)), ie.length !== fe.key / 8)
      throw new TypeError("invalid key length " + ie.length);
    return fe.type === "stream" ? new o(fe.module, ie, ue, !0) : fe.type === "auth" ? new e(fe.module, ie, ue, !0) : new O(fe.module, ie, ue);
  }
  function Y(ee, ie) {
    var ue = h[ee.toLowerCase()];
    if (!ue)
      throw new TypeError("invalid suite type");
    var fe = B(ie, !1, ue.key, ue.iv);
    return Z(ee, fe.key, fe.iv);
  }
  return decrypter.createDecipher = Y, decrypter.createDecipheriv = Z, decrypter;
}
var hasRequiredBrowser$6;
function requireBrowser$6() {
  if (hasRequiredBrowser$6)
    return browser$5;
  hasRequiredBrowser$6 = 1;
  var e = requireEncrypter(), t = requireDecrypter(), h = require$$2;
  function o() {
    return Object.keys(h);
  }
  return browser$5.createCipher = browser$5.Cipher = e.createCipher, browser$5.createCipheriv = browser$5.Cipheriv = e.createCipheriv, browser$5.createDecipher = browser$5.Decipher = t.createDecipher, browser$5.createDecipheriv = browser$5.Decipheriv = t.createDecipheriv, browser$5.listCiphers = browser$5.getCiphers = o, browser$5;
}
var modes = {}, hasRequiredModes;
function requireModes() {
  return hasRequiredModes || (hasRequiredModes = 1, function(e) {
    e["des-ecb"] = {
      key: 8,
      iv: 0
    }, e["des-cbc"] = e.des = {
      key: 8,
      iv: 8
    }, e["des-ede3-cbc"] = e.des3 = {
      key: 24,
      iv: 8
    }, e["des-ede3"] = {
      key: 24,
      iv: 0
    }, e["des-ede-cbc"] = {
      key: 16,
      iv: 8
    }, e["des-ede"] = {
      key: 16,
      iv: 0
    };
  }(modes)), modes;
}
var hasRequiredBrowser$5;
function requireBrowser$5() {
  if (hasRequiredBrowser$5)
    return browser$6;
  hasRequiredBrowser$5 = 1;
  var e = requireBrowserifyDes(), t = requireBrowser$6(), h = requireModes$1(), o = requireModes(), S = requireEvp_bytestokey();
  function g(D, Z) {
    D = D.toLowerCase();
    var Y, ee;
    if (h[D])
      Y = h[D].key, ee = h[D].iv;
    else if (o[D])
      Y = o[D].key * 8, ee = o[D].iv;
    else
      throw new TypeError("invalid suite type");
    var ie = S(Z, !1, Y, ee);
    return M(D, ie.key, ie.iv);
  }
  function B(D, Z) {
    D = D.toLowerCase();
    var Y, ee;
    if (h[D])
      Y = h[D].key, ee = h[D].iv;
    else if (o[D])
      Y = o[D].key * 8, ee = o[D].iv;
    else
      throw new TypeError("invalid suite type");
    var ie = S(Z, !1, Y, ee);
    return O(D, ie.key, ie.iv);
  }
  function M(D, Z, Y) {
    if (D = D.toLowerCase(), h[D])
      return t.createCipheriv(D, Z, Y);
    if (o[D])
      return new e({ key: Z, iv: Y, mode: D });
    throw new TypeError("invalid suite type");
  }
  function O(D, Z, Y) {
    if (D = D.toLowerCase(), h[D])
      return t.createDecipheriv(D, Z, Y);
    if (o[D])
      return new e({ key: Z, iv: Y, mode: D, decrypt: !0 });
    throw new TypeError("invalid suite type");
  }
  function P() {
    return Object.keys(o).concat(t.getCiphers());
  }
  return browser$6.createCipher = browser$6.Cipher = g, browser$6.createCipheriv = browser$6.Cipheriv = M, browser$6.createDecipher = browser$6.Decipher = B, browser$6.createDecipheriv = browser$6.Decipheriv = O, browser$6.listCiphers = browser$6.getCiphers = P, browser$6;
}
var browser$4 = {}, bn$2 = { exports: {} }, hasRequiredBn$2;
function requireBn$2() {
  return hasRequiredBn$2 || (hasRequiredBn$2 = 1, function(e) {
    (function(t, h) {
      function o(J, ne) {
        if (!J)
          throw new Error(ne || "Assertion failed");
      }
      function S(J, ne) {
        J.super_ = ne;
        var A = function() {
        };
        A.prototype = ne.prototype, J.prototype = new A(), J.prototype.constructor = J;
      }
      function g(J, ne, A) {
        if (g.isBN(J))
          return J;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, J !== null && ((ne === "le" || ne === "be") && (A = ne, ne = 10), this._init(J || 0, ne || 10, A || "be"));
      }
      typeof t == "object" ? t.exports = g : h.BN = g, g.BN = g, g.wordSize = 26;
      var B;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? B = window.Buffer : B = requireBuffer$1().Buffer;
      } catch {
      }
      g.isBN = function(J) {
        return J instanceof g ? !0 : J !== null && typeof J == "object" && J.constructor.wordSize === g.wordSize && Array.isArray(J.words);
      }, g.max = function(J, ne) {
        return J.cmp(ne) > 0 ? J : ne;
      }, g.min = function(J, ne) {
        return J.cmp(ne) < 0 ? J : ne;
      }, g.prototype._init = function(J, ne, A) {
        if (typeof J == "number")
          return this._initNumber(J, ne, A);
        if (typeof J == "object")
          return this._initArray(J, ne, A);
        ne === "hex" && (ne = 16), o(ne === (ne | 0) && ne >= 2 && ne <= 36), J = J.toString().replace(/\s+/g, "");
        var I = 0;
        J[0] === "-" && (I++, this.negative = 1), I < J.length && (ne === 16 ? this._parseHex(J, I, A) : (this._parseBase(J, ne, I), A === "le" && this._initArray(this.toArray(), ne, A)));
      }, g.prototype._initNumber = function(J, ne, A) {
        J < 0 && (this.negative = 1, J = -J), J < 67108864 ? (this.words = [J & 67108863], this.length = 1) : J < 4503599627370496 ? (this.words = [
          J & 67108863,
          J / 67108864 & 67108863
        ], this.length = 2) : (o(J < 9007199254740992), this.words = [
          J & 67108863,
          J / 67108864 & 67108863,
          1
        ], this.length = 3), A === "le" && this._initArray(this.toArray(), ne, A);
      }, g.prototype._initArray = function(J, ne, A) {
        if (o(typeof J.length == "number"), J.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(J.length / 3), this.words = new Array(this.length);
        for (var I = 0; I < this.length; I++)
          this.words[I] = 0;
        var U, X, Q = 0;
        if (A === "be")
          for (I = J.length - 1, U = 0; I >= 0; I -= 3)
            X = J[I] | J[I - 1] << 8 | J[I - 2] << 16, this.words[U] |= X << Q & 67108863, this.words[U + 1] = X >>> 26 - Q & 67108863, Q += 24, Q >= 26 && (Q -= 26, U++);
        else if (A === "le")
          for (I = 0, U = 0; I < J.length; I += 3)
            X = J[I] | J[I + 1] << 8 | J[I + 2] << 16, this.words[U] |= X << Q & 67108863, this.words[U + 1] = X >>> 26 - Q & 67108863, Q += 24, Q >= 26 && (Q -= 26, U++);
        return this.strip();
      };
      function M(J, ne) {
        var A = J.charCodeAt(ne);
        return A >= 65 && A <= 70 ? A - 55 : A >= 97 && A <= 102 ? A - 87 : A - 48 & 15;
      }
      function O(J, ne, A) {
        var I = M(J, A);
        return A - 1 >= ne && (I |= M(J, A - 1) << 4), I;
      }
      g.prototype._parseHex = function(J, ne, A) {
        this.length = Math.ceil((J.length - ne) / 6), this.words = new Array(this.length);
        for (var I = 0; I < this.length; I++)
          this.words[I] = 0;
        var U = 0, X = 0, Q;
        if (A === "be")
          for (I = J.length - 1; I >= ne; I -= 2)
            Q = O(J, ne, I) << U, this.words[X] |= Q & 67108863, U >= 18 ? (U -= 18, X += 1, this.words[X] |= Q >>> 26) : U += 8;
        else {
          var F = J.length - ne;
          for (I = F % 2 === 0 ? ne + 1 : ne; I < J.length; I += 2)
            Q = O(J, ne, I) << U, this.words[X] |= Q & 67108863, U >= 18 ? (U -= 18, X += 1, this.words[X] |= Q >>> 26) : U += 8;
        }
        this.strip();
      };
      function P(J, ne, A, I) {
        for (var U = 0, X = Math.min(J.length, A), Q = ne; Q < X; Q++) {
          var F = J.charCodeAt(Q) - 48;
          U *= I, F >= 49 ? U += F - 49 + 10 : F >= 17 ? U += F - 17 + 10 : U += F;
        }
        return U;
      }
      g.prototype._parseBase = function(J, ne, A) {
        this.words = [0], this.length = 1;
        for (var I = 0, U = 1; U <= 67108863; U *= ne)
          I++;
        I--, U = U / ne | 0;
        for (var X = J.length - A, Q = X % I, F = Math.min(X, X - Q) + A, $ = 0, H = A; H < F; H += I)
          $ = P(J, H, H + I, ne), this.imuln(U), this.words[0] + $ < 67108864 ? this.words[0] += $ : this._iaddn($);
        if (Q !== 0) {
          var q = 1;
          for ($ = P(J, H, J.length, ne), H = 0; H < Q; H++)
            q *= ne;
          this.imuln(q), this.words[0] + $ < 67108864 ? this.words[0] += $ : this._iaddn($);
        }
        this.strip();
      }, g.prototype.copy = function(J) {
        J.words = new Array(this.length);
        for (var ne = 0; ne < this.length; ne++)
          J.words[ne] = this.words[ne];
        J.length = this.length, J.negative = this.negative, J.red = this.red;
      }, g.prototype.clone = function() {
        var J = new g(null);
        return this.copy(J), J;
      }, g.prototype._expand = function(J) {
        for (; this.length < J; )
          this.words[this.length++] = 0;
        return this;
      }, g.prototype.strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, g.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, g.prototype.inspect = function() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      };
      var D = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], Z = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], Y = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      g.prototype.toString = function(J, ne) {
        J = J || 10, ne = ne | 0 || 1;
        var A;
        if (J === 16 || J === "hex") {
          A = "";
          for (var I = 0, U = 0, X = 0; X < this.length; X++) {
            var Q = this.words[X], F = ((Q << I | U) & 16777215).toString(16);
            U = Q >>> 24 - I & 16777215, U !== 0 || X !== this.length - 1 ? A = D[6 - F.length] + F + A : A = F + A, I += 2, I >= 26 && (I -= 26, X--);
          }
          for (U !== 0 && (A = U.toString(16) + A); A.length % ne !== 0; )
            A = "0" + A;
          return this.negative !== 0 && (A = "-" + A), A;
        }
        if (J === (J | 0) && J >= 2 && J <= 36) {
          var $ = Z[J], H = Y[J];
          A = "";
          var q = this.clone();
          for (q.negative = 0; !q.isZero(); ) {
            var z = q.modn(H).toString(J);
            q = q.idivn(H), q.isZero() ? A = z + A : A = D[$ - z.length] + z + A;
          }
          for (this.isZero() && (A = "0" + A); A.length % ne !== 0; )
            A = "0" + A;
          return this.negative !== 0 && (A = "-" + A), A;
        }
        o(!1, "Base should be between 2 and 36");
      }, g.prototype.toNumber = function() {
        var J = this.words[0];
        return this.length === 2 ? J += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? J += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && o(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -J : J;
      }, g.prototype.toJSON = function() {
        return this.toString(16);
      }, g.prototype.toBuffer = function(J, ne) {
        return o(typeof B < "u"), this.toArrayLike(B, J, ne);
      }, g.prototype.toArray = function(J, ne) {
        return this.toArrayLike(Array, J, ne);
      }, g.prototype.toArrayLike = function(J, ne, A) {
        var I = this.byteLength(), U = A || Math.max(1, I);
        o(I <= U, "byte array longer than desired length"), o(U > 0, "Requested array length <= 0"), this.strip();
        var X = ne === "le", Q = new J(U), F, $, H = this.clone();
        if (X) {
          for ($ = 0; !H.isZero(); $++)
            F = H.andln(255), H.iushrn(8), Q[$] = F;
          for (; $ < U; $++)
            Q[$] = 0;
        } else {
          for ($ = 0; $ < U - I; $++)
            Q[$] = 0;
          for ($ = 0; !H.isZero(); $++)
            F = H.andln(255), H.iushrn(8), Q[U - $ - 1] = F;
        }
        return Q;
      }, Math.clz32 ? g.prototype._countBits = function(J) {
        return 32 - Math.clz32(J);
      } : g.prototype._countBits = function(J) {
        var ne = J, A = 0;
        return ne >= 4096 && (A += 13, ne >>>= 13), ne >= 64 && (A += 7, ne >>>= 7), ne >= 8 && (A += 4, ne >>>= 4), ne >= 2 && (A += 2, ne >>>= 2), A + ne;
      }, g.prototype._zeroBits = function(J) {
        if (J === 0)
          return 26;
        var ne = J, A = 0;
        return ne & 8191 || (A += 13, ne >>>= 13), ne & 127 || (A += 7, ne >>>= 7), ne & 15 || (A += 4, ne >>>= 4), ne & 3 || (A += 2, ne >>>= 2), ne & 1 || A++, A;
      }, g.prototype.bitLength = function() {
        var J = this.words[this.length - 1], ne = this._countBits(J);
        return (this.length - 1) * 26 + ne;
      };
      function ee(J) {
        for (var ne = new Array(J.bitLength()), A = 0; A < ne.length; A++) {
          var I = A / 26 | 0, U = A % 26;
          ne[A] = (J.words[I] & 1 << U) >>> U;
        }
        return ne;
      }
      g.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var J = 0, ne = 0; ne < this.length; ne++) {
          var A = this._zeroBits(this.words[ne]);
          if (J += A, A !== 26)
            break;
        }
        return J;
      }, g.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, g.prototype.toTwos = function(J) {
        return this.negative !== 0 ? this.abs().inotn(J).iaddn(1) : this.clone();
      }, g.prototype.fromTwos = function(J) {
        return this.testn(J - 1) ? this.notn(J).iaddn(1).ineg() : this.clone();
      }, g.prototype.isNeg = function() {
        return this.negative !== 0;
      }, g.prototype.neg = function() {
        return this.clone().ineg();
      }, g.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, g.prototype.iuor = function(J) {
        for (; this.length < J.length; )
          this.words[this.length++] = 0;
        for (var ne = 0; ne < J.length; ne++)
          this.words[ne] = this.words[ne] | J.words[ne];
        return this.strip();
      }, g.prototype.ior = function(J) {
        return o((this.negative | J.negative) === 0), this.iuor(J);
      }, g.prototype.or = function(J) {
        return this.length > J.length ? this.clone().ior(J) : J.clone().ior(this);
      }, g.prototype.uor = function(J) {
        return this.length > J.length ? this.clone().iuor(J) : J.clone().iuor(this);
      }, g.prototype.iuand = function(J) {
        var ne;
        this.length > J.length ? ne = J : ne = this;
        for (var A = 0; A < ne.length; A++)
          this.words[A] = this.words[A] & J.words[A];
        return this.length = ne.length, this.strip();
      }, g.prototype.iand = function(J) {
        return o((this.negative | J.negative) === 0), this.iuand(J);
      }, g.prototype.and = function(J) {
        return this.length > J.length ? this.clone().iand(J) : J.clone().iand(this);
      }, g.prototype.uand = function(J) {
        return this.length > J.length ? this.clone().iuand(J) : J.clone().iuand(this);
      }, g.prototype.iuxor = function(J) {
        var ne, A;
        this.length > J.length ? (ne = this, A = J) : (ne = J, A = this);
        for (var I = 0; I < A.length; I++)
          this.words[I] = ne.words[I] ^ A.words[I];
        if (this !== ne)
          for (; I < ne.length; I++)
            this.words[I] = ne.words[I];
        return this.length = ne.length, this.strip();
      }, g.prototype.ixor = function(J) {
        return o((this.negative | J.negative) === 0), this.iuxor(J);
      }, g.prototype.xor = function(J) {
        return this.length > J.length ? this.clone().ixor(J) : J.clone().ixor(this);
      }, g.prototype.uxor = function(J) {
        return this.length > J.length ? this.clone().iuxor(J) : J.clone().iuxor(this);
      }, g.prototype.inotn = function(J) {
        o(typeof J == "number" && J >= 0);
        var ne = Math.ceil(J / 26) | 0, A = J % 26;
        this._expand(ne), A > 0 && ne--;
        for (var I = 0; I < ne; I++)
          this.words[I] = ~this.words[I] & 67108863;
        return A > 0 && (this.words[I] = ~this.words[I] & 67108863 >> 26 - A), this.strip();
      }, g.prototype.notn = function(J) {
        return this.clone().inotn(J);
      }, g.prototype.setn = function(J, ne) {
        o(typeof J == "number" && J >= 0);
        var A = J / 26 | 0, I = J % 26;
        return this._expand(A + 1), ne ? this.words[A] = this.words[A] | 1 << I : this.words[A] = this.words[A] & ~(1 << I), this.strip();
      }, g.prototype.iadd = function(J) {
        var ne;
        if (this.negative !== 0 && J.negative === 0)
          return this.negative = 0, ne = this.isub(J), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && J.negative !== 0)
          return J.negative = 0, ne = this.isub(J), J.negative = 1, ne._normSign();
        var A, I;
        this.length > J.length ? (A = this, I = J) : (A = J, I = this);
        for (var U = 0, X = 0; X < I.length; X++)
          ne = (A.words[X] | 0) + (I.words[X] | 0) + U, this.words[X] = ne & 67108863, U = ne >>> 26;
        for (; U !== 0 && X < A.length; X++)
          ne = (A.words[X] | 0) + U, this.words[X] = ne & 67108863, U = ne >>> 26;
        if (this.length = A.length, U !== 0)
          this.words[this.length] = U, this.length++;
        else if (A !== this)
          for (; X < A.length; X++)
            this.words[X] = A.words[X];
        return this;
      }, g.prototype.add = function(J) {
        var ne;
        return J.negative !== 0 && this.negative === 0 ? (J.negative = 0, ne = this.sub(J), J.negative ^= 1, ne) : J.negative === 0 && this.negative !== 0 ? (this.negative = 0, ne = J.sub(this), this.negative = 1, ne) : this.length > J.length ? this.clone().iadd(J) : J.clone().iadd(this);
      }, g.prototype.isub = function(J) {
        if (J.negative !== 0) {
          J.negative = 0;
          var ne = this.iadd(J);
          return J.negative = 1, ne._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(J), this.negative = 1, this._normSign();
        var A = this.cmp(J);
        if (A === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var I, U;
        A > 0 ? (I = this, U = J) : (I = J, U = this);
        for (var X = 0, Q = 0; Q < U.length; Q++)
          ne = (I.words[Q] | 0) - (U.words[Q] | 0) + X, X = ne >> 26, this.words[Q] = ne & 67108863;
        for (; X !== 0 && Q < I.length; Q++)
          ne = (I.words[Q] | 0) + X, X = ne >> 26, this.words[Q] = ne & 67108863;
        if (X === 0 && Q < I.length && I !== this)
          for (; Q < I.length; Q++)
            this.words[Q] = I.words[Q];
        return this.length = Math.max(this.length, Q), I !== this && (this.negative = 1), this.strip();
      }, g.prototype.sub = function(J) {
        return this.clone().isub(J);
      };
      function ie(J, ne, A) {
        A.negative = ne.negative ^ J.negative;
        var I = J.length + ne.length | 0;
        A.length = I, I = I - 1 | 0;
        var U = J.words[0] | 0, X = ne.words[0] | 0, Q = U * X, F = Q & 67108863, $ = Q / 67108864 | 0;
        A.words[0] = F;
        for (var H = 1; H < I; H++) {
          for (var q = $ >>> 26, z = $ & 67108863, me = Math.min(H, ne.length - 1), Ce = Math.max(0, H - J.length + 1); Ce <= me; Ce++) {
            var je = H - Ce | 0;
            U = J.words[je] | 0, X = ne.words[Ce] | 0, Q = U * X + z, q += Q / 67108864 | 0, z = Q & 67108863;
          }
          A.words[H] = z | 0, $ = q | 0;
        }
        return $ !== 0 ? A.words[H] = $ | 0 : A.length--, A.strip();
      }
      var ue = function(J, ne, A) {
        var I = J.words, U = ne.words, X = A.words, Q = 0, F, $, H, q = I[0] | 0, z = q & 8191, me = q >>> 13, Ce = I[1] | 0, je = Ce & 8191, Re = Ce >>> 13, Ae = I[2] | 0, ke = Ae & 8191, Qe = Ae >>> 13, Ze = I[3] | 0, qe = Ze & 8191, Oe = Ze >>> 13, Xe = I[4] | 0, et = Xe & 8191, nt = Xe >>> 13, re = I[5] | 0, oe = re & 8191, le = re >>> 13, ge = I[6] | 0, Ke = ge & 8191, Je = ge >>> 13, Fe = I[7] | 0, Ye = Fe & 8191, it = Fe >>> 13, rt = I[8] | 0, tt = rt & 8191, vt = rt >>> 13, St = I[9] | 0, ot = St & 8191, si = St >>> 13, oi = U[0] | 0, At = oi & 8191, Nn = oi >>> 13, ui = U[1] | 0, Bt = ui & 8191, vi = ui >>> 13, fi = U[2] | 0, Ct = fi & 8191, rM = fi >>> 13, hi = U[3] | 0, Tt = hi & 8191, Dn = hi >>> 13, di = U[4] | 0, Ot = di & 8191, iM = di >>> 13, ci = U[5] | 0, Dt = ci & 8191, nM = ci >>> 13, li = U[6] | 0, ri = li & 8191, eM = li >>> 13, ai = U[7] | 0, It = ai & 8191, tM = ai >>> 13, pi = U[8] | 0, ii = pi & 8191, oM = pi >>> 13, gi = U[9] | 0, ni = gi & 8191, aM = gi >>> 13;
        A.negative = J.negative ^ ne.negative, A.length = 19, F = Math.imul(z, At), $ = Math.imul(z, Nn), $ = $ + Math.imul(me, At) | 0, H = Math.imul(me, Nn);
        var yi = (Q + F | 0) + (($ & 8191) << 13) | 0;
        Q = (H + ($ >>> 13) | 0) + (yi >>> 26) | 0, yi &= 67108863, F = Math.imul(je, At), $ = Math.imul(je, Nn), $ = $ + Math.imul(Re, At) | 0, H = Math.imul(Re, Nn), F = F + Math.imul(z, Bt) | 0, $ = $ + Math.imul(z, vi) | 0, $ = $ + Math.imul(me, Bt) | 0, H = H + Math.imul(me, vi) | 0;
        var mi = (Q + F | 0) + (($ & 8191) << 13) | 0;
        Q = (H + ($ >>> 13) | 0) + (mi >>> 26) | 0, mi &= 67108863, F = Math.imul(ke, At), $ = Math.imul(ke, Nn), $ = $ + Math.imul(Qe, At) | 0, H = Math.imul(Qe, Nn), F = F + Math.imul(je, Bt) | 0, $ = $ + Math.imul(je, vi) | 0, $ = $ + Math.imul(Re, Bt) | 0, H = H + Math.imul(Re, vi) | 0, F = F + Math.imul(z, Ct) | 0, $ = $ + Math.imul(z, rM) | 0, $ = $ + Math.imul(me, Ct) | 0, H = H + Math.imul(me, rM) | 0;
        var sM = (Q + F | 0) + (($ & 8191) << 13) | 0;
        Q = (H + ($ >>> 13) | 0) + (sM >>> 26) | 0, sM &= 67108863, F = Math.imul(qe, At), $ = Math.imul(qe, Nn), $ = $ + Math.imul(Oe, At) | 0, H = Math.imul(Oe, Nn), F = F + Math.imul(ke, Bt) | 0, $ = $ + Math.imul(ke, vi) | 0, $ = $ + Math.imul(Qe, Bt) | 0, H = H + Math.imul(Qe, vi) | 0, F = F + Math.imul(je, Ct) | 0, $ = $ + Math.imul(je, rM) | 0, $ = $ + Math.imul(Re, Ct) | 0, H = H + Math.imul(Re, rM) | 0, F = F + Math.imul(z, Tt) | 0, $ = $ + Math.imul(z, Dn) | 0, $ = $ + Math.imul(me, Tt) | 0, H = H + Math.imul(me, Dn) | 0;
        var uM = (Q + F | 0) + (($ & 8191) << 13) | 0;
        Q = (H + ($ >>> 13) | 0) + (uM >>> 26) | 0, uM &= 67108863, F = Math.imul(et, At), $ = Math.imul(et, Nn), $ = $ + Math.imul(nt, At) | 0, H = Math.imul(nt, Nn), F = F + Math.imul(qe, Bt) | 0, $ = $ + Math.imul(qe, vi) | 0, $ = $ + Math.imul(Oe, Bt) | 0, H = H + Math.imul(Oe, vi) | 0, F = F + Math.imul(ke, Ct) | 0, $ = $ + Math.imul(ke, rM) | 0, $ = $ + Math.imul(Qe, Ct) | 0, H = H + Math.imul(Qe, rM) | 0, F = F + Math.imul(je, Tt) | 0, $ = $ + Math.imul(je, Dn) | 0, $ = $ + Math.imul(Re, Tt) | 0, H = H + Math.imul(Re, Dn) | 0, F = F + Math.imul(z, Ot) | 0, $ = $ + Math.imul(z, iM) | 0, $ = $ + Math.imul(me, Ot) | 0, H = H + Math.imul(me, iM) | 0;
        var fM = (Q + F | 0) + (($ & 8191) << 13) | 0;
        Q = (H + ($ >>> 13) | 0) + (fM >>> 26) | 0, fM &= 67108863, F = Math.imul(oe, At), $ = Math.imul(oe, Nn), $ = $ + Math.imul(le, At) | 0, H = Math.imul(le, Nn), F = F + Math.imul(et, Bt) | 0, $ = $ + Math.imul(et, vi) | 0, $ = $ + Math.imul(nt, Bt) | 0, H = H + Math.imul(nt, vi) | 0, F = F + Math.imul(qe, Ct) | 0, $ = $ + Math.imul(qe, rM) | 0, $ = $ + Math.imul(Oe, Ct) | 0, H = H + Math.imul(Oe, rM) | 0, F = F + Math.imul(ke, Tt) | 0, $ = $ + Math.imul(ke, Dn) | 0, $ = $ + Math.imul(Qe, Tt) | 0, H = H + Math.imul(Qe, Dn) | 0, F = F + Math.imul(je, Ot) | 0, $ = $ + Math.imul(je, iM) | 0, $ = $ + Math.imul(Re, Ot) | 0, H = H + Math.imul(Re, iM) | 0, F = F + Math.imul(z, Dt) | 0, $ = $ + Math.imul(z, nM) | 0, $ = $ + Math.imul(me, Dt) | 0, H = H + Math.imul(me, nM) | 0;
        var hM = (Q + F | 0) + (($ & 8191) << 13) | 0;
        Q = (H + ($ >>> 13) | 0) + (hM >>> 26) | 0, hM &= 67108863, F = Math.imul(Ke, At), $ = Math.imul(Ke, Nn), $ = $ + Math.imul(Je, At) | 0, H = Math.imul(Je, Nn), F = F + Math.imul(oe, Bt) | 0, $ = $ + Math.imul(oe, vi) | 0, $ = $ + Math.imul(le, Bt) | 0, H = H + Math.imul(le, vi) | 0, F = F + Math.imul(et, Ct) | 0, $ = $ + Math.imul(et, rM) | 0, $ = $ + Math.imul(nt, Ct) | 0, H = H + Math.imul(nt, rM) | 0, F = F + Math.imul(qe, Tt) | 0, $ = $ + Math.imul(qe, Dn) | 0, $ = $ + Math.imul(Oe, Tt) | 0, H = H + Math.imul(Oe, Dn) | 0, F = F + Math.imul(ke, Ot) | 0, $ = $ + Math.imul(ke, iM) | 0, $ = $ + Math.imul(Qe, Ot) | 0, H = H + Math.imul(Qe, iM) | 0, F = F + Math.imul(je, Dt) | 0, $ = $ + Math.imul(je, nM) | 0, $ = $ + Math.imul(Re, Dt) | 0, H = H + Math.imul(Re, nM) | 0, F = F + Math.imul(z, ri) | 0, $ = $ + Math.imul(z, eM) | 0, $ = $ + Math.imul(me, ri) | 0, H = H + Math.imul(me, eM) | 0;
        var cM = (Q + F | 0) + (($ & 8191) << 13) | 0;
        Q = (H + ($ >>> 13) | 0) + (cM >>> 26) | 0, cM &= 67108863, F = Math.imul(Ye, At), $ = Math.imul(Ye, Nn), $ = $ + Math.imul(it, At) | 0, H = Math.imul(it, Nn), F = F + Math.imul(Ke, Bt) | 0, $ = $ + Math.imul(Ke, vi) | 0, $ = $ + Math.imul(Je, Bt) | 0, H = H + Math.imul(Je, vi) | 0, F = F + Math.imul(oe, Ct) | 0, $ = $ + Math.imul(oe, rM) | 0, $ = $ + Math.imul(le, Ct) | 0, H = H + Math.imul(le, rM) | 0, F = F + Math.imul(et, Tt) | 0, $ = $ + Math.imul(et, Dn) | 0, $ = $ + Math.imul(nt, Tt) | 0, H = H + Math.imul(nt, Dn) | 0, F = F + Math.imul(qe, Ot) | 0, $ = $ + Math.imul(qe, iM) | 0, $ = $ + Math.imul(Oe, Ot) | 0, H = H + Math.imul(Oe, iM) | 0, F = F + Math.imul(ke, Dt) | 0, $ = $ + Math.imul(ke, nM) | 0, $ = $ + Math.imul(Qe, Dt) | 0, H = H + Math.imul(Qe, nM) | 0, F = F + Math.imul(je, ri) | 0, $ = $ + Math.imul(je, eM) | 0, $ = $ + Math.imul(Re, ri) | 0, H = H + Math.imul(Re, eM) | 0, F = F + Math.imul(z, It) | 0, $ = $ + Math.imul(z, tM) | 0, $ = $ + Math.imul(me, It) | 0, H = H + Math.imul(me, tM) | 0;
        var lM = (Q + F | 0) + (($ & 8191) << 13) | 0;
        Q = (H + ($ >>> 13) | 0) + (lM >>> 26) | 0, lM &= 67108863, F = Math.imul(tt, At), $ = Math.imul(tt, Nn), $ = $ + Math.imul(vt, At) | 0, H = Math.imul(vt, Nn), F = F + Math.imul(Ye, Bt) | 0, $ = $ + Math.imul(Ye, vi) | 0, $ = $ + Math.imul(it, Bt) | 0, H = H + Math.imul(it, vi) | 0, F = F + Math.imul(Ke, Ct) | 0, $ = $ + Math.imul(Ke, rM) | 0, $ = $ + Math.imul(Je, Ct) | 0, H = H + Math.imul(Je, rM) | 0, F = F + Math.imul(oe, Tt) | 0, $ = $ + Math.imul(oe, Dn) | 0, $ = $ + Math.imul(le, Tt) | 0, H = H + Math.imul(le, Dn) | 0, F = F + Math.imul(et, Ot) | 0, $ = $ + Math.imul(et, iM) | 0, $ = $ + Math.imul(nt, Ot) | 0, H = H + Math.imul(nt, iM) | 0, F = F + Math.imul(qe, Dt) | 0, $ = $ + Math.imul(qe, nM) | 0, $ = $ + Math.imul(Oe, Dt) | 0, H = H + Math.imul(Oe, nM) | 0, F = F + Math.imul(ke, ri) | 0, $ = $ + Math.imul(ke, eM) | 0, $ = $ + Math.imul(Qe, ri) | 0, H = H + Math.imul(Qe, eM) | 0, F = F + Math.imul(je, It) | 0, $ = $ + Math.imul(je, tM) | 0, $ = $ + Math.imul(Re, It) | 0, H = H + Math.imul(Re, tM) | 0, F = F + Math.imul(z, ii) | 0, $ = $ + Math.imul(z, oM) | 0, $ = $ + Math.imul(me, ii) | 0, H = H + Math.imul(me, oM) | 0;
        var dM = (Q + F | 0) + (($ & 8191) << 13) | 0;
        Q = (H + ($ >>> 13) | 0) + (dM >>> 26) | 0, dM &= 67108863, F = Math.imul(ot, At), $ = Math.imul(ot, Nn), $ = $ + Math.imul(si, At) | 0, H = Math.imul(si, Nn), F = F + Math.imul(tt, Bt) | 0, $ = $ + Math.imul(tt, vi) | 0, $ = $ + Math.imul(vt, Bt) | 0, H = H + Math.imul(vt, vi) | 0, F = F + Math.imul(Ye, Ct) | 0, $ = $ + Math.imul(Ye, rM) | 0, $ = $ + Math.imul(it, Ct) | 0, H = H + Math.imul(it, rM) | 0, F = F + Math.imul(Ke, Tt) | 0, $ = $ + Math.imul(Ke, Dn) | 0, $ = $ + Math.imul(Je, Tt) | 0, H = H + Math.imul(Je, Dn) | 0, F = F + Math.imul(oe, Ot) | 0, $ = $ + Math.imul(oe, iM) | 0, $ = $ + Math.imul(le, Ot) | 0, H = H + Math.imul(le, iM) | 0, F = F + Math.imul(et, Dt) | 0, $ = $ + Math.imul(et, nM) | 0, $ = $ + Math.imul(nt, Dt) | 0, H = H + Math.imul(nt, nM) | 0, F = F + Math.imul(qe, ri) | 0, $ = $ + Math.imul(qe, eM) | 0, $ = $ + Math.imul(Oe, ri) | 0, H = H + Math.imul(Oe, eM) | 0, F = F + Math.imul(ke, It) | 0, $ = $ + Math.imul(ke, tM) | 0, $ = $ + Math.imul(Qe, It) | 0, H = H + Math.imul(Qe, tM) | 0, F = F + Math.imul(je, ii) | 0, $ = $ + Math.imul(je, oM) | 0, $ = $ + Math.imul(Re, ii) | 0, H = H + Math.imul(Re, oM) | 0, F = F + Math.imul(z, ni) | 0, $ = $ + Math.imul(z, aM) | 0, $ = $ + Math.imul(me, ni) | 0, H = H + Math.imul(me, aM) | 0;
        var pM = (Q + F | 0) + (($ & 8191) << 13) | 0;
        Q = (H + ($ >>> 13) | 0) + (pM >>> 26) | 0, pM &= 67108863, F = Math.imul(ot, Bt), $ = Math.imul(ot, vi), $ = $ + Math.imul(si, Bt) | 0, H = Math.imul(si, vi), F = F + Math.imul(tt, Ct) | 0, $ = $ + Math.imul(tt, rM) | 0, $ = $ + Math.imul(vt, Ct) | 0, H = H + Math.imul(vt, rM) | 0, F = F + Math.imul(Ye, Tt) | 0, $ = $ + Math.imul(Ye, Dn) | 0, $ = $ + Math.imul(it, Tt) | 0, H = H + Math.imul(it, Dn) | 0, F = F + Math.imul(Ke, Ot) | 0, $ = $ + Math.imul(Ke, iM) | 0, $ = $ + Math.imul(Je, Ot) | 0, H = H + Math.imul(Je, iM) | 0, F = F + Math.imul(oe, Dt) | 0, $ = $ + Math.imul(oe, nM) | 0, $ = $ + Math.imul(le, Dt) | 0, H = H + Math.imul(le, nM) | 0, F = F + Math.imul(et, ri) | 0, $ = $ + Math.imul(et, eM) | 0, $ = $ + Math.imul(nt, ri) | 0, H = H + Math.imul(nt, eM) | 0, F = F + Math.imul(qe, It) | 0, $ = $ + Math.imul(qe, tM) | 0, $ = $ + Math.imul(Oe, It) | 0, H = H + Math.imul(Oe, tM) | 0, F = F + Math.imul(ke, ii) | 0, $ = $ + Math.imul(ke, oM) | 0, $ = $ + Math.imul(Qe, ii) | 0, H = H + Math.imul(Qe, oM) | 0, F = F + Math.imul(je, ni) | 0, $ = $ + Math.imul(je, aM) | 0, $ = $ + Math.imul(Re, ni) | 0, H = H + Math.imul(Re, aM) | 0;
        var yM = (Q + F | 0) + (($ & 8191) << 13) | 0;
        Q = (H + ($ >>> 13) | 0) + (yM >>> 26) | 0, yM &= 67108863, F = Math.imul(ot, Ct), $ = Math.imul(ot, rM), $ = $ + Math.imul(si, Ct) | 0, H = Math.imul(si, rM), F = F + Math.imul(tt, Tt) | 0, $ = $ + Math.imul(tt, Dn) | 0, $ = $ + Math.imul(vt, Tt) | 0, H = H + Math.imul(vt, Dn) | 0, F = F + Math.imul(Ye, Ot) | 0, $ = $ + Math.imul(Ye, iM) | 0, $ = $ + Math.imul(it, Ot) | 0, H = H + Math.imul(it, iM) | 0, F = F + Math.imul(Ke, Dt) | 0, $ = $ + Math.imul(Ke, nM) | 0, $ = $ + Math.imul(Je, Dt) | 0, H = H + Math.imul(Je, nM) | 0, F = F + Math.imul(oe, ri) | 0, $ = $ + Math.imul(oe, eM) | 0, $ = $ + Math.imul(le, ri) | 0, H = H + Math.imul(le, eM) | 0, F = F + Math.imul(et, It) | 0, $ = $ + Math.imul(et, tM) | 0, $ = $ + Math.imul(nt, It) | 0, H = H + Math.imul(nt, tM) | 0, F = F + Math.imul(qe, ii) | 0, $ = $ + Math.imul(qe, oM) | 0, $ = $ + Math.imul(Oe, ii) | 0, H = H + Math.imul(Oe, oM) | 0, F = F + Math.imul(ke, ni) | 0, $ = $ + Math.imul(ke, aM) | 0, $ = $ + Math.imul(Qe, ni) | 0, H = H + Math.imul(Qe, aM) | 0;
        var mM = (Q + F | 0) + (($ & 8191) << 13) | 0;
        Q = (H + ($ >>> 13) | 0) + (mM >>> 26) | 0, mM &= 67108863, F = Math.imul(ot, Tt), $ = Math.imul(ot, Dn), $ = $ + Math.imul(si, Tt) | 0, H = Math.imul(si, Dn), F = F + Math.imul(tt, Ot) | 0, $ = $ + Math.imul(tt, iM) | 0, $ = $ + Math.imul(vt, Ot) | 0, H = H + Math.imul(vt, iM) | 0, F = F + Math.imul(Ye, Dt) | 0, $ = $ + Math.imul(Ye, nM) | 0, $ = $ + Math.imul(it, Dt) | 0, H = H + Math.imul(it, nM) | 0, F = F + Math.imul(Ke, ri) | 0, $ = $ + Math.imul(Ke, eM) | 0, $ = $ + Math.imul(Je, ri) | 0, H = H + Math.imul(Je, eM) | 0, F = F + Math.imul(oe, It) | 0, $ = $ + Math.imul(oe, tM) | 0, $ = $ + Math.imul(le, It) | 0, H = H + Math.imul(le, tM) | 0, F = F + Math.imul(et, ii) | 0, $ = $ + Math.imul(et, oM) | 0, $ = $ + Math.imul(nt, ii) | 0, H = H + Math.imul(nt, oM) | 0, F = F + Math.imul(qe, ni) | 0, $ = $ + Math.imul(qe, aM) | 0, $ = $ + Math.imul(Oe, ni) | 0, H = H + Math.imul(Oe, aM) | 0;
        var gM = (Q + F | 0) + (($ & 8191) << 13) | 0;
        Q = (H + ($ >>> 13) | 0) + (gM >>> 26) | 0, gM &= 67108863, F = Math.imul(ot, Ot), $ = Math.imul(ot, iM), $ = $ + Math.imul(si, Ot) | 0, H = Math.imul(si, iM), F = F + Math.imul(tt, Dt) | 0, $ = $ + Math.imul(tt, nM) | 0, $ = $ + Math.imul(vt, Dt) | 0, H = H + Math.imul(vt, nM) | 0, F = F + Math.imul(Ye, ri) | 0, $ = $ + Math.imul(Ye, eM) | 0, $ = $ + Math.imul(it, ri) | 0, H = H + Math.imul(it, eM) | 0, F = F + Math.imul(Ke, It) | 0, $ = $ + Math.imul(Ke, tM) | 0, $ = $ + Math.imul(Je, It) | 0, H = H + Math.imul(Je, tM) | 0, F = F + Math.imul(oe, ii) | 0, $ = $ + Math.imul(oe, oM) | 0, $ = $ + Math.imul(le, ii) | 0, H = H + Math.imul(le, oM) | 0, F = F + Math.imul(et, ni) | 0, $ = $ + Math.imul(et, aM) | 0, $ = $ + Math.imul(nt, ni) | 0, H = H + Math.imul(nt, aM) | 0;
        var bM = (Q + F | 0) + (($ & 8191) << 13) | 0;
        Q = (H + ($ >>> 13) | 0) + (bM >>> 26) | 0, bM &= 67108863, F = Math.imul(ot, Dt), $ = Math.imul(ot, nM), $ = $ + Math.imul(si, Dt) | 0, H = Math.imul(si, nM), F = F + Math.imul(tt, ri) | 0, $ = $ + Math.imul(tt, eM) | 0, $ = $ + Math.imul(vt, ri) | 0, H = H + Math.imul(vt, eM) | 0, F = F + Math.imul(Ye, It) | 0, $ = $ + Math.imul(Ye, tM) | 0, $ = $ + Math.imul(it, It) | 0, H = H + Math.imul(it, tM) | 0, F = F + Math.imul(Ke, ii) | 0, $ = $ + Math.imul(Ke, oM) | 0, $ = $ + Math.imul(Je, ii) | 0, H = H + Math.imul(Je, oM) | 0, F = F + Math.imul(oe, ni) | 0, $ = $ + Math.imul(oe, aM) | 0, $ = $ + Math.imul(le, ni) | 0, H = H + Math.imul(le, aM) | 0;
        var vM = (Q + F | 0) + (($ & 8191) << 13) | 0;
        Q = (H + ($ >>> 13) | 0) + (vM >>> 26) | 0, vM &= 67108863, F = Math.imul(ot, ri), $ = Math.imul(ot, eM), $ = $ + Math.imul(si, ri) | 0, H = Math.imul(si, eM), F = F + Math.imul(tt, It) | 0, $ = $ + Math.imul(tt, tM) | 0, $ = $ + Math.imul(vt, It) | 0, H = H + Math.imul(vt, tM) | 0, F = F + Math.imul(Ye, ii) | 0, $ = $ + Math.imul(Ye, oM) | 0, $ = $ + Math.imul(it, ii) | 0, H = H + Math.imul(it, oM) | 0, F = F + Math.imul(Ke, ni) | 0, $ = $ + Math.imul(Ke, aM) | 0, $ = $ + Math.imul(Je, ni) | 0, H = H + Math.imul(Je, aM) | 0;
        var wM = (Q + F | 0) + (($ & 8191) << 13) | 0;
        Q = (H + ($ >>> 13) | 0) + (wM >>> 26) | 0, wM &= 67108863, F = Math.imul(ot, It), $ = Math.imul(ot, tM), $ = $ + Math.imul(si, It) | 0, H = Math.imul(si, tM), F = F + Math.imul(tt, ii) | 0, $ = $ + Math.imul(tt, oM) | 0, $ = $ + Math.imul(vt, ii) | 0, H = H + Math.imul(vt, oM) | 0, F = F + Math.imul(Ye, ni) | 0, $ = $ + Math.imul(Ye, aM) | 0, $ = $ + Math.imul(it, ni) | 0, H = H + Math.imul(it, aM) | 0;
        var _M = (Q + F | 0) + (($ & 8191) << 13) | 0;
        Q = (H + ($ >>> 13) | 0) + (_M >>> 26) | 0, _M &= 67108863, F = Math.imul(ot, ii), $ = Math.imul(ot, oM), $ = $ + Math.imul(si, ii) | 0, H = Math.imul(si, oM), F = F + Math.imul(tt, ni) | 0, $ = $ + Math.imul(tt, aM) | 0, $ = $ + Math.imul(vt, ni) | 0, H = H + Math.imul(vt, aM) | 0;
        var SM = (Q + F | 0) + (($ & 8191) << 13) | 0;
        Q = (H + ($ >>> 13) | 0) + (SM >>> 26) | 0, SM &= 67108863, F = Math.imul(ot, ni), $ = Math.imul(ot, aM), $ = $ + Math.imul(si, ni) | 0, H = Math.imul(si, aM);
        var EM = (Q + F | 0) + (($ & 8191) << 13) | 0;
        return Q = (H + ($ >>> 13) | 0) + (EM >>> 26) | 0, EM &= 67108863, X[0] = yi, X[1] = mi, X[2] = sM, X[3] = uM, X[4] = fM, X[5] = hM, X[6] = cM, X[7] = lM, X[8] = dM, X[9] = pM, X[10] = yM, X[11] = mM, X[12] = gM, X[13] = bM, X[14] = vM, X[15] = wM, X[16] = _M, X[17] = SM, X[18] = EM, Q !== 0 && (X[19] = Q, A.length++), A;
      };
      Math.imul || (ue = ie);
      function fe(J, ne, A) {
        A.negative = ne.negative ^ J.negative, A.length = J.length + ne.length;
        for (var I = 0, U = 0, X = 0; X < A.length - 1; X++) {
          var Q = U;
          U = 0;
          for (var F = I & 67108863, $ = Math.min(X, ne.length - 1), H = Math.max(0, X - J.length + 1); H <= $; H++) {
            var q = X - H, z = J.words[q] | 0, me = ne.words[H] | 0, Ce = z * me, je = Ce & 67108863;
            Q = Q + (Ce / 67108864 | 0) | 0, je = je + F | 0, F = je & 67108863, Q = Q + (je >>> 26) | 0, U += Q >>> 26, Q &= 67108863;
          }
          A.words[X] = F, I = Q, Q = U;
        }
        return I !== 0 ? A.words[X] = I : A.length--, A.strip();
      }
      function de(J, ne, A) {
        var I = new ce();
        return I.mulp(J, ne, A);
      }
      g.prototype.mulTo = function(J, ne) {
        var A, I = this.length + J.length;
        return this.length === 10 && J.length === 10 ? A = ue(this, J, ne) : I < 63 ? A = ie(this, J, ne) : I < 1024 ? A = fe(this, J, ne) : A = de(this, J, ne), A;
      };
      function ce(J, ne) {
        this.x = J, this.y = ne;
      }
      ce.prototype.makeRBT = function(J) {
        for (var ne = new Array(J), A = g.prototype._countBits(J) - 1, I = 0; I < J; I++)
          ne[I] = this.revBin(I, A, J);
        return ne;
      }, ce.prototype.revBin = function(J, ne, A) {
        if (J === 0 || J === A - 1)
          return J;
        for (var I = 0, U = 0; U < ne; U++)
          I |= (J & 1) << ne - U - 1, J >>= 1;
        return I;
      }, ce.prototype.permute = function(J, ne, A, I, U, X) {
        for (var Q = 0; Q < X; Q++)
          I[Q] = ne[J[Q]], U[Q] = A[J[Q]];
      }, ce.prototype.transform = function(J, ne, A, I, U, X) {
        this.permute(X, J, ne, A, I, U);
        for (var Q = 1; Q < U; Q <<= 1)
          for (var F = Q << 1, $ = Math.cos(2 * Math.PI / F), H = Math.sin(2 * Math.PI / F), q = 0; q < U; q += F)
            for (var z = $, me = H, Ce = 0; Ce < Q; Ce++) {
              var je = A[q + Ce], Re = I[q + Ce], Ae = A[q + Ce + Q], ke = I[q + Ce + Q], Qe = z * Ae - me * ke;
              ke = z * ke + me * Ae, Ae = Qe, A[q + Ce] = je + Ae, I[q + Ce] = Re + ke, A[q + Ce + Q] = je - Ae, I[q + Ce + Q] = Re - ke, Ce !== F && (Qe = $ * z - H * me, me = $ * me + H * z, z = Qe);
            }
      }, ce.prototype.guessLen13b = function(J, ne) {
        var A = Math.max(ne, J) | 1, I = A & 1, U = 0;
        for (A = A / 2 | 0; A; A = A >>> 1)
          U++;
        return 1 << U + 1 + I;
      }, ce.prototype.conjugate = function(J, ne, A) {
        if (!(A <= 1))
          for (var I = 0; I < A / 2; I++) {
            var U = J[I];
            J[I] = J[A - I - 1], J[A - I - 1] = U, U = ne[I], ne[I] = -ne[A - I - 1], ne[A - I - 1] = -U;
          }
      }, ce.prototype.normalize13b = function(J, ne) {
        for (var A = 0, I = 0; I < ne / 2; I++) {
          var U = Math.round(J[2 * I + 1] / ne) * 8192 + Math.round(J[2 * I] / ne) + A;
          J[I] = U & 67108863, U < 67108864 ? A = 0 : A = U / 67108864 | 0;
        }
        return J;
      }, ce.prototype.convert13b = function(J, ne, A, I) {
        for (var U = 0, X = 0; X < ne; X++)
          U = U + (J[X] | 0), A[2 * X] = U & 8191, U = U >>> 13, A[2 * X + 1] = U & 8191, U = U >>> 13;
        for (X = 2 * ne; X < I; ++X)
          A[X] = 0;
        o(U === 0), o((U & -8192) === 0);
      }, ce.prototype.stub = function(J) {
        for (var ne = new Array(J), A = 0; A < J; A++)
          ne[A] = 0;
        return ne;
      }, ce.prototype.mulp = function(J, ne, A) {
        var I = 2 * this.guessLen13b(J.length, ne.length), U = this.makeRBT(I), X = this.stub(I), Q = new Array(I), F = new Array(I), $ = new Array(I), H = new Array(I), q = new Array(I), z = new Array(I), me = A.words;
        me.length = I, this.convert13b(J.words, J.length, Q, I), this.convert13b(ne.words, ne.length, H, I), this.transform(Q, X, F, $, I, U), this.transform(H, X, q, z, I, U);
        for (var Ce = 0; Ce < I; Ce++) {
          var je = F[Ce] * q[Ce] - $[Ce] * z[Ce];
          $[Ce] = F[Ce] * z[Ce] + $[Ce] * q[Ce], F[Ce] = je;
        }
        return this.conjugate(F, $, I), this.transform(F, $, me, X, I, U), this.conjugate(me, X, I), this.normalize13b(me, I), A.negative = J.negative ^ ne.negative, A.length = J.length + ne.length, A.strip();
      }, g.prototype.mul = function(J) {
        var ne = new g(null);
        return ne.words = new Array(this.length + J.length), this.mulTo(J, ne);
      }, g.prototype.mulf = function(J) {
        var ne = new g(null);
        return ne.words = new Array(this.length + J.length), de(this, J, ne);
      }, g.prototype.imul = function(J) {
        return this.clone().mulTo(J, this);
      }, g.prototype.imuln = function(J) {
        o(typeof J == "number"), o(J < 67108864);
        for (var ne = 0, A = 0; A < this.length; A++) {
          var I = (this.words[A] | 0) * J, U = (I & 67108863) + (ne & 67108863);
          ne >>= 26, ne += I / 67108864 | 0, ne += U >>> 26, this.words[A] = U & 67108863;
        }
        return ne !== 0 && (this.words[A] = ne, this.length++), this;
      }, g.prototype.muln = function(J) {
        return this.clone().imuln(J);
      }, g.prototype.sqr = function() {
        return this.mul(this);
      }, g.prototype.isqr = function() {
        return this.imul(this.clone());
      }, g.prototype.pow = function(J) {
        var ne = ee(J);
        if (ne.length === 0)
          return new g(1);
        for (var A = this, I = 0; I < ne.length && ne[I] === 0; I++, A = A.sqr())
          ;
        if (++I < ne.length)
          for (var U = A.sqr(); I < ne.length; I++, U = U.sqr())
            ne[I] !== 0 && (A = A.mul(U));
        return A;
      }, g.prototype.iushln = function(J) {
        o(typeof J == "number" && J >= 0);
        var ne = J % 26, A = (J - ne) / 26, I = 67108863 >>> 26 - ne << 26 - ne, U;
        if (ne !== 0) {
          var X = 0;
          for (U = 0; U < this.length; U++) {
            var Q = this.words[U] & I, F = (this.words[U] | 0) - Q << ne;
            this.words[U] = F | X, X = Q >>> 26 - ne;
          }
          X && (this.words[U] = X, this.length++);
        }
        if (A !== 0) {
          for (U = this.length - 1; U >= 0; U--)
            this.words[U + A] = this.words[U];
          for (U = 0; U < A; U++)
            this.words[U] = 0;
          this.length += A;
        }
        return this.strip();
      }, g.prototype.ishln = function(J) {
        return o(this.negative === 0), this.iushln(J);
      }, g.prototype.iushrn = function(J, ne, A) {
        o(typeof J == "number" && J >= 0);
        var I;
        ne ? I = (ne - ne % 26) / 26 : I = 0;
        var U = J % 26, X = Math.min((J - U) / 26, this.length), Q = 67108863 ^ 67108863 >>> U << U, F = A;
        if (I -= X, I = Math.max(0, I), F) {
          for (var $ = 0; $ < X; $++)
            F.words[$] = this.words[$];
          F.length = X;
        }
        if (X !== 0)
          if (this.length > X)
            for (this.length -= X, $ = 0; $ < this.length; $++)
              this.words[$] = this.words[$ + X];
          else
            this.words[0] = 0, this.length = 1;
        var H = 0;
        for ($ = this.length - 1; $ >= 0 && (H !== 0 || $ >= I); $--) {
          var q = this.words[$] | 0;
          this.words[$] = H << 26 - U | q >>> U, H = q & Q;
        }
        return F && H !== 0 && (F.words[F.length++] = H), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
      }, g.prototype.ishrn = function(J, ne, A) {
        return o(this.negative === 0), this.iushrn(J, ne, A);
      }, g.prototype.shln = function(J) {
        return this.clone().ishln(J);
      }, g.prototype.ushln = function(J) {
        return this.clone().iushln(J);
      }, g.prototype.shrn = function(J) {
        return this.clone().ishrn(J);
      }, g.prototype.ushrn = function(J) {
        return this.clone().iushrn(J);
      }, g.prototype.testn = function(J) {
        o(typeof J == "number" && J >= 0);
        var ne = J % 26, A = (J - ne) / 26, I = 1 << ne;
        if (this.length <= A)
          return !1;
        var U = this.words[A];
        return !!(U & I);
      }, g.prototype.imaskn = function(J) {
        o(typeof J == "number" && J >= 0);
        var ne = J % 26, A = (J - ne) / 26;
        if (o(this.negative === 0, "imaskn works only with positive numbers"), this.length <= A)
          return this;
        if (ne !== 0 && A++, this.length = Math.min(A, this.length), ne !== 0) {
          var I = 67108863 ^ 67108863 >>> ne << ne;
          this.words[this.length - 1] &= I;
        }
        return this.strip();
      }, g.prototype.maskn = function(J) {
        return this.clone().imaskn(J);
      }, g.prototype.iaddn = function(J) {
        return o(typeof J == "number"), o(J < 67108864), J < 0 ? this.isubn(-J) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < J ? (this.words[0] = J - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(J), this.negative = 1, this) : this._iaddn(J);
      }, g.prototype._iaddn = function(J) {
        this.words[0] += J;
        for (var ne = 0; ne < this.length && this.words[ne] >= 67108864; ne++)
          this.words[ne] -= 67108864, ne === this.length - 1 ? this.words[ne + 1] = 1 : this.words[ne + 1]++;
        return this.length = Math.max(this.length, ne + 1), this;
      }, g.prototype.isubn = function(J) {
        if (o(typeof J == "number"), o(J < 67108864), J < 0)
          return this.iaddn(-J);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(J), this.negative = 1, this;
        if (this.words[0] -= J, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var ne = 0; ne < this.length && this.words[ne] < 0; ne++)
            this.words[ne] += 67108864, this.words[ne + 1] -= 1;
        return this.strip();
      }, g.prototype.addn = function(J) {
        return this.clone().iaddn(J);
      }, g.prototype.subn = function(J) {
        return this.clone().isubn(J);
      }, g.prototype.iabs = function() {
        return this.negative = 0, this;
      }, g.prototype.abs = function() {
        return this.clone().iabs();
      }, g.prototype._ishlnsubmul = function(J, ne, A) {
        var I = J.length + A, U;
        this._expand(I);
        var X, Q = 0;
        for (U = 0; U < J.length; U++) {
          X = (this.words[U + A] | 0) + Q;
          var F = (J.words[U] | 0) * ne;
          X -= F & 67108863, Q = (X >> 26) - (F / 67108864 | 0), this.words[U + A] = X & 67108863;
        }
        for (; U < this.length - A; U++)
          X = (this.words[U + A] | 0) + Q, Q = X >> 26, this.words[U + A] = X & 67108863;
        if (Q === 0)
          return this.strip();
        for (o(Q === -1), Q = 0, U = 0; U < this.length; U++)
          X = -(this.words[U] | 0) + Q, Q = X >> 26, this.words[U] = X & 67108863;
        return this.negative = 1, this.strip();
      }, g.prototype._wordDiv = function(J, ne) {
        var A = this.length - J.length, I = this.clone(), U = J, X = U.words[U.length - 1] | 0, Q = this._countBits(X);
        A = 26 - Q, A !== 0 && (U = U.ushln(A), I.iushln(A), X = U.words[U.length - 1] | 0);
        var F = I.length - U.length, $;
        if (ne !== "mod") {
          $ = new g(null), $.length = F + 1, $.words = new Array($.length);
          for (var H = 0; H < $.length; H++)
            $.words[H] = 0;
        }
        var q = I.clone()._ishlnsubmul(U, 1, F);
        q.negative === 0 && (I = q, $ && ($.words[F] = 1));
        for (var z = F - 1; z >= 0; z--) {
          var me = (I.words[U.length + z] | 0) * 67108864 + (I.words[U.length + z - 1] | 0);
          for (me = Math.min(me / X | 0, 67108863), I._ishlnsubmul(U, me, z); I.negative !== 0; )
            me--, I.negative = 0, I._ishlnsubmul(U, 1, z), I.isZero() || (I.negative ^= 1);
          $ && ($.words[z] = me);
        }
        return $ && $.strip(), I.strip(), ne !== "div" && A !== 0 && I.iushrn(A), {
          div: $ || null,
          mod: I
        };
      }, g.prototype.divmod = function(J, ne, A) {
        if (o(!J.isZero()), this.isZero())
          return {
            div: new g(0),
            mod: new g(0)
          };
        var I, U, X;
        return this.negative !== 0 && J.negative === 0 ? (X = this.neg().divmod(J, ne), ne !== "mod" && (I = X.div.neg()), ne !== "div" && (U = X.mod.neg(), A && U.negative !== 0 && U.iadd(J)), {
          div: I,
          mod: U
        }) : this.negative === 0 && J.negative !== 0 ? (X = this.divmod(J.neg(), ne), ne !== "mod" && (I = X.div.neg()), {
          div: I,
          mod: X.mod
        }) : this.negative & J.negative ? (X = this.neg().divmod(J.neg(), ne), ne !== "div" && (U = X.mod.neg(), A && U.negative !== 0 && U.isub(J)), {
          div: X.div,
          mod: U
        }) : J.length > this.length || this.cmp(J) < 0 ? {
          div: new g(0),
          mod: this
        } : J.length === 1 ? ne === "div" ? {
          div: this.divn(J.words[0]),
          mod: null
        } : ne === "mod" ? {
          div: null,
          mod: new g(this.modn(J.words[0]))
        } : {
          div: this.divn(J.words[0]),
          mod: new g(this.modn(J.words[0]))
        } : this._wordDiv(J, ne);
      }, g.prototype.div = function(J) {
        return this.divmod(J, "div", !1).div;
      }, g.prototype.mod = function(J) {
        return this.divmod(J, "mod", !1).mod;
      }, g.prototype.umod = function(J) {
        return this.divmod(J, "mod", !0).mod;
      }, g.prototype.divRound = function(J) {
        var ne = this.divmod(J);
        if (ne.mod.isZero())
          return ne.div;
        var A = ne.div.negative !== 0 ? ne.mod.isub(J) : ne.mod, I = J.ushrn(1), U = J.andln(1), X = A.cmp(I);
        return X < 0 || U === 1 && X === 0 ? ne.div : ne.div.negative !== 0 ? ne.div.isubn(1) : ne.div.iaddn(1);
      }, g.prototype.modn = function(J) {
        o(J <= 67108863);
        for (var ne = (1 << 26) % J, A = 0, I = this.length - 1; I >= 0; I--)
          A = (ne * A + (this.words[I] | 0)) % J;
        return A;
      }, g.prototype.idivn = function(J) {
        o(J <= 67108863);
        for (var ne = 0, A = this.length - 1; A >= 0; A--) {
          var I = (this.words[A] | 0) + ne * 67108864;
          this.words[A] = I / J | 0, ne = I % J;
        }
        return this.strip();
      }, g.prototype.divn = function(J) {
        return this.clone().idivn(J);
      }, g.prototype.egcd = function(J) {
        o(J.negative === 0), o(!J.isZero());
        var ne = this, A = J.clone();
        ne.negative !== 0 ? ne = ne.umod(J) : ne = ne.clone();
        for (var I = new g(1), U = new g(0), X = new g(0), Q = new g(1), F = 0; ne.isEven() && A.isEven(); )
          ne.iushrn(1), A.iushrn(1), ++F;
        for (var $ = A.clone(), H = ne.clone(); !ne.isZero(); ) {
          for (var q = 0, z = 1; !(ne.words[0] & z) && q < 26; ++q, z <<= 1)
            ;
          if (q > 0)
            for (ne.iushrn(q); q-- > 0; )
              (I.isOdd() || U.isOdd()) && (I.iadd($), U.isub(H)), I.iushrn(1), U.iushrn(1);
          for (var me = 0, Ce = 1; !(A.words[0] & Ce) && me < 26; ++me, Ce <<= 1)
            ;
          if (me > 0)
            for (A.iushrn(me); me-- > 0; )
              (X.isOdd() || Q.isOdd()) && (X.iadd($), Q.isub(H)), X.iushrn(1), Q.iushrn(1);
          ne.cmp(A) >= 0 ? (ne.isub(A), I.isub(X), U.isub(Q)) : (A.isub(ne), X.isub(I), Q.isub(U));
        }
        return {
          a: X,
          b: Q,
          gcd: A.iushln(F)
        };
      }, g.prototype._invmp = function(J) {
        o(J.negative === 0), o(!J.isZero());
        var ne = this, A = J.clone();
        ne.negative !== 0 ? ne = ne.umod(J) : ne = ne.clone();
        for (var I = new g(1), U = new g(0), X = A.clone(); ne.cmpn(1) > 0 && A.cmpn(1) > 0; ) {
          for (var Q = 0, F = 1; !(ne.words[0] & F) && Q < 26; ++Q, F <<= 1)
            ;
          if (Q > 0)
            for (ne.iushrn(Q); Q-- > 0; )
              I.isOdd() && I.iadd(X), I.iushrn(1);
          for (var $ = 0, H = 1; !(A.words[0] & H) && $ < 26; ++$, H <<= 1)
            ;
          if ($ > 0)
            for (A.iushrn($); $-- > 0; )
              U.isOdd() && U.iadd(X), U.iushrn(1);
          ne.cmp(A) >= 0 ? (ne.isub(A), I.isub(U)) : (A.isub(ne), U.isub(I));
        }
        var q;
        return ne.cmpn(1) === 0 ? q = I : q = U, q.cmpn(0) < 0 && q.iadd(J), q;
      }, g.prototype.gcd = function(J) {
        if (this.isZero())
          return J.abs();
        if (J.isZero())
          return this.abs();
        var ne = this.clone(), A = J.clone();
        ne.negative = 0, A.negative = 0;
        for (var I = 0; ne.isEven() && A.isEven(); I++)
          ne.iushrn(1), A.iushrn(1);
        do {
          for (; ne.isEven(); )
            ne.iushrn(1);
          for (; A.isEven(); )
            A.iushrn(1);
          var U = ne.cmp(A);
          if (U < 0) {
            var X = ne;
            ne = A, A = X;
          } else if (U === 0 || A.cmpn(1) === 0)
            break;
          ne.isub(A);
        } while (!0);
        return A.iushln(I);
      }, g.prototype.invm = function(J) {
        return this.egcd(J).a.umod(J);
      }, g.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, g.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, g.prototype.andln = function(J) {
        return this.words[0] & J;
      }, g.prototype.bincn = function(J) {
        o(typeof J == "number");
        var ne = J % 26, A = (J - ne) / 26, I = 1 << ne;
        if (this.length <= A)
          return this._expand(A + 1), this.words[A] |= I, this;
        for (var U = I, X = A; U !== 0 && X < this.length; X++) {
          var Q = this.words[X] | 0;
          Q += U, U = Q >>> 26, Q &= 67108863, this.words[X] = Q;
        }
        return U !== 0 && (this.words[X] = U, this.length++), this;
      }, g.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, g.prototype.cmpn = function(J) {
        var ne = J < 0;
        if (this.negative !== 0 && !ne)
          return -1;
        if (this.negative === 0 && ne)
          return 1;
        this.strip();
        var A;
        if (this.length > 1)
          A = 1;
        else {
          ne && (J = -J), o(J <= 67108863, "Number is too big");
          var I = this.words[0] | 0;
          A = I === J ? 0 : I < J ? -1 : 1;
        }
        return this.negative !== 0 ? -A | 0 : A;
      }, g.prototype.cmp = function(J) {
        if (this.negative !== 0 && J.negative === 0)
          return -1;
        if (this.negative === 0 && J.negative !== 0)
          return 1;
        var ne = this.ucmp(J);
        return this.negative !== 0 ? -ne | 0 : ne;
      }, g.prototype.ucmp = function(J) {
        if (this.length > J.length)
          return 1;
        if (this.length < J.length)
          return -1;
        for (var ne = 0, A = this.length - 1; A >= 0; A--) {
          var I = this.words[A] | 0, U = J.words[A] | 0;
          if (I !== U) {
            I < U ? ne = -1 : I > U && (ne = 1);
            break;
          }
        }
        return ne;
      }, g.prototype.gtn = function(J) {
        return this.cmpn(J) === 1;
      }, g.prototype.gt = function(J) {
        return this.cmp(J) === 1;
      }, g.prototype.gten = function(J) {
        return this.cmpn(J) >= 0;
      }, g.prototype.gte = function(J) {
        return this.cmp(J) >= 0;
      }, g.prototype.ltn = function(J) {
        return this.cmpn(J) === -1;
      }, g.prototype.lt = function(J) {
        return this.cmp(J) === -1;
      }, g.prototype.lten = function(J) {
        return this.cmpn(J) <= 0;
      }, g.prototype.lte = function(J) {
        return this.cmp(J) <= 0;
      }, g.prototype.eqn = function(J) {
        return this.cmpn(J) === 0;
      }, g.prototype.eq = function(J) {
        return this.cmp(J) === 0;
      }, g.red = function(J) {
        return new Ne(J);
      }, g.prototype.toRed = function(J) {
        return o(!this.red, "Already a number in reduction context"), o(this.negative === 0, "red works only with positives"), J.convertTo(this)._forceRed(J);
      }, g.prototype.fromRed = function() {
        return o(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, g.prototype._forceRed = function(J) {
        return this.red = J, this;
      }, g.prototype.forceRed = function(J) {
        return o(!this.red, "Already a number in reduction context"), this._forceRed(J);
      }, g.prototype.redAdd = function(J) {
        return o(this.red, "redAdd works only with red numbers"), this.red.add(this, J);
      }, g.prototype.redIAdd = function(J) {
        return o(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, J);
      }, g.prototype.redSub = function(J) {
        return o(this.red, "redSub works only with red numbers"), this.red.sub(this, J);
      }, g.prototype.redISub = function(J) {
        return o(this.red, "redISub works only with red numbers"), this.red.isub(this, J);
      }, g.prototype.redShl = function(J) {
        return o(this.red, "redShl works only with red numbers"), this.red.shl(this, J);
      }, g.prototype.redMul = function(J) {
        return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, J), this.red.mul(this, J);
      }, g.prototype.redIMul = function(J) {
        return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, J), this.red.imul(this, J);
      }, g.prototype.redSqr = function() {
        return o(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, g.prototype.redISqr = function() {
        return o(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, g.prototype.redSqrt = function() {
        return o(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, g.prototype.redInvm = function() {
        return o(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, g.prototype.redNeg = function() {
        return o(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, g.prototype.redPow = function(J) {
        return o(this.red && !J.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, J);
      };
      var be = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function ve(J, ne) {
        this.name = J, this.p = new g(ne, 16), this.n = this.p.bitLength(), this.k = new g(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      ve.prototype._tmp = function() {
        var J = new g(null);
        return J.words = new Array(Math.ceil(this.n / 13)), J;
      }, ve.prototype.ireduce = function(J) {
        var ne = J, A;
        do
          this.split(ne, this.tmp), ne = this.imulK(ne), ne = ne.iadd(this.tmp), A = ne.bitLength();
        while (A > this.n);
        var I = A < this.n ? -1 : ne.ucmp(this.p);
        return I === 0 ? (ne.words[0] = 0, ne.length = 1) : I > 0 ? ne.isub(this.p) : ne.strip !== void 0 ? ne.strip() : ne._strip(), ne;
      }, ve.prototype.split = function(J, ne) {
        J.iushrn(this.n, 0, ne);
      }, ve.prototype.imulK = function(J) {
        return J.imul(this.k);
      };
      function Pe() {
        ve.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      S(Pe, ve), Pe.prototype.split = function(J, ne) {
        for (var A = 4194303, I = Math.min(J.length, 9), U = 0; U < I; U++)
          ne.words[U] = J.words[U];
        if (ne.length = I, J.length <= 9) {
          J.words[0] = 0, J.length = 1;
          return;
        }
        var X = J.words[9];
        for (ne.words[ne.length++] = X & A, U = 10; U < J.length; U++) {
          var Q = J.words[U] | 0;
          J.words[U - 10] = (Q & A) << 4 | X >>> 22, X = Q;
        }
        X >>>= 22, J.words[U - 10] = X, X === 0 && J.length > 10 ? J.length -= 10 : J.length -= 9;
      }, Pe.prototype.imulK = function(J) {
        J.words[J.length] = 0, J.words[J.length + 1] = 0, J.length += 2;
        for (var ne = 0, A = 0; A < J.length; A++) {
          var I = J.words[A] | 0;
          ne += I * 977, J.words[A] = ne & 67108863, ne = I * 64 + (ne / 67108864 | 0);
        }
        return J.words[J.length - 1] === 0 && (J.length--, J.words[J.length - 1] === 0 && J.length--), J;
      };
      function Ue() {
        ve.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      S(Ue, ve);
      function ze() {
        ve.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      S(ze, ve);
      function Le() {
        ve.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      S(Le, ve), Le.prototype.imulK = function(J) {
        for (var ne = 0, A = 0; A < J.length; A++) {
          var I = (J.words[A] | 0) * 19 + ne, U = I & 67108863;
          I >>>= 26, J.words[A] = U, ne = I;
        }
        return ne !== 0 && (J.words[J.length++] = ne), J;
      }, g._prime = function(J) {
        if (be[J])
          return be[J];
        var ne;
        if (J === "k256")
          ne = new Pe();
        else if (J === "p224")
          ne = new Ue();
        else if (J === "p192")
          ne = new ze();
        else if (J === "p25519")
          ne = new Le();
        else
          throw new Error("Unknown prime " + J);
        return be[J] = ne, ne;
      };
      function Ne(J) {
        if (typeof J == "string") {
          var ne = g._prime(J);
          this.m = ne.p, this.prime = ne;
        } else
          o(J.gtn(1), "modulus must be greater than 1"), this.m = J, this.prime = null;
      }
      Ne.prototype._verify1 = function(J) {
        o(J.negative === 0, "red works only with positives"), o(J.red, "red works only with red numbers");
      }, Ne.prototype._verify2 = function(J, ne) {
        o((J.negative | ne.negative) === 0, "red works only with positives"), o(
          J.red && J.red === ne.red,
          "red works only with red numbers"
        );
      }, Ne.prototype.imod = function(J) {
        return this.prime ? this.prime.ireduce(J)._forceRed(this) : J.umod(this.m)._forceRed(this);
      }, Ne.prototype.neg = function(J) {
        return J.isZero() ? J.clone() : this.m.sub(J)._forceRed(this);
      }, Ne.prototype.add = function(J, ne) {
        this._verify2(J, ne);
        var A = J.add(ne);
        return A.cmp(this.m) >= 0 && A.isub(this.m), A._forceRed(this);
      }, Ne.prototype.iadd = function(J, ne) {
        this._verify2(J, ne);
        var A = J.iadd(ne);
        return A.cmp(this.m) >= 0 && A.isub(this.m), A;
      }, Ne.prototype.sub = function(J, ne) {
        this._verify2(J, ne);
        var A = J.sub(ne);
        return A.cmpn(0) < 0 && A.iadd(this.m), A._forceRed(this);
      }, Ne.prototype.isub = function(J, ne) {
        this._verify2(J, ne);
        var A = J.isub(ne);
        return A.cmpn(0) < 0 && A.iadd(this.m), A;
      }, Ne.prototype.shl = function(J, ne) {
        return this._verify1(J), this.imod(J.ushln(ne));
      }, Ne.prototype.imul = function(J, ne) {
        return this._verify2(J, ne), this.imod(J.imul(ne));
      }, Ne.prototype.mul = function(J, ne) {
        return this._verify2(J, ne), this.imod(J.mul(ne));
      }, Ne.prototype.isqr = function(J) {
        return this.imul(J, J.clone());
      }, Ne.prototype.sqr = function(J) {
        return this.mul(J, J);
      }, Ne.prototype.sqrt = function(J) {
        if (J.isZero())
          return J.clone();
        var ne = this.m.andln(3);
        if (o(ne % 2 === 1), ne === 3) {
          var A = this.m.add(new g(1)).iushrn(2);
          return this.pow(J, A);
        }
        for (var I = this.m.subn(1), U = 0; !I.isZero() && I.andln(1) === 0; )
          U++, I.iushrn(1);
        o(!I.isZero());
        var X = new g(1).toRed(this), Q = X.redNeg(), F = this.m.subn(1).iushrn(1), $ = this.m.bitLength();
        for ($ = new g(2 * $ * $).toRed(this); this.pow($, F).cmp(Q) !== 0; )
          $.redIAdd(Q);
        for (var H = this.pow($, I), q = this.pow(J, I.addn(1).iushrn(1)), z = this.pow(J, I), me = U; z.cmp(X) !== 0; ) {
          for (var Ce = z, je = 0; Ce.cmp(X) !== 0; je++)
            Ce = Ce.redSqr();
          o(je < me);
          var Re = this.pow(H, new g(1).iushln(me - je - 1));
          q = q.redMul(Re), H = Re.redSqr(), z = z.redMul(H), me = je;
        }
        return q;
      }, Ne.prototype.invm = function(J) {
        var ne = J._invmp(this.m);
        return ne.negative !== 0 ? (ne.negative = 0, this.imod(ne).redNeg()) : this.imod(ne);
      }, Ne.prototype.pow = function(J, ne) {
        if (ne.isZero())
          return new g(1).toRed(this);
        if (ne.cmpn(1) === 0)
          return J.clone();
        var A = 4, I = new Array(1 << A);
        I[0] = new g(1).toRed(this), I[1] = J;
        for (var U = 2; U < I.length; U++)
          I[U] = this.mul(I[U - 1], J);
        var X = I[0], Q = 0, F = 0, $ = ne.bitLength() % 26;
        for ($ === 0 && ($ = 26), U = ne.length - 1; U >= 0; U--) {
          for (var H = ne.words[U], q = $ - 1; q >= 0; q--) {
            var z = H >> q & 1;
            if (X !== I[0] && (X = this.sqr(X)), z === 0 && Q === 0) {
              F = 0;
              continue;
            }
            Q <<= 1, Q |= z, F++, !(F !== A && (U !== 0 || q !== 0)) && (X = this.mul(X, I[Q]), F = 0, Q = 0);
          }
          $ = 26;
        }
        return X;
      }, Ne.prototype.convertTo = function(J) {
        var ne = J.umod(this.m);
        return ne === J ? ne.clone() : ne;
      }, Ne.prototype.convertFrom = function(J) {
        var ne = J.clone();
        return ne.red = null, ne;
      }, g.mont = function(J) {
        return new $e(J);
      };
      function $e(J) {
        Ne.call(this, J), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new g(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      S($e, Ne), $e.prototype.convertTo = function(J) {
        return this.imod(J.ushln(this.shift));
      }, $e.prototype.convertFrom = function(J) {
        var ne = this.imod(J.mul(this.rinv));
        return ne.red = null, ne;
      }, $e.prototype.imul = function(J, ne) {
        if (J.isZero() || ne.isZero())
          return J.words[0] = 0, J.length = 1, J;
        var A = J.imul(ne), I = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), U = A.isub(I).iushrn(this.shift), X = U;
        return U.cmp(this.m) >= 0 ? X = U.isub(this.m) : U.cmpn(0) < 0 && (X = U.iadd(this.m)), X._forceRed(this);
      }, $e.prototype.mul = function(J, ne) {
        if (J.isZero() || ne.isZero())
          return new g(0)._forceRed(this);
        var A = J.mul(ne), I = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), U = A.isub(I).iushrn(this.shift), X = U;
        return U.cmp(this.m) >= 0 ? X = U.isub(this.m) : U.cmpn(0) < 0 && (X = U.iadd(this.m)), X._forceRed(this);
      }, $e.prototype.invm = function(J) {
        var ne = this.imod(J._invmp(this.m).mul(this.r2));
        return ne._forceRed(this);
      };
    })(e, commonjsGlobal);
  }(bn$2)), bn$2.exports;
}
var brorand = { exports: {} }, hasRequiredBrorand;
function requireBrorand() {
  if (hasRequiredBrorand)
    return brorand.exports;
  hasRequiredBrorand = 1;
  var e;
  brorand.exports = function(o) {
    return e || (e = new t(null)), e.generate(o);
  };
  function t(o) {
    this.rand = o;
  }
  if (brorand.exports.Rand = t, t.prototype.generate = function(o) {
    return this._rand(o);
  }, t.prototype._rand = function(o) {
    if (this.rand.getBytes)
      return this.rand.getBytes(o);
    for (var S = new Uint8Array(o), g = 0; g < S.length; g++)
      S[g] = this.rand.getByte();
    return S;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? t.prototype._rand = function(o) {
      var S = new Uint8Array(o);
      return self.crypto.getRandomValues(S), S;
    } : self.msCrypto && self.msCrypto.getRandomValues ? t.prototype._rand = function(o) {
      var S = new Uint8Array(o);
      return self.msCrypto.getRandomValues(S), S;
    } : typeof window == "object" && (t.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var h = requireCryptoBrowserify();
      if (typeof h.randomBytes != "function")
        throw new Error("Not supported");
      t.prototype._rand = function(o) {
        return h.randomBytes(o);
      };
    } catch {
    }
  return brorand.exports;
}
var mr$1, hasRequiredMr;
function requireMr() {
  if (hasRequiredMr)
    return mr$1;
  hasRequiredMr = 1;
  var e = requireBn$2(), t = requireBrorand();
  function h(o) {
    this.rand = o || new t.Rand();
  }
  return mr$1 = h, h.create = function(o) {
    return new h(o);
  }, h.prototype._randbelow = function(o) {
    var S = o.bitLength(), g = Math.ceil(S / 8);
    do
      var B = new e(this.rand.generate(g));
    while (B.cmp(o) >= 0);
    return B;
  }, h.prototype._randrange = function(o, S) {
    var g = S.sub(o);
    return o.add(this._randbelow(g));
  }, h.prototype.test = function(o, S, g) {
    var B = o.bitLength(), M = e.mont(o), O = new e(1).toRed(M);
    S || (S = Math.max(1, B / 48 | 0));
    for (var P = o.subn(1), D = 0; !P.testn(D); D++)
      ;
    for (var Z = o.shrn(D), Y = P.toRed(M), ee = !0; S > 0; S--) {
      var ie = this._randrange(new e(2), P);
      g && g(ie);
      var ue = ie.toRed(M).redPow(Z);
      if (!(ue.cmp(O) === 0 || ue.cmp(Y) === 0)) {
        for (var fe = 1; fe < D; fe++) {
          if (ue = ue.redSqr(), ue.cmp(O) === 0)
            return !1;
          if (ue.cmp(Y) === 0)
            break;
        }
        if (fe === D)
          return !1;
      }
    }
    return ee;
  }, h.prototype.getDivisor = function(o, S) {
    var g = o.bitLength(), B = e.mont(o), M = new e(1).toRed(B);
    S || (S = Math.max(1, g / 48 | 0));
    for (var O = o.subn(1), P = 0; !O.testn(P); P++)
      ;
    for (var D = o.shrn(P), Z = O.toRed(B); S > 0; S--) {
      var Y = this._randrange(new e(2), O), ee = o.gcd(Y);
      if (ee.cmpn(1) !== 0)
        return ee;
      var ie = Y.toRed(B).redPow(D);
      if (!(ie.cmp(M) === 0 || ie.cmp(Z) === 0)) {
        for (var ue = 1; ue < P; ue++) {
          if (ie = ie.redSqr(), ie.cmp(M) === 0)
            return ie.fromRed().subn(1).gcd(o);
          if (ie.cmp(Z) === 0)
            break;
        }
        if (ue === P)
          return ie = ie.redSqr(), ie.fromRed().subn(1).gcd(o);
      }
    }
    return !1;
  }, mr$1;
}
var generatePrime, hasRequiredGeneratePrime;
function requireGeneratePrime() {
  if (hasRequiredGeneratePrime)
    return generatePrime;
  hasRequiredGeneratePrime = 1;
  var e = requireBrowser$b();
  generatePrime = fe, fe.simpleSieve = ie, fe.fermatTest = ue;
  var t = requireBn$2(), h = new t(24), o = requireMr(), S = new o(), g = new t(1), B = new t(2), M = new t(5);
  new t(16), new t(8);
  var O = new t(10), P = new t(3);
  new t(7);
  var D = new t(11), Z = new t(4);
  new t(12);
  var Y = null;
  function ee() {
    if (Y !== null)
      return Y;
    var de = 1048576, ce = [];
    ce[0] = 2;
    for (var be = 1, ve = 3; ve < de; ve += 2) {
      for (var Pe = Math.ceil(Math.sqrt(ve)), Ue = 0; Ue < be && ce[Ue] <= Pe && ve % ce[Ue] !== 0; Ue++)
        ;
      be !== Ue && ce[Ue] <= Pe || (ce[be++] = ve);
    }
    return Y = ce, ce;
  }
  function ie(de) {
    for (var ce = ee(), be = 0; be < ce.length; be++)
      if (de.modn(ce[be]) === 0)
        return de.cmpn(ce[be]) === 0;
    return !0;
  }
  function ue(de) {
    var ce = t.mont(de);
    return B.toRed(ce).redPow(de.subn(1)).fromRed().cmpn(1) === 0;
  }
  function fe(de, ce) {
    if (de < 16)
      return ce === 2 || ce === 5 ? new t([140, 123]) : new t([140, 39]);
    ce = new t(ce);
    for (var be, ve; ; ) {
      for (be = new t(e(Math.ceil(de / 8))); be.bitLength() > de; )
        be.ishrn(1);
      if (be.isEven() && be.iadd(g), be.testn(1) || be.iadd(B), ce.cmp(B)) {
        if (!ce.cmp(M))
          for (; be.mod(O).cmp(P); )
            be.iadd(Z);
      } else
        for (; be.mod(h).cmp(D); )
          be.iadd(Z);
      if (ve = be.shrn(1), ie(ve) && ie(be) && ue(ve) && ue(be) && S.test(ve) && S.test(be))
        return be;
    }
  }
  return generatePrime;
}
const modp1 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, modp2 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, modp5 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, modp14 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, modp15 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, modp16 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, modp17 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, modp18 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, require$$1$1 = {
  modp1,
  modp2,
  modp5,
  modp14,
  modp15,
  modp16,
  modp17,
  modp18
};
var dh$1, hasRequiredDh;
function requireDh() {
  if (hasRequiredDh)
    return dh$1;
  hasRequiredDh = 1;
  var e = requireBn$2(), t = requireMr(), h = new t(), o = new e(24), S = new e(11), g = new e(10), B = new e(3), M = new e(7), O = requireGeneratePrime(), P = requireBrowser$b();
  dh$1 = ie;
  function D(fe, de) {
    return de = de || "utf8", bufferExports.Buffer.isBuffer(fe) || (fe = new bufferExports.Buffer(fe, de)), this._pub = new e(fe), this;
  }
  function Z(fe, de) {
    return de = de || "utf8", bufferExports.Buffer.isBuffer(fe) || (fe = new bufferExports.Buffer(fe, de)), this._priv = new e(fe), this;
  }
  var Y = {};
  function ee(fe, de) {
    var ce = de.toString("hex"), be = [ce, fe.toString(16)].join("_");
    if (be in Y)
      return Y[be];
    var ve = 0;
    if (fe.isEven() || !O.simpleSieve || !O.fermatTest(fe) || !h.test(fe))
      return ve += 1, ce === "02" || ce === "05" ? ve += 8 : ve += 4, Y[be] = ve, ve;
    h.test(fe.shrn(1)) || (ve += 2);
    var Pe;
    switch (ce) {
      case "02":
        fe.mod(o).cmp(S) && (ve += 8);
        break;
      case "05":
        Pe = fe.mod(g), Pe.cmp(B) && Pe.cmp(M) && (ve += 8);
        break;
      default:
        ve += 4;
    }
    return Y[be] = ve, ve;
  }
  function ie(fe, de, ce) {
    this.setGenerator(de), this.__prime = new e(fe), this._prime = e.mont(this.__prime), this._primeLen = fe.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, ce ? (this.setPublicKey = D, this.setPrivateKey = Z) : this._primeCode = 8;
  }
  Object.defineProperty(ie.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = ee(this.__prime, this.__gen)), this._primeCode;
    }
  }), ie.prototype.generateKeys = function() {
    return this._priv || (this._priv = new e(P(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, ie.prototype.computeSecret = function(fe) {
    fe = new e(fe), fe = fe.toRed(this._prime);
    var de = fe.redPow(this._priv).fromRed(), ce = new bufferExports.Buffer(de.toArray()), be = this.getPrime();
    if (ce.length < be.length) {
      var ve = new bufferExports.Buffer(be.length - ce.length);
      ve.fill(0), ce = bufferExports.Buffer.concat([ve, ce]);
    }
    return ce;
  }, ie.prototype.getPublicKey = function(fe) {
    return ue(this._pub, fe);
  }, ie.prototype.getPrivateKey = function(fe) {
    return ue(this._priv, fe);
  }, ie.prototype.getPrime = function(fe) {
    return ue(this.__prime, fe);
  }, ie.prototype.getGenerator = function(fe) {
    return ue(this._gen, fe);
  }, ie.prototype.setGenerator = function(fe, de) {
    return de = de || "utf8", bufferExports.Buffer.isBuffer(fe) || (fe = new bufferExports.Buffer(fe, de)), this.__gen = fe, this._gen = new e(fe), this;
  };
  function ue(fe, de) {
    var ce = new bufferExports.Buffer(fe.toArray());
    return de ? ce.toString(de) : ce;
  }
  return dh$1;
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4)
    return browser$4;
  hasRequiredBrowser$4 = 1;
  var e = requireGeneratePrime(), t = require$$1$1, h = requireDh();
  function o(B) {
    var M = new bufferExports.Buffer(t[B].prime, "hex"), O = new bufferExports.Buffer(t[B].gen, "hex");
    return new h(M, O);
  }
  var S = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function g(B, M, O, P) {
    return bufferExports.Buffer.isBuffer(M) || S[M] === void 0 ? g(B, "binary", M, O) : (M = M || "binary", P = P || "binary", O = O || new bufferExports.Buffer([2]), bufferExports.Buffer.isBuffer(O) || (O = new bufferExports.Buffer(O, P)), typeof B == "number" ? new h(e(B, O), O, !0) : (bufferExports.Buffer.isBuffer(B) || (B = new bufferExports.Buffer(B, M)), new h(B, O, !0)));
  }
  return browser$4.DiffieHellmanGroup = browser$4.createDiffieHellmanGroup = browser$4.getDiffieHellman = o, browser$4.createDiffieHellman = browser$4.DiffieHellman = g, browser$4;
}
var readableBrowser = { exports: {} }, processNextickArgs = { exports: {} }, hasRequiredProcessNextickArgs;
function requireProcessNextickArgs() {
  if (hasRequiredProcessNextickArgs)
    return processNextickArgs.exports;
  hasRequiredProcessNextickArgs = 1, typeof process$1 > "u" || !process$1.version || process$1.version.indexOf("v0.") === 0 || process$1.version.indexOf("v1.") === 0 && process$1.version.indexOf("v1.8.") !== 0 ? processNextickArgs.exports = { nextTick: e } : processNextickArgs.exports = process$1;
  function e(t, h, o, S) {
    if (typeof t != "function")
      throw new TypeError('"callback" argument must be a function');
    var g = arguments.length, B, M;
    switch (g) {
      case 0:
      case 1:
        return process$1.nextTick(t);
      case 2:
        return process$1.nextTick(function() {
          t.call(null, h);
        });
      case 3:
        return process$1.nextTick(function() {
          t.call(null, h, o);
        });
      case 4:
        return process$1.nextTick(function() {
          t.call(null, h, o, S);
        });
      default:
        for (B = new Array(g - 1), M = 0; M < B.length; )
          B[M++] = arguments[M];
        return process$1.nextTick(function() {
          t.apply(null, B);
        });
    }
  }
  return processNextickArgs.exports;
}
var isarray, hasRequiredIsarray;
function requireIsarray() {
  if (hasRequiredIsarray)
    return isarray;
  hasRequiredIsarray = 1;
  var e = {}.toString;
  return isarray = Array.isArray || function(t) {
    return e.call(t) == "[object Array]";
  }, isarray;
}
var streamBrowser, hasRequiredStreamBrowser;
function requireStreamBrowser() {
  return hasRequiredStreamBrowser || (hasRequiredStreamBrowser = 1, streamBrowser = requireEvents().EventEmitter), streamBrowser;
}
var safeBuffer = { exports: {} }, hasRequiredSafeBuffer;
function requireSafeBuffer() {
  return hasRequiredSafeBuffer || (hasRequiredSafeBuffer = 1, function(e, t) {
    var h = requireBuffer$1(), o = h.Buffer;
    function S(B, M) {
      for (var O in B)
        M[O] = B[O];
    }
    o.from && o.alloc && o.allocUnsafe && o.allocUnsafeSlow ? e.exports = h : (S(h, t), t.Buffer = g);
    function g(B, M, O) {
      return o(B, M, O);
    }
    S(o, g), g.from = function(B, M, O) {
      if (typeof B == "number")
        throw new TypeError("Argument must not be a number");
      return o(B, M, O);
    }, g.alloc = function(B, M, O) {
      if (typeof B != "number")
        throw new TypeError("Argument must be a number");
      var P = o(B);
      return M !== void 0 ? typeof O == "string" ? P.fill(M, O) : P.fill(M) : P.fill(0), P;
    }, g.allocUnsafe = function(B) {
      if (typeof B != "number")
        throw new TypeError("Argument must be a number");
      return o(B);
    }, g.allocUnsafeSlow = function(B) {
      if (typeof B != "number")
        throw new TypeError("Argument must be a number");
      return h.SlowBuffer(B);
    };
  }(safeBuffer, safeBuffer.exports)), safeBuffer.exports;
}
var util = {}, hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil)
    return util;
  hasRequiredUtil = 1;
  function e(ue) {
    return Array.isArray ? Array.isArray(ue) : ie(ue) === "[object Array]";
  }
  util.isArray = e;
  function t(ue) {
    return typeof ue == "boolean";
  }
  util.isBoolean = t;
  function h(ue) {
    return ue === null;
  }
  util.isNull = h;
  function o(ue) {
    return ue == null;
  }
  util.isNullOrUndefined = o;
  function S(ue) {
    return typeof ue == "number";
  }
  util.isNumber = S;
  function g(ue) {
    return typeof ue == "string";
  }
  util.isString = g;
  function B(ue) {
    return typeof ue == "symbol";
  }
  util.isSymbol = B;
  function M(ue) {
    return ue === void 0;
  }
  util.isUndefined = M;
  function O(ue) {
    return ie(ue) === "[object RegExp]";
  }
  util.isRegExp = O;
  function P(ue) {
    return typeof ue == "object" && ue !== null;
  }
  util.isObject = P;
  function D(ue) {
    return ie(ue) === "[object Date]";
  }
  util.isDate = D;
  function Z(ue) {
    return ie(ue) === "[object Error]" || ue instanceof Error;
  }
  util.isError = Z;
  function Y(ue) {
    return typeof ue == "function";
  }
  util.isFunction = Y;
  function ee(ue) {
    return ue === null || typeof ue == "boolean" || typeof ue == "number" || typeof ue == "string" || typeof ue == "symbol" || // ES6 symbol
    typeof ue > "u";
  }
  util.isPrimitive = ee, util.isBuffer = requireBuffer$1().Buffer.isBuffer;
  function ie(ue) {
    return Object.prototype.toString.call(ue);
  }
  return util;
}
var BufferList = { exports: {} }, hasRequiredBufferList;
function requireBufferList() {
  return hasRequiredBufferList || (hasRequiredBufferList = 1, function(e) {
    function t(g, B) {
      if (!(g instanceof B))
        throw new TypeError("Cannot call a class as a function");
    }
    var h = requireSafeBuffer().Buffer, o = requireUtil$1();
    function S(g, B, M) {
      g.copy(B, M);
    }
    e.exports = function() {
      function g() {
        t(this, g), this.head = null, this.tail = null, this.length = 0;
      }
      return g.prototype.push = function(B) {
        var M = { data: B, next: null };
        this.length > 0 ? this.tail.next = M : this.head = M, this.tail = M, ++this.length;
      }, g.prototype.unshift = function(B) {
        var M = { data: B, next: this.head };
        this.length === 0 && (this.tail = M), this.head = M, ++this.length;
      }, g.prototype.shift = function() {
        if (this.length !== 0) {
          var B = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, B;
        }
      }, g.prototype.clear = function() {
        this.head = this.tail = null, this.length = 0;
      }, g.prototype.join = function(B) {
        if (this.length === 0)
          return "";
        for (var M = this.head, O = "" + M.data; M = M.next; )
          O += B + M.data;
        return O;
      }, g.prototype.concat = function(B) {
        if (this.length === 0)
          return h.alloc(0);
        for (var M = h.allocUnsafe(B >>> 0), O = this.head, P = 0; O; )
          S(O.data, M, P), P += O.data.length, O = O.next;
        return M;
      }, g;
    }(), o && o.inspect && o.inspect.custom && (e.exports.prototype[o.inspect.custom] = function() {
      var g = o.inspect({ length: this.length });
      return this.constructor.name + " " + g;
    });
  }(BufferList)), BufferList.exports;
}
var destroy_1, hasRequiredDestroy;
function requireDestroy() {
  if (hasRequiredDestroy)
    return destroy_1;
  hasRequiredDestroy = 1;
  var e = requireProcessNextickArgs();
  function t(S, g) {
    var B = this, M = this._readableState && this._readableState.destroyed, O = this._writableState && this._writableState.destroyed;
    return M || O ? (g ? g(S) : S && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, e.nextTick(o, this, S)) : e.nextTick(o, this, S)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(S || null, function(P) {
      !g && P ? B._writableState ? B._writableState.errorEmitted || (B._writableState.errorEmitted = !0, e.nextTick(o, B, P)) : e.nextTick(o, B, P) : g && g(P);
    }), this);
  }
  function h() {
    this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
  }
  function o(S, g) {
    S.emit("error", g);
  }
  return destroy_1 = {
    destroy: t,
    undestroy: h
  }, destroy_1;
}
var _stream_writable, hasRequired_stream_writable;
function require_stream_writable() {
  if (hasRequired_stream_writable)
    return _stream_writable;
  hasRequired_stream_writable = 1;
  var e = requireProcessNextickArgs();
  _stream_writable = ue;
  function t(Q) {
    var F = this;
    this.next = null, this.entry = null, this.finish = function() {
      X(F, Q);
    };
  }
  var h = !process$1.browser && ["v0.10", "v0.9."].indexOf(process$1.version.slice(0, 5)) > -1 ? setImmediate : e.nextTick, o;
  ue.WritableState = ee;
  var S = Object.create(requireUtil());
  S.inherits = requireInherits_browser();
  var g = {
    deprecate: requireBrowser$a()
  }, B = requireStreamBrowser(), M = requireSafeBuffer().Buffer, O = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function P(Q) {
    return M.from(Q);
  }
  function D(Q) {
    return M.isBuffer(Q) || Q instanceof O;
  }
  var Z = requireDestroy();
  S.inherits(ue, B);
  function Y() {
  }
  function ee(Q, F) {
    o = o || require_stream_duplex(), Q = Q || {};
    var $ = F instanceof o;
    this.objectMode = !!Q.objectMode, $ && (this.objectMode = this.objectMode || !!Q.writableObjectMode);
    var H = Q.highWaterMark, q = Q.writableHighWaterMark, z = this.objectMode ? 16 : 16 * 1024;
    H || H === 0 ? this.highWaterMark = H : $ && (q || q === 0) ? this.highWaterMark = q : this.highWaterMark = z, this.highWaterMark = Math.floor(this.highWaterMark), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var me = Q.decodeStrings === !1;
    this.decodeStrings = !me, this.defaultEncoding = Q.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Ce) {
      ze(F, Ce);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.bufferedRequestCount = 0, this.corkedRequestsFree = new t(this);
  }
  ee.prototype.getBuffer = function() {
    for (var Q = this.bufferedRequest, F = []; Q; )
      F.push(Q), Q = Q.next;
    return F;
  }, function() {
    try {
      Object.defineProperty(ee.prototype, "buffer", {
        get: g.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var ie;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ie = Function.prototype[Symbol.hasInstance], Object.defineProperty(ue, Symbol.hasInstance, {
    value: function(Q) {
      return ie.call(this, Q) ? !0 : this !== ue ? !1 : Q && Q._writableState instanceof ee;
    }
  })) : ie = function(Q) {
    return Q instanceof this;
  };
  function ue(Q) {
    if (o = o || require_stream_duplex(), !ie.call(ue, this) && !(this instanceof o))
      return new ue(Q);
    this._writableState = new ee(Q, this), this.writable = !0, Q && (typeof Q.write == "function" && (this._write = Q.write), typeof Q.writev == "function" && (this._writev = Q.writev), typeof Q.destroy == "function" && (this._destroy = Q.destroy), typeof Q.final == "function" && (this._final = Q.final)), B.call(this);
  }
  ue.prototype.pipe = function() {
    this.emit("error", new Error("Cannot pipe, not readable"));
  };
  function fe(Q, F) {
    var $ = new Error("write after end");
    Q.emit("error", $), e.nextTick(F, $);
  }
  function de(Q, F, $, H) {
    var q = !0, z = !1;
    return $ === null ? z = new TypeError("May not write null values to stream") : typeof $ != "string" && $ !== void 0 && !F.objectMode && (z = new TypeError("Invalid non-string/buffer chunk")), z && (Q.emit("error", z), e.nextTick(H, z), q = !1), q;
  }
  ue.prototype.write = function(Q, F, $) {
    var H = this._writableState, q = !1, z = !H.objectMode && D(Q);
    return z && !M.isBuffer(Q) && (Q = P(Q)), typeof F == "function" && ($ = F, F = null), z ? F = "buffer" : F || (F = H.defaultEncoding), typeof $ != "function" && ($ = Y), H.ended ? fe(this, $) : (z || de(this, H, Q, $)) && (H.pendingcb++, q = be(this, H, z, Q, F, $)), q;
  }, ue.prototype.cork = function() {
    var Q = this._writableState;
    Q.corked++;
  }, ue.prototype.uncork = function() {
    var Q = this._writableState;
    Q.corked && (Q.corked--, !Q.writing && !Q.corked && !Q.bufferProcessing && Q.bufferedRequest && $e(this, Q));
  }, ue.prototype.setDefaultEncoding = function(Q) {
    if (typeof Q == "string" && (Q = Q.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Q + "").toLowerCase()) > -1))
      throw new TypeError("Unknown encoding: " + Q);
    return this._writableState.defaultEncoding = Q, this;
  };
  function ce(Q, F, $) {
    return !Q.objectMode && Q.decodeStrings !== !1 && typeof F == "string" && (F = M.from(F, $)), F;
  }
  Object.defineProperty(ue.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function be(Q, F, $, H, q, z) {
    if (!$) {
      var me = ce(F, H, q);
      H !== me && ($ = !0, q = "buffer", H = me);
    }
    var Ce = F.objectMode ? 1 : H.length;
    F.length += Ce;
    var je = F.length < F.highWaterMark;
    if (je || (F.needDrain = !0), F.writing || F.corked) {
      var Re = F.lastBufferedRequest;
      F.lastBufferedRequest = {
        chunk: H,
        encoding: q,
        isBuf: $,
        callback: z,
        next: null
      }, Re ? Re.next = F.lastBufferedRequest : F.bufferedRequest = F.lastBufferedRequest, F.bufferedRequestCount += 1;
    } else
      ve(Q, F, !1, Ce, H, q, z);
    return je;
  }
  function ve(Q, F, $, H, q, z, me) {
    F.writelen = H, F.writecb = me, F.writing = !0, F.sync = !0, $ ? Q._writev(q, F.onwrite) : Q._write(q, z, F.onwrite), F.sync = !1;
  }
  function Pe(Q, F, $, H, q) {
    --F.pendingcb, $ ? (e.nextTick(q, H), e.nextTick(I, Q, F), Q._writableState.errorEmitted = !0, Q.emit("error", H)) : (q(H), Q._writableState.errorEmitted = !0, Q.emit("error", H), I(Q, F));
  }
  function Ue(Q) {
    Q.writing = !1, Q.writecb = null, Q.length -= Q.writelen, Q.writelen = 0;
  }
  function ze(Q, F) {
    var $ = Q._writableState, H = $.sync, q = $.writecb;
    if (Ue($), F)
      Pe(Q, $, H, F, q);
    else {
      var z = J($);
      !z && !$.corked && !$.bufferProcessing && $.bufferedRequest && $e(Q, $), H ? h(Le, Q, $, z, q) : Le(Q, $, z, q);
    }
  }
  function Le(Q, F, $, H) {
    $ || Ne(Q, F), F.pendingcb--, H(), I(Q, F);
  }
  function Ne(Q, F) {
    F.length === 0 && F.needDrain && (F.needDrain = !1, Q.emit("drain"));
  }
  function $e(Q, F) {
    F.bufferProcessing = !0;
    var $ = F.bufferedRequest;
    if (Q._writev && $ && $.next) {
      var H = F.bufferedRequestCount, q = new Array(H), z = F.corkedRequestsFree;
      z.entry = $;
      for (var me = 0, Ce = !0; $; )
        q[me] = $, $.isBuf || (Ce = !1), $ = $.next, me += 1;
      q.allBuffers = Ce, ve(Q, F, !0, F.length, q, "", z.finish), F.pendingcb++, F.lastBufferedRequest = null, z.next ? (F.corkedRequestsFree = z.next, z.next = null) : F.corkedRequestsFree = new t(F), F.bufferedRequestCount = 0;
    } else {
      for (; $; ) {
        var je = $.chunk, Re = $.encoding, Ae = $.callback, ke = F.objectMode ? 1 : je.length;
        if (ve(Q, F, !1, ke, je, Re, Ae), $ = $.next, F.bufferedRequestCount--, F.writing)
          break;
      }
      $ === null && (F.lastBufferedRequest = null);
    }
    F.bufferedRequest = $, F.bufferProcessing = !1;
  }
  ue.prototype._write = function(Q, F, $) {
    $(new Error("_write() is not implemented"));
  }, ue.prototype._writev = null, ue.prototype.end = function(Q, F, $) {
    var H = this._writableState;
    typeof Q == "function" ? ($ = Q, Q = null, F = null) : typeof F == "function" && ($ = F, F = null), Q != null && this.write(Q, F), H.corked && (H.corked = 1, this.uncork()), H.ending || U(this, H, $);
  };
  function J(Q) {
    return Q.ending && Q.length === 0 && Q.bufferedRequest === null && !Q.finished && !Q.writing;
  }
  function ne(Q, F) {
    Q._final(function($) {
      F.pendingcb--, $ && Q.emit("error", $), F.prefinished = !0, Q.emit("prefinish"), I(Q, F);
    });
  }
  function A(Q, F) {
    !F.prefinished && !F.finalCalled && (typeof Q._final == "function" ? (F.pendingcb++, F.finalCalled = !0, e.nextTick(ne, Q, F)) : (F.prefinished = !0, Q.emit("prefinish")));
  }
  function I(Q, F) {
    var $ = J(F);
    return $ && (A(Q, F), F.pendingcb === 0 && (F.finished = !0, Q.emit("finish"))), $;
  }
  function U(Q, F, $) {
    F.ending = !0, I(Q, F), $ && (F.finished ? e.nextTick($) : Q.once("finish", $)), F.ended = !0, Q.writable = !1;
  }
  function X(Q, F, $) {
    var H = Q.entry;
    for (Q.entry = null; H; ) {
      var q = H.callback;
      F.pendingcb--, q($), H = H.next;
    }
    F.corkedRequestsFree.next = Q;
  }
  return Object.defineProperty(ue.prototype, "destroyed", {
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Q) {
      this._writableState && (this._writableState.destroyed = Q);
    }
  }), ue.prototype.destroy = Z.destroy, ue.prototype._undestroy = Z.undestroy, ue.prototype._destroy = function(Q, F) {
    this.end(), F(Q);
  }, _stream_writable;
}
var _stream_duplex, hasRequired_stream_duplex;
function require_stream_duplex() {
  if (hasRequired_stream_duplex)
    return _stream_duplex;
  hasRequired_stream_duplex = 1;
  var e = requireProcessNextickArgs(), t = Object.keys || function(Z) {
    var Y = [];
    for (var ee in Z)
      Y.push(ee);
    return Y;
  };
  _stream_duplex = O;
  var h = Object.create(requireUtil());
  h.inherits = requireInherits_browser();
  var o = require_stream_readable(), S = require_stream_writable();
  h.inherits(O, o);
  for (var g = t(S.prototype), B = 0; B < g.length; B++) {
    var M = g[B];
    O.prototype[M] || (O.prototype[M] = S.prototype[M]);
  }
  function O(Z) {
    if (!(this instanceof O))
      return new O(Z);
    o.call(this, Z), S.call(this, Z), Z && Z.readable === !1 && (this.readable = !1), Z && Z.writable === !1 && (this.writable = !1), this.allowHalfOpen = !0, Z && Z.allowHalfOpen === !1 && (this.allowHalfOpen = !1), this.once("end", P);
  }
  Object.defineProperty(O.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function P() {
    this.allowHalfOpen || this._writableState.ended || e.nextTick(D, this);
  }
  function D(Z) {
    Z.end();
  }
  return Object.defineProperty(O.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(Z) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = Z, this._writableState.destroyed = Z);
    }
  }), O.prototype._destroy = function(Z, Y) {
    this.push(null), this.end(), e.nextTick(Y, Z);
  }, _stream_duplex;
}
var _stream_readable, hasRequired_stream_readable;
function require_stream_readable() {
  if (hasRequired_stream_readable)
    return _stream_readable;
  hasRequired_stream_readable = 1;
  var e = requireProcessNextickArgs();
  _stream_readable = ce;
  var t = requireIsarray(), h;
  ce.ReadableState = de, requireEvents().EventEmitter;
  var o = function(Ae, ke) {
    return Ae.listeners(ke).length;
  }, S = requireStreamBrowser(), g = requireSafeBuffer().Buffer, B = (typeof commonjsGlobal < "u" ? commonjsGlobal : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function M(Ae) {
    return g.from(Ae);
  }
  function O(Ae) {
    return g.isBuffer(Ae) || Ae instanceof B;
  }
  var P = Object.create(requireUtil());
  P.inherits = requireInherits_browser();
  var D = requireUtil$1(), Z = void 0;
  D && D.debuglog ? Z = D.debuglog("stream") : Z = function() {
  };
  var Y = requireBufferList(), ee = requireDestroy(), ie;
  P.inherits(ce, S);
  var ue = ["error", "close", "destroy", "pause", "resume"];
  function fe(Ae, ke, Qe) {
    if (typeof Ae.prependListener == "function")
      return Ae.prependListener(ke, Qe);
    !Ae._events || !Ae._events[ke] ? Ae.on(ke, Qe) : t(Ae._events[ke]) ? Ae._events[ke].unshift(Qe) : Ae._events[ke] = [Qe, Ae._events[ke]];
  }
  function de(Ae, ke) {
    h = h || require_stream_duplex(), Ae = Ae || {};
    var Qe = ke instanceof h;
    this.objectMode = !!Ae.objectMode, Qe && (this.objectMode = this.objectMode || !!Ae.readableObjectMode);
    var Ze = Ae.highWaterMark, qe = Ae.readableHighWaterMark, Oe = this.objectMode ? 16 : 16 * 1024;
    Ze || Ze === 0 ? this.highWaterMark = Ze : Qe && (qe || qe === 0) ? this.highWaterMark = qe : this.highWaterMark = Oe, this.highWaterMark = Math.floor(this.highWaterMark), this.buffer = new Y(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.destroyed = !1, this.defaultEncoding = Ae.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, Ae.encoding && (ie || (ie = requireString_decoder().StringDecoder), this.decoder = new ie(Ae.encoding), this.encoding = Ae.encoding);
  }
  function ce(Ae) {
    if (h = h || require_stream_duplex(), !(this instanceof ce))
      return new ce(Ae);
    this._readableState = new de(Ae, this), this.readable = !0, Ae && (typeof Ae.read == "function" && (this._read = Ae.read), typeof Ae.destroy == "function" && (this._destroy = Ae.destroy)), S.call(this);
  }
  Object.defineProperty(ce.prototype, "destroyed", {
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(Ae) {
      this._readableState && (this._readableState.destroyed = Ae);
    }
  }), ce.prototype.destroy = ee.destroy, ce.prototype._undestroy = ee.undestroy, ce.prototype._destroy = function(Ae, ke) {
    this.push(null), ke(Ae);
  }, ce.prototype.push = function(Ae, ke) {
    var Qe = this._readableState, Ze;
    return Qe.objectMode ? Ze = !0 : typeof Ae == "string" && (ke = ke || Qe.defaultEncoding, ke !== Qe.encoding && (Ae = g.from(Ae, ke), ke = ""), Ze = !0), be(this, Ae, ke, !1, Ze);
  }, ce.prototype.unshift = function(Ae) {
    return be(this, Ae, null, !0, !1);
  };
  function be(Ae, ke, Qe, Ze, qe) {
    var Oe = Ae._readableState;
    if (ke === null)
      Oe.reading = !1, $e(Ae, Oe);
    else {
      var Xe;
      qe || (Xe = Pe(Oe, ke)), Xe ? Ae.emit("error", Xe) : Oe.objectMode || ke && ke.length > 0 ? (typeof ke != "string" && !Oe.objectMode && Object.getPrototypeOf(ke) !== g.prototype && (ke = M(ke)), Ze ? Oe.endEmitted ? Ae.emit("error", new Error("stream.unshift() after end event")) : ve(Ae, Oe, ke, !0) : Oe.ended ? Ae.emit("error", new Error("stream.push() after EOF")) : (Oe.reading = !1, Oe.decoder && !Qe ? (ke = Oe.decoder.write(ke), Oe.objectMode || ke.length !== 0 ? ve(Ae, Oe, ke, !1) : A(Ae, Oe)) : ve(Ae, Oe, ke, !1))) : Ze || (Oe.reading = !1);
    }
    return Ue(Oe);
  }
  function ve(Ae, ke, Qe, Ze) {
    ke.flowing && ke.length === 0 && !ke.sync ? (Ae.emit("data", Qe), Ae.read(0)) : (ke.length += ke.objectMode ? 1 : Qe.length, Ze ? ke.buffer.unshift(Qe) : ke.buffer.push(Qe), ke.needReadable && J(Ae)), A(Ae, ke);
  }
  function Pe(Ae, ke) {
    var Qe;
    return !O(ke) && typeof ke != "string" && ke !== void 0 && !Ae.objectMode && (Qe = new TypeError("Invalid non-string/buffer chunk")), Qe;
  }
  function Ue(Ae) {
    return !Ae.ended && (Ae.needReadable || Ae.length < Ae.highWaterMark || Ae.length === 0);
  }
  ce.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, ce.prototype.setEncoding = function(Ae) {
    return ie || (ie = requireString_decoder().StringDecoder), this._readableState.decoder = new ie(Ae), this._readableState.encoding = Ae, this;
  };
  var ze = 8388608;
  function Le(Ae) {
    return Ae >= ze ? Ae = ze : (Ae--, Ae |= Ae >>> 1, Ae |= Ae >>> 2, Ae |= Ae >>> 4, Ae |= Ae >>> 8, Ae |= Ae >>> 16, Ae++), Ae;
  }
  function Ne(Ae, ke) {
    return Ae <= 0 || ke.length === 0 && ke.ended ? 0 : ke.objectMode ? 1 : Ae !== Ae ? ke.flowing && ke.length ? ke.buffer.head.data.length : ke.length : (Ae > ke.highWaterMark && (ke.highWaterMark = Le(Ae)), Ae <= ke.length ? Ae : ke.ended ? ke.length : (ke.needReadable = !0, 0));
  }
  ce.prototype.read = function(Ae) {
    Z("read", Ae), Ae = parseInt(Ae, 10);
    var ke = this._readableState, Qe = Ae;
    if (Ae !== 0 && (ke.emittedReadable = !1), Ae === 0 && ke.needReadable && (ke.length >= ke.highWaterMark || ke.ended))
      return Z("read: emitReadable", ke.length, ke.ended), ke.length === 0 && ke.ended ? Ce(this) : J(this), null;
    if (Ae = Ne(Ae, ke), Ae === 0 && ke.ended)
      return ke.length === 0 && Ce(this), null;
    var Ze = ke.needReadable;
    Z("need readable", Ze), (ke.length === 0 || ke.length - Ae < ke.highWaterMark) && (Ze = !0, Z("length less than watermark", Ze)), ke.ended || ke.reading ? (Ze = !1, Z("reading or ended", Ze)) : Ze && (Z("do read"), ke.reading = !0, ke.sync = !0, ke.length === 0 && (ke.needReadable = !0), this._read(ke.highWaterMark), ke.sync = !1, ke.reading || (Ae = Ne(Qe, ke)));
    var qe;
    return Ae > 0 ? qe = H(Ae, ke) : qe = null, qe === null ? (ke.needReadable = !0, Ae = 0) : ke.length -= Ae, ke.length === 0 && (ke.ended || (ke.needReadable = !0), Qe !== Ae && ke.ended && Ce(this)), qe !== null && this.emit("data", qe), qe;
  };
  function $e(Ae, ke) {
    if (!ke.ended) {
      if (ke.decoder) {
        var Qe = ke.decoder.end();
        Qe && Qe.length && (ke.buffer.push(Qe), ke.length += ke.objectMode ? 1 : Qe.length);
      }
      ke.ended = !0, J(Ae);
    }
  }
  function J(Ae) {
    var ke = Ae._readableState;
    ke.needReadable = !1, ke.emittedReadable || (Z("emitReadable", ke.flowing), ke.emittedReadable = !0, ke.sync ? e.nextTick(ne, Ae) : ne(Ae));
  }
  function ne(Ae) {
    Z("emit readable"), Ae.emit("readable"), $(Ae);
  }
  function A(Ae, ke) {
    ke.readingMore || (ke.readingMore = !0, e.nextTick(I, Ae, ke));
  }
  function I(Ae, ke) {
    for (var Qe = ke.length; !ke.reading && !ke.flowing && !ke.ended && ke.length < ke.highWaterMark && (Z("maybeReadMore read 0"), Ae.read(0), Qe !== ke.length); )
      Qe = ke.length;
    ke.readingMore = !1;
  }
  ce.prototype._read = function(Ae) {
    this.emit("error", new Error("_read() is not implemented"));
  }, ce.prototype.pipe = function(Ae, ke) {
    var Qe = this, Ze = this._readableState;
    switch (Ze.pipesCount) {
      case 0:
        Ze.pipes = Ae;
        break;
      case 1:
        Ze.pipes = [Ze.pipes, Ae];
        break;
      default:
        Ze.pipes.push(Ae);
        break;
    }
    Ze.pipesCount += 1, Z("pipe count=%d opts=%j", Ze.pipesCount, ke);
    var qe = (!ke || ke.end !== !1) && Ae !== process$1.stdout && Ae !== process$1.stderr, Oe = qe ? et : Ye;
    Ze.endEmitted ? e.nextTick(Oe) : Qe.once("end", Oe), Ae.on("unpipe", Xe);
    function Xe(it, rt) {
      Z("onunpipe"), it === Qe && rt && rt.hasUnpiped === !1 && (rt.hasUnpiped = !0, oe());
    }
    function et() {
      Z("onend"), Ae.end();
    }
    var nt = U(Qe);
    Ae.on("drain", nt);
    var re = !1;
    function oe() {
      Z("cleanup"), Ae.removeListener("close", Je), Ae.removeListener("finish", Fe), Ae.removeListener("drain", nt), Ae.removeListener("error", Ke), Ae.removeListener("unpipe", Xe), Qe.removeListener("end", et), Qe.removeListener("end", Ye), Qe.removeListener("data", ge), re = !0, Ze.awaitDrain && (!Ae._writableState || Ae._writableState.needDrain) && nt();
    }
    var le = !1;
    Qe.on("data", ge);
    function ge(it) {
      Z("ondata"), le = !1;
      var rt = Ae.write(it);
      rt === !1 && !le && ((Ze.pipesCount === 1 && Ze.pipes === Ae || Ze.pipesCount > 1 && Re(Ze.pipes, Ae) !== -1) && !re && (Z("false write response, pause", Ze.awaitDrain), Ze.awaitDrain++, le = !0), Qe.pause());
    }
    function Ke(it) {
      Z("onerror", it), Ye(), Ae.removeListener("error", Ke), o(Ae, "error") === 0 && Ae.emit("error", it);
    }
    fe(Ae, "error", Ke);
    function Je() {
      Ae.removeListener("finish", Fe), Ye();
    }
    Ae.once("close", Je);
    function Fe() {
      Z("onfinish"), Ae.removeListener("close", Je), Ye();
    }
    Ae.once("finish", Fe);
    function Ye() {
      Z("unpipe"), Qe.unpipe(Ae);
    }
    return Ae.emit("pipe", Qe), Ze.flowing || (Z("pipe resume"), Qe.resume()), Ae;
  };
  function U(Ae) {
    return function() {
      var ke = Ae._readableState;
      Z("pipeOnDrain", ke.awaitDrain), ke.awaitDrain && ke.awaitDrain--, ke.awaitDrain === 0 && o(Ae, "data") && (ke.flowing = !0, $(Ae));
    };
  }
  ce.prototype.unpipe = function(Ae) {
    var ke = this._readableState, Qe = { hasUnpiped: !1 };
    if (ke.pipesCount === 0)
      return this;
    if (ke.pipesCount === 1)
      return Ae && Ae !== ke.pipes ? this : (Ae || (Ae = ke.pipes), ke.pipes = null, ke.pipesCount = 0, ke.flowing = !1, Ae && Ae.emit("unpipe", this, Qe), this);
    if (!Ae) {
      var Ze = ke.pipes, qe = ke.pipesCount;
      ke.pipes = null, ke.pipesCount = 0, ke.flowing = !1;
      for (var Oe = 0; Oe < qe; Oe++)
        Ze[Oe].emit("unpipe", this, { hasUnpiped: !1 });
      return this;
    }
    var Xe = Re(ke.pipes, Ae);
    return Xe === -1 ? this : (ke.pipes.splice(Xe, 1), ke.pipesCount -= 1, ke.pipesCount === 1 && (ke.pipes = ke.pipes[0]), Ae.emit("unpipe", this, Qe), this);
  }, ce.prototype.on = function(Ae, ke) {
    var Qe = S.prototype.on.call(this, Ae, ke);
    if (Ae === "data")
      this._readableState.flowing !== !1 && this.resume();
    else if (Ae === "readable") {
      var Ze = this._readableState;
      !Ze.endEmitted && !Ze.readableListening && (Ze.readableListening = Ze.needReadable = !0, Ze.emittedReadable = !1, Ze.reading ? Ze.length && J(this) : e.nextTick(X, this));
    }
    return Qe;
  }, ce.prototype.addListener = ce.prototype.on;
  function X(Ae) {
    Z("readable nexttick read 0"), Ae.read(0);
  }
  ce.prototype.resume = function() {
    var Ae = this._readableState;
    return Ae.flowing || (Z("resume"), Ae.flowing = !0, Q(this, Ae)), this;
  };
  function Q(Ae, ke) {
    ke.resumeScheduled || (ke.resumeScheduled = !0, e.nextTick(F, Ae, ke));
  }
  function F(Ae, ke) {
    ke.reading || (Z("resume read 0"), Ae.read(0)), ke.resumeScheduled = !1, ke.awaitDrain = 0, Ae.emit("resume"), $(Ae), ke.flowing && !ke.reading && Ae.read(0);
  }
  ce.prototype.pause = function() {
    return Z("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (Z("pause"), this._readableState.flowing = !1, this.emit("pause")), this;
  };
  function $(Ae) {
    var ke = Ae._readableState;
    for (Z("flow", ke.flowing); ke.flowing && Ae.read() !== null; )
      ;
  }
  ce.prototype.wrap = function(Ae) {
    var ke = this, Qe = this._readableState, Ze = !1;
    Ae.on("end", function() {
      if (Z("wrapped end"), Qe.decoder && !Qe.ended) {
        var Xe = Qe.decoder.end();
        Xe && Xe.length && ke.push(Xe);
      }
      ke.push(null);
    }), Ae.on("data", function(Xe) {
      if (Z("wrapped data"), Qe.decoder && (Xe = Qe.decoder.write(Xe)), !(Qe.objectMode && Xe == null) && !(!Qe.objectMode && (!Xe || !Xe.length))) {
        var et = ke.push(Xe);
        et || (Ze = !0, Ae.pause());
      }
    });
    for (var qe in Ae)
      this[qe] === void 0 && typeof Ae[qe] == "function" && (this[qe] = /* @__PURE__ */ function(Xe) {
        return function() {
          return Ae[Xe].apply(Ae, arguments);
        };
      }(qe));
    for (var Oe = 0; Oe < ue.length; Oe++)
      Ae.on(ue[Oe], this.emit.bind(this, ue[Oe]));
    return this._read = function(Xe) {
      Z("wrapped _read", Xe), Ze && (Ze = !1, Ae.resume());
    }, this;
  }, Object.defineProperty(ce.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), ce._fromList = H;
  function H(Ae, ke) {
    if (ke.length === 0)
      return null;
    var Qe;
    return ke.objectMode ? Qe = ke.buffer.shift() : !Ae || Ae >= ke.length ? (ke.decoder ? Qe = ke.buffer.join("") : ke.buffer.length === 1 ? Qe = ke.buffer.head.data : Qe = ke.buffer.concat(ke.length), ke.buffer.clear()) : Qe = q(Ae, ke.buffer, ke.decoder), Qe;
  }
  function q(Ae, ke, Qe) {
    var Ze;
    return Ae < ke.head.data.length ? (Ze = ke.head.data.slice(0, Ae), ke.head.data = ke.head.data.slice(Ae)) : Ae === ke.head.data.length ? Ze = ke.shift() : Ze = Qe ? z(Ae, ke) : me(Ae, ke), Ze;
  }
  function z(Ae, ke) {
    var Qe = ke.head, Ze = 1, qe = Qe.data;
    for (Ae -= qe.length; Qe = Qe.next; ) {
      var Oe = Qe.data, Xe = Ae > Oe.length ? Oe.length : Ae;
      if (Xe === Oe.length ? qe += Oe : qe += Oe.slice(0, Ae), Ae -= Xe, Ae === 0) {
        Xe === Oe.length ? (++Ze, Qe.next ? ke.head = Qe.next : ke.head = ke.tail = null) : (ke.head = Qe, Qe.data = Oe.slice(Xe));
        break;
      }
      ++Ze;
    }
    return ke.length -= Ze, qe;
  }
  function me(Ae, ke) {
    var Qe = g.allocUnsafe(Ae), Ze = ke.head, qe = 1;
    for (Ze.data.copy(Qe), Ae -= Ze.data.length; Ze = Ze.next; ) {
      var Oe = Ze.data, Xe = Ae > Oe.length ? Oe.length : Ae;
      if (Oe.copy(Qe, Qe.length - Ae, 0, Xe), Ae -= Xe, Ae === 0) {
        Xe === Oe.length ? (++qe, Ze.next ? ke.head = Ze.next : ke.head = ke.tail = null) : (ke.head = Ze, Ze.data = Oe.slice(Xe));
        break;
      }
      ++qe;
    }
    return ke.length -= qe, Qe;
  }
  function Ce(Ae) {
    var ke = Ae._readableState;
    if (ke.length > 0)
      throw new Error('"endReadable()" called on non-empty stream');
    ke.endEmitted || (ke.ended = !0, e.nextTick(je, ke, Ae));
  }
  function je(Ae, ke) {
    !Ae.endEmitted && Ae.length === 0 && (Ae.endEmitted = !0, ke.readable = !1, ke.emit("end"));
  }
  function Re(Ae, ke) {
    for (var Qe = 0, Ze = Ae.length; Qe < Ze; Qe++)
      if (Ae[Qe] === ke)
        return Qe;
    return -1;
  }
  return _stream_readable;
}
var _stream_transform, hasRequired_stream_transform;
function require_stream_transform() {
  if (hasRequired_stream_transform)
    return _stream_transform;
  hasRequired_stream_transform = 1, _stream_transform = o;
  var e = require_stream_duplex(), t = Object.create(requireUtil());
  t.inherits = requireInherits_browser(), t.inherits(o, e);
  function h(B, M) {
    var O = this._transformState;
    O.transforming = !1;
    var P = O.writecb;
    if (!P)
      return this.emit("error", new Error("write callback called multiple times"));
    O.writechunk = null, O.writecb = null, M != null && this.push(M), P(B);
    var D = this._readableState;
    D.reading = !1, (D.needReadable || D.length < D.highWaterMark) && this._read(D.highWaterMark);
  }
  function o(B) {
    if (!(this instanceof o))
      return new o(B);
    e.call(this, B), this._transformState = {
      afterTransform: h.bind(this),
      needTransform: !1,
      transforming: !1,
      writecb: null,
      writechunk: null,
      writeencoding: null
    }, this._readableState.needReadable = !0, this._readableState.sync = !1, B && (typeof B.transform == "function" && (this._transform = B.transform), typeof B.flush == "function" && (this._flush = B.flush)), this.on("prefinish", S);
  }
  function S() {
    var B = this;
    typeof this._flush == "function" ? this._flush(function(M, O) {
      g(B, M, O);
    }) : g(this, null, null);
  }
  o.prototype.push = function(B, M) {
    return this._transformState.needTransform = !1, e.prototype.push.call(this, B, M);
  }, o.prototype._transform = function(B, M, O) {
    throw new Error("_transform() is not implemented");
  }, o.prototype._write = function(B, M, O) {
    var P = this._transformState;
    if (P.writecb = O, P.writechunk = B, P.writeencoding = M, !P.transforming) {
      var D = this._readableState;
      (P.needTransform || D.needReadable || D.length < D.highWaterMark) && this._read(D.highWaterMark);
    }
  }, o.prototype._read = function(B) {
    var M = this._transformState;
    M.writechunk !== null && M.writecb && !M.transforming ? (M.transforming = !0, this._transform(M.writechunk, M.writeencoding, M.afterTransform)) : M.needTransform = !0;
  }, o.prototype._destroy = function(B, M) {
    var O = this;
    e.prototype._destroy.call(this, B, function(P) {
      M(P), O.emit("close");
    });
  };
  function g(B, M, O) {
    if (M)
      return B.emit("error", M);
    if (O != null && B.push(O), B._writableState.length)
      throw new Error("Calling transform done when ws.length != 0");
    if (B._transformState.transforming)
      throw new Error("Calling transform done when still transforming");
    return B.push(null);
  }
  return _stream_transform;
}
var _stream_passthrough, hasRequired_stream_passthrough;
function require_stream_passthrough() {
  if (hasRequired_stream_passthrough)
    return _stream_passthrough;
  hasRequired_stream_passthrough = 1, _stream_passthrough = h;
  var e = require_stream_transform(), t = Object.create(requireUtil());
  t.inherits = requireInherits_browser(), t.inherits(h, e);
  function h(o) {
    if (!(this instanceof h))
      return new h(o);
    e.call(this, o);
  }
  return h.prototype._transform = function(o, S, g) {
    g(null, o);
  }, _stream_passthrough;
}
var hasRequiredReadableBrowser;
function requireReadableBrowser() {
  return hasRequiredReadableBrowser || (hasRequiredReadableBrowser = 1, function(e, t) {
    t = e.exports = require_stream_readable(), t.Stream = t, t.Readable = t, t.Writable = require_stream_writable(), t.Duplex = require_stream_duplex(), t.Transform = require_stream_transform(), t.PassThrough = require_stream_passthrough();
  }(readableBrowser, readableBrowser.exports)), readableBrowser.exports;
}
var sign = { exports: {} }, bn$1 = { exports: {} }, hasRequiredBn$1;
function requireBn$1() {
  return hasRequiredBn$1 || (hasRequiredBn$1 = 1, function(e) {
    (function(t, h) {
      function o(A, I) {
        if (!A)
          throw new Error(I || "Assertion failed");
      }
      function S(A, I) {
        A.super_ = I;
        var U = function() {
        };
        U.prototype = I.prototype, A.prototype = new U(), A.prototype.constructor = A;
      }
      function g(A, I, U) {
        if (g.isBN(A))
          return A;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, A !== null && ((I === "le" || I === "be") && (U = I, I = 10), this._init(A || 0, I || 10, U || "be"));
      }
      typeof t == "object" ? t.exports = g : h.BN = g, g.BN = g, g.wordSize = 26;
      var B;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? B = window.Buffer : B = requireBuffer$1().Buffer;
      } catch {
      }
      g.isBN = function(A) {
        return A instanceof g ? !0 : A !== null && typeof A == "object" && A.constructor.wordSize === g.wordSize && Array.isArray(A.words);
      }, g.max = function(A, I) {
        return A.cmp(I) > 0 ? A : I;
      }, g.min = function(A, I) {
        return A.cmp(I) < 0 ? A : I;
      }, g.prototype._init = function(A, I, U) {
        if (typeof A == "number")
          return this._initNumber(A, I, U);
        if (typeof A == "object")
          return this._initArray(A, I, U);
        I === "hex" && (I = 16), o(I === (I | 0) && I >= 2 && I <= 36), A = A.toString().replace(/\s+/g, "");
        var X = 0;
        A[0] === "-" && (X++, this.negative = 1), X < A.length && (I === 16 ? this._parseHex(A, X, U) : (this._parseBase(A, I, X), U === "le" && this._initArray(this.toArray(), I, U)));
      }, g.prototype._initNumber = function(A, I, U) {
        A < 0 && (this.negative = 1, A = -A), A < 67108864 ? (this.words = [A & 67108863], this.length = 1) : A < 4503599627370496 ? (this.words = [
          A & 67108863,
          A / 67108864 & 67108863
        ], this.length = 2) : (o(A < 9007199254740992), this.words = [
          A & 67108863,
          A / 67108864 & 67108863,
          1
        ], this.length = 3), U === "le" && this._initArray(this.toArray(), I, U);
      }, g.prototype._initArray = function(A, I, U) {
        if (o(typeof A.length == "number"), A.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(A.length / 3), this.words = new Array(this.length);
        for (var X = 0; X < this.length; X++)
          this.words[X] = 0;
        var Q, F, $ = 0;
        if (U === "be")
          for (X = A.length - 1, Q = 0; X >= 0; X -= 3)
            F = A[X] | A[X - 1] << 8 | A[X - 2] << 16, this.words[Q] |= F << $ & 67108863, this.words[Q + 1] = F >>> 26 - $ & 67108863, $ += 24, $ >= 26 && ($ -= 26, Q++);
        else if (U === "le")
          for (X = 0, Q = 0; X < A.length; X += 3)
            F = A[X] | A[X + 1] << 8 | A[X + 2] << 16, this.words[Q] |= F << $ & 67108863, this.words[Q + 1] = F >>> 26 - $ & 67108863, $ += 24, $ >= 26 && ($ -= 26, Q++);
        return this._strip();
      };
      function M(A, I) {
        var U = A.charCodeAt(I);
        if (U >= 48 && U <= 57)
          return U - 48;
        if (U >= 65 && U <= 70)
          return U - 55;
        if (U >= 97 && U <= 102)
          return U - 87;
        o(!1, "Invalid character in " + A);
      }
      function O(A, I, U) {
        var X = M(A, U);
        return U - 1 >= I && (X |= M(A, U - 1) << 4), X;
      }
      g.prototype._parseHex = function(A, I, U) {
        this.length = Math.ceil((A.length - I) / 6), this.words = new Array(this.length);
        for (var X = 0; X < this.length; X++)
          this.words[X] = 0;
        var Q = 0, F = 0, $;
        if (U === "be")
          for (X = A.length - 1; X >= I; X -= 2)
            $ = O(A, I, X) << Q, this.words[F] |= $ & 67108863, Q >= 18 ? (Q -= 18, F += 1, this.words[F] |= $ >>> 26) : Q += 8;
        else {
          var H = A.length - I;
          for (X = H % 2 === 0 ? I + 1 : I; X < A.length; X += 2)
            $ = O(A, I, X) << Q, this.words[F] |= $ & 67108863, Q >= 18 ? (Q -= 18, F += 1, this.words[F] |= $ >>> 26) : Q += 8;
        }
        this._strip();
      };
      function P(A, I, U, X) {
        for (var Q = 0, F = 0, $ = Math.min(A.length, U), H = I; H < $; H++) {
          var q = A.charCodeAt(H) - 48;
          Q *= X, q >= 49 ? F = q - 49 + 10 : q >= 17 ? F = q - 17 + 10 : F = q, o(q >= 0 && F < X, "Invalid character"), Q += F;
        }
        return Q;
      }
      g.prototype._parseBase = function(A, I, U) {
        this.words = [0], this.length = 1;
        for (var X = 0, Q = 1; Q <= 67108863; Q *= I)
          X++;
        X--, Q = Q / I | 0;
        for (var F = A.length - U, $ = F % X, H = Math.min(F, F - $) + U, q = 0, z = U; z < H; z += X)
          q = P(A, z, z + X, I), this.imuln(Q), this.words[0] + q < 67108864 ? this.words[0] += q : this._iaddn(q);
        if ($ !== 0) {
          var me = 1;
          for (q = P(A, z, A.length, I), z = 0; z < $; z++)
            me *= I;
          this.imuln(me), this.words[0] + q < 67108864 ? this.words[0] += q : this._iaddn(q);
        }
        this._strip();
      }, g.prototype.copy = function(A) {
        A.words = new Array(this.length);
        for (var I = 0; I < this.length; I++)
          A.words[I] = this.words[I];
        A.length = this.length, A.negative = this.negative, A.red = this.red;
      };
      function D(A, I) {
        A.words = I.words, A.length = I.length, A.negative = I.negative, A.red = I.red;
      }
      if (g.prototype._move = function(A) {
        D(A, this);
      }, g.prototype.clone = function() {
        var A = new g(null);
        return this.copy(A), A;
      }, g.prototype._expand = function(A) {
        for (; this.length < A; )
          this.words[this.length++] = 0;
        return this;
      }, g.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, g.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          g.prototype[Symbol.for("nodejs.util.inspect.custom")] = Z;
        } catch {
          g.prototype.inspect = Z;
        }
      else
        g.prototype.inspect = Z;
      function Z() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var Y = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], ee = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], ie = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      g.prototype.toString = function(A, I) {
        A = A || 10, I = I | 0 || 1;
        var U;
        if (A === 16 || A === "hex") {
          U = "";
          for (var X = 0, Q = 0, F = 0; F < this.length; F++) {
            var $ = this.words[F], H = (($ << X | Q) & 16777215).toString(16);
            Q = $ >>> 24 - X & 16777215, X += 2, X >= 26 && (X -= 26, F--), Q !== 0 || F !== this.length - 1 ? U = Y[6 - H.length] + H + U : U = H + U;
          }
          for (Q !== 0 && (U = Q.toString(16) + U); U.length % I !== 0; )
            U = "0" + U;
          return this.negative !== 0 && (U = "-" + U), U;
        }
        if (A === (A | 0) && A >= 2 && A <= 36) {
          var q = ee[A], z = ie[A];
          U = "";
          var me = this.clone();
          for (me.negative = 0; !me.isZero(); ) {
            var Ce = me.modrn(z).toString(A);
            me = me.idivn(z), me.isZero() ? U = Ce + U : U = Y[q - Ce.length] + Ce + U;
          }
          for (this.isZero() && (U = "0" + U); U.length % I !== 0; )
            U = "0" + U;
          return this.negative !== 0 && (U = "-" + U), U;
        }
        o(!1, "Base should be between 2 and 36");
      }, g.prototype.toNumber = function() {
        var A = this.words[0];
        return this.length === 2 ? A += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? A += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && o(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -A : A;
      }, g.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, B && (g.prototype.toBuffer = function(A, I) {
        return this.toArrayLike(B, A, I);
      }), g.prototype.toArray = function(A, I) {
        return this.toArrayLike(Array, A, I);
      };
      var ue = function(A, I) {
        return A.allocUnsafe ? A.allocUnsafe(I) : new A(I);
      };
      g.prototype.toArrayLike = function(A, I, U) {
        this._strip();
        var X = this.byteLength(), Q = U || Math.max(1, X);
        o(X <= Q, "byte array longer than desired length"), o(Q > 0, "Requested array length <= 0");
        var F = ue(A, Q), $ = I === "le" ? "LE" : "BE";
        return this["_toArrayLike" + $](F, X), F;
      }, g.prototype._toArrayLikeLE = function(A, I) {
        for (var U = 0, X = 0, Q = 0, F = 0; Q < this.length; Q++) {
          var $ = this.words[Q] << F | X;
          A[U++] = $ & 255, U < A.length && (A[U++] = $ >> 8 & 255), U < A.length && (A[U++] = $ >> 16 & 255), F === 6 ? (U < A.length && (A[U++] = $ >> 24 & 255), X = 0, F = 0) : (X = $ >>> 24, F += 2);
        }
        if (U < A.length)
          for (A[U++] = X; U < A.length; )
            A[U++] = 0;
      }, g.prototype._toArrayLikeBE = function(A, I) {
        for (var U = A.length - 1, X = 0, Q = 0, F = 0; Q < this.length; Q++) {
          var $ = this.words[Q] << F | X;
          A[U--] = $ & 255, U >= 0 && (A[U--] = $ >> 8 & 255), U >= 0 && (A[U--] = $ >> 16 & 255), F === 6 ? (U >= 0 && (A[U--] = $ >> 24 & 255), X = 0, F = 0) : (X = $ >>> 24, F += 2);
        }
        if (U >= 0)
          for (A[U--] = X; U >= 0; )
            A[U--] = 0;
      }, Math.clz32 ? g.prototype._countBits = function(A) {
        return 32 - Math.clz32(A);
      } : g.prototype._countBits = function(A) {
        var I = A, U = 0;
        return I >= 4096 && (U += 13, I >>>= 13), I >= 64 && (U += 7, I >>>= 7), I >= 8 && (U += 4, I >>>= 4), I >= 2 && (U += 2, I >>>= 2), U + I;
      }, g.prototype._zeroBits = function(A) {
        if (A === 0)
          return 26;
        var I = A, U = 0;
        return I & 8191 || (U += 13, I >>>= 13), I & 127 || (U += 7, I >>>= 7), I & 15 || (U += 4, I >>>= 4), I & 3 || (U += 2, I >>>= 2), I & 1 || U++, U;
      }, g.prototype.bitLength = function() {
        var A = this.words[this.length - 1], I = this._countBits(A);
        return (this.length - 1) * 26 + I;
      };
      function fe(A) {
        for (var I = new Array(A.bitLength()), U = 0; U < I.length; U++) {
          var X = U / 26 | 0, Q = U % 26;
          I[U] = A.words[X] >>> Q & 1;
        }
        return I;
      }
      g.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var A = 0, I = 0; I < this.length; I++) {
          var U = this._zeroBits(this.words[I]);
          if (A += U, U !== 26)
            break;
        }
        return A;
      }, g.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, g.prototype.toTwos = function(A) {
        return this.negative !== 0 ? this.abs().inotn(A).iaddn(1) : this.clone();
      }, g.prototype.fromTwos = function(A) {
        return this.testn(A - 1) ? this.notn(A).iaddn(1).ineg() : this.clone();
      }, g.prototype.isNeg = function() {
        return this.negative !== 0;
      }, g.prototype.neg = function() {
        return this.clone().ineg();
      }, g.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, g.prototype.iuor = function(A) {
        for (; this.length < A.length; )
          this.words[this.length++] = 0;
        for (var I = 0; I < A.length; I++)
          this.words[I] = this.words[I] | A.words[I];
        return this._strip();
      }, g.prototype.ior = function(A) {
        return o((this.negative | A.negative) === 0), this.iuor(A);
      }, g.prototype.or = function(A) {
        return this.length > A.length ? this.clone().ior(A) : A.clone().ior(this);
      }, g.prototype.uor = function(A) {
        return this.length > A.length ? this.clone().iuor(A) : A.clone().iuor(this);
      }, g.prototype.iuand = function(A) {
        var I;
        this.length > A.length ? I = A : I = this;
        for (var U = 0; U < I.length; U++)
          this.words[U] = this.words[U] & A.words[U];
        return this.length = I.length, this._strip();
      }, g.prototype.iand = function(A) {
        return o((this.negative | A.negative) === 0), this.iuand(A);
      }, g.prototype.and = function(A) {
        return this.length > A.length ? this.clone().iand(A) : A.clone().iand(this);
      }, g.prototype.uand = function(A) {
        return this.length > A.length ? this.clone().iuand(A) : A.clone().iuand(this);
      }, g.prototype.iuxor = function(A) {
        var I, U;
        this.length > A.length ? (I = this, U = A) : (I = A, U = this);
        for (var X = 0; X < U.length; X++)
          this.words[X] = I.words[X] ^ U.words[X];
        if (this !== I)
          for (; X < I.length; X++)
            this.words[X] = I.words[X];
        return this.length = I.length, this._strip();
      }, g.prototype.ixor = function(A) {
        return o((this.negative | A.negative) === 0), this.iuxor(A);
      }, g.prototype.xor = function(A) {
        return this.length > A.length ? this.clone().ixor(A) : A.clone().ixor(this);
      }, g.prototype.uxor = function(A) {
        return this.length > A.length ? this.clone().iuxor(A) : A.clone().iuxor(this);
      }, g.prototype.inotn = function(A) {
        o(typeof A == "number" && A >= 0);
        var I = Math.ceil(A / 26) | 0, U = A % 26;
        this._expand(I), U > 0 && I--;
        for (var X = 0; X < I; X++)
          this.words[X] = ~this.words[X] & 67108863;
        return U > 0 && (this.words[X] = ~this.words[X] & 67108863 >> 26 - U), this._strip();
      }, g.prototype.notn = function(A) {
        return this.clone().inotn(A);
      }, g.prototype.setn = function(A, I) {
        o(typeof A == "number" && A >= 0);
        var U = A / 26 | 0, X = A % 26;
        return this._expand(U + 1), I ? this.words[U] = this.words[U] | 1 << X : this.words[U] = this.words[U] & ~(1 << X), this._strip();
      }, g.prototype.iadd = function(A) {
        var I;
        if (this.negative !== 0 && A.negative === 0)
          return this.negative = 0, I = this.isub(A), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && A.negative !== 0)
          return A.negative = 0, I = this.isub(A), A.negative = 1, I._normSign();
        var U, X;
        this.length > A.length ? (U = this, X = A) : (U = A, X = this);
        for (var Q = 0, F = 0; F < X.length; F++)
          I = (U.words[F] | 0) + (X.words[F] | 0) + Q, this.words[F] = I & 67108863, Q = I >>> 26;
        for (; Q !== 0 && F < U.length; F++)
          I = (U.words[F] | 0) + Q, this.words[F] = I & 67108863, Q = I >>> 26;
        if (this.length = U.length, Q !== 0)
          this.words[this.length] = Q, this.length++;
        else if (U !== this)
          for (; F < U.length; F++)
            this.words[F] = U.words[F];
        return this;
      }, g.prototype.add = function(A) {
        var I;
        return A.negative !== 0 && this.negative === 0 ? (A.negative = 0, I = this.sub(A), A.negative ^= 1, I) : A.negative === 0 && this.negative !== 0 ? (this.negative = 0, I = A.sub(this), this.negative = 1, I) : this.length > A.length ? this.clone().iadd(A) : A.clone().iadd(this);
      }, g.prototype.isub = function(A) {
        if (A.negative !== 0) {
          A.negative = 0;
          var I = this.iadd(A);
          return A.negative = 1, I._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(A), this.negative = 1, this._normSign();
        var U = this.cmp(A);
        if (U === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var X, Q;
        U > 0 ? (X = this, Q = A) : (X = A, Q = this);
        for (var F = 0, $ = 0; $ < Q.length; $++)
          I = (X.words[$] | 0) - (Q.words[$] | 0) + F, F = I >> 26, this.words[$] = I & 67108863;
        for (; F !== 0 && $ < X.length; $++)
          I = (X.words[$] | 0) + F, F = I >> 26, this.words[$] = I & 67108863;
        if (F === 0 && $ < X.length && X !== this)
          for (; $ < X.length; $++)
            this.words[$] = X.words[$];
        return this.length = Math.max(this.length, $), X !== this && (this.negative = 1), this._strip();
      }, g.prototype.sub = function(A) {
        return this.clone().isub(A);
      };
      function de(A, I, U) {
        U.negative = I.negative ^ A.negative;
        var X = A.length + I.length | 0;
        U.length = X, X = X - 1 | 0;
        var Q = A.words[0] | 0, F = I.words[0] | 0, $ = Q * F, H = $ & 67108863, q = $ / 67108864 | 0;
        U.words[0] = H;
        for (var z = 1; z < X; z++) {
          for (var me = q >>> 26, Ce = q & 67108863, je = Math.min(z, I.length - 1), Re = Math.max(0, z - A.length + 1); Re <= je; Re++) {
            var Ae = z - Re | 0;
            Q = A.words[Ae] | 0, F = I.words[Re] | 0, $ = Q * F + Ce, me += $ / 67108864 | 0, Ce = $ & 67108863;
          }
          U.words[z] = Ce | 0, q = me | 0;
        }
        return q !== 0 ? U.words[z] = q | 0 : U.length--, U._strip();
      }
      var ce = function(A, I, U) {
        var X = A.words, Q = I.words, F = U.words, $ = 0, H, q, z, me = X[0] | 0, Ce = me & 8191, je = me >>> 13, Re = X[1] | 0, Ae = Re & 8191, ke = Re >>> 13, Qe = X[2] | 0, Ze = Qe & 8191, qe = Qe >>> 13, Oe = X[3] | 0, Xe = Oe & 8191, et = Oe >>> 13, nt = X[4] | 0, re = nt & 8191, oe = nt >>> 13, le = X[5] | 0, ge = le & 8191, Ke = le >>> 13, Je = X[6] | 0, Fe = Je & 8191, Ye = Je >>> 13, it = X[7] | 0, rt = it & 8191, tt = it >>> 13, vt = X[8] | 0, St = vt & 8191, ot = vt >>> 13, si = X[9] | 0, oi = si & 8191, At = si >>> 13, Nn = Q[0] | 0, ui = Nn & 8191, Bt = Nn >>> 13, vi = Q[1] | 0, fi = vi & 8191, Ct = vi >>> 13, rM = Q[2] | 0, hi = rM & 8191, Tt = rM >>> 13, Dn = Q[3] | 0, di = Dn & 8191, Ot = Dn >>> 13, iM = Q[4] | 0, ci = iM & 8191, Dt = iM >>> 13, nM = Q[5] | 0, li = nM & 8191, ri = nM >>> 13, eM = Q[6] | 0, ai = eM & 8191, It = eM >>> 13, tM = Q[7] | 0, pi = tM & 8191, ii = tM >>> 13, oM = Q[8] | 0, gi = oM & 8191, ni = oM >>> 13, aM = Q[9] | 0, yi = aM & 8191, mi = aM >>> 13;
        U.negative = A.negative ^ I.negative, U.length = 19, H = Math.imul(Ce, ui), q = Math.imul(Ce, Bt), q = q + Math.imul(je, ui) | 0, z = Math.imul(je, Bt);
        var sM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (sM >>> 26) | 0, sM &= 67108863, H = Math.imul(Ae, ui), q = Math.imul(Ae, Bt), q = q + Math.imul(ke, ui) | 0, z = Math.imul(ke, Bt), H = H + Math.imul(Ce, fi) | 0, q = q + Math.imul(Ce, Ct) | 0, q = q + Math.imul(je, fi) | 0, z = z + Math.imul(je, Ct) | 0;
        var uM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (uM >>> 26) | 0, uM &= 67108863, H = Math.imul(Ze, ui), q = Math.imul(Ze, Bt), q = q + Math.imul(qe, ui) | 0, z = Math.imul(qe, Bt), H = H + Math.imul(Ae, fi) | 0, q = q + Math.imul(Ae, Ct) | 0, q = q + Math.imul(ke, fi) | 0, z = z + Math.imul(ke, Ct) | 0, H = H + Math.imul(Ce, hi) | 0, q = q + Math.imul(Ce, Tt) | 0, q = q + Math.imul(je, hi) | 0, z = z + Math.imul(je, Tt) | 0;
        var fM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (fM >>> 26) | 0, fM &= 67108863, H = Math.imul(Xe, ui), q = Math.imul(Xe, Bt), q = q + Math.imul(et, ui) | 0, z = Math.imul(et, Bt), H = H + Math.imul(Ze, fi) | 0, q = q + Math.imul(Ze, Ct) | 0, q = q + Math.imul(qe, fi) | 0, z = z + Math.imul(qe, Ct) | 0, H = H + Math.imul(Ae, hi) | 0, q = q + Math.imul(Ae, Tt) | 0, q = q + Math.imul(ke, hi) | 0, z = z + Math.imul(ke, Tt) | 0, H = H + Math.imul(Ce, di) | 0, q = q + Math.imul(Ce, Ot) | 0, q = q + Math.imul(je, di) | 0, z = z + Math.imul(je, Ot) | 0;
        var hM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (hM >>> 26) | 0, hM &= 67108863, H = Math.imul(re, ui), q = Math.imul(re, Bt), q = q + Math.imul(oe, ui) | 0, z = Math.imul(oe, Bt), H = H + Math.imul(Xe, fi) | 0, q = q + Math.imul(Xe, Ct) | 0, q = q + Math.imul(et, fi) | 0, z = z + Math.imul(et, Ct) | 0, H = H + Math.imul(Ze, hi) | 0, q = q + Math.imul(Ze, Tt) | 0, q = q + Math.imul(qe, hi) | 0, z = z + Math.imul(qe, Tt) | 0, H = H + Math.imul(Ae, di) | 0, q = q + Math.imul(Ae, Ot) | 0, q = q + Math.imul(ke, di) | 0, z = z + Math.imul(ke, Ot) | 0, H = H + Math.imul(Ce, ci) | 0, q = q + Math.imul(Ce, Dt) | 0, q = q + Math.imul(je, ci) | 0, z = z + Math.imul(je, Dt) | 0;
        var cM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (cM >>> 26) | 0, cM &= 67108863, H = Math.imul(ge, ui), q = Math.imul(ge, Bt), q = q + Math.imul(Ke, ui) | 0, z = Math.imul(Ke, Bt), H = H + Math.imul(re, fi) | 0, q = q + Math.imul(re, Ct) | 0, q = q + Math.imul(oe, fi) | 0, z = z + Math.imul(oe, Ct) | 0, H = H + Math.imul(Xe, hi) | 0, q = q + Math.imul(Xe, Tt) | 0, q = q + Math.imul(et, hi) | 0, z = z + Math.imul(et, Tt) | 0, H = H + Math.imul(Ze, di) | 0, q = q + Math.imul(Ze, Ot) | 0, q = q + Math.imul(qe, di) | 0, z = z + Math.imul(qe, Ot) | 0, H = H + Math.imul(Ae, ci) | 0, q = q + Math.imul(Ae, Dt) | 0, q = q + Math.imul(ke, ci) | 0, z = z + Math.imul(ke, Dt) | 0, H = H + Math.imul(Ce, li) | 0, q = q + Math.imul(Ce, ri) | 0, q = q + Math.imul(je, li) | 0, z = z + Math.imul(je, ri) | 0;
        var lM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (lM >>> 26) | 0, lM &= 67108863, H = Math.imul(Fe, ui), q = Math.imul(Fe, Bt), q = q + Math.imul(Ye, ui) | 0, z = Math.imul(Ye, Bt), H = H + Math.imul(ge, fi) | 0, q = q + Math.imul(ge, Ct) | 0, q = q + Math.imul(Ke, fi) | 0, z = z + Math.imul(Ke, Ct) | 0, H = H + Math.imul(re, hi) | 0, q = q + Math.imul(re, Tt) | 0, q = q + Math.imul(oe, hi) | 0, z = z + Math.imul(oe, Tt) | 0, H = H + Math.imul(Xe, di) | 0, q = q + Math.imul(Xe, Ot) | 0, q = q + Math.imul(et, di) | 0, z = z + Math.imul(et, Ot) | 0, H = H + Math.imul(Ze, ci) | 0, q = q + Math.imul(Ze, Dt) | 0, q = q + Math.imul(qe, ci) | 0, z = z + Math.imul(qe, Dt) | 0, H = H + Math.imul(Ae, li) | 0, q = q + Math.imul(Ae, ri) | 0, q = q + Math.imul(ke, li) | 0, z = z + Math.imul(ke, ri) | 0, H = H + Math.imul(Ce, ai) | 0, q = q + Math.imul(Ce, It) | 0, q = q + Math.imul(je, ai) | 0, z = z + Math.imul(je, It) | 0;
        var dM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (dM >>> 26) | 0, dM &= 67108863, H = Math.imul(rt, ui), q = Math.imul(rt, Bt), q = q + Math.imul(tt, ui) | 0, z = Math.imul(tt, Bt), H = H + Math.imul(Fe, fi) | 0, q = q + Math.imul(Fe, Ct) | 0, q = q + Math.imul(Ye, fi) | 0, z = z + Math.imul(Ye, Ct) | 0, H = H + Math.imul(ge, hi) | 0, q = q + Math.imul(ge, Tt) | 0, q = q + Math.imul(Ke, hi) | 0, z = z + Math.imul(Ke, Tt) | 0, H = H + Math.imul(re, di) | 0, q = q + Math.imul(re, Ot) | 0, q = q + Math.imul(oe, di) | 0, z = z + Math.imul(oe, Ot) | 0, H = H + Math.imul(Xe, ci) | 0, q = q + Math.imul(Xe, Dt) | 0, q = q + Math.imul(et, ci) | 0, z = z + Math.imul(et, Dt) | 0, H = H + Math.imul(Ze, li) | 0, q = q + Math.imul(Ze, ri) | 0, q = q + Math.imul(qe, li) | 0, z = z + Math.imul(qe, ri) | 0, H = H + Math.imul(Ae, ai) | 0, q = q + Math.imul(Ae, It) | 0, q = q + Math.imul(ke, ai) | 0, z = z + Math.imul(ke, It) | 0, H = H + Math.imul(Ce, pi) | 0, q = q + Math.imul(Ce, ii) | 0, q = q + Math.imul(je, pi) | 0, z = z + Math.imul(je, ii) | 0;
        var pM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (pM >>> 26) | 0, pM &= 67108863, H = Math.imul(St, ui), q = Math.imul(St, Bt), q = q + Math.imul(ot, ui) | 0, z = Math.imul(ot, Bt), H = H + Math.imul(rt, fi) | 0, q = q + Math.imul(rt, Ct) | 0, q = q + Math.imul(tt, fi) | 0, z = z + Math.imul(tt, Ct) | 0, H = H + Math.imul(Fe, hi) | 0, q = q + Math.imul(Fe, Tt) | 0, q = q + Math.imul(Ye, hi) | 0, z = z + Math.imul(Ye, Tt) | 0, H = H + Math.imul(ge, di) | 0, q = q + Math.imul(ge, Ot) | 0, q = q + Math.imul(Ke, di) | 0, z = z + Math.imul(Ke, Ot) | 0, H = H + Math.imul(re, ci) | 0, q = q + Math.imul(re, Dt) | 0, q = q + Math.imul(oe, ci) | 0, z = z + Math.imul(oe, Dt) | 0, H = H + Math.imul(Xe, li) | 0, q = q + Math.imul(Xe, ri) | 0, q = q + Math.imul(et, li) | 0, z = z + Math.imul(et, ri) | 0, H = H + Math.imul(Ze, ai) | 0, q = q + Math.imul(Ze, It) | 0, q = q + Math.imul(qe, ai) | 0, z = z + Math.imul(qe, It) | 0, H = H + Math.imul(Ae, pi) | 0, q = q + Math.imul(Ae, ii) | 0, q = q + Math.imul(ke, pi) | 0, z = z + Math.imul(ke, ii) | 0, H = H + Math.imul(Ce, gi) | 0, q = q + Math.imul(Ce, ni) | 0, q = q + Math.imul(je, gi) | 0, z = z + Math.imul(je, ni) | 0;
        var yM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (yM >>> 26) | 0, yM &= 67108863, H = Math.imul(oi, ui), q = Math.imul(oi, Bt), q = q + Math.imul(At, ui) | 0, z = Math.imul(At, Bt), H = H + Math.imul(St, fi) | 0, q = q + Math.imul(St, Ct) | 0, q = q + Math.imul(ot, fi) | 0, z = z + Math.imul(ot, Ct) | 0, H = H + Math.imul(rt, hi) | 0, q = q + Math.imul(rt, Tt) | 0, q = q + Math.imul(tt, hi) | 0, z = z + Math.imul(tt, Tt) | 0, H = H + Math.imul(Fe, di) | 0, q = q + Math.imul(Fe, Ot) | 0, q = q + Math.imul(Ye, di) | 0, z = z + Math.imul(Ye, Ot) | 0, H = H + Math.imul(ge, ci) | 0, q = q + Math.imul(ge, Dt) | 0, q = q + Math.imul(Ke, ci) | 0, z = z + Math.imul(Ke, Dt) | 0, H = H + Math.imul(re, li) | 0, q = q + Math.imul(re, ri) | 0, q = q + Math.imul(oe, li) | 0, z = z + Math.imul(oe, ri) | 0, H = H + Math.imul(Xe, ai) | 0, q = q + Math.imul(Xe, It) | 0, q = q + Math.imul(et, ai) | 0, z = z + Math.imul(et, It) | 0, H = H + Math.imul(Ze, pi) | 0, q = q + Math.imul(Ze, ii) | 0, q = q + Math.imul(qe, pi) | 0, z = z + Math.imul(qe, ii) | 0, H = H + Math.imul(Ae, gi) | 0, q = q + Math.imul(Ae, ni) | 0, q = q + Math.imul(ke, gi) | 0, z = z + Math.imul(ke, ni) | 0, H = H + Math.imul(Ce, yi) | 0, q = q + Math.imul(Ce, mi) | 0, q = q + Math.imul(je, yi) | 0, z = z + Math.imul(je, mi) | 0;
        var mM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (mM >>> 26) | 0, mM &= 67108863, H = Math.imul(oi, fi), q = Math.imul(oi, Ct), q = q + Math.imul(At, fi) | 0, z = Math.imul(At, Ct), H = H + Math.imul(St, hi) | 0, q = q + Math.imul(St, Tt) | 0, q = q + Math.imul(ot, hi) | 0, z = z + Math.imul(ot, Tt) | 0, H = H + Math.imul(rt, di) | 0, q = q + Math.imul(rt, Ot) | 0, q = q + Math.imul(tt, di) | 0, z = z + Math.imul(tt, Ot) | 0, H = H + Math.imul(Fe, ci) | 0, q = q + Math.imul(Fe, Dt) | 0, q = q + Math.imul(Ye, ci) | 0, z = z + Math.imul(Ye, Dt) | 0, H = H + Math.imul(ge, li) | 0, q = q + Math.imul(ge, ri) | 0, q = q + Math.imul(Ke, li) | 0, z = z + Math.imul(Ke, ri) | 0, H = H + Math.imul(re, ai) | 0, q = q + Math.imul(re, It) | 0, q = q + Math.imul(oe, ai) | 0, z = z + Math.imul(oe, It) | 0, H = H + Math.imul(Xe, pi) | 0, q = q + Math.imul(Xe, ii) | 0, q = q + Math.imul(et, pi) | 0, z = z + Math.imul(et, ii) | 0, H = H + Math.imul(Ze, gi) | 0, q = q + Math.imul(Ze, ni) | 0, q = q + Math.imul(qe, gi) | 0, z = z + Math.imul(qe, ni) | 0, H = H + Math.imul(Ae, yi) | 0, q = q + Math.imul(Ae, mi) | 0, q = q + Math.imul(ke, yi) | 0, z = z + Math.imul(ke, mi) | 0;
        var gM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (gM >>> 26) | 0, gM &= 67108863, H = Math.imul(oi, hi), q = Math.imul(oi, Tt), q = q + Math.imul(At, hi) | 0, z = Math.imul(At, Tt), H = H + Math.imul(St, di) | 0, q = q + Math.imul(St, Ot) | 0, q = q + Math.imul(ot, di) | 0, z = z + Math.imul(ot, Ot) | 0, H = H + Math.imul(rt, ci) | 0, q = q + Math.imul(rt, Dt) | 0, q = q + Math.imul(tt, ci) | 0, z = z + Math.imul(tt, Dt) | 0, H = H + Math.imul(Fe, li) | 0, q = q + Math.imul(Fe, ri) | 0, q = q + Math.imul(Ye, li) | 0, z = z + Math.imul(Ye, ri) | 0, H = H + Math.imul(ge, ai) | 0, q = q + Math.imul(ge, It) | 0, q = q + Math.imul(Ke, ai) | 0, z = z + Math.imul(Ke, It) | 0, H = H + Math.imul(re, pi) | 0, q = q + Math.imul(re, ii) | 0, q = q + Math.imul(oe, pi) | 0, z = z + Math.imul(oe, ii) | 0, H = H + Math.imul(Xe, gi) | 0, q = q + Math.imul(Xe, ni) | 0, q = q + Math.imul(et, gi) | 0, z = z + Math.imul(et, ni) | 0, H = H + Math.imul(Ze, yi) | 0, q = q + Math.imul(Ze, mi) | 0, q = q + Math.imul(qe, yi) | 0, z = z + Math.imul(qe, mi) | 0;
        var bM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (bM >>> 26) | 0, bM &= 67108863, H = Math.imul(oi, di), q = Math.imul(oi, Ot), q = q + Math.imul(At, di) | 0, z = Math.imul(At, Ot), H = H + Math.imul(St, ci) | 0, q = q + Math.imul(St, Dt) | 0, q = q + Math.imul(ot, ci) | 0, z = z + Math.imul(ot, Dt) | 0, H = H + Math.imul(rt, li) | 0, q = q + Math.imul(rt, ri) | 0, q = q + Math.imul(tt, li) | 0, z = z + Math.imul(tt, ri) | 0, H = H + Math.imul(Fe, ai) | 0, q = q + Math.imul(Fe, It) | 0, q = q + Math.imul(Ye, ai) | 0, z = z + Math.imul(Ye, It) | 0, H = H + Math.imul(ge, pi) | 0, q = q + Math.imul(ge, ii) | 0, q = q + Math.imul(Ke, pi) | 0, z = z + Math.imul(Ke, ii) | 0, H = H + Math.imul(re, gi) | 0, q = q + Math.imul(re, ni) | 0, q = q + Math.imul(oe, gi) | 0, z = z + Math.imul(oe, ni) | 0, H = H + Math.imul(Xe, yi) | 0, q = q + Math.imul(Xe, mi) | 0, q = q + Math.imul(et, yi) | 0, z = z + Math.imul(et, mi) | 0;
        var vM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (vM >>> 26) | 0, vM &= 67108863, H = Math.imul(oi, ci), q = Math.imul(oi, Dt), q = q + Math.imul(At, ci) | 0, z = Math.imul(At, Dt), H = H + Math.imul(St, li) | 0, q = q + Math.imul(St, ri) | 0, q = q + Math.imul(ot, li) | 0, z = z + Math.imul(ot, ri) | 0, H = H + Math.imul(rt, ai) | 0, q = q + Math.imul(rt, It) | 0, q = q + Math.imul(tt, ai) | 0, z = z + Math.imul(tt, It) | 0, H = H + Math.imul(Fe, pi) | 0, q = q + Math.imul(Fe, ii) | 0, q = q + Math.imul(Ye, pi) | 0, z = z + Math.imul(Ye, ii) | 0, H = H + Math.imul(ge, gi) | 0, q = q + Math.imul(ge, ni) | 0, q = q + Math.imul(Ke, gi) | 0, z = z + Math.imul(Ke, ni) | 0, H = H + Math.imul(re, yi) | 0, q = q + Math.imul(re, mi) | 0, q = q + Math.imul(oe, yi) | 0, z = z + Math.imul(oe, mi) | 0;
        var wM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (wM >>> 26) | 0, wM &= 67108863, H = Math.imul(oi, li), q = Math.imul(oi, ri), q = q + Math.imul(At, li) | 0, z = Math.imul(At, ri), H = H + Math.imul(St, ai) | 0, q = q + Math.imul(St, It) | 0, q = q + Math.imul(ot, ai) | 0, z = z + Math.imul(ot, It) | 0, H = H + Math.imul(rt, pi) | 0, q = q + Math.imul(rt, ii) | 0, q = q + Math.imul(tt, pi) | 0, z = z + Math.imul(tt, ii) | 0, H = H + Math.imul(Fe, gi) | 0, q = q + Math.imul(Fe, ni) | 0, q = q + Math.imul(Ye, gi) | 0, z = z + Math.imul(Ye, ni) | 0, H = H + Math.imul(ge, yi) | 0, q = q + Math.imul(ge, mi) | 0, q = q + Math.imul(Ke, yi) | 0, z = z + Math.imul(Ke, mi) | 0;
        var _M = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (_M >>> 26) | 0, _M &= 67108863, H = Math.imul(oi, ai), q = Math.imul(oi, It), q = q + Math.imul(At, ai) | 0, z = Math.imul(At, It), H = H + Math.imul(St, pi) | 0, q = q + Math.imul(St, ii) | 0, q = q + Math.imul(ot, pi) | 0, z = z + Math.imul(ot, ii) | 0, H = H + Math.imul(rt, gi) | 0, q = q + Math.imul(rt, ni) | 0, q = q + Math.imul(tt, gi) | 0, z = z + Math.imul(tt, ni) | 0, H = H + Math.imul(Fe, yi) | 0, q = q + Math.imul(Fe, mi) | 0, q = q + Math.imul(Ye, yi) | 0, z = z + Math.imul(Ye, mi) | 0;
        var SM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (SM >>> 26) | 0, SM &= 67108863, H = Math.imul(oi, pi), q = Math.imul(oi, ii), q = q + Math.imul(At, pi) | 0, z = Math.imul(At, ii), H = H + Math.imul(St, gi) | 0, q = q + Math.imul(St, ni) | 0, q = q + Math.imul(ot, gi) | 0, z = z + Math.imul(ot, ni) | 0, H = H + Math.imul(rt, yi) | 0, q = q + Math.imul(rt, mi) | 0, q = q + Math.imul(tt, yi) | 0, z = z + Math.imul(tt, mi) | 0;
        var EM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (EM >>> 26) | 0, EM &= 67108863, H = Math.imul(oi, gi), q = Math.imul(oi, ni), q = q + Math.imul(At, gi) | 0, z = Math.imul(At, ni), H = H + Math.imul(St, yi) | 0, q = q + Math.imul(St, mi) | 0, q = q + Math.imul(ot, yi) | 0, z = z + Math.imul(ot, mi) | 0;
        var AM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (AM >>> 26) | 0, AM &= 67108863, H = Math.imul(oi, yi), q = Math.imul(oi, mi), q = q + Math.imul(At, yi) | 0, z = Math.imul(At, mi);
        var MM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        return $ = (z + (q >>> 13) | 0) + (MM >>> 26) | 0, MM &= 67108863, F[0] = sM, F[1] = uM, F[2] = fM, F[3] = hM, F[4] = cM, F[5] = lM, F[6] = dM, F[7] = pM, F[8] = yM, F[9] = mM, F[10] = gM, F[11] = bM, F[12] = vM, F[13] = wM, F[14] = _M, F[15] = SM, F[16] = EM, F[17] = AM, F[18] = MM, $ !== 0 && (F[19] = $, U.length++), U;
      };
      Math.imul || (ce = de);
      function be(A, I, U) {
        U.negative = I.negative ^ A.negative, U.length = A.length + I.length;
        for (var X = 0, Q = 0, F = 0; F < U.length - 1; F++) {
          var $ = Q;
          Q = 0;
          for (var H = X & 67108863, q = Math.min(F, I.length - 1), z = Math.max(0, F - A.length + 1); z <= q; z++) {
            var me = F - z, Ce = A.words[me] | 0, je = I.words[z] | 0, Re = Ce * je, Ae = Re & 67108863;
            $ = $ + (Re / 67108864 | 0) | 0, Ae = Ae + H | 0, H = Ae & 67108863, $ = $ + (Ae >>> 26) | 0, Q += $ >>> 26, $ &= 67108863;
          }
          U.words[F] = H, X = $, $ = Q;
        }
        return X !== 0 ? U.words[F] = X : U.length--, U._strip();
      }
      function ve(A, I, U) {
        return be(A, I, U);
      }
      g.prototype.mulTo = function(A, I) {
        var U, X = this.length + A.length;
        return this.length === 10 && A.length === 10 ? U = ce(this, A, I) : X < 63 ? U = de(this, A, I) : X < 1024 ? U = be(this, A, I) : U = ve(this, A, I), U;
      }, g.prototype.mul = function(A) {
        var I = new g(null);
        return I.words = new Array(this.length + A.length), this.mulTo(A, I);
      }, g.prototype.mulf = function(A) {
        var I = new g(null);
        return I.words = new Array(this.length + A.length), ve(this, A, I);
      }, g.prototype.imul = function(A) {
        return this.clone().mulTo(A, this);
      }, g.prototype.imuln = function(A) {
        var I = A < 0;
        I && (A = -A), o(typeof A == "number"), o(A < 67108864);
        for (var U = 0, X = 0; X < this.length; X++) {
          var Q = (this.words[X] | 0) * A, F = (Q & 67108863) + (U & 67108863);
          U >>= 26, U += Q / 67108864 | 0, U += F >>> 26, this.words[X] = F & 67108863;
        }
        return U !== 0 && (this.words[X] = U, this.length++), I ? this.ineg() : this;
      }, g.prototype.muln = function(A) {
        return this.clone().imuln(A);
      }, g.prototype.sqr = function() {
        return this.mul(this);
      }, g.prototype.isqr = function() {
        return this.imul(this.clone());
      }, g.prototype.pow = function(A) {
        var I = fe(A);
        if (I.length === 0)
          return new g(1);
        for (var U = this, X = 0; X < I.length && I[X] === 0; X++, U = U.sqr())
          ;
        if (++X < I.length)
          for (var Q = U.sqr(); X < I.length; X++, Q = Q.sqr())
            I[X] !== 0 && (U = U.mul(Q));
        return U;
      }, g.prototype.iushln = function(A) {
        o(typeof A == "number" && A >= 0);
        var I = A % 26, U = (A - I) / 26, X = 67108863 >>> 26 - I << 26 - I, Q;
        if (I !== 0) {
          var F = 0;
          for (Q = 0; Q < this.length; Q++) {
            var $ = this.words[Q] & X, H = (this.words[Q] | 0) - $ << I;
            this.words[Q] = H | F, F = $ >>> 26 - I;
          }
          F && (this.words[Q] = F, this.length++);
        }
        if (U !== 0) {
          for (Q = this.length - 1; Q >= 0; Q--)
            this.words[Q + U] = this.words[Q];
          for (Q = 0; Q < U; Q++)
            this.words[Q] = 0;
          this.length += U;
        }
        return this._strip();
      }, g.prototype.ishln = function(A) {
        return o(this.negative === 0), this.iushln(A);
      }, g.prototype.iushrn = function(A, I, U) {
        o(typeof A == "number" && A >= 0);
        var X;
        I ? X = (I - I % 26) / 26 : X = 0;
        var Q = A % 26, F = Math.min((A - Q) / 26, this.length), $ = 67108863 ^ 67108863 >>> Q << Q, H = U;
        if (X -= F, X = Math.max(0, X), H) {
          for (var q = 0; q < F; q++)
            H.words[q] = this.words[q];
          H.length = F;
        }
        if (F !== 0)
          if (this.length > F)
            for (this.length -= F, q = 0; q < this.length; q++)
              this.words[q] = this.words[q + F];
          else
            this.words[0] = 0, this.length = 1;
        var z = 0;
        for (q = this.length - 1; q >= 0 && (z !== 0 || q >= X); q--) {
          var me = this.words[q] | 0;
          this.words[q] = z << 26 - Q | me >>> Q, z = me & $;
        }
        return H && z !== 0 && (H.words[H.length++] = z), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, g.prototype.ishrn = function(A, I, U) {
        return o(this.negative === 0), this.iushrn(A, I, U);
      }, g.prototype.shln = function(A) {
        return this.clone().ishln(A);
      }, g.prototype.ushln = function(A) {
        return this.clone().iushln(A);
      }, g.prototype.shrn = function(A) {
        return this.clone().ishrn(A);
      }, g.prototype.ushrn = function(A) {
        return this.clone().iushrn(A);
      }, g.prototype.testn = function(A) {
        o(typeof A == "number" && A >= 0);
        var I = A % 26, U = (A - I) / 26, X = 1 << I;
        if (this.length <= U)
          return !1;
        var Q = this.words[U];
        return !!(Q & X);
      }, g.prototype.imaskn = function(A) {
        o(typeof A == "number" && A >= 0);
        var I = A % 26, U = (A - I) / 26;
        if (o(this.negative === 0, "imaskn works only with positive numbers"), this.length <= U)
          return this;
        if (I !== 0 && U++, this.length = Math.min(U, this.length), I !== 0) {
          var X = 67108863 ^ 67108863 >>> I << I;
          this.words[this.length - 1] &= X;
        }
        return this._strip();
      }, g.prototype.maskn = function(A) {
        return this.clone().imaskn(A);
      }, g.prototype.iaddn = function(A) {
        return o(typeof A == "number"), o(A < 67108864), A < 0 ? this.isubn(-A) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= A ? (this.words[0] = A - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(A), this.negative = 1, this) : this._iaddn(A);
      }, g.prototype._iaddn = function(A) {
        this.words[0] += A;
        for (var I = 0; I < this.length && this.words[I] >= 67108864; I++)
          this.words[I] -= 67108864, I === this.length - 1 ? this.words[I + 1] = 1 : this.words[I + 1]++;
        return this.length = Math.max(this.length, I + 1), this;
      }, g.prototype.isubn = function(A) {
        if (o(typeof A == "number"), o(A < 67108864), A < 0)
          return this.iaddn(-A);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(A), this.negative = 1, this;
        if (this.words[0] -= A, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var I = 0; I < this.length && this.words[I] < 0; I++)
            this.words[I] += 67108864, this.words[I + 1] -= 1;
        return this._strip();
      }, g.prototype.addn = function(A) {
        return this.clone().iaddn(A);
      }, g.prototype.subn = function(A) {
        return this.clone().isubn(A);
      }, g.prototype.iabs = function() {
        return this.negative = 0, this;
      }, g.prototype.abs = function() {
        return this.clone().iabs();
      }, g.prototype._ishlnsubmul = function(A, I, U) {
        var X = A.length + U, Q;
        this._expand(X);
        var F, $ = 0;
        for (Q = 0; Q < A.length; Q++) {
          F = (this.words[Q + U] | 0) + $;
          var H = (A.words[Q] | 0) * I;
          F -= H & 67108863, $ = (F >> 26) - (H / 67108864 | 0), this.words[Q + U] = F & 67108863;
        }
        for (; Q < this.length - U; Q++)
          F = (this.words[Q + U] | 0) + $, $ = F >> 26, this.words[Q + U] = F & 67108863;
        if ($ === 0)
          return this._strip();
        for (o($ === -1), $ = 0, Q = 0; Q < this.length; Q++)
          F = -(this.words[Q] | 0) + $, $ = F >> 26, this.words[Q] = F & 67108863;
        return this.negative = 1, this._strip();
      }, g.prototype._wordDiv = function(A, I) {
        var U = this.length - A.length, X = this.clone(), Q = A, F = Q.words[Q.length - 1] | 0, $ = this._countBits(F);
        U = 26 - $, U !== 0 && (Q = Q.ushln(U), X.iushln(U), F = Q.words[Q.length - 1] | 0);
        var H = X.length - Q.length, q;
        if (I !== "mod") {
          q = new g(null), q.length = H + 1, q.words = new Array(q.length);
          for (var z = 0; z < q.length; z++)
            q.words[z] = 0;
        }
        var me = X.clone()._ishlnsubmul(Q, 1, H);
        me.negative === 0 && (X = me, q && (q.words[H] = 1));
        for (var Ce = H - 1; Ce >= 0; Ce--) {
          var je = (X.words[Q.length + Ce] | 0) * 67108864 + (X.words[Q.length + Ce - 1] | 0);
          for (je = Math.min(je / F | 0, 67108863), X._ishlnsubmul(Q, je, Ce); X.negative !== 0; )
            je--, X.negative = 0, X._ishlnsubmul(Q, 1, Ce), X.isZero() || (X.negative ^= 1);
          q && (q.words[Ce] = je);
        }
        return q && q._strip(), X._strip(), I !== "div" && U !== 0 && X.iushrn(U), {
          div: q || null,
          mod: X
        };
      }, g.prototype.divmod = function(A, I, U) {
        if (o(!A.isZero()), this.isZero())
          return {
            div: new g(0),
            mod: new g(0)
          };
        var X, Q, F;
        return this.negative !== 0 && A.negative === 0 ? (F = this.neg().divmod(A, I), I !== "mod" && (X = F.div.neg()), I !== "div" && (Q = F.mod.neg(), U && Q.negative !== 0 && Q.iadd(A)), {
          div: X,
          mod: Q
        }) : this.negative === 0 && A.negative !== 0 ? (F = this.divmod(A.neg(), I), I !== "mod" && (X = F.div.neg()), {
          div: X,
          mod: F.mod
        }) : this.negative & A.negative ? (F = this.neg().divmod(A.neg(), I), I !== "div" && (Q = F.mod.neg(), U && Q.negative !== 0 && Q.isub(A)), {
          div: F.div,
          mod: Q
        }) : A.length > this.length || this.cmp(A) < 0 ? {
          div: new g(0),
          mod: this
        } : A.length === 1 ? I === "div" ? {
          div: this.divn(A.words[0]),
          mod: null
        } : I === "mod" ? {
          div: null,
          mod: new g(this.modrn(A.words[0]))
        } : {
          div: this.divn(A.words[0]),
          mod: new g(this.modrn(A.words[0]))
        } : this._wordDiv(A, I);
      }, g.prototype.div = function(A) {
        return this.divmod(A, "div", !1).div;
      }, g.prototype.mod = function(A) {
        return this.divmod(A, "mod", !1).mod;
      }, g.prototype.umod = function(A) {
        return this.divmod(A, "mod", !0).mod;
      }, g.prototype.divRound = function(A) {
        var I = this.divmod(A);
        if (I.mod.isZero())
          return I.div;
        var U = I.div.negative !== 0 ? I.mod.isub(A) : I.mod, X = A.ushrn(1), Q = A.andln(1), F = U.cmp(X);
        return F < 0 || Q === 1 && F === 0 ? I.div : I.div.negative !== 0 ? I.div.isubn(1) : I.div.iaddn(1);
      }, g.prototype.modrn = function(A) {
        var I = A < 0;
        I && (A = -A), o(A <= 67108863);
        for (var U = (1 << 26) % A, X = 0, Q = this.length - 1; Q >= 0; Q--)
          X = (U * X + (this.words[Q] | 0)) % A;
        return I ? -X : X;
      }, g.prototype.modn = function(A) {
        return this.modrn(A);
      }, g.prototype.idivn = function(A) {
        var I = A < 0;
        I && (A = -A), o(A <= 67108863);
        for (var U = 0, X = this.length - 1; X >= 0; X--) {
          var Q = (this.words[X] | 0) + U * 67108864;
          this.words[X] = Q / A | 0, U = Q % A;
        }
        return this._strip(), I ? this.ineg() : this;
      }, g.prototype.divn = function(A) {
        return this.clone().idivn(A);
      }, g.prototype.egcd = function(A) {
        o(A.negative === 0), o(!A.isZero());
        var I = this, U = A.clone();
        I.negative !== 0 ? I = I.umod(A) : I = I.clone();
        for (var X = new g(1), Q = new g(0), F = new g(0), $ = new g(1), H = 0; I.isEven() && U.isEven(); )
          I.iushrn(1), U.iushrn(1), ++H;
        for (var q = U.clone(), z = I.clone(); !I.isZero(); ) {
          for (var me = 0, Ce = 1; !(I.words[0] & Ce) && me < 26; ++me, Ce <<= 1)
            ;
          if (me > 0)
            for (I.iushrn(me); me-- > 0; )
              (X.isOdd() || Q.isOdd()) && (X.iadd(q), Q.isub(z)), X.iushrn(1), Q.iushrn(1);
          for (var je = 0, Re = 1; !(U.words[0] & Re) && je < 26; ++je, Re <<= 1)
            ;
          if (je > 0)
            for (U.iushrn(je); je-- > 0; )
              (F.isOdd() || $.isOdd()) && (F.iadd(q), $.isub(z)), F.iushrn(1), $.iushrn(1);
          I.cmp(U) >= 0 ? (I.isub(U), X.isub(F), Q.isub($)) : (U.isub(I), F.isub(X), $.isub(Q));
        }
        return {
          a: F,
          b: $,
          gcd: U.iushln(H)
        };
      }, g.prototype._invmp = function(A) {
        o(A.negative === 0), o(!A.isZero());
        var I = this, U = A.clone();
        I.negative !== 0 ? I = I.umod(A) : I = I.clone();
        for (var X = new g(1), Q = new g(0), F = U.clone(); I.cmpn(1) > 0 && U.cmpn(1) > 0; ) {
          for (var $ = 0, H = 1; !(I.words[0] & H) && $ < 26; ++$, H <<= 1)
            ;
          if ($ > 0)
            for (I.iushrn($); $-- > 0; )
              X.isOdd() && X.iadd(F), X.iushrn(1);
          for (var q = 0, z = 1; !(U.words[0] & z) && q < 26; ++q, z <<= 1)
            ;
          if (q > 0)
            for (U.iushrn(q); q-- > 0; )
              Q.isOdd() && Q.iadd(F), Q.iushrn(1);
          I.cmp(U) >= 0 ? (I.isub(U), X.isub(Q)) : (U.isub(I), Q.isub(X));
        }
        var me;
        return I.cmpn(1) === 0 ? me = X : me = Q, me.cmpn(0) < 0 && me.iadd(A), me;
      }, g.prototype.gcd = function(A) {
        if (this.isZero())
          return A.abs();
        if (A.isZero())
          return this.abs();
        var I = this.clone(), U = A.clone();
        I.negative = 0, U.negative = 0;
        for (var X = 0; I.isEven() && U.isEven(); X++)
          I.iushrn(1), U.iushrn(1);
        do {
          for (; I.isEven(); )
            I.iushrn(1);
          for (; U.isEven(); )
            U.iushrn(1);
          var Q = I.cmp(U);
          if (Q < 0) {
            var F = I;
            I = U, U = F;
          } else if (Q === 0 || U.cmpn(1) === 0)
            break;
          I.isub(U);
        } while (!0);
        return U.iushln(X);
      }, g.prototype.invm = function(A) {
        return this.egcd(A).a.umod(A);
      }, g.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, g.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, g.prototype.andln = function(A) {
        return this.words[0] & A;
      }, g.prototype.bincn = function(A) {
        o(typeof A == "number");
        var I = A % 26, U = (A - I) / 26, X = 1 << I;
        if (this.length <= U)
          return this._expand(U + 1), this.words[U] |= X, this;
        for (var Q = X, F = U; Q !== 0 && F < this.length; F++) {
          var $ = this.words[F] | 0;
          $ += Q, Q = $ >>> 26, $ &= 67108863, this.words[F] = $;
        }
        return Q !== 0 && (this.words[F] = Q, this.length++), this;
      }, g.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, g.prototype.cmpn = function(A) {
        var I = A < 0;
        if (this.negative !== 0 && !I)
          return -1;
        if (this.negative === 0 && I)
          return 1;
        this._strip();
        var U;
        if (this.length > 1)
          U = 1;
        else {
          I && (A = -A), o(A <= 67108863, "Number is too big");
          var X = this.words[0] | 0;
          U = X === A ? 0 : X < A ? -1 : 1;
        }
        return this.negative !== 0 ? -U | 0 : U;
      }, g.prototype.cmp = function(A) {
        if (this.negative !== 0 && A.negative === 0)
          return -1;
        if (this.negative === 0 && A.negative !== 0)
          return 1;
        var I = this.ucmp(A);
        return this.negative !== 0 ? -I | 0 : I;
      }, g.prototype.ucmp = function(A) {
        if (this.length > A.length)
          return 1;
        if (this.length < A.length)
          return -1;
        for (var I = 0, U = this.length - 1; U >= 0; U--) {
          var X = this.words[U] | 0, Q = A.words[U] | 0;
          if (X !== Q) {
            X < Q ? I = -1 : X > Q && (I = 1);
            break;
          }
        }
        return I;
      }, g.prototype.gtn = function(A) {
        return this.cmpn(A) === 1;
      }, g.prototype.gt = function(A) {
        return this.cmp(A) === 1;
      }, g.prototype.gten = function(A) {
        return this.cmpn(A) >= 0;
      }, g.prototype.gte = function(A) {
        return this.cmp(A) >= 0;
      }, g.prototype.ltn = function(A) {
        return this.cmpn(A) === -1;
      }, g.prototype.lt = function(A) {
        return this.cmp(A) === -1;
      }, g.prototype.lten = function(A) {
        return this.cmpn(A) <= 0;
      }, g.prototype.lte = function(A) {
        return this.cmp(A) <= 0;
      }, g.prototype.eqn = function(A) {
        return this.cmpn(A) === 0;
      }, g.prototype.eq = function(A) {
        return this.cmp(A) === 0;
      }, g.red = function(A) {
        return new J(A);
      }, g.prototype.toRed = function(A) {
        return o(!this.red, "Already a number in reduction context"), o(this.negative === 0, "red works only with positives"), A.convertTo(this)._forceRed(A);
      }, g.prototype.fromRed = function() {
        return o(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, g.prototype._forceRed = function(A) {
        return this.red = A, this;
      }, g.prototype.forceRed = function(A) {
        return o(!this.red, "Already a number in reduction context"), this._forceRed(A);
      }, g.prototype.redAdd = function(A) {
        return o(this.red, "redAdd works only with red numbers"), this.red.add(this, A);
      }, g.prototype.redIAdd = function(A) {
        return o(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, A);
      }, g.prototype.redSub = function(A) {
        return o(this.red, "redSub works only with red numbers"), this.red.sub(this, A);
      }, g.prototype.redISub = function(A) {
        return o(this.red, "redISub works only with red numbers"), this.red.isub(this, A);
      }, g.prototype.redShl = function(A) {
        return o(this.red, "redShl works only with red numbers"), this.red.shl(this, A);
      }, g.prototype.redMul = function(A) {
        return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, A), this.red.mul(this, A);
      }, g.prototype.redIMul = function(A) {
        return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, A), this.red.imul(this, A);
      }, g.prototype.redSqr = function() {
        return o(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, g.prototype.redISqr = function() {
        return o(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, g.prototype.redSqrt = function() {
        return o(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, g.prototype.redInvm = function() {
        return o(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, g.prototype.redNeg = function() {
        return o(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, g.prototype.redPow = function(A) {
        return o(this.red && !A.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, A);
      };
      var Pe = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function Ue(A, I) {
        this.name = A, this.p = new g(I, 16), this.n = this.p.bitLength(), this.k = new g(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      Ue.prototype._tmp = function() {
        var A = new g(null);
        return A.words = new Array(Math.ceil(this.n / 13)), A;
      }, Ue.prototype.ireduce = function(A) {
        var I = A, U;
        do
          this.split(I, this.tmp), I = this.imulK(I), I = I.iadd(this.tmp), U = I.bitLength();
        while (U > this.n);
        var X = U < this.n ? -1 : I.ucmp(this.p);
        return X === 0 ? (I.words[0] = 0, I.length = 1) : X > 0 ? I.isub(this.p) : I.strip !== void 0 ? I.strip() : I._strip(), I;
      }, Ue.prototype.split = function(A, I) {
        A.iushrn(this.n, 0, I);
      }, Ue.prototype.imulK = function(A) {
        return A.imul(this.k);
      };
      function ze() {
        Ue.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      S(ze, Ue), ze.prototype.split = function(A, I) {
        for (var U = 4194303, X = Math.min(A.length, 9), Q = 0; Q < X; Q++)
          I.words[Q] = A.words[Q];
        if (I.length = X, A.length <= 9) {
          A.words[0] = 0, A.length = 1;
          return;
        }
        var F = A.words[9];
        for (I.words[I.length++] = F & U, Q = 10; Q < A.length; Q++) {
          var $ = A.words[Q] | 0;
          A.words[Q - 10] = ($ & U) << 4 | F >>> 22, F = $;
        }
        F >>>= 22, A.words[Q - 10] = F, F === 0 && A.length > 10 ? A.length -= 10 : A.length -= 9;
      }, ze.prototype.imulK = function(A) {
        A.words[A.length] = 0, A.words[A.length + 1] = 0, A.length += 2;
        for (var I = 0, U = 0; U < A.length; U++) {
          var X = A.words[U] | 0;
          I += X * 977, A.words[U] = I & 67108863, I = X * 64 + (I / 67108864 | 0);
        }
        return A.words[A.length - 1] === 0 && (A.length--, A.words[A.length - 1] === 0 && A.length--), A;
      };
      function Le() {
        Ue.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      S(Le, Ue);
      function Ne() {
        Ue.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      S(Ne, Ue);
      function $e() {
        Ue.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      S($e, Ue), $e.prototype.imulK = function(A) {
        for (var I = 0, U = 0; U < A.length; U++) {
          var X = (A.words[U] | 0) * 19 + I, Q = X & 67108863;
          X >>>= 26, A.words[U] = Q, I = X;
        }
        return I !== 0 && (A.words[A.length++] = I), A;
      }, g._prime = function(A) {
        if (Pe[A])
          return Pe[A];
        var I;
        if (A === "k256")
          I = new ze();
        else if (A === "p224")
          I = new Le();
        else if (A === "p192")
          I = new Ne();
        else if (A === "p25519")
          I = new $e();
        else
          throw new Error("Unknown prime " + A);
        return Pe[A] = I, I;
      };
      function J(A) {
        if (typeof A == "string") {
          var I = g._prime(A);
          this.m = I.p, this.prime = I;
        } else
          o(A.gtn(1), "modulus must be greater than 1"), this.m = A, this.prime = null;
      }
      J.prototype._verify1 = function(A) {
        o(A.negative === 0, "red works only with positives"), o(A.red, "red works only with red numbers");
      }, J.prototype._verify2 = function(A, I) {
        o((A.negative | I.negative) === 0, "red works only with positives"), o(
          A.red && A.red === I.red,
          "red works only with red numbers"
        );
      }, J.prototype.imod = function(A) {
        return this.prime ? this.prime.ireduce(A)._forceRed(this) : (D(A, A.umod(this.m)._forceRed(this)), A);
      }, J.prototype.neg = function(A) {
        return A.isZero() ? A.clone() : this.m.sub(A)._forceRed(this);
      }, J.prototype.add = function(A, I) {
        this._verify2(A, I);
        var U = A.add(I);
        return U.cmp(this.m) >= 0 && U.isub(this.m), U._forceRed(this);
      }, J.prototype.iadd = function(A, I) {
        this._verify2(A, I);
        var U = A.iadd(I);
        return U.cmp(this.m) >= 0 && U.isub(this.m), U;
      }, J.prototype.sub = function(A, I) {
        this._verify2(A, I);
        var U = A.sub(I);
        return U.cmpn(0) < 0 && U.iadd(this.m), U._forceRed(this);
      }, J.prototype.isub = function(A, I) {
        this._verify2(A, I);
        var U = A.isub(I);
        return U.cmpn(0) < 0 && U.iadd(this.m), U;
      }, J.prototype.shl = function(A, I) {
        return this._verify1(A), this.imod(A.ushln(I));
      }, J.prototype.imul = function(A, I) {
        return this._verify2(A, I), this.imod(A.imul(I));
      }, J.prototype.mul = function(A, I) {
        return this._verify2(A, I), this.imod(A.mul(I));
      }, J.prototype.isqr = function(A) {
        return this.imul(A, A.clone());
      }, J.prototype.sqr = function(A) {
        return this.mul(A, A);
      }, J.prototype.sqrt = function(A) {
        if (A.isZero())
          return A.clone();
        var I = this.m.andln(3);
        if (o(I % 2 === 1), I === 3) {
          var U = this.m.add(new g(1)).iushrn(2);
          return this.pow(A, U);
        }
        for (var X = this.m.subn(1), Q = 0; !X.isZero() && X.andln(1) === 0; )
          Q++, X.iushrn(1);
        o(!X.isZero());
        var F = new g(1).toRed(this), $ = F.redNeg(), H = this.m.subn(1).iushrn(1), q = this.m.bitLength();
        for (q = new g(2 * q * q).toRed(this); this.pow(q, H).cmp($) !== 0; )
          q.redIAdd($);
        for (var z = this.pow(q, X), me = this.pow(A, X.addn(1).iushrn(1)), Ce = this.pow(A, X), je = Q; Ce.cmp(F) !== 0; ) {
          for (var Re = Ce, Ae = 0; Re.cmp(F) !== 0; Ae++)
            Re = Re.redSqr();
          o(Ae < je);
          var ke = this.pow(z, new g(1).iushln(je - Ae - 1));
          me = me.redMul(ke), z = ke.redSqr(), Ce = Ce.redMul(z), je = Ae;
        }
        return me;
      }, J.prototype.invm = function(A) {
        var I = A._invmp(this.m);
        return I.negative !== 0 ? (I.negative = 0, this.imod(I).redNeg()) : this.imod(I);
      }, J.prototype.pow = function(A, I) {
        if (I.isZero())
          return new g(1).toRed(this);
        if (I.cmpn(1) === 0)
          return A.clone();
        var U = 4, X = new Array(1 << U);
        X[0] = new g(1).toRed(this), X[1] = A;
        for (var Q = 2; Q < X.length; Q++)
          X[Q] = this.mul(X[Q - 1], A);
        var F = X[0], $ = 0, H = 0, q = I.bitLength() % 26;
        for (q === 0 && (q = 26), Q = I.length - 1; Q >= 0; Q--) {
          for (var z = I.words[Q], me = q - 1; me >= 0; me--) {
            var Ce = z >> me & 1;
            if (F !== X[0] && (F = this.sqr(F)), Ce === 0 && $ === 0) {
              H = 0;
              continue;
            }
            $ <<= 1, $ |= Ce, H++, !(H !== U && (Q !== 0 || me !== 0)) && (F = this.mul(F, X[$]), H = 0, $ = 0);
          }
          q = 26;
        }
        return F;
      }, J.prototype.convertTo = function(A) {
        var I = A.umod(this.m);
        return I === A ? I.clone() : I;
      }, J.prototype.convertFrom = function(A) {
        var I = A.clone();
        return I.red = null, I;
      }, g.mont = function(A) {
        return new ne(A);
      };
      function ne(A) {
        J.call(this, A), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new g(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      S(ne, J), ne.prototype.convertTo = function(A) {
        return this.imod(A.ushln(this.shift));
      }, ne.prototype.convertFrom = function(A) {
        var I = this.imod(A.mul(this.rinv));
        return I.red = null, I;
      }, ne.prototype.imul = function(A, I) {
        if (A.isZero() || I.isZero())
          return A.words[0] = 0, A.length = 1, A;
        var U = A.imul(I), X = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Q = U.isub(X).iushrn(this.shift), F = Q;
        return Q.cmp(this.m) >= 0 ? F = Q.isub(this.m) : Q.cmpn(0) < 0 && (F = Q.iadd(this.m)), F._forceRed(this);
      }, ne.prototype.mul = function(A, I) {
        if (A.isZero() || I.isZero())
          return new g(0)._forceRed(this);
        var U = A.mul(I), X = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Q = U.isub(X).iushrn(this.shift), F = Q;
        return Q.cmp(this.m) >= 0 ? F = Q.isub(this.m) : Q.cmpn(0) < 0 && (F = Q.iadd(this.m)), F._forceRed(this);
      }, ne.prototype.invm = function(A) {
        var I = this.imod(A._invmp(this.m).mul(this.r2));
        return I._forceRed(this);
      };
    })(e, commonjsGlobal);
  }(bn$1)), bn$1.exports;
}
var browserifyRsa, hasRequiredBrowserifyRsa;
function requireBrowserifyRsa() {
  if (hasRequiredBrowserifyRsa)
    return browserifyRsa;
  hasRequiredBrowserifyRsa = 1;
  var e = requireBn$1(), t = requireBrowser$b();
  function h(g) {
    var B = o(g), M = B.toRed(e.mont(g.modulus)).redPow(new e(g.publicExponent)).fromRed();
    return { blinder: M, unblinder: B.invm(g.modulus) };
  }
  function o(g) {
    var B = g.modulus.byteLength(), M;
    do
      M = new e(t(B));
    while (M.cmp(g.modulus) >= 0 || !M.umod(g.prime1) || !M.umod(g.prime2));
    return M;
  }
  function S(g, B) {
    var M = h(B), O = B.modulus.byteLength(), P = new e(g).mul(M.blinder).umod(B.modulus), D = P.toRed(e.mont(B.prime1)), Z = P.toRed(e.mont(B.prime2)), Y = B.coefficient, ee = B.prime1, ie = B.prime2, ue = D.redPow(B.exponent1).fromRed(), fe = Z.redPow(B.exponent2).fromRed(), de = ue.isub(fe).imul(Y).umod(ee).imul(ie);
    return fe.iadd(de).imul(M.unblinder).umod(B.modulus).toArrayLike(bufferExports.Buffer, "be", O);
  }
  return S.getr = o, browserifyRsa = S, browserifyRsa;
}
var elliptic = {};
const name = "elliptic", version = "6.5.5", description = "EC cryptography", main = "lib/elliptic.js", files = [
  "lib"
], scripts = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, repository = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, keywords = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], author = "Fedor Indutny <fedor@indutny.com>", license = "MIT", bugs = {
  url: "https://github.com/indutny/elliptic/issues"
}, homepage = "https://github.com/indutny/elliptic", devDependencies = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, dependencies = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, require$$0 = {
  name,
  version,
  description,
  main,
  files,
  scripts,
  repository,
  keywords,
  author,
  license,
  bugs,
  homepage,
  devDependencies,
  dependencies
};
var utils$2 = {}, utils$1 = {}, hasRequiredUtils$2;
function requireUtils$2() {
  return hasRequiredUtils$2 || (hasRequiredUtils$2 = 1, function(e) {
    var t = e;
    function h(g, B) {
      if (Array.isArray(g))
        return g.slice();
      if (!g)
        return [];
      var M = [];
      if (typeof g != "string") {
        for (var O = 0; O < g.length; O++)
          M[O] = g[O] | 0;
        return M;
      }
      if (B === "hex") {
        g = g.replace(/[^a-z0-9]+/ig, ""), g.length % 2 !== 0 && (g = "0" + g);
        for (var O = 0; O < g.length; O += 2)
          M.push(parseInt(g[O] + g[O + 1], 16));
      } else
        for (var O = 0; O < g.length; O++) {
          var P = g.charCodeAt(O), D = P >> 8, Z = P & 255;
          D ? M.push(D, Z) : M.push(Z);
        }
      return M;
    }
    t.toArray = h;
    function o(g) {
      return g.length === 1 ? "0" + g : g;
    }
    t.zero2 = o;
    function S(g) {
      for (var B = "", M = 0; M < g.length; M++)
        B += o(g[M].toString(16));
      return B;
    }
    t.toHex = S, t.encode = function(g, B) {
      return B === "hex" ? S(g) : g;
    };
  }(utils$1)), utils$1;
}
var hasRequiredUtils$1;
function requireUtils$1() {
  return hasRequiredUtils$1 || (hasRequiredUtils$1 = 1, function(e) {
    var t = e, h = requireBn$2(), o = requireMinimalisticAssert(), S = requireUtils$2();
    t.assert = o, t.toArray = S.toArray, t.zero2 = S.zero2, t.toHex = S.toHex, t.encode = S.encode;
    function g(D, Z, Y) {
      var ee = new Array(Math.max(D.bitLength(), Y) + 1), ie;
      for (ie = 0; ie < ee.length; ie += 1)
        ee[ie] = 0;
      var ue = 1 << Z + 1, fe = D.clone();
      for (ie = 0; ie < ee.length; ie++) {
        var de, ce = fe.andln(ue - 1);
        fe.isOdd() ? (ce > (ue >> 1) - 1 ? de = (ue >> 1) - ce : de = ce, fe.isubn(de)) : de = 0, ee[ie] = de, fe.iushrn(1);
      }
      return ee;
    }
    t.getNAF = g;
    function B(D, Z) {
      var Y = [
        [],
        []
      ];
      D = D.clone(), Z = Z.clone();
      for (var ee = 0, ie = 0, ue; D.cmpn(-ee) > 0 || Z.cmpn(-ie) > 0; ) {
        var fe = D.andln(3) + ee & 3, de = Z.andln(3) + ie & 3;
        fe === 3 && (fe = -1), de === 3 && (de = -1);
        var ce;
        fe & 1 ? (ue = D.andln(7) + ee & 7, (ue === 3 || ue === 5) && de === 2 ? ce = -fe : ce = fe) : ce = 0, Y[0].push(ce);
        var be;
        de & 1 ? (ue = Z.andln(7) + ie & 7, (ue === 3 || ue === 5) && fe === 2 ? be = -de : be = de) : be = 0, Y[1].push(be), 2 * ee === ce + 1 && (ee = 1 - ee), 2 * ie === be + 1 && (ie = 1 - ie), D.iushrn(1), Z.iushrn(1);
      }
      return Y;
    }
    t.getJSF = B;
    function M(D, Z, Y) {
      var ee = "_" + Z;
      D.prototype[Z] = function() {
        return this[ee] !== void 0 ? this[ee] : this[ee] = Y.call(this);
      };
    }
    t.cachedProperty = M;
    function O(D) {
      return typeof D == "string" ? t.toArray(D, "hex") : D;
    }
    t.parseBytes = O;
    function P(D) {
      return new h(D, "hex", "le");
    }
    t.intFromLE = P;
  }(utils$2)), utils$2;
}
var curve = {}, base$1, hasRequiredBase$1;
function requireBase$1() {
  if (hasRequiredBase$1)
    return base$1;
  hasRequiredBase$1 = 1;
  var e = requireBn$2(), t = requireUtils$1(), h = t.getNAF, o = t.getJSF, S = t.assert;
  function g(M, O) {
    this.type = M, this.p = new e(O.p, 16), this.red = O.prime ? e.red(O.prime) : e.mont(this.p), this.zero = new e(0).toRed(this.red), this.one = new e(1).toRed(this.red), this.two = new e(2).toRed(this.red), this.n = O.n && new e(O.n, 16), this.g = O.g && this.pointFromJSON(O.g, O.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
    var P = this.n && this.p.div(this.n);
    !P || P.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
  }
  base$1 = g, g.prototype.point = function() {
    throw new Error("Not implemented");
  }, g.prototype.validate = function() {
    throw new Error("Not implemented");
  }, g.prototype._fixedNafMul = function(M, O) {
    S(M.precomputed);
    var P = M._getDoubles(), D = h(O, 1, this._bitLength), Z = (1 << P.step + 1) - (P.step % 2 === 0 ? 2 : 1);
    Z /= 3;
    var Y = [], ee, ie;
    for (ee = 0; ee < D.length; ee += P.step) {
      ie = 0;
      for (var ue = ee + P.step - 1; ue >= ee; ue--)
        ie = (ie << 1) + D[ue];
      Y.push(ie);
    }
    for (var fe = this.jpoint(null, null, null), de = this.jpoint(null, null, null), ce = Z; ce > 0; ce--) {
      for (ee = 0; ee < Y.length; ee++)
        ie = Y[ee], ie === ce ? de = de.mixedAdd(P.points[ee]) : ie === -ce && (de = de.mixedAdd(P.points[ee].neg()));
      fe = fe.add(de);
    }
    return fe.toP();
  }, g.prototype._wnafMul = function(M, O) {
    var P = 4, D = M._getNAFPoints(P);
    P = D.wnd;
    for (var Z = D.points, Y = h(O, P, this._bitLength), ee = this.jpoint(null, null, null), ie = Y.length - 1; ie >= 0; ie--) {
      for (var ue = 0; ie >= 0 && Y[ie] === 0; ie--)
        ue++;
      if (ie >= 0 && ue++, ee = ee.dblp(ue), ie < 0)
        break;
      var fe = Y[ie];
      S(fe !== 0), M.type === "affine" ? fe > 0 ? ee = ee.mixedAdd(Z[fe - 1 >> 1]) : ee = ee.mixedAdd(Z[-fe - 1 >> 1].neg()) : fe > 0 ? ee = ee.add(Z[fe - 1 >> 1]) : ee = ee.add(Z[-fe - 1 >> 1].neg());
    }
    return M.type === "affine" ? ee.toP() : ee;
  }, g.prototype._wnafMulAdd = function(M, O, P, D, Z) {
    var Y = this._wnafT1, ee = this._wnafT2, ie = this._wnafT3, ue = 0, fe, de, ce;
    for (fe = 0; fe < D; fe++) {
      ce = O[fe];
      var be = ce._getNAFPoints(M);
      Y[fe] = be.wnd, ee[fe] = be.points;
    }
    for (fe = D - 1; fe >= 1; fe -= 2) {
      var ve = fe - 1, Pe = fe;
      if (Y[ve] !== 1 || Y[Pe] !== 1) {
        ie[ve] = h(P[ve], Y[ve], this._bitLength), ie[Pe] = h(P[Pe], Y[Pe], this._bitLength), ue = Math.max(ie[ve].length, ue), ue = Math.max(ie[Pe].length, ue);
        continue;
      }
      var Ue = [
        O[ve],
        /* 1 */
        null,
        /* 3 */
        null,
        /* 5 */
        O[Pe]
        /* 7 */
      ];
      O[ve].y.cmp(O[Pe].y) === 0 ? (Ue[1] = O[ve].add(O[Pe]), Ue[2] = O[ve].toJ().mixedAdd(O[Pe].neg())) : O[ve].y.cmp(O[Pe].y.redNeg()) === 0 ? (Ue[1] = O[ve].toJ().mixedAdd(O[Pe]), Ue[2] = O[ve].add(O[Pe].neg())) : (Ue[1] = O[ve].toJ().mixedAdd(O[Pe]), Ue[2] = O[ve].toJ().mixedAdd(O[Pe].neg()));
      var ze = [
        -3,
        /* -1 -1 */
        -1,
        /* -1 0 */
        -5,
        /* -1 1 */
        -7,
        /* 0 -1 */
        0,
        /* 0 0 */
        7,
        /* 0 1 */
        5,
        /* 1 -1 */
        1,
        /* 1 0 */
        3
        /* 1 1 */
      ], Le = o(P[ve], P[Pe]);
      for (ue = Math.max(Le[0].length, ue), ie[ve] = new Array(ue), ie[Pe] = new Array(ue), de = 0; de < ue; de++) {
        var Ne = Le[0][de] | 0, $e = Le[1][de] | 0;
        ie[ve][de] = ze[(Ne + 1) * 3 + ($e + 1)], ie[Pe][de] = 0, ee[ve] = Ue;
      }
    }
    var J = this.jpoint(null, null, null), ne = this._wnafT4;
    for (fe = ue; fe >= 0; fe--) {
      for (var A = 0; fe >= 0; ) {
        var I = !0;
        for (de = 0; de < D; de++)
          ne[de] = ie[de][fe] | 0, ne[de] !== 0 && (I = !1);
        if (!I)
          break;
        A++, fe--;
      }
      if (fe >= 0 && A++, J = J.dblp(A), fe < 0)
        break;
      for (de = 0; de < D; de++) {
        var U = ne[de];
        U !== 0 && (U > 0 ? ce = ee[de][U - 1 >> 1] : U < 0 && (ce = ee[de][-U - 1 >> 1].neg()), ce.type === "affine" ? J = J.mixedAdd(ce) : J = J.add(ce));
      }
    }
    for (fe = 0; fe < D; fe++)
      ee[fe] = null;
    return Z ? J : J.toP();
  };
  function B(M, O) {
    this.curve = M, this.type = O, this.precomputed = null;
  }
  return g.BasePoint = B, B.prototype.eq = function() {
    throw new Error("Not implemented");
  }, B.prototype.validate = function() {
    return this.curve.validate(this);
  }, g.prototype.decodePoint = function(M, O) {
    M = t.toArray(M, O);
    var P = this.p.byteLength();
    if ((M[0] === 4 || M[0] === 6 || M[0] === 7) && M.length - 1 === 2 * P) {
      M[0] === 6 ? S(M[M.length - 1] % 2 === 0) : M[0] === 7 && S(M[M.length - 1] % 2 === 1);
      var D = this.point(
        M.slice(1, 1 + P),
        M.slice(1 + P, 1 + 2 * P)
      );
      return D;
    } else if ((M[0] === 2 || M[0] === 3) && M.length - 1 === P)
      return this.pointFromX(M.slice(1, 1 + P), M[0] === 3);
    throw new Error("Unknown point format");
  }, B.prototype.encodeCompressed = function(M) {
    return this.encode(M, !0);
  }, B.prototype._encode = function(M) {
    var O = this.curve.p.byteLength(), P = this.getX().toArray("be", O);
    return M ? [this.getY().isEven() ? 2 : 3].concat(P) : [4].concat(P, this.getY().toArray("be", O));
  }, B.prototype.encode = function(M, O) {
    return t.encode(this._encode(O), M);
  }, B.prototype.precompute = function(M) {
    if (this.precomputed)
      return this;
    var O = {
      doubles: null,
      naf: null,
      beta: null
    };
    return O.naf = this._getNAFPoints(8), O.doubles = this._getDoubles(4, M), O.beta = this._getBeta(), this.precomputed = O, this;
  }, B.prototype._hasDoubles = function(M) {
    if (!this.precomputed)
      return !1;
    var O = this.precomputed.doubles;
    return O ? O.points.length >= Math.ceil((M.bitLength() + 1) / O.step) : !1;
  }, B.prototype._getDoubles = function(M, O) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    for (var P = [this], D = this, Z = 0; Z < O; Z += M) {
      for (var Y = 0; Y < M; Y++)
        D = D.dbl();
      P.push(D);
    }
    return {
      step: M,
      points: P
    };
  }, B.prototype._getNAFPoints = function(M) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    for (var O = [this], P = (1 << M) - 1, D = P === 1 ? null : this.dbl(), Z = 1; Z < P; Z++)
      O[Z] = O[Z - 1].add(D);
    return {
      wnd: M,
      points: O
    };
  }, B.prototype._getBeta = function() {
    return null;
  }, B.prototype.dblp = function(M) {
    for (var O = this, P = 0; P < M; P++)
      O = O.dbl();
    return O;
  }, base$1;
}
var short, hasRequiredShort;
function requireShort() {
  if (hasRequiredShort)
    return short;
  hasRequiredShort = 1;
  var e = requireUtils$1(), t = requireBn$2(), h = requireInherits_browser(), o = requireBase$1(), S = e.assert;
  function g(O) {
    o.call(this, "short", O), this.a = new t(O.a, 16).toRed(this.red), this.b = new t(O.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(O), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
  }
  h(g, o), short = g, g.prototype._getEndomorphism = function(O) {
    if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
      var P, D;
      if (O.beta)
        P = new t(O.beta, 16).toRed(this.red);
      else {
        var Z = this._getEndoRoots(this.p);
        P = Z[0].cmp(Z[1]) < 0 ? Z[0] : Z[1], P = P.toRed(this.red);
      }
      if (O.lambda)
        D = new t(O.lambda, 16);
      else {
        var Y = this._getEndoRoots(this.n);
        this.g.mul(Y[0]).x.cmp(this.g.x.redMul(P)) === 0 ? D = Y[0] : (D = Y[1], S(this.g.mul(D).x.cmp(this.g.x.redMul(P)) === 0));
      }
      var ee;
      return O.basis ? ee = O.basis.map(function(ie) {
        return {
          a: new t(ie.a, 16),
          b: new t(ie.b, 16)
        };
      }) : ee = this._getEndoBasis(D), {
        beta: P,
        lambda: D,
        basis: ee
      };
    }
  }, g.prototype._getEndoRoots = function(O) {
    var P = O === this.p ? this.red : t.mont(O), D = new t(2).toRed(P).redInvm(), Z = D.redNeg(), Y = new t(3).toRed(P).redNeg().redSqrt().redMul(D), ee = Z.redAdd(Y).fromRed(), ie = Z.redSub(Y).fromRed();
    return [ee, ie];
  }, g.prototype._getEndoBasis = function(O) {
    for (var P = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), D = O, Z = this.n.clone(), Y = new t(1), ee = new t(0), ie = new t(0), ue = new t(1), fe, de, ce, be, ve, Pe, Ue, ze = 0, Le, Ne; D.cmpn(0) !== 0; ) {
      var $e = Z.div(D);
      Le = Z.sub($e.mul(D)), Ne = ie.sub($e.mul(Y));
      var J = ue.sub($e.mul(ee));
      if (!ce && Le.cmp(P) < 0)
        fe = Ue.neg(), de = Y, ce = Le.neg(), be = Ne;
      else if (ce && ++ze === 2)
        break;
      Ue = Le, Z = D, D = Le, ie = Y, Y = Ne, ue = ee, ee = J;
    }
    ve = Le.neg(), Pe = Ne;
    var ne = ce.sqr().add(be.sqr()), A = ve.sqr().add(Pe.sqr());
    return A.cmp(ne) >= 0 && (ve = fe, Pe = de), ce.negative && (ce = ce.neg(), be = be.neg()), ve.negative && (ve = ve.neg(), Pe = Pe.neg()), [
      { a: ce, b: be },
      { a: ve, b: Pe }
    ];
  }, g.prototype._endoSplit = function(O) {
    var P = this.endo.basis, D = P[0], Z = P[1], Y = Z.b.mul(O).divRound(this.n), ee = D.b.neg().mul(O).divRound(this.n), ie = Y.mul(D.a), ue = ee.mul(Z.a), fe = Y.mul(D.b), de = ee.mul(Z.b), ce = O.sub(ie).sub(ue), be = fe.add(de).neg();
    return { k1: ce, k2: be };
  }, g.prototype.pointFromX = function(O, P) {
    O = new t(O, 16), O.red || (O = O.toRed(this.red));
    var D = O.redSqr().redMul(O).redIAdd(O.redMul(this.a)).redIAdd(this.b), Z = D.redSqrt();
    if (Z.redSqr().redSub(D).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var Y = Z.fromRed().isOdd();
    return (P && !Y || !P && Y) && (Z = Z.redNeg()), this.point(O, Z);
  }, g.prototype.validate = function(O) {
    if (O.inf)
      return !0;
    var P = O.x, D = O.y, Z = this.a.redMul(P), Y = P.redSqr().redMul(P).redIAdd(Z).redIAdd(this.b);
    return D.redSqr().redISub(Y).cmpn(0) === 0;
  }, g.prototype._endoWnafMulAdd = function(O, P, D) {
    for (var Z = this._endoWnafT1, Y = this._endoWnafT2, ee = 0; ee < O.length; ee++) {
      var ie = this._endoSplit(P[ee]), ue = O[ee], fe = ue._getBeta();
      ie.k1.negative && (ie.k1.ineg(), ue = ue.neg(!0)), ie.k2.negative && (ie.k2.ineg(), fe = fe.neg(!0)), Z[ee * 2] = ue, Z[ee * 2 + 1] = fe, Y[ee * 2] = ie.k1, Y[ee * 2 + 1] = ie.k2;
    }
    for (var de = this._wnafMulAdd(1, Z, Y, ee * 2, D), ce = 0; ce < ee * 2; ce++)
      Z[ce] = null, Y[ce] = null;
    return de;
  };
  function B(O, P, D, Z) {
    o.BasePoint.call(this, O, "affine"), P === null && D === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new t(P, 16), this.y = new t(D, 16), Z && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
  }
  h(B, o.BasePoint), g.prototype.point = function(O, P, D) {
    return new B(this, O, P, D);
  }, g.prototype.pointFromJSON = function(O, P) {
    return B.fromJSON(this, O, P);
  }, B.prototype._getBeta = function() {
    if (this.curve.endo) {
      var O = this.precomputed;
      if (O && O.beta)
        return O.beta;
      var P = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
      if (O) {
        var D = this.curve, Z = function(Y) {
          return D.point(Y.x.redMul(D.endo.beta), Y.y);
        };
        O.beta = P, P.precomputed = {
          beta: null,
          naf: O.naf && {
            wnd: O.naf.wnd,
            points: O.naf.points.map(Z)
          },
          doubles: O.doubles && {
            step: O.doubles.step,
            points: O.doubles.points.map(Z)
          }
        };
      }
      return P;
    }
  }, B.prototype.toJSON = function() {
    return this.precomputed ? [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }] : [this.x, this.y];
  }, B.fromJSON = function(O, P, D) {
    typeof P == "string" && (P = JSON.parse(P));
    var Z = O.point(P[0], P[1], D);
    if (!P[2])
      return Z;
    function Y(ie) {
      return O.point(ie[0], ie[1], D);
    }
    var ee = P[2];
    return Z.precomputed = {
      beta: null,
      doubles: ee.doubles && {
        step: ee.doubles.step,
        points: [Z].concat(ee.doubles.points.map(Y))
      },
      naf: ee.naf && {
        wnd: ee.naf.wnd,
        points: [Z].concat(ee.naf.points.map(Y))
      }
    }, Z;
  }, B.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  }, B.prototype.isInfinity = function() {
    return this.inf;
  }, B.prototype.add = function(O) {
    if (this.inf)
      return O;
    if (O.inf)
      return this;
    if (this.eq(O))
      return this.dbl();
    if (this.neg().eq(O))
      return this.curve.point(null, null);
    if (this.x.cmp(O.x) === 0)
      return this.curve.point(null, null);
    var P = this.y.redSub(O.y);
    P.cmpn(0) !== 0 && (P = P.redMul(this.x.redSub(O.x).redInvm()));
    var D = P.redSqr().redISub(this.x).redISub(O.x), Z = P.redMul(this.x.redSub(D)).redISub(this.y);
    return this.curve.point(D, Z);
  }, B.prototype.dbl = function() {
    if (this.inf)
      return this;
    var O = this.y.redAdd(this.y);
    if (O.cmpn(0) === 0)
      return this.curve.point(null, null);
    var P = this.curve.a, D = this.x.redSqr(), Z = O.redInvm(), Y = D.redAdd(D).redIAdd(D).redIAdd(P).redMul(Z), ee = Y.redSqr().redISub(this.x.redAdd(this.x)), ie = Y.redMul(this.x.redSub(ee)).redISub(this.y);
    return this.curve.point(ee, ie);
  }, B.prototype.getX = function() {
    return this.x.fromRed();
  }, B.prototype.getY = function() {
    return this.y.fromRed();
  }, B.prototype.mul = function(O) {
    return O = new t(O, 16), this.isInfinity() ? this : this._hasDoubles(O) ? this.curve._fixedNafMul(this, O) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [O]) : this.curve._wnafMul(this, O);
  }, B.prototype.mulAdd = function(O, P, D) {
    var Z = [this, P], Y = [O, D];
    return this.curve.endo ? this.curve._endoWnafMulAdd(Z, Y) : this.curve._wnafMulAdd(1, Z, Y, 2);
  }, B.prototype.jmulAdd = function(O, P, D) {
    var Z = [this, P], Y = [O, D];
    return this.curve.endo ? this.curve._endoWnafMulAdd(Z, Y, !0) : this.curve._wnafMulAdd(1, Z, Y, 2, !0);
  }, B.prototype.eq = function(O) {
    return this === O || this.inf === O.inf && (this.inf || this.x.cmp(O.x) === 0 && this.y.cmp(O.y) === 0);
  }, B.prototype.neg = function(O) {
    if (this.inf)
      return this;
    var P = this.curve.point(this.x, this.y.redNeg());
    if (O && this.precomputed) {
      var D = this.precomputed, Z = function(Y) {
        return Y.neg();
      };
      P.precomputed = {
        naf: D.naf && {
          wnd: D.naf.wnd,
          points: D.naf.points.map(Z)
        },
        doubles: D.doubles && {
          step: D.doubles.step,
          points: D.doubles.points.map(Z)
        }
      };
    }
    return P;
  }, B.prototype.toJ = function() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var O = this.curve.jpoint(this.x, this.y, this.curve.one);
    return O;
  };
  function M(O, P, D, Z) {
    o.BasePoint.call(this, O, "jacobian"), P === null && D === null && Z === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new t(0)) : (this.x = new t(P, 16), this.y = new t(D, 16), this.z = new t(Z, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
  }
  return h(M, o.BasePoint), g.prototype.jpoint = function(O, P, D) {
    return new M(this, O, P, D);
  }, M.prototype.toP = function() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var O = this.z.redInvm(), P = O.redSqr(), D = this.x.redMul(P), Z = this.y.redMul(P).redMul(O);
    return this.curve.point(D, Z);
  }, M.prototype.neg = function() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  }, M.prototype.add = function(O) {
    if (this.isInfinity())
      return O;
    if (O.isInfinity())
      return this;
    var P = O.z.redSqr(), D = this.z.redSqr(), Z = this.x.redMul(P), Y = O.x.redMul(D), ee = this.y.redMul(P.redMul(O.z)), ie = O.y.redMul(D.redMul(this.z)), ue = Z.redSub(Y), fe = ee.redSub(ie);
    if (ue.cmpn(0) === 0)
      return fe.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var de = ue.redSqr(), ce = de.redMul(ue), be = Z.redMul(de), ve = fe.redSqr().redIAdd(ce).redISub(be).redISub(be), Pe = fe.redMul(be.redISub(ve)).redISub(ee.redMul(ce)), Ue = this.z.redMul(O.z).redMul(ue);
    return this.curve.jpoint(ve, Pe, Ue);
  }, M.prototype.mixedAdd = function(O) {
    if (this.isInfinity())
      return O.toJ();
    if (O.isInfinity())
      return this;
    var P = this.z.redSqr(), D = this.x, Z = O.x.redMul(P), Y = this.y, ee = O.y.redMul(P).redMul(this.z), ie = D.redSub(Z), ue = Y.redSub(ee);
    if (ie.cmpn(0) === 0)
      return ue.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
    var fe = ie.redSqr(), de = fe.redMul(ie), ce = D.redMul(fe), be = ue.redSqr().redIAdd(de).redISub(ce).redISub(ce), ve = ue.redMul(ce.redISub(be)).redISub(Y.redMul(de)), Pe = this.z.redMul(ie);
    return this.curve.jpoint(be, ve, Pe);
  }, M.prototype.dblp = function(O) {
    if (O === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!O)
      return this.dbl();
    var P;
    if (this.curve.zeroA || this.curve.threeA) {
      var D = this;
      for (P = 0; P < O; P++)
        D = D.dbl();
      return D;
    }
    var Z = this.curve.a, Y = this.curve.tinv, ee = this.x, ie = this.y, ue = this.z, fe = ue.redSqr().redSqr(), de = ie.redAdd(ie);
    for (P = 0; P < O; P++) {
      var ce = ee.redSqr(), be = de.redSqr(), ve = be.redSqr(), Pe = ce.redAdd(ce).redIAdd(ce).redIAdd(Z.redMul(fe)), Ue = ee.redMul(be), ze = Pe.redSqr().redISub(Ue.redAdd(Ue)), Le = Ue.redISub(ze), Ne = Pe.redMul(Le);
      Ne = Ne.redIAdd(Ne).redISub(ve);
      var $e = de.redMul(ue);
      P + 1 < O && (fe = fe.redMul(ve)), ee = ze, ue = $e, de = Ne;
    }
    return this.curve.jpoint(ee, de.redMul(Y), ue);
  }, M.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
  }, M.prototype._zeroDbl = function() {
    var O, P, D;
    if (this.zOne) {
      var Z = this.x.redSqr(), Y = this.y.redSqr(), ee = Y.redSqr(), ie = this.x.redAdd(Y).redSqr().redISub(Z).redISub(ee);
      ie = ie.redIAdd(ie);
      var ue = Z.redAdd(Z).redIAdd(Z), fe = ue.redSqr().redISub(ie).redISub(ie), de = ee.redIAdd(ee);
      de = de.redIAdd(de), de = de.redIAdd(de), O = fe, P = ue.redMul(ie.redISub(fe)).redISub(de), D = this.y.redAdd(this.y);
    } else {
      var ce = this.x.redSqr(), be = this.y.redSqr(), ve = be.redSqr(), Pe = this.x.redAdd(be).redSqr().redISub(ce).redISub(ve);
      Pe = Pe.redIAdd(Pe);
      var Ue = ce.redAdd(ce).redIAdd(ce), ze = Ue.redSqr(), Le = ve.redIAdd(ve);
      Le = Le.redIAdd(Le), Le = Le.redIAdd(Le), O = ze.redISub(Pe).redISub(Pe), P = Ue.redMul(Pe.redISub(O)).redISub(Le), D = this.y.redMul(this.z), D = D.redIAdd(D);
    }
    return this.curve.jpoint(O, P, D);
  }, M.prototype._threeDbl = function() {
    var O, P, D;
    if (this.zOne) {
      var Z = this.x.redSqr(), Y = this.y.redSqr(), ee = Y.redSqr(), ie = this.x.redAdd(Y).redSqr().redISub(Z).redISub(ee);
      ie = ie.redIAdd(ie);
      var ue = Z.redAdd(Z).redIAdd(Z).redIAdd(this.curve.a), fe = ue.redSqr().redISub(ie).redISub(ie);
      O = fe;
      var de = ee.redIAdd(ee);
      de = de.redIAdd(de), de = de.redIAdd(de), P = ue.redMul(ie.redISub(fe)).redISub(de), D = this.y.redAdd(this.y);
    } else {
      var ce = this.z.redSqr(), be = this.y.redSqr(), ve = this.x.redMul(be), Pe = this.x.redSub(ce).redMul(this.x.redAdd(ce));
      Pe = Pe.redAdd(Pe).redIAdd(Pe);
      var Ue = ve.redIAdd(ve);
      Ue = Ue.redIAdd(Ue);
      var ze = Ue.redAdd(Ue);
      O = Pe.redSqr().redISub(ze), D = this.y.redAdd(this.z).redSqr().redISub(be).redISub(ce);
      var Le = be.redSqr();
      Le = Le.redIAdd(Le), Le = Le.redIAdd(Le), Le = Le.redIAdd(Le), P = Pe.redMul(Ue.redISub(O)).redISub(Le);
    }
    return this.curve.jpoint(O, P, D);
  }, M.prototype._dbl = function() {
    var O = this.curve.a, P = this.x, D = this.y, Z = this.z, Y = Z.redSqr().redSqr(), ee = P.redSqr(), ie = D.redSqr(), ue = ee.redAdd(ee).redIAdd(ee).redIAdd(O.redMul(Y)), fe = P.redAdd(P);
    fe = fe.redIAdd(fe);
    var de = fe.redMul(ie), ce = ue.redSqr().redISub(de.redAdd(de)), be = de.redISub(ce), ve = ie.redSqr();
    ve = ve.redIAdd(ve), ve = ve.redIAdd(ve), ve = ve.redIAdd(ve);
    var Pe = ue.redMul(be).redISub(ve), Ue = D.redAdd(D).redMul(Z);
    return this.curve.jpoint(ce, Pe, Ue);
  }, M.prototype.trpl = function() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var O = this.x.redSqr(), P = this.y.redSqr(), D = this.z.redSqr(), Z = P.redSqr(), Y = O.redAdd(O).redIAdd(O), ee = Y.redSqr(), ie = this.x.redAdd(P).redSqr().redISub(O).redISub(Z);
    ie = ie.redIAdd(ie), ie = ie.redAdd(ie).redIAdd(ie), ie = ie.redISub(ee);
    var ue = ie.redSqr(), fe = Z.redIAdd(Z);
    fe = fe.redIAdd(fe), fe = fe.redIAdd(fe), fe = fe.redIAdd(fe);
    var de = Y.redIAdd(ie).redSqr().redISub(ee).redISub(ue).redISub(fe), ce = P.redMul(de);
    ce = ce.redIAdd(ce), ce = ce.redIAdd(ce);
    var be = this.x.redMul(ue).redISub(ce);
    be = be.redIAdd(be), be = be.redIAdd(be);
    var ve = this.y.redMul(de.redMul(fe.redISub(de)).redISub(ie.redMul(ue)));
    ve = ve.redIAdd(ve), ve = ve.redIAdd(ve), ve = ve.redIAdd(ve);
    var Pe = this.z.redAdd(ie).redSqr().redISub(D).redISub(ue);
    return this.curve.jpoint(be, ve, Pe);
  }, M.prototype.mul = function(O, P) {
    return O = new t(O, P), this.curve._wnafMul(this, O);
  }, M.prototype.eq = function(O) {
    if (O.type === "affine")
      return this.eq(O.toJ());
    if (this === O)
      return !0;
    var P = this.z.redSqr(), D = O.z.redSqr();
    if (this.x.redMul(D).redISub(O.x.redMul(P)).cmpn(0) !== 0)
      return !1;
    var Z = P.redMul(this.z), Y = D.redMul(O.z);
    return this.y.redMul(Y).redISub(O.y.redMul(Z)).cmpn(0) === 0;
  }, M.prototype.eqXToP = function(O) {
    var P = this.z.redSqr(), D = O.toRed(this.curve.red).redMul(P);
    if (this.x.cmp(D) === 0)
      return !0;
    for (var Z = O.clone(), Y = this.curve.redN.redMul(P); ; ) {
      if (Z.iadd(this.curve.n), Z.cmp(this.curve.p) >= 0)
        return !1;
      if (D.redIAdd(Y), this.x.cmp(D) === 0)
        return !0;
    }
  }, M.prototype.inspect = function() {
    return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  }, M.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, short;
}
var mont, hasRequiredMont;
function requireMont() {
  if (hasRequiredMont)
    return mont;
  hasRequiredMont = 1;
  var e = requireBn$2(), t = requireInherits_browser(), h = requireBase$1(), o = requireUtils$1();
  function S(B) {
    h.call(this, "mont", B), this.a = new e(B.a, 16).toRed(this.red), this.b = new e(B.b, 16).toRed(this.red), this.i4 = new e(4).toRed(this.red).redInvm(), this.two = new e(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  t(S, h), mont = S, S.prototype.validate = function(B) {
    var M = B.normalize().x, O = M.redSqr(), P = O.redMul(M).redAdd(O.redMul(this.a)).redAdd(M), D = P.redSqrt();
    return D.redSqr().cmp(P) === 0;
  };
  function g(B, M, O) {
    h.BasePoint.call(this, B, "projective"), M === null && O === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new e(M, 16), this.z = new e(O, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
  }
  return t(g, h.BasePoint), S.prototype.decodePoint = function(B, M) {
    return this.point(o.toArray(B, M), 1);
  }, S.prototype.point = function(B, M) {
    return new g(this, B, M);
  }, S.prototype.pointFromJSON = function(B) {
    return g.fromJSON(this, B);
  }, g.prototype.precompute = function() {
  }, g.prototype._encode = function() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  }, g.fromJSON = function(B, M) {
    return new g(B, M[0], M[1] || B.one);
  }, g.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, g.prototype.isInfinity = function() {
    return this.z.cmpn(0) === 0;
  }, g.prototype.dbl = function() {
    var B = this.x.redAdd(this.z), M = B.redSqr(), O = this.x.redSub(this.z), P = O.redSqr(), D = M.redSub(P), Z = M.redMul(P), Y = D.redMul(P.redAdd(this.curve.a24.redMul(D)));
    return this.curve.point(Z, Y);
  }, g.prototype.add = function() {
    throw new Error("Not supported on Montgomery curve");
  }, g.prototype.diffAdd = function(B, M) {
    var O = this.x.redAdd(this.z), P = this.x.redSub(this.z), D = B.x.redAdd(B.z), Z = B.x.redSub(B.z), Y = Z.redMul(O), ee = D.redMul(P), ie = M.z.redMul(Y.redAdd(ee).redSqr()), ue = M.x.redMul(Y.redISub(ee).redSqr());
    return this.curve.point(ie, ue);
  }, g.prototype.mul = function(B) {
    for (var M = B.clone(), O = this, P = this.curve.point(null, null), D = this, Z = []; M.cmpn(0) !== 0; M.iushrn(1))
      Z.push(M.andln(1));
    for (var Y = Z.length - 1; Y >= 0; Y--)
      Z[Y] === 0 ? (O = O.diffAdd(P, D), P = P.dbl()) : (P = O.diffAdd(P, D), O = O.dbl());
    return P;
  }, g.prototype.mulAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, g.prototype.jumlAdd = function() {
    throw new Error("Not supported on Montgomery curve");
  }, g.prototype.eq = function(B) {
    return this.getX().cmp(B.getX()) === 0;
  }, g.prototype.normalize = function() {
    return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
  }, g.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, mont;
}
var edwards, hasRequiredEdwards;
function requireEdwards() {
  if (hasRequiredEdwards)
    return edwards;
  hasRequiredEdwards = 1;
  var e = requireUtils$1(), t = requireBn$2(), h = requireInherits_browser(), o = requireBase$1(), S = e.assert;
  function g(M) {
    this.twisted = (M.a | 0) !== 1, this.mOneA = this.twisted && (M.a | 0) === -1, this.extended = this.mOneA, o.call(this, "edwards", M), this.a = new t(M.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new t(M.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new t(M.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), S(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (M.c | 0) === 1;
  }
  h(g, o), edwards = g, g.prototype._mulA = function(M) {
    return this.mOneA ? M.redNeg() : this.a.redMul(M);
  }, g.prototype._mulC = function(M) {
    return this.oneC ? M : this.c.redMul(M);
  }, g.prototype.jpoint = function(M, O, P, D) {
    return this.point(M, O, P, D);
  }, g.prototype.pointFromX = function(M, O) {
    M = new t(M, 16), M.red || (M = M.toRed(this.red));
    var P = M.redSqr(), D = this.c2.redSub(this.a.redMul(P)), Z = this.one.redSub(this.c2.redMul(this.d).redMul(P)), Y = D.redMul(Z.redInvm()), ee = Y.redSqrt();
    if (ee.redSqr().redSub(Y).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var ie = ee.fromRed().isOdd();
    return (O && !ie || !O && ie) && (ee = ee.redNeg()), this.point(M, ee);
  }, g.prototype.pointFromY = function(M, O) {
    M = new t(M, 16), M.red || (M = M.toRed(this.red));
    var P = M.redSqr(), D = P.redSub(this.c2), Z = P.redMul(this.d).redMul(this.c2).redSub(this.a), Y = D.redMul(Z.redInvm());
    if (Y.cmp(this.zero) === 0) {
      if (O)
        throw new Error("invalid point");
      return this.point(this.zero, M);
    }
    var ee = Y.redSqrt();
    if (ee.redSqr().redSub(Y).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    return ee.fromRed().isOdd() !== O && (ee = ee.redNeg()), this.point(ee, M);
  }, g.prototype.validate = function(M) {
    if (M.isInfinity())
      return !0;
    M.normalize();
    var O = M.x.redSqr(), P = M.y.redSqr(), D = O.redMul(this.a).redAdd(P), Z = this.c2.redMul(this.one.redAdd(this.d.redMul(O).redMul(P)));
    return D.cmp(Z) === 0;
  };
  function B(M, O, P, D, Z) {
    o.BasePoint.call(this, M, "projective"), O === null && P === null && D === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new t(O, 16), this.y = new t(P, 16), this.z = D ? new t(D, 16) : this.curve.one, this.t = Z && new t(Z, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
  }
  return h(B, o.BasePoint), g.prototype.pointFromJSON = function(M) {
    return B.fromJSON(this, M);
  }, g.prototype.point = function(M, O, P, D) {
    return new B(this, M, O, P, D);
  }, B.fromJSON = function(M, O) {
    return new B(M, O[0], O[1], O[2]);
  }, B.prototype.inspect = function() {
    return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  }, B.prototype.isInfinity = function() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  }, B.prototype._extDbl = function() {
    var M = this.x.redSqr(), O = this.y.redSqr(), P = this.z.redSqr();
    P = P.redIAdd(P);
    var D = this.curve._mulA(M), Z = this.x.redAdd(this.y).redSqr().redISub(M).redISub(O), Y = D.redAdd(O), ee = Y.redSub(P), ie = D.redSub(O), ue = Z.redMul(ee), fe = Y.redMul(ie), de = Z.redMul(ie), ce = ee.redMul(Y);
    return this.curve.point(ue, fe, ce, de);
  }, B.prototype._projDbl = function() {
    var M = this.x.redAdd(this.y).redSqr(), O = this.x.redSqr(), P = this.y.redSqr(), D, Z, Y, ee, ie, ue;
    if (this.curve.twisted) {
      ee = this.curve._mulA(O);
      var fe = ee.redAdd(P);
      this.zOne ? (D = M.redSub(O).redSub(P).redMul(fe.redSub(this.curve.two)), Z = fe.redMul(ee.redSub(P)), Y = fe.redSqr().redSub(fe).redSub(fe)) : (ie = this.z.redSqr(), ue = fe.redSub(ie).redISub(ie), D = M.redSub(O).redISub(P).redMul(ue), Z = fe.redMul(ee.redSub(P)), Y = fe.redMul(ue));
    } else
      ee = O.redAdd(P), ie = this.curve._mulC(this.z).redSqr(), ue = ee.redSub(ie).redSub(ie), D = this.curve._mulC(M.redISub(ee)).redMul(ue), Z = this.curve._mulC(ee).redMul(O.redISub(P)), Y = ee.redMul(ue);
    return this.curve.point(D, Z, Y);
  }, B.prototype.dbl = function() {
    return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
  }, B.prototype._extAdd = function(M) {
    var O = this.y.redSub(this.x).redMul(M.y.redSub(M.x)), P = this.y.redAdd(this.x).redMul(M.y.redAdd(M.x)), D = this.t.redMul(this.curve.dd).redMul(M.t), Z = this.z.redMul(M.z.redAdd(M.z)), Y = P.redSub(O), ee = Z.redSub(D), ie = Z.redAdd(D), ue = P.redAdd(O), fe = Y.redMul(ee), de = ie.redMul(ue), ce = Y.redMul(ue), be = ee.redMul(ie);
    return this.curve.point(fe, de, be, ce);
  }, B.prototype._projAdd = function(M) {
    var O = this.z.redMul(M.z), P = O.redSqr(), D = this.x.redMul(M.x), Z = this.y.redMul(M.y), Y = this.curve.d.redMul(D).redMul(Z), ee = P.redSub(Y), ie = P.redAdd(Y), ue = this.x.redAdd(this.y).redMul(M.x.redAdd(M.y)).redISub(D).redISub(Z), fe = O.redMul(ee).redMul(ue), de, ce;
    return this.curve.twisted ? (de = O.redMul(ie).redMul(Z.redSub(this.curve._mulA(D))), ce = ee.redMul(ie)) : (de = O.redMul(ie).redMul(Z.redSub(D)), ce = this.curve._mulC(ee).redMul(ie)), this.curve.point(fe, de, ce);
  }, B.prototype.add = function(M) {
    return this.isInfinity() ? M : M.isInfinity() ? this : this.curve.extended ? this._extAdd(M) : this._projAdd(M);
  }, B.prototype.mul = function(M) {
    return this._hasDoubles(M) ? this.curve._fixedNafMul(this, M) : this.curve._wnafMul(this, M);
  }, B.prototype.mulAdd = function(M, O, P) {
    return this.curve._wnafMulAdd(1, [this, O], [M, P], 2, !1);
  }, B.prototype.jmulAdd = function(M, O, P) {
    return this.curve._wnafMulAdd(1, [this, O], [M, P], 2, !0);
  }, B.prototype.normalize = function() {
    if (this.zOne)
      return this;
    var M = this.z.redInvm();
    return this.x = this.x.redMul(M), this.y = this.y.redMul(M), this.t && (this.t = this.t.redMul(M)), this.z = this.curve.one, this.zOne = !0, this;
  }, B.prototype.neg = function() {
    return this.curve.point(
      this.x.redNeg(),
      this.y,
      this.z,
      this.t && this.t.redNeg()
    );
  }, B.prototype.getX = function() {
    return this.normalize(), this.x.fromRed();
  }, B.prototype.getY = function() {
    return this.normalize(), this.y.fromRed();
  }, B.prototype.eq = function(M) {
    return this === M || this.getX().cmp(M.getX()) === 0 && this.getY().cmp(M.getY()) === 0;
  }, B.prototype.eqXToP = function(M) {
    var O = M.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(O) === 0)
      return !0;
    for (var P = M.clone(), D = this.curve.redN.redMul(this.z); ; ) {
      if (P.iadd(this.curve.n), P.cmp(this.curve.p) >= 0)
        return !1;
      if (O.redIAdd(D), this.x.cmp(O) === 0)
        return !0;
    }
  }, B.prototype.toP = B.prototype.normalize, B.prototype.mixedAdd = B.prototype.add, edwards;
}
var hasRequiredCurve;
function requireCurve() {
  return hasRequiredCurve || (hasRequiredCurve = 1, function(e) {
    var t = e;
    t.base = requireBase$1(), t.short = requireShort(), t.mont = requireMont(), t.edwards = requireEdwards();
  }(curve)), curve;
}
var curves = {}, hash = {}, utils = {}, hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils)
    return utils;
  hasRequiredUtils = 1;
  var e = requireMinimalisticAssert(), t = requireInherits_browser();
  utils.inherits = t;
  function h(ne, A) {
    return (ne.charCodeAt(A) & 64512) !== 55296 || A < 0 || A + 1 >= ne.length ? !1 : (ne.charCodeAt(A + 1) & 64512) === 56320;
  }
  function o(ne, A) {
    if (Array.isArray(ne))
      return ne.slice();
    if (!ne)
      return [];
    var I = [];
    if (typeof ne == "string")
      if (A) {
        if (A === "hex")
          for (ne = ne.replace(/[^a-z0-9]+/ig, ""), ne.length % 2 !== 0 && (ne = "0" + ne), X = 0; X < ne.length; X += 2)
            I.push(parseInt(ne[X] + ne[X + 1], 16));
      } else
        for (var U = 0, X = 0; X < ne.length; X++) {
          var Q = ne.charCodeAt(X);
          Q < 128 ? I[U++] = Q : Q < 2048 ? (I[U++] = Q >> 6 | 192, I[U++] = Q & 63 | 128) : h(ne, X) ? (Q = 65536 + ((Q & 1023) << 10) + (ne.charCodeAt(++X) & 1023), I[U++] = Q >> 18 | 240, I[U++] = Q >> 12 & 63 | 128, I[U++] = Q >> 6 & 63 | 128, I[U++] = Q & 63 | 128) : (I[U++] = Q >> 12 | 224, I[U++] = Q >> 6 & 63 | 128, I[U++] = Q & 63 | 128);
        }
    else
      for (X = 0; X < ne.length; X++)
        I[X] = ne[X] | 0;
    return I;
  }
  utils.toArray = o;
  function S(ne) {
    for (var A = "", I = 0; I < ne.length; I++)
      A += M(ne[I].toString(16));
    return A;
  }
  utils.toHex = S;
  function g(ne) {
    var A = ne >>> 24 | ne >>> 8 & 65280 | ne << 8 & 16711680 | (ne & 255) << 24;
    return A >>> 0;
  }
  utils.htonl = g;
  function B(ne, A) {
    for (var I = "", U = 0; U < ne.length; U++) {
      var X = ne[U];
      A === "little" && (X = g(X)), I += O(X.toString(16));
    }
    return I;
  }
  utils.toHex32 = B;
  function M(ne) {
    return ne.length === 1 ? "0" + ne : ne;
  }
  utils.zero2 = M;
  function O(ne) {
    return ne.length === 7 ? "0" + ne : ne.length === 6 ? "00" + ne : ne.length === 5 ? "000" + ne : ne.length === 4 ? "0000" + ne : ne.length === 3 ? "00000" + ne : ne.length === 2 ? "000000" + ne : ne.length === 1 ? "0000000" + ne : ne;
  }
  utils.zero8 = O;
  function P(ne, A, I, U) {
    var X = I - A;
    e(X % 4 === 0);
    for (var Q = new Array(X / 4), F = 0, $ = A; F < Q.length; F++, $ += 4) {
      var H;
      U === "big" ? H = ne[$] << 24 | ne[$ + 1] << 16 | ne[$ + 2] << 8 | ne[$ + 3] : H = ne[$ + 3] << 24 | ne[$ + 2] << 16 | ne[$ + 1] << 8 | ne[$], Q[F] = H >>> 0;
    }
    return Q;
  }
  utils.join32 = P;
  function D(ne, A) {
    for (var I = new Array(ne.length * 4), U = 0, X = 0; U < ne.length; U++, X += 4) {
      var Q = ne[U];
      A === "big" ? (I[X] = Q >>> 24, I[X + 1] = Q >>> 16 & 255, I[X + 2] = Q >>> 8 & 255, I[X + 3] = Q & 255) : (I[X + 3] = Q >>> 24, I[X + 2] = Q >>> 16 & 255, I[X + 1] = Q >>> 8 & 255, I[X] = Q & 255);
    }
    return I;
  }
  utils.split32 = D;
  function Z(ne, A) {
    return ne >>> A | ne << 32 - A;
  }
  utils.rotr32 = Z;
  function Y(ne, A) {
    return ne << A | ne >>> 32 - A;
  }
  utils.rotl32 = Y;
  function ee(ne, A) {
    return ne + A >>> 0;
  }
  utils.sum32 = ee;
  function ie(ne, A, I) {
    return ne + A + I >>> 0;
  }
  utils.sum32_3 = ie;
  function ue(ne, A, I, U) {
    return ne + A + I + U >>> 0;
  }
  utils.sum32_4 = ue;
  function fe(ne, A, I, U, X) {
    return ne + A + I + U + X >>> 0;
  }
  utils.sum32_5 = fe;
  function de(ne, A, I, U) {
    var X = ne[A], Q = ne[A + 1], F = U + Q >>> 0, $ = (F < U ? 1 : 0) + I + X;
    ne[A] = $ >>> 0, ne[A + 1] = F;
  }
  utils.sum64 = de;
  function ce(ne, A, I, U) {
    var X = A + U >>> 0, Q = (X < A ? 1 : 0) + ne + I;
    return Q >>> 0;
  }
  utils.sum64_hi = ce;
  function be(ne, A, I, U) {
    var X = A + U;
    return X >>> 0;
  }
  utils.sum64_lo = be;
  function ve(ne, A, I, U, X, Q, F, $) {
    var H = 0, q = A;
    q = q + U >>> 0, H += q < A ? 1 : 0, q = q + Q >>> 0, H += q < Q ? 1 : 0, q = q + $ >>> 0, H += q < $ ? 1 : 0;
    var z = ne + I + X + F + H;
    return z >>> 0;
  }
  utils.sum64_4_hi = ve;
  function Pe(ne, A, I, U, X, Q, F, $) {
    var H = A + U + Q + $;
    return H >>> 0;
  }
  utils.sum64_4_lo = Pe;
  function Ue(ne, A, I, U, X, Q, F, $, H, q) {
    var z = 0, me = A;
    me = me + U >>> 0, z += me < A ? 1 : 0, me = me + Q >>> 0, z += me < Q ? 1 : 0, me = me + $ >>> 0, z += me < $ ? 1 : 0, me = me + q >>> 0, z += me < q ? 1 : 0;
    var Ce = ne + I + X + F + H + z;
    return Ce >>> 0;
  }
  utils.sum64_5_hi = Ue;
  function ze(ne, A, I, U, X, Q, F, $, H, q) {
    var z = A + U + Q + $ + q;
    return z >>> 0;
  }
  utils.sum64_5_lo = ze;
  function Le(ne, A, I) {
    var U = A << 32 - I | ne >>> I;
    return U >>> 0;
  }
  utils.rotr64_hi = Le;
  function Ne(ne, A, I) {
    var U = ne << 32 - I | A >>> I;
    return U >>> 0;
  }
  utils.rotr64_lo = Ne;
  function $e(ne, A, I) {
    return ne >>> I;
  }
  utils.shr64_hi = $e;
  function J(ne, A, I) {
    var U = ne << 32 - I | A >>> I;
    return U >>> 0;
  }
  return utils.shr64_lo = J, utils;
}
var common$1 = {}, hasRequiredCommon$1;
function requireCommon$1() {
  if (hasRequiredCommon$1)
    return common$1;
  hasRequiredCommon$1 = 1;
  var e = requireUtils(), t = requireMinimalisticAssert();
  function h() {
    this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
  }
  return common$1.BlockHash = h, h.prototype.update = function(o, S) {
    if (o = e.toArray(o, S), this.pending ? this.pending = this.pending.concat(o) : this.pending = o, this.pendingTotal += o.length, this.pending.length >= this._delta8) {
      o = this.pending;
      var g = o.length % this._delta8;
      this.pending = o.slice(o.length - g, o.length), this.pending.length === 0 && (this.pending = null), o = e.join32(o, 0, o.length - g, this.endian);
      for (var B = 0; B < o.length; B += this._delta32)
        this._update(o, B, B + this._delta32);
    }
    return this;
  }, h.prototype.digest = function(o) {
    return this.update(this._pad()), t(this.pending === null), this._digest(o);
  }, h.prototype._pad = function() {
    var o = this.pendingTotal, S = this._delta8, g = S - (o + this.padLength) % S, B = new Array(g + this.padLength);
    B[0] = 128;
    for (var M = 1; M < g; M++)
      B[M] = 0;
    if (o <<= 3, this.endian === "big") {
      for (var O = 8; O < this.padLength; O++)
        B[M++] = 0;
      B[M++] = 0, B[M++] = 0, B[M++] = 0, B[M++] = 0, B[M++] = o >>> 24 & 255, B[M++] = o >>> 16 & 255, B[M++] = o >>> 8 & 255, B[M++] = o & 255;
    } else
      for (B[M++] = o & 255, B[M++] = o >>> 8 & 255, B[M++] = o >>> 16 & 255, B[M++] = o >>> 24 & 255, B[M++] = 0, B[M++] = 0, B[M++] = 0, B[M++] = 0, O = 8; O < this.padLength; O++)
        B[M++] = 0;
    return B;
  }, common$1;
}
var sha = {}, common = {}, hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon)
    return common;
  hasRequiredCommon = 1;
  var e = requireUtils(), t = e.rotr32;
  function h(D, Z, Y, ee) {
    if (D === 0)
      return o(Z, Y, ee);
    if (D === 1 || D === 3)
      return g(Z, Y, ee);
    if (D === 2)
      return S(Z, Y, ee);
  }
  common.ft_1 = h;
  function o(D, Z, Y) {
    return D & Z ^ ~D & Y;
  }
  common.ch32 = o;
  function S(D, Z, Y) {
    return D & Z ^ D & Y ^ Z & Y;
  }
  common.maj32 = S;
  function g(D, Z, Y) {
    return D ^ Z ^ Y;
  }
  common.p32 = g;
  function B(D) {
    return t(D, 2) ^ t(D, 13) ^ t(D, 22);
  }
  common.s0_256 = B;
  function M(D) {
    return t(D, 6) ^ t(D, 11) ^ t(D, 25);
  }
  common.s1_256 = M;
  function O(D) {
    return t(D, 7) ^ t(D, 18) ^ D >>> 3;
  }
  common.g0_256 = O;
  function P(D) {
    return t(D, 17) ^ t(D, 19) ^ D >>> 10;
  }
  return common.g1_256 = P, common;
}
var _1$1, hasRequired_1;
function require_1() {
  if (hasRequired_1)
    return _1$1;
  hasRequired_1 = 1;
  var e = requireUtils(), t = requireCommon$1(), h = requireCommon(), o = e.rotl32, S = e.sum32, g = e.sum32_5, B = h.ft_1, M = t.BlockHash, O = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function P() {
    if (!(this instanceof P))
      return new P();
    M.call(this), this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ], this.W = new Array(80);
  }
  return e.inherits(P, M), _1$1 = P, P.blockSize = 512, P.outSize = 160, P.hmacStrength = 80, P.padLength = 64, P.prototype._update = function(D, Z) {
    for (var Y = this.W, ee = 0; ee < 16; ee++)
      Y[ee] = D[Z + ee];
    for (; ee < Y.length; ee++)
      Y[ee] = o(Y[ee - 3] ^ Y[ee - 8] ^ Y[ee - 14] ^ Y[ee - 16], 1);
    var ie = this.h[0], ue = this.h[1], fe = this.h[2], de = this.h[3], ce = this.h[4];
    for (ee = 0; ee < Y.length; ee++) {
      var be = ~~(ee / 20), ve = g(o(ie, 5), B(be, ue, fe, de), ce, Y[ee], O[be]);
      ce = de, de = fe, fe = o(ue, 30), ue = ie, ie = ve;
    }
    this.h[0] = S(this.h[0], ie), this.h[1] = S(this.h[1], ue), this.h[2] = S(this.h[2], fe), this.h[3] = S(this.h[3], de), this.h[4] = S(this.h[4], ce);
  }, P.prototype._digest = function(D) {
    return D === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  }, _1$1;
}
var _256, hasRequired_256;
function require_256() {
  if (hasRequired_256)
    return _256;
  hasRequired_256 = 1;
  var e = requireUtils(), t = requireCommon$1(), h = requireCommon(), o = requireMinimalisticAssert(), S = e.sum32, g = e.sum32_4, B = e.sum32_5, M = h.ch32, O = h.maj32, P = h.s0_256, D = h.s1_256, Z = h.g0_256, Y = h.g1_256, ee = t.BlockHash, ie = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function ue() {
    if (!(this instanceof ue))
      return new ue();
    ee.call(this), this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ], this.k = ie, this.W = new Array(64);
  }
  return e.inherits(ue, ee), _256 = ue, ue.blockSize = 512, ue.outSize = 256, ue.hmacStrength = 192, ue.padLength = 64, ue.prototype._update = function(fe, de) {
    for (var ce = this.W, be = 0; be < 16; be++)
      ce[be] = fe[de + be];
    for (; be < ce.length; be++)
      ce[be] = g(Y(ce[be - 2]), ce[be - 7], Z(ce[be - 15]), ce[be - 16]);
    var ve = this.h[0], Pe = this.h[1], Ue = this.h[2], ze = this.h[3], Le = this.h[4], Ne = this.h[5], $e = this.h[6], J = this.h[7];
    for (o(this.k.length === ce.length), be = 0; be < ce.length; be++) {
      var ne = B(J, D(Le), M(Le, Ne, $e), this.k[be], ce[be]), A = S(P(ve), O(ve, Pe, Ue));
      J = $e, $e = Ne, Ne = Le, Le = S(ze, ne), ze = Ue, Ue = Pe, Pe = ve, ve = S(ne, A);
    }
    this.h[0] = S(this.h[0], ve), this.h[1] = S(this.h[1], Pe), this.h[2] = S(this.h[2], Ue), this.h[3] = S(this.h[3], ze), this.h[4] = S(this.h[4], Le), this.h[5] = S(this.h[5], Ne), this.h[6] = S(this.h[6], $e), this.h[7] = S(this.h[7], J);
  }, ue.prototype._digest = function(fe) {
    return fe === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  }, _256;
}
var _224, hasRequired_224;
function require_224() {
  if (hasRequired_224)
    return _224;
  hasRequired_224 = 1;
  var e = requireUtils(), t = require_256();
  function h() {
    if (!(this instanceof h))
      return new h();
    t.call(this), this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  return e.inherits(h, t), _224 = h, h.blockSize = 512, h.outSize = 224, h.hmacStrength = 192, h.padLength = 64, h.prototype._digest = function(o) {
    return o === "hex" ? e.toHex32(this.h.slice(0, 7), "big") : e.split32(this.h.slice(0, 7), "big");
  }, _224;
}
var _512, hasRequired_512;
function require_512() {
  if (hasRequired_512)
    return _512;
  hasRequired_512 = 1;
  var e = requireUtils(), t = requireCommon$1(), h = requireMinimalisticAssert(), o = e.rotr64_hi, S = e.rotr64_lo, g = e.shr64_hi, B = e.shr64_lo, M = e.sum64, O = e.sum64_hi, P = e.sum64_lo, D = e.sum64_4_hi, Z = e.sum64_4_lo, Y = e.sum64_5_hi, ee = e.sum64_5_lo, ie = t.BlockHash, ue = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function fe() {
    if (!(this instanceof fe))
      return new fe();
    ie.call(this), this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ], this.k = ue, this.W = new Array(160);
  }
  e.inherits(fe, ie), _512 = fe, fe.blockSize = 1024, fe.outSize = 512, fe.hmacStrength = 192, fe.padLength = 128, fe.prototype._prepareBlock = function(A, I) {
    for (var U = this.W, X = 0; X < 32; X++)
      U[X] = A[I + X];
    for (; X < U.length; X += 2) {
      var Q = J(U[X - 4], U[X - 3]), F = ne(U[X - 4], U[X - 3]), $ = U[X - 14], H = U[X - 13], q = Ne(U[X - 30], U[X - 29]), z = $e(U[X - 30], U[X - 29]), me = U[X - 32], Ce = U[X - 31];
      U[X] = D(
        Q,
        F,
        $,
        H,
        q,
        z,
        me,
        Ce
      ), U[X + 1] = Z(
        Q,
        F,
        $,
        H,
        q,
        z,
        me,
        Ce
      );
    }
  }, fe.prototype._update = function(A, I) {
    this._prepareBlock(A, I);
    var U = this.W, X = this.h[0], Q = this.h[1], F = this.h[2], $ = this.h[3], H = this.h[4], q = this.h[5], z = this.h[6], me = this.h[7], Ce = this.h[8], je = this.h[9], Re = this.h[10], Ae = this.h[11], ke = this.h[12], Qe = this.h[13], Ze = this.h[14], qe = this.h[15];
    h(this.k.length === U.length);
    for (var Oe = 0; Oe < U.length; Oe += 2) {
      var Xe = Ze, et = qe, nt = ze(Ce, je), re = Le(Ce, je), oe = de(Ce, je, Re, Ae, ke), le = ce(Ce, je, Re, Ae, ke, Qe), ge = this.k[Oe], Ke = this.k[Oe + 1], Je = U[Oe], Fe = U[Oe + 1], Ye = Y(
        Xe,
        et,
        nt,
        re,
        oe,
        le,
        ge,
        Ke,
        Je,
        Fe
      ), it = ee(
        Xe,
        et,
        nt,
        re,
        oe,
        le,
        ge,
        Ke,
        Je,
        Fe
      );
      Xe = Pe(X, Q), et = Ue(X, Q), nt = be(X, Q, F, $, H), re = ve(X, Q, F, $, H, q);
      var rt = O(Xe, et, nt, re), tt = P(Xe, et, nt, re);
      Ze = ke, qe = Qe, ke = Re, Qe = Ae, Re = Ce, Ae = je, Ce = O(z, me, Ye, it), je = P(me, me, Ye, it), z = H, me = q, H = F, q = $, F = X, $ = Q, X = O(Ye, it, rt, tt), Q = P(Ye, it, rt, tt);
    }
    M(this.h, 0, X, Q), M(this.h, 2, F, $), M(this.h, 4, H, q), M(this.h, 6, z, me), M(this.h, 8, Ce, je), M(this.h, 10, Re, Ae), M(this.h, 12, ke, Qe), M(this.h, 14, Ze, qe);
  }, fe.prototype._digest = function(A) {
    return A === "hex" ? e.toHex32(this.h, "big") : e.split32(this.h, "big");
  };
  function de(A, I, U, X, Q) {
    var F = A & U ^ ~A & Q;
    return F < 0 && (F += 4294967296), F;
  }
  function ce(A, I, U, X, Q, F) {
    var $ = I & X ^ ~I & F;
    return $ < 0 && ($ += 4294967296), $;
  }
  function be(A, I, U, X, Q) {
    var F = A & U ^ A & Q ^ U & Q;
    return F < 0 && (F += 4294967296), F;
  }
  function ve(A, I, U, X, Q, F) {
    var $ = I & X ^ I & F ^ X & F;
    return $ < 0 && ($ += 4294967296), $;
  }
  function Pe(A, I) {
    var U = o(A, I, 28), X = o(I, A, 2), Q = o(I, A, 7), F = U ^ X ^ Q;
    return F < 0 && (F += 4294967296), F;
  }
  function Ue(A, I) {
    var U = S(A, I, 28), X = S(I, A, 2), Q = S(I, A, 7), F = U ^ X ^ Q;
    return F < 0 && (F += 4294967296), F;
  }
  function ze(A, I) {
    var U = o(A, I, 14), X = o(A, I, 18), Q = o(I, A, 9), F = U ^ X ^ Q;
    return F < 0 && (F += 4294967296), F;
  }
  function Le(A, I) {
    var U = S(A, I, 14), X = S(A, I, 18), Q = S(I, A, 9), F = U ^ X ^ Q;
    return F < 0 && (F += 4294967296), F;
  }
  function Ne(A, I) {
    var U = o(A, I, 1), X = o(A, I, 8), Q = g(A, I, 7), F = U ^ X ^ Q;
    return F < 0 && (F += 4294967296), F;
  }
  function $e(A, I) {
    var U = S(A, I, 1), X = S(A, I, 8), Q = B(A, I, 7), F = U ^ X ^ Q;
    return F < 0 && (F += 4294967296), F;
  }
  function J(A, I) {
    var U = o(A, I, 19), X = o(I, A, 29), Q = g(A, I, 6), F = U ^ X ^ Q;
    return F < 0 && (F += 4294967296), F;
  }
  function ne(A, I) {
    var U = S(A, I, 19), X = S(I, A, 29), Q = B(A, I, 6), F = U ^ X ^ Q;
    return F < 0 && (F += 4294967296), F;
  }
  return _512;
}
var _384, hasRequired_384;
function require_384() {
  if (hasRequired_384)
    return _384;
  hasRequired_384 = 1;
  var e = requireUtils(), t = require_512();
  function h() {
    if (!(this instanceof h))
      return new h();
    t.call(this), this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  return e.inherits(h, t), _384 = h, h.blockSize = 1024, h.outSize = 384, h.hmacStrength = 192, h.padLength = 128, h.prototype._digest = function(o) {
    return o === "hex" ? e.toHex32(this.h.slice(0, 12), "big") : e.split32(this.h.slice(0, 12), "big");
  }, _384;
}
var hasRequiredSha;
function requireSha() {
  return hasRequiredSha || (hasRequiredSha = 1, sha.sha1 = require_1(), sha.sha224 = require_224(), sha.sha256 = require_256(), sha.sha384 = require_384(), sha.sha512 = require_512()), sha;
}
var ripemd = {}, hasRequiredRipemd;
function requireRipemd() {
  if (hasRequiredRipemd)
    return ripemd;
  hasRequiredRipemd = 1;
  var e = requireUtils(), t = requireCommon$1(), h = e.rotl32, o = e.sum32, S = e.sum32_3, g = e.sum32_4, B = t.BlockHash;
  function M() {
    if (!(this instanceof M))
      return new M();
    B.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
  }
  e.inherits(M, B), ripemd.ripemd160 = M, M.blockSize = 512, M.outSize = 160, M.hmacStrength = 192, M.padLength = 64, M.prototype._update = function(ue, fe) {
    for (var de = this.h[0], ce = this.h[1], be = this.h[2], ve = this.h[3], Pe = this.h[4], Ue = de, ze = ce, Le = be, Ne = ve, $e = Pe, J = 0; J < 80; J++) {
      var ne = o(
        h(
          g(de, O(J, ce, be, ve), ue[Z[J] + fe], P(J)),
          ee[J]
        ),
        Pe
      );
      de = Pe, Pe = ve, ve = h(be, 10), be = ce, ce = ne, ne = o(
        h(
          g(Ue, O(79 - J, ze, Le, Ne), ue[Y[J] + fe], D(J)),
          ie[J]
        ),
        $e
      ), Ue = $e, $e = Ne, Ne = h(Le, 10), Le = ze, ze = ne;
    }
    ne = S(this.h[1], be, Ne), this.h[1] = S(this.h[2], ve, $e), this.h[2] = S(this.h[3], Pe, Ue), this.h[3] = S(this.h[4], de, ze), this.h[4] = S(this.h[0], ce, Le), this.h[0] = ne;
  }, M.prototype._digest = function(ue) {
    return ue === "hex" ? e.toHex32(this.h, "little") : e.split32(this.h, "little");
  };
  function O(ue, fe, de, ce) {
    return ue <= 15 ? fe ^ de ^ ce : ue <= 31 ? fe & de | ~fe & ce : ue <= 47 ? (fe | ~de) ^ ce : ue <= 63 ? fe & ce | de & ~ce : fe ^ (de | ~ce);
  }
  function P(ue) {
    return ue <= 15 ? 0 : ue <= 31 ? 1518500249 : ue <= 47 ? 1859775393 : ue <= 63 ? 2400959708 : 2840853838;
  }
  function D(ue) {
    return ue <= 15 ? 1352829926 : ue <= 31 ? 1548603684 : ue <= 47 ? 1836072691 : ue <= 63 ? 2053994217 : 0;
  }
  var Z = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ], Y = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ], ee = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ], ie = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
  return ripemd;
}
var hmac, hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac)
    return hmac;
  hasRequiredHmac = 1;
  var e = requireUtils(), t = requireMinimalisticAssert();
  function h(o, S, g) {
    if (!(this instanceof h))
      return new h(o, S, g);
    this.Hash = o, this.blockSize = o.blockSize / 8, this.outSize = o.outSize / 8, this.inner = null, this.outer = null, this._init(e.toArray(S, g));
  }
  return hmac = h, h.prototype._init = function(o) {
    o.length > this.blockSize && (o = new this.Hash().update(o).digest()), t(o.length <= this.blockSize);
    for (var S = o.length; S < this.blockSize; S++)
      o.push(0);
    for (S = 0; S < o.length; S++)
      o[S] ^= 54;
    for (this.inner = new this.Hash().update(o), S = 0; S < o.length; S++)
      o[S] ^= 106;
    this.outer = new this.Hash().update(o);
  }, h.prototype.update = function(o, S) {
    return this.inner.update(o, S), this;
  }, h.prototype.digest = function(o) {
    return this.outer.update(this.inner.digest()), this.outer.digest(o);
  }, hmac;
}
var hasRequiredHash;
function requireHash() {
  return hasRequiredHash || (hasRequiredHash = 1, function(e) {
    var t = e;
    t.utils = requireUtils(), t.common = requireCommon$1(), t.sha = requireSha(), t.ripemd = requireRipemd(), t.hmac = requireHmac(), t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160;
  }(hash)), hash;
}
var secp256k1, hasRequiredSecp256k1;
function requireSecp256k1() {
  return hasRequiredSecp256k1 || (hasRequiredSecp256k1 = 1, secp256k1 = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), secp256k1;
}
var hasRequiredCurves;
function requireCurves() {
  return hasRequiredCurves || (hasRequiredCurves = 1, function(e) {
    var t = e, h = requireHash(), o = requireCurve(), S = requireUtils$1(), g = S.assert;
    function B(P) {
      P.type === "short" ? this.curve = new o.short(P) : P.type === "edwards" ? this.curve = new o.edwards(P) : this.curve = new o.mont(P), this.g = this.curve.g, this.n = this.curve.n, this.hash = P.hash, g(this.g.validate(), "Invalid curve"), g(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
    }
    t.PresetCurve = B;
    function M(P, D) {
      Object.defineProperty(t, P, {
        configurable: !0,
        enumerable: !0,
        get: function() {
          var Z = new B(D);
          return Object.defineProperty(t, P, {
            configurable: !0,
            enumerable: !0,
            value: Z
          }), Z;
        }
      });
    }
    M("p192", {
      type: "short",
      prime: "p192",
      p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
      b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
      n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
      hash: h.sha256,
      gRed: !1,
      g: [
        "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
        "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
      ]
    }), M("p224", {
      type: "short",
      prime: "p224",
      p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
      a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
      b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
      n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
      hash: h.sha256,
      gRed: !1,
      g: [
        "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
        "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
      ]
    }), M("p256", {
      type: "short",
      prime: null,
      p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
      a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
      b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
      n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
      hash: h.sha256,
      gRed: !1,
      g: [
        "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
        "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
      ]
    }), M("p384", {
      type: "short",
      prime: null,
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
      a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
      b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
      n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
      hash: h.sha384,
      gRed: !1,
      g: [
        "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
        "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
      ]
    }), M("p521", {
      type: "short",
      prime: null,
      p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
      a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
      b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
      n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
      hash: h.sha512,
      gRed: !1,
      g: [
        "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
        "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
      ]
    }), M("curve25519", {
      type: "mont",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "76d06",
      b: "1",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: h.sha256,
      gRed: !1,
      g: [
        "9"
      ]
    }), M("ed25519", {
      type: "edwards",
      prime: "p25519",
      p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
      a: "-1",
      c: "1",
      // -121665 * (121666^(-1)) (mod P)
      d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
      n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
      hash: h.sha256,
      gRed: !1,
      g: [
        "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
        // 4/5
        "6666666666666666666666666666666666666666666666666666666666666658"
      ]
    });
    var O;
    try {
      O = requireSecp256k1();
    } catch {
      O = void 0;
    }
    M("secp256k1", {
      type: "short",
      prime: "k256",
      p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
      a: "0",
      b: "7",
      n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
      h: "1",
      hash: h.sha256,
      // Precomputed endomorphism
      beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
      lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
      basis: [
        {
          a: "3086d221a7d46bcde86c90e49284eb15",
          b: "-e4437ed6010e88286f547fa90abfe4c3"
        },
        {
          a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
          b: "3086d221a7d46bcde86c90e49284eb15"
        }
      ],
      gRed: !1,
      g: [
        "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
        "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
        O
      ]
    });
  }(curves)), curves;
}
var hmacDrbg, hasRequiredHmacDrbg;
function requireHmacDrbg() {
  if (hasRequiredHmacDrbg)
    return hmacDrbg;
  hasRequiredHmacDrbg = 1;
  var e = requireHash(), t = requireUtils$2(), h = requireMinimalisticAssert();
  function o(S) {
    if (!(this instanceof o))
      return new o(S);
    this.hash = S.hash, this.predResist = !!S.predResist, this.outLen = this.hash.outSize, this.minEntropy = S.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
    var g = t.toArray(S.entropy, S.entropyEnc || "hex"), B = t.toArray(S.nonce, S.nonceEnc || "hex"), M = t.toArray(S.pers, S.persEnc || "hex");
    h(
      g.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._init(g, B, M);
  }
  return hmacDrbg = o, o.prototype._init = function(S, g, B) {
    var M = S.concat(g).concat(B);
    this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
    for (var O = 0; O < this.V.length; O++)
      this.K[O] = 0, this.V[O] = 1;
    this._update(M), this._reseed = 1, this.reseedInterval = 281474976710656;
  }, o.prototype._hmac = function() {
    return new e.hmac(this.hash, this.K);
  }, o.prototype._update = function(S) {
    var g = this._hmac().update(this.V).update([0]);
    S && (g = g.update(S)), this.K = g.digest(), this.V = this._hmac().update(this.V).digest(), S && (this.K = this._hmac().update(this.V).update([1]).update(S).digest(), this.V = this._hmac().update(this.V).digest());
  }, o.prototype.reseed = function(S, g, B, M) {
    typeof g != "string" && (M = B, B = g, g = null), S = t.toArray(S, g), B = t.toArray(B, M), h(
      S.length >= this.minEntropy / 8,
      "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
    ), this._update(S.concat(B || [])), this._reseed = 1;
  }, o.prototype.generate = function(S, g, B, M) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    typeof g != "string" && (M = B, B = g, g = null), B && (B = t.toArray(B, M || "hex"), this._update(B));
    for (var O = []; O.length < S; )
      this.V = this._hmac().update(this.V).digest(), O = O.concat(this.V);
    var P = O.slice(0, S);
    return this._update(B), this._reseed++, t.encode(P, g);
  }, hmacDrbg;
}
var key$1, hasRequiredKey$1;
function requireKey$1() {
  if (hasRequiredKey$1)
    return key$1;
  hasRequiredKey$1 = 1;
  var e = requireBn$2(), t = requireUtils$1(), h = t.assert;
  function o(S, g) {
    this.ec = S, this.priv = null, this.pub = null, g.priv && this._importPrivate(g.priv, g.privEnc), g.pub && this._importPublic(g.pub, g.pubEnc);
  }
  return key$1 = o, o.fromPublic = function(S, g, B) {
    return g instanceof o ? g : new o(S, {
      pub: g,
      pubEnc: B
    });
  }, o.fromPrivate = function(S, g, B) {
    return g instanceof o ? g : new o(S, {
      priv: g,
      privEnc: B
    });
  }, o.prototype.validate = function() {
    var S = this.getPublic();
    return S.isInfinity() ? { result: !1, reason: "Invalid public key" } : S.validate() ? S.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
  }, o.prototype.getPublic = function(S, g) {
    return typeof S == "string" && (g = S, S = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), g ? this.pub.encode(g, S) : this.pub;
  }, o.prototype.getPrivate = function(S) {
    return S === "hex" ? this.priv.toString(16, 2) : this.priv;
  }, o.prototype._importPrivate = function(S, g) {
    this.priv = new e(S, g || 16), this.priv = this.priv.umod(this.ec.curve.n);
  }, o.prototype._importPublic = function(S, g) {
    if (S.x || S.y) {
      this.ec.curve.type === "mont" ? h(S.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && h(S.x && S.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(S.x, S.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(S, g);
  }, o.prototype.derive = function(S) {
    return S.validate() || h(S.validate(), "public point not validated"), S.mul(this.priv).getX();
  }, o.prototype.sign = function(S, g, B) {
    return this.ec.sign(S, this, g, B);
  }, o.prototype.verify = function(S, g) {
    return this.ec.verify(S, g, this);
  }, o.prototype.inspect = function() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  }, key$1;
}
var signature$1, hasRequiredSignature$1;
function requireSignature$1() {
  if (hasRequiredSignature$1)
    return signature$1;
  hasRequiredSignature$1 = 1;
  var e = requireBn$2(), t = requireUtils$1(), h = t.assert;
  function o(O, P) {
    if (O instanceof o)
      return O;
    this._importDER(O, P) || (h(O.r && O.s, "Signature without r or s"), this.r = new e(O.r, 16), this.s = new e(O.s, 16), O.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = O.recoveryParam);
  }
  signature$1 = o;
  function S() {
    this.place = 0;
  }
  function g(O, P) {
    var D = O[P.place++];
    if (!(D & 128))
      return D;
    var Z = D & 15;
    if (Z === 0 || Z > 4)
      return !1;
    for (var Y = 0, ee = 0, ie = P.place; ee < Z; ee++, ie++)
      Y <<= 8, Y |= O[ie], Y >>>= 0;
    return Y <= 127 ? !1 : (P.place = ie, Y);
  }
  function B(O) {
    for (var P = 0, D = O.length - 1; !O[P] && !(O[P + 1] & 128) && P < D; )
      P++;
    return P === 0 ? O : O.slice(P);
  }
  o.prototype._importDER = function(O, P) {
    O = t.toArray(O, P);
    var D = new S();
    if (O[D.place++] !== 48)
      return !1;
    var Z = g(O, D);
    if (Z === !1 || Z + D.place !== O.length || O[D.place++] !== 2)
      return !1;
    var Y = g(O, D);
    if (Y === !1)
      return !1;
    var ee = O.slice(D.place, Y + D.place);
    if (D.place += Y, O[D.place++] !== 2)
      return !1;
    var ie = g(O, D);
    if (ie === !1 || O.length !== ie + D.place)
      return !1;
    var ue = O.slice(D.place, ie + D.place);
    if (ee[0] === 0)
      if (ee[1] & 128)
        ee = ee.slice(1);
      else
        return !1;
    if (ue[0] === 0)
      if (ue[1] & 128)
        ue = ue.slice(1);
      else
        return !1;
    return this.r = new e(ee), this.s = new e(ue), this.recoveryParam = null, !0;
  };
  function M(O, P) {
    if (P < 128) {
      O.push(P);
      return;
    }
    var D = 1 + (Math.log(P) / Math.LN2 >>> 3);
    for (O.push(D | 128); --D; )
      O.push(P >>> (D << 3) & 255);
    O.push(P);
  }
  return o.prototype.toDER = function(O) {
    var P = this.r.toArray(), D = this.s.toArray();
    for (P[0] & 128 && (P = [0].concat(P)), D[0] & 128 && (D = [0].concat(D)), P = B(P), D = B(D); !D[0] && !(D[1] & 128); )
      D = D.slice(1);
    var Z = [2];
    M(Z, P.length), Z = Z.concat(P), Z.push(2), M(Z, D.length);
    var Y = Z.concat(D), ee = [48];
    return M(ee, Y.length), ee = ee.concat(Y), t.encode(ee, O);
  }, signature$1;
}
var ec$1, hasRequiredEc;
function requireEc() {
  if (hasRequiredEc)
    return ec$1;
  hasRequiredEc = 1;
  var e = requireBn$2(), t = requireHmacDrbg(), h = requireUtils$1(), o = requireCurves(), S = requireBrorand(), g = h.assert, B = requireKey$1(), M = requireSignature$1();
  function O(P) {
    if (!(this instanceof O))
      return new O(P);
    typeof P == "string" && (g(
      Object.prototype.hasOwnProperty.call(o, P),
      "Unknown curve " + P
    ), P = o[P]), P instanceof o.PresetCurve && (P = { curve: P }), this.curve = P.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = P.curve.g, this.g.precompute(P.curve.n.bitLength() + 1), this.hash = P.hash || P.curve.hash;
  }
  return ec$1 = O, O.prototype.keyPair = function(P) {
    return new B(this, P);
  }, O.prototype.keyFromPrivate = function(P, D) {
    return B.fromPrivate(this, P, D);
  }, O.prototype.keyFromPublic = function(P, D) {
    return B.fromPublic(this, P, D);
  }, O.prototype.genKeyPair = function(P) {
    P || (P = {});
    for (var D = new t({
      hash: this.hash,
      pers: P.pers,
      persEnc: P.persEnc || "utf8",
      entropy: P.entropy || S(this.hash.hmacStrength),
      entropyEnc: P.entropy && P.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), Z = this.n.byteLength(), Y = this.n.sub(new e(2)); ; ) {
      var ee = new e(D.generate(Z));
      if (!(ee.cmp(Y) > 0))
        return ee.iaddn(1), this.keyFromPrivate(ee);
    }
  }, O.prototype._truncateToN = function(P, D) {
    var Z = P.byteLength() * 8 - this.n.bitLength();
    return Z > 0 && (P = P.ushrn(Z)), !D && P.cmp(this.n) >= 0 ? P.sub(this.n) : P;
  }, O.prototype.sign = function(P, D, Z, Y) {
    typeof Z == "object" && (Y = Z, Z = null), Y || (Y = {}), D = this.keyFromPrivate(D, Z), P = this._truncateToN(new e(P, 16));
    for (var ee = this.n.byteLength(), ie = D.getPrivate().toArray("be", ee), ue = P.toArray("be", ee), fe = new t({
      hash: this.hash,
      entropy: ie,
      nonce: ue,
      pers: Y.pers,
      persEnc: Y.persEnc || "utf8"
    }), de = this.n.sub(new e(1)), ce = 0; ; ce++) {
      var be = Y.k ? Y.k(ce) : new e(fe.generate(this.n.byteLength()));
      if (be = this._truncateToN(be, !0), !(be.cmpn(1) <= 0 || be.cmp(de) >= 0)) {
        var ve = this.g.mul(be);
        if (!ve.isInfinity()) {
          var Pe = ve.getX(), Ue = Pe.umod(this.n);
          if (Ue.cmpn(0) !== 0) {
            var ze = be.invm(this.n).mul(Ue.mul(D.getPrivate()).iadd(P));
            if (ze = ze.umod(this.n), ze.cmpn(0) !== 0) {
              var Le = (ve.getY().isOdd() ? 1 : 0) | (Pe.cmp(Ue) !== 0 ? 2 : 0);
              return Y.canonical && ze.cmp(this.nh) > 0 && (ze = this.n.sub(ze), Le ^= 1), new M({ r: Ue, s: ze, recoveryParam: Le });
            }
          }
        }
      }
    }
  }, O.prototype.verify = function(P, D, Z, Y) {
    P = this._truncateToN(new e(P, 16)), Z = this.keyFromPublic(Z, Y), D = new M(D, "hex");
    var ee = D.r, ie = D.s;
    if (ee.cmpn(1) < 0 || ee.cmp(this.n) >= 0 || ie.cmpn(1) < 0 || ie.cmp(this.n) >= 0)
      return !1;
    var ue = ie.invm(this.n), fe = ue.mul(P).umod(this.n), de = ue.mul(ee).umod(this.n), ce;
    return this.curve._maxwellTrick ? (ce = this.g.jmulAdd(fe, Z.getPublic(), de), ce.isInfinity() ? !1 : ce.eqXToP(ee)) : (ce = this.g.mulAdd(fe, Z.getPublic(), de), ce.isInfinity() ? !1 : ce.getX().umod(this.n).cmp(ee) === 0);
  }, O.prototype.recoverPubKey = function(P, D, Z, Y) {
    g((3 & Z) === Z, "The recovery param is more than two bits"), D = new M(D, Y);
    var ee = this.n, ie = new e(P), ue = D.r, fe = D.s, de = Z & 1, ce = Z >> 1;
    if (ue.cmp(this.curve.p.umod(this.curve.n)) >= 0 && ce)
      throw new Error("Unable to find sencond key candinate");
    ce ? ue = this.curve.pointFromX(ue.add(this.curve.n), de) : ue = this.curve.pointFromX(ue, de);
    var be = D.r.invm(ee), ve = ee.sub(ie).mul(be).umod(ee), Pe = fe.mul(be).umod(ee);
    return this.g.mulAdd(ve, ue, Pe);
  }, O.prototype.getKeyRecoveryParam = function(P, D, Z, Y) {
    if (D = new M(D, Y), D.recoveryParam !== null)
      return D.recoveryParam;
    for (var ee = 0; ee < 4; ee++) {
      var ie;
      try {
        ie = this.recoverPubKey(P, D, ee);
      } catch {
        continue;
      }
      if (ie.eq(Z))
        return ee;
    }
    throw new Error("Unable to find valid recovery factor");
  }, ec$1;
}
var key, hasRequiredKey;
function requireKey() {
  if (hasRequiredKey)
    return key;
  hasRequiredKey = 1;
  var e = requireUtils$1(), t = e.assert, h = e.parseBytes, o = e.cachedProperty;
  function S(g, B) {
    this.eddsa = g, this._secret = h(B.secret), g.isPoint(B.pub) ? this._pub = B.pub : this._pubBytes = h(B.pub);
  }
  return S.fromPublic = function(g, B) {
    return B instanceof S ? B : new S(g, { pub: B });
  }, S.fromSecret = function(g, B) {
    return B instanceof S ? B : new S(g, { secret: B });
  }, S.prototype.secret = function() {
    return this._secret;
  }, o(S, "pubBytes", function() {
    return this.eddsa.encodePoint(this.pub());
  }), o(S, "pub", function() {
    return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
  }), o(S, "privBytes", function() {
    var g = this.eddsa, B = this.hash(), M = g.encodingLength - 1, O = B.slice(0, g.encodingLength);
    return O[0] &= 248, O[M] &= 127, O[M] |= 64, O;
  }), o(S, "priv", function() {
    return this.eddsa.decodeInt(this.privBytes());
  }), o(S, "hash", function() {
    return this.eddsa.hash().update(this.secret()).digest();
  }), o(S, "messagePrefix", function() {
    return this.hash().slice(this.eddsa.encodingLength);
  }), S.prototype.sign = function(g) {
    return t(this._secret, "KeyPair can only verify"), this.eddsa.sign(g, this);
  }, S.prototype.verify = function(g, B) {
    return this.eddsa.verify(g, B, this);
  }, S.prototype.getSecret = function(g) {
    return t(this._secret, "KeyPair is public only"), e.encode(this.secret(), g);
  }, S.prototype.getPublic = function(g) {
    return e.encode(this.pubBytes(), g);
  }, key = S, key;
}
var signature, hasRequiredSignature;
function requireSignature() {
  if (hasRequiredSignature)
    return signature;
  hasRequiredSignature = 1;
  var e = requireBn$2(), t = requireUtils$1(), h = t.assert, o = t.cachedProperty, S = t.parseBytes;
  function g(B, M) {
    this.eddsa = B, typeof M != "object" && (M = S(M)), Array.isArray(M) && (M = {
      R: M.slice(0, B.encodingLength),
      S: M.slice(B.encodingLength)
    }), h(M.R && M.S, "Signature without R or S"), B.isPoint(M.R) && (this._R = M.R), M.S instanceof e && (this._S = M.S), this._Rencoded = Array.isArray(M.R) ? M.R : M.Rencoded, this._Sencoded = Array.isArray(M.S) ? M.S : M.Sencoded;
  }
  return o(g, "S", function() {
    return this.eddsa.decodeInt(this.Sencoded());
  }), o(g, "R", function() {
    return this.eddsa.decodePoint(this.Rencoded());
  }), o(g, "Rencoded", function() {
    return this.eddsa.encodePoint(this.R());
  }), o(g, "Sencoded", function() {
    return this.eddsa.encodeInt(this.S());
  }), g.prototype.toBytes = function() {
    return this.Rencoded().concat(this.Sencoded());
  }, g.prototype.toHex = function() {
    return t.encode(this.toBytes(), "hex").toUpperCase();
  }, signature = g, signature;
}
var eddsa, hasRequiredEddsa;
function requireEddsa() {
  if (hasRequiredEddsa)
    return eddsa;
  hasRequiredEddsa = 1;
  var e = requireHash(), t = requireCurves(), h = requireUtils$1(), o = h.assert, S = h.parseBytes, g = requireKey(), B = requireSignature();
  function M(O) {
    if (o(O === "ed25519", "only tested with ed25519 so far"), !(this instanceof M))
      return new M(O);
    O = t[O].curve, this.curve = O, this.g = O.g, this.g.precompute(O.n.bitLength() + 1), this.pointClass = O.point().constructor, this.encodingLength = Math.ceil(O.n.bitLength() / 8), this.hash = e.sha512;
  }
  return eddsa = M, M.prototype.sign = function(O, P) {
    O = S(O);
    var D = this.keyFromSecret(P), Z = this.hashInt(D.messagePrefix(), O), Y = this.g.mul(Z), ee = this.encodePoint(Y), ie = this.hashInt(ee, D.pubBytes(), O).mul(D.priv()), ue = Z.add(ie).umod(this.curve.n);
    return this.makeSignature({ R: Y, S: ue, Rencoded: ee });
  }, M.prototype.verify = function(O, P, D) {
    O = S(O), P = this.makeSignature(P);
    var Z = this.keyFromPublic(D), Y = this.hashInt(P.Rencoded(), Z.pubBytes(), O), ee = this.g.mul(P.S()), ie = P.R().add(Z.pub().mul(Y));
    return ie.eq(ee);
  }, M.prototype.hashInt = function() {
    for (var O = this.hash(), P = 0; P < arguments.length; P++)
      O.update(arguments[P]);
    return h.intFromLE(O.digest()).umod(this.curve.n);
  }, M.prototype.keyFromPublic = function(O) {
    return g.fromPublic(this, O);
  }, M.prototype.keyFromSecret = function(O) {
    return g.fromSecret(this, O);
  }, M.prototype.makeSignature = function(O) {
    return O instanceof B ? O : new B(this, O);
  }, M.prototype.encodePoint = function(O) {
    var P = O.getY().toArray("le", this.encodingLength);
    return P[this.encodingLength - 1] |= O.getX().isOdd() ? 128 : 0, P;
  }, M.prototype.decodePoint = function(O) {
    O = h.parseBytes(O);
    var P = O.length - 1, D = O.slice(0, P).concat(O[P] & -129), Z = (O[P] & 128) !== 0, Y = h.intFromLE(D);
    return this.curve.pointFromY(Y, Z);
  }, M.prototype.encodeInt = function(O) {
    return O.toArray("le", this.encodingLength);
  }, M.prototype.decodeInt = function(O) {
    return h.intFromLE(O);
  }, M.prototype.isPoint = function(O) {
    return O instanceof this.pointClass;
  }, eddsa;
}
var hasRequiredElliptic;
function requireElliptic() {
  return hasRequiredElliptic || (hasRequiredElliptic = 1, function(e) {
    var t = e;
    t.version = require$$0.version, t.utils = requireUtils$1(), t.rand = requireBrorand(), t.curve = requireCurve(), t.curves = requireCurves(), t.ec = requireEc(), t.eddsa = requireEddsa();
  }(elliptic)), elliptic;
}
var bn$3 = { exports: {} }, hasRequiredBn;
function requireBn() {
  return hasRequiredBn || (hasRequiredBn = 1, function(e) {
    (function(t, h) {
      function o(A, I) {
        if (!A)
          throw new Error(I || "Assertion failed");
      }
      function S(A, I) {
        A.super_ = I;
        var U = function() {
        };
        U.prototype = I.prototype, A.prototype = new U(), A.prototype.constructor = A;
      }
      function g(A, I, U) {
        if (g.isBN(A))
          return A;
        this.negative = 0, this.words = null, this.length = 0, this.red = null, A !== null && ((I === "le" || I === "be") && (U = I, I = 10), this._init(A || 0, I || 10, U || "be"));
      }
      typeof t == "object" ? t.exports = g : h.BN = g, g.BN = g, g.wordSize = 26;
      var B;
      try {
        typeof window < "u" && typeof window.Buffer < "u" ? B = window.Buffer : B = requireBuffer$1().Buffer;
      } catch {
      }
      g.isBN = function(A) {
        return A instanceof g ? !0 : A !== null && typeof A == "object" && A.constructor.wordSize === g.wordSize && Array.isArray(A.words);
      }, g.max = function(A, I) {
        return A.cmp(I) > 0 ? A : I;
      }, g.min = function(A, I) {
        return A.cmp(I) < 0 ? A : I;
      }, g.prototype._init = function(A, I, U) {
        if (typeof A == "number")
          return this._initNumber(A, I, U);
        if (typeof A == "object")
          return this._initArray(A, I, U);
        I === "hex" && (I = 16), o(I === (I | 0) && I >= 2 && I <= 36), A = A.toString().replace(/\s+/g, "");
        var X = 0;
        A[0] === "-" && (X++, this.negative = 1), X < A.length && (I === 16 ? this._parseHex(A, X, U) : (this._parseBase(A, I, X), U === "le" && this._initArray(this.toArray(), I, U)));
      }, g.prototype._initNumber = function(A, I, U) {
        A < 0 && (this.negative = 1, A = -A), A < 67108864 ? (this.words = [A & 67108863], this.length = 1) : A < 4503599627370496 ? (this.words = [
          A & 67108863,
          A / 67108864 & 67108863
        ], this.length = 2) : (o(A < 9007199254740992), this.words = [
          A & 67108863,
          A / 67108864 & 67108863,
          1
        ], this.length = 3), U === "le" && this._initArray(this.toArray(), I, U);
      }, g.prototype._initArray = function(A, I, U) {
        if (o(typeof A.length == "number"), A.length <= 0)
          return this.words = [0], this.length = 1, this;
        this.length = Math.ceil(A.length / 3), this.words = new Array(this.length);
        for (var X = 0; X < this.length; X++)
          this.words[X] = 0;
        var Q, F, $ = 0;
        if (U === "be")
          for (X = A.length - 1, Q = 0; X >= 0; X -= 3)
            F = A[X] | A[X - 1] << 8 | A[X - 2] << 16, this.words[Q] |= F << $ & 67108863, this.words[Q + 1] = F >>> 26 - $ & 67108863, $ += 24, $ >= 26 && ($ -= 26, Q++);
        else if (U === "le")
          for (X = 0, Q = 0; X < A.length; X += 3)
            F = A[X] | A[X + 1] << 8 | A[X + 2] << 16, this.words[Q] |= F << $ & 67108863, this.words[Q + 1] = F >>> 26 - $ & 67108863, $ += 24, $ >= 26 && ($ -= 26, Q++);
        return this._strip();
      };
      function M(A, I) {
        var U = A.charCodeAt(I);
        if (U >= 48 && U <= 57)
          return U - 48;
        if (U >= 65 && U <= 70)
          return U - 55;
        if (U >= 97 && U <= 102)
          return U - 87;
        o(!1, "Invalid character in " + A);
      }
      function O(A, I, U) {
        var X = M(A, U);
        return U - 1 >= I && (X |= M(A, U - 1) << 4), X;
      }
      g.prototype._parseHex = function(A, I, U) {
        this.length = Math.ceil((A.length - I) / 6), this.words = new Array(this.length);
        for (var X = 0; X < this.length; X++)
          this.words[X] = 0;
        var Q = 0, F = 0, $;
        if (U === "be")
          for (X = A.length - 1; X >= I; X -= 2)
            $ = O(A, I, X) << Q, this.words[F] |= $ & 67108863, Q >= 18 ? (Q -= 18, F += 1, this.words[F] |= $ >>> 26) : Q += 8;
        else {
          var H = A.length - I;
          for (X = H % 2 === 0 ? I + 1 : I; X < A.length; X += 2)
            $ = O(A, I, X) << Q, this.words[F] |= $ & 67108863, Q >= 18 ? (Q -= 18, F += 1, this.words[F] |= $ >>> 26) : Q += 8;
        }
        this._strip();
      };
      function P(A, I, U, X) {
        for (var Q = 0, F = 0, $ = Math.min(A.length, U), H = I; H < $; H++) {
          var q = A.charCodeAt(H) - 48;
          Q *= X, q >= 49 ? F = q - 49 + 10 : q >= 17 ? F = q - 17 + 10 : F = q, o(q >= 0 && F < X, "Invalid character"), Q += F;
        }
        return Q;
      }
      g.prototype._parseBase = function(A, I, U) {
        this.words = [0], this.length = 1;
        for (var X = 0, Q = 1; Q <= 67108863; Q *= I)
          X++;
        X--, Q = Q / I | 0;
        for (var F = A.length - U, $ = F % X, H = Math.min(F, F - $) + U, q = 0, z = U; z < H; z += X)
          q = P(A, z, z + X, I), this.imuln(Q), this.words[0] + q < 67108864 ? this.words[0] += q : this._iaddn(q);
        if ($ !== 0) {
          var me = 1;
          for (q = P(A, z, A.length, I), z = 0; z < $; z++)
            me *= I;
          this.imuln(me), this.words[0] + q < 67108864 ? this.words[0] += q : this._iaddn(q);
        }
        this._strip();
      }, g.prototype.copy = function(A) {
        A.words = new Array(this.length);
        for (var I = 0; I < this.length; I++)
          A.words[I] = this.words[I];
        A.length = this.length, A.negative = this.negative, A.red = this.red;
      };
      function D(A, I) {
        A.words = I.words, A.length = I.length, A.negative = I.negative, A.red = I.red;
      }
      if (g.prototype._move = function(A) {
        D(A, this);
      }, g.prototype.clone = function() {
        var A = new g(null);
        return this.copy(A), A;
      }, g.prototype._expand = function(A) {
        for (; this.length < A; )
          this.words[this.length++] = 0;
        return this;
      }, g.prototype._strip = function() {
        for (; this.length > 1 && this.words[this.length - 1] === 0; )
          this.length--;
        return this._normSign();
      }, g.prototype._normSign = function() {
        return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
      }, typeof Symbol < "u" && typeof Symbol.for == "function")
        try {
          g.prototype[Symbol.for("nodejs.util.inspect.custom")] = Z;
        } catch {
          g.prototype.inspect = Z;
        }
      else
        g.prototype.inspect = Z;
      function Z() {
        return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
      }
      var Y = [
        "",
        "0",
        "00",
        "000",
        "0000",
        "00000",
        "000000",
        "0000000",
        "00000000",
        "000000000",
        "0000000000",
        "00000000000",
        "000000000000",
        "0000000000000",
        "00000000000000",
        "000000000000000",
        "0000000000000000",
        "00000000000000000",
        "000000000000000000",
        "0000000000000000000",
        "00000000000000000000",
        "000000000000000000000",
        "0000000000000000000000",
        "00000000000000000000000",
        "000000000000000000000000",
        "0000000000000000000000000"
      ], ee = [
        0,
        0,
        25,
        16,
        12,
        11,
        10,
        9,
        8,
        8,
        7,
        7,
        7,
        7,
        6,
        6,
        6,
        6,
        6,
        6,
        6,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5,
        5
      ], ie = [
        0,
        0,
        33554432,
        43046721,
        16777216,
        48828125,
        60466176,
        40353607,
        16777216,
        43046721,
        1e7,
        19487171,
        35831808,
        62748517,
        7529536,
        11390625,
        16777216,
        24137569,
        34012224,
        47045881,
        64e6,
        4084101,
        5153632,
        6436343,
        7962624,
        9765625,
        11881376,
        14348907,
        17210368,
        20511149,
        243e5,
        28629151,
        33554432,
        39135393,
        45435424,
        52521875,
        60466176
      ];
      g.prototype.toString = function(A, I) {
        A = A || 10, I = I | 0 || 1;
        var U;
        if (A === 16 || A === "hex") {
          U = "";
          for (var X = 0, Q = 0, F = 0; F < this.length; F++) {
            var $ = this.words[F], H = (($ << X | Q) & 16777215).toString(16);
            Q = $ >>> 24 - X & 16777215, X += 2, X >= 26 && (X -= 26, F--), Q !== 0 || F !== this.length - 1 ? U = Y[6 - H.length] + H + U : U = H + U;
          }
          for (Q !== 0 && (U = Q.toString(16) + U); U.length % I !== 0; )
            U = "0" + U;
          return this.negative !== 0 && (U = "-" + U), U;
        }
        if (A === (A | 0) && A >= 2 && A <= 36) {
          var q = ee[A], z = ie[A];
          U = "";
          var me = this.clone();
          for (me.negative = 0; !me.isZero(); ) {
            var Ce = me.modrn(z).toString(A);
            me = me.idivn(z), me.isZero() ? U = Ce + U : U = Y[q - Ce.length] + Ce + U;
          }
          for (this.isZero() && (U = "0" + U); U.length % I !== 0; )
            U = "0" + U;
          return this.negative !== 0 && (U = "-" + U), U;
        }
        o(!1, "Base should be between 2 and 36");
      }, g.prototype.toNumber = function() {
        var A = this.words[0];
        return this.length === 2 ? A += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? A += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && o(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -A : A;
      }, g.prototype.toJSON = function() {
        return this.toString(16, 2);
      }, B && (g.prototype.toBuffer = function(A, I) {
        return this.toArrayLike(B, A, I);
      }), g.prototype.toArray = function(A, I) {
        return this.toArrayLike(Array, A, I);
      };
      var ue = function(A, I) {
        return A.allocUnsafe ? A.allocUnsafe(I) : new A(I);
      };
      g.prototype.toArrayLike = function(A, I, U) {
        this._strip();
        var X = this.byteLength(), Q = U || Math.max(1, X);
        o(X <= Q, "byte array longer than desired length"), o(Q > 0, "Requested array length <= 0");
        var F = ue(A, Q), $ = I === "le" ? "LE" : "BE";
        return this["_toArrayLike" + $](F, X), F;
      }, g.prototype._toArrayLikeLE = function(A, I) {
        for (var U = 0, X = 0, Q = 0, F = 0; Q < this.length; Q++) {
          var $ = this.words[Q] << F | X;
          A[U++] = $ & 255, U < A.length && (A[U++] = $ >> 8 & 255), U < A.length && (A[U++] = $ >> 16 & 255), F === 6 ? (U < A.length && (A[U++] = $ >> 24 & 255), X = 0, F = 0) : (X = $ >>> 24, F += 2);
        }
        if (U < A.length)
          for (A[U++] = X; U < A.length; )
            A[U++] = 0;
      }, g.prototype._toArrayLikeBE = function(A, I) {
        for (var U = A.length - 1, X = 0, Q = 0, F = 0; Q < this.length; Q++) {
          var $ = this.words[Q] << F | X;
          A[U--] = $ & 255, U >= 0 && (A[U--] = $ >> 8 & 255), U >= 0 && (A[U--] = $ >> 16 & 255), F === 6 ? (U >= 0 && (A[U--] = $ >> 24 & 255), X = 0, F = 0) : (X = $ >>> 24, F += 2);
        }
        if (U >= 0)
          for (A[U--] = X; U >= 0; )
            A[U--] = 0;
      }, Math.clz32 ? g.prototype._countBits = function(A) {
        return 32 - Math.clz32(A);
      } : g.prototype._countBits = function(A) {
        var I = A, U = 0;
        return I >= 4096 && (U += 13, I >>>= 13), I >= 64 && (U += 7, I >>>= 7), I >= 8 && (U += 4, I >>>= 4), I >= 2 && (U += 2, I >>>= 2), U + I;
      }, g.prototype._zeroBits = function(A) {
        if (A === 0)
          return 26;
        var I = A, U = 0;
        return I & 8191 || (U += 13, I >>>= 13), I & 127 || (U += 7, I >>>= 7), I & 15 || (U += 4, I >>>= 4), I & 3 || (U += 2, I >>>= 2), I & 1 || U++, U;
      }, g.prototype.bitLength = function() {
        var A = this.words[this.length - 1], I = this._countBits(A);
        return (this.length - 1) * 26 + I;
      };
      function fe(A) {
        for (var I = new Array(A.bitLength()), U = 0; U < I.length; U++) {
          var X = U / 26 | 0, Q = U % 26;
          I[U] = A.words[X] >>> Q & 1;
        }
        return I;
      }
      g.prototype.zeroBits = function() {
        if (this.isZero())
          return 0;
        for (var A = 0, I = 0; I < this.length; I++) {
          var U = this._zeroBits(this.words[I]);
          if (A += U, U !== 26)
            break;
        }
        return A;
      }, g.prototype.byteLength = function() {
        return Math.ceil(this.bitLength() / 8);
      }, g.prototype.toTwos = function(A) {
        return this.negative !== 0 ? this.abs().inotn(A).iaddn(1) : this.clone();
      }, g.prototype.fromTwos = function(A) {
        return this.testn(A - 1) ? this.notn(A).iaddn(1).ineg() : this.clone();
      }, g.prototype.isNeg = function() {
        return this.negative !== 0;
      }, g.prototype.neg = function() {
        return this.clone().ineg();
      }, g.prototype.ineg = function() {
        return this.isZero() || (this.negative ^= 1), this;
      }, g.prototype.iuor = function(A) {
        for (; this.length < A.length; )
          this.words[this.length++] = 0;
        for (var I = 0; I < A.length; I++)
          this.words[I] = this.words[I] | A.words[I];
        return this._strip();
      }, g.prototype.ior = function(A) {
        return o((this.negative | A.negative) === 0), this.iuor(A);
      }, g.prototype.or = function(A) {
        return this.length > A.length ? this.clone().ior(A) : A.clone().ior(this);
      }, g.prototype.uor = function(A) {
        return this.length > A.length ? this.clone().iuor(A) : A.clone().iuor(this);
      }, g.prototype.iuand = function(A) {
        var I;
        this.length > A.length ? I = A : I = this;
        for (var U = 0; U < I.length; U++)
          this.words[U] = this.words[U] & A.words[U];
        return this.length = I.length, this._strip();
      }, g.prototype.iand = function(A) {
        return o((this.negative | A.negative) === 0), this.iuand(A);
      }, g.prototype.and = function(A) {
        return this.length > A.length ? this.clone().iand(A) : A.clone().iand(this);
      }, g.prototype.uand = function(A) {
        return this.length > A.length ? this.clone().iuand(A) : A.clone().iuand(this);
      }, g.prototype.iuxor = function(A) {
        var I, U;
        this.length > A.length ? (I = this, U = A) : (I = A, U = this);
        for (var X = 0; X < U.length; X++)
          this.words[X] = I.words[X] ^ U.words[X];
        if (this !== I)
          for (; X < I.length; X++)
            this.words[X] = I.words[X];
        return this.length = I.length, this._strip();
      }, g.prototype.ixor = function(A) {
        return o((this.negative | A.negative) === 0), this.iuxor(A);
      }, g.prototype.xor = function(A) {
        return this.length > A.length ? this.clone().ixor(A) : A.clone().ixor(this);
      }, g.prototype.uxor = function(A) {
        return this.length > A.length ? this.clone().iuxor(A) : A.clone().iuxor(this);
      }, g.prototype.inotn = function(A) {
        o(typeof A == "number" && A >= 0);
        var I = Math.ceil(A / 26) | 0, U = A % 26;
        this._expand(I), U > 0 && I--;
        for (var X = 0; X < I; X++)
          this.words[X] = ~this.words[X] & 67108863;
        return U > 0 && (this.words[X] = ~this.words[X] & 67108863 >> 26 - U), this._strip();
      }, g.prototype.notn = function(A) {
        return this.clone().inotn(A);
      }, g.prototype.setn = function(A, I) {
        o(typeof A == "number" && A >= 0);
        var U = A / 26 | 0, X = A % 26;
        return this._expand(U + 1), I ? this.words[U] = this.words[U] | 1 << X : this.words[U] = this.words[U] & ~(1 << X), this._strip();
      }, g.prototype.iadd = function(A) {
        var I;
        if (this.negative !== 0 && A.negative === 0)
          return this.negative = 0, I = this.isub(A), this.negative ^= 1, this._normSign();
        if (this.negative === 0 && A.negative !== 0)
          return A.negative = 0, I = this.isub(A), A.negative = 1, I._normSign();
        var U, X;
        this.length > A.length ? (U = this, X = A) : (U = A, X = this);
        for (var Q = 0, F = 0; F < X.length; F++)
          I = (U.words[F] | 0) + (X.words[F] | 0) + Q, this.words[F] = I & 67108863, Q = I >>> 26;
        for (; Q !== 0 && F < U.length; F++)
          I = (U.words[F] | 0) + Q, this.words[F] = I & 67108863, Q = I >>> 26;
        if (this.length = U.length, Q !== 0)
          this.words[this.length] = Q, this.length++;
        else if (U !== this)
          for (; F < U.length; F++)
            this.words[F] = U.words[F];
        return this;
      }, g.prototype.add = function(A) {
        var I;
        return A.negative !== 0 && this.negative === 0 ? (A.negative = 0, I = this.sub(A), A.negative ^= 1, I) : A.negative === 0 && this.negative !== 0 ? (this.negative = 0, I = A.sub(this), this.negative = 1, I) : this.length > A.length ? this.clone().iadd(A) : A.clone().iadd(this);
      }, g.prototype.isub = function(A) {
        if (A.negative !== 0) {
          A.negative = 0;
          var I = this.iadd(A);
          return A.negative = 1, I._normSign();
        } else if (this.negative !== 0)
          return this.negative = 0, this.iadd(A), this.negative = 1, this._normSign();
        var U = this.cmp(A);
        if (U === 0)
          return this.negative = 0, this.length = 1, this.words[0] = 0, this;
        var X, Q;
        U > 0 ? (X = this, Q = A) : (X = A, Q = this);
        for (var F = 0, $ = 0; $ < Q.length; $++)
          I = (X.words[$] | 0) - (Q.words[$] | 0) + F, F = I >> 26, this.words[$] = I & 67108863;
        for (; F !== 0 && $ < X.length; $++)
          I = (X.words[$] | 0) + F, F = I >> 26, this.words[$] = I & 67108863;
        if (F === 0 && $ < X.length && X !== this)
          for (; $ < X.length; $++)
            this.words[$] = X.words[$];
        return this.length = Math.max(this.length, $), X !== this && (this.negative = 1), this._strip();
      }, g.prototype.sub = function(A) {
        return this.clone().isub(A);
      };
      function de(A, I, U) {
        U.negative = I.negative ^ A.negative;
        var X = A.length + I.length | 0;
        U.length = X, X = X - 1 | 0;
        var Q = A.words[0] | 0, F = I.words[0] | 0, $ = Q * F, H = $ & 67108863, q = $ / 67108864 | 0;
        U.words[0] = H;
        for (var z = 1; z < X; z++) {
          for (var me = q >>> 26, Ce = q & 67108863, je = Math.min(z, I.length - 1), Re = Math.max(0, z - A.length + 1); Re <= je; Re++) {
            var Ae = z - Re | 0;
            Q = A.words[Ae] | 0, F = I.words[Re] | 0, $ = Q * F + Ce, me += $ / 67108864 | 0, Ce = $ & 67108863;
          }
          U.words[z] = Ce | 0, q = me | 0;
        }
        return q !== 0 ? U.words[z] = q | 0 : U.length--, U._strip();
      }
      var ce = function(A, I, U) {
        var X = A.words, Q = I.words, F = U.words, $ = 0, H, q, z, me = X[0] | 0, Ce = me & 8191, je = me >>> 13, Re = X[1] | 0, Ae = Re & 8191, ke = Re >>> 13, Qe = X[2] | 0, Ze = Qe & 8191, qe = Qe >>> 13, Oe = X[3] | 0, Xe = Oe & 8191, et = Oe >>> 13, nt = X[4] | 0, re = nt & 8191, oe = nt >>> 13, le = X[5] | 0, ge = le & 8191, Ke = le >>> 13, Je = X[6] | 0, Fe = Je & 8191, Ye = Je >>> 13, it = X[7] | 0, rt = it & 8191, tt = it >>> 13, vt = X[8] | 0, St = vt & 8191, ot = vt >>> 13, si = X[9] | 0, oi = si & 8191, At = si >>> 13, Nn = Q[0] | 0, ui = Nn & 8191, Bt = Nn >>> 13, vi = Q[1] | 0, fi = vi & 8191, Ct = vi >>> 13, rM = Q[2] | 0, hi = rM & 8191, Tt = rM >>> 13, Dn = Q[3] | 0, di = Dn & 8191, Ot = Dn >>> 13, iM = Q[4] | 0, ci = iM & 8191, Dt = iM >>> 13, nM = Q[5] | 0, li = nM & 8191, ri = nM >>> 13, eM = Q[6] | 0, ai = eM & 8191, It = eM >>> 13, tM = Q[7] | 0, pi = tM & 8191, ii = tM >>> 13, oM = Q[8] | 0, gi = oM & 8191, ni = oM >>> 13, aM = Q[9] | 0, yi = aM & 8191, mi = aM >>> 13;
        U.negative = A.negative ^ I.negative, U.length = 19, H = Math.imul(Ce, ui), q = Math.imul(Ce, Bt), q = q + Math.imul(je, ui) | 0, z = Math.imul(je, Bt);
        var sM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (sM >>> 26) | 0, sM &= 67108863, H = Math.imul(Ae, ui), q = Math.imul(Ae, Bt), q = q + Math.imul(ke, ui) | 0, z = Math.imul(ke, Bt), H = H + Math.imul(Ce, fi) | 0, q = q + Math.imul(Ce, Ct) | 0, q = q + Math.imul(je, fi) | 0, z = z + Math.imul(je, Ct) | 0;
        var uM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (uM >>> 26) | 0, uM &= 67108863, H = Math.imul(Ze, ui), q = Math.imul(Ze, Bt), q = q + Math.imul(qe, ui) | 0, z = Math.imul(qe, Bt), H = H + Math.imul(Ae, fi) | 0, q = q + Math.imul(Ae, Ct) | 0, q = q + Math.imul(ke, fi) | 0, z = z + Math.imul(ke, Ct) | 0, H = H + Math.imul(Ce, hi) | 0, q = q + Math.imul(Ce, Tt) | 0, q = q + Math.imul(je, hi) | 0, z = z + Math.imul(je, Tt) | 0;
        var fM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (fM >>> 26) | 0, fM &= 67108863, H = Math.imul(Xe, ui), q = Math.imul(Xe, Bt), q = q + Math.imul(et, ui) | 0, z = Math.imul(et, Bt), H = H + Math.imul(Ze, fi) | 0, q = q + Math.imul(Ze, Ct) | 0, q = q + Math.imul(qe, fi) | 0, z = z + Math.imul(qe, Ct) | 0, H = H + Math.imul(Ae, hi) | 0, q = q + Math.imul(Ae, Tt) | 0, q = q + Math.imul(ke, hi) | 0, z = z + Math.imul(ke, Tt) | 0, H = H + Math.imul(Ce, di) | 0, q = q + Math.imul(Ce, Ot) | 0, q = q + Math.imul(je, di) | 0, z = z + Math.imul(je, Ot) | 0;
        var hM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (hM >>> 26) | 0, hM &= 67108863, H = Math.imul(re, ui), q = Math.imul(re, Bt), q = q + Math.imul(oe, ui) | 0, z = Math.imul(oe, Bt), H = H + Math.imul(Xe, fi) | 0, q = q + Math.imul(Xe, Ct) | 0, q = q + Math.imul(et, fi) | 0, z = z + Math.imul(et, Ct) | 0, H = H + Math.imul(Ze, hi) | 0, q = q + Math.imul(Ze, Tt) | 0, q = q + Math.imul(qe, hi) | 0, z = z + Math.imul(qe, Tt) | 0, H = H + Math.imul(Ae, di) | 0, q = q + Math.imul(Ae, Ot) | 0, q = q + Math.imul(ke, di) | 0, z = z + Math.imul(ke, Ot) | 0, H = H + Math.imul(Ce, ci) | 0, q = q + Math.imul(Ce, Dt) | 0, q = q + Math.imul(je, ci) | 0, z = z + Math.imul(je, Dt) | 0;
        var cM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (cM >>> 26) | 0, cM &= 67108863, H = Math.imul(ge, ui), q = Math.imul(ge, Bt), q = q + Math.imul(Ke, ui) | 0, z = Math.imul(Ke, Bt), H = H + Math.imul(re, fi) | 0, q = q + Math.imul(re, Ct) | 0, q = q + Math.imul(oe, fi) | 0, z = z + Math.imul(oe, Ct) | 0, H = H + Math.imul(Xe, hi) | 0, q = q + Math.imul(Xe, Tt) | 0, q = q + Math.imul(et, hi) | 0, z = z + Math.imul(et, Tt) | 0, H = H + Math.imul(Ze, di) | 0, q = q + Math.imul(Ze, Ot) | 0, q = q + Math.imul(qe, di) | 0, z = z + Math.imul(qe, Ot) | 0, H = H + Math.imul(Ae, ci) | 0, q = q + Math.imul(Ae, Dt) | 0, q = q + Math.imul(ke, ci) | 0, z = z + Math.imul(ke, Dt) | 0, H = H + Math.imul(Ce, li) | 0, q = q + Math.imul(Ce, ri) | 0, q = q + Math.imul(je, li) | 0, z = z + Math.imul(je, ri) | 0;
        var lM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (lM >>> 26) | 0, lM &= 67108863, H = Math.imul(Fe, ui), q = Math.imul(Fe, Bt), q = q + Math.imul(Ye, ui) | 0, z = Math.imul(Ye, Bt), H = H + Math.imul(ge, fi) | 0, q = q + Math.imul(ge, Ct) | 0, q = q + Math.imul(Ke, fi) | 0, z = z + Math.imul(Ke, Ct) | 0, H = H + Math.imul(re, hi) | 0, q = q + Math.imul(re, Tt) | 0, q = q + Math.imul(oe, hi) | 0, z = z + Math.imul(oe, Tt) | 0, H = H + Math.imul(Xe, di) | 0, q = q + Math.imul(Xe, Ot) | 0, q = q + Math.imul(et, di) | 0, z = z + Math.imul(et, Ot) | 0, H = H + Math.imul(Ze, ci) | 0, q = q + Math.imul(Ze, Dt) | 0, q = q + Math.imul(qe, ci) | 0, z = z + Math.imul(qe, Dt) | 0, H = H + Math.imul(Ae, li) | 0, q = q + Math.imul(Ae, ri) | 0, q = q + Math.imul(ke, li) | 0, z = z + Math.imul(ke, ri) | 0, H = H + Math.imul(Ce, ai) | 0, q = q + Math.imul(Ce, It) | 0, q = q + Math.imul(je, ai) | 0, z = z + Math.imul(je, It) | 0;
        var dM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (dM >>> 26) | 0, dM &= 67108863, H = Math.imul(rt, ui), q = Math.imul(rt, Bt), q = q + Math.imul(tt, ui) | 0, z = Math.imul(tt, Bt), H = H + Math.imul(Fe, fi) | 0, q = q + Math.imul(Fe, Ct) | 0, q = q + Math.imul(Ye, fi) | 0, z = z + Math.imul(Ye, Ct) | 0, H = H + Math.imul(ge, hi) | 0, q = q + Math.imul(ge, Tt) | 0, q = q + Math.imul(Ke, hi) | 0, z = z + Math.imul(Ke, Tt) | 0, H = H + Math.imul(re, di) | 0, q = q + Math.imul(re, Ot) | 0, q = q + Math.imul(oe, di) | 0, z = z + Math.imul(oe, Ot) | 0, H = H + Math.imul(Xe, ci) | 0, q = q + Math.imul(Xe, Dt) | 0, q = q + Math.imul(et, ci) | 0, z = z + Math.imul(et, Dt) | 0, H = H + Math.imul(Ze, li) | 0, q = q + Math.imul(Ze, ri) | 0, q = q + Math.imul(qe, li) | 0, z = z + Math.imul(qe, ri) | 0, H = H + Math.imul(Ae, ai) | 0, q = q + Math.imul(Ae, It) | 0, q = q + Math.imul(ke, ai) | 0, z = z + Math.imul(ke, It) | 0, H = H + Math.imul(Ce, pi) | 0, q = q + Math.imul(Ce, ii) | 0, q = q + Math.imul(je, pi) | 0, z = z + Math.imul(je, ii) | 0;
        var pM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (pM >>> 26) | 0, pM &= 67108863, H = Math.imul(St, ui), q = Math.imul(St, Bt), q = q + Math.imul(ot, ui) | 0, z = Math.imul(ot, Bt), H = H + Math.imul(rt, fi) | 0, q = q + Math.imul(rt, Ct) | 0, q = q + Math.imul(tt, fi) | 0, z = z + Math.imul(tt, Ct) | 0, H = H + Math.imul(Fe, hi) | 0, q = q + Math.imul(Fe, Tt) | 0, q = q + Math.imul(Ye, hi) | 0, z = z + Math.imul(Ye, Tt) | 0, H = H + Math.imul(ge, di) | 0, q = q + Math.imul(ge, Ot) | 0, q = q + Math.imul(Ke, di) | 0, z = z + Math.imul(Ke, Ot) | 0, H = H + Math.imul(re, ci) | 0, q = q + Math.imul(re, Dt) | 0, q = q + Math.imul(oe, ci) | 0, z = z + Math.imul(oe, Dt) | 0, H = H + Math.imul(Xe, li) | 0, q = q + Math.imul(Xe, ri) | 0, q = q + Math.imul(et, li) | 0, z = z + Math.imul(et, ri) | 0, H = H + Math.imul(Ze, ai) | 0, q = q + Math.imul(Ze, It) | 0, q = q + Math.imul(qe, ai) | 0, z = z + Math.imul(qe, It) | 0, H = H + Math.imul(Ae, pi) | 0, q = q + Math.imul(Ae, ii) | 0, q = q + Math.imul(ke, pi) | 0, z = z + Math.imul(ke, ii) | 0, H = H + Math.imul(Ce, gi) | 0, q = q + Math.imul(Ce, ni) | 0, q = q + Math.imul(je, gi) | 0, z = z + Math.imul(je, ni) | 0;
        var yM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (yM >>> 26) | 0, yM &= 67108863, H = Math.imul(oi, ui), q = Math.imul(oi, Bt), q = q + Math.imul(At, ui) | 0, z = Math.imul(At, Bt), H = H + Math.imul(St, fi) | 0, q = q + Math.imul(St, Ct) | 0, q = q + Math.imul(ot, fi) | 0, z = z + Math.imul(ot, Ct) | 0, H = H + Math.imul(rt, hi) | 0, q = q + Math.imul(rt, Tt) | 0, q = q + Math.imul(tt, hi) | 0, z = z + Math.imul(tt, Tt) | 0, H = H + Math.imul(Fe, di) | 0, q = q + Math.imul(Fe, Ot) | 0, q = q + Math.imul(Ye, di) | 0, z = z + Math.imul(Ye, Ot) | 0, H = H + Math.imul(ge, ci) | 0, q = q + Math.imul(ge, Dt) | 0, q = q + Math.imul(Ke, ci) | 0, z = z + Math.imul(Ke, Dt) | 0, H = H + Math.imul(re, li) | 0, q = q + Math.imul(re, ri) | 0, q = q + Math.imul(oe, li) | 0, z = z + Math.imul(oe, ri) | 0, H = H + Math.imul(Xe, ai) | 0, q = q + Math.imul(Xe, It) | 0, q = q + Math.imul(et, ai) | 0, z = z + Math.imul(et, It) | 0, H = H + Math.imul(Ze, pi) | 0, q = q + Math.imul(Ze, ii) | 0, q = q + Math.imul(qe, pi) | 0, z = z + Math.imul(qe, ii) | 0, H = H + Math.imul(Ae, gi) | 0, q = q + Math.imul(Ae, ni) | 0, q = q + Math.imul(ke, gi) | 0, z = z + Math.imul(ke, ni) | 0, H = H + Math.imul(Ce, yi) | 0, q = q + Math.imul(Ce, mi) | 0, q = q + Math.imul(je, yi) | 0, z = z + Math.imul(je, mi) | 0;
        var mM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (mM >>> 26) | 0, mM &= 67108863, H = Math.imul(oi, fi), q = Math.imul(oi, Ct), q = q + Math.imul(At, fi) | 0, z = Math.imul(At, Ct), H = H + Math.imul(St, hi) | 0, q = q + Math.imul(St, Tt) | 0, q = q + Math.imul(ot, hi) | 0, z = z + Math.imul(ot, Tt) | 0, H = H + Math.imul(rt, di) | 0, q = q + Math.imul(rt, Ot) | 0, q = q + Math.imul(tt, di) | 0, z = z + Math.imul(tt, Ot) | 0, H = H + Math.imul(Fe, ci) | 0, q = q + Math.imul(Fe, Dt) | 0, q = q + Math.imul(Ye, ci) | 0, z = z + Math.imul(Ye, Dt) | 0, H = H + Math.imul(ge, li) | 0, q = q + Math.imul(ge, ri) | 0, q = q + Math.imul(Ke, li) | 0, z = z + Math.imul(Ke, ri) | 0, H = H + Math.imul(re, ai) | 0, q = q + Math.imul(re, It) | 0, q = q + Math.imul(oe, ai) | 0, z = z + Math.imul(oe, It) | 0, H = H + Math.imul(Xe, pi) | 0, q = q + Math.imul(Xe, ii) | 0, q = q + Math.imul(et, pi) | 0, z = z + Math.imul(et, ii) | 0, H = H + Math.imul(Ze, gi) | 0, q = q + Math.imul(Ze, ni) | 0, q = q + Math.imul(qe, gi) | 0, z = z + Math.imul(qe, ni) | 0, H = H + Math.imul(Ae, yi) | 0, q = q + Math.imul(Ae, mi) | 0, q = q + Math.imul(ke, yi) | 0, z = z + Math.imul(ke, mi) | 0;
        var gM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (gM >>> 26) | 0, gM &= 67108863, H = Math.imul(oi, hi), q = Math.imul(oi, Tt), q = q + Math.imul(At, hi) | 0, z = Math.imul(At, Tt), H = H + Math.imul(St, di) | 0, q = q + Math.imul(St, Ot) | 0, q = q + Math.imul(ot, di) | 0, z = z + Math.imul(ot, Ot) | 0, H = H + Math.imul(rt, ci) | 0, q = q + Math.imul(rt, Dt) | 0, q = q + Math.imul(tt, ci) | 0, z = z + Math.imul(tt, Dt) | 0, H = H + Math.imul(Fe, li) | 0, q = q + Math.imul(Fe, ri) | 0, q = q + Math.imul(Ye, li) | 0, z = z + Math.imul(Ye, ri) | 0, H = H + Math.imul(ge, ai) | 0, q = q + Math.imul(ge, It) | 0, q = q + Math.imul(Ke, ai) | 0, z = z + Math.imul(Ke, It) | 0, H = H + Math.imul(re, pi) | 0, q = q + Math.imul(re, ii) | 0, q = q + Math.imul(oe, pi) | 0, z = z + Math.imul(oe, ii) | 0, H = H + Math.imul(Xe, gi) | 0, q = q + Math.imul(Xe, ni) | 0, q = q + Math.imul(et, gi) | 0, z = z + Math.imul(et, ni) | 0, H = H + Math.imul(Ze, yi) | 0, q = q + Math.imul(Ze, mi) | 0, q = q + Math.imul(qe, yi) | 0, z = z + Math.imul(qe, mi) | 0;
        var bM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (bM >>> 26) | 0, bM &= 67108863, H = Math.imul(oi, di), q = Math.imul(oi, Ot), q = q + Math.imul(At, di) | 0, z = Math.imul(At, Ot), H = H + Math.imul(St, ci) | 0, q = q + Math.imul(St, Dt) | 0, q = q + Math.imul(ot, ci) | 0, z = z + Math.imul(ot, Dt) | 0, H = H + Math.imul(rt, li) | 0, q = q + Math.imul(rt, ri) | 0, q = q + Math.imul(tt, li) | 0, z = z + Math.imul(tt, ri) | 0, H = H + Math.imul(Fe, ai) | 0, q = q + Math.imul(Fe, It) | 0, q = q + Math.imul(Ye, ai) | 0, z = z + Math.imul(Ye, It) | 0, H = H + Math.imul(ge, pi) | 0, q = q + Math.imul(ge, ii) | 0, q = q + Math.imul(Ke, pi) | 0, z = z + Math.imul(Ke, ii) | 0, H = H + Math.imul(re, gi) | 0, q = q + Math.imul(re, ni) | 0, q = q + Math.imul(oe, gi) | 0, z = z + Math.imul(oe, ni) | 0, H = H + Math.imul(Xe, yi) | 0, q = q + Math.imul(Xe, mi) | 0, q = q + Math.imul(et, yi) | 0, z = z + Math.imul(et, mi) | 0;
        var vM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (vM >>> 26) | 0, vM &= 67108863, H = Math.imul(oi, ci), q = Math.imul(oi, Dt), q = q + Math.imul(At, ci) | 0, z = Math.imul(At, Dt), H = H + Math.imul(St, li) | 0, q = q + Math.imul(St, ri) | 0, q = q + Math.imul(ot, li) | 0, z = z + Math.imul(ot, ri) | 0, H = H + Math.imul(rt, ai) | 0, q = q + Math.imul(rt, It) | 0, q = q + Math.imul(tt, ai) | 0, z = z + Math.imul(tt, It) | 0, H = H + Math.imul(Fe, pi) | 0, q = q + Math.imul(Fe, ii) | 0, q = q + Math.imul(Ye, pi) | 0, z = z + Math.imul(Ye, ii) | 0, H = H + Math.imul(ge, gi) | 0, q = q + Math.imul(ge, ni) | 0, q = q + Math.imul(Ke, gi) | 0, z = z + Math.imul(Ke, ni) | 0, H = H + Math.imul(re, yi) | 0, q = q + Math.imul(re, mi) | 0, q = q + Math.imul(oe, yi) | 0, z = z + Math.imul(oe, mi) | 0;
        var wM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (wM >>> 26) | 0, wM &= 67108863, H = Math.imul(oi, li), q = Math.imul(oi, ri), q = q + Math.imul(At, li) | 0, z = Math.imul(At, ri), H = H + Math.imul(St, ai) | 0, q = q + Math.imul(St, It) | 0, q = q + Math.imul(ot, ai) | 0, z = z + Math.imul(ot, It) | 0, H = H + Math.imul(rt, pi) | 0, q = q + Math.imul(rt, ii) | 0, q = q + Math.imul(tt, pi) | 0, z = z + Math.imul(tt, ii) | 0, H = H + Math.imul(Fe, gi) | 0, q = q + Math.imul(Fe, ni) | 0, q = q + Math.imul(Ye, gi) | 0, z = z + Math.imul(Ye, ni) | 0, H = H + Math.imul(ge, yi) | 0, q = q + Math.imul(ge, mi) | 0, q = q + Math.imul(Ke, yi) | 0, z = z + Math.imul(Ke, mi) | 0;
        var _M = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (_M >>> 26) | 0, _M &= 67108863, H = Math.imul(oi, ai), q = Math.imul(oi, It), q = q + Math.imul(At, ai) | 0, z = Math.imul(At, It), H = H + Math.imul(St, pi) | 0, q = q + Math.imul(St, ii) | 0, q = q + Math.imul(ot, pi) | 0, z = z + Math.imul(ot, ii) | 0, H = H + Math.imul(rt, gi) | 0, q = q + Math.imul(rt, ni) | 0, q = q + Math.imul(tt, gi) | 0, z = z + Math.imul(tt, ni) | 0, H = H + Math.imul(Fe, yi) | 0, q = q + Math.imul(Fe, mi) | 0, q = q + Math.imul(Ye, yi) | 0, z = z + Math.imul(Ye, mi) | 0;
        var SM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (SM >>> 26) | 0, SM &= 67108863, H = Math.imul(oi, pi), q = Math.imul(oi, ii), q = q + Math.imul(At, pi) | 0, z = Math.imul(At, ii), H = H + Math.imul(St, gi) | 0, q = q + Math.imul(St, ni) | 0, q = q + Math.imul(ot, gi) | 0, z = z + Math.imul(ot, ni) | 0, H = H + Math.imul(rt, yi) | 0, q = q + Math.imul(rt, mi) | 0, q = q + Math.imul(tt, yi) | 0, z = z + Math.imul(tt, mi) | 0;
        var EM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (EM >>> 26) | 0, EM &= 67108863, H = Math.imul(oi, gi), q = Math.imul(oi, ni), q = q + Math.imul(At, gi) | 0, z = Math.imul(At, ni), H = H + Math.imul(St, yi) | 0, q = q + Math.imul(St, mi) | 0, q = q + Math.imul(ot, yi) | 0, z = z + Math.imul(ot, mi) | 0;
        var AM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        $ = (z + (q >>> 13) | 0) + (AM >>> 26) | 0, AM &= 67108863, H = Math.imul(oi, yi), q = Math.imul(oi, mi), q = q + Math.imul(At, yi) | 0, z = Math.imul(At, mi);
        var MM = ($ + H | 0) + ((q & 8191) << 13) | 0;
        return $ = (z + (q >>> 13) | 0) + (MM >>> 26) | 0, MM &= 67108863, F[0] = sM, F[1] = uM, F[2] = fM, F[3] = hM, F[4] = cM, F[5] = lM, F[6] = dM, F[7] = pM, F[8] = yM, F[9] = mM, F[10] = gM, F[11] = bM, F[12] = vM, F[13] = wM, F[14] = _M, F[15] = SM, F[16] = EM, F[17] = AM, F[18] = MM, $ !== 0 && (F[19] = $, U.length++), U;
      };
      Math.imul || (ce = de);
      function be(A, I, U) {
        U.negative = I.negative ^ A.negative, U.length = A.length + I.length;
        for (var X = 0, Q = 0, F = 0; F < U.length - 1; F++) {
          var $ = Q;
          Q = 0;
          for (var H = X & 67108863, q = Math.min(F, I.length - 1), z = Math.max(0, F - A.length + 1); z <= q; z++) {
            var me = F - z, Ce = A.words[me] | 0, je = I.words[z] | 0, Re = Ce * je, Ae = Re & 67108863;
            $ = $ + (Re / 67108864 | 0) | 0, Ae = Ae + H | 0, H = Ae & 67108863, $ = $ + (Ae >>> 26) | 0, Q += $ >>> 26, $ &= 67108863;
          }
          U.words[F] = H, X = $, $ = Q;
        }
        return X !== 0 ? U.words[F] = X : U.length--, U._strip();
      }
      function ve(A, I, U) {
        return be(A, I, U);
      }
      g.prototype.mulTo = function(A, I) {
        var U, X = this.length + A.length;
        return this.length === 10 && A.length === 10 ? U = ce(this, A, I) : X < 63 ? U = de(this, A, I) : X < 1024 ? U = be(this, A, I) : U = ve(this, A, I), U;
      }, g.prototype.mul = function(A) {
        var I = new g(null);
        return I.words = new Array(this.length + A.length), this.mulTo(A, I);
      }, g.prototype.mulf = function(A) {
        var I = new g(null);
        return I.words = new Array(this.length + A.length), ve(this, A, I);
      }, g.prototype.imul = function(A) {
        return this.clone().mulTo(A, this);
      }, g.prototype.imuln = function(A) {
        var I = A < 0;
        I && (A = -A), o(typeof A == "number"), o(A < 67108864);
        for (var U = 0, X = 0; X < this.length; X++) {
          var Q = (this.words[X] | 0) * A, F = (Q & 67108863) + (U & 67108863);
          U >>= 26, U += Q / 67108864 | 0, U += F >>> 26, this.words[X] = F & 67108863;
        }
        return U !== 0 && (this.words[X] = U, this.length++), I ? this.ineg() : this;
      }, g.prototype.muln = function(A) {
        return this.clone().imuln(A);
      }, g.prototype.sqr = function() {
        return this.mul(this);
      }, g.prototype.isqr = function() {
        return this.imul(this.clone());
      }, g.prototype.pow = function(A) {
        var I = fe(A);
        if (I.length === 0)
          return new g(1);
        for (var U = this, X = 0; X < I.length && I[X] === 0; X++, U = U.sqr())
          ;
        if (++X < I.length)
          for (var Q = U.sqr(); X < I.length; X++, Q = Q.sqr())
            I[X] !== 0 && (U = U.mul(Q));
        return U;
      }, g.prototype.iushln = function(A) {
        o(typeof A == "number" && A >= 0);
        var I = A % 26, U = (A - I) / 26, X = 67108863 >>> 26 - I << 26 - I, Q;
        if (I !== 0) {
          var F = 0;
          for (Q = 0; Q < this.length; Q++) {
            var $ = this.words[Q] & X, H = (this.words[Q] | 0) - $ << I;
            this.words[Q] = H | F, F = $ >>> 26 - I;
          }
          F && (this.words[Q] = F, this.length++);
        }
        if (U !== 0) {
          for (Q = this.length - 1; Q >= 0; Q--)
            this.words[Q + U] = this.words[Q];
          for (Q = 0; Q < U; Q++)
            this.words[Q] = 0;
          this.length += U;
        }
        return this._strip();
      }, g.prototype.ishln = function(A) {
        return o(this.negative === 0), this.iushln(A);
      }, g.prototype.iushrn = function(A, I, U) {
        o(typeof A == "number" && A >= 0);
        var X;
        I ? X = (I - I % 26) / 26 : X = 0;
        var Q = A % 26, F = Math.min((A - Q) / 26, this.length), $ = 67108863 ^ 67108863 >>> Q << Q, H = U;
        if (X -= F, X = Math.max(0, X), H) {
          for (var q = 0; q < F; q++)
            H.words[q] = this.words[q];
          H.length = F;
        }
        if (F !== 0)
          if (this.length > F)
            for (this.length -= F, q = 0; q < this.length; q++)
              this.words[q] = this.words[q + F];
          else
            this.words[0] = 0, this.length = 1;
        var z = 0;
        for (q = this.length - 1; q >= 0 && (z !== 0 || q >= X); q--) {
          var me = this.words[q] | 0;
          this.words[q] = z << 26 - Q | me >>> Q, z = me & $;
        }
        return H && z !== 0 && (H.words[H.length++] = z), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
      }, g.prototype.ishrn = function(A, I, U) {
        return o(this.negative === 0), this.iushrn(A, I, U);
      }, g.prototype.shln = function(A) {
        return this.clone().ishln(A);
      }, g.prototype.ushln = function(A) {
        return this.clone().iushln(A);
      }, g.prototype.shrn = function(A) {
        return this.clone().ishrn(A);
      }, g.prototype.ushrn = function(A) {
        return this.clone().iushrn(A);
      }, g.prototype.testn = function(A) {
        o(typeof A == "number" && A >= 0);
        var I = A % 26, U = (A - I) / 26, X = 1 << I;
        if (this.length <= U)
          return !1;
        var Q = this.words[U];
        return !!(Q & X);
      }, g.prototype.imaskn = function(A) {
        o(typeof A == "number" && A >= 0);
        var I = A % 26, U = (A - I) / 26;
        if (o(this.negative === 0, "imaskn works only with positive numbers"), this.length <= U)
          return this;
        if (I !== 0 && U++, this.length = Math.min(U, this.length), I !== 0) {
          var X = 67108863 ^ 67108863 >>> I << I;
          this.words[this.length - 1] &= X;
        }
        return this._strip();
      }, g.prototype.maskn = function(A) {
        return this.clone().imaskn(A);
      }, g.prototype.iaddn = function(A) {
        return o(typeof A == "number"), o(A < 67108864), A < 0 ? this.isubn(-A) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= A ? (this.words[0] = A - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(A), this.negative = 1, this) : this._iaddn(A);
      }, g.prototype._iaddn = function(A) {
        this.words[0] += A;
        for (var I = 0; I < this.length && this.words[I] >= 67108864; I++)
          this.words[I] -= 67108864, I === this.length - 1 ? this.words[I + 1] = 1 : this.words[I + 1]++;
        return this.length = Math.max(this.length, I + 1), this;
      }, g.prototype.isubn = function(A) {
        if (o(typeof A == "number"), o(A < 67108864), A < 0)
          return this.iaddn(-A);
        if (this.negative !== 0)
          return this.negative = 0, this.iaddn(A), this.negative = 1, this;
        if (this.words[0] -= A, this.length === 1 && this.words[0] < 0)
          this.words[0] = -this.words[0], this.negative = 1;
        else
          for (var I = 0; I < this.length && this.words[I] < 0; I++)
            this.words[I] += 67108864, this.words[I + 1] -= 1;
        return this._strip();
      }, g.prototype.addn = function(A) {
        return this.clone().iaddn(A);
      }, g.prototype.subn = function(A) {
        return this.clone().isubn(A);
      }, g.prototype.iabs = function() {
        return this.negative = 0, this;
      }, g.prototype.abs = function() {
        return this.clone().iabs();
      }, g.prototype._ishlnsubmul = function(A, I, U) {
        var X = A.length + U, Q;
        this._expand(X);
        var F, $ = 0;
        for (Q = 0; Q < A.length; Q++) {
          F = (this.words[Q + U] | 0) + $;
          var H = (A.words[Q] | 0) * I;
          F -= H & 67108863, $ = (F >> 26) - (H / 67108864 | 0), this.words[Q + U] = F & 67108863;
        }
        for (; Q < this.length - U; Q++)
          F = (this.words[Q + U] | 0) + $, $ = F >> 26, this.words[Q + U] = F & 67108863;
        if ($ === 0)
          return this._strip();
        for (o($ === -1), $ = 0, Q = 0; Q < this.length; Q++)
          F = -(this.words[Q] | 0) + $, $ = F >> 26, this.words[Q] = F & 67108863;
        return this.negative = 1, this._strip();
      }, g.prototype._wordDiv = function(A, I) {
        var U = this.length - A.length, X = this.clone(), Q = A, F = Q.words[Q.length - 1] | 0, $ = this._countBits(F);
        U = 26 - $, U !== 0 && (Q = Q.ushln(U), X.iushln(U), F = Q.words[Q.length - 1] | 0);
        var H = X.length - Q.length, q;
        if (I !== "mod") {
          q = new g(null), q.length = H + 1, q.words = new Array(q.length);
          for (var z = 0; z < q.length; z++)
            q.words[z] = 0;
        }
        var me = X.clone()._ishlnsubmul(Q, 1, H);
        me.negative === 0 && (X = me, q && (q.words[H] = 1));
        for (var Ce = H - 1; Ce >= 0; Ce--) {
          var je = (X.words[Q.length + Ce] | 0) * 67108864 + (X.words[Q.length + Ce - 1] | 0);
          for (je = Math.min(je / F | 0, 67108863), X._ishlnsubmul(Q, je, Ce); X.negative !== 0; )
            je--, X.negative = 0, X._ishlnsubmul(Q, 1, Ce), X.isZero() || (X.negative ^= 1);
          q && (q.words[Ce] = je);
        }
        return q && q._strip(), X._strip(), I !== "div" && U !== 0 && X.iushrn(U), {
          div: q || null,
          mod: X
        };
      }, g.prototype.divmod = function(A, I, U) {
        if (o(!A.isZero()), this.isZero())
          return {
            div: new g(0),
            mod: new g(0)
          };
        var X, Q, F;
        return this.negative !== 0 && A.negative === 0 ? (F = this.neg().divmod(A, I), I !== "mod" && (X = F.div.neg()), I !== "div" && (Q = F.mod.neg(), U && Q.negative !== 0 && Q.iadd(A)), {
          div: X,
          mod: Q
        }) : this.negative === 0 && A.negative !== 0 ? (F = this.divmod(A.neg(), I), I !== "mod" && (X = F.div.neg()), {
          div: X,
          mod: F.mod
        }) : this.negative & A.negative ? (F = this.neg().divmod(A.neg(), I), I !== "div" && (Q = F.mod.neg(), U && Q.negative !== 0 && Q.isub(A)), {
          div: F.div,
          mod: Q
        }) : A.length > this.length || this.cmp(A) < 0 ? {
          div: new g(0),
          mod: this
        } : A.length === 1 ? I === "div" ? {
          div: this.divn(A.words[0]),
          mod: null
        } : I === "mod" ? {
          div: null,
          mod: new g(this.modrn(A.words[0]))
        } : {
          div: this.divn(A.words[0]),
          mod: new g(this.modrn(A.words[0]))
        } : this._wordDiv(A, I);
      }, g.prototype.div = function(A) {
        return this.divmod(A, "div", !1).div;
      }, g.prototype.mod = function(A) {
        return this.divmod(A, "mod", !1).mod;
      }, g.prototype.umod = function(A) {
        return this.divmod(A, "mod", !0).mod;
      }, g.prototype.divRound = function(A) {
        var I = this.divmod(A);
        if (I.mod.isZero())
          return I.div;
        var U = I.div.negative !== 0 ? I.mod.isub(A) : I.mod, X = A.ushrn(1), Q = A.andln(1), F = U.cmp(X);
        return F < 0 || Q === 1 && F === 0 ? I.div : I.div.negative !== 0 ? I.div.isubn(1) : I.div.iaddn(1);
      }, g.prototype.modrn = function(A) {
        var I = A < 0;
        I && (A = -A), o(A <= 67108863);
        for (var U = (1 << 26) % A, X = 0, Q = this.length - 1; Q >= 0; Q--)
          X = (U * X + (this.words[Q] | 0)) % A;
        return I ? -X : X;
      }, g.prototype.modn = function(A) {
        return this.modrn(A);
      }, g.prototype.idivn = function(A) {
        var I = A < 0;
        I && (A = -A), o(A <= 67108863);
        for (var U = 0, X = this.length - 1; X >= 0; X--) {
          var Q = (this.words[X] | 0) + U * 67108864;
          this.words[X] = Q / A | 0, U = Q % A;
        }
        return this._strip(), I ? this.ineg() : this;
      }, g.prototype.divn = function(A) {
        return this.clone().idivn(A);
      }, g.prototype.egcd = function(A) {
        o(A.negative === 0), o(!A.isZero());
        var I = this, U = A.clone();
        I.negative !== 0 ? I = I.umod(A) : I = I.clone();
        for (var X = new g(1), Q = new g(0), F = new g(0), $ = new g(1), H = 0; I.isEven() && U.isEven(); )
          I.iushrn(1), U.iushrn(1), ++H;
        for (var q = U.clone(), z = I.clone(); !I.isZero(); ) {
          for (var me = 0, Ce = 1; !(I.words[0] & Ce) && me < 26; ++me, Ce <<= 1)
            ;
          if (me > 0)
            for (I.iushrn(me); me-- > 0; )
              (X.isOdd() || Q.isOdd()) && (X.iadd(q), Q.isub(z)), X.iushrn(1), Q.iushrn(1);
          for (var je = 0, Re = 1; !(U.words[0] & Re) && je < 26; ++je, Re <<= 1)
            ;
          if (je > 0)
            for (U.iushrn(je); je-- > 0; )
              (F.isOdd() || $.isOdd()) && (F.iadd(q), $.isub(z)), F.iushrn(1), $.iushrn(1);
          I.cmp(U) >= 0 ? (I.isub(U), X.isub(F), Q.isub($)) : (U.isub(I), F.isub(X), $.isub(Q));
        }
        return {
          a: F,
          b: $,
          gcd: U.iushln(H)
        };
      }, g.prototype._invmp = function(A) {
        o(A.negative === 0), o(!A.isZero());
        var I = this, U = A.clone();
        I.negative !== 0 ? I = I.umod(A) : I = I.clone();
        for (var X = new g(1), Q = new g(0), F = U.clone(); I.cmpn(1) > 0 && U.cmpn(1) > 0; ) {
          for (var $ = 0, H = 1; !(I.words[0] & H) && $ < 26; ++$, H <<= 1)
            ;
          if ($ > 0)
            for (I.iushrn($); $-- > 0; )
              X.isOdd() && X.iadd(F), X.iushrn(1);
          for (var q = 0, z = 1; !(U.words[0] & z) && q < 26; ++q, z <<= 1)
            ;
          if (q > 0)
            for (U.iushrn(q); q-- > 0; )
              Q.isOdd() && Q.iadd(F), Q.iushrn(1);
          I.cmp(U) >= 0 ? (I.isub(U), X.isub(Q)) : (U.isub(I), Q.isub(X));
        }
        var me;
        return I.cmpn(1) === 0 ? me = X : me = Q, me.cmpn(0) < 0 && me.iadd(A), me;
      }, g.prototype.gcd = function(A) {
        if (this.isZero())
          return A.abs();
        if (A.isZero())
          return this.abs();
        var I = this.clone(), U = A.clone();
        I.negative = 0, U.negative = 0;
        for (var X = 0; I.isEven() && U.isEven(); X++)
          I.iushrn(1), U.iushrn(1);
        do {
          for (; I.isEven(); )
            I.iushrn(1);
          for (; U.isEven(); )
            U.iushrn(1);
          var Q = I.cmp(U);
          if (Q < 0) {
            var F = I;
            I = U, U = F;
          } else if (Q === 0 || U.cmpn(1) === 0)
            break;
          I.isub(U);
        } while (!0);
        return U.iushln(X);
      }, g.prototype.invm = function(A) {
        return this.egcd(A).a.umod(A);
      }, g.prototype.isEven = function() {
        return (this.words[0] & 1) === 0;
      }, g.prototype.isOdd = function() {
        return (this.words[0] & 1) === 1;
      }, g.prototype.andln = function(A) {
        return this.words[0] & A;
      }, g.prototype.bincn = function(A) {
        o(typeof A == "number");
        var I = A % 26, U = (A - I) / 26, X = 1 << I;
        if (this.length <= U)
          return this._expand(U + 1), this.words[U] |= X, this;
        for (var Q = X, F = U; Q !== 0 && F < this.length; F++) {
          var $ = this.words[F] | 0;
          $ += Q, Q = $ >>> 26, $ &= 67108863, this.words[F] = $;
        }
        return Q !== 0 && (this.words[F] = Q, this.length++), this;
      }, g.prototype.isZero = function() {
        return this.length === 1 && this.words[0] === 0;
      }, g.prototype.cmpn = function(A) {
        var I = A < 0;
        if (this.negative !== 0 && !I)
          return -1;
        if (this.negative === 0 && I)
          return 1;
        this._strip();
        var U;
        if (this.length > 1)
          U = 1;
        else {
          I && (A = -A), o(A <= 67108863, "Number is too big");
          var X = this.words[0] | 0;
          U = X === A ? 0 : X < A ? -1 : 1;
        }
        return this.negative !== 0 ? -U | 0 : U;
      }, g.prototype.cmp = function(A) {
        if (this.negative !== 0 && A.negative === 0)
          return -1;
        if (this.negative === 0 && A.negative !== 0)
          return 1;
        var I = this.ucmp(A);
        return this.negative !== 0 ? -I | 0 : I;
      }, g.prototype.ucmp = function(A) {
        if (this.length > A.length)
          return 1;
        if (this.length < A.length)
          return -1;
        for (var I = 0, U = this.length - 1; U >= 0; U--) {
          var X = this.words[U] | 0, Q = A.words[U] | 0;
          if (X !== Q) {
            X < Q ? I = -1 : X > Q && (I = 1);
            break;
          }
        }
        return I;
      }, g.prototype.gtn = function(A) {
        return this.cmpn(A) === 1;
      }, g.prototype.gt = function(A) {
        return this.cmp(A) === 1;
      }, g.prototype.gten = function(A) {
        return this.cmpn(A) >= 0;
      }, g.prototype.gte = function(A) {
        return this.cmp(A) >= 0;
      }, g.prototype.ltn = function(A) {
        return this.cmpn(A) === -1;
      }, g.prototype.lt = function(A) {
        return this.cmp(A) === -1;
      }, g.prototype.lten = function(A) {
        return this.cmpn(A) <= 0;
      }, g.prototype.lte = function(A) {
        return this.cmp(A) <= 0;
      }, g.prototype.eqn = function(A) {
        return this.cmpn(A) === 0;
      }, g.prototype.eq = function(A) {
        return this.cmp(A) === 0;
      }, g.red = function(A) {
        return new J(A);
      }, g.prototype.toRed = function(A) {
        return o(!this.red, "Already a number in reduction context"), o(this.negative === 0, "red works only with positives"), A.convertTo(this)._forceRed(A);
      }, g.prototype.fromRed = function() {
        return o(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
      }, g.prototype._forceRed = function(A) {
        return this.red = A, this;
      }, g.prototype.forceRed = function(A) {
        return o(!this.red, "Already a number in reduction context"), this._forceRed(A);
      }, g.prototype.redAdd = function(A) {
        return o(this.red, "redAdd works only with red numbers"), this.red.add(this, A);
      }, g.prototype.redIAdd = function(A) {
        return o(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, A);
      }, g.prototype.redSub = function(A) {
        return o(this.red, "redSub works only with red numbers"), this.red.sub(this, A);
      }, g.prototype.redISub = function(A) {
        return o(this.red, "redISub works only with red numbers"), this.red.isub(this, A);
      }, g.prototype.redShl = function(A) {
        return o(this.red, "redShl works only with red numbers"), this.red.shl(this, A);
      }, g.prototype.redMul = function(A) {
        return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, A), this.red.mul(this, A);
      }, g.prototype.redIMul = function(A) {
        return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, A), this.red.imul(this, A);
      }, g.prototype.redSqr = function() {
        return o(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
      }, g.prototype.redISqr = function() {
        return o(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
      }, g.prototype.redSqrt = function() {
        return o(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
      }, g.prototype.redInvm = function() {
        return o(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
      }, g.prototype.redNeg = function() {
        return o(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
      }, g.prototype.redPow = function(A) {
        return o(this.red && !A.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, A);
      };
      var Pe = {
        k256: null,
        p224: null,
        p192: null,
        p25519: null
      };
      function Ue(A, I) {
        this.name = A, this.p = new g(I, 16), this.n = this.p.bitLength(), this.k = new g(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
      }
      Ue.prototype._tmp = function() {
        var A = new g(null);
        return A.words = new Array(Math.ceil(this.n / 13)), A;
      }, Ue.prototype.ireduce = function(A) {
        var I = A, U;
        do
          this.split(I, this.tmp), I = this.imulK(I), I = I.iadd(this.tmp), U = I.bitLength();
        while (U > this.n);
        var X = U < this.n ? -1 : I.ucmp(this.p);
        return X === 0 ? (I.words[0] = 0, I.length = 1) : X > 0 ? I.isub(this.p) : I.strip !== void 0 ? I.strip() : I._strip(), I;
      }, Ue.prototype.split = function(A, I) {
        A.iushrn(this.n, 0, I);
      }, Ue.prototype.imulK = function(A) {
        return A.imul(this.k);
      };
      function ze() {
        Ue.call(
          this,
          "k256",
          "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
        );
      }
      S(ze, Ue), ze.prototype.split = function(A, I) {
        for (var U = 4194303, X = Math.min(A.length, 9), Q = 0; Q < X; Q++)
          I.words[Q] = A.words[Q];
        if (I.length = X, A.length <= 9) {
          A.words[0] = 0, A.length = 1;
          return;
        }
        var F = A.words[9];
        for (I.words[I.length++] = F & U, Q = 10; Q < A.length; Q++) {
          var $ = A.words[Q] | 0;
          A.words[Q - 10] = ($ & U) << 4 | F >>> 22, F = $;
        }
        F >>>= 22, A.words[Q - 10] = F, F === 0 && A.length > 10 ? A.length -= 10 : A.length -= 9;
      }, ze.prototype.imulK = function(A) {
        A.words[A.length] = 0, A.words[A.length + 1] = 0, A.length += 2;
        for (var I = 0, U = 0; U < A.length; U++) {
          var X = A.words[U] | 0;
          I += X * 977, A.words[U] = I & 67108863, I = X * 64 + (I / 67108864 | 0);
        }
        return A.words[A.length - 1] === 0 && (A.length--, A.words[A.length - 1] === 0 && A.length--), A;
      };
      function Le() {
        Ue.call(
          this,
          "p224",
          "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
        );
      }
      S(Le, Ue);
      function Ne() {
        Ue.call(
          this,
          "p192",
          "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
        );
      }
      S(Ne, Ue);
      function $e() {
        Ue.call(
          this,
          "25519",
          "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
        );
      }
      S($e, Ue), $e.prototype.imulK = function(A) {
        for (var I = 0, U = 0; U < A.length; U++) {
          var X = (A.words[U] | 0) * 19 + I, Q = X & 67108863;
          X >>>= 26, A.words[U] = Q, I = X;
        }
        return I !== 0 && (A.words[A.length++] = I), A;
      }, g._prime = function(A) {
        if (Pe[A])
          return Pe[A];
        var I;
        if (A === "k256")
          I = new ze();
        else if (A === "p224")
          I = new Le();
        else if (A === "p192")
          I = new Ne();
        else if (A === "p25519")
          I = new $e();
        else
          throw new Error("Unknown prime " + A);
        return Pe[A] = I, I;
      };
      function J(A) {
        if (typeof A == "string") {
          var I = g._prime(A);
          this.m = I.p, this.prime = I;
        } else
          o(A.gtn(1), "modulus must be greater than 1"), this.m = A, this.prime = null;
      }
      J.prototype._verify1 = function(A) {
        o(A.negative === 0, "red works only with positives"), o(A.red, "red works only with red numbers");
      }, J.prototype._verify2 = function(A, I) {
        o((A.negative | I.negative) === 0, "red works only with positives"), o(
          A.red && A.red === I.red,
          "red works only with red numbers"
        );
      }, J.prototype.imod = function(A) {
        return this.prime ? this.prime.ireduce(A)._forceRed(this) : (D(A, A.umod(this.m)._forceRed(this)), A);
      }, J.prototype.neg = function(A) {
        return A.isZero() ? A.clone() : this.m.sub(A)._forceRed(this);
      }, J.prototype.add = function(A, I) {
        this._verify2(A, I);
        var U = A.add(I);
        return U.cmp(this.m) >= 0 && U.isub(this.m), U._forceRed(this);
      }, J.prototype.iadd = function(A, I) {
        this._verify2(A, I);
        var U = A.iadd(I);
        return U.cmp(this.m) >= 0 && U.isub(this.m), U;
      }, J.prototype.sub = function(A, I) {
        this._verify2(A, I);
        var U = A.sub(I);
        return U.cmpn(0) < 0 && U.iadd(this.m), U._forceRed(this);
      }, J.prototype.isub = function(A, I) {
        this._verify2(A, I);
        var U = A.isub(I);
        return U.cmpn(0) < 0 && U.iadd(this.m), U;
      }, J.prototype.shl = function(A, I) {
        return this._verify1(A), this.imod(A.ushln(I));
      }, J.prototype.imul = function(A, I) {
        return this._verify2(A, I), this.imod(A.imul(I));
      }, J.prototype.mul = function(A, I) {
        return this._verify2(A, I), this.imod(A.mul(I));
      }, J.prototype.isqr = function(A) {
        return this.imul(A, A.clone());
      }, J.prototype.sqr = function(A) {
        return this.mul(A, A);
      }, J.prototype.sqrt = function(A) {
        if (A.isZero())
          return A.clone();
        var I = this.m.andln(3);
        if (o(I % 2 === 1), I === 3) {
          var U = this.m.add(new g(1)).iushrn(2);
          return this.pow(A, U);
        }
        for (var X = this.m.subn(1), Q = 0; !X.isZero() && X.andln(1) === 0; )
          Q++, X.iushrn(1);
        o(!X.isZero());
        var F = new g(1).toRed(this), $ = F.redNeg(), H = this.m.subn(1).iushrn(1), q = this.m.bitLength();
        for (q = new g(2 * q * q).toRed(this); this.pow(q, H).cmp($) !== 0; )
          q.redIAdd($);
        for (var z = this.pow(q, X), me = this.pow(A, X.addn(1).iushrn(1)), Ce = this.pow(A, X), je = Q; Ce.cmp(F) !== 0; ) {
          for (var Re = Ce, Ae = 0; Re.cmp(F) !== 0; Ae++)
            Re = Re.redSqr();
          o(Ae < je);
          var ke = this.pow(z, new g(1).iushln(je - Ae - 1));
          me = me.redMul(ke), z = ke.redSqr(), Ce = Ce.redMul(z), je = Ae;
        }
        return me;
      }, J.prototype.invm = function(A) {
        var I = A._invmp(this.m);
        return I.negative !== 0 ? (I.negative = 0, this.imod(I).redNeg()) : this.imod(I);
      }, J.prototype.pow = function(A, I) {
        if (I.isZero())
          return new g(1).toRed(this);
        if (I.cmpn(1) === 0)
          return A.clone();
        var U = 4, X = new Array(1 << U);
        X[0] = new g(1).toRed(this), X[1] = A;
        for (var Q = 2; Q < X.length; Q++)
          X[Q] = this.mul(X[Q - 1], A);
        var F = X[0], $ = 0, H = 0, q = I.bitLength() % 26;
        for (q === 0 && (q = 26), Q = I.length - 1; Q >= 0; Q--) {
          for (var z = I.words[Q], me = q - 1; me >= 0; me--) {
            var Ce = z >> me & 1;
            if (F !== X[0] && (F = this.sqr(F)), Ce === 0 && $ === 0) {
              H = 0;
              continue;
            }
            $ <<= 1, $ |= Ce, H++, !(H !== U && (Q !== 0 || me !== 0)) && (F = this.mul(F, X[$]), H = 0, $ = 0);
          }
          q = 26;
        }
        return F;
      }, J.prototype.convertTo = function(A) {
        var I = A.umod(this.m);
        return I === A ? I.clone() : I;
      }, J.prototype.convertFrom = function(A) {
        var I = A.clone();
        return I.red = null, I;
      }, g.mont = function(A) {
        return new ne(A);
      };
      function ne(A) {
        J.call(this, A), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new g(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
      }
      S(ne, J), ne.prototype.convertTo = function(A) {
        return this.imod(A.ushln(this.shift));
      }, ne.prototype.convertFrom = function(A) {
        var I = this.imod(A.mul(this.rinv));
        return I.red = null, I;
      }, ne.prototype.imul = function(A, I) {
        if (A.isZero() || I.isZero())
          return A.words[0] = 0, A.length = 1, A;
        var U = A.imul(I), X = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Q = U.isub(X).iushrn(this.shift), F = Q;
        return Q.cmp(this.m) >= 0 ? F = Q.isub(this.m) : Q.cmpn(0) < 0 && (F = Q.iadd(this.m)), F._forceRed(this);
      }, ne.prototype.mul = function(A, I) {
        if (A.isZero() || I.isZero())
          return new g(0)._forceRed(this);
        var U = A.mul(I), X = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Q = U.isub(X).iushrn(this.shift), F = Q;
        return Q.cmp(this.m) >= 0 ? F = Q.isub(this.m) : Q.cmpn(0) < 0 && (F = Q.iadd(this.m)), F._forceRed(this);
      }, ne.prototype.invm = function(A) {
        var I = this.imod(A._invmp(this.m).mul(this.r2));
        return I._forceRed(this);
      };
    })(e, commonjsGlobal);
  }(bn$3)), bn$3.exports;
}
var asn1$1 = {}, asn1 = {}, api = {}, vmBrowserify = {}, hasRequiredVmBrowserify;
function requireVmBrowserify() {
  return hasRequiredVmBrowserify || (hasRequiredVmBrowserify = 1, function(exports) {
    var indexOf = function(e, t) {
      if (e.indexOf)
        return e.indexOf(t);
      for (var h = 0; h < e.length; h++)
        if (e[h] === t)
          return h;
      return -1;
    }, Object_keys = function(e) {
      if (Object.keys)
        return Object.keys(e);
      var t = [];
      for (var h in e)
        t.push(h);
      return t;
    }, forEach = function(e, t) {
      if (e.forEach)
        return e.forEach(t);
      for (var h = 0; h < e.length; h++)
        t(e[h], h, e);
    }, defineProp = function() {
      try {
        return Object.defineProperty({}, "_", {}), function(e, t, h) {
          Object.defineProperty(e, t, {
            writable: !0,
            enumerable: !1,
            configurable: !0,
            value: h
          });
        };
      } catch {
        return function(e, t, h) {
          e[t] = h;
        };
      }
    }(), globals = [
      "Array",
      "Boolean",
      "Date",
      "Error",
      "EvalError",
      "Function",
      "Infinity",
      "JSON",
      "Math",
      "NaN",
      "Number",
      "Object",
      "RangeError",
      "ReferenceError",
      "RegExp",
      "String",
      "SyntaxError",
      "TypeError",
      "URIError",
      "decodeURI",
      "decodeURIComponent",
      "encodeURI",
      "encodeURIComponent",
      "escape",
      "eval",
      "isFinite",
      "isNaN",
      "parseFloat",
      "parseInt",
      "undefined",
      "unescape"
    ];
    function Context() {
    }
    Context.prototype = {};
    var Script = exports.Script = function(e) {
      if (!(this instanceof Script))
        return new Script(e);
      this.code = e;
    };
    Script.prototype.runInContext = function(e) {
      if (!(e instanceof Context))
        throw new TypeError("needs a 'context' argument.");
      var t = document.createElement("iframe");
      t.style || (t.style = {}), t.style.display = "none", document.body.appendChild(t);
      var h = t.contentWindow, o = h.eval, S = h.execScript;
      !o && S && (S.call(h, "null"), o = h.eval), forEach(Object_keys(e), function(M) {
        h[M] = e[M];
      }), forEach(globals, function(M) {
        e[M] && (h[M] = e[M]);
      });
      var g = Object_keys(h), B = o.call(h, this.code);
      return forEach(Object_keys(h), function(M) {
        (M in e || indexOf(g, M) === -1) && (e[M] = h[M]);
      }), forEach(globals, function(M) {
        M in e || defineProp(e, M, h[M]);
      }), document.body.removeChild(t), B;
    }, Script.prototype.runInThisContext = function() {
      return eval(this.code);
    }, Script.prototype.runInNewContext = function(e) {
      var t = Script.createContext(e), h = this.runInContext(t);
      return e && forEach(Object_keys(t), function(o) {
        e[o] = t[o];
      }), h;
    }, forEach(Object_keys(Script.prototype), function(e) {
      exports[e] = Script[e] = function(t) {
        var h = Script(t);
        return h[e].apply(h, [].slice.call(arguments, 1));
      };
    }), exports.isContext = function(e) {
      return e instanceof Context;
    }, exports.createScript = function(e) {
      return exports.Script(e);
    }, exports.createContext = Script.createContext = function(e) {
      var t = new Context();
      return typeof e == "object" && forEach(Object_keys(e), function(h) {
        t[h] = e[h];
      }), t;
    };
  }(vmBrowserify)), vmBrowserify;
}
var hasRequiredApi;
function requireApi() {
  return hasRequiredApi || (hasRequiredApi = 1, function(e) {
    var t = requireAsn1$1(), h = requireInherits_browser(), o = e;
    o.define = function(g, B) {
      return new S(g, B);
    };
    function S(g, B) {
      this.name = g, this.body = B, this.decoders = {}, this.encoders = {};
    }
    S.prototype._createNamed = function(g) {
      var B;
      try {
        B = requireVmBrowserify().runInThisContext(
          "(function " + this.name + `(entity) {
  this._initNamed(entity);
})`
        );
      } catch {
        B = function(M) {
          this._initNamed(M);
        };
      }
      return h(B, g), B.prototype._initNamed = function(M) {
        g.call(this, M);
      }, new B(this);
    }, S.prototype._getDecoder = function(g) {
      return g = g || "der", this.decoders.hasOwnProperty(g) || (this.decoders[g] = this._createNamed(t.decoders[g])), this.decoders[g];
    }, S.prototype.decode = function(g, B, M) {
      return this._getDecoder(B).decode(g, M);
    }, S.prototype._getEncoder = function(g) {
      return g = g || "der", this.encoders.hasOwnProperty(g) || (this.encoders[g] = this._createNamed(t.encoders[g])), this.encoders[g];
    }, S.prototype.encode = function(g, B, M) {
      return this._getEncoder(B).encode(g, M);
    };
  }(api)), api;
}
var base = {}, reporter = {}, hasRequiredReporter;
function requireReporter() {
  if (hasRequiredReporter)
    return reporter;
  hasRequiredReporter = 1;
  var e = requireInherits_browser();
  function t(o) {
    this._reporterState = {
      obj: null,
      path: [],
      options: o || {},
      errors: []
    };
  }
  reporter.Reporter = t, t.prototype.isError = function(o) {
    return o instanceof h;
  }, t.prototype.save = function() {
    var o = this._reporterState;
    return { obj: o.obj, pathLen: o.path.length };
  }, t.prototype.restore = function(o) {
    var S = this._reporterState;
    S.obj = o.obj, S.path = S.path.slice(0, o.pathLen);
  }, t.prototype.enterKey = function(o) {
    return this._reporterState.path.push(o);
  }, t.prototype.exitKey = function(o) {
    var S = this._reporterState;
    S.path = S.path.slice(0, o - 1);
  }, t.prototype.leaveKey = function(o, S, g) {
    var B = this._reporterState;
    this.exitKey(o), B.obj !== null && (B.obj[S] = g);
  }, t.prototype.path = function() {
    return this._reporterState.path.join("/");
  }, t.prototype.enterObject = function() {
    var o = this._reporterState, S = o.obj;
    return o.obj = {}, S;
  }, t.prototype.leaveObject = function(o) {
    var S = this._reporterState, g = S.obj;
    return S.obj = o, g;
  }, t.prototype.error = function(o) {
    var S, g = this._reporterState, B = o instanceof h;
    if (B ? S = o : S = new h(g.path.map(function(M) {
      return "[" + JSON.stringify(M) + "]";
    }).join(""), o.message || o, o.stack), !g.options.partial)
      throw S;
    return B || g.errors.push(S), S;
  }, t.prototype.wrapResult = function(o) {
    var S = this._reporterState;
    return S.options.partial ? {
      result: this.isError(o) ? null : o,
      errors: S.errors
    } : o;
  };
  function h(o, S) {
    this.path = o, this.rethrow(S);
  }
  return e(h, Error), h.prototype.rethrow = function(o) {
    if (this.message = o + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, h), !this.stack)
      try {
        throw new Error(this.message);
      } catch (S) {
        this.stack = S.stack;
      }
    return this;
  }, reporter;
}
var buffer = {}, hasRequiredBuffer;
function requireBuffer() {
  if (hasRequiredBuffer)
    return buffer;
  hasRequiredBuffer = 1;
  var e = requireInherits_browser(), t = requireBase().Reporter, h = requireBuffer$1().Buffer;
  function o(g, B) {
    if (t.call(this, B), !h.isBuffer(g)) {
      this.error("Input not Buffer");
      return;
    }
    this.base = g, this.offset = 0, this.length = g.length;
  }
  e(o, t), buffer.DecoderBuffer = o, o.prototype.save = function() {
    return { offset: this.offset, reporter: t.prototype.save.call(this) };
  }, o.prototype.restore = function(g) {
    var B = new o(this.base);
    return B.offset = g.offset, B.length = this.offset, this.offset = g.offset, t.prototype.restore.call(this, g.reporter), B;
  }, o.prototype.isEmpty = function() {
    return this.offset === this.length;
  }, o.prototype.readUInt8 = function(g) {
    return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(g || "DecoderBuffer overrun");
  }, o.prototype.skip = function(g, B) {
    if (!(this.offset + g <= this.length))
      return this.error(B || "DecoderBuffer overrun");
    var M = new o(this.base);
    return M._reporterState = this._reporterState, M.offset = this.offset, M.length = this.offset + g, this.offset += g, M;
  }, o.prototype.raw = function(g) {
    return this.base.slice(g ? g.offset : this.offset, this.length);
  };
  function S(g, B) {
    if (Array.isArray(g))
      this.length = 0, this.value = g.map(function(M) {
        return M instanceof S || (M = new S(M, B)), this.length += M.length, M;
      }, this);
    else if (typeof g == "number") {
      if (!(0 <= g && g <= 255))
        return B.error("non-byte EncoderBuffer value");
      this.value = g, this.length = 1;
    } else if (typeof g == "string")
      this.value = g, this.length = h.byteLength(g);
    else if (h.isBuffer(g))
      this.value = g, this.length = g.length;
    else
      return B.error("Unsupported type: " + typeof g);
  }
  return buffer.EncoderBuffer = S, S.prototype.join = function(g, B) {
    return g || (g = new h(this.length)), B || (B = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(M) {
      M.join(g, B), B += M.length;
    }) : (typeof this.value == "number" ? g[B] = this.value : typeof this.value == "string" ? g.write(this.value, B) : h.isBuffer(this.value) && this.value.copy(g, B), B += this.length)), g;
  }, buffer;
}
var node, hasRequiredNode;
function requireNode() {
  if (hasRequiredNode)
    return node;
  hasRequiredNode = 1;
  var e = requireBase().Reporter, t = requireBase().EncoderBuffer, h = requireBase().DecoderBuffer, o = requireMinimalisticAssert(), S = [
    "seq",
    "seqof",
    "set",
    "setof",
    "objid",
    "bool",
    "gentime",
    "utctime",
    "null_",
    "enum",
    "int",
    "objDesc",
    "bitstr",
    "bmpstr",
    "charstr",
    "genstr",
    "graphstr",
    "ia5str",
    "iso646str",
    "numstr",
    "octstr",
    "printstr",
    "t61str",
    "unistr",
    "utf8str",
    "videostr"
  ], g = [
    "key",
    "obj",
    "use",
    "optional",
    "explicit",
    "implicit",
    "def",
    "choice",
    "any",
    "contains"
  ].concat(S), B = [
    "_peekTag",
    "_decodeTag",
    "_use",
    "_decodeStr",
    "_decodeObjid",
    "_decodeTime",
    "_decodeNull",
    "_decodeInt",
    "_decodeBool",
    "_decodeList",
    "_encodeComposite",
    "_encodeStr",
    "_encodeObjid",
    "_encodeTime",
    "_encodeNull",
    "_encodeInt",
    "_encodeBool"
  ];
  function M(P, D) {
    var Z = {};
    this._baseState = Z, Z.enc = P, Z.parent = D || null, Z.children = null, Z.tag = null, Z.args = null, Z.reverseArgs = null, Z.choice = null, Z.optional = !1, Z.any = !1, Z.obj = !1, Z.use = null, Z.useDecoder = null, Z.key = null, Z.default = null, Z.explicit = null, Z.implicit = null, Z.contains = null, Z.parent || (Z.children = [], this._wrap());
  }
  node = M;
  var O = [
    "enc",
    "parent",
    "children",
    "tag",
    "args",
    "reverseArgs",
    "choice",
    "optional",
    "any",
    "obj",
    "use",
    "alteredUse",
    "key",
    "default",
    "explicit",
    "implicit",
    "contains"
  ];
  return M.prototype.clone = function() {
    var P = this._baseState, D = {};
    O.forEach(function(Y) {
      D[Y] = P[Y];
    });
    var Z = new this.constructor(D.parent);
    return Z._baseState = D, Z;
  }, M.prototype._wrap = function() {
    var P = this._baseState;
    g.forEach(function(D) {
      this[D] = function() {
        var Z = new this.constructor(this);
        return P.children.push(Z), Z[D].apply(Z, arguments);
      };
    }, this);
  }, M.prototype._init = function(P) {
    var D = this._baseState;
    o(D.parent === null), P.call(this), D.children = D.children.filter(function(Z) {
      return Z._baseState.parent === this;
    }, this), o.equal(D.children.length, 1, "Root node can have only one child");
  }, M.prototype._useArgs = function(P) {
    var D = this._baseState, Z = P.filter(function(Y) {
      return Y instanceof this.constructor;
    }, this);
    P = P.filter(function(Y) {
      return !(Y instanceof this.constructor);
    }, this), Z.length !== 0 && (o(D.children === null), D.children = Z, Z.forEach(function(Y) {
      Y._baseState.parent = this;
    }, this)), P.length !== 0 && (o(D.args === null), D.args = P, D.reverseArgs = P.map(function(Y) {
      if (typeof Y != "object" || Y.constructor !== Object)
        return Y;
      var ee = {};
      return Object.keys(Y).forEach(function(ie) {
        ie == (ie | 0) && (ie |= 0);
        var ue = Y[ie];
        ee[ue] = ie;
      }), ee;
    }));
  }, B.forEach(function(P) {
    M.prototype[P] = function() {
      var D = this._baseState;
      throw new Error(P + " not implemented for encoding: " + D.enc);
    };
  }), S.forEach(function(P) {
    M.prototype[P] = function() {
      var D = this._baseState, Z = Array.prototype.slice.call(arguments);
      return o(D.tag === null), D.tag = P, this._useArgs(Z), this;
    };
  }), M.prototype.use = function(P) {
    o(P);
    var D = this._baseState;
    return o(D.use === null), D.use = P, this;
  }, M.prototype.optional = function() {
    var P = this._baseState;
    return P.optional = !0, this;
  }, M.prototype.def = function(P) {
    var D = this._baseState;
    return o(D.default === null), D.default = P, D.optional = !0, this;
  }, M.prototype.explicit = function(P) {
    var D = this._baseState;
    return o(D.explicit === null && D.implicit === null), D.explicit = P, this;
  }, M.prototype.implicit = function(P) {
    var D = this._baseState;
    return o(D.explicit === null && D.implicit === null), D.implicit = P, this;
  }, M.prototype.obj = function() {
    var P = this._baseState, D = Array.prototype.slice.call(arguments);
    return P.obj = !0, D.length !== 0 && this._useArgs(D), this;
  }, M.prototype.key = function(P) {
    var D = this._baseState;
    return o(D.key === null), D.key = P, this;
  }, M.prototype.any = function() {
    var P = this._baseState;
    return P.any = !0, this;
  }, M.prototype.choice = function(P) {
    var D = this._baseState;
    return o(D.choice === null), D.choice = P, this._useArgs(Object.keys(P).map(function(Z) {
      return P[Z];
    })), this;
  }, M.prototype.contains = function(P) {
    var D = this._baseState;
    return o(D.use === null), D.contains = P, this;
  }, M.prototype._decode = function(P, D) {
    var Z = this._baseState;
    if (Z.parent === null)
      return P.wrapResult(Z.children[0]._decode(P, D));
    var Y = Z.default, ee = !0, ie = null;
    if (Z.key !== null && (ie = P.enterKey(Z.key)), Z.optional) {
      var ue = null;
      if (Z.explicit !== null ? ue = Z.explicit : Z.implicit !== null ? ue = Z.implicit : Z.tag !== null && (ue = Z.tag), ue === null && !Z.any) {
        var fe = P.save();
        try {
          Z.choice === null ? this._decodeGeneric(Z.tag, P, D) : this._decodeChoice(P, D), ee = !0;
        } catch {
          ee = !1;
        }
        P.restore(fe);
      } else if (ee = this._peekTag(P, ue, Z.any), P.isError(ee))
        return ee;
    }
    var de;
    if (Z.obj && ee && (de = P.enterObject()), ee) {
      if (Z.explicit !== null) {
        var ce = this._decodeTag(P, Z.explicit);
        if (P.isError(ce))
          return ce;
        P = ce;
      }
      var be = P.offset;
      if (Z.use === null && Z.choice === null) {
        if (Z.any)
          var fe = P.save();
        var ve = this._decodeTag(
          P,
          Z.implicit !== null ? Z.implicit : Z.tag,
          Z.any
        );
        if (P.isError(ve))
          return ve;
        Z.any ? Y = P.raw(fe) : P = ve;
      }
      if (D && D.track && Z.tag !== null && D.track(P.path(), be, P.length, "tagged"), D && D.track && Z.tag !== null && D.track(P.path(), P.offset, P.length, "content"), Z.any ? Y = Y : Z.choice === null ? Y = this._decodeGeneric(Z.tag, P, D) : Y = this._decodeChoice(P, D), P.isError(Y))
        return Y;
      if (!Z.any && Z.choice === null && Z.children !== null && Z.children.forEach(function(Ue) {
        Ue._decode(P, D);
      }), Z.contains && (Z.tag === "octstr" || Z.tag === "bitstr")) {
        var Pe = new h(Y);
        Y = this._getUse(Z.contains, P._reporterState.obj)._decode(Pe, D);
      }
    }
    return Z.obj && ee && (Y = P.leaveObject(de)), Z.key !== null && (Y !== null || ee === !0) ? P.leaveKey(ie, Z.key, Y) : ie !== null && P.exitKey(ie), Y;
  }, M.prototype._decodeGeneric = function(P, D, Z) {
    var Y = this._baseState;
    return P === "seq" || P === "set" ? null : P === "seqof" || P === "setof" ? this._decodeList(D, P, Y.args[0], Z) : /str$/.test(P) ? this._decodeStr(D, P, Z) : P === "objid" && Y.args ? this._decodeObjid(D, Y.args[0], Y.args[1], Z) : P === "objid" ? this._decodeObjid(D, null, null, Z) : P === "gentime" || P === "utctime" ? this._decodeTime(D, P, Z) : P === "null_" ? this._decodeNull(D, Z) : P === "bool" ? this._decodeBool(D, Z) : P === "objDesc" ? this._decodeStr(D, P, Z) : P === "int" || P === "enum" ? this._decodeInt(D, Y.args && Y.args[0], Z) : Y.use !== null ? this._getUse(Y.use, D._reporterState.obj)._decode(D, Z) : D.error("unknown tag: " + P);
  }, M.prototype._getUse = function(P, D) {
    var Z = this._baseState;
    return Z.useDecoder = this._use(P, D), o(Z.useDecoder._baseState.parent === null), Z.useDecoder = Z.useDecoder._baseState.children[0], Z.implicit !== Z.useDecoder._baseState.implicit && (Z.useDecoder = Z.useDecoder.clone(), Z.useDecoder._baseState.implicit = Z.implicit), Z.useDecoder;
  }, M.prototype._decodeChoice = function(P, D) {
    var Z = this._baseState, Y = null, ee = !1;
    return Object.keys(Z.choice).some(function(ie) {
      var ue = P.save(), fe = Z.choice[ie];
      try {
        var de = fe._decode(P, D);
        if (P.isError(de))
          return !1;
        Y = { type: ie, value: de }, ee = !0;
      } catch {
        return P.restore(ue), !1;
      }
      return !0;
    }, this), ee ? Y : P.error("Choice not matched");
  }, M.prototype._createEncoderBuffer = function(P) {
    return new t(P, this.reporter);
  }, M.prototype._encode = function(P, D, Z) {
    var Y = this._baseState;
    if (!(Y.default !== null && Y.default === P)) {
      var ee = this._encodeValue(P, D, Z);
      if (ee !== void 0 && !this._skipDefault(ee, D, Z))
        return ee;
    }
  }, M.prototype._encodeValue = function(P, D, Z) {
    var Y = this._baseState;
    if (Y.parent === null)
      return Y.children[0]._encode(P, D || new e());
    var fe = null;
    if (this.reporter = D, Y.optional && P === void 0)
      if (Y.default !== null)
        P = Y.default;
      else
        return;
    var ee = null, ie = !1;
    if (Y.any)
      fe = this._createEncoderBuffer(P);
    else if (Y.choice)
      fe = this._encodeChoice(P, D);
    else if (Y.contains)
      ee = this._getUse(Y.contains, Z)._encode(P, D), ie = !0;
    else if (Y.children)
      ee = Y.children.map(function(be) {
        if (be._baseState.tag === "null_")
          return be._encode(null, D, P);
        if (be._baseState.key === null)
          return D.error("Child should have a key");
        var ve = D.enterKey(be._baseState.key);
        if (typeof P != "object")
          return D.error("Child expected, but input is not object");
        var Pe = be._encode(P[be._baseState.key], D, P);
        return D.leaveKey(ve), Pe;
      }, this).filter(function(be) {
        return be;
      }), ee = this._createEncoderBuffer(ee);
    else if (Y.tag === "seqof" || Y.tag === "setof") {
      if (!(Y.args && Y.args.length === 1))
        return D.error("Too many args for : " + Y.tag);
      if (!Array.isArray(P))
        return D.error("seqof/setof, but data is not Array");
      var ue = this.clone();
      ue._baseState.implicit = null, ee = this._createEncoderBuffer(P.map(function(be) {
        var ve = this._baseState;
        return this._getUse(ve.args[0], P)._encode(be, D);
      }, ue));
    } else
      Y.use !== null ? fe = this._getUse(Y.use, Z)._encode(P, D) : (ee = this._encodePrimitive(Y.tag, P), ie = !0);
    var fe;
    if (!Y.any && Y.choice === null) {
      var de = Y.implicit !== null ? Y.implicit : Y.tag, ce = Y.implicit === null ? "universal" : "context";
      de === null ? Y.use === null && D.error("Tag could be omitted only for .use()") : Y.use === null && (fe = this._encodeComposite(de, ie, ce, ee));
    }
    return Y.explicit !== null && (fe = this._encodeComposite(Y.explicit, !1, "context", fe)), fe;
  }, M.prototype._encodeChoice = function(P, D) {
    var Z = this._baseState, Y = Z.choice[P.type];
    return Y || o(
      !1,
      P.type + " not found in " + JSON.stringify(Object.keys(Z.choice))
    ), Y._encode(P.value, D);
  }, M.prototype._encodePrimitive = function(P, D) {
    var Z = this._baseState;
    if (/str$/.test(P))
      return this._encodeStr(D, P);
    if (P === "objid" && Z.args)
      return this._encodeObjid(D, Z.reverseArgs[0], Z.args[1]);
    if (P === "objid")
      return this._encodeObjid(D, null, null);
    if (P === "gentime" || P === "utctime")
      return this._encodeTime(D, P);
    if (P === "null_")
      return this._encodeNull();
    if (P === "int" || P === "enum")
      return this._encodeInt(D, Z.args && Z.reverseArgs[0]);
    if (P === "bool")
      return this._encodeBool(D);
    if (P === "objDesc")
      return this._encodeStr(D, P);
    throw new Error("Unsupported tag: " + P);
  }, M.prototype._isNumstr = function(P) {
    return /^[0-9 ]*$/.test(P);
  }, M.prototype._isPrintstr = function(P) {
    return /^[A-Za-z0-9 '\(\)\+,\-\.\/:=\?]*$/.test(P);
  }, node;
}
var hasRequiredBase;
function requireBase() {
  return hasRequiredBase || (hasRequiredBase = 1, function(e) {
    var t = e;
    t.Reporter = requireReporter().Reporter, t.DecoderBuffer = requireBuffer().DecoderBuffer, t.EncoderBuffer = requireBuffer().EncoderBuffer, t.Node = requireNode();
  }(base)), base;
}
var constants = {}, der = {}, hasRequiredDer$2;
function requireDer$2() {
  return hasRequiredDer$2 || (hasRequiredDer$2 = 1, function(e) {
    var t = requireConstants();
    e.tagClass = {
      0: "universal",
      1: "application",
      2: "context",
      3: "private"
    }, e.tagClassByName = t._reverse(e.tagClass), e.tag = {
      0: "end",
      1: "bool",
      2: "int",
      3: "bitstr",
      4: "octstr",
      5: "null_",
      6: "objid",
      7: "objDesc",
      8: "external",
      9: "real",
      10: "enum",
      11: "embed",
      12: "utf8str",
      13: "relativeOid",
      16: "seq",
      17: "set",
      18: "numstr",
      19: "printstr",
      20: "t61str",
      21: "videostr",
      22: "ia5str",
      23: "utctime",
      24: "gentime",
      25: "graphstr",
      26: "iso646str",
      27: "genstr",
      28: "unistr",
      29: "charstr",
      30: "bmpstr"
    }, e.tagByName = t._reverse(e.tag);
  }(der)), der;
}
var hasRequiredConstants;
function requireConstants() {
  return hasRequiredConstants || (hasRequiredConstants = 1, function(e) {
    var t = e;
    t._reverse = function(h) {
      var o = {};
      return Object.keys(h).forEach(function(S) {
        (S | 0) == S && (S = S | 0);
        var g = h[S];
        o[g] = S;
      }), o;
    }, t.der = requireDer$2();
  }(constants)), constants;
}
var decoders = {}, der_1$1, hasRequiredDer$1;
function requireDer$1() {
  if (hasRequiredDer$1)
    return der_1$1;
  hasRequiredDer$1 = 1;
  var e = requireInherits_browser(), t = requireAsn1$1(), h = t.base, o = t.bignum, S = t.constants.der;
  function g(P) {
    this.enc = "der", this.name = P.name, this.entity = P, this.tree = new B(), this.tree._init(P.body);
  }
  der_1$1 = g, g.prototype.decode = function(P, D) {
    return P instanceof h.DecoderBuffer || (P = new h.DecoderBuffer(P, D)), this.tree._decode(P, D);
  };
  function B(P) {
    h.Node.call(this, "der", P);
  }
  e(B, h.Node), B.prototype._peekTag = function(P, D, Z) {
    if (P.isEmpty())
      return !1;
    var Y = P.save(), ee = M(P, 'Failed to peek tag: "' + D + '"');
    return P.isError(ee) ? ee : (P.restore(Y), ee.tag === D || ee.tagStr === D || ee.tagStr + "of" === D || Z);
  }, B.prototype._decodeTag = function(P, D, Z) {
    var Y = M(
      P,
      'Failed to decode tag of "' + D + '"'
    );
    if (P.isError(Y))
      return Y;
    var ee = O(
      P,
      Y.primitive,
      'Failed to get length of "' + D + '"'
    );
    if (P.isError(ee))
      return ee;
    if (!Z && Y.tag !== D && Y.tagStr !== D && Y.tagStr + "of" !== D)
      return P.error('Failed to match tag: "' + D + '"');
    if (Y.primitive || ee !== null)
      return P.skip(ee, 'Failed to match body of: "' + D + '"');
    var ie = P.save(), ue = this._skipUntilEnd(
      P,
      'Failed to skip indefinite length body: "' + this.tag + '"'
    );
    return P.isError(ue) ? ue : (ee = P.offset - ie.offset, P.restore(ie), P.skip(ee, 'Failed to match body of: "' + D + '"'));
  }, B.prototype._skipUntilEnd = function(P, D) {
    for (; ; ) {
      var Z = M(P, D);
      if (P.isError(Z))
        return Z;
      var Y = O(P, Z.primitive, D);
      if (P.isError(Y))
        return Y;
      var ee;
      if (Z.primitive || Y !== null ? ee = P.skip(Y) : ee = this._skipUntilEnd(P, D), P.isError(ee))
        return ee;
      if (Z.tagStr === "end")
        break;
    }
  }, B.prototype._decodeList = function(P, D, Z, Y) {
    for (var ee = []; !P.isEmpty(); ) {
      var ie = this._peekTag(P, "end");
      if (P.isError(ie))
        return ie;
      var ue = Z.decode(P, "der", Y);
      if (P.isError(ue) && ie)
        break;
      ee.push(ue);
    }
    return ee;
  }, B.prototype._decodeStr = function(P, D) {
    if (D === "bitstr") {
      var Z = P.readUInt8();
      return P.isError(Z) ? Z : { unused: Z, data: P.raw() };
    } else if (D === "bmpstr") {
      var Y = P.raw();
      if (Y.length % 2 === 1)
        return P.error("Decoding of string type: bmpstr length mismatch");
      for (var ee = "", ie = 0; ie < Y.length / 2; ie++)
        ee += String.fromCharCode(Y.readUInt16BE(ie * 2));
      return ee;
    } else if (D === "numstr") {
      var ue = P.raw().toString("ascii");
      return this._isNumstr(ue) ? ue : P.error("Decoding of string type: numstr unsupported characters");
    } else {
      if (D === "octstr" || D === "objDesc")
        return P.raw();
      if (D === "printstr") {
        var fe = P.raw().toString("ascii");
        return this._isPrintstr(fe) ? fe : P.error("Decoding of string type: printstr unsupported characters");
      } else
        return /str$/.test(D) ? P.raw().toString() : P.error("Decoding of string type: " + D + " unsupported");
    }
  }, B.prototype._decodeObjid = function(P, D, Z) {
    for (var Y, ee = [], ie = 0; !P.isEmpty(); ) {
      var ue = P.readUInt8();
      ie <<= 7, ie |= ue & 127, ue & 128 || (ee.push(ie), ie = 0);
    }
    ue & 128 && ee.push(ie);
    var fe = ee[0] / 40 | 0, de = ee[0] % 40;
    if (Z ? Y = ee : Y = [fe, de].concat(ee.slice(1)), D) {
      var ce = D[Y.join(" ")];
      ce === void 0 && (ce = D[Y.join(".")]), ce !== void 0 && (Y = ce);
    }
    return Y;
  }, B.prototype._decodeTime = function(P, D) {
    var Z = P.raw().toString();
    if (D === "gentime")
      var Y = Z.slice(0, 4) | 0, ee = Z.slice(4, 6) | 0, ie = Z.slice(6, 8) | 0, ue = Z.slice(8, 10) | 0, fe = Z.slice(10, 12) | 0, de = Z.slice(12, 14) | 0;
    else if (D === "utctime") {
      var Y = Z.slice(0, 2) | 0, ee = Z.slice(2, 4) | 0, ie = Z.slice(4, 6) | 0, ue = Z.slice(6, 8) | 0, fe = Z.slice(8, 10) | 0, de = Z.slice(10, 12) | 0;
      Y < 70 ? Y = 2e3 + Y : Y = 1900 + Y;
    } else
      return P.error("Decoding " + D + " time is not supported yet");
    return Date.UTC(Y, ee - 1, ie, ue, fe, de, 0);
  }, B.prototype._decodeNull = function(P) {
    return null;
  }, B.prototype._decodeBool = function(P) {
    var D = P.readUInt8();
    return P.isError(D) ? D : D !== 0;
  }, B.prototype._decodeInt = function(P, D) {
    var Z = P.raw(), Y = new o(Z);
    return D && (Y = D[Y.toString(10)] || Y), Y;
  }, B.prototype._use = function(P, D) {
    return typeof P == "function" && (P = P(D)), P._getDecoder("der").tree;
  };
  function M(P, D) {
    var Z = P.readUInt8(D);
    if (P.isError(Z))
      return Z;
    var Y = S.tagClass[Z >> 6], ee = (Z & 32) === 0;
    if ((Z & 31) === 31) {
      var ie = Z;
      for (Z = 0; (ie & 128) === 128; ) {
        if (ie = P.readUInt8(D), P.isError(ie))
          return ie;
        Z <<= 7, Z |= ie & 127;
      }
    } else
      Z &= 31;
    var ue = S.tag[Z];
    return {
      cls: Y,
      primitive: ee,
      tag: Z,
      tagStr: ue
    };
  }
  function O(P, D, Z) {
    var Y = P.readUInt8(Z);
    if (P.isError(Y))
      return Y;
    if (!D && Y === 128)
      return null;
    if (!(Y & 128))
      return Y;
    var ee = Y & 127;
    if (ee > 4)
      return P.error("length octect is too long");
    Y = 0;
    for (var ie = 0; ie < ee; ie++) {
      Y <<= 8;
      var ue = P.readUInt8(Z);
      if (P.isError(ue))
        return ue;
      Y |= ue;
    }
    return Y;
  }
  return der_1$1;
}
var pem$1, hasRequiredPem$1;
function requirePem$1() {
  if (hasRequiredPem$1)
    return pem$1;
  hasRequiredPem$1 = 1;
  var e = requireInherits_browser(), t = requireBuffer$1().Buffer, h = requireDer$1();
  function o(S) {
    h.call(this, S), this.enc = "pem";
  }
  return e(o, h), pem$1 = o, o.prototype.decode = function(S, g) {
    for (var B = S.toString().split(/[\r\n]+/g), M = g.label.toUpperCase(), O = /^-----(BEGIN|END) ([^-]+)-----$/, P = -1, D = -1, Z = 0; Z < B.length; Z++) {
      var Y = B[Z].match(O);
      if (Y !== null && Y[2] === M)
        if (P === -1) {
          if (Y[1] !== "BEGIN")
            break;
          P = Z;
        } else {
          if (Y[1] !== "END")
            break;
          D = Z;
          break;
        }
    }
    if (P === -1 || D === -1)
      throw new Error("PEM section not found for: " + M);
    var ee = B.slice(P + 1, D).join("");
    ee.replace(/[^a-z0-9\+\/=]+/gi, "");
    var ie = new t(ee, "base64");
    return h.prototype.decode.call(this, ie, g);
  }, pem$1;
}
var hasRequiredDecoders;
function requireDecoders() {
  return hasRequiredDecoders || (hasRequiredDecoders = 1, function(e) {
    var t = e;
    t.der = requireDer$1(), t.pem = requirePem$1();
  }(decoders)), decoders;
}
var encoders = {}, der_1, hasRequiredDer;
function requireDer() {
  if (hasRequiredDer)
    return der_1;
  hasRequiredDer = 1;
  var e = requireInherits_browser(), t = requireBuffer$1().Buffer, h = requireAsn1$1(), o = h.base, S = h.constants.der;
  function g(P) {
    this.enc = "der", this.name = P.name, this.entity = P, this.tree = new B(), this.tree._init(P.body);
  }
  der_1 = g, g.prototype.encode = function(P, D) {
    return this.tree._encode(P, D).join();
  };
  function B(P) {
    o.Node.call(this, "der", P);
  }
  e(B, o.Node), B.prototype._encodeComposite = function(P, D, Z, Y) {
    var ee = O(P, D, Z, this.reporter);
    if (Y.length < 128) {
      var fe = new t(2);
      return fe[0] = ee, fe[1] = Y.length, this._createEncoderBuffer([fe, Y]);
    }
    for (var ie = 1, ue = Y.length; ue >= 256; ue >>= 8)
      ie++;
    var fe = new t(2 + ie);
    fe[0] = ee, fe[1] = 128 | ie;
    for (var ue = 1 + ie, de = Y.length; de > 0; ue--, de >>= 8)
      fe[ue] = de & 255;
    return this._createEncoderBuffer([fe, Y]);
  }, B.prototype._encodeStr = function(P, D) {
    if (D === "bitstr")
      return this._createEncoderBuffer([P.unused | 0, P.data]);
    if (D === "bmpstr") {
      for (var Z = new t(P.length * 2), Y = 0; Y < P.length; Y++)
        Z.writeUInt16BE(P.charCodeAt(Y), Y * 2);
      return this._createEncoderBuffer(Z);
    } else
      return D === "numstr" ? this._isNumstr(P) ? this._createEncoderBuffer(P) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : D === "printstr" ? this._isPrintstr(P) ? this._createEncoderBuffer(P) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(D) ? this._createEncoderBuffer(P) : D === "objDesc" ? this._createEncoderBuffer(P) : this.reporter.error("Encoding of string type: " + D + " unsupported");
  }, B.prototype._encodeObjid = function(P, D, Z) {
    if (typeof P == "string") {
      if (!D)
        return this.reporter.error("string objid given, but no values map found");
      if (!D.hasOwnProperty(P))
        return this.reporter.error("objid not found in values map");
      P = D[P].split(/[\s\.]+/g);
      for (var Y = 0; Y < P.length; Y++)
        P[Y] |= 0;
    } else if (Array.isArray(P)) {
      P = P.slice();
      for (var Y = 0; Y < P.length; Y++)
        P[Y] |= 0;
    }
    if (!Array.isArray(P))
      return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(P));
    if (!Z) {
      if (P[1] >= 40)
        return this.reporter.error("Second objid identifier OOB");
      P.splice(0, 2, P[0] * 40 + P[1]);
    }
    for (var ee = 0, Y = 0; Y < P.length; Y++) {
      var ie = P[Y];
      for (ee++; ie >= 128; ie >>= 7)
        ee++;
    }
    for (var ue = new t(ee), fe = ue.length - 1, Y = P.length - 1; Y >= 0; Y--) {
      var ie = P[Y];
      for (ue[fe--] = ie & 127; (ie >>= 7) > 0; )
        ue[fe--] = 128 | ie & 127;
    }
    return this._createEncoderBuffer(ue);
  };
  function M(P) {
    return P < 10 ? "0" + P : P;
  }
  B.prototype._encodeTime = function(P, D) {
    var Z, Y = new Date(P);
    return D === "gentime" ? Z = [
      M(Y.getFullYear()),
      M(Y.getUTCMonth() + 1),
      M(Y.getUTCDate()),
      M(Y.getUTCHours()),
      M(Y.getUTCMinutes()),
      M(Y.getUTCSeconds()),
      "Z"
    ].join("") : D === "utctime" ? Z = [
      M(Y.getFullYear() % 100),
      M(Y.getUTCMonth() + 1),
      M(Y.getUTCDate()),
      M(Y.getUTCHours()),
      M(Y.getUTCMinutes()),
      M(Y.getUTCSeconds()),
      "Z"
    ].join("") : this.reporter.error("Encoding " + D + " time is not supported yet"), this._encodeStr(Z, "octstr");
  }, B.prototype._encodeNull = function() {
    return this._createEncoderBuffer("");
  }, B.prototype._encodeInt = function(P, D) {
    if (typeof P == "string") {
      if (!D)
        return this.reporter.error("String int or enum given, but no values map");
      if (!D.hasOwnProperty(P))
        return this.reporter.error("Values map doesn't contain: " + JSON.stringify(P));
      P = D[P];
    }
    if (typeof P != "number" && !t.isBuffer(P)) {
      var Z = P.toArray();
      !P.sign && Z[0] & 128 && Z.unshift(0), P = new t(Z);
    }
    if (t.isBuffer(P)) {
      var Y = P.length;
      P.length === 0 && Y++;
      var ee = new t(Y);
      return P.copy(ee), P.length === 0 && (ee[0] = 0), this._createEncoderBuffer(ee);
    }
    if (P < 128)
      return this._createEncoderBuffer(P);
    if (P < 256)
      return this._createEncoderBuffer([0, P]);
    for (var Y = 1, ie = P; ie >= 256; ie >>= 8)
      Y++;
    for (var ee = new Array(Y), ie = ee.length - 1; ie >= 0; ie--)
      ee[ie] = P & 255, P >>= 8;
    return ee[0] & 128 && ee.unshift(0), this._createEncoderBuffer(new t(ee));
  }, B.prototype._encodeBool = function(P) {
    return this._createEncoderBuffer(P ? 255 : 0);
  }, B.prototype._use = function(P, D) {
    return typeof P == "function" && (P = P(D)), P._getEncoder("der").tree;
  }, B.prototype._skipDefault = function(P, D, Z) {
    var Y = this._baseState, ee;
    if (Y.default === null)
      return !1;
    var ie = P.join();
    if (Y.defaultBuffer === void 0 && (Y.defaultBuffer = this._encodeValue(Y.default, D, Z).join()), ie.length !== Y.defaultBuffer.length)
      return !1;
    for (ee = 0; ee < ie.length; ee++)
      if (ie[ee] !== Y.defaultBuffer[ee])
        return !1;
    return !0;
  };
  function O(P, D, Z, Y) {
    var ee;
    if (P === "seqof" ? P = "seq" : P === "setof" && (P = "set"), S.tagByName.hasOwnProperty(P))
      ee = S.tagByName[P];
    else if (typeof P == "number" && (P | 0) === P)
      ee = P;
    else
      return Y.error("Unknown tag: " + P);
    return ee >= 31 ? Y.error("Multi-octet tag encoding unsupported") : (D || (ee |= 32), ee |= S.tagClassByName[Z || "universal"] << 6, ee);
  }
  return der_1;
}
var pem, hasRequiredPem;
function requirePem() {
  if (hasRequiredPem)
    return pem;
  hasRequiredPem = 1;
  var e = requireInherits_browser(), t = requireDer();
  function h(o) {
    t.call(this, o), this.enc = "pem";
  }
  return e(h, t), pem = h, h.prototype.encode = function(o, S) {
    for (var g = t.prototype.encode.call(this, o), B = g.toString("base64"), M = ["-----BEGIN " + S.label + "-----"], O = 0; O < B.length; O += 64)
      M.push(B.slice(O, O + 64));
    return M.push("-----END " + S.label + "-----"), M.join(`
`);
  }, pem;
}
var hasRequiredEncoders;
function requireEncoders() {
  return hasRequiredEncoders || (hasRequiredEncoders = 1, function(e) {
    var t = e;
    t.der = requireDer(), t.pem = requirePem();
  }(encoders)), encoders;
}
var hasRequiredAsn1$1;
function requireAsn1$1() {
  return hasRequiredAsn1$1 || (hasRequiredAsn1$1 = 1, function(e) {
    var t = e;
    t.bignum = requireBn$2(), t.define = requireApi().define, t.base = requireBase(), t.constants = requireConstants(), t.decoders = requireDecoders(), t.encoders = requireEncoders();
  }(asn1)), asn1;
}
var certificate, hasRequiredCertificate;
function requireCertificate() {
  if (hasRequiredCertificate)
    return certificate;
  hasRequiredCertificate = 1;
  var e = requireAsn1$1(), t = e.define("Time", function() {
    this.choice({
      utcTime: this.utctime(),
      generalTime: this.gentime()
    });
  }), h = e.define("AttributeTypeValue", function() {
    this.seq().obj(
      this.key("type").objid(),
      this.key("value").any()
    );
  }), o = e.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("parameters").optional(),
      this.key("curve").objid().optional()
    );
  }), S = e.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(o),
      this.key("subjectPublicKey").bitstr()
    );
  }), g = e.define("RelativeDistinguishedName", function() {
    this.setof(h);
  }), B = e.define("RDNSequence", function() {
    this.seqof(g);
  }), M = e.define("Name", function() {
    this.choice({
      rdnSequence: this.use(B)
    });
  }), O = e.define("Validity", function() {
    this.seq().obj(
      this.key("notBefore").use(t),
      this.key("notAfter").use(t)
    );
  }), P = e.define("Extension", function() {
    this.seq().obj(
      this.key("extnID").objid(),
      this.key("critical").bool().def(!1),
      this.key("extnValue").octstr()
    );
  }), D = e.define("TBSCertificate", function() {
    this.seq().obj(
      this.key("version").explicit(0).int().optional(),
      this.key("serialNumber").int(),
      this.key("signature").use(o),
      this.key("issuer").use(M),
      this.key("validity").use(O),
      this.key("subject").use(M),
      this.key("subjectPublicKeyInfo").use(S),
      this.key("issuerUniqueID").implicit(1).bitstr().optional(),
      this.key("subjectUniqueID").implicit(2).bitstr().optional(),
      this.key("extensions").explicit(3).seqof(P).optional()
    );
  }), Z = e.define("X509Certificate", function() {
    this.seq().obj(
      this.key("tbsCertificate").use(D),
      this.key("signatureAlgorithm").use(o),
      this.key("signatureValue").bitstr()
    );
  });
  return certificate = Z, certificate;
}
var hasRequiredAsn1;
function requireAsn1() {
  if (hasRequiredAsn1)
    return asn1$1;
  hasRequiredAsn1 = 1;
  var e = requireAsn1$1();
  asn1$1.certificate = requireCertificate();
  var t = e.define("RSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("modulus").int(),
      this.key("publicExponent").int(),
      this.key("privateExponent").int(),
      this.key("prime1").int(),
      this.key("prime2").int(),
      this.key("exponent1").int(),
      this.key("exponent2").int(),
      this.key("coefficient").int()
    );
  });
  asn1$1.RSAPrivateKey = t;
  var h = e.define("RSAPublicKey", function() {
    this.seq().obj(
      this.key("modulus").int(),
      this.key("publicExponent").int()
    );
  });
  asn1$1.RSAPublicKey = h;
  var o = e.define("AlgorithmIdentifier", function() {
    this.seq().obj(
      this.key("algorithm").objid(),
      this.key("none").null_().optional(),
      this.key("curve").objid().optional(),
      this.key("params").seq().obj(
        this.key("p").int(),
        this.key("q").int(),
        this.key("g").int()
      ).optional()
    );
  }), S = e.define("SubjectPublicKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").use(o),
      this.key("subjectPublicKey").bitstr()
    );
  });
  asn1$1.PublicKey = S;
  var g = e.define("PrivateKeyInfo", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("algorithm").use(o),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.PrivateKey = g;
  var B = e.define("EncryptedPrivateKeyInfo", function() {
    this.seq().obj(
      this.key("algorithm").seq().obj(
        this.key("id").objid(),
        this.key("decrypt").seq().obj(
          this.key("kde").seq().obj(
            this.key("id").objid(),
            this.key("kdeparams").seq().obj(
              this.key("salt").octstr(),
              this.key("iters").int()
            )
          ),
          this.key("cipher").seq().obj(
            this.key("algo").objid(),
            this.key("iv").octstr()
          )
        )
      ),
      this.key("subjectPrivateKey").octstr()
    );
  });
  asn1$1.EncryptedPrivateKey = B;
  var M = e.define("DSAPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int(),
      this.key("pub_key").int(),
      this.key("priv_key").int()
    );
  });
  asn1$1.DSAPrivateKey = M, asn1$1.DSAparam = e.define("DSAparam", function() {
    this.int();
  });
  var O = e.define("ECParameters", function() {
    this.choice({
      namedCurve: this.objid()
    });
  }), P = e.define("ECPrivateKey", function() {
    this.seq().obj(
      this.key("version").int(),
      this.key("privateKey").octstr(),
      this.key("parameters").optional().explicit(0).use(O),
      this.key("publicKey").optional().explicit(1).bitstr()
    );
  });
  return asn1$1.ECPrivateKey = P, asn1$1.signature = e.define("signature", function() {
    this.seq().obj(
      this.key("r").int(),
      this.key("s").int()
    );
  }), asn1$1;
}
const require$$1 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var fixProc, hasRequiredFixProc;
function requireFixProc() {
  if (hasRequiredFixProc)
    return fixProc;
  hasRequiredFixProc = 1;
  var e = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, t = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, h = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, o = requireEvp_bytestokey(), S = requireBrowser$6(), g = requireSafeBuffer$1().Buffer;
  return fixProc = function(B, M) {
    var O = B.toString(), P = O.match(e), D;
    if (P) {
      var Z = "aes" + P[1], Y = g.from(P[2], "hex"), ee = g.from(P[3].replace(/[\r\n]/g, ""), "base64"), ie = o(M, Y.slice(0, 8), parseInt(P[1], 10)).key, ue = [], fe = S.createDecipheriv(Z, ie, Y);
      ue.push(fe.update(ee)), ue.push(fe.final()), D = g.concat(ue);
    } else {
      var de = O.match(h);
      D = g.from(de[2].replace(/[\r\n]/g, ""), "base64");
    }
    var ce = O.match(t)[1];
    return {
      tag: ce,
      data: D
    };
  }, fixProc;
}
var parseAsn1, hasRequiredParseAsn1;
function requireParseAsn1() {
  if (hasRequiredParseAsn1)
    return parseAsn1;
  hasRequiredParseAsn1 = 1;
  var e = requireAsn1(), t = require$$1, h = requireFixProc(), o = requireBrowser$6(), S = requireBrowser$7(), g = requireSafeBuffer$1().Buffer;
  function B(O, P) {
    var D = O.algorithm.decrypt.kde.kdeparams.salt, Z = parseInt(O.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), Y = t[O.algorithm.decrypt.cipher.algo.join(".")], ee = O.algorithm.decrypt.cipher.iv, ie = O.subjectPrivateKey, ue = parseInt(Y.split("-")[1], 10) / 8, fe = S.pbkdf2Sync(P, D, Z, ue, "sha1"), de = o.createDecipheriv(Y, fe, ee), ce = [];
    return ce.push(de.update(ie)), ce.push(de.final()), g.concat(ce);
  }
  function M(O) {
    var P;
    typeof O == "object" && !g.isBuffer(O) && (P = O.passphrase, O = O.key), typeof O == "string" && (O = g.from(O));
    var D = h(O, P), Z = D.tag, Y = D.data, ee, ie;
    switch (Z) {
      case "CERTIFICATE":
        ie = e.certificate.decode(Y, "der").tbsCertificate.subjectPublicKeyInfo;
      case "PUBLIC KEY":
        switch (ie || (ie = e.PublicKey.decode(Y, "der")), ee = ie.algorithm.algorithm.join("."), ee) {
          case "1.2.840.113549.1.1.1":
            return e.RSAPublicKey.decode(ie.subjectPublicKey.data, "der");
          case "1.2.840.10045.2.1":
            return ie.subjectPrivateKey = ie.subjectPublicKey, {
              type: "ec",
              data: ie
            };
          case "1.2.840.10040.4.1":
            return ie.algorithm.params.pub_key = e.DSAparam.decode(ie.subjectPublicKey.data, "der"), {
              type: "dsa",
              data: ie.algorithm.params
            };
          default:
            throw new Error("unknown key id " + ee);
        }
      case "ENCRYPTED PRIVATE KEY":
        Y = e.EncryptedPrivateKey.decode(Y, "der"), Y = B(Y, P);
      case "PRIVATE KEY":
        switch (ie = e.PrivateKey.decode(Y, "der"), ee = ie.algorithm.algorithm.join("."), ee) {
          case "1.2.840.113549.1.1.1":
            return e.RSAPrivateKey.decode(ie.subjectPrivateKey, "der");
          case "1.2.840.10045.2.1":
            return {
              curve: ie.algorithm.curve,
              privateKey: e.ECPrivateKey.decode(ie.subjectPrivateKey, "der").privateKey
            };
          case "1.2.840.10040.4.1":
            return ie.algorithm.params.priv_key = e.DSAparam.decode(ie.subjectPrivateKey, "der"), {
              type: "dsa",
              params: ie.algorithm.params
            };
          default:
            throw new Error("unknown key id " + ee);
        }
      case "RSA PUBLIC KEY":
        return e.RSAPublicKey.decode(Y, "der");
      case "RSA PRIVATE KEY":
        return e.RSAPrivateKey.decode(Y, "der");
      case "DSA PRIVATE KEY":
        return {
          type: "dsa",
          params: e.DSAPrivateKey.decode(Y, "der")
        };
      case "EC PRIVATE KEY":
        return Y = e.ECPrivateKey.decode(Y, "der"), {
          curve: Y.parameters.value,
          privateKey: Y.privateKey
        };
      default:
        throw new Error("unknown key type " + Z);
    }
  }
  return M.signature = e.signature, parseAsn1 = M, parseAsn1;
}
const require$$4 = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var hasRequiredSign;
function requireSign() {
  if (hasRequiredSign)
    return sign.exports;
  hasRequiredSign = 1;
  var e = requireSafeBuffer$1().Buffer, t = requireBrowser$8(), h = requireBrowserifyRsa(), o = requireElliptic().ec, S = requireBn(), g = requireParseAsn1(), B = require$$4, M = 1;
  function O(de, ce, be, ve, Pe) {
    var Ue = g(ce);
    if (Ue.curve) {
      if (ve !== "ecdsa" && ve !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return P(de, Ue);
    } else if (Ue.type === "dsa") {
      if (ve !== "dsa")
        throw new Error("wrong private key type");
      return D(de, Ue, be);
    }
    if (ve !== "rsa" && ve !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    if (ce.padding !== void 0 && ce.padding !== M)
      throw new Error("illegal or unsupported padding mode");
    de = e.concat([Pe, de]);
    for (var ze = Ue.modulus.byteLength(), Le = [0, 1]; de.length + Le.length + 1 < ze; )
      Le.push(255);
    Le.push(0);
    for (var Ne = -1; ++Ne < de.length; )
      Le.push(de[Ne]);
    var $e = h(Le, Ue);
    return $e;
  }
  function P(de, ce) {
    var be = B[ce.curve.join(".")];
    if (!be)
      throw new Error("unknown curve " + ce.curve.join("."));
    var ve = new o(be), Pe = ve.keyFromPrivate(ce.privateKey), Ue = Pe.sign(de);
    return e.from(Ue.toDER());
  }
  function D(de, ce, be) {
    for (var ve = ce.params.priv_key, Pe = ce.params.p, Ue = ce.params.q, ze = ce.params.g, Le = new S(0), Ne, $e = ee(de, Ue).mod(Ue), J = !1, ne = Y(ve, Ue, de, be); J === !1; )
      Ne = ue(Ue, ne, be), Le = fe(ze, Ne, Pe, Ue), J = Ne.invm(Ue).imul($e.add(ve.mul(Le))).mod(Ue), J.cmpn(0) === 0 && (J = !1, Le = new S(0));
    return Z(Le, J);
  }
  function Z(de, ce) {
    de = de.toArray(), ce = ce.toArray(), de[0] & 128 && (de = [0].concat(de)), ce[0] & 128 && (ce = [0].concat(ce));
    var be = de.length + ce.length + 4, ve = [
      48,
      be,
      2,
      de.length
    ];
    return ve = ve.concat(de, [2, ce.length], ce), e.from(ve);
  }
  function Y(de, ce, be, ve) {
    if (de = e.from(de.toArray()), de.length < ce.byteLength()) {
      var Pe = e.alloc(ce.byteLength() - de.length);
      de = e.concat([Pe, de]);
    }
    var Ue = be.length, ze = ie(be, ce), Le = e.alloc(Ue);
    Le.fill(1);
    var Ne = e.alloc(Ue);
    return Ne = t(ve, Ne).update(Le).update(e.from([0])).update(de).update(ze).digest(), Le = t(ve, Ne).update(Le).digest(), Ne = t(ve, Ne).update(Le).update(e.from([1])).update(de).update(ze).digest(), Le = t(ve, Ne).update(Le).digest(), { k: Ne, v: Le };
  }
  function ee(de, ce) {
    var be = new S(de), ve = (de.length << 3) - ce.bitLength();
    return ve > 0 && be.ishrn(ve), be;
  }
  function ie(de, ce) {
    de = ee(de, ce), de = de.mod(ce);
    var be = e.from(de.toArray());
    if (be.length < ce.byteLength()) {
      var ve = e.alloc(ce.byteLength() - be.length);
      be = e.concat([ve, be]);
    }
    return be;
  }
  function ue(de, ce, be) {
    var ve, Pe;
    do {
      for (ve = e.alloc(0); ve.length * 8 < de.bitLength(); )
        ce.v = t(be, ce.k).update(ce.v).digest(), ve = e.concat([ve, ce.v]);
      Pe = ee(ve, de), ce.k = t(be, ce.k).update(ce.v).update(e.from([0])).digest(), ce.v = t(be, ce.k).update(ce.v).digest();
    } while (Pe.cmp(de) !== -1);
    return Pe;
  }
  function fe(de, ce, be, ve) {
    return de.toRed(S.mont(be)).redPow(ce).fromRed().mod(ve);
  }
  return sign.exports = O, sign.exports.getKey = Y, sign.exports.makeKey = ue, sign.exports;
}
var verify_1, hasRequiredVerify;
function requireVerify() {
  if (hasRequiredVerify)
    return verify_1;
  hasRequiredVerify = 1;
  var e = requireSafeBuffer$1().Buffer, t = requireBn(), h = requireElliptic().ec, o = requireParseAsn1(), S = require$$4;
  function g(P, D, Z, Y, ee) {
    var ie = o(Z);
    if (ie.type === "ec") {
      if (Y !== "ecdsa" && Y !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return B(P, D, ie);
    } else if (ie.type === "dsa") {
      if (Y !== "dsa")
        throw new Error("wrong public key type");
      return M(P, D, ie);
    }
    if (Y !== "rsa" && Y !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    D = e.concat([ee, D]);
    for (var ue = ie.modulus.byteLength(), fe = [1], de = 0; D.length + fe.length + 2 < ue; )
      fe.push(255), de += 1;
    fe.push(0);
    for (var ce = -1; ++ce < D.length; )
      fe.push(D[ce]);
    fe = e.from(fe);
    var be = t.mont(ie.modulus);
    P = new t(P).toRed(be), P = P.redPow(new t(ie.publicExponent)), P = e.from(P.fromRed().toArray());
    var ve = de < 8 ? 1 : 0;
    for (ue = Math.min(P.length, fe.length), P.length !== fe.length && (ve = 1), ce = -1; ++ce < ue; )
      ve |= P[ce] ^ fe[ce];
    return ve === 0;
  }
  function B(P, D, Z) {
    var Y = S[Z.data.algorithm.curve.join(".")];
    if (!Y)
      throw new Error("unknown curve " + Z.data.algorithm.curve.join("."));
    var ee = new h(Y), ie = Z.data.subjectPrivateKey.data;
    return ee.verify(D, P, ie);
  }
  function M(P, D, Z) {
    var Y = Z.data.p, ee = Z.data.q, ie = Z.data.g, ue = Z.data.pub_key, fe = o.signature.decode(P, "der"), de = fe.s, ce = fe.r;
    O(de, ee), O(ce, ee);
    var be = t.mont(Y), ve = de.invm(ee), Pe = ie.toRed(be).redPow(new t(D).mul(ve).mod(ee)).fromRed().mul(ue.toRed(be).redPow(ce.mul(ve).mod(ee)).fromRed()).mod(Y).mod(ee);
    return Pe.cmp(ce) === 0;
  }
  function O(P, D) {
    if (P.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (P.cmp(D) >= 0)
      throw new Error("invalid sig");
  }
  return verify_1 = g, verify_1;
}
var browser$3, hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3)
    return browser$3;
  hasRequiredBrowser$3 = 1;
  var e = requireSafeBuffer$1().Buffer, t = requireBrowser$9(), h = requireReadableBrowser(), o = requireInherits_browser(), S = requireSign(), g = requireVerify(), B = require$$6;
  Object.keys(B).forEach(function(Z) {
    B[Z].id = e.from(B[Z].id, "hex"), B[Z.toLowerCase()] = B[Z];
  });
  function M(Z) {
    h.Writable.call(this);
    var Y = B[Z];
    if (!Y)
      throw new Error("Unknown message digest");
    this._hashType = Y.hash, this._hash = t(Y.hash), this._tag = Y.id, this._signType = Y.sign;
  }
  o(M, h.Writable), M.prototype._write = function(Z, Y, ee) {
    this._hash.update(Z), ee();
  }, M.prototype.update = function(Z, Y) {
    return this._hash.update(typeof Z == "string" ? e.from(Z, Y) : Z), this;
  }, M.prototype.sign = function(Z, Y) {
    this.end();
    var ee = this._hash.digest(), ie = S(ee, Z, this._hashType, this._signType, this._tag);
    return Y ? ie.toString(Y) : ie;
  };
  function O(Z) {
    h.Writable.call(this);
    var Y = B[Z];
    if (!Y)
      throw new Error("Unknown message digest");
    this._hash = t(Y.hash), this._tag = Y.id, this._signType = Y.sign;
  }
  o(O, h.Writable), O.prototype._write = function(Z, Y, ee) {
    this._hash.update(Z), ee();
  }, O.prototype.update = function(Z, Y) {
    return this._hash.update(typeof Z == "string" ? e.from(Z, Y) : Z), this;
  }, O.prototype.verify = function(Z, Y, ee) {
    var ie = typeof Y == "string" ? e.from(Y, ee) : Y;
    this.end();
    var ue = this._hash.digest();
    return g(ie, ue, Z, this._signType, this._tag);
  };
  function P(Z) {
    return new M(Z);
  }
  function D(Z) {
    return new O(Z);
  }
  return browser$3 = {
    Sign: P,
    Verify: D,
    createSign: P,
    createVerify: D
  }, browser$3;
}
var browser$2, hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2)
    return browser$2;
  hasRequiredBrowser$2 = 1;
  var e = requireElliptic(), t = requireBn$2();
  browser$2 = function(g) {
    return new o(g);
  };
  var h = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  h.p224 = h.secp224r1, h.p256 = h.secp256r1 = h.prime256v1, h.p192 = h.secp192r1 = h.prime192v1, h.p384 = h.secp384r1, h.p521 = h.secp521r1;
  function o(g) {
    this.curveType = h[g], this.curveType || (this.curveType = {
      name: g
    }), this.curve = new e.ec(this.curveType.name), this.keys = void 0;
  }
  o.prototype.generateKeys = function(g, B) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(g, B);
  }, o.prototype.computeSecret = function(g, B, M) {
    B = B || "utf8", bufferExports.Buffer.isBuffer(g) || (g = new bufferExports.Buffer(g, B));
    var O = this.curve.keyFromPublic(g).getPublic(), P = O.mul(this.keys.getPrivate()).getX();
    return S(P, M, this.curveType.byteLength);
  }, o.prototype.getPublicKey = function(g, B) {
    var M = this.keys.getPublic(B === "compressed", !0);
    return B === "hybrid" && (M[M.length - 1] % 2 ? M[0] = 7 : M[0] = 6), S(M, g);
  }, o.prototype.getPrivateKey = function(g) {
    return S(this.keys.getPrivate(), g);
  }, o.prototype.setPublicKey = function(g, B) {
    return B = B || "utf8", bufferExports.Buffer.isBuffer(g) || (g = new bufferExports.Buffer(g, B)), this.keys._importPublic(g), this;
  }, o.prototype.setPrivateKey = function(g, B) {
    B = B || "utf8", bufferExports.Buffer.isBuffer(g) || (g = new bufferExports.Buffer(g, B));
    var M = new t(g);
    return M = M.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(M), this;
  };
  function S(g, B, M) {
    Array.isArray(g) || (g = g.toArray());
    var O = new bufferExports.Buffer(g);
    if (M && O.length < M) {
      var P = new bufferExports.Buffer(M - O.length);
      P.fill(0), O = bufferExports.Buffer.concat([P, O]);
    }
    return B ? O.toString(B) : O;
  }
  return browser$2;
}
var browser$1 = {}, mgf, hasRequiredMgf;
function requireMgf() {
  if (hasRequiredMgf)
    return mgf;
  hasRequiredMgf = 1;
  var e = requireBrowser$9(), t = requireSafeBuffer$1().Buffer;
  mgf = function(o, S) {
    for (var g = t.alloc(0), B = 0, M; g.length < S; )
      M = h(B++), g = t.concat([g, e("sha1").update(o).update(M).digest()]);
    return g.slice(0, S);
  };
  function h(o) {
    var S = t.allocUnsafe(4);
    return S.writeUInt32BE(o, 0), S;
  }
  return mgf;
}
var xor, hasRequiredXor;
function requireXor() {
  return hasRequiredXor || (hasRequiredXor = 1, xor = function(e, t) {
    for (var h = e.length, o = -1; ++o < h; )
      e[o] ^= t[o];
    return e;
  }), xor;
}
var withPublic_1, hasRequiredWithPublic;
function requireWithPublic() {
  if (hasRequiredWithPublic)
    return withPublic_1;
  hasRequiredWithPublic = 1;
  var e = requireBn$2(), t = requireSafeBuffer$1().Buffer;
  function h(o, S) {
    return t.from(o.toRed(e.mont(S.modulus)).redPow(new e(S.publicExponent)).fromRed().toArray());
  }
  return withPublic_1 = h, withPublic_1;
}
var publicEncrypt, hasRequiredPublicEncrypt;
function requirePublicEncrypt() {
  if (hasRequiredPublicEncrypt)
    return publicEncrypt;
  hasRequiredPublicEncrypt = 1;
  var e = requireParseAsn1(), t = requireBrowser$b(), h = requireBrowser$9(), o = requireMgf(), S = requireXor(), g = requireBn$2(), B = requireWithPublic(), M = requireBrowserifyRsa(), O = requireSafeBuffer$1().Buffer;
  publicEncrypt = function(Y, ee, ie) {
    var ue;
    Y.padding ? ue = Y.padding : ie ? ue = 1 : ue = 4;
    var fe = e(Y), de;
    if (ue === 4)
      de = P(fe, ee);
    else if (ue === 1)
      de = D(fe, ee, ie);
    else if (ue === 3) {
      if (de = new g(ee), de.cmp(fe.modulus) >= 0)
        throw new Error("data too long for modulus");
    } else
      throw new Error("unknown padding");
    return ie ? M(de, fe) : B(de, fe);
  };
  function P(Y, ee) {
    var ie = Y.modulus.byteLength(), ue = ee.length, fe = h("sha1").update(O.alloc(0)).digest(), de = fe.length, ce = 2 * de;
    if (ue > ie - ce - 2)
      throw new Error("message too long");
    var be = O.alloc(ie - ue - ce - 2), ve = ie - de - 1, Pe = t(de), Ue = S(O.concat([fe, be, O.alloc(1, 1), ee], ve), o(Pe, ve)), ze = S(Pe, o(Ue, de));
    return new g(O.concat([O.alloc(1), ze, Ue], ie));
  }
  function D(Y, ee, ie) {
    var ue = ee.length, fe = Y.modulus.byteLength();
    if (ue > fe - 11)
      throw new Error("message too long");
    var de;
    return ie ? de = O.alloc(fe - ue - 3, 255) : de = Z(fe - ue - 3), new g(O.concat([O.from([0, ie ? 1 : 2]), de, O.alloc(1), ee], fe));
  }
  function Z(Y) {
    for (var ee = O.allocUnsafe(Y), ie = 0, ue = t(Y * 2), fe = 0, de; ie < Y; )
      fe === ue.length && (ue = t(Y * 2), fe = 0), de = ue[fe++], de && (ee[ie++] = de);
    return ee;
  }
  return publicEncrypt;
}
var privateDecrypt, hasRequiredPrivateDecrypt;
function requirePrivateDecrypt() {
  if (hasRequiredPrivateDecrypt)
    return privateDecrypt;
  hasRequiredPrivateDecrypt = 1;
  var e = requireParseAsn1(), t = requireMgf(), h = requireXor(), o = requireBn$2(), S = requireBrowserifyRsa(), g = requireBrowser$9(), B = requireWithPublic(), M = requireSafeBuffer$1().Buffer;
  privateDecrypt = function(Z, Y, ee) {
    var ie;
    Z.padding ? ie = Z.padding : ee ? ie = 1 : ie = 4;
    var ue = e(Z), fe = ue.modulus.byteLength();
    if (Y.length > fe || new o(Y).cmp(ue.modulus) >= 0)
      throw new Error("decryption error");
    var de;
    ee ? de = B(new o(Y), ue) : de = S(Y, ue);
    var ce = M.alloc(fe - de.length);
    if (de = M.concat([ce, de], fe), ie === 4)
      return O(ue, de);
    if (ie === 1)
      return P(ue, de, ee);
    if (ie === 3)
      return de;
    throw new Error("unknown padding");
  };
  function O(Z, Y) {
    var ee = Z.modulus.byteLength(), ie = g("sha1").update(M.alloc(0)).digest(), ue = ie.length;
    if (Y[0] !== 0)
      throw new Error("decryption error");
    var fe = Y.slice(1, ue + 1), de = Y.slice(ue + 1), ce = h(fe, t(de, ue)), be = h(de, t(ce, ee - ue - 1));
    if (D(ie, be.slice(0, ue)))
      throw new Error("decryption error");
    for (var ve = ue; be[ve] === 0; )
      ve++;
    if (be[ve++] !== 1)
      throw new Error("decryption error");
    return be.slice(ve);
  }
  function P(Z, Y, ee) {
    for (var ie = Y.slice(0, 2), ue = 2, fe = 0; Y[ue++] !== 0; )
      if (ue >= Y.length) {
        fe++;
        break;
      }
    var de = Y.slice(2, ue - 1);
    if ((ie.toString("hex") !== "0002" && !ee || ie.toString("hex") !== "0001" && ee) && fe++, de.length < 8 && fe++, fe)
      throw new Error("decryption error");
    return Y.slice(ue);
  }
  function D(Z, Y) {
    Z = M.from(Z), Y = M.from(Y);
    var ee = 0, ie = Z.length;
    Z.length !== Y.length && (ee++, ie = Math.min(Z.length, Y.length));
    for (var ue = -1; ++ue < ie; )
      ee += Z[ue] ^ Y[ue];
    return ee;
  }
  return privateDecrypt;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  return hasRequiredBrowser$1 || (hasRequiredBrowser$1 = 1, function(e) {
    e.publicEncrypt = requirePublicEncrypt(), e.privateDecrypt = requirePrivateDecrypt(), e.privateEncrypt = function(t, h) {
      return e.publicEncrypt(t, h, !0);
    }, e.publicDecrypt = function(t, h) {
      return e.privateDecrypt(t, h, !0);
    };
  }(browser$1)), browser$1;
}
var browser = {}, hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser)
    return browser;
  hasRequiredBrowser = 1;
  function e() {
    throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
  }
  var t = requireSafeBuffer$1(), h = requireBrowser$b(), o = t.Buffer, S = t.kMaxLength, g = commonjsGlobal.crypto || commonjsGlobal.msCrypto, B = Math.pow(2, 32) - 1;
  function M(Y, ee) {
    if (typeof Y != "number" || Y !== Y)
      throw new TypeError("offset must be a number");
    if (Y > B || Y < 0)
      throw new TypeError("offset must be a uint32");
    if (Y > S || Y > ee)
      throw new RangeError("offset out of range");
  }
  function O(Y, ee, ie) {
    if (typeof Y != "number" || Y !== Y)
      throw new TypeError("size must be a number");
    if (Y > B || Y < 0)
      throw new TypeError("size must be a uint32");
    if (Y + ee > ie || Y > S)
      throw new RangeError("buffer too small");
  }
  g && g.getRandomValues || !process$1.browser ? (browser.randomFill = P, browser.randomFillSync = Z) : (browser.randomFill = e, browser.randomFillSync = e);
  function P(Y, ee, ie, ue) {
    if (!o.isBuffer(Y) && !(Y instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    if (typeof ee == "function")
      ue = ee, ee = 0, ie = Y.length;
    else if (typeof ie == "function")
      ue = ie, ie = Y.length - ee;
    else if (typeof ue != "function")
      throw new TypeError('"cb" argument must be a function');
    return M(ee, Y.length), O(ie, ee, Y.length), D(Y, ee, ie, ue);
  }
  function D(Y, ee, ie, ue) {
    if (process$1.browser) {
      var fe = Y.buffer, de = new Uint8Array(fe, ee, ie);
      if (g.getRandomValues(de), ue) {
        process$1.nextTick(function() {
          ue(null, Y);
        });
        return;
      }
      return Y;
    }
    if (ue) {
      h(ie, function(be, ve) {
        if (be)
          return ue(be);
        ve.copy(Y, ee), ue(null, Y);
      });
      return;
    }
    var ce = h(ie);
    return ce.copy(Y, ee), Y;
  }
  function Z(Y, ee, ie) {
    if (typeof ee > "u" && (ee = 0), !o.isBuffer(Y) && !(Y instanceof commonjsGlobal.Uint8Array))
      throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
    return M(ee, Y.length), ie === void 0 && (ie = Y.length - ee), O(ie, ee, Y.length), D(Y, ee, ie);
  }
  return browser;
}
var hasRequiredCryptoBrowserify;
function requireCryptoBrowserify() {
  if (hasRequiredCryptoBrowserify)
    return cryptoBrowserify;
  hasRequiredCryptoBrowserify = 1, cryptoBrowserify.randomBytes = cryptoBrowserify.rng = cryptoBrowserify.pseudoRandomBytes = cryptoBrowserify.prng = requireBrowser$b(), cryptoBrowserify.createHash = cryptoBrowserify.Hash = requireBrowser$9(), cryptoBrowserify.createHmac = cryptoBrowserify.Hmac = requireBrowser$8();
  var e = requireAlgos(), t = Object.keys(e), h = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(t);
  cryptoBrowserify.getHashes = function() {
    return h;
  };
  var o = requireBrowser$7();
  cryptoBrowserify.pbkdf2 = o.pbkdf2, cryptoBrowserify.pbkdf2Sync = o.pbkdf2Sync;
  var S = requireBrowser$5();
  cryptoBrowserify.Cipher = S.Cipher, cryptoBrowserify.createCipher = S.createCipher, cryptoBrowserify.Cipheriv = S.Cipheriv, cryptoBrowserify.createCipheriv = S.createCipheriv, cryptoBrowserify.Decipher = S.Decipher, cryptoBrowserify.createDecipher = S.createDecipher, cryptoBrowserify.Decipheriv = S.Decipheriv, cryptoBrowserify.createDecipheriv = S.createDecipheriv, cryptoBrowserify.getCiphers = S.getCiphers, cryptoBrowserify.listCiphers = S.listCiphers;
  var g = requireBrowser$4();
  cryptoBrowserify.DiffieHellmanGroup = g.DiffieHellmanGroup, cryptoBrowserify.createDiffieHellmanGroup = g.createDiffieHellmanGroup, cryptoBrowserify.getDiffieHellman = g.getDiffieHellman, cryptoBrowserify.createDiffieHellman = g.createDiffieHellman, cryptoBrowserify.DiffieHellman = g.DiffieHellman;
  var B = requireBrowser$3();
  cryptoBrowserify.createSign = B.createSign, cryptoBrowserify.Sign = B.Sign, cryptoBrowserify.createVerify = B.createVerify, cryptoBrowserify.Verify = B.Verify, cryptoBrowserify.createECDH = requireBrowser$2();
  var M = requireBrowser$1();
  cryptoBrowserify.publicEncrypt = M.publicEncrypt, cryptoBrowserify.privateEncrypt = M.privateEncrypt, cryptoBrowserify.publicDecrypt = M.publicDecrypt, cryptoBrowserify.privateDecrypt = M.privateDecrypt;
  var O = requireBrowser();
  return cryptoBrowserify.randomFill = O.randomFill, cryptoBrowserify.randomFillSync = O.randomFillSync, cryptoBrowserify.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, cryptoBrowserify.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, cryptoBrowserify;
}
(function(e) {
  /**
   * @license bcrypt.js (c) 2013 Daniel Wirtz <dcode@dcode.io>
   * Released under the Apache License, Version 2.0
   * see: https://github.com/dcodeIO/bcrypt.js for details
   */
  (function(t, h) {
    typeof commonjsRequire == "function" && e && e.exports ? e.exports = h() : (t.dcodeIO = t.dcodeIO || {}).bcrypt = h();
  })(commonjsGlobal, function() {
    var t = {}, h = null;
    function o(J) {
      if (e && e.exports)
        try {
          return requireCryptoBrowserify().randomBytes(J);
        } catch {
        }
      try {
        var ne;
        return (self.crypto || self.msCrypto).getRandomValues(ne = new Uint32Array(J)), Array.prototype.slice.call(ne);
      } catch {
      }
      if (!h)
        throw Error("Neither WebCryptoAPI nor a crypto module is available. Use bcrypt.setRandomFallback to set an alternative");
      return h(J);
    }
    var S = !1;
    try {
      o(1), S = !0;
    } catch {
    }
    h = null, t.setRandomFallback = function(J) {
      h = J;
    }, t.genSaltSync = function(J, ne) {
      if (J = J || ue, typeof J != "number")
        throw Error("Illegal arguments: " + typeof J + ", " + typeof ne);
      J < 4 ? J = 4 : J > 31 && (J = 31);
      var A = [];
      return A.push("$2a$"), J < 10 && A.push("0"), A.push(J.toString()), A.push("$"), A.push(Z(o(ie), ie)), A.join("");
    }, t.genSalt = function(J, ne, A) {
      if (typeof ne == "function" && (A = ne, ne = void 0), typeof J == "function" && (A = J, J = void 0), typeof J > "u")
        J = ue;
      else if (typeof J != "number")
        throw Error("illegal arguments: " + typeof J);
      function I(U) {
        B(function() {
          try {
            U(null, t.genSaltSync(J));
          } catch (X) {
            U(X);
          }
        });
      }
      if (A) {
        if (typeof A != "function")
          throw Error("Illegal callback: " + typeof A);
        I(A);
      } else
        return new Promise(function(U, X) {
          I(function(Q, F) {
            if (Q) {
              X(Q);
              return;
            }
            U(F);
          });
        });
    }, t.hashSync = function(J, ne) {
      if (typeof ne > "u" && (ne = ue), typeof ne == "number" && (ne = t.genSaltSync(ne)), typeof J != "string" || typeof ne != "string")
        throw Error("Illegal arguments: " + typeof J + ", " + typeof ne);
      return $e(J, ne);
    }, t.hash = function(J, ne, A, I) {
      function U(X) {
        typeof J == "string" && typeof ne == "number" ? t.genSalt(ne, function(Q, F) {
          $e(J, F, X, I);
        }) : typeof J == "string" && typeof ne == "string" ? $e(J, ne, X, I) : B(X.bind(this, Error("Illegal arguments: " + typeof J + ", " + typeof ne)));
      }
      if (A) {
        if (typeof A != "function")
          throw Error("Illegal callback: " + typeof A);
        U(A);
      } else
        return new Promise(function(X, Q) {
          U(function(F, $) {
            if (F) {
              Q(F);
              return;
            }
            X($);
          });
        });
    };
    function g(J, ne) {
      for (var A = 0, I = 0, U = 0, X = J.length; U < X; ++U)
        J.charCodeAt(U) === ne.charCodeAt(U) ? ++A : ++I;
      return A < 0 ? !1 : I === 0;
    }
    t.compareSync = function(J, ne) {
      if (typeof J != "string" || typeof ne != "string")
        throw Error("Illegal arguments: " + typeof J + ", " + typeof ne);
      return ne.length !== 60 ? !1 : g(t.hashSync(J, ne.substr(0, ne.length - 31)), ne);
    }, t.compare = function(J, ne, A, I) {
      function U(X) {
        if (typeof J != "string" || typeof ne != "string") {
          B(X.bind(this, Error("Illegal arguments: " + typeof J + ", " + typeof ne)));
          return;
        }
        if (ne.length !== 60) {
          B(X.bind(this, null, !1));
          return;
        }
        t.hash(J, ne.substr(0, 29), function(Q, F) {
          Q ? X(Q) : X(null, g(F, ne));
        }, I);
      }
      if (A) {
        if (typeof A != "function")
          throw Error("Illegal callback: " + typeof A);
        U(A);
      } else
        return new Promise(function(X, Q) {
          U(function(F, $) {
            if (F) {
              Q(F);
              return;
            }
            X($);
          });
        });
    }, t.getRounds = function(J) {
      if (typeof J != "string")
        throw Error("Illegal arguments: " + typeof J);
      return parseInt(J.split("$")[2], 10);
    }, t.getSalt = function(J) {
      if (typeof J != "string")
        throw Error("Illegal arguments: " + typeof J);
      if (J.length !== 60)
        throw Error("Illegal hash length: " + J.length + " != 60");
      return J.substring(0, 29);
    };
    var B = typeof process$1 < "u" && process$1 && typeof process$1.nextTick == "function" ? typeof setImmediate == "function" ? setImmediate : process$1.nextTick : setTimeout;
    function M(J) {
      var ne = [], A = 0;
      return ee.encodeUTF16toUTF8(function() {
        return A >= J.length ? null : J.charCodeAt(A++);
      }, function(I) {
        ne.push(I);
      }), ne;
    }
    var O = "./ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789".split(""), P = [
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      0,
      1,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      -1,
      -1,
      -1,
      -1,
      -1
    ], D = String.fromCharCode;
    function Z(J, ne) {
      var A = 0, I = [], U, X;
      if (ne <= 0 || ne > J.length)
        throw Error("Illegal len: " + ne);
      for (; A < ne; ) {
        if (U = J[A++] & 255, I.push(O[U >> 2 & 63]), U = (U & 3) << 4, A >= ne) {
          I.push(O[U & 63]);
          break;
        }
        if (X = J[A++] & 255, U |= X >> 4 & 15, I.push(O[U & 63]), U = (X & 15) << 2, A >= ne) {
          I.push(O[U & 63]);
          break;
        }
        X = J[A++] & 255, U |= X >> 6 & 3, I.push(O[U & 63]), I.push(O[X & 63]);
      }
      return I.join("");
    }
    function Y(J, ne) {
      var A = 0, I = J.length, U = 0, X = [], Q, F, $, H, q, z;
      if (ne <= 0)
        throw Error("Illegal len: " + ne);
      for (; A < I - 1 && U < ne && (z = J.charCodeAt(A++), Q = z < P.length ? P[z] : -1, z = J.charCodeAt(A++), F = z < P.length ? P[z] : -1, !(Q == -1 || F == -1 || (q = Q << 2 >>> 0, q |= (F & 48) >> 4, X.push(D(q)), ++U >= ne || A >= I) || (z = J.charCodeAt(A++), $ = z < P.length ? P[z] : -1, $ == -1) || (q = (F & 15) << 4 >>> 0, q |= ($ & 60) >> 2, X.push(D(q)), ++U >= ne || A >= I))); )
        z = J.charCodeAt(A++), H = z < P.length ? P[z] : -1, q = ($ & 3) << 6 >>> 0, q |= H, X.push(D(q)), ++U;
      var me = [];
      for (A = 0; A < U; A++)
        me.push(X[A].charCodeAt(0));
      return me;
    }
    var ee = function() {
      var J = {};
      return J.MAX_CODEPOINT = 1114111, J.encodeUTF8 = function(ne, A) {
        var I = null;
        for (typeof ne == "number" && (I = ne, ne = function() {
          return null;
        }); I !== null || (I = ne()) !== null; )
          I < 128 ? A(I & 127) : I < 2048 ? (A(I >> 6 & 31 | 192), A(I & 63 | 128)) : I < 65536 ? (A(I >> 12 & 15 | 224), A(I >> 6 & 63 | 128), A(I & 63 | 128)) : (A(I >> 18 & 7 | 240), A(I >> 12 & 63 | 128), A(I >> 6 & 63 | 128), A(I & 63 | 128)), I = null;
      }, J.decodeUTF8 = function(ne, A) {
        for (var I, U, X, Q, F = function($) {
          $ = $.slice(0, $.indexOf(null));
          var H = Error($.toString());
          throw H.name = "TruncatedError", H.bytes = $, H;
        }; (I = ne()) !== null; )
          if (!(I & 128))
            A(I);
          else if ((I & 224) === 192)
            (U = ne()) === null && F([I, U]), A((I & 31) << 6 | U & 63);
          else if ((I & 240) === 224)
            ((U = ne()) === null || (X = ne()) === null) && F([I, U, X]), A((I & 15) << 12 | (U & 63) << 6 | X & 63);
          else if ((I & 248) === 240)
            ((U = ne()) === null || (X = ne()) === null || (Q = ne()) === null) && F([I, U, X, Q]), A((I & 7) << 18 | (U & 63) << 12 | (X & 63) << 6 | Q & 63);
          else
            throw RangeError("Illegal starting byte: " + I);
      }, J.UTF16toUTF8 = function(ne, A) {
        for (var I, U = null; (I = U !== null ? U : ne()) !== null; ) {
          if (I >= 55296 && I <= 57343 && (U = ne()) !== null && U >= 56320 && U <= 57343) {
            A((I - 55296) * 1024 + U - 56320 + 65536), U = null;
            continue;
          }
          A(I);
        }
        U !== null && A(U);
      }, J.UTF8toUTF16 = function(ne, A) {
        var I = null;
        for (typeof ne == "number" && (I = ne, ne = function() {
          return null;
        }); I !== null || (I = ne()) !== null; )
          I <= 65535 ? A(I) : (I -= 65536, A((I >> 10) + 55296), A(I % 1024 + 56320)), I = null;
      }, J.encodeUTF16toUTF8 = function(ne, A) {
        J.UTF16toUTF8(ne, function(I) {
          J.encodeUTF8(I, A);
        });
      }, J.decodeUTF8toUTF16 = function(ne, A) {
        J.decodeUTF8(ne, function(I) {
          J.UTF8toUTF16(I, A);
        });
      }, J.calculateCodePoint = function(ne) {
        return ne < 128 ? 1 : ne < 2048 ? 2 : ne < 65536 ? 3 : 4;
      }, J.calculateUTF8 = function(ne) {
        for (var A, I = 0; (A = ne()) !== null; )
          I += J.calculateCodePoint(A);
        return I;
      }, J.calculateUTF16asUTF8 = function(ne) {
        var A = 0, I = 0;
        return J.UTF16toUTF8(ne, function(U) {
          ++A, I += J.calculateCodePoint(U);
        }), [A, I];
      }, J;
    }();
    Date.now = Date.now || function() {
      return +/* @__PURE__ */ new Date();
    };
    var ie = 16, ue = 10, fe = 16, de = 100, ce = [
      608135816,
      2242054355,
      320440878,
      57701188,
      2752067618,
      698298832,
      137296536,
      3964562569,
      1160258022,
      953160567,
      3193202383,
      887688300,
      3232508343,
      3380367581,
      1065670069,
      3041331479,
      2450970073,
      2306472731
    ], be = [
      3509652390,
      2564797868,
      805139163,
      3491422135,
      3101798381,
      1780907670,
      3128725573,
      4046225305,
      614570311,
      3012652279,
      134345442,
      2240740374,
      1667834072,
      1901547113,
      2757295779,
      4103290238,
      227898511,
      1921955416,
      1904987480,
      2182433518,
      2069144605,
      3260701109,
      2620446009,
      720527379,
      3318853667,
      677414384,
      3393288472,
      3101374703,
      2390351024,
      1614419982,
      1822297739,
      2954791486,
      3608508353,
      3174124327,
      2024746970,
      1432378464,
      3864339955,
      2857741204,
      1464375394,
      1676153920,
      1439316330,
      715854006,
      3033291828,
      289532110,
      2706671279,
      2087905683,
      3018724369,
      1668267050,
      732546397,
      1947742710,
      3462151702,
      2609353502,
      2950085171,
      1814351708,
      2050118529,
      680887927,
      999245976,
      1800124847,
      3300911131,
      1713906067,
      1641548236,
      4213287313,
      1216130144,
      1575780402,
      4018429277,
      3917837745,
      3693486850,
      3949271944,
      596196993,
      3549867205,
      258830323,
      2213823033,
      772490370,
      2760122372,
      1774776394,
      2652871518,
      566650946,
      4142492826,
      1728879713,
      2882767088,
      1783734482,
      3629395816,
      2517608232,
      2874225571,
      1861159788,
      326777828,
      3124490320,
      2130389656,
      2716951837,
      967770486,
      1724537150,
      2185432712,
      2364442137,
      1164943284,
      2105845187,
      998989502,
      3765401048,
      2244026483,
      1075463327,
      1455516326,
      1322494562,
      910128902,
      469688178,
      1117454909,
      936433444,
      3490320968,
      3675253459,
      1240580251,
      122909385,
      2157517691,
      634681816,
      4142456567,
      3825094682,
      3061402683,
      2540495037,
      79693498,
      3249098678,
      1084186820,
      1583128258,
      426386531,
      1761308591,
      1047286709,
      322548459,
      995290223,
      1845252383,
      2603652396,
      3431023940,
      2942221577,
      3202600964,
      3727903485,
      1712269319,
      422464435,
      3234572375,
      1170764815,
      3523960633,
      3117677531,
      1434042557,
      442511882,
      3600875718,
      1076654713,
      1738483198,
      4213154764,
      2393238008,
      3677496056,
      1014306527,
      4251020053,
      793779912,
      2902807211,
      842905082,
      4246964064,
      1395751752,
      1040244610,
      2656851899,
      3396308128,
      445077038,
      3742853595,
      3577915638,
      679411651,
      2892444358,
      2354009459,
      1767581616,
      3150600392,
      3791627101,
      3102740896,
      284835224,
      4246832056,
      1258075500,
      768725851,
      2589189241,
      3069724005,
      3532540348,
      1274779536,
      3789419226,
      2764799539,
      1660621633,
      3471099624,
      4011903706,
      913787905,
      3497959166,
      737222580,
      2514213453,
      2928710040,
      3937242737,
      1804850592,
      3499020752,
      2949064160,
      2386320175,
      2390070455,
      2415321851,
      4061277028,
      2290661394,
      2416832540,
      1336762016,
      1754252060,
      3520065937,
      3014181293,
      791618072,
      3188594551,
      3933548030,
      2332172193,
      3852520463,
      3043980520,
      413987798,
      3465142937,
      3030929376,
      4245938359,
      2093235073,
      3534596313,
      375366246,
      2157278981,
      2479649556,
      555357303,
      3870105701,
      2008414854,
      3344188149,
      4221384143,
      3956125452,
      2067696032,
      3594591187,
      2921233993,
      2428461,
      544322398,
      577241275,
      1471733935,
      610547355,
      4027169054,
      1432588573,
      1507829418,
      2025931657,
      3646575487,
      545086370,
      48609733,
      2200306550,
      1653985193,
      298326376,
      1316178497,
      3007786442,
      2064951626,
      458293330,
      2589141269,
      3591329599,
      3164325604,
      727753846,
      2179363840,
      146436021,
      1461446943,
      4069977195,
      705550613,
      3059967265,
      3887724982,
      4281599278,
      3313849956,
      1404054877,
      2845806497,
      146425753,
      1854211946,
      1266315497,
      3048417604,
      3681880366,
      3289982499,
      290971e4,
      1235738493,
      2632868024,
      2414719590,
      3970600049,
      1771706367,
      1449415276,
      3266420449,
      422970021,
      1963543593,
      2690192192,
      3826793022,
      1062508698,
      1531092325,
      1804592342,
      2583117782,
      2714934279,
      4024971509,
      1294809318,
      4028980673,
      1289560198,
      2221992742,
      1669523910,
      35572830,
      157838143,
      1052438473,
      1016535060,
      1802137761,
      1753167236,
      1386275462,
      3080475397,
      2857371447,
      1040679964,
      2145300060,
      2390574316,
      1461121720,
      2956646967,
      4031777805,
      4028374788,
      33600511,
      2920084762,
      1018524850,
      629373528,
      3691585981,
      3515945977,
      2091462646,
      2486323059,
      586499841,
      988145025,
      935516892,
      3367335476,
      2599673255,
      2839830854,
      265290510,
      3972581182,
      2759138881,
      3795373465,
      1005194799,
      847297441,
      406762289,
      1314163512,
      1332590856,
      1866599683,
      4127851711,
      750260880,
      613907577,
      1450815602,
      3165620655,
      3734664991,
      3650291728,
      3012275730,
      3704569646,
      1427272223,
      778793252,
      1343938022,
      2676280711,
      2052605720,
      1946737175,
      3164576444,
      3914038668,
      3967478842,
      3682934266,
      1661551462,
      3294938066,
      4011595847,
      840292616,
      3712170807,
      616741398,
      312560963,
      711312465,
      1351876610,
      322626781,
      1910503582,
      271666773,
      2175563734,
      1594956187,
      70604529,
      3617834859,
      1007753275,
      1495573769,
      4069517037,
      2549218298,
      2663038764,
      504708206,
      2263041392,
      3941167025,
      2249088522,
      1514023603,
      1998579484,
      1312622330,
      694541497,
      2582060303,
      2151582166,
      1382467621,
      776784248,
      2618340202,
      3323268794,
      2497899128,
      2784771155,
      503983604,
      4076293799,
      907881277,
      423175695,
      432175456,
      1378068232,
      4145222326,
      3954048622,
      3938656102,
      3820766613,
      2793130115,
      2977904593,
      26017576,
      3274890735,
      3194772133,
      1700274565,
      1756076034,
      4006520079,
      3677328699,
      720338349,
      1533947780,
      354530856,
      688349552,
      3973924725,
      1637815568,
      332179504,
      3949051286,
      53804574,
      2852348879,
      3044236432,
      1282449977,
      3583942155,
      3416972820,
      4006381244,
      1617046695,
      2628476075,
      3002303598,
      1686838959,
      431878346,
      2686675385,
      1700445008,
      1080580658,
      1009431731,
      832498133,
      3223435511,
      2605976345,
      2271191193,
      2516031870,
      1648197032,
      4164389018,
      2548247927,
      300782431,
      375919233,
      238389289,
      3353747414,
      2531188641,
      2019080857,
      1475708069,
      455242339,
      2609103871,
      448939670,
      3451063019,
      1395535956,
      2413381860,
      1841049896,
      1491858159,
      885456874,
      4264095073,
      4001119347,
      1565136089,
      3898914787,
      1108368660,
      540939232,
      1173283510,
      2745871338,
      3681308437,
      4207628240,
      3343053890,
      4016749493,
      1699691293,
      1103962373,
      3625875870,
      2256883143,
      3830138730,
      1031889488,
      3479347698,
      1535977030,
      4236805024,
      3251091107,
      2132092099,
      1774941330,
      1199868427,
      1452454533,
      157007616,
      2904115357,
      342012276,
      595725824,
      1480756522,
      206960106,
      497939518,
      591360097,
      863170706,
      2375253569,
      3596610801,
      1814182875,
      2094937945,
      3421402208,
      1082520231,
      3463918190,
      2785509508,
      435703966,
      3908032597,
      1641649973,
      2842273706,
      3305899714,
      1510255612,
      2148256476,
      2655287854,
      3276092548,
      4258621189,
      236887753,
      3681803219,
      274041037,
      1734335097,
      3815195456,
      3317970021,
      1899903192,
      1026095262,
      4050517792,
      356393447,
      2410691914,
      3873677099,
      3682840055,
      3913112168,
      2491498743,
      4132185628,
      2489919796,
      1091903735,
      1979897079,
      3170134830,
      3567386728,
      3557303409,
      857797738,
      1136121015,
      1342202287,
      507115054,
      2535736646,
      337727348,
      3213592640,
      1301675037,
      2528481711,
      1895095763,
      1721773893,
      3216771564,
      62756741,
      2142006736,
      835421444,
      2531993523,
      1442658625,
      3659876326,
      2882144922,
      676362277,
      1392781812,
      170690266,
      3921047035,
      1759253602,
      3611846912,
      1745797284,
      664899054,
      1329594018,
      3901205900,
      3045908486,
      2062866102,
      2865634940,
      3543621612,
      3464012697,
      1080764994,
      553557557,
      3656615353,
      3996768171,
      991055499,
      499776247,
      1265440854,
      648242737,
      3940784050,
      980351604,
      3713745714,
      1749149687,
      3396870395,
      4211799374,
      3640570775,
      1161844396,
      3125318951,
      1431517754,
      545492359,
      4268468663,
      3499529547,
      1437099964,
      2702547544,
      3433638243,
      2581715763,
      2787789398,
      1060185593,
      1593081372,
      2418618748,
      4260947970,
      69676912,
      2159744348,
      86519011,
      2512459080,
      3838209314,
      1220612927,
      3339683548,
      133810670,
      1090789135,
      1078426020,
      1569222167,
      845107691,
      3583754449,
      4072456591,
      1091646820,
      628848692,
      1613405280,
      3757631651,
      526609435,
      236106946,
      48312990,
      2942717905,
      3402727701,
      1797494240,
      859738849,
      992217954,
      4005476642,
      2243076622,
      3870952857,
      3732016268,
      765654824,
      3490871365,
      2511836413,
      1685915746,
      3888969200,
      1414112111,
      2273134842,
      3281911079,
      4080962846,
      172450625,
      2569994100,
      980381355,
      4109958455,
      2819808352,
      2716589560,
      2568741196,
      3681446669,
      3329971472,
      1835478071,
      660984891,
      3704678404,
      4045999559,
      3422617507,
      3040415634,
      1762651403,
      1719377915,
      3470491036,
      2693910283,
      3642056355,
      3138596744,
      1364962596,
      2073328063,
      1983633131,
      926494387,
      3423689081,
      2150032023,
      4096667949,
      1749200295,
      3328846651,
      309677260,
      2016342300,
      1779581495,
      3079819751,
      111262694,
      1274766160,
      443224088,
      298511866,
      1025883608,
      3806446537,
      1145181785,
      168956806,
      3641502830,
      3584813610,
      1689216846,
      3666258015,
      3200248200,
      1692713982,
      2646376535,
      4042768518,
      1618508792,
      1610833997,
      3523052358,
      4130873264,
      2001055236,
      3610705100,
      2202168115,
      4028541809,
      2961195399,
      1006657119,
      2006996926,
      3186142756,
      1430667929,
      3210227297,
      1314452623,
      4074634658,
      4101304120,
      2273951170,
      1399257539,
      3367210612,
      3027628629,
      1190975929,
      2062231137,
      2333990788,
      2221543033,
      2438960610,
      1181637006,
      548689776,
      2362791313,
      3372408396,
      3104550113,
      3145860560,
      296247880,
      1970579870,
      3078560182,
      3769228297,
      1714227617,
      3291629107,
      3898220290,
      166772364,
      1251581989,
      493813264,
      448347421,
      195405023,
      2709975567,
      677966185,
      3703036547,
      1463355134,
      2715995803,
      1338867538,
      1343315457,
      2802222074,
      2684532164,
      233230375,
      2599980071,
      2000651841,
      3277868038,
      1638401717,
      4028070440,
      3237316320,
      6314154,
      819756386,
      300326615,
      590932579,
      1405279636,
      3267499572,
      3150704214,
      2428286686,
      3959192993,
      3461946742,
      1862657033,
      1266418056,
      963775037,
      2089974820,
      2263052895,
      1917689273,
      448879540,
      3550394620,
      3981727096,
      150775221,
      3627908307,
      1303187396,
      508620638,
      2975983352,
      2726630617,
      1817252668,
      1876281319,
      1457606340,
      908771278,
      3720792119,
      3617206836,
      2455994898,
      1729034894,
      1080033504,
      976866871,
      3556439503,
      2881648439,
      1522871579,
      1555064734,
      1336096578,
      3548522304,
      2579274686,
      3574697629,
      3205460757,
      3593280638,
      3338716283,
      3079412587,
      564236357,
      2993598910,
      1781952180,
      1464380207,
      3163844217,
      3332601554,
      1699332808,
      1393555694,
      1183702653,
      3581086237,
      1288719814,
      691649499,
      2847557200,
      2895455976,
      3193889540,
      2717570544,
      1781354906,
      1676643554,
      2592534050,
      3230253752,
      1126444790,
      2770207658,
      2633158820,
      2210423226,
      2615765581,
      2414155088,
      3127139286,
      673620729,
      2805611233,
      1269405062,
      4015350505,
      3341807571,
      4149409754,
      1057255273,
      2012875353,
      2162469141,
      2276492801,
      2601117357,
      993977747,
      3918593370,
      2654263191,
      753973209,
      36408145,
      2530585658,
      25011837,
      3520020182,
      2088578344,
      530523599,
      2918365339,
      1524020338,
      1518925132,
      3760827505,
      3759777254,
      1202760957,
      3985898139,
      3906192525,
      674977740,
      4174734889,
      2031300136,
      2019492241,
      3983892565,
      4153806404,
      3822280332,
      352677332,
      2297720250,
      60907813,
      90501309,
      3286998549,
      1016092578,
      2535922412,
      2839152426,
      457141659,
      509813237,
      4120667899,
      652014361,
      1966332200,
      2975202805,
      55981186,
      2327461051,
      676427537,
      3255491064,
      2882294119,
      3433927263,
      1307055953,
      942726286,
      933058658,
      2468411793,
      3933900994,
      4215176142,
      1361170020,
      2001714738,
      2830558078,
      3274259782,
      1222529897,
      1679025792,
      2729314320,
      3714953764,
      1770335741,
      151462246,
      3013232138,
      1682292957,
      1483529935,
      471910574,
      1539241949,
      458788160,
      3436315007,
      1807016891,
      3718408830,
      978976581,
      1043663428,
      3165965781,
      1927990952,
      4200891579,
      2372276910,
      3208408903,
      3533431907,
      1412390302,
      2931980059,
      4132332400,
      1947078029,
      3881505623,
      4168226417,
      2941484381,
      1077988104,
      1320477388,
      886195818,
      18198404,
      3786409e3,
      2509781533,
      112762804,
      3463356488,
      1866414978,
      891333506,
      18488651,
      661792760,
      1628790961,
      3885187036,
      3141171499,
      876946877,
      2693282273,
      1372485963,
      791857591,
      2686433993,
      3759982718,
      3167212022,
      3472953795,
      2716379847,
      445679433,
      3561995674,
      3504004811,
      3574258232,
      54117162,
      3331405415,
      2381918588,
      3769707343,
      4154350007,
      1140177722,
      4074052095,
      668550556,
      3214352940,
      367459370,
      261225585,
      2610173221,
      4209349473,
      3468074219,
      3265815641,
      314222801,
      3066103646,
      3808782860,
      282218597,
      3406013506,
      3773591054,
      379116347,
      1285071038,
      846784868,
      2669647154,
      3771962079,
      3550491691,
      2305946142,
      453669953,
      1268987020,
      3317592352,
      3279303384,
      3744833421,
      2610507566,
      3859509063,
      266596637,
      3847019092,
      517658769,
      3462560207,
      3443424879,
      370717030,
      4247526661,
      2224018117,
      4143653529,
      4112773975,
      2788324899,
      2477274417,
      1456262402,
      2901442914,
      1517677493,
      1846949527,
      2295493580,
      3734397586,
      2176403920,
      1280348187,
      1908823572,
      3871786941,
      846861322,
      1172426758,
      3287448474,
      3383383037,
      1655181056,
      3139813346,
      901632758,
      1897031941,
      2986607138,
      3066810236,
      3447102507,
      1393639104,
      373351379,
      950779232,
      625454576,
      3124240540,
      4148612726,
      2007998917,
      544563296,
      2244738638,
      2330496472,
      2058025392,
      1291430526,
      424198748,
      50039436,
      29584100,
      3605783033,
      2429876329,
      2791104160,
      1057563949,
      3255363231,
      3075367218,
      3463963227,
      1469046755,
      985887462
    ], ve = [
      1332899944,
      1700884034,
      1701343084,
      1684370003,
      1668446532,
      1869963892
    ];
    function Pe(J, ne, A, I) {
      var U, X = J[ne], Q = J[ne + 1];
      return X ^= A[0], U = I[X >>> 24], U += I[256 | X >> 16 & 255], U ^= I[512 | X >> 8 & 255], U += I[768 | X & 255], Q ^= U ^ A[1], U = I[Q >>> 24], U += I[256 | Q >> 16 & 255], U ^= I[512 | Q >> 8 & 255], U += I[768 | Q & 255], X ^= U ^ A[2], U = I[X >>> 24], U += I[256 | X >> 16 & 255], U ^= I[512 | X >> 8 & 255], U += I[768 | X & 255], Q ^= U ^ A[3], U = I[Q >>> 24], U += I[256 | Q >> 16 & 255], U ^= I[512 | Q >> 8 & 255], U += I[768 | Q & 255], X ^= U ^ A[4], U = I[X >>> 24], U += I[256 | X >> 16 & 255], U ^= I[512 | X >> 8 & 255], U += I[768 | X & 255], Q ^= U ^ A[5], U = I[Q >>> 24], U += I[256 | Q >> 16 & 255], U ^= I[512 | Q >> 8 & 255], U += I[768 | Q & 255], X ^= U ^ A[6], U = I[X >>> 24], U += I[256 | X >> 16 & 255], U ^= I[512 | X >> 8 & 255], U += I[768 | X & 255], Q ^= U ^ A[7], U = I[Q >>> 24], U += I[256 | Q >> 16 & 255], U ^= I[512 | Q >> 8 & 255], U += I[768 | Q & 255], X ^= U ^ A[8], U = I[X >>> 24], U += I[256 | X >> 16 & 255], U ^= I[512 | X >> 8 & 255], U += I[768 | X & 255], Q ^= U ^ A[9], U = I[Q >>> 24], U += I[256 | Q >> 16 & 255], U ^= I[512 | Q >> 8 & 255], U += I[768 | Q & 255], X ^= U ^ A[10], U = I[X >>> 24], U += I[256 | X >> 16 & 255], U ^= I[512 | X >> 8 & 255], U += I[768 | X & 255], Q ^= U ^ A[11], U = I[Q >>> 24], U += I[256 | Q >> 16 & 255], U ^= I[512 | Q >> 8 & 255], U += I[768 | Q & 255], X ^= U ^ A[12], U = I[X >>> 24], U += I[256 | X >> 16 & 255], U ^= I[512 | X >> 8 & 255], U += I[768 | X & 255], Q ^= U ^ A[13], U = I[Q >>> 24], U += I[256 | Q >> 16 & 255], U ^= I[512 | Q >> 8 & 255], U += I[768 | Q & 255], X ^= U ^ A[14], U = I[X >>> 24], U += I[256 | X >> 16 & 255], U ^= I[512 | X >> 8 & 255], U += I[768 | X & 255], Q ^= U ^ A[15], U = I[Q >>> 24], U += I[256 | Q >> 16 & 255], U ^= I[512 | Q >> 8 & 255], U += I[768 | Q & 255], X ^= U ^ A[16], J[ne] = Q ^ A[fe + 1], J[ne + 1] = X, J;
    }
    function Ue(J, ne) {
      for (var A = 0, I = 0; A < 4; ++A)
        I = I << 8 | J[ne] & 255, ne = (ne + 1) % J.length;
      return { key: I, offp: ne };
    }
    function ze(J, ne, A) {
      for (var I = 0, U = [0, 0], X = ne.length, Q = A.length, F, $ = 0; $ < X; $++)
        F = Ue(J, I), I = F.offp, ne[$] = ne[$] ^ F.key;
      for ($ = 0; $ < X; $ += 2)
        U = Pe(U, 0, ne, A), ne[$] = U[0], ne[$ + 1] = U[1];
      for ($ = 0; $ < Q; $ += 2)
        U = Pe(U, 0, ne, A), A[$] = U[0], A[$ + 1] = U[1];
    }
    function Le(J, ne, A, I) {
      for (var U = 0, X = [0, 0], Q = A.length, F = I.length, $, H = 0; H < Q; H++)
        $ = Ue(ne, U), U = $.offp, A[H] = A[H] ^ $.key;
      for (U = 0, H = 0; H < Q; H += 2)
        $ = Ue(J, U), U = $.offp, X[0] ^= $.key, $ = Ue(J, U), U = $.offp, X[1] ^= $.key, X = Pe(X, 0, A, I), A[H] = X[0], A[H + 1] = X[1];
      for (H = 0; H < F; H += 2)
        $ = Ue(J, U), U = $.offp, X[0] ^= $.key, $ = Ue(J, U), U = $.offp, X[1] ^= $.key, X = Pe(X, 0, A, I), I[H] = X[0], I[H + 1] = X[1];
    }
    function Ne(J, ne, A, I, U) {
      var X = ve.slice(), Q = X.length, F;
      if (A < 4 || A > 31)
        if (F = Error("Illegal number of rounds (4-31): " + A), I) {
          B(I.bind(this, F));
          return;
        } else
          throw F;
      if (ne.length !== ie)
        if (F = Error("Illegal salt length: " + ne.length + " != " + ie), I) {
          B(I.bind(this, F));
          return;
        } else
          throw F;
      A = 1 << A >>> 0;
      var $, H, q = 0, z;
      Int32Array ? ($ = new Int32Array(ce), H = new Int32Array(be)) : ($ = ce.slice(), H = be.slice()), Le(ne, J, $, H);
      function me() {
        if (U && U(q / A), q < A)
          for (var je = Date.now(); q < A && (q = q + 1, ze(J, $, H), ze(ne, $, H), !(Date.now() - je > de)); )
            ;
        else {
          for (q = 0; q < 64; q++)
            for (z = 0; z < Q >> 1; z++)
              Pe(X, z << 1, $, H);
          var Re = [];
          for (q = 0; q < Q; q++)
            Re.push((X[q] >> 24 & 255) >>> 0), Re.push((X[q] >> 16 & 255) >>> 0), Re.push((X[q] >> 8 & 255) >>> 0), Re.push((X[q] & 255) >>> 0);
          if (I) {
            I(null, Re);
            return;
          } else
            return Re;
        }
        I && B(me);
      }
      if (typeof I < "u")
        me();
      else
        for (var Ce; ; )
          if (typeof (Ce = me()) < "u")
            return Ce || [];
    }
    function $e(J, ne, A, I) {
      var U;
      if (typeof J != "string" || typeof ne != "string")
        if (U = Error("Invalid string / salt: Not a string"), A) {
          B(A.bind(this, U));
          return;
        } else
          throw U;
      var X, Q;
      if (ne.charAt(0) !== "$" || ne.charAt(1) !== "2")
        if (U = Error("Invalid salt version: " + ne.substring(0, 2)), A) {
          B(A.bind(this, U));
          return;
        } else
          throw U;
      if (ne.charAt(2) === "$")
        X = "\0", Q = 3;
      else {
        if (X = ne.charAt(2), X !== "a" && X !== "b" && X !== "y" || ne.charAt(3) !== "$")
          if (U = Error("Invalid salt revision: " + ne.substring(2, 4)), A) {
            B(A.bind(this, U));
            return;
          } else
            throw U;
        Q = 4;
      }
      if (ne.charAt(Q + 2) > "$")
        if (U = Error("Missing salt rounds"), A) {
          B(A.bind(this, U));
          return;
        } else
          throw U;
      var F = parseInt(ne.substring(Q, Q + 1), 10) * 10, $ = parseInt(ne.substring(Q + 1, Q + 2), 10), H = F + $, q = ne.substring(Q + 3, Q + 25);
      J += X >= "a" ? "\0" : "";
      var z = M(J), me = Y(q, ie);
      function Ce(je) {
        var Re = [];
        return Re.push("$2"), X >= "a" && Re.push(X), Re.push("$"), H < 10 && Re.push("0"), Re.push(H.toString()), Re.push("$"), Re.push(Z(me, me.length)), Re.push(Z(je, ve.length * 4 - 1)), Re.join("");
      }
      if (typeof A > "u")
        return Ce(Ne(z, me, H));
      Ne(z, me, H, function(je, Re) {
        je ? A(je, null) : A(null, Ce(Re));
      }, I);
    }
    return t.encodeBase64 = Z, t.decodeBase64 = Y, t;
  });
})(bcrypt$1);
var bcryptExports = bcrypt$1.exports;
const bcrypt = /* @__PURE__ */ getDefaultExportFromCjs(bcryptExports);
class FirebaseAuthAPI {
  constructor(t) {
    this.FIREBASE_AUTH_URL = "https://identitytoolkit.googleapis.com/v1/", this.BCRYPT_SALT = "$2a$10$QCJoWqnN.acrjPIgKYCthu";
    const h = new URL(this.FIREBASE_AUTH_URL);
    this.firebaseKey = t.apiKey, this.fetcher = new FetchAPI(h.toString());
  }
  checkError(t) {
    if (t.error)
      throw new Error(
        `Error code: ${t.error.code}, message: ${t.error.message}`
      );
  }
  async signUpWithEmailPassword(t, h, o = !0) {
    let S = h;
    o && (S = bcrypt.hashSync(h, this.BCRYPT_SALT));
    const g = JSON.stringify({
      email: t,
      password: S,
      returnSecureToken: !0
    }), B = await this.fetcher.send({
      url: "accounts:signUp",
      method: "POST",
      data: g,
      query: {
        key: this.firebaseKey
      },
      withCredentials: !1
    });
    return this.checkError(B.data), B.data;
  }
  async signInWithEmailPassword(t, h, o = !0) {
    let S = h;
    o && (S = bcrypt.hashSync(h, this.BCRYPT_SALT));
    const g = JSON.stringify({
      email: t,
      password: S,
      returnSecureToken: !0
    }), B = await this.fetcher.send({
      url: "accounts:signInWithPassword",
      method: "POST",
      data: g,
      query: {
        key: this.firebaseKey
      },
      withCredentials: !1
    });
    return this.checkError(B.data), B.data;
  }
  async getCurrentUser(t) {
    const h = JSON.stringify({
      idToken: t
    }), o = await this.fetcher.send({
      url: "accounts:lookup",
      method: "POST",
      data: h,
      query: {
        key: this.firebaseKey
      },
      withCredentials: !1
    });
    return this.checkError(o.data), o.data;
  }
  async getRefreshIdToken(t) {
    const h = JSON.stringify({
      grant_type: "refresh_token",
      refresh_token: t
    }), o = await this.fetcher.send({
      url: "token",
      method: "POST",
      data: h,
      query: {
        key: this.firebaseKey
      },
      withCredentials: !1
    }), S = o.data;
    return this.checkError(o.data), S.id_token;
  }
  async resetPassword(t, h, o = !0) {
    let S = h;
    o && (S = bcrypt.hashSync(h, this.BCRYPT_SALT));
    const g = JSON.stringify({
      oobCode: t,
      newPassword: S
    }), B = await this.fetcher.send({
      url: "accounts:resetPassword",
      method: "POST",
      data: g,
      query: {
        key: this.firebaseKey
      },
      withCredentials: !1
    });
    return this.checkError(B.data), B.data;
  }
  async verifyEmail(t) {
    const h = JSON.stringify({
      oobCode: t
    }), o = await this.fetcher.send({
      url: "accounts:update",
      method: "POST",
      data: h,
      query: {
        key: this.firebaseKey
      },
      withCredentials: !1
    });
    return this.checkError(o.data), o.data;
  }
  async signInWithCustomToken(t) {
    const h = JSON.stringify({
      token: t,
      returnSecureToken: !0
    }), o = await this.fetcher.send({
      url: "accounts:signInWithCustomToken",
      data: h,
      query: {
        key: this.firebaseKey
      },
      method: "POST",
      withCredentials: !1
    });
    return this.checkError(o.data), {
      idToken: o.data.idToken,
      refreshToken: o.data.refreshToken
    };
  }
  async updatePassword(t, h) {
    const o = bcrypt.hashSync(h, this.BCRYPT_SALT), S = JSON.stringify({
      idToken: t,
      password: o,
      returnSecureToken: !0
    }), g = await this.fetcher.send({
      url: "accounts:update",
      method: "POST",
      data: S,
      query: {
        key: this.firebaseKey
      },
      withCredentials: !1
    });
    return this.checkError(g.data), g.data;
  }
}
var u$1 = (e, t, h) => {
  if (!t.has(e))
    throw TypeError("Cannot " + h);
}, i$1 = (e, t, h) => (u$1(e, t, "read from private field"), h ? h.call(e) : t.get(e)), n$1 = (e, t, h) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, h);
}, l$1;
const s$1 = class TM {
  static getLocalStorageEnabled() {
    let t = !1;
    try {
      t = window.localStorage && !0;
    } catch {
      t = !1;
    }
    return t;
  }
  static setAllLocalStorage(t, h) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const o = JSON.stringify(h);
    localStorage.setItem(i$1(this, l$1) + t, o);
  }
  static setLocalStorage(t, h, o) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const S = this.getAllLocalStorage(t);
    if (S) {
      S[h] = o, localStorage.setItem(
        i$1(this, l$1) + t,
        // btoa(JSON.stringify(localData)),
        JSON.stringify(S)
      );
      return;
    }
    const g = { [h]: o };
    localStorage.setItem(
      i$1(this, l$1) + t,
      // btoa(JSON.stringify(newData)),
      JSON.stringify(g)
    );
  }
  static getLocalStorage(t, h) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const o = this.getAllLocalStorage(t);
    try {
      if (o)
        return JSON.parse(o[h]);
    } catch {
      return o[h];
    }
  }
  static getAllLocalStorage(t) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    try {
      return localStorage.getItem(i$1(this, l$1) + t) ? (
        // ? JSON.parse(atob(localStorage.getItem(this.#COOKIE_NAME + appId)))
        JSON.parse(localStorage.getItem(i$1(this, l$1) + t))
      ) : void 0;
    } catch {
      return;
    }
  }
  static clearLocalStorage(t, h) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    if (this.getLocalStorage(t, h)) {
      const o = this.getAllLocalStorage(t);
      delete o[h], localStorage.setItem(
        i$1(this, l$1) + t,
        // btoa(JSON.stringify(localData)),
        JSON.stringify(o)
      );
    }
  }
  static clearAllLocalStorage(t) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    localStorage.removeItem(i$1(this, l$1) + t);
  }
  static setLoginUserLocalStorage(t, h, o) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const S = {};
    return S["firebase:wepin"] = Object.assign(
      { provider: h == null ? void 0 : h.provider },
      h == null ? void 0 : h.token
    ), S["wepin:connectUser"] = {
      accessToken: o.token.access,
      refreshToken: o.token.refresh
    }, S.user_id = o.userInfo.userId, S.user_info = {
      status: "success",
      userInfo: {
        userId: o.userInfo.userId,
        email: o.userInfo.email,
        provider: h.provider,
        use2FA: o.userInfo.use2FA >= 2
      }
    }, S.user_status = {
      loginStatus: o.loginStatus,
      pinRequired: o.loginStatus === "registerRequired" ? o.pinRequired : !1
    }, o.loginStatus !== "pinRequired" && o.walletId && (S.wallet_id = o.walletId, S.user_info.walletId = o.walletId), S.oauth_provider_pending = h.provider, TM.setAllLocalStorage(t, S), {
      userInfo: S.user_info,
      connectUser: S["wepin:connectUser"]
    };
  }
};
l$1 = /* @__PURE__ */ new WeakMap(), s$1.platform = "web", n$1(s$1, l$1, "wepin:auth:");
let c$1 = s$1;
const isErrorResponse = (e) => {
  const t = e.statusCode !== void 0 || e.status !== void 0, h = e.timestamp !== void 0 && e.message !== void 0 && e.path !== void 0;
  return t && h;
}, getBaseUrl = (e) => {
  if (e.slice(0, 8) === "ak_live_")
    return "https://sdk.wepin.io/v1";
  if (e.slice(0, 8) === "ak_test_")
    return "https://stage-sdk.wepin.io/v1";
  if (e.slice(0, 7) === "ak_dev_")
    return "https://dev-sdk.wepin.io/v1";
  if (e.slice(0, 13) === "local_ak_dev_")
    return "https://local-sdk.wepin.io/v1";
  throw new Error("Invalid appKey");
};
class APIRequest {
  constructor({
    data: t,
    headers: h,
    url: o,
    query: S,
    withCredentials: g = !1,
    method: B
  }) {
    this.data = t, this.headers = h, this.url = o, this.query = S, this.withCredentials = g, this.method = B;
  }
}
const APIEvents = {
  request: "request",
  response: "response"
};
let InvalidTokenError$1 = class extends Error {
};
InvalidTokenError$1.prototype.name = "InvalidTokenError";
function b64DecodeUnicode$1(e) {
  return decodeURIComponent(atob(e).replace(/(.)/g, (t, h) => {
    let o = h.charCodeAt(0).toString(16).toUpperCase();
    return o.length < 2 && (o = "0" + o), "%" + o;
  }));
}
function base64UrlDecode$1(e) {
  let t = e.replace(/-/g, "+").replace(/_/g, "/");
  switch (t.length % 4) {
    case 0:
      break;
    case 2:
      t += "==";
      break;
    case 3:
      t += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode$1(t);
  } catch {
    return atob(t);
  }
}
function jwtDecode$1(e, t) {
  if (typeof e != "string")
    throw new InvalidTokenError$1("Invalid token specified: must be a string");
  t || (t = {});
  const h = t.header === !0 ? 0 : 1, o = e.split(".")[h];
  if (typeof o != "string")
    throw new InvalidTokenError$1(`Invalid token specified: missing part #${h + 1}`);
  let S;
  try {
    S = base64UrlDecode$1(o);
  } catch (g) {
    throw new InvalidTokenError$1(`Invalid token specified: invalid base64 for part #${h + 1} (${g.message})`);
  }
  try {
    return JSON.parse(S);
  } catch (g) {
    throw new InvalidTokenError$1(`Invalid token specified: invalid json for part #${h + 1} (${g.message})`);
  }
}
const checkJwtToken = () => {
  const e = (t) => {
    var h;
    const o = t;
    return !o || ((h = jwtDecode$1(o)) == null ? void 0 : h.exp) <= Math.floor(Date.now() / 1e3) + 60;
  };
  return {
    // isExpiredAccessToken,
    checkTokenExpired: (t, h) => {
      if (!(t === "/app/info" || t === "/user/login" || t === "/user/oauth") && e(h)) {
        if (t !== "/access-token")
          throw new Error("token_expired");
        return;
      }
    }
  };
};
class WepinSDKFetchAPI extends FetchAPI {
  constructor(t, h) {
    super(), this.baseUrl = t, this.params = h, this.addListener(APIEvents.request, this.requestCallback), this.addListener(APIEvents.response, this.responseCallback);
  }
  async send(t, h) {
    await this.emitAsync(APIEvents.request, t, h || {});
    const { data: o, url: S, headers: g } = t, B = (() => {
      if (o instanceof FormData)
        return {};
    })();
    t.headers = Object.assign(g || {}, B);
    const M = await super.send(t, h);
    return this.setToken(S, M), await this.emitAsync(
      APIEvents.response,
      M,
      h || {}
    ), M;
  }
  setToken(t, h) {
    var o, S, g, B, M, O;
    isErrorResponse(h.data) || (t === "user/login" && (o = h.data) != null && o.token ? this.params.wepinFetch.setToken({
      accessToken: (S = h.data) == null ? void 0 : S.token.access,
      refreshToken: (g = h.data) == null ? void 0 : g.token.refresh
    }) : t === "/user/access-token" && (B = h.data) != null && B.token ? this.params.wepinFetch.setToken({
      accessToken: (M = h.data) == null ? void 0 : M.token,
      refreshToken: (O = this.params.wepinFetch.Token) == null ? void 0 : O.refreshToken
    }) : t === "user/logout" && this.params.wepinFetch.setToken());
  }
  async requestCallback(t, h) {
    var o, S, g;
    try {
      t.headers || (t.headers = {}), t.headers["X-API-KEY"] = this.params.appKey;
      const B = this.params.domain && this.params.domain.includes("localhost") ? "" : this.params.domain;
      if (t.headers["X-SDK-TYPE"] = this.params.sdk.type, t.headers["X-SDK-VERSION"] = this.params.sdk.version, t.headers["X-API-DOMAIN"] = B, t.url === "/user/access-token" && (t.query = {
        refresh_token: (o = this.params.wepinFetch.Token) == null ? void 0 : o.refreshToken
      }), h != null && h.ignoreCheckToken)
        return;
      try {
        const O = (S = this.params.wepinFetch.Token) == null ? void 0 : S.accessToken, { checkTokenExpired: P } = checkJwtToken();
        P(t.url, O);
      } catch {
        const O = new APIRequest({
          url: "/user/access-token",
          method: "GET",
          withCredentials: !0
        });
        await this.send(O, { ignoreCheckToken: !0 });
      }
      const M = (g = this.params.wepinFetch.Token) == null ? void 0 : g.accessToken;
      M && (t.headers.Authorization = `Bearer ${M}`);
    } catch {
      throw new Error("Unauthorized Error");
    }
  }
  async responseCallback(t) {
    if (t.status === 401)
      throw new Error("Unauthorized Error");
  }
  // private setUserInfo(url: string, response: any) {
  //   if (!isErrorResponse(response.data) && response.data?.userInfo) {
  //     // set token
  //     if (url === 'user/login') {
  //       WepinStorage.setLocalStorage('userInfo', response.data?.userInfo)
  //       if (response.data?.walletId) {
  //         WepinStorage.setLocalStorage('walletId', response.data?.walletId)
  //       }
  //     } else if (url === '/app/register') {
  //       if (response.data?.walletId) {
  //         WepinStorage.setLocalStorage('walletId', response.data?.walletId)
  //       }
  //     }
  //   }
  // }
}
class UserAPI {
  constructor(t) {
    this.fetcher = t, this.basePath = "/user";
  }
  // 2.1 Check User Email
  async checkEmailExist(t) {
    const h = new APIRequest({
      url: `${this.basePath}/check-user`,
      method: "GET",
      query: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(h, {
      ignoreCheckToken: !0
    })).data;
  }
  // 2.2 Get User PW State
  async getUserPasswordState(t) {
    const h = new APIRequest({
      url: `${this.basePath}/password-state`,
      method: "GET",
      query: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(h, {
      ignoreCheckToken: !0
    })).data;
  }
  // 2.3 Provider Login
  async oAuth(t, h) {
    const o = new APIRequest({
      url: `${this.basePath}/oauth/login/${h.provider}`,
      method: "GET",
      query: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(o, {
      ignoreCheckToken: !0
    })).data;
  }
  // 2.4 Verify User Email
  async verify(t) {
    const h = new APIRequest({
      url: `${this.basePath}/verify`,
      method: "POST",
      data: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(h, {
      ignoreCheckToken: !0
    })).data;
  }
  // 2.5 Login
  async login(t) {
    const h = new APIRequest({
      url: `${this.basePath}/login`,
      method: "POST",
      data: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(h, { ignoreCheckToken: !0 })).data;
  }
  // 2.6 Update User PW State
  async updateUserPasswordState(t, h) {
    const o = new APIRequest({
      url: `${this.basePath}/${t.userId}/password-state`,
      method: "PATCH",
      data: h,
      withCredentials: !0
    });
    return (await this.fetcher.send(o)).data;
  }
  // 2.7 Update Terms Accepted
  async updateTermsAccepted(t, h) {
    const o = new APIRequest({
      url: `${this.basePath}/${t.userId}/terms-accepted`,
      method: "PATCH",
      data: h,
      withCredentials: !0
    });
    return (await this.fetcher.send(o)).data;
  }
  // 2.8 Get Access Token
  async refreshToken() {
    const t = new APIRequest({
      url: `${this.basePath}/access-token`,
      method: "GET",
      // query: {
      //   refresh_token: WepinStorage.getLocalStorage('token')?.refreshToken,
      // },
      withCredentials: !0
    });
    return (await this.fetcher.send(t, { ignoreCheckToken: !0 })).data;
  }
  // 2.9 Get Public Key
  async fetchKey() {
    const t = new APIRequest({
      url: `${this.basePath}/pubkey`,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(t)).data;
  }
  // 2.11 Get Terms Accepted
  async getTermsAccepted(t) {
    const h = new APIRequest({
      url: `${this.basePath}/${t.userId}/terms-accepted`,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(h)).data;
  }
  // 2.12 Logout
  async logout(t) {
    const h = new APIRequest({
      url: `${this.basePath}/${t.userId}/logout`,
      method: "POST",
      withCredentials: !0
    });
    return (await this.fetcher.send(h)).data;
  }
  // 2.13 Get Firebase Config
  async getFirebaseConfig() {
    const t = new APIRequest({
      url: `${this.basePath}/firebase-config`,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(t, { ignoreCheckToken: !0 })).data;
  }
  // 2.14 Login OAuth idToken
  async loginOAuthIdToken(t) {
    const h = new APIRequest({
      url: `${this.basePath}/oauth/login/id-token`,
      method: "POST",
      data: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(h, { ignoreCheckToken: !0 })).data;
  }
  // 2.15 Login OAuth AccessToken
  async loginOAuthAccessToken(t) {
    const h = new APIRequest({
      url: `${this.basePath}/oauth/login/access-token`,
      method: "POST",
      data: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(h, { ignoreCheckToken: !0 })).data;
  }
  // 2.18 Get User Info
  async getUserInfo(t) {
    const h = new APIRequest({
      url: `${this.basePath}/${t.userId}/detail`,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(h)).data;
  }
}
class WalletAPI {
  constructor(t) {
    this.fetcher = t, this.basePath = "/wallet";
  }
  // 3.1 Verify Wallet PIN
  async verifyPin(t) {
    const h = new APIRequest({
      url: `${this.basePath}/pin/verify`,
      data: t,
      method: "POST",
      withCredentials: !0
    });
    return (await this.fetcher.send(h)).data;
  }
  // 3.2 Change Wallet PIN
  async changePin(t) {
    const h = new APIRequest({
      url: `${this.basePath}/pin/change`,
      data: t,
      method: "PATCH",
      withCredentials: !0
    });
    return (await this.fetcher.send(h)).data;
  }
  // 3.3 Get Wallet Info
  async fetchWalletInfo(t, h) {
    const o = new APIRequest({
      url: `${this.basePath}/${t.walletId}`,
      query: h,
      method: "PATCH",
      withCredentials: !0
    });
    return (await this.fetcher.send(o)).data;
  }
  // 3.4 Get Wallet Key Info
  async getWalletKeyInfo(t, h) {
    const o = new APIRequest({
      url: `${this.basePath}/${t.walletId}/wallet-keyinfo`,
      query: h,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(o)).data;
  }
  // 3.5 Reset Wallet PIN Try Count
  async resetPinTryCount(t, h) {
    const o = new APIRequest({
      url: `${this.basePath}/${t.walletId}/pin/reset-try-count`,
      query: h,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(o)).data;
  }
}
class AppAPI {
  constructor(t) {
    this.fetcher = t, this.basePath = "/app";
  }
  // 1.1 Get Theme
  async getThemeById(t) {
    return (await fetch(`${this.fetcher.baseUrl}/app/theme/${t.id}`, {
      method: "GET"
    })).json();
  }
  async getLayoutById(t) {
    return (await fetch(`${this.fetcher.baseUrl}/app/layout/${t.id}`, {
      method: "GET"
    })).json();
  }
  // 1.3 Get App Info
  async getAppInfo(t) {
    const h = new APIRequest({
      url: `${this.basePath}/info`,
      query: t,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(h, {
      ignoreCheckToken: !0
    })).data;
  }
  // 1.4 Get App Coins
  async getAppCoins(t) {
    const h = new APIRequest({
      url: `${this.basePath}/coins`,
      method: "GET",
      query: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(h, {
      ignoreCheckToken: !0
    })).data;
  }
  // 1.5 Get App Theme
  async getAppTheme() {
    const t = new APIRequest({
      url: `${this.basePath}/theme`,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(t, {
      ignoreCheckToken: !0
    })).data;
  }
  // 1.6 Register
  async register(t) {
    const h = new APIRequest({
      url: `${this.basePath}/register`,
      method: "POST",
      data: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(h)).data;
  }
}
class AccountAPI {
  constructor(t) {
    this.fetcher = t, this.basePath = "/account";
  }
  // 4.1 Readdress
  async readdress(t) {
    const h = new APIRequest({
      url: `${this.basePath}/readdress`,
      data: t,
      method: "PATCH",
      withCredentials: !0
    });
    return (await this.fetcher.send(h)).data;
  }
  // 4.2 Get App Account
  async getAppAccountList(t) {
    const h = new APIRequest({
      url: `${this.basePath}`,
      query: t,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(h)).data;
  }
}
class AccountBalanceAPI {
  constructor(t) {
    this.fetcher = t, this.basePath = "/accountbalance";
  }
  // 5.1 Get Account Balance
  async getAccountBalance(t) {
    const h = new APIRequest({
      url: `${this.basePath}/${t.accountId}/balance`,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(h)).data;
  }
}
class NFTAPI {
  constructor(t) {
    this.fetcher = t, this.basePath = "/nft";
  }
  // 6.1 Get NFT supporting network list
  async getSupportingNetworkList() {
    const t = new APIRequest({
      url: `${this.basePath}/support-network`,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(t, {
      // ignoreCheckToken: true,
    })).data;
  }
  // 6.2 Get App NFTs
  async getAppNFTList(t) {
    const h = new APIRequest({
      url: this.basePath,
      method: "GET",
      query: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(h)).data;
  }
  // 6.3 Refresh NFTs
  async refreshAppNFTList(t) {
    const h = new APIRequest({
      url: `${this.basePath}/refresh`,
      method: "GET",
      query: t,
      withCredentials: !0
    });
    return (await this.fetcher.send(h)).data;
  }
}
class TransactionAPI {
  constructor(t) {
    this.fetcher = t, this.basePath = "/tx";
  }
  // 7.1 Sign transaction
  async sign(t) {
    const h = new APIRequest({
      url: `${this.basePath}/sign`,
      data: t,
      method: "POST",
      withCredentials: !0
    });
    return (await this.fetcher.send(h)).data;
  }
  // 7.2 Broadcast Transaction
  async broadCast(t) {
    const h = new APIRequest({
      url: `${this.basePath}/broadcast`,
      data: t,
      method: "POST",
      withCredentials: !0
    });
    return (await this.fetcher.send(h)).data;
  }
  // 7.3 Get prepare transaction data
  async prepareTransaction(t) {
    const h = new APIRequest({
      url: `${this.basePath}/prepare`,
      data: t,
      method: "POST",
      withCredentials: !0
    });
    return (await this.fetcher.send(h)).data;
  }
  // 7.4 Check Address validation
  async checkAddressValidation(t) {
    const h = new APIRequest({
      url: `${this.basePath}/check_address`,
      query: t,
      method: "GET",
      withCredentials: !0
    });
    return (await this.fetcher.send(h)).data;
  }
}
class WepinSdkAPI {
  constructor(t, h) {
    const o = new WepinSDKFetchAPI(t, h);
    this.app = new AppAPI(o), this.user = new UserAPI(o), this.wallet = new WalletAPI(o), this.account = new AccountAPI(o), this.balance = new AccountBalanceAPI(o), this.nft = new NFTAPI(o), this.transaction = new TransactionAPI(o);
  }
}
class WepinFetch {
  constructor({
    appId: t,
    appKey: h,
    domain: o,
    sdk: S,
    storage: g
  }) {
    this.version = packageJson.version, this.appId = t, this._appKey = h, this._domain = o, this._token = void 0, this.sdk = S, this._wepinStorage = g ?? c$1;
  }
  async init() {
    const t = await WepinFetch.getFirebaseConfig(
      this._appKey,
      this.sdk.type,
      this.sdk.version
    );
    this.wepinFirebaseApi = new FirebaseAuthAPI(t), this.wepinApi = new WepinSdkAPI(getBaseUrl(this._appKey), {
      appId: this.appId,
      appKey: this._appKey,
      domain: this._domain,
      sdk: this.sdk,
      wepinFetch: this
    }), this._isInitialized = !0;
  }
  isInitialized() {
    return this._isInitialized;
  }
  static async getFirebaseConfig(t, h, o) {
    const S = getBaseUrl(t), g = await (await fetch(`${S}/user/firebase-config`, {
      method: "GET",
      headers: {
        "X-API-KEY": t,
        "X-SDK-TYPE": h,
        "X-SDK-VERSION": o,
        "Content-Type": "application/json"
      }
    })).text();
    return JSON.parse(atob(g));
  }
  get Token() {
    return this._token = this._wepinStorage.getLocalStorage(
      this.appId,
      "wepin:connectUser"
    ), this._token;
  }
  setToken(t) {
    this._token = t, t ? this._wepinStorage.setLocalStorage(this.appId, "wepin:connectUser", t) : this._wepinStorage.clearLocalStorage(this.appId, "wepin:connectUser");
  }
  // public finalize() {
  //   this._wepinStorage.clearLocalStorage(this.appId, 'wepin:connectUser')
  // }
}
var ProjectPlatformKind = /* @__PURE__ */ ((e) => (e[e.web = 1] = "web", e[e.android = 2] = "android", e[e.ios = 3] = "ios", e))(ProjectPlatformKind || {});
class InvalidTokenError extends Error {
}
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(e) {
  return decodeURIComponent(atob(e).replace(/(.)/g, (t, h) => {
    let o = h.charCodeAt(0).toString(16).toUpperCase();
    return o.length < 2 && (o = "0" + o), "%" + o;
  }));
}
function base64UrlDecode(e) {
  let t = e.replace(/-/g, "+").replace(/_/g, "/");
  switch (t.length % 4) {
    case 0:
      break;
    case 2:
      t += "==";
      break;
    case 3:
      t += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode(t);
  } catch {
    return atob(t);
  }
}
function jwtDecode(e, t) {
  if (typeof e != "string")
    throw new InvalidTokenError("Invalid token specified: must be a string");
  t || (t = {});
  const h = t.header === !0 ? 0 : 1, o = e.split(".")[h];
  if (typeof o != "string")
    throw new InvalidTokenError(`Invalid token specified: missing part #${h + 1}`);
  let S;
  try {
    S = base64UrlDecode(o);
  } catch (g) {
    throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${h + 1} (${g.message})`);
  }
  try {
    return JSON.parse(S);
  } catch (g) {
    throw new InvalidTokenError(`Invalid token specified: invalid json for part #${h + 1} (${g.message})`);
  }
}
const getAccountSDK = (e) => {
  let t = [];
  return e != null && e.length && (t = e.map((h) => h.contract && h.accountTokenId ? {
    network: h.network,
    address: h.address,
    contract: h.contract
    // name: account.name,
  } : {
    network: h.network,
    address: h.address
  })), t;
}, filterAccountList = (e, t) => {
  const { accounts: h, aa_accounts: o } = e;
  return t ? o ? h.concat(o) : h : h.map((g) => {
    const B = o == null ? void 0 : o.find(
      (M) => M.coinId === g.coinId && (M == null ? void 0 : M.contract) === (g == null ? void 0 : g.contract) && (M == null ? void 0 : M.eoaAddress) === g.address
    );
    return B || g;
  });
};
var u = (e, t, h) => {
  if (!t.has(e))
    throw TypeError("Cannot " + h);
}, i = (e, t, h) => (u(e, t, "read from private field"), h ? h.call(e) : t.get(e)), n = (e, t, h) => {
  if (t.has(e))
    throw TypeError("Cannot add the same private member more than once");
  t instanceof WeakSet ? t.add(e) : t.set(e, h);
}, l;
const s = class kM {
  static getLocalStorageEnabled() {
    let t = !1;
    try {
      t = window.localStorage && !0;
    } catch {
      t = !1;
    }
    return t;
  }
  static setAllLocalStorage(t, h) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const o = JSON.stringify(h);
    localStorage.setItem(i(this, l) + t, o);
  }
  static setLocalStorage(t, h, o) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const S = this.getAllLocalStorage(t);
    if (S) {
      S[h] = o, localStorage.setItem(
        i(this, l) + t,
        // btoa(JSON.stringify(localData)),
        JSON.stringify(S)
      );
      return;
    }
    const g = { [h]: o };
    localStorage.setItem(
      i(this, l) + t,
      // btoa(JSON.stringify(newData)),
      JSON.stringify(g)
    );
  }
  static getLocalStorage(t, h) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const o = this.getAllLocalStorage(t);
    try {
      if (o)
        return JSON.parse(o[h]);
    } catch {
      return o[h];
    }
  }
  static getAllLocalStorage(t) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    try {
      return localStorage.getItem(i(this, l) + t) ? (
        // ? JSON.parse(atob(localStorage.getItem(this.#COOKIE_NAME + appId)))
        JSON.parse(localStorage.getItem(i(this, l) + t))
      ) : void 0;
    } catch {
      return;
    }
  }
  static clearLocalStorage(t, h) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    if (this.getLocalStorage(t, h)) {
      const o = this.getAllLocalStorage(t);
      delete o[h], localStorage.setItem(
        i(this, l) + t,
        // btoa(JSON.stringify(localData)),
        JSON.stringify(o)
      );
    }
  }
  static clearAllLocalStorage(t) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    localStorage.removeItem(i(this, l) + t);
  }
  static setLoginUserLocalStorage(t, h, o) {
    if (!this.getLocalStorageEnabled()) {
      console.error(
        "Local storage is not available. We recommend using local storage to maintain login sessions."
      );
      return;
    }
    const S = {};
    return S["firebase:wepin"] = Object.assign(
      { provider: h == null ? void 0 : h.provider },
      h == null ? void 0 : h.token
    ), S["wepin:connectUser"] = {
      accessToken: o.token.access,
      refreshToken: o.token.refresh
    }, S.user_id = o.userInfo.userId, S.user_info = {
      status: "success",
      userInfo: {
        userId: o.userInfo.userId,
        email: o.userInfo.email,
        provider: h.provider,
        use2FA: o.userInfo.use2FA >= 2
      }
    }, S.user_status = {
      loginStatus: o.loginStatus,
      pinRequired: o.loginStatus === "registerRequired" ? o.pinRequired : !1
    }, o.loginStatus !== "pinRequired" && o.walletId && (S.wallet_id = o.walletId, S.user_info.walletId = o.walletId), S.oauth_provider_pending = h.provider, kM.setAllLocalStorage(t, S), {
      userInfo: S.user_info,
      connectUser: S["wepin:connectUser"]
    };
  }
};
l = /* @__PURE__ */ new WeakMap(), s.platform = "web", n(s, l, "wepin:auth:");
let c = s;
var Me = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof _global < "u" ? _global : typeof self < "u" ? self : {};
function Gs(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var pe = {}, zs = {};
zs.byteLength = cg;
zs.toByteArray = lg;
zs.fromByteArray = vg;
var Pi = [], Ur = [], og = typeof Uint8Array < "u" ? Uint8Array : Array, Gf = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (var ca = 0, ug = Gf.length; ca < ug; ++ca)
  Pi[ca] = Gf[ca], Ur[Gf.charCodeAt(ca)] = ca;
Ur[45] = 62;
Ur[95] = 63;
function n1(e) {
  var t = e.length;
  if (t % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var h = e.indexOf("=");
  h === -1 && (h = t);
  var o = h === t ? 0 : 4 - h % 4;
  return [h, o];
}
function cg(e) {
  var t = n1(e), h = t[0], o = t[1];
  return (h + o) * 3 / 4 - o;
}
function hg(e, t, h) {
  return (t + h) * 3 / 4 - h;
}
function lg(e) {
  var t, h = n1(e), o = h[0], S = h[1], g = new og(hg(e, o, S)), B = 0, M = S > 0 ? o - 4 : o, O;
  for (O = 0; O < M; O += 4)
    t = Ur[e.charCodeAt(O)] << 18 | Ur[e.charCodeAt(O + 1)] << 12 | Ur[e.charCodeAt(O + 2)] << 6 | Ur[e.charCodeAt(O + 3)], g[B++] = t >> 16 & 255, g[B++] = t >> 8 & 255, g[B++] = t & 255;
  return S === 2 && (t = Ur[e.charCodeAt(O)] << 2 | Ur[e.charCodeAt(O + 1)] >> 4, g[B++] = t & 255), S === 1 && (t = Ur[e.charCodeAt(O)] << 10 | Ur[e.charCodeAt(O + 1)] << 4 | Ur[e.charCodeAt(O + 2)] >> 2, g[B++] = t >> 8 & 255, g[B++] = t & 255), g;
}
function dg(e) {
  return Pi[e >> 18 & 63] + Pi[e >> 12 & 63] + Pi[e >> 6 & 63] + Pi[e & 63];
}
function pg(e, t, h) {
  for (var o, S = [], g = t; g < h; g += 3)
    o = (e[g] << 16 & 16711680) + (e[g + 1] << 8 & 65280) + (e[g + 2] & 255), S.push(dg(o));
  return S.join("");
}
function vg(e) {
  for (var t, h = e.length, o = h % 3, S = [], g = 16383, B = 0, M = h - o; B < M; B += g)
    S.push(pg(e, B, B + g > M ? M : B + g));
  return o === 1 ? (t = e[h - 1], S.push(
    Pi[t >> 2] + Pi[t << 4 & 63] + "=="
  )) : o === 2 && (t = (e[h - 2] << 8) + e[h - 1], S.push(
    Pi[t >> 10] + Pi[t >> 4 & 63] + Pi[t << 2 & 63] + "="
  )), S.join("");
}
var Oc = {};
/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
Oc.read = function(e, t, h, o, S) {
  var g, B, M = S * 8 - o - 1, O = (1 << M) - 1, P = O >> 1, D = -7, Z = h ? S - 1 : 0, Y = h ? -1 : 1, ee = e[t + Z];
  for (Z += Y, g = ee & (1 << -D) - 1, ee >>= -D, D += M; D > 0; g = g * 256 + e[t + Z], Z += Y, D -= 8)
    ;
  for (B = g & (1 << -D) - 1, g >>= -D, D += o; D > 0; B = B * 256 + e[t + Z], Z += Y, D -= 8)
    ;
  if (g === 0)
    g = 1 - P;
  else {
    if (g === O)
      return B ? NaN : (ee ? -1 : 1) * (1 / 0);
    B = B + Math.pow(2, o), g = g - P;
  }
  return (ee ? -1 : 1) * B * Math.pow(2, g - o);
};
Oc.write = function(e, t, h, o, S, g) {
  var B, M, O, P = g * 8 - S - 1, D = (1 << P) - 1, Z = D >> 1, Y = S === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, ee = o ? 0 : g - 1, ie = o ? 1 : -1, ue = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
  for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (M = isNaN(t) ? 1 : 0, B = D) : (B = Math.floor(Math.log(t) / Math.LN2), t * (O = Math.pow(2, -B)) < 1 && (B--, O *= 2), B + Z >= 1 ? t += Y / O : t += Y * Math.pow(2, 1 - Z), t * O >= 2 && (B++, O /= 2), B + Z >= D ? (M = 0, B = D) : B + Z >= 1 ? (M = (t * O - 1) * Math.pow(2, S), B = B + Z) : (M = t * Math.pow(2, Z - 1) * Math.pow(2, S), B = 0)); S >= 8; e[h + ee] = M & 255, ee += ie, M /= 256, S -= 8)
    ;
  for (B = B << S | M, P += S; P > 0; e[h + ee] = B & 255, ee += ie, B /= 256, P -= 8)
    ;
  e[h + ee - ie] |= ue * 128;
};
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
(function(e) {
  var t = zs, h = Oc, o = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  e.Buffer = M, e.SlowBuffer = ce, e.INSPECT_MAX_BYTES = 50;
  var S = 2147483647;
  e.kMaxLength = S, M.TYPED_ARRAY_SUPPORT = g(), !M.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function g() {
    try {
      var re = new Uint8Array(1), oe = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(oe, Uint8Array.prototype), Object.setPrototypeOf(re, oe), re.foo() === 42;
    } catch {
      return !1;
    }
  }
  Object.defineProperty(M.prototype, "parent", {
    enumerable: !0,
    get: function() {
      if (M.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(M.prototype, "offset", {
    enumerable: !0,
    get: function() {
      if (M.isBuffer(this))
        return this.byteOffset;
    }
  });
  function B(re) {
    if (re > S)
      throw new RangeError('The value "' + re + '" is invalid for option "size"');
    var oe = new Uint8Array(re);
    return Object.setPrototypeOf(oe, M.prototype), oe;
  }
  function M(re, oe, le) {
    if (typeof re == "number") {
      if (typeof oe == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return Z(re);
    }
    return O(re, oe, le);
  }
  M.poolSize = 8192;
  function O(re, oe, le) {
    if (typeof re == "string")
      return Y(re, oe);
    if (ArrayBuffer.isView(re))
      return ie(re);
    if (re == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof re
      );
    if (Xe(re, ArrayBuffer) || re && Xe(re.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (Xe(re, SharedArrayBuffer) || re && Xe(re.buffer, SharedArrayBuffer)))
      return ue(re, oe, le);
    if (typeof re == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    var ge = re.valueOf && re.valueOf();
    if (ge != null && ge !== re)
      return M.from(ge, oe, le);
    var Ke = fe(re);
    if (Ke)
      return Ke;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof re[Symbol.toPrimitive] == "function")
      return M.from(
        re[Symbol.toPrimitive]("string"),
        oe,
        le
      );
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof re
    );
  }
  M.from = function(re, oe, le) {
    return O(re, oe, le);
  }, Object.setPrototypeOf(M.prototype, Uint8Array.prototype), Object.setPrototypeOf(M, Uint8Array);
  function P(re) {
    if (typeof re != "number")
      throw new TypeError('"size" argument must be of type number');
    if (re < 0)
      throw new RangeError('The value "' + re + '" is invalid for option "size"');
  }
  function D(re, oe, le) {
    return P(re), re <= 0 ? B(re) : oe !== void 0 ? typeof le == "string" ? B(re).fill(oe, le) : B(re).fill(oe) : B(re);
  }
  M.alloc = function(re, oe, le) {
    return D(re, oe, le);
  };
  function Z(re) {
    return P(re), B(re < 0 ? 0 : de(re) | 0);
  }
  M.allocUnsafe = function(re) {
    return Z(re);
  }, M.allocUnsafeSlow = function(re) {
    return Z(re);
  };
  function Y(re, oe) {
    if ((typeof oe != "string" || oe === "") && (oe = "utf8"), !M.isEncoding(oe))
      throw new TypeError("Unknown encoding: " + oe);
    var le = be(re, oe) | 0, ge = B(le), Ke = ge.write(re, oe);
    return Ke !== le && (ge = ge.slice(0, Ke)), ge;
  }
  function ee(re) {
    for (var oe = re.length < 0 ? 0 : de(re.length) | 0, le = B(oe), ge = 0; ge < oe; ge += 1)
      le[ge] = re[ge] & 255;
    return le;
  }
  function ie(re) {
    if (Xe(re, Uint8Array)) {
      var oe = new Uint8Array(re);
      return ue(oe.buffer, oe.byteOffset, oe.byteLength);
    }
    return ee(re);
  }
  function ue(re, oe, le) {
    if (oe < 0 || re.byteLength < oe)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (re.byteLength < oe + (le || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    var ge;
    return oe === void 0 && le === void 0 ? ge = new Uint8Array(re) : le === void 0 ? ge = new Uint8Array(re, oe) : ge = new Uint8Array(re, oe, le), Object.setPrototypeOf(ge, M.prototype), ge;
  }
  function fe(re) {
    if (M.isBuffer(re)) {
      var oe = de(re.length) | 0, le = B(oe);
      return le.length === 0 || re.copy(le, 0, 0, oe), le;
    }
    if (re.length !== void 0)
      return typeof re.length != "number" || et(re.length) ? B(0) : ee(re);
    if (re.type === "Buffer" && Array.isArray(re.data))
      return ee(re.data);
  }
  function de(re) {
    if (re >= S)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + S.toString(16) + " bytes");
    return re | 0;
  }
  function ce(re) {
    return +re != re && (re = 0), M.alloc(+re);
  }
  M.isBuffer = function(re) {
    return re != null && re._isBuffer === !0 && re !== M.prototype;
  }, M.compare = function(re, oe) {
    if (Xe(re, Uint8Array) && (re = M.from(re, re.offset, re.byteLength)), Xe(oe, Uint8Array) && (oe = M.from(oe, oe.offset, oe.byteLength)), !M.isBuffer(re) || !M.isBuffer(oe))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (re === oe)
      return 0;
    for (var le = re.length, ge = oe.length, Ke = 0, Je = Math.min(le, ge); Ke < Je; ++Ke)
      if (re[Ke] !== oe[Ke]) {
        le = re[Ke], ge = oe[Ke];
        break;
      }
    return le < ge ? -1 : ge < le ? 1 : 0;
  }, M.isEncoding = function(re) {
    switch (String(re).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }, M.concat = function(re, oe) {
    if (!Array.isArray(re))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (re.length === 0)
      return M.alloc(0);
    var le;
    if (oe === void 0)
      for (oe = 0, le = 0; le < re.length; ++le)
        oe += re[le].length;
    var ge = M.allocUnsafe(oe), Ke = 0;
    for (le = 0; le < re.length; ++le) {
      var Je = re[le];
      if (Xe(Je, Uint8Array))
        Ke + Je.length > ge.length ? M.from(Je).copy(ge, Ke) : Uint8Array.prototype.set.call(
          ge,
          Je,
          Ke
        );
      else if (M.isBuffer(Je))
        Je.copy(ge, Ke);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      Ke += Je.length;
    }
    return ge;
  };
  function be(re, oe) {
    if (M.isBuffer(re))
      return re.length;
    if (ArrayBuffer.isView(re) || Xe(re, ArrayBuffer))
      return re.byteLength;
    if (typeof re != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof re
      );
    var le = re.length, ge = arguments.length > 2 && arguments[2] === !0;
    if (!ge && le === 0)
      return 0;
    for (var Ke = !1; ; )
      switch (oe) {
        case "ascii":
        case "latin1":
        case "binary":
          return le;
        case "utf8":
        case "utf-8":
          return ke(re).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return le * 2;
        case "hex":
          return le >>> 1;
        case "base64":
          return qe(re).length;
        default:
          if (Ke)
            return ge ? -1 : ke(re).length;
          oe = ("" + oe).toLowerCase(), Ke = !0;
      }
  }
  M.byteLength = be;
  function ve(re, oe, le) {
    var ge = !1;
    if ((oe === void 0 || oe < 0) && (oe = 0), oe > this.length || ((le === void 0 || le > this.length) && (le = this.length), le <= 0) || (le >>>= 0, oe >>>= 0, le <= oe))
      return "";
    for (re || (re = "utf8"); ; )
      switch (re) {
        case "hex":
          return $(this, oe, le);
        case "utf8":
        case "utf-8":
          return I(this, oe, le);
        case "ascii":
          return Q(this, oe, le);
        case "latin1":
        case "binary":
          return F(this, oe, le);
        case "base64":
          return A(this, oe, le);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return H(this, oe, le);
        default:
          if (ge)
            throw new TypeError("Unknown encoding: " + re);
          re = (re + "").toLowerCase(), ge = !0;
      }
  }
  M.prototype._isBuffer = !0;
  function Pe(re, oe, le) {
    var ge = re[oe];
    re[oe] = re[le], re[le] = ge;
  }
  M.prototype.swap16 = function() {
    var re = this.length;
    if (re % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var oe = 0; oe < re; oe += 2)
      Pe(this, oe, oe + 1);
    return this;
  }, M.prototype.swap32 = function() {
    var re = this.length;
    if (re % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var oe = 0; oe < re; oe += 4)
      Pe(this, oe, oe + 3), Pe(this, oe + 1, oe + 2);
    return this;
  }, M.prototype.swap64 = function() {
    var re = this.length;
    if (re % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var oe = 0; oe < re; oe += 8)
      Pe(this, oe, oe + 7), Pe(this, oe + 1, oe + 6), Pe(this, oe + 2, oe + 5), Pe(this, oe + 3, oe + 4);
    return this;
  }, M.prototype.toString = function() {
    var re = this.length;
    return re === 0 ? "" : arguments.length === 0 ? I(this, 0, re) : ve.apply(this, arguments);
  }, M.prototype.toLocaleString = M.prototype.toString, M.prototype.equals = function(re) {
    if (!M.isBuffer(re))
      throw new TypeError("Argument must be a Buffer");
    return this === re ? !0 : M.compare(this, re) === 0;
  }, M.prototype.inspect = function() {
    var re = "", oe = e.INSPECT_MAX_BYTES;
    return re = this.toString("hex", 0, oe).replace(/(.{2})/g, "$1 ").trim(), this.length > oe && (re += " ... "), "<Buffer " + re + ">";
  }, o && (M.prototype[o] = M.prototype.inspect), M.prototype.compare = function(re, oe, le, ge, Ke) {
    if (Xe(re, Uint8Array) && (re = M.from(re, re.offset, re.byteLength)), !M.isBuffer(re))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof re
      );
    if (oe === void 0 && (oe = 0), le === void 0 && (le = re ? re.length : 0), ge === void 0 && (ge = 0), Ke === void 0 && (Ke = this.length), oe < 0 || le > re.length || ge < 0 || Ke > this.length)
      throw new RangeError("out of range index");
    if (ge >= Ke && oe >= le)
      return 0;
    if (ge >= Ke)
      return -1;
    if (oe >= le)
      return 1;
    if (oe >>>= 0, le >>>= 0, ge >>>= 0, Ke >>>= 0, this === re)
      return 0;
    for (var Je = Ke - ge, Fe = le - oe, Ye = Math.min(Je, Fe), it = this.slice(ge, Ke), rt = re.slice(oe, le), tt = 0; tt < Ye; ++tt)
      if (it[tt] !== rt[tt]) {
        Je = it[tt], Fe = rt[tt];
        break;
      }
    return Je < Fe ? -1 : Fe < Je ? 1 : 0;
  };
  function Ue(re, oe, le, ge, Ke) {
    if (re.length === 0)
      return -1;
    if (typeof le == "string" ? (ge = le, le = 0) : le > 2147483647 ? le = 2147483647 : le < -2147483648 && (le = -2147483648), le = +le, et(le) && (le = Ke ? 0 : re.length - 1), le < 0 && (le = re.length + le), le >= re.length) {
      if (Ke)
        return -1;
      le = re.length - 1;
    } else if (le < 0)
      if (Ke)
        le = 0;
      else
        return -1;
    if (typeof oe == "string" && (oe = M.from(oe, ge)), M.isBuffer(oe))
      return oe.length === 0 ? -1 : ze(re, oe, le, ge, Ke);
    if (typeof oe == "number")
      return oe = oe & 255, typeof Uint8Array.prototype.indexOf == "function" ? Ke ? Uint8Array.prototype.indexOf.call(re, oe, le) : Uint8Array.prototype.lastIndexOf.call(re, oe, le) : ze(re, [oe], le, ge, Ke);
    throw new TypeError("val must be string, number or Buffer");
  }
  function ze(re, oe, le, ge, Ke) {
    var Je = 1, Fe = re.length, Ye = oe.length;
    if (ge !== void 0 && (ge = String(ge).toLowerCase(), ge === "ucs2" || ge === "ucs-2" || ge === "utf16le" || ge === "utf-16le")) {
      if (re.length < 2 || oe.length < 2)
        return -1;
      Je = 2, Fe /= 2, Ye /= 2, le /= 2;
    }
    function it(ot, si) {
      return Je === 1 ? ot[si] : ot.readUInt16BE(si * Je);
    }
    var rt;
    if (Ke) {
      var tt = -1;
      for (rt = le; rt < Fe; rt++)
        if (it(re, rt) === it(oe, tt === -1 ? 0 : rt - tt)) {
          if (tt === -1 && (tt = rt), rt - tt + 1 === Ye)
            return tt * Je;
        } else
          tt !== -1 && (rt -= rt - tt), tt = -1;
    } else
      for (le + Ye > Fe && (le = Fe - Ye), rt = le; rt >= 0; rt--) {
        for (var vt = !0, St = 0; St < Ye; St++)
          if (it(re, rt + St) !== it(oe, St)) {
            vt = !1;
            break;
          }
        if (vt)
          return rt;
      }
    return -1;
  }
  M.prototype.includes = function(re, oe, le) {
    return this.indexOf(re, oe, le) !== -1;
  }, M.prototype.indexOf = function(re, oe, le) {
    return Ue(this, re, oe, le, !0);
  }, M.prototype.lastIndexOf = function(re, oe, le) {
    return Ue(this, re, oe, le, !1);
  };
  function Le(re, oe, le, ge) {
    le = Number(le) || 0;
    var Ke = re.length - le;
    ge ? (ge = Number(ge), ge > Ke && (ge = Ke)) : ge = Ke;
    var Je = oe.length;
    ge > Je / 2 && (ge = Je / 2);
    for (var Fe = 0; Fe < ge; ++Fe) {
      var Ye = parseInt(oe.substr(Fe * 2, 2), 16);
      if (et(Ye))
        return Fe;
      re[le + Fe] = Ye;
    }
    return Fe;
  }
  function Ne(re, oe, le, ge) {
    return Oe(ke(oe, re.length - le), re, le, ge);
  }
  function $e(re, oe, le, ge) {
    return Oe(Qe(oe), re, le, ge);
  }
  function J(re, oe, le, ge) {
    return Oe(qe(oe), re, le, ge);
  }
  function ne(re, oe, le, ge) {
    return Oe(Ze(oe, re.length - le), re, le, ge);
  }
  M.prototype.write = function(re, oe, le, ge) {
    if (oe === void 0)
      ge = "utf8", le = this.length, oe = 0;
    else if (le === void 0 && typeof oe == "string")
      ge = oe, le = this.length, oe = 0;
    else if (isFinite(oe))
      oe = oe >>> 0, isFinite(le) ? (le = le >>> 0, ge === void 0 && (ge = "utf8")) : (ge = le, le = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    var Ke = this.length - oe;
    if ((le === void 0 || le > Ke) && (le = Ke), re.length > 0 && (le < 0 || oe < 0) || oe > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    ge || (ge = "utf8");
    for (var Je = !1; ; )
      switch (ge) {
        case "hex":
          return Le(this, re, oe, le);
        case "utf8":
        case "utf-8":
          return Ne(this, re, oe, le);
        case "ascii":
        case "latin1":
        case "binary":
          return $e(this, re, oe, le);
        case "base64":
          return J(this, re, oe, le);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ne(this, re, oe, le);
        default:
          if (Je)
            throw new TypeError("Unknown encoding: " + ge);
          ge = ("" + ge).toLowerCase(), Je = !0;
      }
  }, M.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function A(re, oe, le) {
    return oe === 0 && le === re.length ? t.fromByteArray(re) : t.fromByteArray(re.slice(oe, le));
  }
  function I(re, oe, le) {
    le = Math.min(re.length, le);
    for (var ge = [], Ke = oe; Ke < le; ) {
      var Je = re[Ke], Fe = null, Ye = Je > 239 ? 4 : Je > 223 ? 3 : Je > 191 ? 2 : 1;
      if (Ke + Ye <= le) {
        var it, rt, tt, vt;
        switch (Ye) {
          case 1:
            Je < 128 && (Fe = Je);
            break;
          case 2:
            it = re[Ke + 1], (it & 192) === 128 && (vt = (Je & 31) << 6 | it & 63, vt > 127 && (Fe = vt));
            break;
          case 3:
            it = re[Ke + 1], rt = re[Ke + 2], (it & 192) === 128 && (rt & 192) === 128 && (vt = (Je & 15) << 12 | (it & 63) << 6 | rt & 63, vt > 2047 && (vt < 55296 || vt > 57343) && (Fe = vt));
            break;
          case 4:
            it = re[Ke + 1], rt = re[Ke + 2], tt = re[Ke + 3], (it & 192) === 128 && (rt & 192) === 128 && (tt & 192) === 128 && (vt = (Je & 15) << 18 | (it & 63) << 12 | (rt & 63) << 6 | tt & 63, vt > 65535 && vt < 1114112 && (Fe = vt));
        }
      }
      Fe === null ? (Fe = 65533, Ye = 1) : Fe > 65535 && (Fe -= 65536, ge.push(Fe >>> 10 & 1023 | 55296), Fe = 56320 | Fe & 1023), ge.push(Fe), Ke += Ye;
    }
    return X(ge);
  }
  var U = 4096;
  function X(re) {
    var oe = re.length;
    if (oe <= U)
      return String.fromCharCode.apply(String, re);
    for (var le = "", ge = 0; ge < oe; )
      le += String.fromCharCode.apply(
        String,
        re.slice(ge, ge += U)
      );
    return le;
  }
  function Q(re, oe, le) {
    var ge = "";
    le = Math.min(re.length, le);
    for (var Ke = oe; Ke < le; ++Ke)
      ge += String.fromCharCode(re[Ke] & 127);
    return ge;
  }
  function F(re, oe, le) {
    var ge = "";
    le = Math.min(re.length, le);
    for (var Ke = oe; Ke < le; ++Ke)
      ge += String.fromCharCode(re[Ke]);
    return ge;
  }
  function $(re, oe, le) {
    var ge = re.length;
    (!oe || oe < 0) && (oe = 0), (!le || le < 0 || le > ge) && (le = ge);
    for (var Ke = "", Je = oe; Je < le; ++Je)
      Ke += nt[re[Je]];
    return Ke;
  }
  function H(re, oe, le) {
    for (var ge = re.slice(oe, le), Ke = "", Je = 0; Je < ge.length - 1; Je += 2)
      Ke += String.fromCharCode(ge[Je] + ge[Je + 1] * 256);
    return Ke;
  }
  M.prototype.slice = function(re, oe) {
    var le = this.length;
    re = ~~re, oe = oe === void 0 ? le : ~~oe, re < 0 ? (re += le, re < 0 && (re = 0)) : re > le && (re = le), oe < 0 ? (oe += le, oe < 0 && (oe = 0)) : oe > le && (oe = le), oe < re && (oe = re);
    var ge = this.subarray(re, oe);
    return Object.setPrototypeOf(ge, M.prototype), ge;
  };
  function q(re, oe, le) {
    if (re % 1 !== 0 || re < 0)
      throw new RangeError("offset is not uint");
    if (re + oe > le)
      throw new RangeError("Trying to access beyond buffer length");
  }
  M.prototype.readUintLE = M.prototype.readUIntLE = function(re, oe, le) {
    re = re >>> 0, oe = oe >>> 0, le || q(re, oe, this.length);
    for (var ge = this[re], Ke = 1, Je = 0; ++Je < oe && (Ke *= 256); )
      ge += this[re + Je] * Ke;
    return ge;
  }, M.prototype.readUintBE = M.prototype.readUIntBE = function(re, oe, le) {
    re = re >>> 0, oe = oe >>> 0, le || q(re, oe, this.length);
    for (var ge = this[re + --oe], Ke = 1; oe > 0 && (Ke *= 256); )
      ge += this[re + --oe] * Ke;
    return ge;
  }, M.prototype.readUint8 = M.prototype.readUInt8 = function(re, oe) {
    return re = re >>> 0, oe || q(re, 1, this.length), this[re];
  }, M.prototype.readUint16LE = M.prototype.readUInt16LE = function(re, oe) {
    return re = re >>> 0, oe || q(re, 2, this.length), this[re] | this[re + 1] << 8;
  }, M.prototype.readUint16BE = M.prototype.readUInt16BE = function(re, oe) {
    return re = re >>> 0, oe || q(re, 2, this.length), this[re] << 8 | this[re + 1];
  }, M.prototype.readUint32LE = M.prototype.readUInt32LE = function(re, oe) {
    return re = re >>> 0, oe || q(re, 4, this.length), (this[re] | this[re + 1] << 8 | this[re + 2] << 16) + this[re + 3] * 16777216;
  }, M.prototype.readUint32BE = M.prototype.readUInt32BE = function(re, oe) {
    return re = re >>> 0, oe || q(re, 4, this.length), this[re] * 16777216 + (this[re + 1] << 16 | this[re + 2] << 8 | this[re + 3]);
  }, M.prototype.readIntLE = function(re, oe, le) {
    re = re >>> 0, oe = oe >>> 0, le || q(re, oe, this.length);
    for (var ge = this[re], Ke = 1, Je = 0; ++Je < oe && (Ke *= 256); )
      ge += this[re + Je] * Ke;
    return Ke *= 128, ge >= Ke && (ge -= Math.pow(2, 8 * oe)), ge;
  }, M.prototype.readIntBE = function(re, oe, le) {
    re = re >>> 0, oe = oe >>> 0, le || q(re, oe, this.length);
    for (var ge = oe, Ke = 1, Je = this[re + --ge]; ge > 0 && (Ke *= 256); )
      Je += this[re + --ge] * Ke;
    return Ke *= 128, Je >= Ke && (Je -= Math.pow(2, 8 * oe)), Je;
  }, M.prototype.readInt8 = function(re, oe) {
    return re = re >>> 0, oe || q(re, 1, this.length), this[re] & 128 ? (255 - this[re] + 1) * -1 : this[re];
  }, M.prototype.readInt16LE = function(re, oe) {
    re = re >>> 0, oe || q(re, 2, this.length);
    var le = this[re] | this[re + 1] << 8;
    return le & 32768 ? le | 4294901760 : le;
  }, M.prototype.readInt16BE = function(re, oe) {
    re = re >>> 0, oe || q(re, 2, this.length);
    var le = this[re + 1] | this[re] << 8;
    return le & 32768 ? le | 4294901760 : le;
  }, M.prototype.readInt32LE = function(re, oe) {
    return re = re >>> 0, oe || q(re, 4, this.length), this[re] | this[re + 1] << 8 | this[re + 2] << 16 | this[re + 3] << 24;
  }, M.prototype.readInt32BE = function(re, oe) {
    return re = re >>> 0, oe || q(re, 4, this.length), this[re] << 24 | this[re + 1] << 16 | this[re + 2] << 8 | this[re + 3];
  }, M.prototype.readFloatLE = function(re, oe) {
    return re = re >>> 0, oe || q(re, 4, this.length), h.read(this, re, !0, 23, 4);
  }, M.prototype.readFloatBE = function(re, oe) {
    return re = re >>> 0, oe || q(re, 4, this.length), h.read(this, re, !1, 23, 4);
  }, M.prototype.readDoubleLE = function(re, oe) {
    return re = re >>> 0, oe || q(re, 8, this.length), h.read(this, re, !0, 52, 8);
  }, M.prototype.readDoubleBE = function(re, oe) {
    return re = re >>> 0, oe || q(re, 8, this.length), h.read(this, re, !1, 52, 8);
  };
  function z(re, oe, le, ge, Ke, Je) {
    if (!M.isBuffer(re))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (oe > Ke || oe < Je)
      throw new RangeError('"value" argument is out of bounds');
    if (le + ge > re.length)
      throw new RangeError("Index out of range");
  }
  M.prototype.writeUintLE = M.prototype.writeUIntLE = function(re, oe, le, ge) {
    if (re = +re, oe = oe >>> 0, le = le >>> 0, !ge) {
      var Ke = Math.pow(2, 8 * le) - 1;
      z(this, re, oe, le, Ke, 0);
    }
    var Je = 1, Fe = 0;
    for (this[oe] = re & 255; ++Fe < le && (Je *= 256); )
      this[oe + Fe] = re / Je & 255;
    return oe + le;
  }, M.prototype.writeUintBE = M.prototype.writeUIntBE = function(re, oe, le, ge) {
    if (re = +re, oe = oe >>> 0, le = le >>> 0, !ge) {
      var Ke = Math.pow(2, 8 * le) - 1;
      z(this, re, oe, le, Ke, 0);
    }
    var Je = le - 1, Fe = 1;
    for (this[oe + Je] = re & 255; --Je >= 0 && (Fe *= 256); )
      this[oe + Je] = re / Fe & 255;
    return oe + le;
  }, M.prototype.writeUint8 = M.prototype.writeUInt8 = function(re, oe, le) {
    return re = +re, oe = oe >>> 0, le || z(this, re, oe, 1, 255, 0), this[oe] = re & 255, oe + 1;
  }, M.prototype.writeUint16LE = M.prototype.writeUInt16LE = function(re, oe, le) {
    return re = +re, oe = oe >>> 0, le || z(this, re, oe, 2, 65535, 0), this[oe] = re & 255, this[oe + 1] = re >>> 8, oe + 2;
  }, M.prototype.writeUint16BE = M.prototype.writeUInt16BE = function(re, oe, le) {
    return re = +re, oe = oe >>> 0, le || z(this, re, oe, 2, 65535, 0), this[oe] = re >>> 8, this[oe + 1] = re & 255, oe + 2;
  }, M.prototype.writeUint32LE = M.prototype.writeUInt32LE = function(re, oe, le) {
    return re = +re, oe = oe >>> 0, le || z(this, re, oe, 4, 4294967295, 0), this[oe + 3] = re >>> 24, this[oe + 2] = re >>> 16, this[oe + 1] = re >>> 8, this[oe] = re & 255, oe + 4;
  }, M.prototype.writeUint32BE = M.prototype.writeUInt32BE = function(re, oe, le) {
    return re = +re, oe = oe >>> 0, le || z(this, re, oe, 4, 4294967295, 0), this[oe] = re >>> 24, this[oe + 1] = re >>> 16, this[oe + 2] = re >>> 8, this[oe + 3] = re & 255, oe + 4;
  }, M.prototype.writeIntLE = function(re, oe, le, ge) {
    if (re = +re, oe = oe >>> 0, !ge) {
      var Ke = Math.pow(2, 8 * le - 1);
      z(this, re, oe, le, Ke - 1, -Ke);
    }
    var Je = 0, Fe = 1, Ye = 0;
    for (this[oe] = re & 255; ++Je < le && (Fe *= 256); )
      re < 0 && Ye === 0 && this[oe + Je - 1] !== 0 && (Ye = 1), this[oe + Je] = (re / Fe >> 0) - Ye & 255;
    return oe + le;
  }, M.prototype.writeIntBE = function(re, oe, le, ge) {
    if (re = +re, oe = oe >>> 0, !ge) {
      var Ke = Math.pow(2, 8 * le - 1);
      z(this, re, oe, le, Ke - 1, -Ke);
    }
    var Je = le - 1, Fe = 1, Ye = 0;
    for (this[oe + Je] = re & 255; --Je >= 0 && (Fe *= 256); )
      re < 0 && Ye === 0 && this[oe + Je + 1] !== 0 && (Ye = 1), this[oe + Je] = (re / Fe >> 0) - Ye & 255;
    return oe + le;
  }, M.prototype.writeInt8 = function(re, oe, le) {
    return re = +re, oe = oe >>> 0, le || z(this, re, oe, 1, 127, -128), re < 0 && (re = 255 + re + 1), this[oe] = re & 255, oe + 1;
  }, M.prototype.writeInt16LE = function(re, oe, le) {
    return re = +re, oe = oe >>> 0, le || z(this, re, oe, 2, 32767, -32768), this[oe] = re & 255, this[oe + 1] = re >>> 8, oe + 2;
  }, M.prototype.writeInt16BE = function(re, oe, le) {
    return re = +re, oe = oe >>> 0, le || z(this, re, oe, 2, 32767, -32768), this[oe] = re >>> 8, this[oe + 1] = re & 255, oe + 2;
  }, M.prototype.writeInt32LE = function(re, oe, le) {
    return re = +re, oe = oe >>> 0, le || z(this, re, oe, 4, 2147483647, -2147483648), this[oe] = re & 255, this[oe + 1] = re >>> 8, this[oe + 2] = re >>> 16, this[oe + 3] = re >>> 24, oe + 4;
  }, M.prototype.writeInt32BE = function(re, oe, le) {
    return re = +re, oe = oe >>> 0, le || z(this, re, oe, 4, 2147483647, -2147483648), re < 0 && (re = 4294967295 + re + 1), this[oe] = re >>> 24, this[oe + 1] = re >>> 16, this[oe + 2] = re >>> 8, this[oe + 3] = re & 255, oe + 4;
  };
  function me(re, oe, le, ge, Ke, Je) {
    if (le + ge > re.length)
      throw new RangeError("Index out of range");
    if (le < 0)
      throw new RangeError("Index out of range");
  }
  function Ce(re, oe, le, ge, Ke) {
    return oe = +oe, le = le >>> 0, Ke || me(re, oe, le, 4), h.write(re, oe, le, ge, 23, 4), le + 4;
  }
  M.prototype.writeFloatLE = function(re, oe, le) {
    return Ce(this, re, oe, !0, le);
  }, M.prototype.writeFloatBE = function(re, oe, le) {
    return Ce(this, re, oe, !1, le);
  };
  function je(re, oe, le, ge, Ke) {
    return oe = +oe, le = le >>> 0, Ke || me(re, oe, le, 8), h.write(re, oe, le, ge, 52, 8), le + 8;
  }
  M.prototype.writeDoubleLE = function(re, oe, le) {
    return je(this, re, oe, !0, le);
  }, M.prototype.writeDoubleBE = function(re, oe, le) {
    return je(this, re, oe, !1, le);
  }, M.prototype.copy = function(re, oe, le, ge) {
    if (!M.isBuffer(re))
      throw new TypeError("argument should be a Buffer");
    if (le || (le = 0), !ge && ge !== 0 && (ge = this.length), oe >= re.length && (oe = re.length), oe || (oe = 0), ge > 0 && ge < le && (ge = le), ge === le || re.length === 0 || this.length === 0)
      return 0;
    if (oe < 0)
      throw new RangeError("targetStart out of bounds");
    if (le < 0 || le >= this.length)
      throw new RangeError("Index out of range");
    if (ge < 0)
      throw new RangeError("sourceEnd out of bounds");
    ge > this.length && (ge = this.length), re.length - oe < ge - le && (ge = re.length - oe + le);
    var Ke = ge - le;
    return this === re && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(oe, le, ge) : Uint8Array.prototype.set.call(
      re,
      this.subarray(le, ge),
      oe
    ), Ke;
  }, M.prototype.fill = function(re, oe, le, ge) {
    if (typeof re == "string") {
      if (typeof oe == "string" ? (ge = oe, oe = 0, le = this.length) : typeof le == "string" && (ge = le, le = this.length), ge !== void 0 && typeof ge != "string")
        throw new TypeError("encoding must be a string");
      if (typeof ge == "string" && !M.isEncoding(ge))
        throw new TypeError("Unknown encoding: " + ge);
      if (re.length === 1) {
        var Ke = re.charCodeAt(0);
        (ge === "utf8" && Ke < 128 || ge === "latin1") && (re = Ke);
      }
    } else
      typeof re == "number" ? re = re & 255 : typeof re == "boolean" && (re = Number(re));
    if (oe < 0 || this.length < oe || this.length < le)
      throw new RangeError("Out of range index");
    if (le <= oe)
      return this;
    oe = oe >>> 0, le = le === void 0 ? this.length : le >>> 0, re || (re = 0);
    var Je;
    if (typeof re == "number")
      for (Je = oe; Je < le; ++Je)
        this[Je] = re;
    else {
      var Fe = M.isBuffer(re) ? re : M.from(re, ge), Ye = Fe.length;
      if (Ye === 0)
        throw new TypeError('The value "' + re + '" is invalid for argument "value"');
      for (Je = 0; Je < le - oe; ++Je)
        this[Je + oe] = Fe[Je % Ye];
    }
    return this;
  };
  var Re = /[^+/0-9A-Za-z-_]/g;
  function Ae(re) {
    if (re = re.split("=")[0], re = re.trim().replace(Re, ""), re.length < 2)
      return "";
    for (; re.length % 4 !== 0; )
      re = re + "=";
    return re;
  }
  function ke(re, oe) {
    oe = oe || 1 / 0;
    for (var le, ge = re.length, Ke = null, Je = [], Fe = 0; Fe < ge; ++Fe) {
      if (le = re.charCodeAt(Fe), le > 55295 && le < 57344) {
        if (!Ke) {
          if (le > 56319) {
            (oe -= 3) > -1 && Je.push(239, 191, 189);
            continue;
          } else if (Fe + 1 === ge) {
            (oe -= 3) > -1 && Je.push(239, 191, 189);
            continue;
          }
          Ke = le;
          continue;
        }
        if (le < 56320) {
          (oe -= 3) > -1 && Je.push(239, 191, 189), Ke = le;
          continue;
        }
        le = (Ke - 55296 << 10 | le - 56320) + 65536;
      } else
        Ke && (oe -= 3) > -1 && Je.push(239, 191, 189);
      if (Ke = null, le < 128) {
        if ((oe -= 1) < 0)
          break;
        Je.push(le);
      } else if (le < 2048) {
        if ((oe -= 2) < 0)
          break;
        Je.push(
          le >> 6 | 192,
          le & 63 | 128
        );
      } else if (le < 65536) {
        if ((oe -= 3) < 0)
          break;
        Je.push(
          le >> 12 | 224,
          le >> 6 & 63 | 128,
          le & 63 | 128
        );
      } else if (le < 1114112) {
        if ((oe -= 4) < 0)
          break;
        Je.push(
          le >> 18 | 240,
          le >> 12 & 63 | 128,
          le >> 6 & 63 | 128,
          le & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return Je;
  }
  function Qe(re) {
    for (var oe = [], le = 0; le < re.length; ++le)
      oe.push(re.charCodeAt(le) & 255);
    return oe;
  }
  function Ze(re, oe) {
    for (var le, ge, Ke, Je = [], Fe = 0; Fe < re.length && !((oe -= 2) < 0); ++Fe)
      le = re.charCodeAt(Fe), ge = le >> 8, Ke = le % 256, Je.push(Ke), Je.push(ge);
    return Je;
  }
  function qe(re) {
    return t.toByteArray(Ae(re));
  }
  function Oe(re, oe, le, ge) {
    for (var Ke = 0; Ke < ge && !(Ke + le >= oe.length || Ke >= re.length); ++Ke)
      oe[Ke + le] = re[Ke];
    return Ke;
  }
  function Xe(re, oe) {
    return re instanceof oe || re != null && re.constructor != null && re.constructor.name != null && re.constructor.name === oe.name;
  }
  function et(re) {
    return re !== re;
  }
  var nt = function() {
    for (var re = "0123456789abcdef", oe = new Array(256), le = 0; le < 16; ++le)
      for (var ge = le * 16, Ke = 0; Ke < 16; ++Ke)
        oe[ge + Ke] = re[le] + re[Ke];
    return oe;
  }();
})(pe);
var a1 = { exports: {} }, $t = a1.exports = {}, Ri, Ni;
function Gu() {
  throw new Error("setTimeout has not been defined");
}
function zu() {
  throw new Error("clearTimeout has not been defined");
}
(function() {
  try {
    typeof setTimeout == "function" ? Ri = setTimeout : Ri = Gu;
  } catch {
    Ri = Gu;
  }
  try {
    typeof clearTimeout == "function" ? Ni = clearTimeout : Ni = zu;
  } catch {
    Ni = zu;
  }
})();
function s1(e) {
  if (Ri === setTimeout)
    return setTimeout(e, 0);
  if ((Ri === Gu || !Ri) && setTimeout)
    return Ri = setTimeout, setTimeout(e, 0);
  try {
    return Ri(e, 0);
  } catch {
    try {
      return Ri.call(null, e, 0);
    } catch {
      return Ri.call(this, e, 0);
    }
  }
}
function yg(e) {
  if (Ni === clearTimeout)
    return clearTimeout(e);
  if ((Ni === zu || !Ni) && clearTimeout)
    return Ni = clearTimeout, clearTimeout(e);
  try {
    return Ni(e);
  } catch {
    try {
      return Ni.call(null, e);
    } catch {
      return Ni.call(this, e);
    }
  }
}
var en = [], xa = !1, Hn, us = -1;
function gg() {
  !xa || !Hn || (xa = !1, Hn.length ? en = Hn.concat(en) : us = -1, en.length && f1());
}
function f1() {
  if (!xa) {
    var e = s1(gg);
    xa = !0;
    for (var t = en.length; t; ) {
      for (Hn = en, en = []; ++us < t; )
        Hn && Hn[us].run();
      us = -1, t = en.length;
    }
    Hn = null, xa = !1, yg(e);
  }
}
$t.nextTick = function(e) {
  var t = new Array(arguments.length - 1);
  if (arguments.length > 1)
    for (var h = 1; h < arguments.length; h++)
      t[h - 1] = arguments[h];
  en.push(new o1(e, t)), en.length === 1 && !xa && s1(f1);
};
function o1(e, t) {
  this.fun = e, this.array = t;
}
o1.prototype.run = function() {
  this.fun.apply(null, this.array);
};
$t.title = "browser";
$t.browser = !0;
$t.env = {};
$t.argv = [];
$t.version = "";
$t.versions = {};
function cn() {
}
$t.on = cn;
$t.addListener = cn;
$t.once = cn;
$t.off = cn;
$t.removeListener = cn;
$t.removeAllListeners = cn;
$t.emit = cn;
$t.prependListener = cn;
$t.prependOnceListener = cn;
$t.listeners = function(e) {
  return [];
};
$t.binding = function(e) {
  throw new Error("process.binding is not supported");
};
$t.cwd = function() {
  return "/";
};
$t.chdir = function(e) {
  throw new Error("process.chdir is not supported");
};
$t.umask = function() {
  return 0;
};
var mg = a1.exports;
const Ve = /* @__PURE__ */ Gs(mg);
(function(e) {
  function t() {
    var o = this || self;
    return delete e.prototype.__magic__, o;
  }
  if (typeof globalThis == "object")
    return globalThis;
  if (this)
    return t();
  e.defineProperty(e.prototype, "__magic__", {
    configurable: !0,
    get: t
  });
  var h = __magic__;
  return h;
})(Object);
var u1 = { exports: {} };
function bg(e) {
  throw new Error('Could not dynamically require "' + e + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var zf = { exports: {} }, st = {}, ju = { exports: {} }, Wu = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(e, t) {
  var h = pe, o = h.Buffer;
  function S(B, M) {
    for (var O in B)
      M[O] = B[O];
  }
  o.from && o.alloc && o.allocUnsafe && o.allocUnsafeSlow ? e.exports = h : (S(h, t), t.Buffer = g);
  function g(B, M, O) {
    return o(B, M, O);
  }
  g.prototype = Object.create(o.prototype), S(o, g), g.from = function(B, M, O) {
    if (typeof B == "number")
      throw new TypeError("Argument must not be a number");
    return o(B, M, O);
  }, g.alloc = function(B, M, O) {
    if (typeof B != "number")
      throw new TypeError("Argument must be a number");
    var P = o(B);
    return M !== void 0 ? typeof O == "string" ? P.fill(M, O) : P.fill(M) : P.fill(0), P;
  }, g.allocUnsafe = function(B) {
    if (typeof B != "number")
      throw new TypeError("Argument must be a number");
    return o(B);
  }, g.allocUnsafeSlow = function(B) {
    if (typeof B != "number")
      throw new TypeError("Argument must be a number");
    return h.SlowBuffer(B);
  };
})(Wu, Wu.exports);
var ct = Wu.exports, jf = 65536, xg = 4294967295;
function _g() {
  throw new Error(`Secure random number generation is not supported by this browser.
Use Chrome, Firefox or Internet Explorer 11`);
}
var Eg = ct.Buffer, ws = Me.crypto || Me.msCrypto;
ws && ws.getRandomValues ? ju.exports = Sg : ju.exports = _g;
function Sg(e, t) {
  if (e > xg)
    throw new RangeError("requested too many random bytes");
  var h = Eg.allocUnsafe(e);
  if (e > 0)
    if (e > jf)
      for (var o = 0; o < e; o += jf)
        ws.getRandomValues(h.slice(o, o + jf));
    else
      ws.getRandomValues(h);
  return typeof t == "function" ? Ve.nextTick(function() {
    t(null, h);
  }) : h;
}
var Ua = ju.exports, Yu = { exports: {} };
typeof Object.create == "function" ? Yu.exports = function(e, t) {
  t && (e.super_ = t, e.prototype = Object.create(t.prototype, {
    constructor: {
      value: e,
      enumerable: !1,
      writable: !0,
      configurable: !0
    }
  }));
} : Yu.exports = function(e, t) {
  if (t) {
    e.super_ = t;
    var h = function() {
    };
    h.prototype = t.prototype, e.prototype = new h(), e.prototype.constructor = e;
  }
};
var ut = Yu.exports, Xu = { exports: {} }, Pc = { exports: {} }, _a = typeof Reflect == "object" ? Reflect : null, Zh = _a && typeof _a.apply == "function" ? _a.apply : function(e, t, h) {
  return Function.prototype.apply.call(e, t, h);
}, cs;
_a && typeof _a.ownKeys == "function" ? cs = _a.ownKeys : Object.getOwnPropertySymbols ? cs = function(e) {
  return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
} : cs = function(e) {
  return Object.getOwnPropertyNames(e);
};
function wg(e) {
  console && console.warn && console.warn(e);
}
var c1 = Number.isNaN || function(e) {
  return e !== e;
};
function Mt() {
  Mt.init.call(this);
}
Pc.exports = Mt;
Pc.exports.once = Ig;
Mt.EventEmitter = Mt;
Mt.prototype._events = void 0;
Mt.prototype._eventsCount = 0;
Mt.prototype._maxListeners = void 0;
var Jh = 10;
function js(e) {
  if (typeof e != "function")
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof e);
}
Object.defineProperty(Mt, "defaultMaxListeners", {
  enumerable: !0,
  get: function() {
    return Jh;
  },
  set: function(e) {
    if (typeof e != "number" || e < 0 || c1(e))
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + e + ".");
    Jh = e;
  }
});
Mt.init = function() {
  (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
};
Mt.prototype.setMaxListeners = function(e) {
  if (typeof e != "number" || e < 0 || c1(e))
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
  return this._maxListeners = e, this;
};
function h1(e) {
  return e._maxListeners === void 0 ? Mt.defaultMaxListeners : e._maxListeners;
}
Mt.prototype.getMaxListeners = function() {
  return h1(this);
};
Mt.prototype.emit = function(e) {
  for (var t = [], h = 1; h < arguments.length; h++)
    t.push(arguments[h]);
  var o = e === "error", S = this._events;
  if (S !== void 0)
    o = o && S.error === void 0;
  else if (!o)
    return !1;
  if (o) {
    var g;
    if (t.length > 0 && (g = t[0]), g instanceof Error)
      throw g;
    var B = new Error("Unhandled error." + (g ? " (" + g.message + ")" : ""));
    throw B.context = g, B;
  }
  var M = S[e];
  if (M === void 0)
    return !1;
  if (typeof M == "function")
    Zh(M, this, t);
  else
    for (var O = M.length, P = y1(M, O), h = 0; h < O; ++h)
      Zh(P[h], this, t);
  return !0;
};
function l1(e, t, h, o) {
  var S, g, B;
  if (js(h), g = e._events, g === void 0 ? (g = e._events = /* @__PURE__ */ Object.create(null), e._eventsCount = 0) : (g.newListener !== void 0 && (e.emit(
    "newListener",
    t,
    h.listener ? h.listener : h
  ), g = e._events), B = g[t]), B === void 0)
    B = g[t] = h, ++e._eventsCount;
  else if (typeof B == "function" ? B = g[t] = o ? [h, B] : [B, h] : o ? B.unshift(h) : B.push(h), S = h1(e), S > 0 && B.length > S && !B.warned) {
    B.warned = !0;
    var M = new Error("Possible EventEmitter memory leak detected. " + B.length + " " + String(t) + " listeners added. Use emitter.setMaxListeners() to increase limit");
    M.name = "MaxListenersExceededWarning", M.emitter = e, M.type = t, M.count = B.length, wg(M);
  }
  return e;
}
Mt.prototype.addListener = function(e, t) {
  return l1(this, e, t, !1);
};
Mt.prototype.on = Mt.prototype.addListener;
Mt.prototype.prependListener = function(e, t) {
  return l1(this, e, t, !0);
};
function Cg() {
  if (!this.fired)
    return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
}
function d1(e, t, h) {
  var o = { fired: !1, wrapFn: void 0, target: e, type: t, listener: h }, S = Cg.bind(o);
  return S.listener = h, o.wrapFn = S, S;
}
Mt.prototype.once = function(e, t) {
  return js(t), this.on(e, d1(this, e, t)), this;
};
Mt.prototype.prependOnceListener = function(e, t) {
  return js(t), this.prependListener(e, d1(this, e, t)), this;
};
Mt.prototype.removeListener = function(e, t) {
  var h, o, S, g, B;
  if (js(t), o = this._events, o === void 0)
    return this;
  if (h = o[e], h === void 0)
    return this;
  if (h === t || h.listener === t)
    --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete o[e], o.removeListener && this.emit("removeListener", e, h.listener || t));
  else if (typeof h != "function") {
    for (S = -1, g = h.length - 1; g >= 0; g--)
      if (h[g] === t || h[g].listener === t) {
        B = h[g].listener, S = g;
        break;
      }
    if (S < 0)
      return this;
    S === 0 ? h.shift() : Ag(h, S), h.length === 1 && (o[e] = h[0]), o.removeListener !== void 0 && this.emit("removeListener", e, B || t);
  }
  return this;
};
Mt.prototype.off = Mt.prototype.removeListener;
Mt.prototype.removeAllListeners = function(e) {
  var t, h, o;
  if (h = this._events, h === void 0)
    return this;
  if (h.removeListener === void 0)
    return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : h[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete h[e]), this;
  if (arguments.length === 0) {
    var S = Object.keys(h), g;
    for (o = 0; o < S.length; ++o)
      g = S[o], g !== "removeListener" && this.removeAllListeners(g);
    return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
  }
  if (t = h[e], typeof t == "function")
    this.removeListener(e, t);
  else if (t !== void 0)
    for (o = t.length - 1; o >= 0; o--)
      this.removeListener(e, t[o]);
  return this;
};
function p1(e, t, h) {
  var o = e._events;
  if (o === void 0)
    return [];
  var S = o[t];
  return S === void 0 ? [] : typeof S == "function" ? h ? [S.listener || S] : [S] : h ? Bg(S) : y1(S, S.length);
}
Mt.prototype.listeners = function(e) {
  return p1(this, e, !0);
};
Mt.prototype.rawListeners = function(e) {
  return p1(this, e, !1);
};
Mt.listenerCount = function(e, t) {
  return typeof e.listenerCount == "function" ? e.listenerCount(t) : v1.call(e, t);
};
Mt.prototype.listenerCount = v1;
function v1(e) {
  var t = this._events;
  if (t !== void 0) {
    var h = t[e];
    if (typeof h == "function")
      return 1;
    if (h !== void 0)
      return h.length;
  }
  return 0;
}
Mt.prototype.eventNames = function() {
  return this._eventsCount > 0 ? cs(this._events) : [];
};
function y1(e, t) {
  for (var h = new Array(t), o = 0; o < t; ++o)
    h[o] = e[o];
  return h;
}
function Ag(e, t) {
  for (; t + 1 < e.length; t++)
    e[t] = e[t + 1];
  e.pop();
}
function Bg(e) {
  for (var t = new Array(e.length), h = 0; h < t.length; ++h)
    t[h] = e[h].listener || e[h];
  return t;
}
function Ig(e, t) {
  return new Promise(function(h, o) {
    function S(B) {
      e.removeListener(t, g), o(B);
    }
    function g() {
      typeof e.removeListener == "function" && e.removeListener("error", S), h([].slice.call(arguments));
    }
    g1(e, t, g, { once: !0 }), t !== "error" && Tg(e, S, { once: !0 });
  });
}
function Tg(e, t, h) {
  typeof e.on == "function" && g1(e, "error", t, h);
}
function g1(e, t, h, o) {
  if (typeof e.on == "function")
    o.once ? e.once(t, h) : e.on(t, h);
  else if (typeof e.addEventListener == "function")
    e.addEventListener(t, function S(g) {
      o.once && e.removeEventListener(t, S), h(g);
    });
  else
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof e);
}
var Lc = Pc.exports, m1 = Lc.EventEmitter, wn = {}, b1 = {}, x1 = function() {
  if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
    return !1;
  if (typeof Symbol.iterator == "symbol")
    return !0;
  var e = {}, t = Symbol("test"), h = Object(t);
  if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(h) !== "[object Symbol]")
    return !1;
  var o = 42;
  e[t] = o;
  for (t in e)
    return !1;
  if (typeof Object.keys == "function" && Object.keys(e).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(e).length !== 0)
    return !1;
  var S = Object.getOwnPropertySymbols(e);
  if (S.length !== 1 || S[0] !== t || !Object.prototype.propertyIsEnumerable.call(e, t))
    return !1;
  if (typeof Object.getOwnPropertyDescriptor == "function") {
    var g = Object.getOwnPropertyDescriptor(e, t);
    if (g.value !== o || g.enumerable !== !0)
      return !1;
  }
  return !0;
}, Mg = x1, kc = function() {
  return Mg() && !!Symbol.toStringTag;
}, Wf, el;
function Rg() {
  if (el)
    return Wf;
  el = 1;
  var e = typeof Symbol < "u" && Symbol, t = x1;
  return Wf = function() {
    return typeof e != "function" || typeof Symbol != "function" || typeof e("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t();
  }, Wf;
}
var Yf, tl;
function Ng() {
  if (tl)
    return Yf;
  tl = 1;
  var e = {
    foo: {}
  }, t = Object;
  return Yf = function() {
    return { __proto__: e }.foo === e.foo && !({ __proto__: null } instanceof t);
  }, Yf;
}
var Xf, rl;
function Dg() {
  if (rl)
    return Xf;
  rl = 1;
  var e = "Function.prototype.bind called on incompatible ", t = Array.prototype.slice, h = Object.prototype.toString, o = "[object Function]";
  return Xf = function(S) {
    var g = this;
    if (typeof g != "function" || h.call(g) !== o)
      throw new TypeError(e + g);
    for (var B = t.call(arguments, 1), M, O = function() {
      if (this instanceof M) {
        var ee = g.apply(
          this,
          B.concat(t.call(arguments))
        );
        return Object(ee) === ee ? ee : this;
      } else
        return g.apply(
          S,
          B.concat(t.call(arguments))
        );
    }, P = Math.max(0, g.length - B.length), D = [], Z = 0; Z < P; Z++)
      D.push("$" + Z);
    if (M = Function("binder", "return function (" + D.join(",") + "){ return binder.apply(this,arguments); }")(O), g.prototype) {
      var Y = function() {
      };
      Y.prototype = g.prototype, M.prototype = new Y(), Y.prototype = null;
    }
    return M;
  }, Xf;
}
var Qf, il;
function Uc() {
  if (il)
    return Qf;
  il = 1;
  var e = Dg();
  return Qf = Function.prototype.bind || e, Qf;
}
var Zf, nl;
function Og() {
  if (nl)
    return Zf;
  nl = 1;
  var e = Uc();
  return Zf = e.call(Function.call, Object.prototype.hasOwnProperty), Zf;
}
var Jf, al;
function Ws() {
  if (al)
    return Jf;
  al = 1;
  var e, t = SyntaxError, h = Function, o = TypeError, S = function(ne) {
    try {
      return h('"use strict"; return (' + ne + ").constructor;")();
    } catch {
    }
  }, g = Object.getOwnPropertyDescriptor;
  if (g)
    try {
      g({}, "");
    } catch {
      g = null;
    }
  var B = function() {
    throw new o();
  }, M = g ? function() {
    try {
      return arguments.callee, B;
    } catch {
      try {
        return g(arguments, "callee").get;
      } catch {
        return B;
      }
    }
  }() : B, O = Rg()(), P = Ng()(), D = Object.getPrototypeOf || (P ? function(ne) {
    return ne.__proto__;
  } : null), Z = {}, Y = typeof Uint8Array > "u" || !D ? e : D(Uint8Array), ee = {
    "%AggregateError%": typeof AggregateError > "u" ? e : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? e : ArrayBuffer,
    "%ArrayIteratorPrototype%": O && D ? D([][Symbol.iterator]()) : e,
    "%AsyncFromSyncIteratorPrototype%": e,
    "%AsyncFunction%": Z,
    "%AsyncGenerator%": Z,
    "%AsyncGeneratorFunction%": Z,
    "%AsyncIteratorPrototype%": Z,
    "%Atomics%": typeof Atomics > "u" ? e : Atomics,
    "%BigInt%": typeof BigInt > "u" ? e : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? e : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? e : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? e : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array > "u" ? e : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? e : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? e : FinalizationRegistry,
    "%Function%": h,
    "%GeneratorFunction%": Z,
    "%Int8Array%": typeof Int8Array > "u" ? e : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? e : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? e : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": O && D ? D(D([][Symbol.iterator]())) : e,
    "%JSON%": typeof JSON == "object" ? JSON : e,
    "%Map%": typeof Map > "u" ? e : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !O || !D ? e : D((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? e : Promise,
    "%Proxy%": typeof Proxy > "u" ? e : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect > "u" ? e : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? e : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !O || !D ? e : D((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? e : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": O && D ? D(""[Symbol.iterator]()) : e,
    "%Symbol%": O ? Symbol : e,
    "%SyntaxError%": t,
    "%ThrowTypeError%": M,
    "%TypedArray%": Y,
    "%TypeError%": o,
    "%Uint8Array%": typeof Uint8Array > "u" ? e : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? e : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? e : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? e : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap > "u" ? e : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? e : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? e : WeakSet
  };
  if (D)
    try {
      null.error;
    } catch (ne) {
      var ie = D(D(ne));
      ee["%Error.prototype%"] = ie;
    }
  var ue = function ne(A) {
    var I;
    if (A === "%AsyncFunction%")
      I = S("async function () {}");
    else if (A === "%GeneratorFunction%")
      I = S("function* () {}");
    else if (A === "%AsyncGeneratorFunction%")
      I = S("async function* () {}");
    else if (A === "%AsyncGenerator%") {
      var U = ne("%AsyncGeneratorFunction%");
      U && (I = U.prototype);
    } else if (A === "%AsyncIteratorPrototype%") {
      var X = ne("%AsyncGenerator%");
      X && D && (I = D(X.prototype));
    }
    return ee[A] = I, I;
  }, fe = {
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  }, de = Uc(), ce = Og(), be = de.call(Function.call, Array.prototype.concat), ve = de.call(Function.apply, Array.prototype.splice), Pe = de.call(Function.call, String.prototype.replace), Ue = de.call(Function.call, String.prototype.slice), ze = de.call(Function.call, RegExp.prototype.exec), Le = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, Ne = /\\(\\)?/g, $e = function(ne) {
    var A = Ue(ne, 0, 1), I = Ue(ne, -1);
    if (A === "%" && I !== "%")
      throw new t("invalid intrinsic syntax, expected closing `%`");
    if (I === "%" && A !== "%")
      throw new t("invalid intrinsic syntax, expected opening `%`");
    var U = [];
    return Pe(ne, Le, function(X, Q, F, $) {
      U[U.length] = F ? Pe($, Ne, "$1") : Q || X;
    }), U;
  }, J = function(ne, A) {
    var I = ne, U;
    if (ce(fe, I) && (U = fe[I], I = "%" + U[0] + "%"), ce(ee, I)) {
      var X = ee[I];
      if (X === Z && (X = ue(I)), typeof X > "u" && !A)
        throw new o("intrinsic " + ne + " exists, but is not available. Please file an issue!");
      return {
        alias: U,
        name: I,
        value: X
      };
    }
    throw new t("intrinsic " + ne + " does not exist!");
  };
  return Jf = function(ne, A) {
    if (typeof ne != "string" || ne.length === 0)
      throw new o("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof A != "boolean")
      throw new o('"allowMissing" argument must be a boolean');
    if (ze(/^%?[^%]*%?$/, ne) === null)
      throw new t("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var I = $e(ne), U = I.length > 0 ? I[0] : "", X = J("%" + U + "%", A), Q = X.name, F = X.value, $ = !1, H = X.alias;
    H && (U = H[0], ve(I, be([0, 1], H)));
    for (var q = 1, z = !0; q < I.length; q += 1) {
      var me = I[q], Ce = Ue(me, 0, 1), je = Ue(me, -1);
      if ((Ce === '"' || Ce === "'" || Ce === "`" || je === '"' || je === "'" || je === "`") && Ce !== je)
        throw new t("property names with quotes must have matching quotes");
      if ((me === "constructor" || !z) && ($ = !0), U += "." + me, Q = "%" + U + "%", ce(ee, Q))
        F = ee[Q];
      else if (F != null) {
        if (!(me in F)) {
          if (!A)
            throw new o("base intrinsic for " + ne + " exists, but the property is not available.");
          return;
        }
        if (g && q + 1 >= I.length) {
          var Re = g(F, me);
          z = !!Re, z && "get" in Re && !("originalValue" in Re.get) ? F = Re.get : F = F[me];
        } else
          z = ce(F, me), F = F[me];
        z && !$ && (ee[Q] = F);
      }
    }
    return F;
  }, Jf;
}
var eo = { exports: {} }, sl;
function Ys() {
  return sl || (sl = 1, function(e) {
    var t = Uc(), h = Ws(), o = h("%Function.prototype.apply%"), S = h("%Function.prototype.call%"), g = h("%Reflect.apply%", !0) || t.call(S, o), B = h("%Object.getOwnPropertyDescriptor%", !0), M = h("%Object.defineProperty%", !0), O = h("%Math.max%");
    if (M)
      try {
        M({}, "a", { value: 1 });
      } catch {
        M = null;
      }
    e.exports = function(D) {
      var Z = g(t, S, arguments);
      if (B && M) {
        var Y = B(Z, "length");
        Y.configurable && M(
          Z,
          "length",
          { value: 1 + O(0, D.length - (arguments.length - 1)) }
        );
      }
      return Z;
    };
    var P = function() {
      return g(t, o, arguments);
    };
    M ? M(e.exports, "apply", { value: P }) : e.exports.apply = P;
  }(eo)), eo.exports;
}
var _1 = Ws(), E1 = Ys(), Pg = E1(_1("String.prototype.indexOf")), S1 = function(e, t) {
  var h = _1(e, !!t);
  return typeof h == "function" && Pg(e, ".prototype.") > -1 ? E1(h) : h;
}, Lg = kc(), kg = S1, Qu = kg("Object.prototype.toString"), Xs = function(e) {
  return Lg && e && typeof e == "object" && Symbol.toStringTag in e ? !1 : Qu(e) === "[object Arguments]";
}, w1 = function(e) {
  return Xs(e) ? !0 : e !== null && typeof e == "object" && typeof e.length == "number" && e.length >= 0 && Qu(e) !== "[object Array]" && Qu(e.callee) === "[object Function]";
}, Ug = function() {
  return Xs(arguments);
}();
Xs.isLegacyArguments = w1;
var Fg = Ug ? Xs : w1, qg = Object.prototype.toString, Vg = Function.prototype.toString, Kg = /^\s*(?:function)?\*/, C1 = kc(), to = Object.getPrototypeOf, $g = function() {
  if (!C1)
    return !1;
  try {
    return Function("return function*() {}")();
  } catch {
  }
}, ro, Hg = function(e) {
  if (typeof e != "function")
    return !1;
  if (Kg.test(Vg.call(e)))
    return !0;
  if (!C1) {
    var t = qg.call(e);
    return t === "[object GeneratorFunction]";
  }
  if (!to)
    return !1;
  if (typeof ro > "u") {
    var h = $g();
    ro = h ? to(h) : !1;
  }
  return to(e) === ro;
}, A1 = Function.prototype.toString, va = typeof Reflect == "object" && Reflect !== null && Reflect.apply, Zu, hs;
if (typeof va == "function" && typeof Object.defineProperty == "function")
  try {
    Zu = Object.defineProperty({}, "length", {
      get: function() {
        throw hs;
      }
    }), hs = {}, va(function() {
      throw 42;
    }, null, Zu);
  } catch (e) {
    e !== hs && (va = null);
  }
else
  va = null;
var Gg = /^\s*class\b/, Ju = function(e) {
  try {
    var t = A1.call(e);
    return Gg.test(t);
  } catch {
    return !1;
  }
}, io = function(e) {
  try {
    return Ju(e) ? !1 : (A1.call(e), !0);
  } catch {
    return !1;
  }
}, ls = Object.prototype.toString, zg = "[object Object]", jg = "[object Function]", Wg = "[object GeneratorFunction]", Yg = "[object HTMLAllCollection]", Xg = "[object HTML document.all class]", Qg = "[object HTMLCollection]", Zg = typeof Symbol == "function" && !!Symbol.toStringTag, Jg = !(0 in [,]), ec = function() {
  return !1;
};
if (typeof document == "object") {
  var em = document.all;
  ls.call(em) === ls.call(document.all) && (ec = function(e) {
    if ((Jg || !e) && (typeof e > "u" || typeof e == "object"))
      try {
        var t = ls.call(e);
        return (t === Yg || t === Xg || t === Qg || t === zg) && e("") == null;
      } catch {
      }
    return !1;
  });
}
var tm = va ? function(e) {
  if (ec(e))
    return !0;
  if (!e || typeof e != "function" && typeof e != "object")
    return !1;
  try {
    va(e, null, Zu);
  } catch (t) {
    if (t !== hs)
      return !1;
  }
  return !Ju(e) && io(e);
} : function(e) {
  if (ec(e))
    return !0;
  if (!e || typeof e != "function" && typeof e != "object")
    return !1;
  if (Zg)
    return io(e);
  if (Ju(e))
    return !1;
  var t = ls.call(e);
  return t !== jg && t !== Wg && !/^\[object HTML/.test(t) ? !1 : io(e);
}, rm = tm, im = Object.prototype.toString, B1 = Object.prototype.hasOwnProperty, nm = function(e, t, h) {
  for (var o = 0, S = e.length; o < S; o++)
    B1.call(e, o) && (h == null ? t(e[o], o, e) : t.call(h, e[o], o, e));
}, am = function(e, t, h) {
  for (var o = 0, S = e.length; o < S; o++)
    h == null ? t(e.charAt(o), o, e) : t.call(h, e.charAt(o), o, e);
}, sm = function(e, t, h) {
  for (var o in e)
    B1.call(e, o) && (h == null ? t(e[o], o, e) : t.call(h, e[o], o, e));
}, fm = function(e, t, h) {
  if (!rm(t))
    throw new TypeError("iterator must be a function");
  var o;
  arguments.length >= 3 && (o = h), im.call(e) === "[object Array]" ? nm(e, t, o) : typeof e == "string" ? am(e, t, o) : sm(e, t, o);
}, om = fm, no = [
  "BigInt64Array",
  "BigUint64Array",
  "Float32Array",
  "Float64Array",
  "Int16Array",
  "Int32Array",
  "Int8Array",
  "Uint16Array",
  "Uint32Array",
  "Uint8Array",
  "Uint8ClampedArray"
], um = typeof globalThis > "u" ? Me : globalThis, cm = function() {
  for (var e = [], t = 0; t < no.length; t++)
    typeof um[no[t]] == "function" && (e[e.length] = no[t]);
  return e;
}, hm = Ws(), ds = hm("%Object.getOwnPropertyDescriptor%", !0);
if (ds)
  try {
    ds([], "length");
  } catch {
    ds = null;
  }
var lm = ds, Cs = om, dm = cm, fl = Ys(), Fc = S1, ps = lm, pm = Fc("Object.prototype.toString"), I1 = kc(), ol = typeof globalThis > "u" ? Me : globalThis, tc = dm(), qc = Fc("String.prototype.slice"), ao = Object.getPrototypeOf, vm = Fc("Array.prototype.indexOf", !0) || function(e, t) {
  for (var h = 0; h < e.length; h += 1)
    if (e[h] === t)
      return h;
  return -1;
}, As = { __proto__: null };
I1 && ps && ao ? Cs(tc, function(e) {
  var t = new ol[e]();
  if (Symbol.toStringTag in t) {
    var h = ao(t), o = ps(h, Symbol.toStringTag);
    if (!o) {
      var S = ao(h);
      o = ps(S, Symbol.toStringTag);
    }
    As["$" + e] = fl(o.get);
  }
}) : Cs(tc, function(e) {
  var t = new ol[e]();
  As["$" + e] = fl(t.slice);
});
var ym = function(e) {
  var t = !1;
  return Cs(As, function(h, o) {
    if (!t)
      try {
        "$" + h(e) === o && (t = qc(o, 1));
      } catch {
      }
  }), t;
}, gm = function(e) {
  var t = !1;
  return Cs(As, function(h, o) {
    if (!t)
      try {
        h(e), t = qc(o, 1);
      } catch {
      }
  }), t;
}, T1 = function(e) {
  if (!e || typeof e != "object")
    return !1;
  if (!I1) {
    var t = qc(pm(e), 8, -1);
    return vm(tc, t) > -1 ? t : t !== "Object" ? !1 : gm(e);
  }
  return ps ? ym(e) : null;
}, mm = T1, bm = function(e) {
  return !!mm(e);
};
(function(e) {
  var t = Fg, h = Hg, o = T1, S = bm;
  function g(ge) {
    return ge.call.bind(ge);
  }
  var B = typeof BigInt < "u", M = typeof Symbol < "u", O = g(Object.prototype.toString), P = g(Number.prototype.valueOf), D = g(String.prototype.valueOf), Z = g(Boolean.prototype.valueOf);
  if (B)
    var Y = g(BigInt.prototype.valueOf);
  if (M)
    var ee = g(Symbol.prototype.valueOf);
  function ie(ge, Ke) {
    if (typeof ge != "object")
      return !1;
    try {
      return Ke(ge), !0;
    } catch {
      return !1;
    }
  }
  e.isArgumentsObject = t, e.isGeneratorFunction = h, e.isTypedArray = S;
  function ue(ge) {
    return typeof Promise < "u" && ge instanceof Promise || ge !== null && typeof ge == "object" && typeof ge.then == "function" && typeof ge.catch == "function";
  }
  e.isPromise = ue;
  function fe(ge) {
    return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(ge) : S(ge) || me(ge);
  }
  e.isArrayBufferView = fe;
  function de(ge) {
    return o(ge) === "Uint8Array";
  }
  e.isUint8Array = de;
  function ce(ge) {
    return o(ge) === "Uint8ClampedArray";
  }
  e.isUint8ClampedArray = ce;
  function be(ge) {
    return o(ge) === "Uint16Array";
  }
  e.isUint16Array = be;
  function ve(ge) {
    return o(ge) === "Uint32Array";
  }
  e.isUint32Array = ve;
  function Pe(ge) {
    return o(ge) === "Int8Array";
  }
  e.isInt8Array = Pe;
  function Ue(ge) {
    return o(ge) === "Int16Array";
  }
  e.isInt16Array = Ue;
  function ze(ge) {
    return o(ge) === "Int32Array";
  }
  e.isInt32Array = ze;
  function Le(ge) {
    return o(ge) === "Float32Array";
  }
  e.isFloat32Array = Le;
  function Ne(ge) {
    return o(ge) === "Float64Array";
  }
  e.isFloat64Array = Ne;
  function $e(ge) {
    return o(ge) === "BigInt64Array";
  }
  e.isBigInt64Array = $e;
  function J(ge) {
    return o(ge) === "BigUint64Array";
  }
  e.isBigUint64Array = J;
  function ne(ge) {
    return O(ge) === "[object Map]";
  }
  ne.working = typeof Map < "u" && ne(/* @__PURE__ */ new Map());
  function A(ge) {
    return typeof Map > "u" ? !1 : ne.working ? ne(ge) : ge instanceof Map;
  }
  e.isMap = A;
  function I(ge) {
    return O(ge) === "[object Set]";
  }
  I.working = typeof Set < "u" && I(/* @__PURE__ */ new Set());
  function U(ge) {
    return typeof Set > "u" ? !1 : I.working ? I(ge) : ge instanceof Set;
  }
  e.isSet = U;
  function X(ge) {
    return O(ge) === "[object WeakMap]";
  }
  X.working = typeof WeakMap < "u" && X(/* @__PURE__ */ new WeakMap());
  function Q(ge) {
    return typeof WeakMap > "u" ? !1 : X.working ? X(ge) : ge instanceof WeakMap;
  }
  e.isWeakMap = Q;
  function F(ge) {
    return O(ge) === "[object WeakSet]";
  }
  F.working = typeof WeakSet < "u" && F(/* @__PURE__ */ new WeakSet());
  function $(ge) {
    return F(ge);
  }
  e.isWeakSet = $;
  function H(ge) {
    return O(ge) === "[object ArrayBuffer]";
  }
  H.working = typeof ArrayBuffer < "u" && H(new ArrayBuffer());
  function q(ge) {
    return typeof ArrayBuffer > "u" ? !1 : H.working ? H(ge) : ge instanceof ArrayBuffer;
  }
  e.isArrayBuffer = q;
  function z(ge) {
    return O(ge) === "[object DataView]";
  }
  z.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && z(new DataView(new ArrayBuffer(1), 0, 1));
  function me(ge) {
    return typeof DataView > "u" ? !1 : z.working ? z(ge) : ge instanceof DataView;
  }
  e.isDataView = me;
  var Ce = typeof SharedArrayBuffer < "u" ? SharedArrayBuffer : void 0;
  function je(ge) {
    return O(ge) === "[object SharedArrayBuffer]";
  }
  function Re(ge) {
    return typeof Ce > "u" ? !1 : (typeof je.working > "u" && (je.working = je(new Ce())), je.working ? je(ge) : ge instanceof Ce);
  }
  e.isSharedArrayBuffer = Re;
  function Ae(ge) {
    return O(ge) === "[object AsyncFunction]";
  }
  e.isAsyncFunction = Ae;
  function ke(ge) {
    return O(ge) === "[object Map Iterator]";
  }
  e.isMapIterator = ke;
  function Qe(ge) {
    return O(ge) === "[object Set Iterator]";
  }
  e.isSetIterator = Qe;
  function Ze(ge) {
    return O(ge) === "[object Generator]";
  }
  e.isGeneratorObject = Ze;
  function qe(ge) {
    return O(ge) === "[object WebAssembly.Module]";
  }
  e.isWebAssemblyCompiledModule = qe;
  function Oe(ge) {
    return ie(ge, P);
  }
  e.isNumberObject = Oe;
  function Xe(ge) {
    return ie(ge, D);
  }
  e.isStringObject = Xe;
  function et(ge) {
    return ie(ge, Z);
  }
  e.isBooleanObject = et;
  function nt(ge) {
    return B && ie(ge, Y);
  }
  e.isBigIntObject = nt;
  function re(ge) {
    return M && ie(ge, ee);
  }
  e.isSymbolObject = re;
  function oe(ge) {
    return Oe(ge) || Xe(ge) || et(ge) || nt(ge) || re(ge);
  }
  e.isBoxedPrimitive = oe;
  function le(ge) {
    return typeof Uint8Array < "u" && (q(ge) || Re(ge));
  }
  e.isAnyArrayBuffer = le, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(ge) {
    Object.defineProperty(e, ge, {
      enumerable: !1,
      value: function() {
        throw new Error(ge + " is not supported in userland");
      }
    });
  });
})(b1);
var xm = function(e) {
  return e && typeof e == "object" && typeof e.copy == "function" && typeof e.fill == "function" && typeof e.readUInt8 == "function";
};
(function(e) {
  var t = Object.getOwnPropertyDescriptors || function(z) {
    for (var me = Object.keys(z), Ce = {}, je = 0; je < me.length; je++)
      Ce[me[je]] = Object.getOwnPropertyDescriptor(z, me[je]);
    return Ce;
  }, h = /%[sdj%]/g;
  e.format = function(z) {
    if (!Pe(z)) {
      for (var me = [], Ce = 0; Ce < arguments.length; Ce++)
        me.push(B(arguments[Ce]));
      return me.join(" ");
    }
    for (var Ce = 1, je = arguments, Re = je.length, Ae = String(z).replace(h, function(Ze) {
      if (Ze === "%%")
        return "%";
      if (Ce >= Re)
        return Ze;
      switch (Ze) {
        case "%s":
          return String(je[Ce++]);
        case "%d":
          return Number(je[Ce++]);
        case "%j":
          try {
            return JSON.stringify(je[Ce++]);
          } catch {
            return "[Circular]";
          }
        default:
          return Ze;
      }
    }), ke = je[Ce]; Ce < Re; ke = je[++Ce])
      ce(ke) || !Ne(ke) ? Ae += " " + ke : Ae += " " + B(ke);
    return Ae;
  }, e.deprecate = function(z, me) {
    if (typeof Ve < "u" && Ve.noDeprecation === !0)
      return z;
    if (typeof Ve > "u")
      return function() {
        return e.deprecate(z, me).apply(this, arguments);
      };
    var Ce = !1;
    function je() {
      if (!Ce) {
        if (Ve.throwDeprecation)
          throw new Error(me);
        Ve.traceDeprecation ? console.trace(me) : console.error(me), Ce = !0;
      }
      return z.apply(this, arguments);
    }
    return je;
  };
  var o = {}, S = /^$/;
  if (Ve.env.NODE_DEBUG) {
    var g = Ve.env.NODE_DEBUG;
    g = g.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), S = new RegExp("^" + g + "$", "i");
  }
  e.debuglog = function(z) {
    if (z = z.toUpperCase(), !o[z])
      if (S.test(z)) {
        var me = Ve.pid;
        o[z] = function() {
          var Ce = e.format.apply(e, arguments);
          console.error("%s %d: %s", z, me, Ce);
        };
      } else
        o[z] = function() {
        };
    return o[z];
  };
  function B(z, me) {
    var Ce = {
      seen: [],
      stylize: O
    };
    return arguments.length >= 3 && (Ce.depth = arguments[2]), arguments.length >= 4 && (Ce.colors = arguments[3]), de(me) ? Ce.showHidden = me : me && e._extend(Ce, me), ze(Ce.showHidden) && (Ce.showHidden = !1), ze(Ce.depth) && (Ce.depth = 2), ze(Ce.colors) && (Ce.colors = !1), ze(Ce.customInspect) && (Ce.customInspect = !0), Ce.colors && (Ce.stylize = M), D(Ce, z, Ce.depth);
  }
  e.inspect = B, B.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  }, B.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    // "name": intentionally not styling
    regexp: "red"
  };
  function M(z, me) {
    var Ce = B.styles[me];
    return Ce ? "\x1B[" + B.colors[Ce][0] + "m" + z + "\x1B[" + B.colors[Ce][1] + "m" : z;
  }
  function O(z, me) {
    return z;
  }
  function P(z) {
    var me = {};
    return z.forEach(function(Ce, je) {
      me[Ce] = !0;
    }), me;
  }
  function D(z, me, Ce) {
    if (z.customInspect && me && ne(me.inspect) && // Filter out the util module, it's inspect function is special
    me.inspect !== e.inspect && // Also filter out any prototype objects using the circular check.
    !(me.constructor && me.constructor.prototype === me)) {
      var je = me.inspect(Ce, z);
      return Pe(je) || (je = D(z, je, Ce)), je;
    }
    var Re = Z(z, me);
    if (Re)
      return Re;
    var Ae = Object.keys(me), ke = P(Ae);
    if (z.showHidden && (Ae = Object.getOwnPropertyNames(me)), J(me) && (Ae.indexOf("message") >= 0 || Ae.indexOf("description") >= 0))
      return Y(me);
    if (Ae.length === 0) {
      if (ne(me)) {
        var Qe = me.name ? ": " + me.name : "";
        return z.stylize("[Function" + Qe + "]", "special");
      }
      if (Le(me))
        return z.stylize(RegExp.prototype.toString.call(me), "regexp");
      if ($e(me))
        return z.stylize(Date.prototype.toString.call(me), "date");
      if (J(me))
        return Y(me);
    }
    var Ze = "", qe = !1, Oe = ["{", "}"];
    if (fe(me) && (qe = !0, Oe = ["[", "]"]), ne(me)) {
      var Xe = me.name ? ": " + me.name : "";
      Ze = " [Function" + Xe + "]";
    }
    if (Le(me) && (Ze = " " + RegExp.prototype.toString.call(me)), $e(me) && (Ze = " " + Date.prototype.toUTCString.call(me)), J(me) && (Ze = " " + Y(me)), Ae.length === 0 && (!qe || me.length == 0))
      return Oe[0] + Ze + Oe[1];
    if (Ce < 0)
      return Le(me) ? z.stylize(RegExp.prototype.toString.call(me), "regexp") : z.stylize("[Object]", "special");
    z.seen.push(me);
    var et;
    return qe ? et = ee(z, me, Ce, ke, Ae) : et = Ae.map(function(nt) {
      return ie(z, me, Ce, ke, nt, qe);
    }), z.seen.pop(), ue(et, Ze, Oe);
  }
  function Z(z, me) {
    if (ze(me))
      return z.stylize("undefined", "undefined");
    if (Pe(me)) {
      var Ce = "'" + JSON.stringify(me).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return z.stylize(Ce, "string");
    }
    if (ve(me))
      return z.stylize("" + me, "number");
    if (de(me))
      return z.stylize("" + me, "boolean");
    if (ce(me))
      return z.stylize("null", "null");
  }
  function Y(z) {
    return "[" + Error.prototype.toString.call(z) + "]";
  }
  function ee(z, me, Ce, je, Re) {
    for (var Ae = [], ke = 0, Qe = me.length; ke < Qe; ++ke)
      F(me, String(ke)) ? Ae.push(ie(
        z,
        me,
        Ce,
        je,
        String(ke),
        !0
      )) : Ae.push("");
    return Re.forEach(function(Ze) {
      Ze.match(/^\d+$/) || Ae.push(ie(
        z,
        me,
        Ce,
        je,
        Ze,
        !0
      ));
    }), Ae;
  }
  function ie(z, me, Ce, je, Re, Ae) {
    var ke, Qe, Ze;
    if (Ze = Object.getOwnPropertyDescriptor(me, Re) || { value: me[Re] }, Ze.get ? Ze.set ? Qe = z.stylize("[Getter/Setter]", "special") : Qe = z.stylize("[Getter]", "special") : Ze.set && (Qe = z.stylize("[Setter]", "special")), F(je, Re) || (ke = "[" + Re + "]"), Qe || (z.seen.indexOf(Ze.value) < 0 ? (ce(Ce) ? Qe = D(z, Ze.value, null) : Qe = D(z, Ze.value, Ce - 1), Qe.indexOf(`
`) > -1 && (Ae ? Qe = Qe.split(`
`).map(function(qe) {
      return "  " + qe;
    }).join(`
`).slice(2) : Qe = `
` + Qe.split(`
`).map(function(qe) {
      return "   " + qe;
    }).join(`
`))) : Qe = z.stylize("[Circular]", "special")), ze(ke)) {
      if (Ae && Re.match(/^\d+$/))
        return Qe;
      ke = JSON.stringify("" + Re), ke.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (ke = ke.slice(1, -1), ke = z.stylize(ke, "name")) : (ke = ke.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), ke = z.stylize(ke, "string"));
    }
    return ke + ": " + Qe;
  }
  function ue(z, me, Ce) {
    var je = z.reduce(function(Re, Ae) {
      return Ae.indexOf(`
`) >= 0, Re + Ae.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    return je > 60 ? Ce[0] + (me === "" ? "" : me + `
 `) + " " + z.join(`,
  `) + " " + Ce[1] : Ce[0] + me + " " + z.join(", ") + " " + Ce[1];
  }
  e.types = b1;
  function fe(z) {
    return Array.isArray(z);
  }
  e.isArray = fe;
  function de(z) {
    return typeof z == "boolean";
  }
  e.isBoolean = de;
  function ce(z) {
    return z === null;
  }
  e.isNull = ce;
  function be(z) {
    return z == null;
  }
  e.isNullOrUndefined = be;
  function ve(z) {
    return typeof z == "number";
  }
  e.isNumber = ve;
  function Pe(z) {
    return typeof z == "string";
  }
  e.isString = Pe;
  function Ue(z) {
    return typeof z == "symbol";
  }
  e.isSymbol = Ue;
  function ze(z) {
    return z === void 0;
  }
  e.isUndefined = ze;
  function Le(z) {
    return Ne(z) && I(z) === "[object RegExp]";
  }
  e.isRegExp = Le, e.types.isRegExp = Le;
  function Ne(z) {
    return typeof z == "object" && z !== null;
  }
  e.isObject = Ne;
  function $e(z) {
    return Ne(z) && I(z) === "[object Date]";
  }
  e.isDate = $e, e.types.isDate = $e;
  function J(z) {
    return Ne(z) && (I(z) === "[object Error]" || z instanceof Error);
  }
  e.isError = J, e.types.isNativeError = J;
  function ne(z) {
    return typeof z == "function";
  }
  e.isFunction = ne;
  function A(z) {
    return z === null || typeof z == "boolean" || typeof z == "number" || typeof z == "string" || typeof z == "symbol" || // ES6 symbol
    typeof z > "u";
  }
  e.isPrimitive = A, e.isBuffer = xm;
  function I(z) {
    return Object.prototype.toString.call(z);
  }
  function U(z) {
    return z < 10 ? "0" + z.toString(10) : z.toString(10);
  }
  var X = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function Q() {
    var z = /* @__PURE__ */ new Date(), me = [
      U(z.getHours()),
      U(z.getMinutes()),
      U(z.getSeconds())
    ].join(":");
    return [z.getDate(), X[z.getMonth()], me].join(" ");
  }
  e.log = function() {
    console.log("%s - %s", Q(), e.format.apply(e, arguments));
  }, e.inherits = ut, e._extend = function(z, me) {
    if (!me || !Ne(me))
      return z;
    for (var Ce = Object.keys(me), je = Ce.length; je--; )
      z[Ce[je]] = me[Ce[je]];
    return z;
  };
  function F(z, me) {
    return Object.prototype.hasOwnProperty.call(z, me);
  }
  var $ = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
  e.promisify = function(z) {
    if (typeof z != "function")
      throw new TypeError('The "original" argument must be of type Function');
    if ($ && z[$]) {
      var me = z[$];
      if (typeof me != "function")
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      return Object.defineProperty(me, $, {
        value: me,
        enumerable: !1,
        writable: !1,
        configurable: !0
      }), me;
    }
    function me() {
      for (var Ce, je, Re = new Promise(function(Qe, Ze) {
        Ce = Qe, je = Ze;
      }), Ae = [], ke = 0; ke < arguments.length; ke++)
        Ae.push(arguments[ke]);
      Ae.push(function(Qe, Ze) {
        Qe ? je(Qe) : Ce(Ze);
      });
      try {
        z.apply(this, Ae);
      } catch (Qe) {
        je(Qe);
      }
      return Re;
    }
    return Object.setPrototypeOf(me, Object.getPrototypeOf(z)), $ && Object.defineProperty(me, $, {
      value: me,
      enumerable: !1,
      writable: !1,
      configurable: !0
    }), Object.defineProperties(
      me,
      t(z)
    );
  }, e.promisify.custom = $;
  function H(z, me) {
    if (!z) {
      var Ce = new Error("Promise was rejected with a falsy value");
      Ce.reason = z, z = Ce;
    }
    return me(z);
  }
  function q(z) {
    if (typeof z != "function")
      throw new TypeError('The "original" argument must be of type Function');
    function me() {
      for (var Ce = [], je = 0; je < arguments.length; je++)
        Ce.push(arguments[je]);
      var Re = Ce.pop();
      if (typeof Re != "function")
        throw new TypeError("The last argument must be of type Function");
      var Ae = this, ke = function() {
        return Re.apply(Ae, arguments);
      };
      z.apply(this, Ce).then(
        function(Qe) {
          Ve.nextTick(ke.bind(null, null, Qe));
        },
        function(Qe) {
          Ve.nextTick(H.bind(null, Qe, ke));
        }
      );
    }
    return Object.setPrototypeOf(me, Object.getPrototypeOf(z)), Object.defineProperties(
      me,
      t(z)
    ), me;
  }
  e.callbackify = q;
})(wn);
var so, ul;
function _m() {
  if (ul)
    return so;
  ul = 1;
  function e(ie, ue) {
    var fe = Object.keys(ie);
    if (Object.getOwnPropertySymbols) {
      var de = Object.getOwnPropertySymbols(ie);
      ue && (de = de.filter(function(ce) {
        return Object.getOwnPropertyDescriptor(ie, ce).enumerable;
      })), fe.push.apply(fe, de);
    }
    return fe;
  }
  function t(ie) {
    for (var ue = 1; ue < arguments.length; ue++) {
      var fe = arguments[ue] != null ? arguments[ue] : {};
      ue % 2 ? e(Object(fe), !0).forEach(function(de) {
        h(ie, de, fe[de]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(ie, Object.getOwnPropertyDescriptors(fe)) : e(Object(fe)).forEach(function(de) {
        Object.defineProperty(ie, de, Object.getOwnPropertyDescriptor(fe, de));
      });
    }
    return ie;
  }
  function h(ie, ue, fe) {
    return ue = B(ue), ue in ie ? Object.defineProperty(ie, ue, { value: fe, enumerable: !0, configurable: !0, writable: !0 }) : ie[ue] = fe, ie;
  }
  function o(ie, ue) {
    if (!(ie instanceof ue))
      throw new TypeError("Cannot call a class as a function");
  }
  function S(ie, ue) {
    for (var fe = 0; fe < ue.length; fe++) {
      var de = ue[fe];
      de.enumerable = de.enumerable || !1, de.configurable = !0, "value" in de && (de.writable = !0), Object.defineProperty(ie, B(de.key), de);
    }
  }
  function g(ie, ue, fe) {
    return ue && S(ie.prototype, ue), fe && S(ie, fe), Object.defineProperty(ie, "prototype", { writable: !1 }), ie;
  }
  function B(ie) {
    var ue = M(ie, "string");
    return typeof ue == "symbol" ? ue : String(ue);
  }
  function M(ie, ue) {
    if (typeof ie != "object" || ie === null)
      return ie;
    var fe = ie[Symbol.toPrimitive];
    if (fe !== void 0) {
      var de = fe.call(ie, ue || "default");
      if (typeof de != "object")
        return de;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (ue === "string" ? String : Number)(ie);
  }
  var O = pe, P = O.Buffer, D = wn, Z = D.inspect, Y = Z && Z.custom || "inspect";
  function ee(ie, ue, fe) {
    P.prototype.copy.call(ie, ue, fe);
  }
  return so = /* @__PURE__ */ function() {
    function ie() {
      o(this, ie), this.head = null, this.tail = null, this.length = 0;
    }
    return g(ie, [{
      key: "push",
      value: function(ue) {
        var fe = {
          data: ue,
          next: null
        };
        this.length > 0 ? this.tail.next = fe : this.head = fe, this.tail = fe, ++this.length;
      }
    }, {
      key: "unshift",
      value: function(ue) {
        var fe = {
          data: ue,
          next: this.head
        };
        this.length === 0 && (this.tail = fe), this.head = fe, ++this.length;
      }
    }, {
      key: "shift",
      value: function() {
        if (this.length !== 0) {
          var ue = this.head.data;
          return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, ue;
        }
      }
    }, {
      key: "clear",
      value: function() {
        this.head = this.tail = null, this.length = 0;
      }
    }, {
      key: "join",
      value: function(ue) {
        if (this.length === 0)
          return "";
        for (var fe = this.head, de = "" + fe.data; fe = fe.next; )
          de += ue + fe.data;
        return de;
      }
    }, {
      key: "concat",
      value: function(ue) {
        if (this.length === 0)
          return P.alloc(0);
        for (var fe = P.allocUnsafe(ue >>> 0), de = this.head, ce = 0; de; )
          ee(de.data, fe, ce), ce += de.data.length, de = de.next;
        return fe;
      }
      // Consumes a specified amount of bytes or characters from the buffered data.
    }, {
      key: "consume",
      value: function(ue, fe) {
        var de;
        return ue < this.head.data.length ? (de = this.head.data.slice(0, ue), this.head.data = this.head.data.slice(ue)) : ue === this.head.data.length ? de = this.shift() : de = fe ? this._getString(ue) : this._getBuffer(ue), de;
      }
    }, {
      key: "first",
      value: function() {
        return this.head.data;
      }
      // Consumes a specified amount of characters from the buffered data.
    }, {
      key: "_getString",
      value: function(ue) {
        var fe = this.head, de = 1, ce = fe.data;
        for (ue -= ce.length; fe = fe.next; ) {
          var be = fe.data, ve = ue > be.length ? be.length : ue;
          if (ve === be.length ? ce += be : ce += be.slice(0, ue), ue -= ve, ue === 0) {
            ve === be.length ? (++de, fe.next ? this.head = fe.next : this.head = this.tail = null) : (this.head = fe, fe.data = be.slice(ve));
            break;
          }
          ++de;
        }
        return this.length -= de, ce;
      }
      // Consumes a specified amount of bytes from the buffered data.
    }, {
      key: "_getBuffer",
      value: function(ue) {
        var fe = P.allocUnsafe(ue), de = this.head, ce = 1;
        for (de.data.copy(fe), ue -= de.data.length; de = de.next; ) {
          var be = de.data, ve = ue > be.length ? be.length : ue;
          if (be.copy(fe, fe.length - ue, 0, ve), ue -= ve, ue === 0) {
            ve === be.length ? (++ce, de.next ? this.head = de.next : this.head = this.tail = null) : (this.head = de, de.data = be.slice(ve));
            break;
          }
          ++ce;
        }
        return this.length -= ce, fe;
      }
      // Make sure the linked list only shows the minimal necessary information.
    }, {
      key: Y,
      value: function(ue, fe) {
        return Z(this, t(t({}, fe), {}, {
          // Only inspect one level.
          depth: 0,
          // It should not recurse.
          customInspect: !1
        }));
      }
    }]), ie;
  }(), so;
}
function Em(e, t) {
  var h = this, o = this._readableState && this._readableState.destroyed, S = this._writableState && this._writableState.destroyed;
  return o || S ? (t ? t(e) : e && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, Ve.nextTick(rc, this, e)) : Ve.nextTick(rc, this, e)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(e || null, function(g) {
    !t && g ? h._writableState ? h._writableState.errorEmitted ? Ve.nextTick(vs, h) : (h._writableState.errorEmitted = !0, Ve.nextTick(cl, h, g)) : Ve.nextTick(cl, h, g) : t ? (Ve.nextTick(vs, h), t(g)) : Ve.nextTick(vs, h);
  }), this);
}
function cl(e, t) {
  rc(e, t), vs(e);
}
function vs(e) {
  e._writableState && !e._writableState.emitClose || e._readableState && !e._readableState.emitClose || e.emit("close");
}
function Sm() {
  this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
}
function rc(e, t) {
  e.emit("error", t);
}
function wm(e, t) {
  var h = e._readableState, o = e._writableState;
  h && h.autoDestroy || o && o.autoDestroy ? e.destroy(t) : e.emit("error", t);
}
var M1 = {
  destroy: Em,
  undestroy: Sm,
  errorOrDestroy: wm
}, ta = {};
function Cm(e, t) {
  e.prototype = Object.create(t.prototype), e.prototype.constructor = e, e.__proto__ = t;
}
var R1 = {};
function Xr(e, t, h) {
  h || (h = Error);
  function o(g, B, M) {
    return typeof t == "string" ? t : t(g, B, M);
  }
  var S = /* @__PURE__ */ function(g) {
    Cm(B, g);
    function B(M, O, P) {
      return g.call(this, o(M, O, P)) || this;
    }
    return B;
  }(h);
  S.prototype.name = h.name, S.prototype.code = e, R1[e] = S;
}
function hl(e, t) {
  if (Array.isArray(e)) {
    var h = e.length;
    return e = e.map(function(o) {
      return String(o);
    }), h > 2 ? "one of ".concat(t, " ").concat(e.slice(0, h - 1).join(", "), ", or ") + e[h - 1] : h === 2 ? "one of ".concat(t, " ").concat(e[0], " or ").concat(e[1]) : "of ".concat(t, " ").concat(e[0]);
  } else
    return "of ".concat(t, " ").concat(String(e));
}
function Am(e, t, h) {
  return e.substr(!h || h < 0 ? 0 : +h, t.length) === t;
}
function Bm(e, t, h) {
  return (h === void 0 || h > e.length) && (h = e.length), e.substring(h - t.length, h) === t;
}
function Im(e, t, h) {
  return typeof h != "number" && (h = 0), h + t.length > e.length ? !1 : e.indexOf(t, h) !== -1;
}
Xr("ERR_INVALID_OPT_VALUE", function(e, t) {
  return 'The value "' + t + '" is invalid for option "' + e + '"';
}, TypeError);
Xr("ERR_INVALID_ARG_TYPE", function(e, t, h) {
  var o;
  typeof t == "string" && Am(t, "not ") ? (o = "must not be", t = t.replace(/^not /, "")) : o = "must be";
  var S;
  if (Bm(e, " argument"))
    S = "The ".concat(e, " ").concat(o, " ").concat(hl(t, "type"));
  else {
    var g = Im(e, ".") ? "property" : "argument";
    S = 'The "'.concat(e, '" ').concat(g, " ").concat(o, " ").concat(hl(t, "type"));
  }
  return S += ". Received type ".concat(typeof h), S;
}, TypeError);
Xr("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
Xr("ERR_METHOD_NOT_IMPLEMENTED", function(e) {
  return "The " + e + " method is not implemented";
});
Xr("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
Xr("ERR_STREAM_DESTROYED", function(e) {
  return "Cannot call " + e + " after a stream was destroyed";
});
Xr("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
Xr("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
Xr("ERR_STREAM_WRITE_AFTER_END", "write after end");
Xr("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
Xr("ERR_UNKNOWN_ENCODING", function(e) {
  return "Unknown encoding: " + e;
}, TypeError);
Xr("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
ta.codes = R1;
var Tm = ta.codes.ERR_INVALID_OPT_VALUE;
function Mm(e, t, h) {
  return e.highWaterMark != null ? e.highWaterMark : t ? e[h] : null;
}
function Rm(e, t, h, o) {
  var S = Mm(t, o, h);
  if (S != null) {
    if (!(isFinite(S) && Math.floor(S) === S) || S < 0) {
      var g = o ? h : "highWaterMark";
      throw new Tm(g, S);
    }
    return Math.floor(S);
  }
  return e.objectMode ? 16 : 16 * 1024;
}
var N1 = {
  getHighWaterMark: Rm
}, Nm = Dm;
function Dm(e, t) {
  if (fo("noDeprecation"))
    return e;
  var h = !1;
  function o() {
    if (!h) {
      if (fo("throwDeprecation"))
        throw new Error(t);
      fo("traceDeprecation") ? console.trace(t) : console.warn(t), h = !0;
    }
    return e.apply(this, arguments);
  }
  return o;
}
function fo(e) {
  try {
    if (!Me.localStorage)
      return !1;
  } catch {
    return !1;
  }
  var t = Me.localStorage[e];
  return t == null ? !1 : String(t).toLowerCase() === "true";
}
var oo, ll;
function Vc() {
  if (ll)
    return oo;
  ll = 1, oo = Le;
  function e(Re) {
    var Ae = this;
    this.next = null, this.entry = null, this.finish = function() {
      je(Ae, Re);
    };
  }
  var t;
  Le.WritableState = Ue;
  var h = {
    deprecate: Nm
  }, o = m1, S = pe.Buffer, g = (typeof Me < "u" ? Me : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function B(Re) {
    return S.from(Re);
  }
  function M(Re) {
    return S.isBuffer(Re) || Re instanceof g;
  }
  var O = M1, P = N1, D = P.getHighWaterMark, Z = ta.codes, Y = Z.ERR_INVALID_ARG_TYPE, ee = Z.ERR_METHOD_NOT_IMPLEMENTED, ie = Z.ERR_MULTIPLE_CALLBACK, ue = Z.ERR_STREAM_CANNOT_PIPE, fe = Z.ERR_STREAM_DESTROYED, de = Z.ERR_STREAM_NULL_VALUES, ce = Z.ERR_STREAM_WRITE_AFTER_END, be = Z.ERR_UNKNOWN_ENCODING, ve = O.errorOrDestroy;
  ut(Le, o);
  function Pe() {
  }
  function Ue(Re, Ae, ke) {
    t = t || Xn(), Re = Re || {}, typeof ke != "boolean" && (ke = Ae instanceof t), this.objectMode = !!Re.objectMode, ke && (this.objectMode = this.objectMode || !!Re.writableObjectMode), this.highWaterMark = D(this, Re, "writableHighWaterMark", ke), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
    var Qe = Re.decodeStrings === !1;
    this.decodeStrings = !Qe, this.defaultEncoding = Re.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(Ze) {
      X(Ae, Ze);
    }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = Re.emitClose !== !1, this.autoDestroy = !!Re.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new e(this);
  }
  Ue.prototype.getBuffer = function() {
    for (var Re = this.bufferedRequest, Ae = []; Re; )
      Ae.push(Re), Re = Re.next;
    return Ae;
  }, function() {
    try {
      Object.defineProperty(Ue.prototype, "buffer", {
        get: h.deprecate(function() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch {
    }
  }();
  var ze;
  typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (ze = Function.prototype[Symbol.hasInstance], Object.defineProperty(Le, Symbol.hasInstance, {
    value: function(Re) {
      return ze.call(this, Re) ? !0 : this !== Le ? !1 : Re && Re._writableState instanceof Ue;
    }
  })) : ze = function(Re) {
    return Re instanceof this;
  };
  function Le(Re) {
    t = t || Xn();
    var Ae = this instanceof t;
    if (!Ae && !ze.call(Le, this))
      return new Le(Re);
    this._writableState = new Ue(Re, this, Ae), this.writable = !0, Re && (typeof Re.write == "function" && (this._write = Re.write), typeof Re.writev == "function" && (this._writev = Re.writev), typeof Re.destroy == "function" && (this._destroy = Re.destroy), typeof Re.final == "function" && (this._final = Re.final)), o.call(this);
  }
  Le.prototype.pipe = function() {
    ve(this, new ue());
  };
  function Ne(Re, Ae) {
    var ke = new ce();
    ve(Re, ke), Ve.nextTick(Ae, ke);
  }
  function $e(Re, Ae, ke, Qe) {
    var Ze;
    return ke === null ? Ze = new de() : typeof ke != "string" && !Ae.objectMode && (Ze = new Y("chunk", ["string", "Buffer"], ke)), Ze ? (ve(Re, Ze), Ve.nextTick(Qe, Ze), !1) : !0;
  }
  Le.prototype.write = function(Re, Ae, ke) {
    var Qe = this._writableState, Ze = !1, qe = !Qe.objectMode && M(Re);
    return qe && !S.isBuffer(Re) && (Re = B(Re)), typeof Ae == "function" && (ke = Ae, Ae = null), qe ? Ae = "buffer" : Ae || (Ae = Qe.defaultEncoding), typeof ke != "function" && (ke = Pe), Qe.ending ? Ne(this, ke) : (qe || $e(this, Qe, Re, ke)) && (Qe.pendingcb++, Ze = ne(this, Qe, qe, Re, Ae, ke)), Ze;
  }, Le.prototype.cork = function() {
    this._writableState.corked++;
  }, Le.prototype.uncork = function() {
    var Re = this._writableState;
    Re.corked && (Re.corked--, !Re.writing && !Re.corked && !Re.bufferProcessing && Re.bufferedRequest && $(this, Re));
  }, Le.prototype.setDefaultEncoding = function(Re) {
    if (typeof Re == "string" && (Re = Re.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((Re + "").toLowerCase()) > -1))
      throw new be(Re);
    return this._writableState.defaultEncoding = Re, this;
  }, Object.defineProperty(Le.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function J(Re, Ae, ke) {
    return !Re.objectMode && Re.decodeStrings !== !1 && typeof Ae == "string" && (Ae = S.from(Ae, ke)), Ae;
  }
  Object.defineProperty(Le.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  });
  function ne(Re, Ae, ke, Qe, Ze, qe) {
    if (!ke) {
      var Oe = J(Ae, Qe, Ze);
      Qe !== Oe && (ke = !0, Ze = "buffer", Qe = Oe);
    }
    var Xe = Ae.objectMode ? 1 : Qe.length;
    Ae.length += Xe;
    var et = Ae.length < Ae.highWaterMark;
    if (et || (Ae.needDrain = !0), Ae.writing || Ae.corked) {
      var nt = Ae.lastBufferedRequest;
      Ae.lastBufferedRequest = {
        chunk: Qe,
        encoding: Ze,
        isBuf: ke,
        callback: qe,
        next: null
      }, nt ? nt.next = Ae.lastBufferedRequest : Ae.bufferedRequest = Ae.lastBufferedRequest, Ae.bufferedRequestCount += 1;
    } else
      A(Re, Ae, !1, Xe, Qe, Ze, qe);
    return et;
  }
  function A(Re, Ae, ke, Qe, Ze, qe, Oe) {
    Ae.writelen = Qe, Ae.writecb = Oe, Ae.writing = !0, Ae.sync = !0, Ae.destroyed ? Ae.onwrite(new fe("write")) : ke ? Re._writev(Ze, Ae.onwrite) : Re._write(Ze, qe, Ae.onwrite), Ae.sync = !1;
  }
  function I(Re, Ae, ke, Qe, Ze) {
    --Ae.pendingcb, ke ? (Ve.nextTick(Ze, Qe), Ve.nextTick(me, Re, Ae), Re._writableState.errorEmitted = !0, ve(Re, Qe)) : (Ze(Qe), Re._writableState.errorEmitted = !0, ve(Re, Qe), me(Re, Ae));
  }
  function U(Re) {
    Re.writing = !1, Re.writecb = null, Re.length -= Re.writelen, Re.writelen = 0;
  }
  function X(Re, Ae) {
    var ke = Re._writableState, Qe = ke.sync, Ze = ke.writecb;
    if (typeof Ze != "function")
      throw new ie();
    if (U(ke), Ae)
      I(Re, ke, Qe, Ae, Ze);
    else {
      var qe = H(ke) || Re.destroyed;
      !qe && !ke.corked && !ke.bufferProcessing && ke.bufferedRequest && $(Re, ke), Qe ? Ve.nextTick(Q, Re, ke, qe, Ze) : Q(Re, ke, qe, Ze);
    }
  }
  function Q(Re, Ae, ke, Qe) {
    ke || F(Re, Ae), Ae.pendingcb--, Qe(), me(Re, Ae);
  }
  function F(Re, Ae) {
    Ae.length === 0 && Ae.needDrain && (Ae.needDrain = !1, Re.emit("drain"));
  }
  function $(Re, Ae) {
    Ae.bufferProcessing = !0;
    var ke = Ae.bufferedRequest;
    if (Re._writev && ke && ke.next) {
      var Qe = Ae.bufferedRequestCount, Ze = new Array(Qe), qe = Ae.corkedRequestsFree;
      qe.entry = ke;
      for (var Oe = 0, Xe = !0; ke; )
        Ze[Oe] = ke, ke.isBuf || (Xe = !1), ke = ke.next, Oe += 1;
      Ze.allBuffers = Xe, A(Re, Ae, !0, Ae.length, Ze, "", qe.finish), Ae.pendingcb++, Ae.lastBufferedRequest = null, qe.next ? (Ae.corkedRequestsFree = qe.next, qe.next = null) : Ae.corkedRequestsFree = new e(Ae), Ae.bufferedRequestCount = 0;
    } else {
      for (; ke; ) {
        var et = ke.chunk, nt = ke.encoding, re = ke.callback, oe = Ae.objectMode ? 1 : et.length;
        if (A(Re, Ae, !1, oe, et, nt, re), ke = ke.next, Ae.bufferedRequestCount--, Ae.writing)
          break;
      }
      ke === null && (Ae.lastBufferedRequest = null);
    }
    Ae.bufferedRequest = ke, Ae.bufferProcessing = !1;
  }
  Le.prototype._write = function(Re, Ae, ke) {
    ke(new ee("_write()"));
  }, Le.prototype._writev = null, Le.prototype.end = function(Re, Ae, ke) {
    var Qe = this._writableState;
    return typeof Re == "function" ? (ke = Re, Re = null, Ae = null) : typeof Ae == "function" && (ke = Ae, Ae = null), Re != null && this.write(Re, Ae), Qe.corked && (Qe.corked = 1, this.uncork()), Qe.ending || Ce(this, Qe, ke), this;
  }, Object.defineProperty(Le.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function H(Re) {
    return Re.ending && Re.length === 0 && Re.bufferedRequest === null && !Re.finished && !Re.writing;
  }
  function q(Re, Ae) {
    Re._final(function(ke) {
      Ae.pendingcb--, ke && ve(Re, ke), Ae.prefinished = !0, Re.emit("prefinish"), me(Re, Ae);
    });
  }
  function z(Re, Ae) {
    !Ae.prefinished && !Ae.finalCalled && (typeof Re._final == "function" && !Ae.destroyed ? (Ae.pendingcb++, Ae.finalCalled = !0, Ve.nextTick(q, Re, Ae)) : (Ae.prefinished = !0, Re.emit("prefinish")));
  }
  function me(Re, Ae) {
    var ke = H(Ae);
    if (ke && (z(Re, Ae), Ae.pendingcb === 0 && (Ae.finished = !0, Re.emit("finish"), Ae.autoDestroy))) {
      var Qe = Re._readableState;
      (!Qe || Qe.autoDestroy && Qe.endEmitted) && Re.destroy();
    }
    return ke;
  }
  function Ce(Re, Ae, ke) {
    Ae.ending = !0, me(Re, Ae), ke && (Ae.finished ? Ve.nextTick(ke) : Re.once("finish", ke)), Ae.ended = !0, Re.writable = !1;
  }
  function je(Re, Ae, ke) {
    var Qe = Re.entry;
    for (Re.entry = null; Qe; ) {
      var Ze = Qe.callback;
      Ae.pendingcb--, Ze(ke), Qe = Qe.next;
    }
    Ae.corkedRequestsFree.next = Re;
  }
  return Object.defineProperty(Le.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState === void 0 ? !1 : this._writableState.destroyed;
    },
    set: function(Re) {
      this._writableState && (this._writableState.destroyed = Re);
    }
  }), Le.prototype.destroy = O.destroy, Le.prototype._undestroy = O.undestroy, Le.prototype._destroy = function(Re, Ae) {
    Ae(Re);
  }, oo;
}
var uo, dl;
function Xn() {
  if (dl)
    return uo;
  dl = 1;
  var e = Object.keys || function(P) {
    var D = [];
    for (var Z in P)
      D.push(Z);
    return D;
  };
  uo = B;
  var t = $c(), h = Vc();
  ut(B, t);
  for (var o = e(h.prototype), S = 0; S < o.length; S++) {
    var g = o[S];
    B.prototype[g] || (B.prototype[g] = h.prototype[g]);
  }
  function B(P) {
    if (!(this instanceof B))
      return new B(P);
    t.call(this, P), h.call(this, P), this.allowHalfOpen = !0, P && (P.readable === !1 && (this.readable = !1), P.writable === !1 && (this.writable = !1), P.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", M)));
  }
  Object.defineProperty(B.prototype, "writableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.highWaterMark;
    }
  }), Object.defineProperty(B.prototype, "writableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState && this._writableState.getBuffer();
    }
  }), Object.defineProperty(B.prototype, "writableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._writableState.length;
    }
  });
  function M() {
    this._writableState.ended || Ve.nextTick(O, this);
  }
  function O(P) {
    P.end();
  }
  return Object.defineProperty(B.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 || this._writableState === void 0 ? !1 : this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function(P) {
      this._readableState === void 0 || this._writableState === void 0 || (this._readableState.destroyed = P, this._writableState.destroyed = P);
    }
  }), uo;
}
var Bs = {}, Kc = ct.Buffer, pl = Kc.isEncoding || function(e) {
  switch (e = "" + e, e && e.toLowerCase()) {
    case "hex":
    case "utf8":
    case "utf-8":
    case "ascii":
    case "binary":
    case "base64":
    case "ucs2":
    case "ucs-2":
    case "utf16le":
    case "utf-16le":
    case "raw":
      return !0;
    default:
      return !1;
  }
};
function Om(e) {
  if (!e)
    return "utf8";
  for (var t; ; )
    switch (e) {
      case "utf8":
      case "utf-8":
        return "utf8";
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return "utf16le";
      case "latin1":
      case "binary":
        return "latin1";
      case "base64":
      case "ascii":
      case "hex":
        return e;
      default:
        if (t)
          return;
        e = ("" + e).toLowerCase(), t = !0;
    }
}
function Pm(e) {
  var t = Om(e);
  if (typeof t != "string" && (Kc.isEncoding === pl || !pl(e)))
    throw new Error("Unknown encoding: " + e);
  return t || e;
}
Bs.StringDecoder = M0;
function M0(e) {
  this.encoding = Pm(e);
  var t;
  switch (this.encoding) {
    case "utf16le":
      this.text = Vm, this.end = Km, t = 4;
      break;
    case "utf8":
      this.fillLast = Um, t = 4;
      break;
    case "base64":
      this.text = $m, this.end = Hm, t = 3;
      break;
    default:
      this.write = Gm, this.end = zm;
      return;
  }
  this.lastNeed = 0, this.lastTotal = 0, this.lastChar = Kc.allocUnsafe(t);
}
M0.prototype.write = function(e) {
  if (e.length === 0)
    return "";
  var t, h;
  if (this.lastNeed) {
    if (t = this.fillLast(e), t === void 0)
      return "";
    h = this.lastNeed, this.lastNeed = 0;
  } else
    h = 0;
  return h < e.length ? t ? t + this.text(e, h) : this.text(e, h) : t || "";
};
M0.prototype.end = qm;
M0.prototype.text = Fm;
M0.prototype.fillLast = function(e) {
  if (this.lastNeed <= e.length)
    return e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  e.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, e.length), this.lastNeed -= e.length;
};
function co(e) {
  return e <= 127 ? 0 : e >> 5 === 6 ? 2 : e >> 4 === 14 ? 3 : e >> 3 === 30 ? 4 : e >> 6 === 2 ? -1 : -2;
}
function Lm(e, t, h) {
  var o = t.length - 1;
  if (o < h)
    return 0;
  var S = co(t[o]);
  return S >= 0 ? (S > 0 && (e.lastNeed = S - 1), S) : --o < h || S === -2 ? 0 : (S = co(t[o]), S >= 0 ? (S > 0 && (e.lastNeed = S - 2), S) : --o < h || S === -2 ? 0 : (S = co(t[o]), S >= 0 ? (S > 0 && (S === 2 ? S = 0 : e.lastNeed = S - 3), S) : 0));
}
function km(e, t, h) {
  if ((t[0] & 192) !== 128)
    return e.lastNeed = 0, "�";
  if (e.lastNeed > 1 && t.length > 1) {
    if ((t[1] & 192) !== 128)
      return e.lastNeed = 1, "�";
    if (e.lastNeed > 2 && t.length > 2 && (t[2] & 192) !== 128)
      return e.lastNeed = 2, "�";
  }
}
function Um(e) {
  var t = this.lastTotal - this.lastNeed, h = km(this, e);
  if (h !== void 0)
    return h;
  if (this.lastNeed <= e.length)
    return e.copy(this.lastChar, t, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
  e.copy(this.lastChar, t, 0, e.length), this.lastNeed -= e.length;
}
function Fm(e, t) {
  var h = Lm(this, e, t);
  if (!this.lastNeed)
    return e.toString("utf8", t);
  this.lastTotal = h;
  var o = e.length - (h - this.lastNeed);
  return e.copy(this.lastChar, 0, o), e.toString("utf8", t, o);
}
function qm(e) {
  var t = e && e.length ? this.write(e) : "";
  return this.lastNeed ? t + "�" : t;
}
function Vm(e, t) {
  if ((e.length - t) % 2 === 0) {
    var h = e.toString("utf16le", t);
    if (h) {
      var o = h.charCodeAt(h.length - 1);
      if (o >= 55296 && o <= 56319)
        return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1], h.slice(0, -1);
    }
    return h;
  }
  return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = e[e.length - 1], e.toString("utf16le", t, e.length - 1);
}
function Km(e) {
  var t = e && e.length ? this.write(e) : "";
  if (this.lastNeed) {
    var h = this.lastTotal - this.lastNeed;
    return t + this.lastChar.toString("utf16le", 0, h);
  }
  return t;
}
function $m(e, t) {
  var h = (e.length - t) % 3;
  return h === 0 ? e.toString("base64", t) : (this.lastNeed = 3 - h, this.lastTotal = 3, h === 1 ? this.lastChar[0] = e[e.length - 1] : (this.lastChar[0] = e[e.length - 2], this.lastChar[1] = e[e.length - 1]), e.toString("base64", t, e.length - h));
}
function Hm(e) {
  var t = e && e.length ? this.write(e) : "";
  return this.lastNeed ? t + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : t;
}
function Gm(e) {
  return e.toString(this.encoding);
}
function zm(e) {
  return e && e.length ? this.write(e) : "";
}
var vl = ta.codes.ERR_STREAM_PREMATURE_CLOSE;
function jm(e) {
  var t = !1;
  return function() {
    if (!t) {
      t = !0;
      for (var h = arguments.length, o = new Array(h), S = 0; S < h; S++)
        o[S] = arguments[S];
      e.apply(this, o);
    }
  };
}
function Wm() {
}
function Ym(e) {
  return e.setHeader && typeof e.abort == "function";
}
function D1(e, t, h) {
  if (typeof t == "function")
    return D1(e, null, t);
  t || (t = {}), h = jm(h || Wm);
  var o = t.readable || t.readable !== !1 && e.readable, S = t.writable || t.writable !== !1 && e.writable, g = function() {
    e.writable || M();
  }, B = e._writableState && e._writableState.finished, M = function() {
    S = !1, B = !0, o || h.call(e);
  }, O = e._readableState && e._readableState.endEmitted, P = function() {
    o = !1, O = !0, S || h.call(e);
  }, D = function(ee) {
    h.call(e, ee);
  }, Z = function() {
    var ee;
    if (o && !O)
      return (!e._readableState || !e._readableState.ended) && (ee = new vl()), h.call(e, ee);
    if (S && !B)
      return (!e._writableState || !e._writableState.ended) && (ee = new vl()), h.call(e, ee);
  }, Y = function() {
    e.req.on("finish", M);
  };
  return Ym(e) ? (e.on("complete", M), e.on("abort", Z), e.req ? Y() : e.on("request", Y)) : S && !e._writableState && (e.on("end", g), e.on("close", g)), e.on("end", P), e.on("finish", M), t.error !== !1 && e.on("error", D), e.on("close", Z), function() {
    e.removeListener("complete", M), e.removeListener("abort", Z), e.removeListener("request", Y), e.req && e.req.removeListener("finish", M), e.removeListener("end", g), e.removeListener("close", g), e.removeListener("finish", M), e.removeListener("end", P), e.removeListener("error", D), e.removeListener("close", Z);
  };
}
var Qs = D1, ho, yl;
function Xm() {
  if (yl)
    return ho;
  yl = 1;
  var e;
  function t(be, ve, Pe) {
    return ve = h(ve), ve in be ? Object.defineProperty(be, ve, { value: Pe, enumerable: !0, configurable: !0, writable: !0 }) : be[ve] = Pe, be;
  }
  function h(be) {
    var ve = o(be, "string");
    return typeof ve == "symbol" ? ve : String(ve);
  }
  function o(be, ve) {
    if (typeof be != "object" || be === null)
      return be;
    var Pe = be[Symbol.toPrimitive];
    if (Pe !== void 0) {
      var Ue = Pe.call(be, ve || "default");
      if (typeof Ue != "object")
        return Ue;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (ve === "string" ? String : Number)(be);
  }
  var S = Qs, g = Symbol("lastResolve"), B = Symbol("lastReject"), M = Symbol("error"), O = Symbol("ended"), P = Symbol("lastPromise"), D = Symbol("handlePromise"), Z = Symbol("stream");
  function Y(be, ve) {
    return {
      value: be,
      done: ve
    };
  }
  function ee(be) {
    var ve = be[g];
    if (ve !== null) {
      var Pe = be[Z].read();
      Pe !== null && (be[P] = null, be[g] = null, be[B] = null, ve(Y(Pe, !1)));
    }
  }
  function ie(be) {
    Ve.nextTick(ee, be);
  }
  function ue(be, ve) {
    return function(Pe, Ue) {
      be.then(function() {
        if (ve[O]) {
          Pe(Y(void 0, !0));
          return;
        }
        ve[D](Pe, Ue);
      }, Ue);
    };
  }
  var fe = Object.getPrototypeOf(function() {
  }), de = Object.setPrototypeOf((e = {
    get stream() {
      return this[Z];
    },
    next: function() {
      var be = this, ve = this[M];
      if (ve !== null)
        return Promise.reject(ve);
      if (this[O])
        return Promise.resolve(Y(void 0, !0));
      if (this[Z].destroyed)
        return new Promise(function(Le, Ne) {
          Ve.nextTick(function() {
            be[M] ? Ne(be[M]) : Le(Y(void 0, !0));
          });
        });
      var Pe = this[P], Ue;
      if (Pe)
        Ue = new Promise(ue(Pe, this));
      else {
        var ze = this[Z].read();
        if (ze !== null)
          return Promise.resolve(Y(ze, !1));
        Ue = new Promise(this[D]);
      }
      return this[P] = Ue, Ue;
    }
  }, t(e, Symbol.asyncIterator, function() {
    return this;
  }), t(e, "return", function() {
    var be = this;
    return new Promise(function(ve, Pe) {
      be[Z].destroy(null, function(Ue) {
        if (Ue) {
          Pe(Ue);
          return;
        }
        ve(Y(void 0, !0));
      });
    });
  }), e), fe), ce = function(be) {
    var ve, Pe = Object.create(de, (ve = {}, t(ve, Z, {
      value: be,
      writable: !0
    }), t(ve, g, {
      value: null,
      writable: !0
    }), t(ve, B, {
      value: null,
      writable: !0
    }), t(ve, M, {
      value: null,
      writable: !0
    }), t(ve, O, {
      value: be._readableState.endEmitted,
      writable: !0
    }), t(ve, D, {
      value: function(Ue, ze) {
        var Le = Pe[Z].read();
        Le ? (Pe[P] = null, Pe[g] = null, Pe[B] = null, Ue(Y(Le, !1))) : (Pe[g] = Ue, Pe[B] = ze);
      },
      writable: !0
    }), ve));
    return Pe[P] = null, S(be, function(Ue) {
      if (Ue && Ue.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var ze = Pe[B];
        ze !== null && (Pe[P] = null, Pe[g] = null, Pe[B] = null, ze(Ue)), Pe[M] = Ue;
        return;
      }
      var Le = Pe[g];
      Le !== null && (Pe[P] = null, Pe[g] = null, Pe[B] = null, Le(Y(void 0, !0))), Pe[O] = !0;
    }), be.on("readable", ie.bind(null, Pe)), Pe;
  };
  return ho = ce, ho;
}
var lo, gl;
function Qm() {
  return gl || (gl = 1, lo = function() {
    throw new Error("Readable.from is not available in the browser");
  }), lo;
}
var po, ml;
function $c() {
  if (ml)
    return po;
  ml = 1, po = Ne;
  var e;
  Ne.ReadableState = Le, Lc.EventEmitter;
  var t = function(qe, Oe) {
    return qe.listeners(Oe).length;
  }, h = m1, o = pe.Buffer, S = (typeof Me < "u" ? Me : typeof window < "u" ? window : typeof self < "u" ? self : {}).Uint8Array || function() {
  };
  function g(qe) {
    return o.from(qe);
  }
  function B(qe) {
    return o.isBuffer(qe) || qe instanceof S;
  }
  var M = wn, O;
  M && M.debuglog ? O = M.debuglog("stream") : O = function() {
  };
  var P = _m(), D = M1, Z = N1, Y = Z.getHighWaterMark, ee = ta.codes, ie = ee.ERR_INVALID_ARG_TYPE, ue = ee.ERR_STREAM_PUSH_AFTER_EOF, fe = ee.ERR_METHOD_NOT_IMPLEMENTED, de = ee.ERR_STREAM_UNSHIFT_AFTER_END_EVENT, ce, be, ve;
  ut(Ne, h);
  var Pe = D.errorOrDestroy, Ue = ["error", "close", "destroy", "pause", "resume"];
  function ze(qe, Oe, Xe) {
    if (typeof qe.prependListener == "function")
      return qe.prependListener(Oe, Xe);
    !qe._events || !qe._events[Oe] ? qe.on(Oe, Xe) : Array.isArray(qe._events[Oe]) ? qe._events[Oe].unshift(Xe) : qe._events[Oe] = [Xe, qe._events[Oe]];
  }
  function Le(qe, Oe, Xe) {
    e = e || Xn(), qe = qe || {}, typeof Xe != "boolean" && (Xe = Oe instanceof e), this.objectMode = !!qe.objectMode, Xe && (this.objectMode = this.objectMode || !!qe.readableObjectMode), this.highWaterMark = Y(this, qe, "readableHighWaterMark", Xe), this.buffer = new P(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = qe.emitClose !== !1, this.autoDestroy = !!qe.autoDestroy, this.destroyed = !1, this.defaultEncoding = qe.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, qe.encoding && (ce || (ce = Bs.StringDecoder), this.decoder = new ce(qe.encoding), this.encoding = qe.encoding);
  }
  function Ne(qe) {
    if (e = e || Xn(), !(this instanceof Ne))
      return new Ne(qe);
    var Oe = this instanceof e;
    this._readableState = new Le(qe, this, Oe), this.readable = !0, qe && (typeof qe.read == "function" && (this._read = qe.read), typeof qe.destroy == "function" && (this._destroy = qe.destroy)), h.call(this);
  }
  Object.defineProperty(Ne.prototype, "destroyed", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState === void 0 ? !1 : this._readableState.destroyed;
    },
    set: function(qe) {
      this._readableState && (this._readableState.destroyed = qe);
    }
  }), Ne.prototype.destroy = D.destroy, Ne.prototype._undestroy = D.undestroy, Ne.prototype._destroy = function(qe, Oe) {
    Oe(qe);
  }, Ne.prototype.push = function(qe, Oe) {
    var Xe = this._readableState, et;
    return Xe.objectMode ? et = !0 : typeof qe == "string" && (Oe = Oe || Xe.defaultEncoding, Oe !== Xe.encoding && (qe = o.from(qe, Oe), Oe = ""), et = !0), $e(this, qe, Oe, !1, et);
  }, Ne.prototype.unshift = function(qe) {
    return $e(this, qe, null, !0, !1);
  };
  function $e(qe, Oe, Xe, et, nt) {
    O("readableAddChunk", Oe);
    var re = qe._readableState;
    if (Oe === null)
      re.reading = !1, X(qe, re);
    else {
      var oe;
      if (nt || (oe = ne(re, Oe)), oe)
        Pe(qe, oe);
      else if (re.objectMode || Oe && Oe.length > 0)
        if (typeof Oe != "string" && !re.objectMode && Object.getPrototypeOf(Oe) !== o.prototype && (Oe = g(Oe)), et)
          re.endEmitted ? Pe(qe, new de()) : J(qe, re, Oe, !0);
        else if (re.ended)
          Pe(qe, new ue());
        else {
          if (re.destroyed)
            return !1;
          re.reading = !1, re.decoder && !Xe ? (Oe = re.decoder.write(Oe), re.objectMode || Oe.length !== 0 ? J(qe, re, Oe, !1) : $(qe, re)) : J(qe, re, Oe, !1);
        }
      else
        et || (re.reading = !1, $(qe, re));
    }
    return !re.ended && (re.length < re.highWaterMark || re.length === 0);
  }
  function J(qe, Oe, Xe, et) {
    Oe.flowing && Oe.length === 0 && !Oe.sync ? (Oe.awaitDrain = 0, qe.emit("data", Xe)) : (Oe.length += Oe.objectMode ? 1 : Xe.length, et ? Oe.buffer.unshift(Xe) : Oe.buffer.push(Xe), Oe.needReadable && Q(qe)), $(qe, Oe);
  }
  function ne(qe, Oe) {
    var Xe;
    return !B(Oe) && typeof Oe != "string" && Oe !== void 0 && !qe.objectMode && (Xe = new ie("chunk", ["string", "Buffer", "Uint8Array"], Oe)), Xe;
  }
  Ne.prototype.isPaused = function() {
    return this._readableState.flowing === !1;
  }, Ne.prototype.setEncoding = function(qe) {
    ce || (ce = Bs.StringDecoder);
    var Oe = new ce(qe);
    this._readableState.decoder = Oe, this._readableState.encoding = this._readableState.decoder.encoding;
    for (var Xe = this._readableState.buffer.head, et = ""; Xe !== null; )
      et += Oe.write(Xe.data), Xe = Xe.next;
    return this._readableState.buffer.clear(), et !== "" && this._readableState.buffer.push(et), this._readableState.length = et.length, this;
  };
  var A = 1073741824;
  function I(qe) {
    return qe >= A ? qe = A : (qe--, qe |= qe >>> 1, qe |= qe >>> 2, qe |= qe >>> 4, qe |= qe >>> 8, qe |= qe >>> 16, qe++), qe;
  }
  function U(qe, Oe) {
    return qe <= 0 || Oe.length === 0 && Oe.ended ? 0 : Oe.objectMode ? 1 : qe !== qe ? Oe.flowing && Oe.length ? Oe.buffer.head.data.length : Oe.length : (qe > Oe.highWaterMark && (Oe.highWaterMark = I(qe)), qe <= Oe.length ? qe : Oe.ended ? Oe.length : (Oe.needReadable = !0, 0));
  }
  Ne.prototype.read = function(qe) {
    O("read", qe), qe = parseInt(qe, 10);
    var Oe = this._readableState, Xe = qe;
    if (qe !== 0 && (Oe.emittedReadable = !1), qe === 0 && Oe.needReadable && ((Oe.highWaterMark !== 0 ? Oe.length >= Oe.highWaterMark : Oe.length > 0) || Oe.ended))
      return O("read: emitReadable", Oe.length, Oe.ended), Oe.length === 0 && Oe.ended ? ke(this) : Q(this), null;
    if (qe = U(qe, Oe), qe === 0 && Oe.ended)
      return Oe.length === 0 && ke(this), null;
    var et = Oe.needReadable;
    O("need readable", et), (Oe.length === 0 || Oe.length - qe < Oe.highWaterMark) && (et = !0, O("length less than watermark", et)), Oe.ended || Oe.reading ? (et = !1, O("reading or ended", et)) : et && (O("do read"), Oe.reading = !0, Oe.sync = !0, Oe.length === 0 && (Oe.needReadable = !0), this._read(Oe.highWaterMark), Oe.sync = !1, Oe.reading || (qe = U(Xe, Oe)));
    var nt;
    return qe > 0 ? nt = Ae(qe, Oe) : nt = null, nt === null ? (Oe.needReadable = Oe.length <= Oe.highWaterMark, qe = 0) : (Oe.length -= qe, Oe.awaitDrain = 0), Oe.length === 0 && (Oe.ended || (Oe.needReadable = !0), Xe !== qe && Oe.ended && ke(this)), nt !== null && this.emit("data", nt), nt;
  };
  function X(qe, Oe) {
    if (O("onEofChunk"), !Oe.ended) {
      if (Oe.decoder) {
        var Xe = Oe.decoder.end();
        Xe && Xe.length && (Oe.buffer.push(Xe), Oe.length += Oe.objectMode ? 1 : Xe.length);
      }
      Oe.ended = !0, Oe.sync ? Q(qe) : (Oe.needReadable = !1, Oe.emittedReadable || (Oe.emittedReadable = !0, F(qe)));
    }
  }
  function Q(qe) {
    var Oe = qe._readableState;
    O("emitReadable", Oe.needReadable, Oe.emittedReadable), Oe.needReadable = !1, Oe.emittedReadable || (O("emitReadable", Oe.flowing), Oe.emittedReadable = !0, Ve.nextTick(F, qe));
  }
  function F(qe) {
    var Oe = qe._readableState;
    O("emitReadable_", Oe.destroyed, Oe.length, Oe.ended), !Oe.destroyed && (Oe.length || Oe.ended) && (qe.emit("readable"), Oe.emittedReadable = !1), Oe.needReadable = !Oe.flowing && !Oe.ended && Oe.length <= Oe.highWaterMark, Re(qe);
  }
  function $(qe, Oe) {
    Oe.readingMore || (Oe.readingMore = !0, Ve.nextTick(H, qe, Oe));
  }
  function H(qe, Oe) {
    for (; !Oe.reading && !Oe.ended && (Oe.length < Oe.highWaterMark || Oe.flowing && Oe.length === 0); ) {
      var Xe = Oe.length;
      if (O("maybeReadMore read 0"), qe.read(0), Xe === Oe.length)
        break;
    }
    Oe.readingMore = !1;
  }
  Ne.prototype._read = function(qe) {
    Pe(this, new fe("_read()"));
  }, Ne.prototype.pipe = function(qe, Oe) {
    var Xe = this, et = this._readableState;
    switch (et.pipesCount) {
      case 0:
        et.pipes = qe;
        break;
      case 1:
        et.pipes = [et.pipes, qe];
        break;
      default:
        et.pipes.push(qe);
        break;
    }
    et.pipesCount += 1, O("pipe count=%d opts=%j", et.pipesCount, Oe);
    var nt = (!Oe || Oe.end !== !1) && qe !== Ve.stdout && qe !== Ve.stderr, re = nt ? le : tt;
    et.endEmitted ? Ve.nextTick(re) : Xe.once("end", re), qe.on("unpipe", oe);
    function oe(vt, St) {
      O("onunpipe"), vt === Xe && St && St.hasUnpiped === !1 && (St.hasUnpiped = !0, Je());
    }
    function le() {
      O("onend"), qe.end();
    }
    var ge = q(Xe);
    qe.on("drain", ge);
    var Ke = !1;
    function Je() {
      O("cleanup"), qe.removeListener("close", it), qe.removeListener("finish", rt), qe.removeListener("drain", ge), qe.removeListener("error", Ye), qe.removeListener("unpipe", oe), Xe.removeListener("end", le), Xe.removeListener("end", tt), Xe.removeListener("data", Fe), Ke = !0, et.awaitDrain && (!qe._writableState || qe._writableState.needDrain) && ge();
    }
    Xe.on("data", Fe);
    function Fe(vt) {
      O("ondata");
      var St = qe.write(vt);
      O("dest.write", St), St === !1 && ((et.pipesCount === 1 && et.pipes === qe || et.pipesCount > 1 && Ze(et.pipes, qe) !== -1) && !Ke && (O("false write response, pause", et.awaitDrain), et.awaitDrain++), Xe.pause());
    }
    function Ye(vt) {
      O("onerror", vt), tt(), qe.removeListener("error", Ye), t(qe, "error") === 0 && Pe(qe, vt);
    }
    ze(qe, "error", Ye);
    function it() {
      qe.removeListener("finish", rt), tt();
    }
    qe.once("close", it);
    function rt() {
      O("onfinish"), qe.removeListener("close", it), tt();
    }
    qe.once("finish", rt);
    function tt() {
      O("unpipe"), Xe.unpipe(qe);
    }
    return qe.emit("pipe", Xe), et.flowing || (O("pipe resume"), Xe.resume()), qe;
  };
  function q(qe) {
    return function() {
      var Oe = qe._readableState;
      O("pipeOnDrain", Oe.awaitDrain), Oe.awaitDrain && Oe.awaitDrain--, Oe.awaitDrain === 0 && t(qe, "data") && (Oe.flowing = !0, Re(qe));
    };
  }
  Ne.prototype.unpipe = function(qe) {
    var Oe = this._readableState, Xe = {
      hasUnpiped: !1
    };
    if (Oe.pipesCount === 0)
      return this;
    if (Oe.pipesCount === 1)
      return qe && qe !== Oe.pipes ? this : (qe || (qe = Oe.pipes), Oe.pipes = null, Oe.pipesCount = 0, Oe.flowing = !1, qe && qe.emit("unpipe", this, Xe), this);
    if (!qe) {
      var et = Oe.pipes, nt = Oe.pipesCount;
      Oe.pipes = null, Oe.pipesCount = 0, Oe.flowing = !1;
      for (var re = 0; re < nt; re++)
        et[re].emit("unpipe", this, {
          hasUnpiped: !1
        });
      return this;
    }
    var oe = Ze(Oe.pipes, qe);
    return oe === -1 ? this : (Oe.pipes.splice(oe, 1), Oe.pipesCount -= 1, Oe.pipesCount === 1 && (Oe.pipes = Oe.pipes[0]), qe.emit("unpipe", this, Xe), this);
  }, Ne.prototype.on = function(qe, Oe) {
    var Xe = h.prototype.on.call(this, qe, Oe), et = this._readableState;
    return qe === "data" ? (et.readableListening = this.listenerCount("readable") > 0, et.flowing !== !1 && this.resume()) : qe === "readable" && !et.endEmitted && !et.readableListening && (et.readableListening = et.needReadable = !0, et.flowing = !1, et.emittedReadable = !1, O("on readable", et.length, et.reading), et.length ? Q(this) : et.reading || Ve.nextTick(me, this)), Xe;
  }, Ne.prototype.addListener = Ne.prototype.on, Ne.prototype.removeListener = function(qe, Oe) {
    var Xe = h.prototype.removeListener.call(this, qe, Oe);
    return qe === "readable" && Ve.nextTick(z, this), Xe;
  }, Ne.prototype.removeAllListeners = function(qe) {
    var Oe = h.prototype.removeAllListeners.apply(this, arguments);
    return (qe === "readable" || qe === void 0) && Ve.nextTick(z, this), Oe;
  };
  function z(qe) {
    var Oe = qe._readableState;
    Oe.readableListening = qe.listenerCount("readable") > 0, Oe.resumeScheduled && !Oe.paused ? Oe.flowing = !0 : qe.listenerCount("data") > 0 && qe.resume();
  }
  function me(qe) {
    O("readable nexttick read 0"), qe.read(0);
  }
  Ne.prototype.resume = function() {
    var qe = this._readableState;
    return qe.flowing || (O("resume"), qe.flowing = !qe.readableListening, Ce(this, qe)), qe.paused = !1, this;
  };
  function Ce(qe, Oe) {
    Oe.resumeScheduled || (Oe.resumeScheduled = !0, Ve.nextTick(je, qe, Oe));
  }
  function je(qe, Oe) {
    O("resume", Oe.reading), Oe.reading || qe.read(0), Oe.resumeScheduled = !1, qe.emit("resume"), Re(qe), Oe.flowing && !Oe.reading && qe.read(0);
  }
  Ne.prototype.pause = function() {
    return O("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (O("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
  };
  function Re(qe) {
    var Oe = qe._readableState;
    for (O("flow", Oe.flowing); Oe.flowing && qe.read() !== null; )
      ;
  }
  Ne.prototype.wrap = function(qe) {
    var Oe = this, Xe = this._readableState, et = !1;
    qe.on("end", function() {
      if (O("wrapped end"), Xe.decoder && !Xe.ended) {
        var oe = Xe.decoder.end();
        oe && oe.length && Oe.push(oe);
      }
      Oe.push(null);
    }), qe.on("data", function(oe) {
      if (O("wrapped data"), Xe.decoder && (oe = Xe.decoder.write(oe)), !(Xe.objectMode && oe == null) && !(!Xe.objectMode && (!oe || !oe.length))) {
        var le = Oe.push(oe);
        le || (et = !0, qe.pause());
      }
    });
    for (var nt in qe)
      this[nt] === void 0 && typeof qe[nt] == "function" && (this[nt] = /* @__PURE__ */ function(oe) {
        return function() {
          return qe[oe].apply(qe, arguments);
        };
      }(nt));
    for (var re = 0; re < Ue.length; re++)
      qe.on(Ue[re], this.emit.bind(this, Ue[re]));
    return this._read = function(oe) {
      O("wrapped _read", oe), et && (et = !1, qe.resume());
    }, this;
  }, typeof Symbol == "function" && (Ne.prototype[Symbol.asyncIterator] = function() {
    return be === void 0 && (be = Xm()), be(this);
  }), Object.defineProperty(Ne.prototype, "readableHighWaterMark", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.highWaterMark;
    }
  }), Object.defineProperty(Ne.prototype, "readableBuffer", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState && this._readableState.buffer;
    }
  }), Object.defineProperty(Ne.prototype, "readableFlowing", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.flowing;
    },
    set: function(qe) {
      this._readableState && (this._readableState.flowing = qe);
    }
  }), Ne._fromList = Ae, Object.defineProperty(Ne.prototype, "readableLength", {
    // making it explicit this property is not enumerable
    // because otherwise some prototype manipulation in
    // userland will fail
    enumerable: !1,
    get: function() {
      return this._readableState.length;
    }
  });
  function Ae(qe, Oe) {
    if (Oe.length === 0)
      return null;
    var Xe;
    return Oe.objectMode ? Xe = Oe.buffer.shift() : !qe || qe >= Oe.length ? (Oe.decoder ? Xe = Oe.buffer.join("") : Oe.buffer.length === 1 ? Xe = Oe.buffer.first() : Xe = Oe.buffer.concat(Oe.length), Oe.buffer.clear()) : Xe = Oe.buffer.consume(qe, Oe.decoder), Xe;
  }
  function ke(qe) {
    var Oe = qe._readableState;
    O("endReadable", Oe.endEmitted), Oe.endEmitted || (Oe.ended = !0, Ve.nextTick(Qe, Oe, qe));
  }
  function Qe(qe, Oe) {
    if (O("endReadableNT", qe.endEmitted, qe.length), !qe.endEmitted && qe.length === 0 && (qe.endEmitted = !0, Oe.readable = !1, Oe.emit("end"), qe.autoDestroy)) {
      var Xe = Oe._writableState;
      (!Xe || Xe.autoDestroy && Xe.finished) && Oe.destroy();
    }
  }
  typeof Symbol == "function" && (Ne.from = function(qe, Oe) {
    return ve === void 0 && (ve = Qm()), ve(Ne, qe, Oe);
  });
  function Ze(qe, Oe) {
    for (var Xe = 0, et = qe.length; Xe < et; Xe++)
      if (qe[Xe] === Oe)
        return Xe;
    return -1;
  }
  return po;
}
var Hc = sn, Zs = ta.codes, Zm = Zs.ERR_METHOD_NOT_IMPLEMENTED, Jm = Zs.ERR_MULTIPLE_CALLBACK, eb = Zs.ERR_TRANSFORM_ALREADY_TRANSFORMING, tb = Zs.ERR_TRANSFORM_WITH_LENGTH_0, Js = Xn();
ut(sn, Js);
function rb(e, t) {
  var h = this._transformState;
  h.transforming = !1;
  var o = h.writecb;
  if (o === null)
    return this.emit("error", new Jm());
  h.writechunk = null, h.writecb = null, t != null && this.push(t), o(e);
  var S = this._readableState;
  S.reading = !1, (S.needReadable || S.length < S.highWaterMark) && this._read(S.highWaterMark);
}
function sn(e) {
  if (!(this instanceof sn))
    return new sn(e);
  Js.call(this, e), this._transformState = {
    afterTransform: rb.bind(this),
    needTransform: !1,
    transforming: !1,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }, this._readableState.needReadable = !0, this._readableState.sync = !1, e && (typeof e.transform == "function" && (this._transform = e.transform), typeof e.flush == "function" && (this._flush = e.flush)), this.on("prefinish", ib);
}
function ib() {
  var e = this;
  typeof this._flush == "function" && !this._readableState.destroyed ? this._flush(function(t, h) {
    bl(e, t, h);
  }) : bl(this, null, null);
}
sn.prototype.push = function(e, t) {
  return this._transformState.needTransform = !1, Js.prototype.push.call(this, e, t);
};
sn.prototype._transform = function(e, t, h) {
  h(new Zm("_transform()"));
};
sn.prototype._write = function(e, t, h) {
  var o = this._transformState;
  if (o.writecb = h, o.writechunk = e, o.writeencoding = t, !o.transforming) {
    var S = this._readableState;
    (o.needTransform || S.needReadable || S.length < S.highWaterMark) && this._read(S.highWaterMark);
  }
};
sn.prototype._read = function(e) {
  var t = this._transformState;
  t.writechunk !== null && !t.transforming ? (t.transforming = !0, this._transform(t.writechunk, t.writeencoding, t.afterTransform)) : t.needTransform = !0;
};
sn.prototype._destroy = function(e, t) {
  Js.prototype._destroy.call(this, e, function(h) {
    t(h);
  });
};
function bl(e, t, h) {
  if (t)
    return e.emit("error", t);
  if (h != null && e.push(h), e._writableState.length)
    throw new tb();
  if (e._transformState.transforming)
    throw new eb();
  return e.push(null);
}
var O1 = C0, P1 = Hc;
ut(C0, P1);
function C0(e) {
  if (!(this instanceof C0))
    return new C0(e);
  P1.call(this, e);
}
C0.prototype._transform = function(e, t, h) {
  h(null, e);
};
var vo;
function nb(e) {
  var t = !1;
  return function() {
    t || (t = !0, e.apply(void 0, arguments));
  };
}
var L1 = ta.codes, ab = L1.ERR_MISSING_ARGS, sb = L1.ERR_STREAM_DESTROYED;
function xl(e) {
  if (e)
    throw e;
}
function fb(e) {
  return e.setHeader && typeof e.abort == "function";
}
function ob(e, t, h, o) {
  o = nb(o);
  var S = !1;
  e.on("close", function() {
    S = !0;
  }), vo === void 0 && (vo = Qs), vo(e, {
    readable: t,
    writable: h
  }, function(B) {
    if (B)
      return o(B);
    S = !0, o();
  });
  var g = !1;
  return function(B) {
    if (!S && !g) {
      if (g = !0, fb(e))
        return e.abort();
      if (typeof e.destroy == "function")
        return e.destroy();
      o(B || new sb("pipe"));
    }
  };
}
function _l(e) {
  e();
}
function ub(e, t) {
  return e.pipe(t);
}
function cb(e) {
  return !e.length || typeof e[e.length - 1] != "function" ? xl : e.pop();
}
function hb() {
  for (var e = arguments.length, t = new Array(e), h = 0; h < e; h++)
    t[h] = arguments[h];
  var o = cb(t);
  if (Array.isArray(t[0]) && (t = t[0]), t.length < 2)
    throw new ab("streams");
  var S, g = t.map(function(B, M) {
    var O = M < t.length - 1, P = M > 0;
    return ob(B, O, P, function(D) {
      S || (S = D), D && g.forEach(_l), !O && (g.forEach(_l), o(S));
    });
  });
  return t.reduce(ub);
}
var k1 = hb;
(function(e, t) {
  t = e.exports = $c(), t.Stream = t, t.Readable = t, t.Writable = Vc(), t.Duplex = Xn(), t.Transform = Hc, t.PassThrough = O1, t.finished = Qs, t.pipeline = k1;
})(Xu, Xu.exports);
var U1 = Xu.exports, Is = ct.Buffer, F1 = U1.Transform, lb = ut;
function db(e, t) {
  if (!Is.isBuffer(e) && typeof e != "string")
    throw new TypeError(t + " must be a string or a buffer");
}
function Tn(e) {
  F1.call(this), this._block = Is.allocUnsafe(e), this._blockSize = e, this._blockOffset = 0, this._length = [0, 0, 0, 0], this._finalized = !1;
}
lb(Tn, F1);
Tn.prototype._transform = function(e, t, h) {
  var o = null;
  try {
    this.update(e, t);
  } catch (S) {
    o = S;
  }
  h(o);
};
Tn.prototype._flush = function(e) {
  var t = null;
  try {
    this.push(this.digest());
  } catch (h) {
    t = h;
  }
  e(t);
};
Tn.prototype.update = function(e, t) {
  if (db(e, "Data"), this._finalized)
    throw new Error("Digest already called");
  Is.isBuffer(e) || (e = Is.from(e, t));
  for (var h = this._block, o = 0; this._blockOffset + e.length - o >= this._blockSize; ) {
    for (var S = this._blockOffset; S < this._blockSize; )
      h[S++] = e[o++];
    this._update(), this._blockOffset = 0;
  }
  for (; o < e.length; )
    h[this._blockOffset++] = e[o++];
  for (var g = 0, B = e.length * 8; B > 0; ++g)
    this._length[g] += B, B = this._length[g] / 4294967296 | 0, B > 0 && (this._length[g] -= 4294967296 * B);
  return this;
};
Tn.prototype._update = function() {
  throw new Error("_update is not implemented");
};
Tn.prototype.digest = function(e) {
  if (this._finalized)
    throw new Error("Digest already called");
  this._finalized = !0;
  var t = this._digest();
  e !== void 0 && (t = t.toString(e)), this._block.fill(0), this._blockOffset = 0;
  for (var h = 0; h < 4; ++h)
    this._length[h] = 0;
  return t;
};
Tn.prototype._digest = function() {
  throw new Error("_digest is not implemented");
};
var q1 = Tn, pb = ut, V1 = q1, vb = ct.Buffer, yb = new Array(16);
function ef() {
  V1.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878;
}
pb(ef, V1);
ef.prototype._update = function() {
  for (var e = yb, t = 0; t < 16; ++t)
    e[t] = this._block.readInt32LE(t * 4);
  var h = this._a, o = this._b, S = this._c, g = this._d;
  h = ur(h, o, S, g, e[0], 3614090360, 7), g = ur(g, h, o, S, e[1], 3905402710, 12), S = ur(S, g, h, o, e[2], 606105819, 17), o = ur(o, S, g, h, e[3], 3250441966, 22), h = ur(h, o, S, g, e[4], 4118548399, 7), g = ur(g, h, o, S, e[5], 1200080426, 12), S = ur(S, g, h, o, e[6], 2821735955, 17), o = ur(o, S, g, h, e[7], 4249261313, 22), h = ur(h, o, S, g, e[8], 1770035416, 7), g = ur(g, h, o, S, e[9], 2336552879, 12), S = ur(S, g, h, o, e[10], 4294925233, 17), o = ur(o, S, g, h, e[11], 2304563134, 22), h = ur(h, o, S, g, e[12], 1804603682, 7), g = ur(g, h, o, S, e[13], 4254626195, 12), S = ur(S, g, h, o, e[14], 2792965006, 17), o = ur(o, S, g, h, e[15], 1236535329, 22), h = cr(h, o, S, g, e[1], 4129170786, 5), g = cr(g, h, o, S, e[6], 3225465664, 9), S = cr(S, g, h, o, e[11], 643717713, 14), o = cr(o, S, g, h, e[0], 3921069994, 20), h = cr(h, o, S, g, e[5], 3593408605, 5), g = cr(g, h, o, S, e[10], 38016083, 9), S = cr(S, g, h, o, e[15], 3634488961, 14), o = cr(o, S, g, h, e[4], 3889429448, 20), h = cr(h, o, S, g, e[9], 568446438, 5), g = cr(g, h, o, S, e[14], 3275163606, 9), S = cr(S, g, h, o, e[3], 4107603335, 14), o = cr(o, S, g, h, e[8], 1163531501, 20), h = cr(h, o, S, g, e[13], 2850285829, 5), g = cr(g, h, o, S, e[2], 4243563512, 9), S = cr(S, g, h, o, e[7], 1735328473, 14), o = cr(o, S, g, h, e[12], 2368359562, 20), h = hr(h, o, S, g, e[5], 4294588738, 4), g = hr(g, h, o, S, e[8], 2272392833, 11), S = hr(S, g, h, o, e[11], 1839030562, 16), o = hr(o, S, g, h, e[14], 4259657740, 23), h = hr(h, o, S, g, e[1], 2763975236, 4), g = hr(g, h, o, S, e[4], 1272893353, 11), S = hr(S, g, h, o, e[7], 4139469664, 16), o = hr(o, S, g, h, e[10], 3200236656, 23), h = hr(h, o, S, g, e[13], 681279174, 4), g = hr(g, h, o, S, e[0], 3936430074, 11), S = hr(S, g, h, o, e[3], 3572445317, 16), o = hr(o, S, g, h, e[6], 76029189, 23), h = hr(h, o, S, g, e[9], 3654602809, 4), g = hr(g, h, o, S, e[12], 3873151461, 11), S = hr(S, g, h, o, e[15], 530742520, 16), o = hr(o, S, g, h, e[2], 3299628645, 23), h = lr(h, o, S, g, e[0], 4096336452, 6), g = lr(g, h, o, S, e[7], 1126891415, 10), S = lr(S, g, h, o, e[14], 2878612391, 15), o = lr(o, S, g, h, e[5], 4237533241, 21), h = lr(h, o, S, g, e[12], 1700485571, 6), g = lr(g, h, o, S, e[3], 2399980690, 10), S = lr(S, g, h, o, e[10], 4293915773, 15), o = lr(o, S, g, h, e[1], 2240044497, 21), h = lr(h, o, S, g, e[8], 1873313359, 6), g = lr(g, h, o, S, e[15], 4264355552, 10), S = lr(S, g, h, o, e[6], 2734768916, 15), o = lr(o, S, g, h, e[13], 1309151649, 21), h = lr(h, o, S, g, e[4], 4149444226, 6), g = lr(g, h, o, S, e[11], 3174756917, 10), S = lr(S, g, h, o, e[2], 718787259, 15), o = lr(o, S, g, h, e[9], 3951481745, 21), this._a = this._a + h | 0, this._b = this._b + o | 0, this._c = this._c + S | 0, this._d = this._d + g | 0;
};
ef.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var e = vb.allocUnsafe(16);
  return e.writeInt32LE(this._a, 0), e.writeInt32LE(this._b, 4), e.writeInt32LE(this._c, 8), e.writeInt32LE(this._d, 12), e;
};
function tf(e, t) {
  return e << t | e >>> 32 - t;
}
function ur(e, t, h, o, S, g, B) {
  return tf(e + (t & h | ~t & o) + S + g | 0, B) + t | 0;
}
function cr(e, t, h, o, S, g, B) {
  return tf(e + (t & o | h & ~o) + S + g | 0, B) + t | 0;
}
function hr(e, t, h, o, S, g, B) {
  return tf(e + (t ^ h ^ o) + S + g | 0, B) + t | 0;
}
function lr(e, t, h, o, S, g, B) {
  return tf(e + (h ^ (t | ~o)) + S + g | 0, B) + t | 0;
}
var Gc = ef, yo = pe.Buffer, gb = ut, K1 = q1, mb = new Array(16), i0 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], n0 = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], a0 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], s0 = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], f0 = [0, 1518500249, 1859775393, 2400959708, 2840853838], o0 = [1352829926, 1548603684, 1836072691, 2053994217, 0];
function rf() {
  K1.call(this, 64), this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520;
}
gb(rf, K1);
rf.prototype._update = function() {
  for (var e = mb, t = 0; t < 16; ++t)
    e[t] = this._block.readInt32LE(t * 4);
  for (var h = this._a | 0, o = this._b | 0, S = this._c | 0, g = this._d | 0, B = this._e | 0, M = this._a | 0, O = this._b | 0, P = this._c | 0, D = this._d | 0, Z = this._e | 0, Y = 0; Y < 80; Y += 1) {
    var ee, ie;
    Y < 16 ? (ee = El(h, o, S, g, B, e[i0[Y]], f0[0], a0[Y]), ie = Al(M, O, P, D, Z, e[n0[Y]], o0[0], s0[Y])) : Y < 32 ? (ee = Sl(h, o, S, g, B, e[i0[Y]], f0[1], a0[Y]), ie = Cl(M, O, P, D, Z, e[n0[Y]], o0[1], s0[Y])) : Y < 48 ? (ee = wl(h, o, S, g, B, e[i0[Y]], f0[2], a0[Y]), ie = wl(M, O, P, D, Z, e[n0[Y]], o0[2], s0[Y])) : Y < 64 ? (ee = Cl(h, o, S, g, B, e[i0[Y]], f0[3], a0[Y]), ie = Sl(M, O, P, D, Z, e[n0[Y]], o0[3], s0[Y])) : (ee = Al(h, o, S, g, B, e[i0[Y]], f0[4], a0[Y]), ie = El(M, O, P, D, Z, e[n0[Y]], o0[4], s0[Y])), h = B, B = g, g = Qn(S, 10), S = o, o = ee, M = Z, Z = D, D = Qn(P, 10), P = O, O = ie;
  }
  var ue = this._b + S + D | 0;
  this._b = this._c + g + Z | 0, this._c = this._d + B + M | 0, this._d = this._e + h + O | 0, this._e = this._a + o + P | 0, this._a = ue;
};
rf.prototype._digest = function() {
  this._block[this._blockOffset++] = 128, this._blockOffset > 56 && (this._block.fill(0, this._blockOffset, 64), this._update(), this._blockOffset = 0), this._block.fill(0, this._blockOffset, 56), this._block.writeUInt32LE(this._length[0], 56), this._block.writeUInt32LE(this._length[1], 60), this._update();
  var e = yo.alloc ? yo.alloc(20) : new yo(20);
  return e.writeInt32LE(this._a, 0), e.writeInt32LE(this._b, 4), e.writeInt32LE(this._c, 8), e.writeInt32LE(this._d, 12), e.writeInt32LE(this._e, 16), e;
};
function Qn(e, t) {
  return e << t | e >>> 32 - t;
}
function El(e, t, h, o, S, g, B, M) {
  return Qn(e + (t ^ h ^ o) + g + B | 0, M) + S | 0;
}
function Sl(e, t, h, o, S, g, B, M) {
  return Qn(e + (t & h | ~t & o) + g + B | 0, M) + S | 0;
}
function wl(e, t, h, o, S, g, B, M) {
  return Qn(e + ((t | ~h) ^ o) + g + B | 0, M) + S | 0;
}
function Cl(e, t, h, o, S, g, B, M) {
  return Qn(e + (t & o | h & ~o) + g + B | 0, M) + S | 0;
}
function Al(e, t, h, o, S, g, B, M) {
  return Qn(e + (t ^ (h | ~o)) + g + B | 0, M) + S | 0;
}
var zc = rf, $1 = { exports: {} }, H1 = ct.Buffer;
function nf(e, t) {
  this._block = H1.alloc(e), this._finalSize = t, this._blockSize = e, this._len = 0;
}
nf.prototype.update = function(e, t) {
  typeof e == "string" && (t = t || "utf8", e = H1.from(e, t));
  for (var h = this._block, o = this._blockSize, S = e.length, g = this._len, B = 0; B < S; ) {
    for (var M = g % o, O = Math.min(S - B, o - M), P = 0; P < O; P++)
      h[M + P] = e[B + P];
    g += O, B += O, g % o === 0 && this._update(h);
  }
  return this._len += S, this;
};
nf.prototype.digest = function(e) {
  var t = this._len % this._blockSize;
  this._block[t] = 128, this._block.fill(0, t + 1), t >= this._finalSize && (this._update(this._block), this._block.fill(0));
  var h = this._len * 8;
  if (h <= 4294967295)
    this._block.writeUInt32BE(h, this._blockSize - 4);
  else {
    var o = (h & 4294967295) >>> 0, S = (h - o) / 4294967296;
    this._block.writeUInt32BE(S, this._blockSize - 8), this._block.writeUInt32BE(o, this._blockSize - 4);
  }
  this._update(this._block);
  var g = this._hash();
  return e ? g.toString(e) : g;
};
nf.prototype._update = function() {
  throw new Error("_update must be implemented by subclass");
};
var Fa = nf, bb = ut, G1 = Fa, xb = ct.Buffer, _b = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], Eb = new Array(80);
function R0() {
  this.init(), this._w = Eb, G1.call(this, 64, 56);
}
bb(R0, G1);
R0.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function Sb(e) {
  return e << 5 | e >>> 27;
}
function wb(e) {
  return e << 30 | e >>> 2;
}
function Cb(e, t, h, o) {
  return e === 0 ? t & h | ~t & o : e === 2 ? t & h | t & o | h & o : t ^ h ^ o;
}
R0.prototype._update = function(e) {
  for (var t = this._w, h = this._a | 0, o = this._b | 0, S = this._c | 0, g = this._d | 0, B = this._e | 0, M = 0; M < 16; ++M)
    t[M] = e.readInt32BE(M * 4);
  for (; M < 80; ++M)
    t[M] = t[M - 3] ^ t[M - 8] ^ t[M - 14] ^ t[M - 16];
  for (var O = 0; O < 80; ++O) {
    var P = ~~(O / 20), D = Sb(h) + Cb(P, o, S, g) + B + t[O] + _b[P] | 0;
    B = g, g = S, S = wb(o), o = h, h = D;
  }
  this._a = h + this._a | 0, this._b = o + this._b | 0, this._c = S + this._c | 0, this._d = g + this._d | 0, this._e = B + this._e | 0;
};
R0.prototype._hash = function() {
  var e = xb.allocUnsafe(20);
  return e.writeInt32BE(this._a | 0, 0), e.writeInt32BE(this._b | 0, 4), e.writeInt32BE(this._c | 0, 8), e.writeInt32BE(this._d | 0, 12), e.writeInt32BE(this._e | 0, 16), e;
};
var Ab = R0, Bb = ut, z1 = Fa, Ib = ct.Buffer, Tb = [
  1518500249,
  1859775393,
  -1894007588,
  -899497514
], Mb = new Array(80);
function N0() {
  this.init(), this._w = Mb, z1.call(this, 64, 56);
}
Bb(N0, z1);
N0.prototype.init = function() {
  return this._a = 1732584193, this._b = 4023233417, this._c = 2562383102, this._d = 271733878, this._e = 3285377520, this;
};
function Rb(e) {
  return e << 1 | e >>> 31;
}
function Nb(e) {
  return e << 5 | e >>> 27;
}
function Db(e) {
  return e << 30 | e >>> 2;
}
function Ob(e, t, h, o) {
  return e === 0 ? t & h | ~t & o : e === 2 ? t & h | t & o | h & o : t ^ h ^ o;
}
N0.prototype._update = function(e) {
  for (var t = this._w, h = this._a | 0, o = this._b | 0, S = this._c | 0, g = this._d | 0, B = this._e | 0, M = 0; M < 16; ++M)
    t[M] = e.readInt32BE(M * 4);
  for (; M < 80; ++M)
    t[M] = Rb(t[M - 3] ^ t[M - 8] ^ t[M - 14] ^ t[M - 16]);
  for (var O = 0; O < 80; ++O) {
    var P = ~~(O / 20), D = Nb(h) + Ob(P, o, S, g) + B + t[O] + Tb[P] | 0;
    B = g, g = S, S = Db(o), o = h, h = D;
  }
  this._a = h + this._a | 0, this._b = o + this._b | 0, this._c = S + this._c | 0, this._d = g + this._d | 0, this._e = B + this._e | 0;
};
N0.prototype._hash = function() {
  var e = Ib.allocUnsafe(20);
  return e.writeInt32BE(this._a | 0, 0), e.writeInt32BE(this._b | 0, 4), e.writeInt32BE(this._c | 0, 8), e.writeInt32BE(this._d | 0, 12), e.writeInt32BE(this._e | 0, 16), e;
};
var Pb = N0, Lb = ut, j1 = Fa, kb = ct.Buffer, Ub = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
], Fb = new Array(64);
function D0() {
  this.init(), this._w = Fb, j1.call(this, 64, 56);
}
Lb(D0, j1);
D0.prototype.init = function() {
  return this._a = 1779033703, this._b = 3144134277, this._c = 1013904242, this._d = 2773480762, this._e = 1359893119, this._f = 2600822924, this._g = 528734635, this._h = 1541459225, this;
};
function qb(e, t, h) {
  return h ^ e & (t ^ h);
}
function Vb(e, t, h) {
  return e & t | h & (e | t);
}
function Kb(e) {
  return (e >>> 2 | e << 30) ^ (e >>> 13 | e << 19) ^ (e >>> 22 | e << 10);
}
function $b(e) {
  return (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
}
function Hb(e) {
  return (e >>> 7 | e << 25) ^ (e >>> 18 | e << 14) ^ e >>> 3;
}
function Gb(e) {
  return (e >>> 17 | e << 15) ^ (e >>> 19 | e << 13) ^ e >>> 10;
}
D0.prototype._update = function(e) {
  for (var t = this._w, h = this._a | 0, o = this._b | 0, S = this._c | 0, g = this._d | 0, B = this._e | 0, M = this._f | 0, O = this._g | 0, P = this._h | 0, D = 0; D < 16; ++D)
    t[D] = e.readInt32BE(D * 4);
  for (; D < 64; ++D)
    t[D] = Gb(t[D - 2]) + t[D - 7] + Hb(t[D - 15]) + t[D - 16] | 0;
  for (var Z = 0; Z < 64; ++Z) {
    var Y = P + $b(B) + qb(B, M, O) + Ub[Z] + t[Z] | 0, ee = Kb(h) + Vb(h, o, S) | 0;
    P = O, O = M, M = B, B = g + Y | 0, g = S, S = o, o = h, h = Y + ee | 0;
  }
  this._a = h + this._a | 0, this._b = o + this._b | 0, this._c = S + this._c | 0, this._d = g + this._d | 0, this._e = B + this._e | 0, this._f = M + this._f | 0, this._g = O + this._g | 0, this._h = P + this._h | 0;
};
D0.prototype._hash = function() {
  var e = kb.allocUnsafe(32);
  return e.writeInt32BE(this._a, 0), e.writeInt32BE(this._b, 4), e.writeInt32BE(this._c, 8), e.writeInt32BE(this._d, 12), e.writeInt32BE(this._e, 16), e.writeInt32BE(this._f, 20), e.writeInt32BE(this._g, 24), e.writeInt32BE(this._h, 28), e;
};
var W1 = D0, zb = ut, jb = W1, Wb = Fa, Yb = ct.Buffer, Xb = new Array(64);
function af() {
  this.init(), this._w = Xb, Wb.call(this, 64, 56);
}
zb(af, jb);
af.prototype.init = function() {
  return this._a = 3238371032, this._b = 914150663, this._c = 812702999, this._d = 4144912697, this._e = 4290775857, this._f = 1750603025, this._g = 1694076839, this._h = 3204075428, this;
};
af.prototype._hash = function() {
  var e = Yb.allocUnsafe(28);
  return e.writeInt32BE(this._a, 0), e.writeInt32BE(this._b, 4), e.writeInt32BE(this._c, 8), e.writeInt32BE(this._d, 12), e.writeInt32BE(this._e, 16), e.writeInt32BE(this._f, 20), e.writeInt32BE(this._g, 24), e;
};
var Qb = af, Zb = ut, Y1 = Fa, Jb = ct.Buffer, Bl = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
], ex = new Array(160);
function O0() {
  this.init(), this._w = ex, Y1.call(this, 128, 112);
}
Zb(O0, Y1);
O0.prototype.init = function() {
  return this._ah = 1779033703, this._bh = 3144134277, this._ch = 1013904242, this._dh = 2773480762, this._eh = 1359893119, this._fh = 2600822924, this._gh = 528734635, this._hh = 1541459225, this._al = 4089235720, this._bl = 2227873595, this._cl = 4271175723, this._dl = 1595750129, this._el = 2917565137, this._fl = 725511199, this._gl = 4215389547, this._hl = 327033209, this;
};
function Il(e, t, h) {
  return h ^ e & (t ^ h);
}
function Tl(e, t, h) {
  return e & t | h & (e | t);
}
function Ml(e, t) {
  return (e >>> 28 | t << 4) ^ (t >>> 2 | e << 30) ^ (t >>> 7 | e << 25);
}
function Rl(e, t) {
  return (e >>> 14 | t << 18) ^ (e >>> 18 | t << 14) ^ (t >>> 9 | e << 23);
}
function tx(e, t) {
  return (e >>> 1 | t << 31) ^ (e >>> 8 | t << 24) ^ e >>> 7;
}
function rx(e, t) {
  return (e >>> 1 | t << 31) ^ (e >>> 8 | t << 24) ^ (e >>> 7 | t << 25);
}
function ix(e, t) {
  return (e >>> 19 | t << 13) ^ (t >>> 29 | e << 3) ^ e >>> 6;
}
function nx(e, t) {
  return (e >>> 19 | t << 13) ^ (t >>> 29 | e << 3) ^ (e >>> 6 | t << 26);
}
function Wt(e, t) {
  return e >>> 0 < t >>> 0 ? 1 : 0;
}
O0.prototype._update = function(e) {
  for (var t = this._w, h = this._ah | 0, o = this._bh | 0, S = this._ch | 0, g = this._dh | 0, B = this._eh | 0, M = this._fh | 0, O = this._gh | 0, P = this._hh | 0, D = this._al | 0, Z = this._bl | 0, Y = this._cl | 0, ee = this._dl | 0, ie = this._el | 0, ue = this._fl | 0, fe = this._gl | 0, de = this._hl | 0, ce = 0; ce < 32; ce += 2)
    t[ce] = e.readInt32BE(ce * 4), t[ce + 1] = e.readInt32BE(ce * 4 + 4);
  for (; ce < 160; ce += 2) {
    var be = t[ce - 30], ve = t[ce - 15 * 2 + 1], Pe = tx(be, ve), Ue = rx(ve, be);
    be = t[ce - 2 * 2], ve = t[ce - 2 * 2 + 1];
    var ze = ix(be, ve), Le = nx(ve, be), Ne = t[ce - 7 * 2], $e = t[ce - 7 * 2 + 1], J = t[ce - 16 * 2], ne = t[ce - 16 * 2 + 1], A = Ue + $e | 0, I = Pe + Ne + Wt(A, Ue) | 0;
    A = A + Le | 0, I = I + ze + Wt(A, Le) | 0, A = A + ne | 0, I = I + J + Wt(A, ne) | 0, t[ce] = I, t[ce + 1] = A;
  }
  for (var U = 0; U < 160; U += 2) {
    I = t[U], A = t[U + 1];
    var X = Tl(h, o, S), Q = Tl(D, Z, Y), F = Ml(h, D), $ = Ml(D, h), H = Rl(B, ie), q = Rl(ie, B), z = Bl[U], me = Bl[U + 1], Ce = Il(B, M, O), je = Il(ie, ue, fe), Re = de + q | 0, Ae = P + H + Wt(Re, de) | 0;
    Re = Re + je | 0, Ae = Ae + Ce + Wt(Re, je) | 0, Re = Re + me | 0, Ae = Ae + z + Wt(Re, me) | 0, Re = Re + A | 0, Ae = Ae + I + Wt(Re, A) | 0;
    var ke = $ + Q | 0, Qe = F + X + Wt(ke, $) | 0;
    P = O, de = fe, O = M, fe = ue, M = B, ue = ie, ie = ee + Re | 0, B = g + Ae + Wt(ie, ee) | 0, g = S, ee = Y, S = o, Y = Z, o = h, Z = D, D = Re + ke | 0, h = Ae + Qe + Wt(D, Re) | 0;
  }
  this._al = this._al + D | 0, this._bl = this._bl + Z | 0, this._cl = this._cl + Y | 0, this._dl = this._dl + ee | 0, this._el = this._el + ie | 0, this._fl = this._fl + ue | 0, this._gl = this._gl + fe | 0, this._hl = this._hl + de | 0, this._ah = this._ah + h + Wt(this._al, D) | 0, this._bh = this._bh + o + Wt(this._bl, Z) | 0, this._ch = this._ch + S + Wt(this._cl, Y) | 0, this._dh = this._dh + g + Wt(this._dl, ee) | 0, this._eh = this._eh + B + Wt(this._el, ie) | 0, this._fh = this._fh + M + Wt(this._fl, ue) | 0, this._gh = this._gh + O + Wt(this._gl, fe) | 0, this._hh = this._hh + P + Wt(this._hl, de) | 0;
};
O0.prototype._hash = function() {
  var e = Jb.allocUnsafe(64);
  function t(h, o, S) {
    e.writeInt32BE(h, S), e.writeInt32BE(o, S + 4);
  }
  return t(this._ah, this._al, 0), t(this._bh, this._bl, 8), t(this._ch, this._cl, 16), t(this._dh, this._dl, 24), t(this._eh, this._el, 32), t(this._fh, this._fl, 40), t(this._gh, this._gl, 48), t(this._hh, this._hl, 56), e;
};
var X1 = O0, ax = ut, sx = X1, fx = Fa, ox = ct.Buffer, ux = new Array(160);
function sf() {
  this.init(), this._w = ux, fx.call(this, 128, 112);
}
ax(sf, sx);
sf.prototype.init = function() {
  return this._ah = 3418070365, this._bh = 1654270250, this._ch = 2438529370, this._dh = 355462360, this._eh = 1731405415, this._fh = 2394180231, this._gh = 3675008525, this._hh = 1203062813, this._al = 3238371032, this._bl = 914150663, this._cl = 812702999, this._dl = 4144912697, this._el = 4290775857, this._fl = 1750603025, this._gl = 1694076839, this._hl = 3204075428, this;
};
sf.prototype._hash = function() {
  var e = ox.allocUnsafe(48);
  function t(h, o, S) {
    e.writeInt32BE(h, S), e.writeInt32BE(o, S + 4);
  }
  return t(this._ah, this._al, 0), t(this._bh, this._bl, 8), t(this._ch, this._cl, 16), t(this._dh, this._dl, 24), t(this._eh, this._el, 32), t(this._fh, this._fl, 40), e;
};
var cx = sf, ra = $1.exports = function(e) {
  e = e.toLowerCase();
  var t = ra[e];
  if (!t)
    throw new Error(e + " is not supported (we accept pull requests)");
  return new t();
};
ra.sha = Ab;
ra.sha1 = Pb;
ra.sha224 = Qb;
ra.sha256 = W1;
ra.sha384 = cx;
ra.sha512 = X1;
var jc = $1.exports, hx = jr, Wc = Lc.EventEmitter, lx = ut;
lx(jr, Wc);
jr.Readable = $c();
jr.Writable = Vc();
jr.Duplex = Xn();
jr.Transform = Hc;
jr.PassThrough = O1;
jr.finished = Qs;
jr.pipeline = k1;
jr.Stream = jr;
function jr() {
  Wc.call(this);
}
jr.prototype.pipe = function(e, t) {
  var h = this;
  function o(D) {
    e.writable && e.write(D) === !1 && h.pause && h.pause();
  }
  h.on("data", o);
  function S() {
    h.readable && h.resume && h.resume();
  }
  e.on("drain", S), !e._isStdio && (!t || t.end !== !1) && (h.on("end", B), h.on("close", M));
  var g = !1;
  function B() {
    g || (g = !0, e.end());
  }
  function M() {
    g || (g = !0, typeof e.destroy == "function" && e.destroy());
  }
  function O(D) {
    if (P(), Wc.listenerCount(this, "error") === 0)
      throw D;
  }
  h.on("error", O), e.on("error", O);
  function P() {
    h.removeListener("data", o), e.removeListener("drain", S), h.removeListener("end", B), h.removeListener("close", M), h.removeListener("error", O), e.removeListener("error", O), h.removeListener("end", P), h.removeListener("close", P), e.removeListener("close", P);
  }
  return h.on("end", P), h.on("close", P), e.on("close", P), e.emit("pipe", h), e;
};
var Q1 = ct.Buffer, Z1 = hx.Transform, dx = Bs.StringDecoder, px = ut;
function Ci(e) {
  Z1.call(this), this.hashMode = typeof e == "string", this.hashMode ? this[e] = this._finalOrDigest : this.final = this._finalOrDigest, this._final && (this.__final = this._final, this._final = null), this._decoder = null, this._encoding = null;
}
px(Ci, Z1);
Ci.prototype.update = function(e, t, h) {
  typeof e == "string" && (e = Q1.from(e, t));
  var o = this._update(e);
  return this.hashMode ? this : (h && (o = this._toString(o, h)), o);
};
Ci.prototype.setAutoPadding = function() {
};
Ci.prototype.getAuthTag = function() {
  throw new Error("trying to get auth tag in unsupported state");
};
Ci.prototype.setAuthTag = function() {
  throw new Error("trying to set auth tag in unsupported state");
};
Ci.prototype.setAAD = function() {
  throw new Error("trying to set aad in unsupported state");
};
Ci.prototype._transform = function(e, t, h) {
  var o;
  try {
    this.hashMode ? this._update(e) : this.push(this._update(e));
  } catch (S) {
    o = S;
  } finally {
    h(o);
  }
};
Ci.prototype._flush = function(e) {
  var t;
  try {
    this.push(this.__final());
  } catch (h) {
    t = h;
  }
  e(t);
};
Ci.prototype._finalOrDigest = function(e) {
  var t = this.__final() || Q1.alloc(0);
  return e && (t = this._toString(t, e, !0)), t;
};
Ci.prototype._toString = function(e, t, h) {
  if (this._decoder || (this._decoder = new dx(t), this._encoding = t), this._encoding !== t)
    throw new Error("can't switch encodings");
  var o = this._decoder.write(e);
  return h && (o += this._decoder.end()), o;
};
var Mn = Ci, vx = ut, yx = Gc, gx = zc, mx = jc, J1 = Mn;
function ff(e) {
  J1.call(this, "digest"), this._hash = e;
}
vx(ff, J1);
ff.prototype._update = function(e) {
  this._hash.update(e);
};
ff.prototype._final = function() {
  return this._hash.digest();
};
var P0 = function(e) {
  return e = e.toLowerCase(), e === "md5" ? new yx() : e === "rmd160" || e === "ripemd160" ? new gx() : new ff(mx(e));
}, bx = ut, Gn = ct.Buffer, ev = Mn, xx = Gn.alloc(128), ha = 64;
function of(e, t) {
  ev.call(this, "digest"), typeof t == "string" && (t = Gn.from(t)), this._alg = e, this._key = t, t.length > ha ? t = e(t) : t.length < ha && (t = Gn.concat([t, xx], ha));
  for (var h = this._ipad = Gn.allocUnsafe(ha), o = this._opad = Gn.allocUnsafe(ha), S = 0; S < ha; S++)
    h[S] = t[S] ^ 54, o[S] = t[S] ^ 92;
  this._hash = [h];
}
bx(of, ev);
of.prototype._update = function(e) {
  this._hash.push(e);
};
of.prototype._final = function() {
  var e = this._alg(Gn.concat(this._hash));
  return this._alg(Gn.concat([this._opad, e]));
};
var _x = of, Ex = Gc, tv = function(e) {
  return new Ex().update(e).digest();
}, Sx = ut, wx = _x, rv = Mn, y0 = ct.Buffer, Cx = tv, ic = zc, nc = jc, Ax = y0.alloc(128);
function A0(e, t) {
  rv.call(this, "digest"), typeof t == "string" && (t = y0.from(t));
  var h = e === "sha512" || e === "sha384" ? 128 : 64;
  if (this._alg = e, this._key = t, t.length > h) {
    var o = e === "rmd160" ? new ic() : nc(e);
    t = o.update(t).digest();
  } else
    t.length < h && (t = y0.concat([t, Ax], h));
  for (var S = this._ipad = y0.allocUnsafe(h), g = this._opad = y0.allocUnsafe(h), B = 0; B < h; B++)
    S[B] = t[B] ^ 54, g[B] = t[B] ^ 92;
  this._hash = e === "rmd160" ? new ic() : nc(e), this._hash.update(S);
}
Sx(A0, rv);
A0.prototype._update = function(e) {
  this._hash.update(e);
};
A0.prototype._final = function() {
  var e = this._hash.digest(), t = this._alg === "rmd160" ? new ic() : nc(this._alg);
  return t.update(this._opad).update(e).digest();
};
var iv = function(e, t) {
  return e = e.toLowerCase(), e === "rmd160" || e === "ripemd160" ? new A0("rmd160", t) : e === "md5" ? new wx(Cx, t) : new A0(e, t);
};
const Bx = {
  sign: "rsa",
  hash: "sha224",
  id: "302d300d06096086480165030402040500041c"
}, Ix = {
  sign: "rsa",
  hash: "sha256",
  id: "3031300d060960864801650304020105000420"
}, Tx = {
  sign: "rsa",
  hash: "sha384",
  id: "3041300d060960864801650304020205000430"
}, Mx = {
  sign: "rsa",
  hash: "sha512",
  id: "3051300d060960864801650304020305000440"
}, Rx = {
  sign: "ecdsa",
  hash: "sha256",
  id: ""
}, Nx = {
  sign: "ecdsa",
  hash: "sha224",
  id: ""
}, Dx = {
  sign: "ecdsa",
  hash: "sha384",
  id: ""
}, Ox = {
  sign: "ecdsa",
  hash: "sha512",
  id: ""
}, Px = {
  sign: "dsa",
  hash: "sha1",
  id: ""
}, Lx = {
  sign: "rsa",
  hash: "rmd160",
  id: "3021300906052b2403020105000414"
}, kx = {
  sign: "rsa",
  hash: "md5",
  id: "3020300c06082a864886f70d020505000410"
}, nv = {
  sha224WithRSAEncryption: Bx,
  "RSA-SHA224": {
    sign: "ecdsa/rsa",
    hash: "sha224",
    id: "302d300d06096086480165030402040500041c"
  },
  sha256WithRSAEncryption: Ix,
  "RSA-SHA256": {
    sign: "ecdsa/rsa",
    hash: "sha256",
    id: "3031300d060960864801650304020105000420"
  },
  sha384WithRSAEncryption: Tx,
  "RSA-SHA384": {
    sign: "ecdsa/rsa",
    hash: "sha384",
    id: "3041300d060960864801650304020205000430"
  },
  sha512WithRSAEncryption: Mx,
  "RSA-SHA512": {
    sign: "ecdsa/rsa",
    hash: "sha512",
    id: "3051300d060960864801650304020305000440"
  },
  "RSA-SHA1": {
    sign: "rsa",
    hash: "sha1",
    id: "3021300906052b0e03021a05000414"
  },
  "ecdsa-with-SHA1": {
    sign: "ecdsa",
    hash: "sha1",
    id: ""
  },
  sha256: Rx,
  sha224: Nx,
  sha384: Dx,
  sha512: Ox,
  "DSA-SHA": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  "DSA-SHA1": {
    sign: "dsa",
    hash: "sha1",
    id: ""
  },
  DSA: Px,
  "DSA-WITH-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-SHA224": {
    sign: "dsa",
    hash: "sha224",
    id: ""
  },
  "DSA-WITH-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-SHA256": {
    sign: "dsa",
    hash: "sha256",
    id: ""
  },
  "DSA-WITH-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-SHA384": {
    sign: "dsa",
    hash: "sha384",
    id: ""
  },
  "DSA-WITH-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-SHA512": {
    sign: "dsa",
    hash: "sha512",
    id: ""
  },
  "DSA-RIPEMD160": {
    sign: "dsa",
    hash: "rmd160",
    id: ""
  },
  ripemd160WithRSA: Lx,
  "RSA-RIPEMD160": {
    sign: "rsa",
    hash: "rmd160",
    id: "3021300906052b2403020105000414"
  },
  md5WithRSAEncryption: kx,
  "RSA-MD5": {
    sign: "rsa",
    hash: "md5",
    id: "3020300c06082a864886f70d020505000410"
  }
};
var Ux = nv, uf = {}, Fx = Math.pow(2, 30) - 1, av = function(e, t) {
  if (typeof e != "number")
    throw new TypeError("Iterations not a number");
  if (e < 0)
    throw new TypeError("Bad iterations");
  if (typeof t != "number")
    throw new TypeError("Key length not a number");
  if (t < 0 || t > Fx || t !== t)
    throw new TypeError("Bad key length");
}, ys;
if (Me.process && Me.process.browser)
  ys = "utf-8";
else if (Me.process && Me.process.version) {
  var qx = parseInt(Ve.version.split(".")[0].slice(1), 10);
  ys = qx >= 6 ? "utf-8" : "binary";
} else
  ys = "utf-8";
var sv = ys, go = ct.Buffer, fv = function(e, t, h) {
  if (go.isBuffer(e))
    return e;
  if (typeof e == "string")
    return go.from(e, t);
  if (ArrayBuffer.isView(e))
    return go.from(e.buffer);
  throw new TypeError(h + " must be a string, a Buffer, a typed array or a DataView");
}, Vx = tv, Kx = zc, $x = jc, zn = ct.Buffer, Hx = av, Nl = sv, Dl = fv, Gx = zn.alloc(128), gs = {
  md5: 16,
  sha1: 20,
  sha224: 28,
  sha256: 32,
  sha384: 48,
  sha512: 64,
  rmd160: 20,
  ripemd160: 20
};
function ov(e, t, h) {
  var o = zx(e), S = e === "sha512" || e === "sha384" ? 128 : 64;
  t.length > S ? t = o(t) : t.length < S && (t = zn.concat([t, Gx], S));
  for (var g = zn.allocUnsafe(S + gs[e]), B = zn.allocUnsafe(S + gs[e]), M = 0; M < S; M++)
    g[M] = t[M] ^ 54, B[M] = t[M] ^ 92;
  var O = zn.allocUnsafe(S + h + 4);
  g.copy(O, 0, 0, S), this.ipad1 = O, this.ipad2 = g, this.opad = B, this.alg = e, this.blocksize = S, this.hash = o, this.size = gs[e];
}
ov.prototype.run = function(e, t) {
  e.copy(t, this.blocksize);
  var h = this.hash(t);
  return h.copy(this.opad, this.blocksize), this.hash(this.opad);
};
function zx(e) {
  function t(o) {
    return $x(e).update(o).digest();
  }
  function h(o) {
    return new Kx().update(o).digest();
  }
  return e === "rmd160" || e === "ripemd160" ? h : e === "md5" ? Vx : t;
}
function jx(e, t, h, o, S) {
  Hx(h, o), e = Dl(e, Nl, "Password"), t = Dl(t, Nl, "Salt"), S = S || "sha1";
  var g = new ov(S, e, t.length), B = zn.allocUnsafe(o), M = zn.allocUnsafe(t.length + 4);
  t.copy(M, 0, 0, t.length);
  for (var O = 0, P = gs[S], D = Math.ceil(o / P), Z = 1; Z <= D; Z++) {
    M.writeUInt32BE(Z, t.length);
    for (var Y = g.run(M, g.ipad1), ee = Y, ie = 1; ie < h; ie++) {
      ee = g.run(ee, g.ipad2);
      for (var ue = 0; ue < P; ue++)
        Y[ue] ^= ee[ue];
    }
    Y.copy(B, O), O += P;
  }
  return B;
}
var uv = jx, cv = ct.Buffer, Wx = av, Ol = sv, Pl = uv, Ll = fv, X0, _0 = Me.crypto && Me.crypto.subtle, Yx = {
  sha: "SHA-1",
  "sha-1": "SHA-1",
  sha1: "SHA-1",
  sha256: "SHA-256",
  "sha-256": "SHA-256",
  sha384: "SHA-384",
  "sha-384": "SHA-384",
  "sha-512": "SHA-512",
  sha512: "SHA-512"
}, mo = [];
function Xx(e) {
  if (Me.process && !Me.process.browser || !_0 || !_0.importKey || !_0.deriveBits)
    return Promise.resolve(!1);
  if (mo[e] !== void 0)
    return mo[e];
  X0 = X0 || cv.alloc(8);
  var t = hv(X0, X0, 10, 128, e).then(function() {
    return !0;
  }).catch(function() {
    return !1;
  });
  return mo[e] = t, t;
}
var On;
function ac() {
  return On || (Me.process && Me.process.nextTick ? On = Me.process.nextTick : Me.queueMicrotask ? On = Me.queueMicrotask : Me.setImmediate ? On = Me.setImmediate : On = Me.setTimeout, On);
}
function hv(e, t, h, o, S) {
  return _0.importKey(
    "raw",
    e,
    { name: "PBKDF2" },
    !1,
    ["deriveBits"]
  ).then(function(g) {
    return _0.deriveBits({
      name: "PBKDF2",
      salt: t,
      iterations: h,
      hash: {
        name: S
      }
    }, g, o << 3);
  }).then(function(g) {
    return cv.from(g);
  });
}
function Qx(e, t) {
  e.then(function(h) {
    ac()(function() {
      t(null, h);
    });
  }, function(h) {
    ac()(function() {
      t(h);
    });
  });
}
var Zx = function(e, t, h, o, S, g) {
  typeof S == "function" && (g = S, S = void 0), S = S || "sha1";
  var B = Yx[S.toLowerCase()];
  if (!B || typeof Me.Promise != "function") {
    ac()(function() {
      var M;
      try {
        M = Pl(e, t, h, o, S);
      } catch (O) {
        return g(O);
      }
      g(null, M);
    });
    return;
  }
  if (Wx(h, o), e = Ll(e, Ol, "Password"), t = Ll(t, Ol, "Salt"), typeof g != "function")
    throw new Error("No callback provided to pbkdf2");
  Qx(Xx(B).then(function(M) {
    return M ? hv(e, t, h, o, B) : Pl(e, t, h, o, S);
  }), g);
};
uf.pbkdf2 = Zx;
uf.pbkdf2Sync = uv;
var Si = {}, qa = {}, Or = {};
Or.readUInt32BE = function(e, t) {
  var h = e[0 + t] << 24 | e[1 + t] << 16 | e[2 + t] << 8 | e[3 + t];
  return h >>> 0;
};
Or.writeUInt32BE = function(e, t, h) {
  e[0 + h] = t >>> 24, e[1 + h] = t >>> 16 & 255, e[2 + h] = t >>> 8 & 255, e[3 + h] = t & 255;
};
Or.ip = function(e, t, h, o) {
  for (var S = 0, g = 0, B = 6; B >= 0; B -= 2) {
    for (var M = 0; M <= 24; M += 8)
      S <<= 1, S |= t >>> M + B & 1;
    for (var M = 0; M <= 24; M += 8)
      S <<= 1, S |= e >>> M + B & 1;
  }
  for (var B = 6; B >= 0; B -= 2) {
    for (var M = 1; M <= 25; M += 8)
      g <<= 1, g |= t >>> M + B & 1;
    for (var M = 1; M <= 25; M += 8)
      g <<= 1, g |= e >>> M + B & 1;
  }
  h[o + 0] = S >>> 0, h[o + 1] = g >>> 0;
};
Or.rip = function(e, t, h, o) {
  for (var S = 0, g = 0, B = 0; B < 4; B++)
    for (var M = 24; M >= 0; M -= 8)
      S <<= 1, S |= t >>> M + B & 1, S <<= 1, S |= e >>> M + B & 1;
  for (var B = 4; B < 8; B++)
    for (var M = 24; M >= 0; M -= 8)
      g <<= 1, g |= t >>> M + B & 1, g <<= 1, g |= e >>> M + B & 1;
  h[o + 0] = S >>> 0, h[o + 1] = g >>> 0;
};
Or.pc1 = function(e, t, h, o) {
  for (var S = 0, g = 0, B = 7; B >= 5; B--) {
    for (var M = 0; M <= 24; M += 8)
      S <<= 1, S |= t >> M + B & 1;
    for (var M = 0; M <= 24; M += 8)
      S <<= 1, S |= e >> M + B & 1;
  }
  for (var M = 0; M <= 24; M += 8)
    S <<= 1, S |= t >> M + B & 1;
  for (var B = 1; B <= 3; B++) {
    for (var M = 0; M <= 24; M += 8)
      g <<= 1, g |= t >> M + B & 1;
    for (var M = 0; M <= 24; M += 8)
      g <<= 1, g |= e >> M + B & 1;
  }
  for (var M = 0; M <= 24; M += 8)
    g <<= 1, g |= e >> M + B & 1;
  h[o + 0] = S >>> 0, h[o + 1] = g >>> 0;
};
Or.r28shl = function(e, t) {
  return e << t & 268435455 | e >>> 28 - t;
};
var Q0 = [
  // inL => outL
  14,
  11,
  17,
  4,
  27,
  23,
  25,
  0,
  13,
  22,
  7,
  18,
  5,
  9,
  16,
  24,
  2,
  20,
  12,
  21,
  1,
  8,
  15,
  26,
  // inR => outR
  15,
  4,
  25,
  19,
  9,
  1,
  26,
  16,
  5,
  11,
  23,
  8,
  12,
  7,
  17,
  0,
  22,
  3,
  10,
  14,
  6,
  20,
  27,
  24
];
Or.pc2 = function(e, t, h, o) {
  for (var S = 0, g = 0, B = Q0.length >>> 1, M = 0; M < B; M++)
    S <<= 1, S |= e >>> Q0[M] & 1;
  for (var M = B; M < Q0.length; M++)
    g <<= 1, g |= t >>> Q0[M] & 1;
  h[o + 0] = S >>> 0, h[o + 1] = g >>> 0;
};
Or.expand = function(e, t, h) {
  var o = 0, S = 0;
  o = (e & 1) << 5 | e >>> 27;
  for (var g = 23; g >= 15; g -= 4)
    o <<= 6, o |= e >>> g & 63;
  for (var g = 11; g >= 3; g -= 4)
    S |= e >>> g & 63, S <<= 6;
  S |= (e & 31) << 1 | e >>> 31, t[h + 0] = o >>> 0, t[h + 1] = S >>> 0;
};
var kl = [
  14,
  0,
  4,
  15,
  13,
  7,
  1,
  4,
  2,
  14,
  15,
  2,
  11,
  13,
  8,
  1,
  3,
  10,
  10,
  6,
  6,
  12,
  12,
  11,
  5,
  9,
  9,
  5,
  0,
  3,
  7,
  8,
  4,
  15,
  1,
  12,
  14,
  8,
  8,
  2,
  13,
  4,
  6,
  9,
  2,
  1,
  11,
  7,
  15,
  5,
  12,
  11,
  9,
  3,
  7,
  14,
  3,
  10,
  10,
  0,
  5,
  6,
  0,
  13,
  15,
  3,
  1,
  13,
  8,
  4,
  14,
  7,
  6,
  15,
  11,
  2,
  3,
  8,
  4,
  14,
  9,
  12,
  7,
  0,
  2,
  1,
  13,
  10,
  12,
  6,
  0,
  9,
  5,
  11,
  10,
  5,
  0,
  13,
  14,
  8,
  7,
  10,
  11,
  1,
  10,
  3,
  4,
  15,
  13,
  4,
  1,
  2,
  5,
  11,
  8,
  6,
  12,
  7,
  6,
  12,
  9,
  0,
  3,
  5,
  2,
  14,
  15,
  9,
  10,
  13,
  0,
  7,
  9,
  0,
  14,
  9,
  6,
  3,
  3,
  4,
  15,
  6,
  5,
  10,
  1,
  2,
  13,
  8,
  12,
  5,
  7,
  14,
  11,
  12,
  4,
  11,
  2,
  15,
  8,
  1,
  13,
  1,
  6,
  10,
  4,
  13,
  9,
  0,
  8,
  6,
  15,
  9,
  3,
  8,
  0,
  7,
  11,
  4,
  1,
  15,
  2,
  14,
  12,
  3,
  5,
  11,
  10,
  5,
  14,
  2,
  7,
  12,
  7,
  13,
  13,
  8,
  14,
  11,
  3,
  5,
  0,
  6,
  6,
  15,
  9,
  0,
  10,
  3,
  1,
  4,
  2,
  7,
  8,
  2,
  5,
  12,
  11,
  1,
  12,
  10,
  4,
  14,
  15,
  9,
  10,
  3,
  6,
  15,
  9,
  0,
  0,
  6,
  12,
  10,
  11,
  1,
  7,
  13,
  13,
  8,
  15,
  9,
  1,
  4,
  3,
  5,
  14,
  11,
  5,
  12,
  2,
  7,
  8,
  2,
  4,
  14,
  2,
  14,
  12,
  11,
  4,
  2,
  1,
  12,
  7,
  4,
  10,
  7,
  11,
  13,
  6,
  1,
  8,
  5,
  5,
  0,
  3,
  15,
  15,
  10,
  13,
  3,
  0,
  9,
  14,
  8,
  9,
  6,
  4,
  11,
  2,
  8,
  1,
  12,
  11,
  7,
  10,
  1,
  13,
  14,
  7,
  2,
  8,
  13,
  15,
  6,
  9,
  15,
  12,
  0,
  5,
  9,
  6,
  10,
  3,
  4,
  0,
  5,
  14,
  3,
  12,
  10,
  1,
  15,
  10,
  4,
  15,
  2,
  9,
  7,
  2,
  12,
  6,
  9,
  8,
  5,
  0,
  6,
  13,
  1,
  3,
  13,
  4,
  14,
  14,
  0,
  7,
  11,
  5,
  3,
  11,
  8,
  9,
  4,
  14,
  3,
  15,
  2,
  5,
  12,
  2,
  9,
  8,
  5,
  12,
  15,
  3,
  10,
  7,
  11,
  0,
  14,
  4,
  1,
  10,
  7,
  1,
  6,
  13,
  0,
  11,
  8,
  6,
  13,
  4,
  13,
  11,
  0,
  2,
  11,
  14,
  7,
  15,
  4,
  0,
  9,
  8,
  1,
  13,
  10,
  3,
  14,
  12,
  3,
  9,
  5,
  7,
  12,
  5,
  2,
  10,
  15,
  6,
  8,
  1,
  6,
  1,
  6,
  4,
  11,
  11,
  13,
  13,
  8,
  12,
  1,
  3,
  4,
  7,
  10,
  14,
  7,
  10,
  9,
  15,
  5,
  6,
  0,
  8,
  15,
  0,
  14,
  5,
  2,
  9,
  3,
  2,
  12,
  13,
  1,
  2,
  15,
  8,
  13,
  4,
  8,
  6,
  10,
  15,
  3,
  11,
  7,
  1,
  4,
  10,
  12,
  9,
  5,
  3,
  6,
  14,
  11,
  5,
  0,
  0,
  14,
  12,
  9,
  7,
  2,
  7,
  2,
  11,
  1,
  4,
  14,
  1,
  7,
  9,
  4,
  12,
  10,
  14,
  8,
  2,
  13,
  0,
  15,
  6,
  12,
  10,
  9,
  13,
  0,
  15,
  3,
  3,
  5,
  5,
  6,
  8,
  11
];
Or.substitute = function(e, t) {
  for (var h = 0, o = 0; o < 4; o++) {
    var S = e >>> 18 - o * 6 & 63, g = kl[o * 64 + S];
    h <<= 4, h |= g;
  }
  for (var o = 0; o < 4; o++) {
    var S = t >>> 18 - o * 6 & 63, g = kl[4 * 64 + o * 64 + S];
    h <<= 4, h |= g;
  }
  return h >>> 0;
};
var Ul = [
  16,
  25,
  12,
  11,
  3,
  20,
  4,
  15,
  31,
  17,
  9,
  6,
  27,
  14,
  1,
  22,
  30,
  24,
  8,
  18,
  0,
  5,
  29,
  23,
  13,
  19,
  2,
  26,
  10,
  21,
  28,
  7
];
Or.permute = function(e) {
  for (var t = 0, h = 0; h < Ul.length; h++)
    t <<= 1, t |= e >>> Ul[h] & 1;
  return t >>> 0;
};
Or.padSplit = function(e, t, h) {
  for (var o = e.toString(2); o.length < t; )
    o = "0" + o;
  for (var S = [], g = 0; g < t; g += h)
    S.push(o.slice(g, g + h));
  return S.join(" ");
};
var Qr = lv;
function lv(e, t) {
  if (!e)
    throw new Error(t || "Assertion failed");
}
lv.equal = function(e, t, h) {
  if (e != t)
    throw new Error(h || "Assertion failed: " + e + " != " + t);
};
var Jx = Qr;
function Zr(e) {
  this.options = e, this.type = this.options.type, this.blockSize = 8, this._init(), this.buffer = new Array(this.blockSize), this.bufferOff = 0, this.padding = e.padding !== !1;
}
var Yc = Zr;
Zr.prototype._init = function() {
};
Zr.prototype.update = function(e) {
  return e.length === 0 ? [] : this.type === "decrypt" ? this._updateDecrypt(e) : this._updateEncrypt(e);
};
Zr.prototype._buffer = function(e, t) {
  for (var h = Math.min(this.buffer.length - this.bufferOff, e.length - t), o = 0; o < h; o++)
    this.buffer[this.bufferOff + o] = e[t + o];
  return this.bufferOff += h, h;
};
Zr.prototype._flushBuffer = function(e, t) {
  return this._update(this.buffer, 0, e, t), this.bufferOff = 0, this.blockSize;
};
Zr.prototype._updateEncrypt = function(e) {
  var t = 0, h = 0, o = (this.bufferOff + e.length) / this.blockSize | 0, S = new Array(o * this.blockSize);
  this.bufferOff !== 0 && (t += this._buffer(e, t), this.bufferOff === this.buffer.length && (h += this._flushBuffer(S, h)));
  for (var g = e.length - (e.length - t) % this.blockSize; t < g; t += this.blockSize)
    this._update(e, t, S, h), h += this.blockSize;
  for (; t < e.length; t++, this.bufferOff++)
    this.buffer[this.bufferOff] = e[t];
  return S;
};
Zr.prototype._updateDecrypt = function(e) {
  for (var t = 0, h = 0, o = Math.ceil((this.bufferOff + e.length) / this.blockSize) - 1, S = new Array(o * this.blockSize); o > 0; o--)
    t += this._buffer(e, t), h += this._flushBuffer(S, h);
  return t += this._buffer(e, t), S;
};
Zr.prototype.final = function(e) {
  var t;
  e && (t = this.update(e));
  var h;
  return this.type === "encrypt" ? h = this._finalEncrypt() : h = this._finalDecrypt(), t ? t.concat(h) : h;
};
Zr.prototype._pad = function(e, t) {
  if (t === 0)
    return !1;
  for (; t < e.length; )
    e[t++] = 0;
  return !0;
};
Zr.prototype._finalEncrypt = function() {
  if (!this._pad(this.buffer, this.bufferOff))
    return [];
  var e = new Array(this.blockSize);
  return this._update(this.buffer, 0, e, 0), e;
};
Zr.prototype._unpad = function(e) {
  return e;
};
Zr.prototype._finalDecrypt = function() {
  Jx.equal(this.bufferOff, this.blockSize, "Not enough data to decrypt");
  var e = new Array(this.blockSize);
  return this._flushBuffer(e, 0), this._unpad(e);
};
var dv = Qr, e4 = ut, jt = Or, pv = Yc;
function t4() {
  this.tmp = new Array(2), this.keys = null;
}
function $i(e) {
  pv.call(this, e);
  var t = new t4();
  this._desState = t, this.deriveKeys(t, e.key);
}
e4($i, pv);
var vv = $i;
$i.create = function(e) {
  return new $i(e);
};
var r4 = [
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  1
];
$i.prototype.deriveKeys = function(e, t) {
  e.keys = new Array(16 * 2), dv.equal(t.length, this.blockSize, "Invalid key length");
  var h = jt.readUInt32BE(t, 0), o = jt.readUInt32BE(t, 4);
  jt.pc1(h, o, e.tmp, 0), h = e.tmp[0], o = e.tmp[1];
  for (var S = 0; S < e.keys.length; S += 2) {
    var g = r4[S >>> 1];
    h = jt.r28shl(h, g), o = jt.r28shl(o, g), jt.pc2(h, o, e.keys, S);
  }
};
$i.prototype._update = function(e, t, h, o) {
  var S = this._desState, g = jt.readUInt32BE(e, t), B = jt.readUInt32BE(e, t + 4);
  jt.ip(g, B, S.tmp, 0), g = S.tmp[0], B = S.tmp[1], this.type === "encrypt" ? this._encrypt(S, g, B, S.tmp, 0) : this._decrypt(S, g, B, S.tmp, 0), g = S.tmp[0], B = S.tmp[1], jt.writeUInt32BE(h, g, o), jt.writeUInt32BE(h, B, o + 4);
};
$i.prototype._pad = function(e, t) {
  if (this.padding === !1)
    return !1;
  for (var h = e.length - t, o = t; o < e.length; o++)
    e[o] = h;
  return !0;
};
$i.prototype._unpad = function(e) {
  if (this.padding === !1)
    return e;
  for (var t = e[e.length - 1], h = e.length - t; h < e.length; h++)
    dv.equal(e[h], t);
  return e.slice(0, e.length - t);
};
$i.prototype._encrypt = function(e, t, h, o, S) {
  for (var g = t, B = h, M = 0; M < e.keys.length; M += 2) {
    var O = e.keys[M], P = e.keys[M + 1];
    jt.expand(B, e.tmp, 0), O ^= e.tmp[0], P ^= e.tmp[1];
    var D = jt.substitute(O, P), Z = jt.permute(D), Y = B;
    B = (g ^ Z) >>> 0, g = Y;
  }
  jt.rip(B, g, o, S);
};
$i.prototype._decrypt = function(e, t, h, o, S) {
  for (var g = h, B = t, M = e.keys.length - 2; M >= 0; M -= 2) {
    var O = e.keys[M], P = e.keys[M + 1];
    jt.expand(g, e.tmp, 0), O ^= e.tmp[0], P ^= e.tmp[1];
    var D = jt.substitute(O, P), Z = jt.permute(D), Y = g;
    g = (B ^ Z) >>> 0, B = Y;
  }
  jt.rip(g, B, o, S);
};
var yv = {}, i4 = Qr, n4 = ut, Ts = {};
function a4(e) {
  i4.equal(e.length, 8, "Invalid IV length"), this.iv = new Array(8);
  for (var t = 0; t < this.iv.length; t++)
    this.iv[t] = e[t];
}
function s4(e) {
  function t(g) {
    e.call(this, g), this._cbcInit();
  }
  n4(t, e);
  for (var h = Object.keys(Ts), o = 0; o < h.length; o++) {
    var S = h[o];
    t.prototype[S] = Ts[S];
  }
  return t.create = function(g) {
    return new t(g);
  }, t;
}
yv.instantiate = s4;
Ts._cbcInit = function() {
  var e = new a4(this.options.iv);
  this._cbcState = e;
};
Ts._update = function(e, t, h, o) {
  var S = this._cbcState, g = this.constructor.super_.prototype, B = S.iv;
  if (this.type === "encrypt") {
    for (var M = 0; M < this.blockSize; M++)
      B[M] ^= e[t + M];
    g._update.call(this, B, 0, h, o);
    for (var M = 0; M < this.blockSize; M++)
      B[M] = h[o + M];
  } else {
    g._update.call(this, e, t, h, o);
    for (var M = 0; M < this.blockSize; M++)
      h[o + M] ^= B[M];
    for (var M = 0; M < this.blockSize; M++)
      B[M] = e[t + M];
  }
};
var f4 = Qr, o4 = ut, gv = Yc, pn = vv;
function u4(e, t) {
  f4.equal(t.length, 24, "Invalid key length");
  var h = t.slice(0, 8), o = t.slice(8, 16), S = t.slice(16, 24);
  e === "encrypt" ? this.ciphers = [
    pn.create({ type: "encrypt", key: h }),
    pn.create({ type: "decrypt", key: o }),
    pn.create({ type: "encrypt", key: S })
  ] : this.ciphers = [
    pn.create({ type: "decrypt", key: S }),
    pn.create({ type: "encrypt", key: o }),
    pn.create({ type: "decrypt", key: h })
  ];
}
function Zn(e) {
  gv.call(this, e);
  var t = new u4(this.type, this.options.key);
  this._edeState = t;
}
o4(Zn, gv);
var c4 = Zn;
Zn.create = function(e) {
  return new Zn(e);
};
Zn.prototype._update = function(e, t, h, o) {
  var S = this._edeState;
  S.ciphers[0]._update(e, t, h, o), S.ciphers[1]._update(h, o, h, o), S.ciphers[2]._update(h, o, h, o);
};
Zn.prototype._pad = pn.prototype._pad;
Zn.prototype._unpad = pn.prototype._unpad;
qa.utils = Or;
qa.Cipher = Yc;
qa.DES = vv;
qa.CBC = yv;
qa.EDE = c4;
var mv = Mn, Xi = qa, h4 = ut, qn = ct.Buffer, B0 = {
  "des-ede3-cbc": Xi.CBC.instantiate(Xi.EDE),
  "des-ede3": Xi.EDE,
  "des-ede-cbc": Xi.CBC.instantiate(Xi.EDE),
  "des-ede": Xi.EDE,
  "des-cbc": Xi.CBC.instantiate(Xi.DES),
  "des-ecb": Xi.DES
};
B0.des = B0["des-cbc"];
B0.des3 = B0["des-ede3-cbc"];
var l4 = cf;
h4(cf, mv);
function cf(e) {
  mv.call(this);
  var t = e.mode.toLowerCase(), h = B0[t], o;
  e.decrypt ? o = "decrypt" : o = "encrypt";
  var S = e.key;
  qn.isBuffer(S) || (S = qn.from(S)), (t === "des-ede" || t === "des-ede-cbc") && (S = qn.concat([S, S.slice(0, 8)]));
  var g = e.iv;
  qn.isBuffer(g) || (g = qn.from(g)), this._des = h.create({
    key: S,
    iv: g,
    type: o
  });
}
cf.prototype._update = function(e) {
  return qn.from(this._des.update(e));
};
cf.prototype._final = function() {
  return qn.from(this._des.final());
};
var Dr = {}, Xc = {}, Qc = {};
Qc.encrypt = function(e, t) {
  return e._cipher.encryptBlock(t);
};
Qc.decrypt = function(e, t) {
  return e._cipher.decryptBlock(t);
};
var Zc = {}, L0 = function(e, t) {
  for (var h = Math.min(e.length, t.length), o = new pe.Buffer(h), S = 0; S < h; ++S)
    o[S] = e[S] ^ t[S];
  return o;
}, bv = L0;
Zc.encrypt = function(e, t) {
  var h = bv(t, e._prev);
  return e._prev = e._cipher.encryptBlock(h), e._prev;
};
Zc.decrypt = function(e, t) {
  var h = e._prev;
  e._prev = t;
  var o = e._cipher.decryptBlock(t);
  return bv(o, h);
};
var xv = {}, g0 = ct.Buffer, d4 = L0;
function Fl(e, t, h) {
  var o = t.length, S = d4(t, e._cache);
  return e._cache = e._cache.slice(o), e._prev = g0.concat([e._prev, h ? t : S]), S;
}
xv.encrypt = function(e, t, h) {
  for (var o = g0.allocUnsafe(0), S; t.length; )
    if (e._cache.length === 0 && (e._cache = e._cipher.encryptBlock(e._prev), e._prev = g0.allocUnsafe(0)), e._cache.length <= t.length)
      S = e._cache.length, o = g0.concat([o, Fl(e, t.slice(0, S), h)]), t = t.slice(S);
    else {
      o = g0.concat([o, Fl(e, t, h)]);
      break;
    }
  return o;
};
var _v = {}, sc = ct.Buffer;
function p4(e, t, h) {
  var o = e._cipher.encryptBlock(e._prev), S = o[0] ^ t;
  return e._prev = sc.concat([
    e._prev.slice(1),
    sc.from([h ? t : S])
  ]), S;
}
_v.encrypt = function(e, t, h) {
  for (var o = t.length, S = sc.allocUnsafe(o), g = -1; ++g < o; )
    S[g] = p4(e, t[g], h);
  return S;
};
var Ev = {}, ms = ct.Buffer;
function v4(e, t, h) {
  for (var o, S = -1, g = 8, B = 0, M, O; ++S < g; )
    o = e._cipher.encryptBlock(e._prev), M = t & 1 << 7 - S ? 128 : 0, O = o[0] ^ M, B += (O & 128) >> S % 8, e._prev = y4(e._prev, h ? M : O);
  return B;
}
function y4(e, t) {
  var h = e.length, o = -1, S = ms.allocUnsafe(e.length);
  for (e = ms.concat([e, ms.from([t])]); ++o < h; )
    S[o] = e[o] << 1 | e[o + 1] >> 7;
  return S;
}
Ev.encrypt = function(e, t, h) {
  for (var o = t.length, S = ms.allocUnsafe(o), g = -1; ++g < o; )
    S[g] = v4(e, t[g], h);
  return S;
};
var Sv = {}, g4 = L0;
function m4(e) {
  return e._prev = e._cipher.encryptBlock(e._prev), e._prev;
}
Sv.encrypt = function(e, t) {
  for (; e._cache.length < t.length; )
    e._cache = pe.Buffer.concat([e._cache, m4(e)]);
  var h = e._cache.slice(0, t.length);
  return e._cache = e._cache.slice(t.length), g4(t, h);
};
var fc = {};
function b4(e) {
  for (var t = e.length, h; t--; )
    if (h = e.readUInt8(t), h === 255)
      e.writeUInt8(0, t);
    else {
      h++, e.writeUInt8(h, t);
      break;
    }
}
var wv = b4, x4 = L0, ql = ct.Buffer, _4 = wv;
function E4(e) {
  var t = e._cipher.encryptBlockRaw(e._prev);
  return _4(e._prev), t;
}
var bo = 16;
fc.encrypt = function(e, t) {
  var h = Math.ceil(t.length / bo), o = e._cache.length;
  e._cache = ql.concat([
    e._cache,
    ql.allocUnsafe(h * bo)
  ]);
  for (var S = 0; S < h; S++) {
    var g = E4(e), B = o + S * bo;
    e._cache.writeUInt32BE(g[0], B + 0), e._cache.writeUInt32BE(g[1], B + 4), e._cache.writeUInt32BE(g[2], B + 8), e._cache.writeUInt32BE(g[3], B + 12);
  }
  var M = e._cache.slice(0, t.length);
  return e._cache = e._cache.slice(t.length), x4(t, M);
};
const S4 = {
  cipher: "AES",
  key: 128,
  iv: 16,
  mode: "CBC",
  type: "block"
}, w4 = {
  cipher: "AES",
  key: 192,
  iv: 16,
  mode: "CBC",
  type: "block"
}, C4 = {
  cipher: "AES",
  key: 256,
  iv: 16,
  mode: "CBC",
  type: "block"
}, Cv = {
  "aes-128-ecb": {
    cipher: "AES",
    key: 128,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-192-ecb": {
    cipher: "AES",
    key: 192,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-256-ecb": {
    cipher: "AES",
    key: 256,
    iv: 0,
    mode: "ECB",
    type: "block"
  },
  "aes-128-cbc": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-192-cbc": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  "aes-256-cbc": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CBC",
    type: "block"
  },
  aes128: S4,
  aes192: w4,
  aes256: C4,
  "aes-128-cfb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-192-cfb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-256-cfb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB",
    type: "stream"
  },
  "aes-128-cfb8": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-192-cfb8": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-256-cfb8": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB8",
    type: "stream"
  },
  "aes-128-cfb1": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-192-cfb1": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-256-cfb1": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CFB1",
    type: "stream"
  },
  "aes-128-ofb": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-192-ofb": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-256-ofb": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "OFB",
    type: "stream"
  },
  "aes-128-ctr": {
    cipher: "AES",
    key: 128,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-192-ctr": {
    cipher: "AES",
    key: 192,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-256-ctr": {
    cipher: "AES",
    key: 256,
    iv: 16,
    mode: "CTR",
    type: "stream"
  },
  "aes-128-gcm": {
    cipher: "AES",
    key: 128,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-192-gcm": {
    cipher: "AES",
    key: 192,
    iv: 12,
    mode: "GCM",
    type: "auth"
  },
  "aes-256-gcm": {
    cipher: "AES",
    key: 256,
    iv: 12,
    mode: "GCM",
    type: "auth"
  }
};
var A4 = {
  ECB: Qc,
  CBC: Zc,
  CFB: xv,
  CFB8: _v,
  CFB1: Ev,
  OFB: Sv,
  CTR: fc,
  GCM: fc
}, bs = Cv;
for (var Vl in bs)
  bs[Vl].module = A4[bs[Vl].mode];
var Jc = bs, k0 = {}, Ms = ct.Buffer;
function eh(e) {
  Ms.isBuffer(e) || (e = Ms.from(e));
  for (var t = e.length / 4 | 0, h = new Array(t), o = 0; o < t; o++)
    h[o] = e.readUInt32BE(o * 4);
  return h;
}
function xo(e) {
  for (var t = 0; t < e.length; e++)
    e[t] = 0;
}
function Av(e, t, h, o, S) {
  for (var g = h[0], B = h[1], M = h[2], O = h[3], P = e[0] ^ t[0], D = e[1] ^ t[1], Z = e[2] ^ t[2], Y = e[3] ^ t[3], ee, ie, ue, fe, de = 4, ce = 1; ce < S; ce++)
    ee = g[P >>> 24] ^ B[D >>> 16 & 255] ^ M[Z >>> 8 & 255] ^ O[Y & 255] ^ t[de++], ie = g[D >>> 24] ^ B[Z >>> 16 & 255] ^ M[Y >>> 8 & 255] ^ O[P & 255] ^ t[de++], ue = g[Z >>> 24] ^ B[Y >>> 16 & 255] ^ M[P >>> 8 & 255] ^ O[D & 255] ^ t[de++], fe = g[Y >>> 24] ^ B[P >>> 16 & 255] ^ M[D >>> 8 & 255] ^ O[Z & 255] ^ t[de++], P = ee, D = ie, Z = ue, Y = fe;
  return ee = (o[P >>> 24] << 24 | o[D >>> 16 & 255] << 16 | o[Z >>> 8 & 255] << 8 | o[Y & 255]) ^ t[de++], ie = (o[D >>> 24] << 24 | o[Z >>> 16 & 255] << 16 | o[Y >>> 8 & 255] << 8 | o[P & 255]) ^ t[de++], ue = (o[Z >>> 24] << 24 | o[Y >>> 16 & 255] << 16 | o[P >>> 8 & 255] << 8 | o[D & 255]) ^ t[de++], fe = (o[Y >>> 24] << 24 | o[P >>> 16 & 255] << 16 | o[D >>> 8 & 255] << 8 | o[Z & 255]) ^ t[de++], ee = ee >>> 0, ie = ie >>> 0, ue = ue >>> 0, fe = fe >>> 0, [ee, ie, ue, fe];
}
var B4 = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], Ht = function() {
  for (var e = new Array(256), t = 0; t < 256; t++)
    t < 128 ? e[t] = t << 1 : e[t] = t << 1 ^ 283;
  for (var h = [], o = [], S = [[], [], [], []], g = [[], [], [], []], B = 0, M = 0, O = 0; O < 256; ++O) {
    var P = M ^ M << 1 ^ M << 2 ^ M << 3 ^ M << 4;
    P = P >>> 8 ^ P & 255 ^ 99, h[B] = P, o[P] = B;
    var D = e[B], Z = e[D], Y = e[Z], ee = e[P] * 257 ^ P * 16843008;
    S[0][B] = ee << 24 | ee >>> 8, S[1][B] = ee << 16 | ee >>> 16, S[2][B] = ee << 8 | ee >>> 24, S[3][B] = ee, ee = Y * 16843009 ^ Z * 65537 ^ D * 257 ^ B * 16843008, g[0][P] = ee << 24 | ee >>> 8, g[1][P] = ee << 16 | ee >>> 16, g[2][P] = ee << 8 | ee >>> 24, g[3][P] = ee, B === 0 ? B = M = 1 : (B = D ^ e[e[e[Y ^ D]]], M ^= e[e[M]]);
  }
  return {
    SBOX: h,
    INV_SBOX: o,
    SUB_MIX: S,
    INV_SUB_MIX: g
  };
}();
function Wr(e) {
  this._key = eh(e), this._reset();
}
Wr.blockSize = 4 * 4;
Wr.keySize = 256 / 8;
Wr.prototype.blockSize = Wr.blockSize;
Wr.prototype.keySize = Wr.keySize;
Wr.prototype._reset = function() {
  for (var e = this._key, t = e.length, h = t + 6, o = (h + 1) * 4, S = [], g = 0; g < t; g++)
    S[g] = e[g];
  for (g = t; g < o; g++) {
    var B = S[g - 1];
    g % t === 0 ? (B = B << 8 | B >>> 24, B = Ht.SBOX[B >>> 24] << 24 | Ht.SBOX[B >>> 16 & 255] << 16 | Ht.SBOX[B >>> 8 & 255] << 8 | Ht.SBOX[B & 255], B ^= B4[g / t | 0] << 24) : t > 6 && g % t === 4 && (B = Ht.SBOX[B >>> 24] << 24 | Ht.SBOX[B >>> 16 & 255] << 16 | Ht.SBOX[B >>> 8 & 255] << 8 | Ht.SBOX[B & 255]), S[g] = S[g - t] ^ B;
  }
  for (var M = [], O = 0; O < o; O++) {
    var P = o - O, D = S[P - (O % 4 ? 0 : 4)];
    O < 4 || P <= 4 ? M[O] = D : M[O] = Ht.INV_SUB_MIX[0][Ht.SBOX[D >>> 24]] ^ Ht.INV_SUB_MIX[1][Ht.SBOX[D >>> 16 & 255]] ^ Ht.INV_SUB_MIX[2][Ht.SBOX[D >>> 8 & 255]] ^ Ht.INV_SUB_MIX[3][Ht.SBOX[D & 255]];
  }
  this._nRounds = h, this._keySchedule = S, this._invKeySchedule = M;
};
Wr.prototype.encryptBlockRaw = function(e) {
  return e = eh(e), Av(e, this._keySchedule, Ht.SUB_MIX, Ht.SBOX, this._nRounds);
};
Wr.prototype.encryptBlock = function(e) {
  var t = this.encryptBlockRaw(e), h = Ms.allocUnsafe(16);
  return h.writeUInt32BE(t[0], 0), h.writeUInt32BE(t[1], 4), h.writeUInt32BE(t[2], 8), h.writeUInt32BE(t[3], 12), h;
};
Wr.prototype.decryptBlock = function(e) {
  e = eh(e);
  var t = e[1];
  e[1] = e[3], e[3] = t;
  var h = Av(e, this._invKeySchedule, Ht.INV_SUB_MIX, Ht.INV_SBOX, this._nRounds), o = Ms.allocUnsafe(16);
  return o.writeUInt32BE(h[0], 0), o.writeUInt32BE(h[3], 4), o.writeUInt32BE(h[2], 8), o.writeUInt32BE(h[1], 12), o;
};
Wr.prototype.scrub = function() {
  xo(this._keySchedule), xo(this._invKeySchedule), xo(this._key);
};
k0.AES = Wr;
var Ca = ct.Buffer, I4 = Ca.alloc(16, 0);
function T4(e) {
  return [
    e.readUInt32BE(0),
    e.readUInt32BE(4),
    e.readUInt32BE(8),
    e.readUInt32BE(12)
  ];
}
function Bv(e) {
  var t = Ca.allocUnsafe(16);
  return t.writeUInt32BE(e[0] >>> 0, 0), t.writeUInt32BE(e[1] >>> 0, 4), t.writeUInt32BE(e[2] >>> 0, 8), t.writeUInt32BE(e[3] >>> 0, 12), t;
}
function U0(e) {
  this.h = e, this.state = Ca.alloc(16, 0), this.cache = Ca.allocUnsafe(0);
}
U0.prototype.ghash = function(e) {
  for (var t = -1; ++t < e.length; )
    this.state[t] ^= e[t];
  this._multiply();
};
U0.prototype._multiply = function() {
  for (var e = T4(this.h), t = [0, 0, 0, 0], h, o, S, g = -1; ++g < 128; ) {
    for (o = (this.state[~~(g / 8)] & 1 << 7 - g % 8) !== 0, o && (t[0] ^= e[0], t[1] ^= e[1], t[2] ^= e[2], t[3] ^= e[3]), S = (e[3] & 1) !== 0, h = 3; h > 0; h--)
      e[h] = e[h] >>> 1 | (e[h - 1] & 1) << 31;
    e[0] = e[0] >>> 1, S && (e[0] = e[0] ^ 225 << 24);
  }
  this.state = Bv(t);
};
U0.prototype.update = function(e) {
  this.cache = Ca.concat([this.cache, e]);
  for (var t; this.cache.length >= 16; )
    t = this.cache.slice(0, 16), this.cache = this.cache.slice(16), this.ghash(t);
};
U0.prototype.final = function(e, t) {
  return this.cache.length && this.ghash(Ca.concat([this.cache, I4], 16)), this.ghash(Bv([0, e, 0, t])), this.state;
};
var M4 = U0, R4 = k0, wr = ct.Buffer, Iv = Mn, N4 = ut, Tv = M4, D4 = L0, O4 = wv;
function P4(e, t) {
  var h = 0;
  e.length !== t.length && h++;
  for (var o = Math.min(e.length, t.length), S = 0; S < o; ++S)
    h += e[S] ^ t[S];
  return h;
}
function L4(e, t, h) {
  if (t.length === 12)
    return e._finID = wr.concat([t, wr.from([0, 0, 0, 1])]), wr.concat([t, wr.from([0, 0, 0, 2])]);
  var o = new Tv(h), S = t.length, g = S % 16;
  o.update(t), g && (g = 16 - g, o.update(wr.alloc(g, 0))), o.update(wr.alloc(8, 0));
  var B = S * 8, M = wr.alloc(8);
  M.writeUIntBE(B, 0, 8), o.update(M), e._finID = o.state;
  var O = wr.from(e._finID);
  return O4(O), O;
}
function ia(e, t, h, o) {
  Iv.call(this);
  var S = wr.alloc(4, 0);
  this._cipher = new R4.AES(t);
  var g = this._cipher.encryptBlock(S);
  this._ghash = new Tv(g), h = L4(this, h, g), this._prev = wr.from(h), this._cache = wr.allocUnsafe(0), this._secCache = wr.allocUnsafe(0), this._decrypt = o, this._alen = 0, this._len = 0, this._mode = e, this._authTag = null, this._called = !1;
}
N4(ia, Iv);
ia.prototype._update = function(e) {
  if (!this._called && this._alen) {
    var t = 16 - this._alen % 16;
    t < 16 && (t = wr.alloc(t, 0), this._ghash.update(t));
  }
  this._called = !0;
  var h = this._mode.encrypt(this, e);
  return this._decrypt ? this._ghash.update(e) : this._ghash.update(h), this._len += e.length, h;
};
ia.prototype._final = function() {
  if (this._decrypt && !this._authTag)
    throw new Error("Unsupported state or unable to authenticate data");
  var e = D4(this._ghash.final(this._alen * 8, this._len * 8), this._cipher.encryptBlock(this._finID));
  if (this._decrypt && P4(e, this._authTag))
    throw new Error("Unsupported state or unable to authenticate data");
  this._authTag = e, this._cipher.scrub();
};
ia.prototype.getAuthTag = function() {
  if (this._decrypt || !wr.isBuffer(this._authTag))
    throw new Error("Attempting to get auth tag in unsupported state");
  return this._authTag;
};
ia.prototype.setAuthTag = function(e) {
  if (!this._decrypt)
    throw new Error("Attempting to set auth tag in unsupported state");
  this._authTag = e;
};
ia.prototype.setAAD = function(e) {
  if (this._called)
    throw new Error("Attempting to set AAD in unsupported state");
  this._ghash.update(e), this._alen += e.length;
};
var Mv = ia, k4 = k0, _o = ct.Buffer, Rv = Mn, U4 = ut;
function hf(e, t, h, o) {
  Rv.call(this), this._cipher = new k4.AES(t), this._prev = _o.from(h), this._cache = _o.allocUnsafe(0), this._secCache = _o.allocUnsafe(0), this._decrypt = o, this._mode = e;
}
U4(hf, Rv);
hf.prototype._update = function(e) {
  return this._mode.encrypt(this, e, this._decrypt);
};
hf.prototype._final = function() {
  this._cipher.scrub();
};
var Nv = hf, Pn = ct.Buffer, F4 = Gc;
function q4(e, t, h, o) {
  if (Pn.isBuffer(e) || (e = Pn.from(e, "binary")), t && (Pn.isBuffer(t) || (t = Pn.from(t, "binary")), t.length !== 8))
    throw new RangeError("salt should be Buffer with 8 byte length");
  for (var S = h / 8, g = Pn.alloc(S), B = Pn.alloc(o || 0), M = Pn.alloc(0); S > 0 || o > 0; ) {
    var O = new F4();
    O.update(M), O.update(e), t && O.update(t), M = O.digest();
    var P = 0;
    if (S > 0) {
      var D = g.length - S;
      P = Math.min(S, M.length), M.copy(g, D, 0, P), S -= P;
    }
    if (P < M.length && o > 0) {
      var Z = B.length - o, Y = Math.min(o, M.length - P);
      M.copy(B, Z, P, P + Y), o -= Y;
    }
  }
  return M.fill(0), { key: g, iv: B };
}
var lf = q4, Dv = Jc, V4 = Mv, fn = ct.Buffer, K4 = Nv, Ov = Mn, $4 = k0, H4 = lf, G4 = ut;
function F0(e, t, h) {
  Ov.call(this), this._cache = new df(), this._cipher = new $4.AES(t), this._prev = fn.from(h), this._mode = e, this._autopadding = !0;
}
G4(F0, Ov);
F0.prototype._update = function(e) {
  this._cache.add(e);
  for (var t, h, o = []; t = this._cache.get(); )
    h = this._mode.encrypt(this, t), o.push(h);
  return fn.concat(o);
};
var z4 = fn.alloc(16, 16);
F0.prototype._final = function() {
  var e = this._cache.flush();
  if (this._autopadding)
    return e = this._mode.encrypt(this, e), this._cipher.scrub(), e;
  if (!e.equals(z4))
    throw this._cipher.scrub(), new Error("data not multiple of block length");
};
F0.prototype.setAutoPadding = function(e) {
  return this._autopadding = !!e, this;
};
function df() {
  this.cache = fn.allocUnsafe(0);
}
df.prototype.add = function(e) {
  this.cache = fn.concat([this.cache, e]);
};
df.prototype.get = function() {
  if (this.cache.length > 15) {
    var e = this.cache.slice(0, 16);
    return this.cache = this.cache.slice(16), e;
  }
  return null;
};
df.prototype.flush = function() {
  for (var e = 16 - this.cache.length, t = fn.allocUnsafe(e), h = -1; ++h < e; )
    t.writeUInt8(e, h);
  return fn.concat([this.cache, t]);
};
function Pv(e, t, h) {
  var o = Dv[e.toLowerCase()];
  if (!o)
    throw new TypeError("invalid suite type");
  if (typeof t == "string" && (t = fn.from(t)), t.length !== o.key / 8)
    throw new TypeError("invalid key length " + t.length);
  if (typeof h == "string" && (h = fn.from(h)), o.mode !== "GCM" && h.length !== o.iv)
    throw new TypeError("invalid iv length " + h.length);
  return o.type === "stream" ? new K4(o.module, t, h) : o.type === "auth" ? new V4(o.module, t, h) : new F0(o.module, t, h);
}
function j4(e, t) {
  var h = Dv[e.toLowerCase()];
  if (!h)
    throw new TypeError("invalid suite type");
  var o = H4(t, !1, h.key, h.iv);
  return Pv(e, o.key, o.iv);
}
Xc.createCipheriv = Pv;
Xc.createCipher = j4;
var th = {}, W4 = Mv, Aa = ct.Buffer, Lv = Jc, Y4 = Nv, kv = Mn, X4 = k0, Q4 = lf, Z4 = ut;
function q0(e, t, h) {
  kv.call(this), this._cache = new pf(), this._last = void 0, this._cipher = new X4.AES(t), this._prev = Aa.from(h), this._mode = e, this._autopadding = !0;
}
Z4(q0, kv);
q0.prototype._update = function(e) {
  this._cache.add(e);
  for (var t, h, o = []; t = this._cache.get(this._autopadding); )
    h = this._mode.decrypt(this, t), o.push(h);
  return Aa.concat(o);
};
q0.prototype._final = function() {
  var e = this._cache.flush();
  if (this._autopadding)
    return J4(this._mode.decrypt(this, e));
  if (e)
    throw new Error("data not multiple of block length");
};
q0.prototype.setAutoPadding = function(e) {
  return this._autopadding = !!e, this;
};
function pf() {
  this.cache = Aa.allocUnsafe(0);
}
pf.prototype.add = function(e) {
  this.cache = Aa.concat([this.cache, e]);
};
pf.prototype.get = function(e) {
  var t;
  if (e) {
    if (this.cache.length > 16)
      return t = this.cache.slice(0, 16), this.cache = this.cache.slice(16), t;
  } else if (this.cache.length >= 16)
    return t = this.cache.slice(0, 16), this.cache = this.cache.slice(16), t;
  return null;
};
pf.prototype.flush = function() {
  if (this.cache.length)
    return this.cache;
};
function J4(e) {
  var t = e[15];
  if (t < 1 || t > 16)
    throw new Error("unable to decrypt data");
  for (var h = -1; ++h < t; )
    if (e[h + (16 - t)] !== t)
      throw new Error("unable to decrypt data");
  if (t !== 16)
    return e.slice(0, 16 - t);
}
function Uv(e, t, h) {
  var o = Lv[e.toLowerCase()];
  if (!o)
    throw new TypeError("invalid suite type");
  if (typeof h == "string" && (h = Aa.from(h)), o.mode !== "GCM" && h.length !== o.iv)
    throw new TypeError("invalid iv length " + h.length);
  if (typeof t == "string" && (t = Aa.from(t)), t.length !== o.key / 8)
    throw new TypeError("invalid key length " + t.length);
  return o.type === "stream" ? new Y4(o.module, t, h, !0) : o.type === "auth" ? new W4(o.module, t, h, !0) : new q0(o.module, t, h);
}
function e3(e, t) {
  var h = Lv[e.toLowerCase()];
  if (!h)
    throw new TypeError("invalid suite type");
  var o = Q4(t, !1, h.key, h.iv);
  return Uv(e, o.key, o.iv);
}
th.createDecipher = e3;
th.createDecipheriv = Uv;
var Fv = Xc, qv = th, t3 = Cv;
function r3() {
  return Object.keys(t3);
}
Dr.createCipher = Dr.Cipher = Fv.createCipher;
Dr.createCipheriv = Dr.Cipheriv = Fv.createCipheriv;
Dr.createDecipher = Dr.Decipher = qv.createDecipher;
Dr.createDecipheriv = Dr.Decipheriv = qv.createDecipheriv;
Dr.listCiphers = Dr.getCiphers = r3;
var Vv = {};
(function(e) {
  e["des-ecb"] = {
    key: 8,
    iv: 0
  }, e["des-cbc"] = e.des = {
    key: 8,
    iv: 8
  }, e["des-ede3-cbc"] = e.des3 = {
    key: 24,
    iv: 8
  }, e["des-ede3"] = {
    key: 24,
    iv: 0
  }, e["des-ede-cbc"] = {
    key: 16,
    iv: 8
  }, e["des-ede"] = {
    key: 16,
    iv: 0
  };
})(Vv);
var Kv = l4, rh = Dr, En = Jc, nn = Vv, $v = lf;
function i3(e, t) {
  e = e.toLowerCase();
  var h, o;
  if (En[e])
    h = En[e].key, o = En[e].iv;
  else if (nn[e])
    h = nn[e].key * 8, o = nn[e].iv;
  else
    throw new TypeError("invalid suite type");
  var S = $v(t, !1, h, o);
  return Hv(e, S.key, S.iv);
}
function n3(e, t) {
  e = e.toLowerCase();
  var h, o;
  if (En[e])
    h = En[e].key, o = En[e].iv;
  else if (nn[e])
    h = nn[e].key * 8, o = nn[e].iv;
  else
    throw new TypeError("invalid suite type");
  var S = $v(t, !1, h, o);
  return Gv(e, S.key, S.iv);
}
function Hv(e, t, h) {
  if (e = e.toLowerCase(), En[e])
    return rh.createCipheriv(e, t, h);
  if (nn[e])
    return new Kv({ key: t, iv: h, mode: e });
  throw new TypeError("invalid suite type");
}
function Gv(e, t, h) {
  if (e = e.toLowerCase(), En[e])
    return rh.createDecipheriv(e, t, h);
  if (nn[e])
    return new Kv({ key: t, iv: h, mode: e, decrypt: !0 });
  throw new TypeError("invalid suite type");
}
function a3() {
  return Object.keys(nn).concat(rh.getCiphers());
}
Si.createCipher = Si.Cipher = i3;
Si.createCipheriv = Si.Cipheriv = Hv;
Si.createDecipher = Si.Decipher = n3;
Si.createDecipheriv = Si.Decipheriv = Gv;
Si.listCiphers = Si.getCiphers = a3;
var Ln = {}, ih = { exports: {} };
(function(e) {
  (function(t, h) {
    function o(J, ne) {
      if (!J)
        throw new Error(ne || "Assertion failed");
    }
    function S(J, ne) {
      J.super_ = ne;
      var A = function() {
      };
      A.prototype = ne.prototype, J.prototype = new A(), J.prototype.constructor = J;
    }
    function g(J, ne, A) {
      if (g.isBN(J))
        return J;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, J !== null && ((ne === "le" || ne === "be") && (A = ne, ne = 10), this._init(J || 0, ne || 10, A || "be"));
    }
    typeof t == "object" ? t.exports = g : h.BN = g, g.BN = g, g.wordSize = 26;
    var B;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? B = window.Buffer : B = pe.Buffer;
    } catch {
    }
    g.isBN = function(J) {
      return J instanceof g ? !0 : J !== null && typeof J == "object" && J.constructor.wordSize === g.wordSize && Array.isArray(J.words);
    }, g.max = function(J, ne) {
      return J.cmp(ne) > 0 ? J : ne;
    }, g.min = function(J, ne) {
      return J.cmp(ne) < 0 ? J : ne;
    }, g.prototype._init = function(J, ne, A) {
      if (typeof J == "number")
        return this._initNumber(J, ne, A);
      if (typeof J == "object")
        return this._initArray(J, ne, A);
      ne === "hex" && (ne = 16), o(ne === (ne | 0) && ne >= 2 && ne <= 36), J = J.toString().replace(/\s+/g, "");
      var I = 0;
      J[0] === "-" && (I++, this.negative = 1), I < J.length && (ne === 16 ? this._parseHex(J, I, A) : (this._parseBase(J, ne, I), A === "le" && this._initArray(this.toArray(), ne, A)));
    }, g.prototype._initNumber = function(J, ne, A) {
      J < 0 && (this.negative = 1, J = -J), J < 67108864 ? (this.words = [J & 67108863], this.length = 1) : J < 4503599627370496 ? (this.words = [
        J & 67108863,
        J / 67108864 & 67108863
      ], this.length = 2) : (o(J < 9007199254740992), this.words = [
        J & 67108863,
        J / 67108864 & 67108863,
        1
      ], this.length = 3), A === "le" && this._initArray(this.toArray(), ne, A);
    }, g.prototype._initArray = function(J, ne, A) {
      if (o(typeof J.length == "number"), J.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(J.length / 3), this.words = new Array(this.length);
      for (var I = 0; I < this.length; I++)
        this.words[I] = 0;
      var U, X, Q = 0;
      if (A === "be")
        for (I = J.length - 1, U = 0; I >= 0; I -= 3)
          X = J[I] | J[I - 1] << 8 | J[I - 2] << 16, this.words[U] |= X << Q & 67108863, this.words[U + 1] = X >>> 26 - Q & 67108863, Q += 24, Q >= 26 && (Q -= 26, U++);
      else if (A === "le")
        for (I = 0, U = 0; I < J.length; I += 3)
          X = J[I] | J[I + 1] << 8 | J[I + 2] << 16, this.words[U] |= X << Q & 67108863, this.words[U + 1] = X >>> 26 - Q & 67108863, Q += 24, Q >= 26 && (Q -= 26, U++);
      return this.strip();
    };
    function M(J, ne) {
      var A = J.charCodeAt(ne);
      return A >= 65 && A <= 70 ? A - 55 : A >= 97 && A <= 102 ? A - 87 : A - 48 & 15;
    }
    function O(J, ne, A) {
      var I = M(J, A);
      return A - 1 >= ne && (I |= M(J, A - 1) << 4), I;
    }
    g.prototype._parseHex = function(J, ne, A) {
      this.length = Math.ceil((J.length - ne) / 6), this.words = new Array(this.length);
      for (var I = 0; I < this.length; I++)
        this.words[I] = 0;
      var U = 0, X = 0, Q;
      if (A === "be")
        for (I = J.length - 1; I >= ne; I -= 2)
          Q = O(J, ne, I) << U, this.words[X] |= Q & 67108863, U >= 18 ? (U -= 18, X += 1, this.words[X] |= Q >>> 26) : U += 8;
      else {
        var F = J.length - ne;
        for (I = F % 2 === 0 ? ne + 1 : ne; I < J.length; I += 2)
          Q = O(J, ne, I) << U, this.words[X] |= Q & 67108863, U >= 18 ? (U -= 18, X += 1, this.words[X] |= Q >>> 26) : U += 8;
      }
      this.strip();
    };
    function P(J, ne, A, I) {
      for (var U = 0, X = Math.min(J.length, A), Q = ne; Q < X; Q++) {
        var F = J.charCodeAt(Q) - 48;
        U *= I, F >= 49 ? U += F - 49 + 10 : F >= 17 ? U += F - 17 + 10 : U += F;
      }
      return U;
    }
    g.prototype._parseBase = function(J, ne, A) {
      this.words = [0], this.length = 1;
      for (var I = 0, U = 1; U <= 67108863; U *= ne)
        I++;
      I--, U = U / ne | 0;
      for (var X = J.length - A, Q = X % I, F = Math.min(X, X - Q) + A, $ = 0, H = A; H < F; H += I)
        $ = P(J, H, H + I, ne), this.imuln(U), this.words[0] + $ < 67108864 ? this.words[0] += $ : this._iaddn($);
      if (Q !== 0) {
        var q = 1;
        for ($ = P(J, H, J.length, ne), H = 0; H < Q; H++)
          q *= ne;
        this.imuln(q), this.words[0] + $ < 67108864 ? this.words[0] += $ : this._iaddn($);
      }
      this.strip();
    }, g.prototype.copy = function(J) {
      J.words = new Array(this.length);
      for (var ne = 0; ne < this.length; ne++)
        J.words[ne] = this.words[ne];
      J.length = this.length, J.negative = this.negative, J.red = this.red;
    }, g.prototype.clone = function() {
      var J = new g(null);
      return this.copy(J), J;
    }, g.prototype._expand = function(J) {
      for (; this.length < J; )
        this.words[this.length++] = 0;
      return this;
    }, g.prototype.strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, g.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, g.prototype.inspect = function() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var D = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], Z = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], Y = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    g.prototype.toString = function(J, ne) {
      J = J || 10, ne = ne | 0 || 1;
      var A;
      if (J === 16 || J === "hex") {
        A = "";
        for (var I = 0, U = 0, X = 0; X < this.length; X++) {
          var Q = this.words[X], F = ((Q << I | U) & 16777215).toString(16);
          U = Q >>> 24 - I & 16777215, U !== 0 || X !== this.length - 1 ? A = D[6 - F.length] + F + A : A = F + A, I += 2, I >= 26 && (I -= 26, X--);
        }
        for (U !== 0 && (A = U.toString(16) + A); A.length % ne !== 0; )
          A = "0" + A;
        return this.negative !== 0 && (A = "-" + A), A;
      }
      if (J === (J | 0) && J >= 2 && J <= 36) {
        var $ = Z[J], H = Y[J];
        A = "";
        var q = this.clone();
        for (q.negative = 0; !q.isZero(); ) {
          var z = q.modn(H).toString(J);
          q = q.idivn(H), q.isZero() ? A = z + A : A = D[$ - z.length] + z + A;
        }
        for (this.isZero() && (A = "0" + A); A.length % ne !== 0; )
          A = "0" + A;
        return this.negative !== 0 && (A = "-" + A), A;
      }
      o(!1, "Base should be between 2 and 36");
    }, g.prototype.toNumber = function() {
      var J = this.words[0];
      return this.length === 2 ? J += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? J += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && o(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -J : J;
    }, g.prototype.toJSON = function() {
      return this.toString(16);
    }, g.prototype.toBuffer = function(J, ne) {
      return o(typeof B < "u"), this.toArrayLike(B, J, ne);
    }, g.prototype.toArray = function(J, ne) {
      return this.toArrayLike(Array, J, ne);
    }, g.prototype.toArrayLike = function(J, ne, A) {
      var I = this.byteLength(), U = A || Math.max(1, I);
      o(I <= U, "byte array longer than desired length"), o(U > 0, "Requested array length <= 0"), this.strip();
      var X = ne === "le", Q = new J(U), F, $, H = this.clone();
      if (X) {
        for ($ = 0; !H.isZero(); $++)
          F = H.andln(255), H.iushrn(8), Q[$] = F;
        for (; $ < U; $++)
          Q[$] = 0;
      } else {
        for ($ = 0; $ < U - I; $++)
          Q[$] = 0;
        for ($ = 0; !H.isZero(); $++)
          F = H.andln(255), H.iushrn(8), Q[U - $ - 1] = F;
      }
      return Q;
    }, Math.clz32 ? g.prototype._countBits = function(J) {
      return 32 - Math.clz32(J);
    } : g.prototype._countBits = function(J) {
      var ne = J, A = 0;
      return ne >= 4096 && (A += 13, ne >>>= 13), ne >= 64 && (A += 7, ne >>>= 7), ne >= 8 && (A += 4, ne >>>= 4), ne >= 2 && (A += 2, ne >>>= 2), A + ne;
    }, g.prototype._zeroBits = function(J) {
      if (J === 0)
        return 26;
      var ne = J, A = 0;
      return ne & 8191 || (A += 13, ne >>>= 13), ne & 127 || (A += 7, ne >>>= 7), ne & 15 || (A += 4, ne >>>= 4), ne & 3 || (A += 2, ne >>>= 2), ne & 1 || A++, A;
    }, g.prototype.bitLength = function() {
      var J = this.words[this.length - 1], ne = this._countBits(J);
      return (this.length - 1) * 26 + ne;
    };
    function ee(J) {
      for (var ne = new Array(J.bitLength()), A = 0; A < ne.length; A++) {
        var I = A / 26 | 0, U = A % 26;
        ne[A] = (J.words[I] & 1 << U) >>> U;
      }
      return ne;
    }
    g.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var J = 0, ne = 0; ne < this.length; ne++) {
        var A = this._zeroBits(this.words[ne]);
        if (J += A, A !== 26)
          break;
      }
      return J;
    }, g.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, g.prototype.toTwos = function(J) {
      return this.negative !== 0 ? this.abs().inotn(J).iaddn(1) : this.clone();
    }, g.prototype.fromTwos = function(J) {
      return this.testn(J - 1) ? this.notn(J).iaddn(1).ineg() : this.clone();
    }, g.prototype.isNeg = function() {
      return this.negative !== 0;
    }, g.prototype.neg = function() {
      return this.clone().ineg();
    }, g.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, g.prototype.iuor = function(J) {
      for (; this.length < J.length; )
        this.words[this.length++] = 0;
      for (var ne = 0; ne < J.length; ne++)
        this.words[ne] = this.words[ne] | J.words[ne];
      return this.strip();
    }, g.prototype.ior = function(J) {
      return o((this.negative | J.negative) === 0), this.iuor(J);
    }, g.prototype.or = function(J) {
      return this.length > J.length ? this.clone().ior(J) : J.clone().ior(this);
    }, g.prototype.uor = function(J) {
      return this.length > J.length ? this.clone().iuor(J) : J.clone().iuor(this);
    }, g.prototype.iuand = function(J) {
      var ne;
      this.length > J.length ? ne = J : ne = this;
      for (var A = 0; A < ne.length; A++)
        this.words[A] = this.words[A] & J.words[A];
      return this.length = ne.length, this.strip();
    }, g.prototype.iand = function(J) {
      return o((this.negative | J.negative) === 0), this.iuand(J);
    }, g.prototype.and = function(J) {
      return this.length > J.length ? this.clone().iand(J) : J.clone().iand(this);
    }, g.prototype.uand = function(J) {
      return this.length > J.length ? this.clone().iuand(J) : J.clone().iuand(this);
    }, g.prototype.iuxor = function(J) {
      var ne, A;
      this.length > J.length ? (ne = this, A = J) : (ne = J, A = this);
      for (var I = 0; I < A.length; I++)
        this.words[I] = ne.words[I] ^ A.words[I];
      if (this !== ne)
        for (; I < ne.length; I++)
          this.words[I] = ne.words[I];
      return this.length = ne.length, this.strip();
    }, g.prototype.ixor = function(J) {
      return o((this.negative | J.negative) === 0), this.iuxor(J);
    }, g.prototype.xor = function(J) {
      return this.length > J.length ? this.clone().ixor(J) : J.clone().ixor(this);
    }, g.prototype.uxor = function(J) {
      return this.length > J.length ? this.clone().iuxor(J) : J.clone().iuxor(this);
    }, g.prototype.inotn = function(J) {
      o(typeof J == "number" && J >= 0);
      var ne = Math.ceil(J / 26) | 0, A = J % 26;
      this._expand(ne), A > 0 && ne--;
      for (var I = 0; I < ne; I++)
        this.words[I] = ~this.words[I] & 67108863;
      return A > 0 && (this.words[I] = ~this.words[I] & 67108863 >> 26 - A), this.strip();
    }, g.prototype.notn = function(J) {
      return this.clone().inotn(J);
    }, g.prototype.setn = function(J, ne) {
      o(typeof J == "number" && J >= 0);
      var A = J / 26 | 0, I = J % 26;
      return this._expand(A + 1), ne ? this.words[A] = this.words[A] | 1 << I : this.words[A] = this.words[A] & ~(1 << I), this.strip();
    }, g.prototype.iadd = function(J) {
      var ne;
      if (this.negative !== 0 && J.negative === 0)
        return this.negative = 0, ne = this.isub(J), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && J.negative !== 0)
        return J.negative = 0, ne = this.isub(J), J.negative = 1, ne._normSign();
      var A, I;
      this.length > J.length ? (A = this, I = J) : (A = J, I = this);
      for (var U = 0, X = 0; X < I.length; X++)
        ne = (A.words[X] | 0) + (I.words[X] | 0) + U, this.words[X] = ne & 67108863, U = ne >>> 26;
      for (; U !== 0 && X < A.length; X++)
        ne = (A.words[X] | 0) + U, this.words[X] = ne & 67108863, U = ne >>> 26;
      if (this.length = A.length, U !== 0)
        this.words[this.length] = U, this.length++;
      else if (A !== this)
        for (; X < A.length; X++)
          this.words[X] = A.words[X];
      return this;
    }, g.prototype.add = function(J) {
      var ne;
      return J.negative !== 0 && this.negative === 0 ? (J.negative = 0, ne = this.sub(J), J.negative ^= 1, ne) : J.negative === 0 && this.negative !== 0 ? (this.negative = 0, ne = J.sub(this), this.negative = 1, ne) : this.length > J.length ? this.clone().iadd(J) : J.clone().iadd(this);
    }, g.prototype.isub = function(J) {
      if (J.negative !== 0) {
        J.negative = 0;
        var ne = this.iadd(J);
        return J.negative = 1, ne._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(J), this.negative = 1, this._normSign();
      var A = this.cmp(J);
      if (A === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var I, U;
      A > 0 ? (I = this, U = J) : (I = J, U = this);
      for (var X = 0, Q = 0; Q < U.length; Q++)
        ne = (I.words[Q] | 0) - (U.words[Q] | 0) + X, X = ne >> 26, this.words[Q] = ne & 67108863;
      for (; X !== 0 && Q < I.length; Q++)
        ne = (I.words[Q] | 0) + X, X = ne >> 26, this.words[Q] = ne & 67108863;
      if (X === 0 && Q < I.length && I !== this)
        for (; Q < I.length; Q++)
          this.words[Q] = I.words[Q];
      return this.length = Math.max(this.length, Q), I !== this && (this.negative = 1), this.strip();
    }, g.prototype.sub = function(J) {
      return this.clone().isub(J);
    };
    function ie(J, ne, A) {
      A.negative = ne.negative ^ J.negative;
      var I = J.length + ne.length | 0;
      A.length = I, I = I - 1 | 0;
      var U = J.words[0] | 0, X = ne.words[0] | 0, Q = U * X, F = Q & 67108863, $ = Q / 67108864 | 0;
      A.words[0] = F;
      for (var H = 1; H < I; H++) {
        for (var q = $ >>> 26, z = $ & 67108863, me = Math.min(H, ne.length - 1), Ce = Math.max(0, H - J.length + 1); Ce <= me; Ce++) {
          var je = H - Ce | 0;
          U = J.words[je] | 0, X = ne.words[Ce] | 0, Q = U * X + z, q += Q / 67108864 | 0, z = Q & 67108863;
        }
        A.words[H] = z | 0, $ = q | 0;
      }
      return $ !== 0 ? A.words[H] = $ | 0 : A.length--, A.strip();
    }
    var ue = function(J, ne, A) {
      var I = J.words, U = ne.words, X = A.words, Q = 0, F, $, H, q = I[0] | 0, z = q & 8191, me = q >>> 13, Ce = I[1] | 0, je = Ce & 8191, Re = Ce >>> 13, Ae = I[2] | 0, ke = Ae & 8191, Qe = Ae >>> 13, Ze = I[3] | 0, qe = Ze & 8191, Oe = Ze >>> 13, Xe = I[4] | 0, et = Xe & 8191, nt = Xe >>> 13, re = I[5] | 0, oe = re & 8191, le = re >>> 13, ge = I[6] | 0, Ke = ge & 8191, Je = ge >>> 13, Fe = I[7] | 0, Ye = Fe & 8191, it = Fe >>> 13, rt = I[8] | 0, tt = rt & 8191, vt = rt >>> 13, St = I[9] | 0, ot = St & 8191, si = St >>> 13, oi = U[0] | 0, At = oi & 8191, Nn = oi >>> 13, ui = U[1] | 0, Bt = ui & 8191, vi = ui >>> 13, fi = U[2] | 0, Ct = fi & 8191, rM = fi >>> 13, hi = U[3] | 0, Tt = hi & 8191, Dn = hi >>> 13, di = U[4] | 0, Ot = di & 8191, iM = di >>> 13, ci = U[5] | 0, Dt = ci & 8191, nM = ci >>> 13, li = U[6] | 0, ri = li & 8191, eM = li >>> 13, ai = U[7] | 0, It = ai & 8191, tM = ai >>> 13, pi = U[8] | 0, ii = pi & 8191, oM = pi >>> 13, gi = U[9] | 0, ni = gi & 8191, aM = gi >>> 13;
      A.negative = J.negative ^ ne.negative, A.length = 19, F = Math.imul(z, At), $ = Math.imul(z, Nn), $ = $ + Math.imul(me, At) | 0, H = Math.imul(me, Nn);
      var yi = (Q + F | 0) + (($ & 8191) << 13) | 0;
      Q = (H + ($ >>> 13) | 0) + (yi >>> 26) | 0, yi &= 67108863, F = Math.imul(je, At), $ = Math.imul(je, Nn), $ = $ + Math.imul(Re, At) | 0, H = Math.imul(Re, Nn), F = F + Math.imul(z, Bt) | 0, $ = $ + Math.imul(z, vi) | 0, $ = $ + Math.imul(me, Bt) | 0, H = H + Math.imul(me, vi) | 0;
      var mi = (Q + F | 0) + (($ & 8191) << 13) | 0;
      Q = (H + ($ >>> 13) | 0) + (mi >>> 26) | 0, mi &= 67108863, F = Math.imul(ke, At), $ = Math.imul(ke, Nn), $ = $ + Math.imul(Qe, At) | 0, H = Math.imul(Qe, Nn), F = F + Math.imul(je, Bt) | 0, $ = $ + Math.imul(je, vi) | 0, $ = $ + Math.imul(Re, Bt) | 0, H = H + Math.imul(Re, vi) | 0, F = F + Math.imul(z, Ct) | 0, $ = $ + Math.imul(z, rM) | 0, $ = $ + Math.imul(me, Ct) | 0, H = H + Math.imul(me, rM) | 0;
      var sM = (Q + F | 0) + (($ & 8191) << 13) | 0;
      Q = (H + ($ >>> 13) | 0) + (sM >>> 26) | 0, sM &= 67108863, F = Math.imul(qe, At), $ = Math.imul(qe, Nn), $ = $ + Math.imul(Oe, At) | 0, H = Math.imul(Oe, Nn), F = F + Math.imul(ke, Bt) | 0, $ = $ + Math.imul(ke, vi) | 0, $ = $ + Math.imul(Qe, Bt) | 0, H = H + Math.imul(Qe, vi) | 0, F = F + Math.imul(je, Ct) | 0, $ = $ + Math.imul(je, rM) | 0, $ = $ + Math.imul(Re, Ct) | 0, H = H + Math.imul(Re, rM) | 0, F = F + Math.imul(z, Tt) | 0, $ = $ + Math.imul(z, Dn) | 0, $ = $ + Math.imul(me, Tt) | 0, H = H + Math.imul(me, Dn) | 0;
      var uM = (Q + F | 0) + (($ & 8191) << 13) | 0;
      Q = (H + ($ >>> 13) | 0) + (uM >>> 26) | 0, uM &= 67108863, F = Math.imul(et, At), $ = Math.imul(et, Nn), $ = $ + Math.imul(nt, At) | 0, H = Math.imul(nt, Nn), F = F + Math.imul(qe, Bt) | 0, $ = $ + Math.imul(qe, vi) | 0, $ = $ + Math.imul(Oe, Bt) | 0, H = H + Math.imul(Oe, vi) | 0, F = F + Math.imul(ke, Ct) | 0, $ = $ + Math.imul(ke, rM) | 0, $ = $ + Math.imul(Qe, Ct) | 0, H = H + Math.imul(Qe, rM) | 0, F = F + Math.imul(je, Tt) | 0, $ = $ + Math.imul(je, Dn) | 0, $ = $ + Math.imul(Re, Tt) | 0, H = H + Math.imul(Re, Dn) | 0, F = F + Math.imul(z, Ot) | 0, $ = $ + Math.imul(z, iM) | 0, $ = $ + Math.imul(me, Ot) | 0, H = H + Math.imul(me, iM) | 0;
      var fM = (Q + F | 0) + (($ & 8191) << 13) | 0;
      Q = (H + ($ >>> 13) | 0) + (fM >>> 26) | 0, fM &= 67108863, F = Math.imul(oe, At), $ = Math.imul(oe, Nn), $ = $ + Math.imul(le, At) | 0, H = Math.imul(le, Nn), F = F + Math.imul(et, Bt) | 0, $ = $ + Math.imul(et, vi) | 0, $ = $ + Math.imul(nt, Bt) | 0, H = H + Math.imul(nt, vi) | 0, F = F + Math.imul(qe, Ct) | 0, $ = $ + Math.imul(qe, rM) | 0, $ = $ + Math.imul(Oe, Ct) | 0, H = H + Math.imul(Oe, rM) | 0, F = F + Math.imul(ke, Tt) | 0, $ = $ + Math.imul(ke, Dn) | 0, $ = $ + Math.imul(Qe, Tt) | 0, H = H + Math.imul(Qe, Dn) | 0, F = F + Math.imul(je, Ot) | 0, $ = $ + Math.imul(je, iM) | 0, $ = $ + Math.imul(Re, Ot) | 0, H = H + Math.imul(Re, iM) | 0, F = F + Math.imul(z, Dt) | 0, $ = $ + Math.imul(z, nM) | 0, $ = $ + Math.imul(me, Dt) | 0, H = H + Math.imul(me, nM) | 0;
      var hM = (Q + F | 0) + (($ & 8191) << 13) | 0;
      Q = (H + ($ >>> 13) | 0) + (hM >>> 26) | 0, hM &= 67108863, F = Math.imul(Ke, At), $ = Math.imul(Ke, Nn), $ = $ + Math.imul(Je, At) | 0, H = Math.imul(Je, Nn), F = F + Math.imul(oe, Bt) | 0, $ = $ + Math.imul(oe, vi) | 0, $ = $ + Math.imul(le, Bt) | 0, H = H + Math.imul(le, vi) | 0, F = F + Math.imul(et, Ct) | 0, $ = $ + Math.imul(et, rM) | 0, $ = $ + Math.imul(nt, Ct) | 0, H = H + Math.imul(nt, rM) | 0, F = F + Math.imul(qe, Tt) | 0, $ = $ + Math.imul(qe, Dn) | 0, $ = $ + Math.imul(Oe, Tt) | 0, H = H + Math.imul(Oe, Dn) | 0, F = F + Math.imul(ke, Ot) | 0, $ = $ + Math.imul(ke, iM) | 0, $ = $ + Math.imul(Qe, Ot) | 0, H = H + Math.imul(Qe, iM) | 0, F = F + Math.imul(je, Dt) | 0, $ = $ + Math.imul(je, nM) | 0, $ = $ + Math.imul(Re, Dt) | 0, H = H + Math.imul(Re, nM) | 0, F = F + Math.imul(z, ri) | 0, $ = $ + Math.imul(z, eM) | 0, $ = $ + Math.imul(me, ri) | 0, H = H + Math.imul(me, eM) | 0;
      var cM = (Q + F | 0) + (($ & 8191) << 13) | 0;
      Q = (H + ($ >>> 13) | 0) + (cM >>> 26) | 0, cM &= 67108863, F = Math.imul(Ye, At), $ = Math.imul(Ye, Nn), $ = $ + Math.imul(it, At) | 0, H = Math.imul(it, Nn), F = F + Math.imul(Ke, Bt) | 0, $ = $ + Math.imul(Ke, vi) | 0, $ = $ + Math.imul(Je, Bt) | 0, H = H + Math.imul(Je, vi) | 0, F = F + Math.imul(oe, Ct) | 0, $ = $ + Math.imul(oe, rM) | 0, $ = $ + Math.imul(le, Ct) | 0, H = H + Math.imul(le, rM) | 0, F = F + Math.imul(et, Tt) | 0, $ = $ + Math.imul(et, Dn) | 0, $ = $ + Math.imul(nt, Tt) | 0, H = H + Math.imul(nt, Dn) | 0, F = F + Math.imul(qe, Ot) | 0, $ = $ + Math.imul(qe, iM) | 0, $ = $ + Math.imul(Oe, Ot) | 0, H = H + Math.imul(Oe, iM) | 0, F = F + Math.imul(ke, Dt) | 0, $ = $ + Math.imul(ke, nM) | 0, $ = $ + Math.imul(Qe, Dt) | 0, H = H + Math.imul(Qe, nM) | 0, F = F + Math.imul(je, ri) | 0, $ = $ + Math.imul(je, eM) | 0, $ = $ + Math.imul(Re, ri) | 0, H = H + Math.imul(Re, eM) | 0, F = F + Math.imul(z, It) | 0, $ = $ + Math.imul(z, tM) | 0, $ = $ + Math.imul(me, It) | 0, H = H + Math.imul(me, tM) | 0;
      var lM = (Q + F | 0) + (($ & 8191) << 13) | 0;
      Q = (H + ($ >>> 13) | 0) + (lM >>> 26) | 0, lM &= 67108863, F = Math.imul(tt, At), $ = Math.imul(tt, Nn), $ = $ + Math.imul(vt, At) | 0, H = Math.imul(vt, Nn), F = F + Math.imul(Ye, Bt) | 0, $ = $ + Math.imul(Ye, vi) | 0, $ = $ + Math.imul(it, Bt) | 0, H = H + Math.imul(it, vi) | 0, F = F + Math.imul(Ke, Ct) | 0, $ = $ + Math.imul(Ke, rM) | 0, $ = $ + Math.imul(Je, Ct) | 0, H = H + Math.imul(Je, rM) | 0, F = F + Math.imul(oe, Tt) | 0, $ = $ + Math.imul(oe, Dn) | 0, $ = $ + Math.imul(le, Tt) | 0, H = H + Math.imul(le, Dn) | 0, F = F + Math.imul(et, Ot) | 0, $ = $ + Math.imul(et, iM) | 0, $ = $ + Math.imul(nt, Ot) | 0, H = H + Math.imul(nt, iM) | 0, F = F + Math.imul(qe, Dt) | 0, $ = $ + Math.imul(qe, nM) | 0, $ = $ + Math.imul(Oe, Dt) | 0, H = H + Math.imul(Oe, nM) | 0, F = F + Math.imul(ke, ri) | 0, $ = $ + Math.imul(ke, eM) | 0, $ = $ + Math.imul(Qe, ri) | 0, H = H + Math.imul(Qe, eM) | 0, F = F + Math.imul(je, It) | 0, $ = $ + Math.imul(je, tM) | 0, $ = $ + Math.imul(Re, It) | 0, H = H + Math.imul(Re, tM) | 0, F = F + Math.imul(z, ii) | 0, $ = $ + Math.imul(z, oM) | 0, $ = $ + Math.imul(me, ii) | 0, H = H + Math.imul(me, oM) | 0;
      var dM = (Q + F | 0) + (($ & 8191) << 13) | 0;
      Q = (H + ($ >>> 13) | 0) + (dM >>> 26) | 0, dM &= 67108863, F = Math.imul(ot, At), $ = Math.imul(ot, Nn), $ = $ + Math.imul(si, At) | 0, H = Math.imul(si, Nn), F = F + Math.imul(tt, Bt) | 0, $ = $ + Math.imul(tt, vi) | 0, $ = $ + Math.imul(vt, Bt) | 0, H = H + Math.imul(vt, vi) | 0, F = F + Math.imul(Ye, Ct) | 0, $ = $ + Math.imul(Ye, rM) | 0, $ = $ + Math.imul(it, Ct) | 0, H = H + Math.imul(it, rM) | 0, F = F + Math.imul(Ke, Tt) | 0, $ = $ + Math.imul(Ke, Dn) | 0, $ = $ + Math.imul(Je, Tt) | 0, H = H + Math.imul(Je, Dn) | 0, F = F + Math.imul(oe, Ot) | 0, $ = $ + Math.imul(oe, iM) | 0, $ = $ + Math.imul(le, Ot) | 0, H = H + Math.imul(le, iM) | 0, F = F + Math.imul(et, Dt) | 0, $ = $ + Math.imul(et, nM) | 0, $ = $ + Math.imul(nt, Dt) | 0, H = H + Math.imul(nt, nM) | 0, F = F + Math.imul(qe, ri) | 0, $ = $ + Math.imul(qe, eM) | 0, $ = $ + Math.imul(Oe, ri) | 0, H = H + Math.imul(Oe, eM) | 0, F = F + Math.imul(ke, It) | 0, $ = $ + Math.imul(ke, tM) | 0, $ = $ + Math.imul(Qe, It) | 0, H = H + Math.imul(Qe, tM) | 0, F = F + Math.imul(je, ii) | 0, $ = $ + Math.imul(je, oM) | 0, $ = $ + Math.imul(Re, ii) | 0, H = H + Math.imul(Re, oM) | 0, F = F + Math.imul(z, ni) | 0, $ = $ + Math.imul(z, aM) | 0, $ = $ + Math.imul(me, ni) | 0, H = H + Math.imul(me, aM) | 0;
      var pM = (Q + F | 0) + (($ & 8191) << 13) | 0;
      Q = (H + ($ >>> 13) | 0) + (pM >>> 26) | 0, pM &= 67108863, F = Math.imul(ot, Bt), $ = Math.imul(ot, vi), $ = $ + Math.imul(si, Bt) | 0, H = Math.imul(si, vi), F = F + Math.imul(tt, Ct) | 0, $ = $ + Math.imul(tt, rM) | 0, $ = $ + Math.imul(vt, Ct) | 0, H = H + Math.imul(vt, rM) | 0, F = F + Math.imul(Ye, Tt) | 0, $ = $ + Math.imul(Ye, Dn) | 0, $ = $ + Math.imul(it, Tt) | 0, H = H + Math.imul(it, Dn) | 0, F = F + Math.imul(Ke, Ot) | 0, $ = $ + Math.imul(Ke, iM) | 0, $ = $ + Math.imul(Je, Ot) | 0, H = H + Math.imul(Je, iM) | 0, F = F + Math.imul(oe, Dt) | 0, $ = $ + Math.imul(oe, nM) | 0, $ = $ + Math.imul(le, Dt) | 0, H = H + Math.imul(le, nM) | 0, F = F + Math.imul(et, ri) | 0, $ = $ + Math.imul(et, eM) | 0, $ = $ + Math.imul(nt, ri) | 0, H = H + Math.imul(nt, eM) | 0, F = F + Math.imul(qe, It) | 0, $ = $ + Math.imul(qe, tM) | 0, $ = $ + Math.imul(Oe, It) | 0, H = H + Math.imul(Oe, tM) | 0, F = F + Math.imul(ke, ii) | 0, $ = $ + Math.imul(ke, oM) | 0, $ = $ + Math.imul(Qe, ii) | 0, H = H + Math.imul(Qe, oM) | 0, F = F + Math.imul(je, ni) | 0, $ = $ + Math.imul(je, aM) | 0, $ = $ + Math.imul(Re, ni) | 0, H = H + Math.imul(Re, aM) | 0;
      var yM = (Q + F | 0) + (($ & 8191) << 13) | 0;
      Q = (H + ($ >>> 13) | 0) + (yM >>> 26) | 0, yM &= 67108863, F = Math.imul(ot, Ct), $ = Math.imul(ot, rM), $ = $ + Math.imul(si, Ct) | 0, H = Math.imul(si, rM), F = F + Math.imul(tt, Tt) | 0, $ = $ + Math.imul(tt, Dn) | 0, $ = $ + Math.imul(vt, Tt) | 0, H = H + Math.imul(vt, Dn) | 0, F = F + Math.imul(Ye, Ot) | 0, $ = $ + Math.imul(Ye, iM) | 0, $ = $ + Math.imul(it, Ot) | 0, H = H + Math.imul(it, iM) | 0, F = F + Math.imul(Ke, Dt) | 0, $ = $ + Math.imul(Ke, nM) | 0, $ = $ + Math.imul(Je, Dt) | 0, H = H + Math.imul(Je, nM) | 0, F = F + Math.imul(oe, ri) | 0, $ = $ + Math.imul(oe, eM) | 0, $ = $ + Math.imul(le, ri) | 0, H = H + Math.imul(le, eM) | 0, F = F + Math.imul(et, It) | 0, $ = $ + Math.imul(et, tM) | 0, $ = $ + Math.imul(nt, It) | 0, H = H + Math.imul(nt, tM) | 0, F = F + Math.imul(qe, ii) | 0, $ = $ + Math.imul(qe, oM) | 0, $ = $ + Math.imul(Oe, ii) | 0, H = H + Math.imul(Oe, oM) | 0, F = F + Math.imul(ke, ni) | 0, $ = $ + Math.imul(ke, aM) | 0, $ = $ + Math.imul(Qe, ni) | 0, H = H + Math.imul(Qe, aM) | 0;
      var mM = (Q + F | 0) + (($ & 8191) << 13) | 0;
      Q = (H + ($ >>> 13) | 0) + (mM >>> 26) | 0, mM &= 67108863, F = Math.imul(ot, Tt), $ = Math.imul(ot, Dn), $ = $ + Math.imul(si, Tt) | 0, H = Math.imul(si, Dn), F = F + Math.imul(tt, Ot) | 0, $ = $ + Math.imul(tt, iM) | 0, $ = $ + Math.imul(vt, Ot) | 0, H = H + Math.imul(vt, iM) | 0, F = F + Math.imul(Ye, Dt) | 0, $ = $ + Math.imul(Ye, nM) | 0, $ = $ + Math.imul(it, Dt) | 0, H = H + Math.imul(it, nM) | 0, F = F + Math.imul(Ke, ri) | 0, $ = $ + Math.imul(Ke, eM) | 0, $ = $ + Math.imul(Je, ri) | 0, H = H + Math.imul(Je, eM) | 0, F = F + Math.imul(oe, It) | 0, $ = $ + Math.imul(oe, tM) | 0, $ = $ + Math.imul(le, It) | 0, H = H + Math.imul(le, tM) | 0, F = F + Math.imul(et, ii) | 0, $ = $ + Math.imul(et, oM) | 0, $ = $ + Math.imul(nt, ii) | 0, H = H + Math.imul(nt, oM) | 0, F = F + Math.imul(qe, ni) | 0, $ = $ + Math.imul(qe, aM) | 0, $ = $ + Math.imul(Oe, ni) | 0, H = H + Math.imul(Oe, aM) | 0;
      var gM = (Q + F | 0) + (($ & 8191) << 13) | 0;
      Q = (H + ($ >>> 13) | 0) + (gM >>> 26) | 0, gM &= 67108863, F = Math.imul(ot, Ot), $ = Math.imul(ot, iM), $ = $ + Math.imul(si, Ot) | 0, H = Math.imul(si, iM), F = F + Math.imul(tt, Dt) | 0, $ = $ + Math.imul(tt, nM) | 0, $ = $ + Math.imul(vt, Dt) | 0, H = H + Math.imul(vt, nM) | 0, F = F + Math.imul(Ye, ri) | 0, $ = $ + Math.imul(Ye, eM) | 0, $ = $ + Math.imul(it, ri) | 0, H = H + Math.imul(it, eM) | 0, F = F + Math.imul(Ke, It) | 0, $ = $ + Math.imul(Ke, tM) | 0, $ = $ + Math.imul(Je, It) | 0, H = H + Math.imul(Je, tM) | 0, F = F + Math.imul(oe, ii) | 0, $ = $ + Math.imul(oe, oM) | 0, $ = $ + Math.imul(le, ii) | 0, H = H + Math.imul(le, oM) | 0, F = F + Math.imul(et, ni) | 0, $ = $ + Math.imul(et, aM) | 0, $ = $ + Math.imul(nt, ni) | 0, H = H + Math.imul(nt, aM) | 0;
      var bM = (Q + F | 0) + (($ & 8191) << 13) | 0;
      Q = (H + ($ >>> 13) | 0) + (bM >>> 26) | 0, bM &= 67108863, F = Math.imul(ot, Dt), $ = Math.imul(ot, nM), $ = $ + Math.imul(si, Dt) | 0, H = Math.imul(si, nM), F = F + Math.imul(tt, ri) | 0, $ = $ + Math.imul(tt, eM) | 0, $ = $ + Math.imul(vt, ri) | 0, H = H + Math.imul(vt, eM) | 0, F = F + Math.imul(Ye, It) | 0, $ = $ + Math.imul(Ye, tM) | 0, $ = $ + Math.imul(it, It) | 0, H = H + Math.imul(it, tM) | 0, F = F + Math.imul(Ke, ii) | 0, $ = $ + Math.imul(Ke, oM) | 0, $ = $ + Math.imul(Je, ii) | 0, H = H + Math.imul(Je, oM) | 0, F = F + Math.imul(oe, ni) | 0, $ = $ + Math.imul(oe, aM) | 0, $ = $ + Math.imul(le, ni) | 0, H = H + Math.imul(le, aM) | 0;
      var vM = (Q + F | 0) + (($ & 8191) << 13) | 0;
      Q = (H + ($ >>> 13) | 0) + (vM >>> 26) | 0, vM &= 67108863, F = Math.imul(ot, ri), $ = Math.imul(ot, eM), $ = $ + Math.imul(si, ri) | 0, H = Math.imul(si, eM), F = F + Math.imul(tt, It) | 0, $ = $ + Math.imul(tt, tM) | 0, $ = $ + Math.imul(vt, It) | 0, H = H + Math.imul(vt, tM) | 0, F = F + Math.imul(Ye, ii) | 0, $ = $ + Math.imul(Ye, oM) | 0, $ = $ + Math.imul(it, ii) | 0, H = H + Math.imul(it, oM) | 0, F = F + Math.imul(Ke, ni) | 0, $ = $ + Math.imul(Ke, aM) | 0, $ = $ + Math.imul(Je, ni) | 0, H = H + Math.imul(Je, aM) | 0;
      var wM = (Q + F | 0) + (($ & 8191) << 13) | 0;
      Q = (H + ($ >>> 13) | 0) + (wM >>> 26) | 0, wM &= 67108863, F = Math.imul(ot, It), $ = Math.imul(ot, tM), $ = $ + Math.imul(si, It) | 0, H = Math.imul(si, tM), F = F + Math.imul(tt, ii) | 0, $ = $ + Math.imul(tt, oM) | 0, $ = $ + Math.imul(vt, ii) | 0, H = H + Math.imul(vt, oM) | 0, F = F + Math.imul(Ye, ni) | 0, $ = $ + Math.imul(Ye, aM) | 0, $ = $ + Math.imul(it, ni) | 0, H = H + Math.imul(it, aM) | 0;
      var _M = (Q + F | 0) + (($ & 8191) << 13) | 0;
      Q = (H + ($ >>> 13) | 0) + (_M >>> 26) | 0, _M &= 67108863, F = Math.imul(ot, ii), $ = Math.imul(ot, oM), $ = $ + Math.imul(si, ii) | 0, H = Math.imul(si, oM), F = F + Math.imul(tt, ni) | 0, $ = $ + Math.imul(tt, aM) | 0, $ = $ + Math.imul(vt, ni) | 0, H = H + Math.imul(vt, aM) | 0;
      var SM = (Q + F | 0) + (($ & 8191) << 13) | 0;
      Q = (H + ($ >>> 13) | 0) + (SM >>> 26) | 0, SM &= 67108863, F = Math.imul(ot, ni), $ = Math.imul(ot, aM), $ = $ + Math.imul(si, ni) | 0, H = Math.imul(si, aM);
      var EM = (Q + F | 0) + (($ & 8191) << 13) | 0;
      return Q = (H + ($ >>> 13) | 0) + (EM >>> 26) | 0, EM &= 67108863, X[0] = yi, X[1] = mi, X[2] = sM, X[3] = uM, X[4] = fM, X[5] = hM, X[6] = cM, X[7] = lM, X[8] = dM, X[9] = pM, X[10] = yM, X[11] = mM, X[12] = gM, X[13] = bM, X[14] = vM, X[15] = wM, X[16] = _M, X[17] = SM, X[18] = EM, Q !== 0 && (X[19] = Q, A.length++), A;
    };
    Math.imul || (ue = ie);
    function fe(J, ne, A) {
      A.negative = ne.negative ^ J.negative, A.length = J.length + ne.length;
      for (var I = 0, U = 0, X = 0; X < A.length - 1; X++) {
        var Q = U;
        U = 0;
        for (var F = I & 67108863, $ = Math.min(X, ne.length - 1), H = Math.max(0, X - J.length + 1); H <= $; H++) {
          var q = X - H, z = J.words[q] | 0, me = ne.words[H] | 0, Ce = z * me, je = Ce & 67108863;
          Q = Q + (Ce / 67108864 | 0) | 0, je = je + F | 0, F = je & 67108863, Q = Q + (je >>> 26) | 0, U += Q >>> 26, Q &= 67108863;
        }
        A.words[X] = F, I = Q, Q = U;
      }
      return I !== 0 ? A.words[X] = I : A.length--, A.strip();
    }
    function de(J, ne, A) {
      var I = new ce();
      return I.mulp(J, ne, A);
    }
    g.prototype.mulTo = function(J, ne) {
      var A, I = this.length + J.length;
      return this.length === 10 && J.length === 10 ? A = ue(this, J, ne) : I < 63 ? A = ie(this, J, ne) : I < 1024 ? A = fe(this, J, ne) : A = de(this, J, ne), A;
    };
    function ce(J, ne) {
      this.x = J, this.y = ne;
    }
    ce.prototype.makeRBT = function(J) {
      for (var ne = new Array(J), A = g.prototype._countBits(J) - 1, I = 0; I < J; I++)
        ne[I] = this.revBin(I, A, J);
      return ne;
    }, ce.prototype.revBin = function(J, ne, A) {
      if (J === 0 || J === A - 1)
        return J;
      for (var I = 0, U = 0; U < ne; U++)
        I |= (J & 1) << ne - U - 1, J >>= 1;
      return I;
    }, ce.prototype.permute = function(J, ne, A, I, U, X) {
      for (var Q = 0; Q < X; Q++)
        I[Q] = ne[J[Q]], U[Q] = A[J[Q]];
    }, ce.prototype.transform = function(J, ne, A, I, U, X) {
      this.permute(X, J, ne, A, I, U);
      for (var Q = 1; Q < U; Q <<= 1)
        for (var F = Q << 1, $ = Math.cos(2 * Math.PI / F), H = Math.sin(2 * Math.PI / F), q = 0; q < U; q += F)
          for (var z = $, me = H, Ce = 0; Ce < Q; Ce++) {
            var je = A[q + Ce], Re = I[q + Ce], Ae = A[q + Ce + Q], ke = I[q + Ce + Q], Qe = z * Ae - me * ke;
            ke = z * ke + me * Ae, Ae = Qe, A[q + Ce] = je + Ae, I[q + Ce] = Re + ke, A[q + Ce + Q] = je - Ae, I[q + Ce + Q] = Re - ke, Ce !== F && (Qe = $ * z - H * me, me = $ * me + H * z, z = Qe);
          }
    }, ce.prototype.guessLen13b = function(J, ne) {
      var A = Math.max(ne, J) | 1, I = A & 1, U = 0;
      for (A = A / 2 | 0; A; A = A >>> 1)
        U++;
      return 1 << U + 1 + I;
    }, ce.prototype.conjugate = function(J, ne, A) {
      if (!(A <= 1))
        for (var I = 0; I < A / 2; I++) {
          var U = J[I];
          J[I] = J[A - I - 1], J[A - I - 1] = U, U = ne[I], ne[I] = -ne[A - I - 1], ne[A - I - 1] = -U;
        }
    }, ce.prototype.normalize13b = function(J, ne) {
      for (var A = 0, I = 0; I < ne / 2; I++) {
        var U = Math.round(J[2 * I + 1] / ne) * 8192 + Math.round(J[2 * I] / ne) + A;
        J[I] = U & 67108863, U < 67108864 ? A = 0 : A = U / 67108864 | 0;
      }
      return J;
    }, ce.prototype.convert13b = function(J, ne, A, I) {
      for (var U = 0, X = 0; X < ne; X++)
        U = U + (J[X] | 0), A[2 * X] = U & 8191, U = U >>> 13, A[2 * X + 1] = U & 8191, U = U >>> 13;
      for (X = 2 * ne; X < I; ++X)
        A[X] = 0;
      o(U === 0), o((U & -8192) === 0);
    }, ce.prototype.stub = function(J) {
      for (var ne = new Array(J), A = 0; A < J; A++)
        ne[A] = 0;
      return ne;
    }, ce.prototype.mulp = function(J, ne, A) {
      var I = 2 * this.guessLen13b(J.length, ne.length), U = this.makeRBT(I), X = this.stub(I), Q = new Array(I), F = new Array(I), $ = new Array(I), H = new Array(I), q = new Array(I), z = new Array(I), me = A.words;
      me.length = I, this.convert13b(J.words, J.length, Q, I), this.convert13b(ne.words, ne.length, H, I), this.transform(Q, X, F, $, I, U), this.transform(H, X, q, z, I, U);
      for (var Ce = 0; Ce < I; Ce++) {
        var je = F[Ce] * q[Ce] - $[Ce] * z[Ce];
        $[Ce] = F[Ce] * z[Ce] + $[Ce] * q[Ce], F[Ce] = je;
      }
      return this.conjugate(F, $, I), this.transform(F, $, me, X, I, U), this.conjugate(me, X, I), this.normalize13b(me, I), A.negative = J.negative ^ ne.negative, A.length = J.length + ne.length, A.strip();
    }, g.prototype.mul = function(J) {
      var ne = new g(null);
      return ne.words = new Array(this.length + J.length), this.mulTo(J, ne);
    }, g.prototype.mulf = function(J) {
      var ne = new g(null);
      return ne.words = new Array(this.length + J.length), de(this, J, ne);
    }, g.prototype.imul = function(J) {
      return this.clone().mulTo(J, this);
    }, g.prototype.imuln = function(J) {
      o(typeof J == "number"), o(J < 67108864);
      for (var ne = 0, A = 0; A < this.length; A++) {
        var I = (this.words[A] | 0) * J, U = (I & 67108863) + (ne & 67108863);
        ne >>= 26, ne += I / 67108864 | 0, ne += U >>> 26, this.words[A] = U & 67108863;
      }
      return ne !== 0 && (this.words[A] = ne, this.length++), this;
    }, g.prototype.muln = function(J) {
      return this.clone().imuln(J);
    }, g.prototype.sqr = function() {
      return this.mul(this);
    }, g.prototype.isqr = function() {
      return this.imul(this.clone());
    }, g.prototype.pow = function(J) {
      var ne = ee(J);
      if (ne.length === 0)
        return new g(1);
      for (var A = this, I = 0; I < ne.length && ne[I] === 0; I++, A = A.sqr())
        ;
      if (++I < ne.length)
        for (var U = A.sqr(); I < ne.length; I++, U = U.sqr())
          ne[I] !== 0 && (A = A.mul(U));
      return A;
    }, g.prototype.iushln = function(J) {
      o(typeof J == "number" && J >= 0);
      var ne = J % 26, A = (J - ne) / 26, I = 67108863 >>> 26 - ne << 26 - ne, U;
      if (ne !== 0) {
        var X = 0;
        for (U = 0; U < this.length; U++) {
          var Q = this.words[U] & I, F = (this.words[U] | 0) - Q << ne;
          this.words[U] = F | X, X = Q >>> 26 - ne;
        }
        X && (this.words[U] = X, this.length++);
      }
      if (A !== 0) {
        for (U = this.length - 1; U >= 0; U--)
          this.words[U + A] = this.words[U];
        for (U = 0; U < A; U++)
          this.words[U] = 0;
        this.length += A;
      }
      return this.strip();
    }, g.prototype.ishln = function(J) {
      return o(this.negative === 0), this.iushln(J);
    }, g.prototype.iushrn = function(J, ne, A) {
      o(typeof J == "number" && J >= 0);
      var I;
      ne ? I = (ne - ne % 26) / 26 : I = 0;
      var U = J % 26, X = Math.min((J - U) / 26, this.length), Q = 67108863 ^ 67108863 >>> U << U, F = A;
      if (I -= X, I = Math.max(0, I), F) {
        for (var $ = 0; $ < X; $++)
          F.words[$] = this.words[$];
        F.length = X;
      }
      if (X !== 0)
        if (this.length > X)
          for (this.length -= X, $ = 0; $ < this.length; $++)
            this.words[$] = this.words[$ + X];
        else
          this.words[0] = 0, this.length = 1;
      var H = 0;
      for ($ = this.length - 1; $ >= 0 && (H !== 0 || $ >= I); $--) {
        var q = this.words[$] | 0;
        this.words[$] = H << 26 - U | q >>> U, H = q & Q;
      }
      return F && H !== 0 && (F.words[F.length++] = H), this.length === 0 && (this.words[0] = 0, this.length = 1), this.strip();
    }, g.prototype.ishrn = function(J, ne, A) {
      return o(this.negative === 0), this.iushrn(J, ne, A);
    }, g.prototype.shln = function(J) {
      return this.clone().ishln(J);
    }, g.prototype.ushln = function(J) {
      return this.clone().iushln(J);
    }, g.prototype.shrn = function(J) {
      return this.clone().ishrn(J);
    }, g.prototype.ushrn = function(J) {
      return this.clone().iushrn(J);
    }, g.prototype.testn = function(J) {
      o(typeof J == "number" && J >= 0);
      var ne = J % 26, A = (J - ne) / 26, I = 1 << ne;
      if (this.length <= A)
        return !1;
      var U = this.words[A];
      return !!(U & I);
    }, g.prototype.imaskn = function(J) {
      o(typeof J == "number" && J >= 0);
      var ne = J % 26, A = (J - ne) / 26;
      if (o(this.negative === 0, "imaskn works only with positive numbers"), this.length <= A)
        return this;
      if (ne !== 0 && A++, this.length = Math.min(A, this.length), ne !== 0) {
        var I = 67108863 ^ 67108863 >>> ne << ne;
        this.words[this.length - 1] &= I;
      }
      return this.strip();
    }, g.prototype.maskn = function(J) {
      return this.clone().imaskn(J);
    }, g.prototype.iaddn = function(J) {
      return o(typeof J == "number"), o(J < 67108864), J < 0 ? this.isubn(-J) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) < J ? (this.words[0] = J - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(J), this.negative = 1, this) : this._iaddn(J);
    }, g.prototype._iaddn = function(J) {
      this.words[0] += J;
      for (var ne = 0; ne < this.length && this.words[ne] >= 67108864; ne++)
        this.words[ne] -= 67108864, ne === this.length - 1 ? this.words[ne + 1] = 1 : this.words[ne + 1]++;
      return this.length = Math.max(this.length, ne + 1), this;
    }, g.prototype.isubn = function(J) {
      if (o(typeof J == "number"), o(J < 67108864), J < 0)
        return this.iaddn(-J);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(J), this.negative = 1, this;
      if (this.words[0] -= J, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var ne = 0; ne < this.length && this.words[ne] < 0; ne++)
          this.words[ne] += 67108864, this.words[ne + 1] -= 1;
      return this.strip();
    }, g.prototype.addn = function(J) {
      return this.clone().iaddn(J);
    }, g.prototype.subn = function(J) {
      return this.clone().isubn(J);
    }, g.prototype.iabs = function() {
      return this.negative = 0, this;
    }, g.prototype.abs = function() {
      return this.clone().iabs();
    }, g.prototype._ishlnsubmul = function(J, ne, A) {
      var I = J.length + A, U;
      this._expand(I);
      var X, Q = 0;
      for (U = 0; U < J.length; U++) {
        X = (this.words[U + A] | 0) + Q;
        var F = (J.words[U] | 0) * ne;
        X -= F & 67108863, Q = (X >> 26) - (F / 67108864 | 0), this.words[U + A] = X & 67108863;
      }
      for (; U < this.length - A; U++)
        X = (this.words[U + A] | 0) + Q, Q = X >> 26, this.words[U + A] = X & 67108863;
      if (Q === 0)
        return this.strip();
      for (o(Q === -1), Q = 0, U = 0; U < this.length; U++)
        X = -(this.words[U] | 0) + Q, Q = X >> 26, this.words[U] = X & 67108863;
      return this.negative = 1, this.strip();
    }, g.prototype._wordDiv = function(J, ne) {
      var A = this.length - J.length, I = this.clone(), U = J, X = U.words[U.length - 1] | 0, Q = this._countBits(X);
      A = 26 - Q, A !== 0 && (U = U.ushln(A), I.iushln(A), X = U.words[U.length - 1] | 0);
      var F = I.length - U.length, $;
      if (ne !== "mod") {
        $ = new g(null), $.length = F + 1, $.words = new Array($.length);
        for (var H = 0; H < $.length; H++)
          $.words[H] = 0;
      }
      var q = I.clone()._ishlnsubmul(U, 1, F);
      q.negative === 0 && (I = q, $ && ($.words[F] = 1));
      for (var z = F - 1; z >= 0; z--) {
        var me = (I.words[U.length + z] | 0) * 67108864 + (I.words[U.length + z - 1] | 0);
        for (me = Math.min(me / X | 0, 67108863), I._ishlnsubmul(U, me, z); I.negative !== 0; )
          me--, I.negative = 0, I._ishlnsubmul(U, 1, z), I.isZero() || (I.negative ^= 1);
        $ && ($.words[z] = me);
      }
      return $ && $.strip(), I.strip(), ne !== "div" && A !== 0 && I.iushrn(A), {
        div: $ || null,
        mod: I
      };
    }, g.prototype.divmod = function(J, ne, A) {
      if (o(!J.isZero()), this.isZero())
        return {
          div: new g(0),
          mod: new g(0)
        };
      var I, U, X;
      return this.negative !== 0 && J.negative === 0 ? (X = this.neg().divmod(J, ne), ne !== "mod" && (I = X.div.neg()), ne !== "div" && (U = X.mod.neg(), A && U.negative !== 0 && U.iadd(J)), {
        div: I,
        mod: U
      }) : this.negative === 0 && J.negative !== 0 ? (X = this.divmod(J.neg(), ne), ne !== "mod" && (I = X.div.neg()), {
        div: I,
        mod: X.mod
      }) : this.negative & J.negative ? (X = this.neg().divmod(J.neg(), ne), ne !== "div" && (U = X.mod.neg(), A && U.negative !== 0 && U.isub(J)), {
        div: X.div,
        mod: U
      }) : J.length > this.length || this.cmp(J) < 0 ? {
        div: new g(0),
        mod: this
      } : J.length === 1 ? ne === "div" ? {
        div: this.divn(J.words[0]),
        mod: null
      } : ne === "mod" ? {
        div: null,
        mod: new g(this.modn(J.words[0]))
      } : {
        div: this.divn(J.words[0]),
        mod: new g(this.modn(J.words[0]))
      } : this._wordDiv(J, ne);
    }, g.prototype.div = function(J) {
      return this.divmod(J, "div", !1).div;
    }, g.prototype.mod = function(J) {
      return this.divmod(J, "mod", !1).mod;
    }, g.prototype.umod = function(J) {
      return this.divmod(J, "mod", !0).mod;
    }, g.prototype.divRound = function(J) {
      var ne = this.divmod(J);
      if (ne.mod.isZero())
        return ne.div;
      var A = ne.div.negative !== 0 ? ne.mod.isub(J) : ne.mod, I = J.ushrn(1), U = J.andln(1), X = A.cmp(I);
      return X < 0 || U === 1 && X === 0 ? ne.div : ne.div.negative !== 0 ? ne.div.isubn(1) : ne.div.iaddn(1);
    }, g.prototype.modn = function(J) {
      o(J <= 67108863);
      for (var ne = (1 << 26) % J, A = 0, I = this.length - 1; I >= 0; I--)
        A = (ne * A + (this.words[I] | 0)) % J;
      return A;
    }, g.prototype.idivn = function(J) {
      o(J <= 67108863);
      for (var ne = 0, A = this.length - 1; A >= 0; A--) {
        var I = (this.words[A] | 0) + ne * 67108864;
        this.words[A] = I / J | 0, ne = I % J;
      }
      return this.strip();
    }, g.prototype.divn = function(J) {
      return this.clone().idivn(J);
    }, g.prototype.egcd = function(J) {
      o(J.negative === 0), o(!J.isZero());
      var ne = this, A = J.clone();
      ne.negative !== 0 ? ne = ne.umod(J) : ne = ne.clone();
      for (var I = new g(1), U = new g(0), X = new g(0), Q = new g(1), F = 0; ne.isEven() && A.isEven(); )
        ne.iushrn(1), A.iushrn(1), ++F;
      for (var $ = A.clone(), H = ne.clone(); !ne.isZero(); ) {
        for (var q = 0, z = 1; !(ne.words[0] & z) && q < 26; ++q, z <<= 1)
          ;
        if (q > 0)
          for (ne.iushrn(q); q-- > 0; )
            (I.isOdd() || U.isOdd()) && (I.iadd($), U.isub(H)), I.iushrn(1), U.iushrn(1);
        for (var me = 0, Ce = 1; !(A.words[0] & Ce) && me < 26; ++me, Ce <<= 1)
          ;
        if (me > 0)
          for (A.iushrn(me); me-- > 0; )
            (X.isOdd() || Q.isOdd()) && (X.iadd($), Q.isub(H)), X.iushrn(1), Q.iushrn(1);
        ne.cmp(A) >= 0 ? (ne.isub(A), I.isub(X), U.isub(Q)) : (A.isub(ne), X.isub(I), Q.isub(U));
      }
      return {
        a: X,
        b: Q,
        gcd: A.iushln(F)
      };
    }, g.prototype._invmp = function(J) {
      o(J.negative === 0), o(!J.isZero());
      var ne = this, A = J.clone();
      ne.negative !== 0 ? ne = ne.umod(J) : ne = ne.clone();
      for (var I = new g(1), U = new g(0), X = A.clone(); ne.cmpn(1) > 0 && A.cmpn(1) > 0; ) {
        for (var Q = 0, F = 1; !(ne.words[0] & F) && Q < 26; ++Q, F <<= 1)
          ;
        if (Q > 0)
          for (ne.iushrn(Q); Q-- > 0; )
            I.isOdd() && I.iadd(X), I.iushrn(1);
        for (var $ = 0, H = 1; !(A.words[0] & H) && $ < 26; ++$, H <<= 1)
          ;
        if ($ > 0)
          for (A.iushrn($); $-- > 0; )
            U.isOdd() && U.iadd(X), U.iushrn(1);
        ne.cmp(A) >= 0 ? (ne.isub(A), I.isub(U)) : (A.isub(ne), U.isub(I));
      }
      var q;
      return ne.cmpn(1) === 0 ? q = I : q = U, q.cmpn(0) < 0 && q.iadd(J), q;
    }, g.prototype.gcd = function(J) {
      if (this.isZero())
        return J.abs();
      if (J.isZero())
        return this.abs();
      var ne = this.clone(), A = J.clone();
      ne.negative = 0, A.negative = 0;
      for (var I = 0; ne.isEven() && A.isEven(); I++)
        ne.iushrn(1), A.iushrn(1);
      do {
        for (; ne.isEven(); )
          ne.iushrn(1);
        for (; A.isEven(); )
          A.iushrn(1);
        var U = ne.cmp(A);
        if (U < 0) {
          var X = ne;
          ne = A, A = X;
        } else if (U === 0 || A.cmpn(1) === 0)
          break;
        ne.isub(A);
      } while (!0);
      return A.iushln(I);
    }, g.prototype.invm = function(J) {
      return this.egcd(J).a.umod(J);
    }, g.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, g.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, g.prototype.andln = function(J) {
      return this.words[0] & J;
    }, g.prototype.bincn = function(J) {
      o(typeof J == "number");
      var ne = J % 26, A = (J - ne) / 26, I = 1 << ne;
      if (this.length <= A)
        return this._expand(A + 1), this.words[A] |= I, this;
      for (var U = I, X = A; U !== 0 && X < this.length; X++) {
        var Q = this.words[X] | 0;
        Q += U, U = Q >>> 26, Q &= 67108863, this.words[X] = Q;
      }
      return U !== 0 && (this.words[X] = U, this.length++), this;
    }, g.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, g.prototype.cmpn = function(J) {
      var ne = J < 0;
      if (this.negative !== 0 && !ne)
        return -1;
      if (this.negative === 0 && ne)
        return 1;
      this.strip();
      var A;
      if (this.length > 1)
        A = 1;
      else {
        ne && (J = -J), o(J <= 67108863, "Number is too big");
        var I = this.words[0] | 0;
        A = I === J ? 0 : I < J ? -1 : 1;
      }
      return this.negative !== 0 ? -A | 0 : A;
    }, g.prototype.cmp = function(J) {
      if (this.negative !== 0 && J.negative === 0)
        return -1;
      if (this.negative === 0 && J.negative !== 0)
        return 1;
      var ne = this.ucmp(J);
      return this.negative !== 0 ? -ne | 0 : ne;
    }, g.prototype.ucmp = function(J) {
      if (this.length > J.length)
        return 1;
      if (this.length < J.length)
        return -1;
      for (var ne = 0, A = this.length - 1; A >= 0; A--) {
        var I = this.words[A] | 0, U = J.words[A] | 0;
        if (I !== U) {
          I < U ? ne = -1 : I > U && (ne = 1);
          break;
        }
      }
      return ne;
    }, g.prototype.gtn = function(J) {
      return this.cmpn(J) === 1;
    }, g.prototype.gt = function(J) {
      return this.cmp(J) === 1;
    }, g.prototype.gten = function(J) {
      return this.cmpn(J) >= 0;
    }, g.prototype.gte = function(J) {
      return this.cmp(J) >= 0;
    }, g.prototype.ltn = function(J) {
      return this.cmpn(J) === -1;
    }, g.prototype.lt = function(J) {
      return this.cmp(J) === -1;
    }, g.prototype.lten = function(J) {
      return this.cmpn(J) <= 0;
    }, g.prototype.lte = function(J) {
      return this.cmp(J) <= 0;
    }, g.prototype.eqn = function(J) {
      return this.cmpn(J) === 0;
    }, g.prototype.eq = function(J) {
      return this.cmp(J) === 0;
    }, g.red = function(J) {
      return new Ne(J);
    }, g.prototype.toRed = function(J) {
      return o(!this.red, "Already a number in reduction context"), o(this.negative === 0, "red works only with positives"), J.convertTo(this)._forceRed(J);
    }, g.prototype.fromRed = function() {
      return o(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, g.prototype._forceRed = function(J) {
      return this.red = J, this;
    }, g.prototype.forceRed = function(J) {
      return o(!this.red, "Already a number in reduction context"), this._forceRed(J);
    }, g.prototype.redAdd = function(J) {
      return o(this.red, "redAdd works only with red numbers"), this.red.add(this, J);
    }, g.prototype.redIAdd = function(J) {
      return o(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, J);
    }, g.prototype.redSub = function(J) {
      return o(this.red, "redSub works only with red numbers"), this.red.sub(this, J);
    }, g.prototype.redISub = function(J) {
      return o(this.red, "redISub works only with red numbers"), this.red.isub(this, J);
    }, g.prototype.redShl = function(J) {
      return o(this.red, "redShl works only with red numbers"), this.red.shl(this, J);
    }, g.prototype.redMul = function(J) {
      return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, J), this.red.mul(this, J);
    }, g.prototype.redIMul = function(J) {
      return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, J), this.red.imul(this, J);
    }, g.prototype.redSqr = function() {
      return o(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, g.prototype.redISqr = function() {
      return o(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, g.prototype.redSqrt = function() {
      return o(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, g.prototype.redInvm = function() {
      return o(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, g.prototype.redNeg = function() {
      return o(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, g.prototype.redPow = function(J) {
      return o(this.red && !J.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, J);
    };
    var be = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function ve(J, ne) {
      this.name = J, this.p = new g(ne, 16), this.n = this.p.bitLength(), this.k = new g(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    ve.prototype._tmp = function() {
      var J = new g(null);
      return J.words = new Array(Math.ceil(this.n / 13)), J;
    }, ve.prototype.ireduce = function(J) {
      var ne = J, A;
      do
        this.split(ne, this.tmp), ne = this.imulK(ne), ne = ne.iadd(this.tmp), A = ne.bitLength();
      while (A > this.n);
      var I = A < this.n ? -1 : ne.ucmp(this.p);
      return I === 0 ? (ne.words[0] = 0, ne.length = 1) : I > 0 ? ne.isub(this.p) : ne.strip !== void 0 ? ne.strip() : ne._strip(), ne;
    }, ve.prototype.split = function(J, ne) {
      J.iushrn(this.n, 0, ne);
    }, ve.prototype.imulK = function(J) {
      return J.imul(this.k);
    };
    function Pe() {
      ve.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    S(Pe, ve), Pe.prototype.split = function(J, ne) {
      for (var A = 4194303, I = Math.min(J.length, 9), U = 0; U < I; U++)
        ne.words[U] = J.words[U];
      if (ne.length = I, J.length <= 9) {
        J.words[0] = 0, J.length = 1;
        return;
      }
      var X = J.words[9];
      for (ne.words[ne.length++] = X & A, U = 10; U < J.length; U++) {
        var Q = J.words[U] | 0;
        J.words[U - 10] = (Q & A) << 4 | X >>> 22, X = Q;
      }
      X >>>= 22, J.words[U - 10] = X, X === 0 && J.length > 10 ? J.length -= 10 : J.length -= 9;
    }, Pe.prototype.imulK = function(J) {
      J.words[J.length] = 0, J.words[J.length + 1] = 0, J.length += 2;
      for (var ne = 0, A = 0; A < J.length; A++) {
        var I = J.words[A] | 0;
        ne += I * 977, J.words[A] = ne & 67108863, ne = I * 64 + (ne / 67108864 | 0);
      }
      return J.words[J.length - 1] === 0 && (J.length--, J.words[J.length - 1] === 0 && J.length--), J;
    };
    function Ue() {
      ve.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    S(Ue, ve);
    function ze() {
      ve.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    S(ze, ve);
    function Le() {
      ve.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    S(Le, ve), Le.prototype.imulK = function(J) {
      for (var ne = 0, A = 0; A < J.length; A++) {
        var I = (J.words[A] | 0) * 19 + ne, U = I & 67108863;
        I >>>= 26, J.words[A] = U, ne = I;
      }
      return ne !== 0 && (J.words[J.length++] = ne), J;
    }, g._prime = function(J) {
      if (be[J])
        return be[J];
      var ne;
      if (J === "k256")
        ne = new Pe();
      else if (J === "p224")
        ne = new Ue();
      else if (J === "p192")
        ne = new ze();
      else if (J === "p25519")
        ne = new Le();
      else
        throw new Error("Unknown prime " + J);
      return be[J] = ne, ne;
    };
    function Ne(J) {
      if (typeof J == "string") {
        var ne = g._prime(J);
        this.m = ne.p, this.prime = ne;
      } else
        o(J.gtn(1), "modulus must be greater than 1"), this.m = J, this.prime = null;
    }
    Ne.prototype._verify1 = function(J) {
      o(J.negative === 0, "red works only with positives"), o(J.red, "red works only with red numbers");
    }, Ne.prototype._verify2 = function(J, ne) {
      o((J.negative | ne.negative) === 0, "red works only with positives"), o(
        J.red && J.red === ne.red,
        "red works only with red numbers"
      );
    }, Ne.prototype.imod = function(J) {
      return this.prime ? this.prime.ireduce(J)._forceRed(this) : J.umod(this.m)._forceRed(this);
    }, Ne.prototype.neg = function(J) {
      return J.isZero() ? J.clone() : this.m.sub(J)._forceRed(this);
    }, Ne.prototype.add = function(J, ne) {
      this._verify2(J, ne);
      var A = J.add(ne);
      return A.cmp(this.m) >= 0 && A.isub(this.m), A._forceRed(this);
    }, Ne.prototype.iadd = function(J, ne) {
      this._verify2(J, ne);
      var A = J.iadd(ne);
      return A.cmp(this.m) >= 0 && A.isub(this.m), A;
    }, Ne.prototype.sub = function(J, ne) {
      this._verify2(J, ne);
      var A = J.sub(ne);
      return A.cmpn(0) < 0 && A.iadd(this.m), A._forceRed(this);
    }, Ne.prototype.isub = function(J, ne) {
      this._verify2(J, ne);
      var A = J.isub(ne);
      return A.cmpn(0) < 0 && A.iadd(this.m), A;
    }, Ne.prototype.shl = function(J, ne) {
      return this._verify1(J), this.imod(J.ushln(ne));
    }, Ne.prototype.imul = function(J, ne) {
      return this._verify2(J, ne), this.imod(J.imul(ne));
    }, Ne.prototype.mul = function(J, ne) {
      return this._verify2(J, ne), this.imod(J.mul(ne));
    }, Ne.prototype.isqr = function(J) {
      return this.imul(J, J.clone());
    }, Ne.prototype.sqr = function(J) {
      return this.mul(J, J);
    }, Ne.prototype.sqrt = function(J) {
      if (J.isZero())
        return J.clone();
      var ne = this.m.andln(3);
      if (o(ne % 2 === 1), ne === 3) {
        var A = this.m.add(new g(1)).iushrn(2);
        return this.pow(J, A);
      }
      for (var I = this.m.subn(1), U = 0; !I.isZero() && I.andln(1) === 0; )
        U++, I.iushrn(1);
      o(!I.isZero());
      var X = new g(1).toRed(this), Q = X.redNeg(), F = this.m.subn(1).iushrn(1), $ = this.m.bitLength();
      for ($ = new g(2 * $ * $).toRed(this); this.pow($, F).cmp(Q) !== 0; )
        $.redIAdd(Q);
      for (var H = this.pow($, I), q = this.pow(J, I.addn(1).iushrn(1)), z = this.pow(J, I), me = U; z.cmp(X) !== 0; ) {
        for (var Ce = z, je = 0; Ce.cmp(X) !== 0; je++)
          Ce = Ce.redSqr();
        o(je < me);
        var Re = this.pow(H, new g(1).iushln(me - je - 1));
        q = q.redMul(Re), H = Re.redSqr(), z = z.redMul(H), me = je;
      }
      return q;
    }, Ne.prototype.invm = function(J) {
      var ne = J._invmp(this.m);
      return ne.negative !== 0 ? (ne.negative = 0, this.imod(ne).redNeg()) : this.imod(ne);
    }, Ne.prototype.pow = function(J, ne) {
      if (ne.isZero())
        return new g(1).toRed(this);
      if (ne.cmpn(1) === 0)
        return J.clone();
      var A = 4, I = new Array(1 << A);
      I[0] = new g(1).toRed(this), I[1] = J;
      for (var U = 2; U < I.length; U++)
        I[U] = this.mul(I[U - 1], J);
      var X = I[0], Q = 0, F = 0, $ = ne.bitLength() % 26;
      for ($ === 0 && ($ = 26), U = ne.length - 1; U >= 0; U--) {
        for (var H = ne.words[U], q = $ - 1; q >= 0; q--) {
          var z = H >> q & 1;
          if (X !== I[0] && (X = this.sqr(X)), z === 0 && Q === 0) {
            F = 0;
            continue;
          }
          Q <<= 1, Q |= z, F++, !(F !== A && (U !== 0 || q !== 0)) && (X = this.mul(X, I[Q]), F = 0, Q = 0);
        }
        $ = 26;
      }
      return X;
    }, Ne.prototype.convertTo = function(J) {
      var ne = J.umod(this.m);
      return ne === J ? ne.clone() : ne;
    }, Ne.prototype.convertFrom = function(J) {
      var ne = J.clone();
      return ne.red = null, ne;
    }, g.mont = function(J) {
      return new $e(J);
    };
    function $e(J) {
      Ne.call(this, J), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new g(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    S($e, Ne), $e.prototype.convertTo = function(J) {
      return this.imod(J.ushln(this.shift));
    }, $e.prototype.convertFrom = function(J) {
      var ne = this.imod(J.mul(this.rinv));
      return ne.red = null, ne;
    }, $e.prototype.imul = function(J, ne) {
      if (J.isZero() || ne.isZero())
        return J.words[0] = 0, J.length = 1, J;
      var A = J.imul(ne), I = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), U = A.isub(I).iushrn(this.shift), X = U;
      return U.cmp(this.m) >= 0 ? X = U.isub(this.m) : U.cmpn(0) < 0 && (X = U.iadd(this.m)), X._forceRed(this);
    }, $e.prototype.mul = function(J, ne) {
      if (J.isZero() || ne.isZero())
        return new g(0)._forceRed(this);
      var A = J.mul(ne), I = A.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), U = A.isub(I).iushrn(this.shift), X = U;
      return U.cmp(this.m) >= 0 ? X = U.isub(this.m) : U.cmpn(0) < 0 && (X = U.iadd(this.m)), X._forceRed(this);
    }, $e.prototype.invm = function(J) {
      var ne = this.imod(J._invmp(this.m).mul(this.r2));
      return ne._forceRed(this);
    };
  })(e, Me);
})(ih);
var rr = ih.exports, Z0 = { exports: {} }, Kl;
function nh() {
  if (Kl)
    return Z0.exports;
  Kl = 1;
  var e;
  Z0.exports = function(o) {
    return e || (e = new t(null)), e.generate(o);
  };
  function t(o) {
    this.rand = o;
  }
  if (Z0.exports.Rand = t, t.prototype.generate = function(o) {
    return this._rand(o);
  }, t.prototype._rand = function(o) {
    if (this.rand.getBytes)
      return this.rand.getBytes(o);
    for (var S = new Uint8Array(o), g = 0; g < S.length; g++)
      S[g] = this.rand.getByte();
    return S;
  }, typeof self == "object")
    self.crypto && self.crypto.getRandomValues ? t.prototype._rand = function(o) {
      var S = new Uint8Array(o);
      return self.crypto.getRandomValues(S), S;
    } : self.msCrypto && self.msCrypto.getRandomValues ? t.prototype._rand = function(o) {
      var S = new Uint8Array(o);
      return self.msCrypto.getRandomValues(S), S;
    } : typeof window == "object" && (t.prototype._rand = function() {
      throw new Error("Not implemented yet");
    });
  else
    try {
      var h = _r();
      if (typeof h.randomBytes != "function")
        throw new Error("Not supported");
      t.prototype._rand = function(o) {
        return h.randomBytes(o);
      };
    } catch {
    }
  return Z0.exports;
}
var Eo, $l;
function zv() {
  if ($l)
    return Eo;
  $l = 1;
  var e = rr, t = nh();
  function h(o) {
    this.rand = o || new t.Rand();
  }
  return Eo = h, h.create = function(o) {
    return new h(o);
  }, h.prototype._randbelow = function(o) {
    var S = o.bitLength(), g = Math.ceil(S / 8);
    do
      var B = new e(this.rand.generate(g));
    while (B.cmp(o) >= 0);
    return B;
  }, h.prototype._randrange = function(o, S) {
    var g = S.sub(o);
    return o.add(this._randbelow(g));
  }, h.prototype.test = function(o, S, g) {
    var B = o.bitLength(), M = e.mont(o), O = new e(1).toRed(M);
    S || (S = Math.max(1, B / 48 | 0));
    for (var P = o.subn(1), D = 0; !P.testn(D); D++)
      ;
    for (var Z = o.shrn(D), Y = P.toRed(M), ee = !0; S > 0; S--) {
      var ie = this._randrange(new e(2), P);
      g && g(ie);
      var ue = ie.toRed(M).redPow(Z);
      if (!(ue.cmp(O) === 0 || ue.cmp(Y) === 0)) {
        for (var fe = 1; fe < D; fe++) {
          if (ue = ue.redSqr(), ue.cmp(O) === 0)
            return !1;
          if (ue.cmp(Y) === 0)
            break;
        }
        if (fe === D)
          return !1;
      }
    }
    return ee;
  }, h.prototype.getDivisor = function(o, S) {
    var g = o.bitLength(), B = e.mont(o), M = new e(1).toRed(B);
    S || (S = Math.max(1, g / 48 | 0));
    for (var O = o.subn(1), P = 0; !O.testn(P); P++)
      ;
    for (var D = o.shrn(P), Z = O.toRed(B); S > 0; S--) {
      var Y = this._randrange(new e(2), O), ee = o.gcd(Y);
      if (ee.cmpn(1) !== 0)
        return ee;
      var ie = Y.toRed(B).redPow(D);
      if (!(ie.cmp(M) === 0 || ie.cmp(Z) === 0)) {
        for (var ue = 1; ue < P; ue++) {
          if (ie = ie.redSqr(), ie.cmp(M) === 0)
            return ie.fromRed().subn(1).gcd(o);
          if (ie.cmp(Z) === 0)
            break;
        }
        if (ue === P)
          return ie = ie.redSqr(), ie.fromRed().subn(1).gcd(o);
      }
    }
    return !1;
  }, Eo;
}
var So, Hl;
function jv() {
  if (Hl)
    return So;
  Hl = 1;
  var e = Ua;
  So = fe, fe.simpleSieve = ie, fe.fermatTest = ue;
  var t = rr, h = new t(24), o = zv(), S = new o(), g = new t(1), B = new t(2), M = new t(5);
  new t(16), new t(8);
  var O = new t(10), P = new t(3);
  new t(7);
  var D = new t(11), Z = new t(4);
  new t(12);
  var Y = null;
  function ee() {
    if (Y !== null)
      return Y;
    var de = 1048576, ce = [];
    ce[0] = 2;
    for (var be = 1, ve = 3; ve < de; ve += 2) {
      for (var Pe = Math.ceil(Math.sqrt(ve)), Ue = 0; Ue < be && ce[Ue] <= Pe && ve % ce[Ue] !== 0; Ue++)
        ;
      be !== Ue && ce[Ue] <= Pe || (ce[be++] = ve);
    }
    return Y = ce, ce;
  }
  function ie(de) {
    for (var ce = ee(), be = 0; be < ce.length; be++)
      if (de.modn(ce[be]) === 0)
        return de.cmpn(ce[be]) === 0;
    return !0;
  }
  function ue(de) {
    var ce = t.mont(de);
    return B.toRed(ce).redPow(de.subn(1)).fromRed().cmpn(1) === 0;
  }
  function fe(de, ce) {
    if (de < 16)
      return ce === 2 || ce === 5 ? new t([140, 123]) : new t([140, 39]);
    ce = new t(ce);
    for (var be, ve; ; ) {
      for (be = new t(e(Math.ceil(de / 8))); be.bitLength() > de; )
        be.ishrn(1);
      if (be.isEven() && be.iadd(g), be.testn(1) || be.iadd(B), ce.cmp(B)) {
        if (!ce.cmp(M))
          for (; be.mod(O).cmp(P); )
            be.iadd(Z);
      } else
        for (; be.mod(h).cmp(D); )
          be.iadd(Z);
      if (ve = be.shrn(1), ie(ve) && ie(be) && ue(ve) && ue(be) && S.test(ve) && S.test(be))
        return be;
    }
  }
  return So;
}
const s3 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a63a3620ffffffffffffffff"
}, f3 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece65381ffffffffffffffff"
}, o3 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca237327ffffffffffffffff"
}, u3 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aacaa68ffffffffffffffff"
}, c3 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a93ad2caffffffffffffffff"
}, h3 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c934063199ffffffffffffffff"
}, l3 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dcc4024ffffffffffffffff"
}, d3 = {
  gen: "02",
  prime: "ffffffffffffffffc90fdaa22168c234c4c6628b80dc1cd129024e088a67cc74020bbea63b139b22514a08798e3404ddef9519b3cd3a431b302b0a6df25f14374fe1356d6d51c245e485b576625e7ec6f44c42e9a637ed6b0bff5cb6f406b7edee386bfb5a899fa5ae9f24117c4b1fe649286651ece45b3dc2007cb8a163bf0598da48361c55d39a69163fa8fd24cf5f83655d23dca3ad961c62f356208552bb9ed529077096966d670c354e4abc9804f1746c08ca18217c32905e462e36ce3be39e772c180e86039b2783a2ec07a28fb5c55df06f4c52c9de2bcbf6955817183995497cea956ae515d2261898fa051015728e5a8aaac42dad33170d04507a33a85521abdf1cba64ecfb850458dbef0a8aea71575d060c7db3970f85a6e1e4c7abf5ae8cdb0933d71e8c94e04a25619dcee3d2261ad2ee6bf12ffa06d98a0864d87602733ec86a64521f2b18177b200cbbe117577a615d6c770988c0bad946e208e24fa074e5ab3143db5bfce0fd108e4b82d120a92108011a723c12a787e6d788719a10bdba5b2699c327186af4e23c1a946834b6150bda2583e9ca2ad44ce8dbbbc2db04de8ef92e8efc141fbecaa6287c59474e6bc05d99b2964fa090c3a2233ba186515be7ed1f612970cee2d7afb81bdd762170481cd0069127d5b05aa993b4ea988d8fddc186ffb7dc90a6c08f4df435c93402849236c3fab4d27c7026c1d4dcb2602646dec9751e763dba37bdf8ff9406ad9e530ee5db382f413001aeb06a53ed9027d831179727b0865a8918da3edbebcf9b14ed44ce6cbaced4bb1bdb7f1447e6cc254b332051512bd7af426fb8f401378cd2bf5983ca01c64b92ecf032ea15d1721d03f482d7ce6e74fef6d55e702f46980c82b5a84031900b1c9e59e7c97fbec7e8f323a97a7e36cc88be0f1d45b7ff585ac54bd407b22b4154aacc8f6d7ebf48e1d814cc5ed20f8037e0a79715eef29be32806a1d58bb7c5da76f550aa3d8a1fbff0eb19ccb1a313d55cda56c9ec2ef29632387fe8d76e3c0468043e8f663f4860ee12bf2d5b0b7474d6e694f91e6dbe115974a3926f12fee5e438777cb6a932df8cd8bec4d073b931ba3bc832b68d9dd300741fa7bf8afc47ed2576f6936ba424663aab639c5ae4f5683423b4742bf1c978238f16cbe39d652de3fdb8befc848ad922222e04a4037c0713eb57a81a23f0c73473fc646cea306b4bcbc8862f8385ddfa9d4b7fa2c087e879683303ed5bdd3a062b3cf5b3a278a66d2a13f83f44f82ddf310ee074ab6a364597e899a0255dc164f31cc50846851df9ab48195ded7ea1b1d510bd7ee74d73faf36bc31ecfa268359046f4eb879f924009438b481c6cd7889a002ed5ee382bc9190da6fc026e479558e4475677e9aa9e3050e2765694dfc81f56e880b96e7160c980dd98edd3dfffffffffffffffff"
}, p3 = {
  modp1: s3,
  modp2: f3,
  modp5: o3,
  modp14: u3,
  modp15: c3,
  modp16: h3,
  modp17: l3,
  modp18: d3
};
var wo, Gl;
function v3() {
  if (Gl)
    return wo;
  Gl = 1;
  var e = rr, t = zv(), h = new t(), o = new e(24), S = new e(11), g = new e(10), B = new e(3), M = new e(7), O = jv(), P = Ua;
  wo = ie;
  function D(fe, de) {
    return de = de || "utf8", pe.Buffer.isBuffer(fe) || (fe = new pe.Buffer(fe, de)), this._pub = new e(fe), this;
  }
  function Z(fe, de) {
    return de = de || "utf8", pe.Buffer.isBuffer(fe) || (fe = new pe.Buffer(fe, de)), this._priv = new e(fe), this;
  }
  var Y = {};
  function ee(fe, de) {
    var ce = de.toString("hex"), be = [ce, fe.toString(16)].join("_");
    if (be in Y)
      return Y[be];
    var ve = 0;
    if (fe.isEven() || !O.simpleSieve || !O.fermatTest(fe) || !h.test(fe))
      return ve += 1, ce === "02" || ce === "05" ? ve += 8 : ve += 4, Y[be] = ve, ve;
    h.test(fe.shrn(1)) || (ve += 2);
    var Pe;
    switch (ce) {
      case "02":
        fe.mod(o).cmp(S) && (ve += 8);
        break;
      case "05":
        Pe = fe.mod(g), Pe.cmp(B) && Pe.cmp(M) && (ve += 8);
        break;
      default:
        ve += 4;
    }
    return Y[be] = ve, ve;
  }
  function ie(fe, de, ce) {
    this.setGenerator(de), this.__prime = new e(fe), this._prime = e.mont(this.__prime), this._primeLen = fe.length, this._pub = void 0, this._priv = void 0, this._primeCode = void 0, ce ? (this.setPublicKey = D, this.setPrivateKey = Z) : this._primeCode = 8;
  }
  Object.defineProperty(ie.prototype, "verifyError", {
    enumerable: !0,
    get: function() {
      return typeof this._primeCode != "number" && (this._primeCode = ee(this.__prime, this.__gen)), this._primeCode;
    }
  }), ie.prototype.generateKeys = function() {
    return this._priv || (this._priv = new e(P(this._primeLen))), this._pub = this._gen.toRed(this._prime).redPow(this._priv).fromRed(), this.getPublicKey();
  }, ie.prototype.computeSecret = function(fe) {
    fe = new e(fe), fe = fe.toRed(this._prime);
    var de = fe.redPow(this._priv).fromRed(), ce = new pe.Buffer(de.toArray()), be = this.getPrime();
    if (ce.length < be.length) {
      var ve = new pe.Buffer(be.length - ce.length);
      ve.fill(0), ce = pe.Buffer.concat([ve, ce]);
    }
    return ce;
  }, ie.prototype.getPublicKey = function(fe) {
    return ue(this._pub, fe);
  }, ie.prototype.getPrivateKey = function(fe) {
    return ue(this._priv, fe);
  }, ie.prototype.getPrime = function(fe) {
    return ue(this.__prime, fe);
  }, ie.prototype.getGenerator = function(fe) {
    return ue(this._gen, fe);
  }, ie.prototype.setGenerator = function(fe, de) {
    return de = de || "utf8", pe.Buffer.isBuffer(fe) || (fe = new pe.Buffer(fe, de)), this.__gen = fe, this._gen = new e(fe), this;
  };
  function ue(fe, de) {
    var ce = new pe.Buffer(fe.toArray());
    return de ? ce.toString(de) : ce;
  }
  return wo;
}
var zl;
function y3() {
  if (zl)
    return Ln;
  zl = 1;
  var e = jv(), t = p3, h = v3();
  function o(B) {
    var M = new pe.Buffer(t[B].prime, "hex"), O = new pe.Buffer(t[B].gen, "hex");
    return new h(M, O);
  }
  var S = {
    binary: !0,
    hex: !0,
    base64: !0
  };
  function g(B, M, O, P) {
    return pe.Buffer.isBuffer(M) || S[M] === void 0 ? g(B, "binary", M, O) : (M = M || "binary", P = P || "binary", O = O || new pe.Buffer([2]), pe.Buffer.isBuffer(O) || (O = new pe.Buffer(O, P)), typeof B == "number" ? new h(e(B, O), O, !0) : (pe.Buffer.isBuffer(B) || (B = new pe.Buffer(B, M)), new h(B, O, !0)));
  }
  return Ln.DiffieHellmanGroup = Ln.createDiffieHellmanGroup = Ln.getDiffieHellman = o, Ln.createDiffieHellman = Ln.DiffieHellman = g, Ln;
}
var u0 = { exports: {} }, ah = { exports: {} };
(function(e) {
  (function(t, h) {
    function o(A, I) {
      if (!A)
        throw new Error(I || "Assertion failed");
    }
    function S(A, I) {
      A.super_ = I;
      var U = function() {
      };
      U.prototype = I.prototype, A.prototype = new U(), A.prototype.constructor = A;
    }
    function g(A, I, U) {
      if (g.isBN(A))
        return A;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, A !== null && ((I === "le" || I === "be") && (U = I, I = 10), this._init(A || 0, I || 10, U || "be"));
    }
    typeof t == "object" ? t.exports = g : h.BN = g, g.BN = g, g.wordSize = 26;
    var B;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? B = window.Buffer : B = pe.Buffer;
    } catch {
    }
    g.isBN = function(A) {
      return A instanceof g ? !0 : A !== null && typeof A == "object" && A.constructor.wordSize === g.wordSize && Array.isArray(A.words);
    }, g.max = function(A, I) {
      return A.cmp(I) > 0 ? A : I;
    }, g.min = function(A, I) {
      return A.cmp(I) < 0 ? A : I;
    }, g.prototype._init = function(A, I, U) {
      if (typeof A == "number")
        return this._initNumber(A, I, U);
      if (typeof A == "object")
        return this._initArray(A, I, U);
      I === "hex" && (I = 16), o(I === (I | 0) && I >= 2 && I <= 36), A = A.toString().replace(/\s+/g, "");
      var X = 0;
      A[0] === "-" && (X++, this.negative = 1), X < A.length && (I === 16 ? this._parseHex(A, X, U) : (this._parseBase(A, I, X), U === "le" && this._initArray(this.toArray(), I, U)));
    }, g.prototype._initNumber = function(A, I, U) {
      A < 0 && (this.negative = 1, A = -A), A < 67108864 ? (this.words = [A & 67108863], this.length = 1) : A < 4503599627370496 ? (this.words = [
        A & 67108863,
        A / 67108864 & 67108863
      ], this.length = 2) : (o(A < 9007199254740992), this.words = [
        A & 67108863,
        A / 67108864 & 67108863,
        1
      ], this.length = 3), U === "le" && this._initArray(this.toArray(), I, U);
    }, g.prototype._initArray = function(A, I, U) {
      if (o(typeof A.length == "number"), A.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(A.length / 3), this.words = new Array(this.length);
      for (var X = 0; X < this.length; X++)
        this.words[X] = 0;
      var Q, F, $ = 0;
      if (U === "be")
        for (X = A.length - 1, Q = 0; X >= 0; X -= 3)
          F = A[X] | A[X - 1] << 8 | A[X - 2] << 16, this.words[Q] |= F << $ & 67108863, this.words[Q + 1] = F >>> 26 - $ & 67108863, $ += 24, $ >= 26 && ($ -= 26, Q++);
      else if (U === "le")
        for (X = 0, Q = 0; X < A.length; X += 3)
          F = A[X] | A[X + 1] << 8 | A[X + 2] << 16, this.words[Q] |= F << $ & 67108863, this.words[Q + 1] = F >>> 26 - $ & 67108863, $ += 24, $ >= 26 && ($ -= 26, Q++);
      return this._strip();
    };
    function M(A, I) {
      var U = A.charCodeAt(I);
      if (U >= 48 && U <= 57)
        return U - 48;
      if (U >= 65 && U <= 70)
        return U - 55;
      if (U >= 97 && U <= 102)
        return U - 87;
      o(!1, "Invalid character in " + A);
    }
    function O(A, I, U) {
      var X = M(A, U);
      return U - 1 >= I && (X |= M(A, U - 1) << 4), X;
    }
    g.prototype._parseHex = function(A, I, U) {
      this.length = Math.ceil((A.length - I) / 6), this.words = new Array(this.length);
      for (var X = 0; X < this.length; X++)
        this.words[X] = 0;
      var Q = 0, F = 0, $;
      if (U === "be")
        for (X = A.length - 1; X >= I; X -= 2)
          $ = O(A, I, X) << Q, this.words[F] |= $ & 67108863, Q >= 18 ? (Q -= 18, F += 1, this.words[F] |= $ >>> 26) : Q += 8;
      else {
        var H = A.length - I;
        for (X = H % 2 === 0 ? I + 1 : I; X < A.length; X += 2)
          $ = O(A, I, X) << Q, this.words[F] |= $ & 67108863, Q >= 18 ? (Q -= 18, F += 1, this.words[F] |= $ >>> 26) : Q += 8;
      }
      this._strip();
    };
    function P(A, I, U, X) {
      for (var Q = 0, F = 0, $ = Math.min(A.length, U), H = I; H < $; H++) {
        var q = A.charCodeAt(H) - 48;
        Q *= X, q >= 49 ? F = q - 49 + 10 : q >= 17 ? F = q - 17 + 10 : F = q, o(q >= 0 && F < X, "Invalid character"), Q += F;
      }
      return Q;
    }
    g.prototype._parseBase = function(A, I, U) {
      this.words = [0], this.length = 1;
      for (var X = 0, Q = 1; Q <= 67108863; Q *= I)
        X++;
      X--, Q = Q / I | 0;
      for (var F = A.length - U, $ = F % X, H = Math.min(F, F - $) + U, q = 0, z = U; z < H; z += X)
        q = P(A, z, z + X, I), this.imuln(Q), this.words[0] + q < 67108864 ? this.words[0] += q : this._iaddn(q);
      if ($ !== 0) {
        var me = 1;
        for (q = P(A, z, A.length, I), z = 0; z < $; z++)
          me *= I;
        this.imuln(me), this.words[0] + q < 67108864 ? this.words[0] += q : this._iaddn(q);
      }
      this._strip();
    }, g.prototype.copy = function(A) {
      A.words = new Array(this.length);
      for (var I = 0; I < this.length; I++)
        A.words[I] = this.words[I];
      A.length = this.length, A.negative = this.negative, A.red = this.red;
    };
    function D(A, I) {
      A.words = I.words, A.length = I.length, A.negative = I.negative, A.red = I.red;
    }
    if (g.prototype._move = function(A) {
      D(A, this);
    }, g.prototype.clone = function() {
      var A = new g(null);
      return this.copy(A), A;
    }, g.prototype._expand = function(A) {
      for (; this.length < A; )
        this.words[this.length++] = 0;
      return this;
    }, g.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, g.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        g.prototype[Symbol.for("nodejs.util.inspect.custom")] = Z;
      } catch {
        g.prototype.inspect = Z;
      }
    else
      g.prototype.inspect = Z;
    function Z() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var Y = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], ee = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], ie = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    g.prototype.toString = function(A, I) {
      A = A || 10, I = I | 0 || 1;
      var U;
      if (A === 16 || A === "hex") {
        U = "";
        for (var X = 0, Q = 0, F = 0; F < this.length; F++) {
          var $ = this.words[F], H = (($ << X | Q) & 16777215).toString(16);
          Q = $ >>> 24 - X & 16777215, X += 2, X >= 26 && (X -= 26, F--), Q !== 0 || F !== this.length - 1 ? U = Y[6 - H.length] + H + U : U = H + U;
        }
        for (Q !== 0 && (U = Q.toString(16) + U); U.length % I !== 0; )
          U = "0" + U;
        return this.negative !== 0 && (U = "-" + U), U;
      }
      if (A === (A | 0) && A >= 2 && A <= 36) {
        var q = ee[A], z = ie[A];
        U = "";
        var me = this.clone();
        for (me.negative = 0; !me.isZero(); ) {
          var Ce = me.modrn(z).toString(A);
          me = me.idivn(z), me.isZero() ? U = Ce + U : U = Y[q - Ce.length] + Ce + U;
        }
        for (this.isZero() && (U = "0" + U); U.length % I !== 0; )
          U = "0" + U;
        return this.negative !== 0 && (U = "-" + U), U;
      }
      o(!1, "Base should be between 2 and 36");
    }, g.prototype.toNumber = function() {
      var A = this.words[0];
      return this.length === 2 ? A += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? A += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && o(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -A : A;
    }, g.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, B && (g.prototype.toBuffer = function(A, I) {
      return this.toArrayLike(B, A, I);
    }), g.prototype.toArray = function(A, I) {
      return this.toArrayLike(Array, A, I);
    };
    var ue = function(A, I) {
      return A.allocUnsafe ? A.allocUnsafe(I) : new A(I);
    };
    g.prototype.toArrayLike = function(A, I, U) {
      this._strip();
      var X = this.byteLength(), Q = U || Math.max(1, X);
      o(X <= Q, "byte array longer than desired length"), o(Q > 0, "Requested array length <= 0");
      var F = ue(A, Q), $ = I === "le" ? "LE" : "BE";
      return this["_toArrayLike" + $](F, X), F;
    }, g.prototype._toArrayLikeLE = function(A, I) {
      for (var U = 0, X = 0, Q = 0, F = 0; Q < this.length; Q++) {
        var $ = this.words[Q] << F | X;
        A[U++] = $ & 255, U < A.length && (A[U++] = $ >> 8 & 255), U < A.length && (A[U++] = $ >> 16 & 255), F === 6 ? (U < A.length && (A[U++] = $ >> 24 & 255), X = 0, F = 0) : (X = $ >>> 24, F += 2);
      }
      if (U < A.length)
        for (A[U++] = X; U < A.length; )
          A[U++] = 0;
    }, g.prototype._toArrayLikeBE = function(A, I) {
      for (var U = A.length - 1, X = 0, Q = 0, F = 0; Q < this.length; Q++) {
        var $ = this.words[Q] << F | X;
        A[U--] = $ & 255, U >= 0 && (A[U--] = $ >> 8 & 255), U >= 0 && (A[U--] = $ >> 16 & 255), F === 6 ? (U >= 0 && (A[U--] = $ >> 24 & 255), X = 0, F = 0) : (X = $ >>> 24, F += 2);
      }
      if (U >= 0)
        for (A[U--] = X; U >= 0; )
          A[U--] = 0;
    }, Math.clz32 ? g.prototype._countBits = function(A) {
      return 32 - Math.clz32(A);
    } : g.prototype._countBits = function(A) {
      var I = A, U = 0;
      return I >= 4096 && (U += 13, I >>>= 13), I >= 64 && (U += 7, I >>>= 7), I >= 8 && (U += 4, I >>>= 4), I >= 2 && (U += 2, I >>>= 2), U + I;
    }, g.prototype._zeroBits = function(A) {
      if (A === 0)
        return 26;
      var I = A, U = 0;
      return I & 8191 || (U += 13, I >>>= 13), I & 127 || (U += 7, I >>>= 7), I & 15 || (U += 4, I >>>= 4), I & 3 || (U += 2, I >>>= 2), I & 1 || U++, U;
    }, g.prototype.bitLength = function() {
      var A = this.words[this.length - 1], I = this._countBits(A);
      return (this.length - 1) * 26 + I;
    };
    function fe(A) {
      for (var I = new Array(A.bitLength()), U = 0; U < I.length; U++) {
        var X = U / 26 | 0, Q = U % 26;
        I[U] = A.words[X] >>> Q & 1;
      }
      return I;
    }
    g.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var A = 0, I = 0; I < this.length; I++) {
        var U = this._zeroBits(this.words[I]);
        if (A += U, U !== 26)
          break;
      }
      return A;
    }, g.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, g.prototype.toTwos = function(A) {
      return this.negative !== 0 ? this.abs().inotn(A).iaddn(1) : this.clone();
    }, g.prototype.fromTwos = function(A) {
      return this.testn(A - 1) ? this.notn(A).iaddn(1).ineg() : this.clone();
    }, g.prototype.isNeg = function() {
      return this.negative !== 0;
    }, g.prototype.neg = function() {
      return this.clone().ineg();
    }, g.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, g.prototype.iuor = function(A) {
      for (; this.length < A.length; )
        this.words[this.length++] = 0;
      for (var I = 0; I < A.length; I++)
        this.words[I] = this.words[I] | A.words[I];
      return this._strip();
    }, g.prototype.ior = function(A) {
      return o((this.negative | A.negative) === 0), this.iuor(A);
    }, g.prototype.or = function(A) {
      return this.length > A.length ? this.clone().ior(A) : A.clone().ior(this);
    }, g.prototype.uor = function(A) {
      return this.length > A.length ? this.clone().iuor(A) : A.clone().iuor(this);
    }, g.prototype.iuand = function(A) {
      var I;
      this.length > A.length ? I = A : I = this;
      for (var U = 0; U < I.length; U++)
        this.words[U] = this.words[U] & A.words[U];
      return this.length = I.length, this._strip();
    }, g.prototype.iand = function(A) {
      return o((this.negative | A.negative) === 0), this.iuand(A);
    }, g.prototype.and = function(A) {
      return this.length > A.length ? this.clone().iand(A) : A.clone().iand(this);
    }, g.prototype.uand = function(A) {
      return this.length > A.length ? this.clone().iuand(A) : A.clone().iuand(this);
    }, g.prototype.iuxor = function(A) {
      var I, U;
      this.length > A.length ? (I = this, U = A) : (I = A, U = this);
      for (var X = 0; X < U.length; X++)
        this.words[X] = I.words[X] ^ U.words[X];
      if (this !== I)
        for (; X < I.length; X++)
          this.words[X] = I.words[X];
      return this.length = I.length, this._strip();
    }, g.prototype.ixor = function(A) {
      return o((this.negative | A.negative) === 0), this.iuxor(A);
    }, g.prototype.xor = function(A) {
      return this.length > A.length ? this.clone().ixor(A) : A.clone().ixor(this);
    }, g.prototype.uxor = function(A) {
      return this.length > A.length ? this.clone().iuxor(A) : A.clone().iuxor(this);
    }, g.prototype.inotn = function(A) {
      o(typeof A == "number" && A >= 0);
      var I = Math.ceil(A / 26) | 0, U = A % 26;
      this._expand(I), U > 0 && I--;
      for (var X = 0; X < I; X++)
        this.words[X] = ~this.words[X] & 67108863;
      return U > 0 && (this.words[X] = ~this.words[X] & 67108863 >> 26 - U), this._strip();
    }, g.prototype.notn = function(A) {
      return this.clone().inotn(A);
    }, g.prototype.setn = function(A, I) {
      o(typeof A == "number" && A >= 0);
      var U = A / 26 | 0, X = A % 26;
      return this._expand(U + 1), I ? this.words[U] = this.words[U] | 1 << X : this.words[U] = this.words[U] & ~(1 << X), this._strip();
    }, g.prototype.iadd = function(A) {
      var I;
      if (this.negative !== 0 && A.negative === 0)
        return this.negative = 0, I = this.isub(A), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && A.negative !== 0)
        return A.negative = 0, I = this.isub(A), A.negative = 1, I._normSign();
      var U, X;
      this.length > A.length ? (U = this, X = A) : (U = A, X = this);
      for (var Q = 0, F = 0; F < X.length; F++)
        I = (U.words[F] | 0) + (X.words[F] | 0) + Q, this.words[F] = I & 67108863, Q = I >>> 26;
      for (; Q !== 0 && F < U.length; F++)
        I = (U.words[F] | 0) + Q, this.words[F] = I & 67108863, Q = I >>> 26;
      if (this.length = U.length, Q !== 0)
        this.words[this.length] = Q, this.length++;
      else if (U !== this)
        for (; F < U.length; F++)
          this.words[F] = U.words[F];
      return this;
    }, g.prototype.add = function(A) {
      var I;
      return A.negative !== 0 && this.negative === 0 ? (A.negative = 0, I = this.sub(A), A.negative ^= 1, I) : A.negative === 0 && this.negative !== 0 ? (this.negative = 0, I = A.sub(this), this.negative = 1, I) : this.length > A.length ? this.clone().iadd(A) : A.clone().iadd(this);
    }, g.prototype.isub = function(A) {
      if (A.negative !== 0) {
        A.negative = 0;
        var I = this.iadd(A);
        return A.negative = 1, I._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(A), this.negative = 1, this._normSign();
      var U = this.cmp(A);
      if (U === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var X, Q;
      U > 0 ? (X = this, Q = A) : (X = A, Q = this);
      for (var F = 0, $ = 0; $ < Q.length; $++)
        I = (X.words[$] | 0) - (Q.words[$] | 0) + F, F = I >> 26, this.words[$] = I & 67108863;
      for (; F !== 0 && $ < X.length; $++)
        I = (X.words[$] | 0) + F, F = I >> 26, this.words[$] = I & 67108863;
      if (F === 0 && $ < X.length && X !== this)
        for (; $ < X.length; $++)
          this.words[$] = X.words[$];
      return this.length = Math.max(this.length, $), X !== this && (this.negative = 1), this._strip();
    }, g.prototype.sub = function(A) {
      return this.clone().isub(A);
    };
    function de(A, I, U) {
      U.negative = I.negative ^ A.negative;
      var X = A.length + I.length | 0;
      U.length = X, X = X - 1 | 0;
      var Q = A.words[0] | 0, F = I.words[0] | 0, $ = Q * F, H = $ & 67108863, q = $ / 67108864 | 0;
      U.words[0] = H;
      for (var z = 1; z < X; z++) {
        for (var me = q >>> 26, Ce = q & 67108863, je = Math.min(z, I.length - 1), Re = Math.max(0, z - A.length + 1); Re <= je; Re++) {
          var Ae = z - Re | 0;
          Q = A.words[Ae] | 0, F = I.words[Re] | 0, $ = Q * F + Ce, me += $ / 67108864 | 0, Ce = $ & 67108863;
        }
        U.words[z] = Ce | 0, q = me | 0;
      }
      return q !== 0 ? U.words[z] = q | 0 : U.length--, U._strip();
    }
    var ce = function(A, I, U) {
      var X = A.words, Q = I.words, F = U.words, $ = 0, H, q, z, me = X[0] | 0, Ce = me & 8191, je = me >>> 13, Re = X[1] | 0, Ae = Re & 8191, ke = Re >>> 13, Qe = X[2] | 0, Ze = Qe & 8191, qe = Qe >>> 13, Oe = X[3] | 0, Xe = Oe & 8191, et = Oe >>> 13, nt = X[4] | 0, re = nt & 8191, oe = nt >>> 13, le = X[5] | 0, ge = le & 8191, Ke = le >>> 13, Je = X[6] | 0, Fe = Je & 8191, Ye = Je >>> 13, it = X[7] | 0, rt = it & 8191, tt = it >>> 13, vt = X[8] | 0, St = vt & 8191, ot = vt >>> 13, si = X[9] | 0, oi = si & 8191, At = si >>> 13, Nn = Q[0] | 0, ui = Nn & 8191, Bt = Nn >>> 13, vi = Q[1] | 0, fi = vi & 8191, Ct = vi >>> 13, rM = Q[2] | 0, hi = rM & 8191, Tt = rM >>> 13, Dn = Q[3] | 0, di = Dn & 8191, Ot = Dn >>> 13, iM = Q[4] | 0, ci = iM & 8191, Dt = iM >>> 13, nM = Q[5] | 0, li = nM & 8191, ri = nM >>> 13, eM = Q[6] | 0, ai = eM & 8191, It = eM >>> 13, tM = Q[7] | 0, pi = tM & 8191, ii = tM >>> 13, oM = Q[8] | 0, gi = oM & 8191, ni = oM >>> 13, aM = Q[9] | 0, yi = aM & 8191, mi = aM >>> 13;
      U.negative = A.negative ^ I.negative, U.length = 19, H = Math.imul(Ce, ui), q = Math.imul(Ce, Bt), q = q + Math.imul(je, ui) | 0, z = Math.imul(je, Bt);
      var sM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (sM >>> 26) | 0, sM &= 67108863, H = Math.imul(Ae, ui), q = Math.imul(Ae, Bt), q = q + Math.imul(ke, ui) | 0, z = Math.imul(ke, Bt), H = H + Math.imul(Ce, fi) | 0, q = q + Math.imul(Ce, Ct) | 0, q = q + Math.imul(je, fi) | 0, z = z + Math.imul(je, Ct) | 0;
      var uM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (uM >>> 26) | 0, uM &= 67108863, H = Math.imul(Ze, ui), q = Math.imul(Ze, Bt), q = q + Math.imul(qe, ui) | 0, z = Math.imul(qe, Bt), H = H + Math.imul(Ae, fi) | 0, q = q + Math.imul(Ae, Ct) | 0, q = q + Math.imul(ke, fi) | 0, z = z + Math.imul(ke, Ct) | 0, H = H + Math.imul(Ce, hi) | 0, q = q + Math.imul(Ce, Tt) | 0, q = q + Math.imul(je, hi) | 0, z = z + Math.imul(je, Tt) | 0;
      var fM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (fM >>> 26) | 0, fM &= 67108863, H = Math.imul(Xe, ui), q = Math.imul(Xe, Bt), q = q + Math.imul(et, ui) | 0, z = Math.imul(et, Bt), H = H + Math.imul(Ze, fi) | 0, q = q + Math.imul(Ze, Ct) | 0, q = q + Math.imul(qe, fi) | 0, z = z + Math.imul(qe, Ct) | 0, H = H + Math.imul(Ae, hi) | 0, q = q + Math.imul(Ae, Tt) | 0, q = q + Math.imul(ke, hi) | 0, z = z + Math.imul(ke, Tt) | 0, H = H + Math.imul(Ce, di) | 0, q = q + Math.imul(Ce, Ot) | 0, q = q + Math.imul(je, di) | 0, z = z + Math.imul(je, Ot) | 0;
      var hM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (hM >>> 26) | 0, hM &= 67108863, H = Math.imul(re, ui), q = Math.imul(re, Bt), q = q + Math.imul(oe, ui) | 0, z = Math.imul(oe, Bt), H = H + Math.imul(Xe, fi) | 0, q = q + Math.imul(Xe, Ct) | 0, q = q + Math.imul(et, fi) | 0, z = z + Math.imul(et, Ct) | 0, H = H + Math.imul(Ze, hi) | 0, q = q + Math.imul(Ze, Tt) | 0, q = q + Math.imul(qe, hi) | 0, z = z + Math.imul(qe, Tt) | 0, H = H + Math.imul(Ae, di) | 0, q = q + Math.imul(Ae, Ot) | 0, q = q + Math.imul(ke, di) | 0, z = z + Math.imul(ke, Ot) | 0, H = H + Math.imul(Ce, ci) | 0, q = q + Math.imul(Ce, Dt) | 0, q = q + Math.imul(je, ci) | 0, z = z + Math.imul(je, Dt) | 0;
      var cM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (cM >>> 26) | 0, cM &= 67108863, H = Math.imul(ge, ui), q = Math.imul(ge, Bt), q = q + Math.imul(Ke, ui) | 0, z = Math.imul(Ke, Bt), H = H + Math.imul(re, fi) | 0, q = q + Math.imul(re, Ct) | 0, q = q + Math.imul(oe, fi) | 0, z = z + Math.imul(oe, Ct) | 0, H = H + Math.imul(Xe, hi) | 0, q = q + Math.imul(Xe, Tt) | 0, q = q + Math.imul(et, hi) | 0, z = z + Math.imul(et, Tt) | 0, H = H + Math.imul(Ze, di) | 0, q = q + Math.imul(Ze, Ot) | 0, q = q + Math.imul(qe, di) | 0, z = z + Math.imul(qe, Ot) | 0, H = H + Math.imul(Ae, ci) | 0, q = q + Math.imul(Ae, Dt) | 0, q = q + Math.imul(ke, ci) | 0, z = z + Math.imul(ke, Dt) | 0, H = H + Math.imul(Ce, li) | 0, q = q + Math.imul(Ce, ri) | 0, q = q + Math.imul(je, li) | 0, z = z + Math.imul(je, ri) | 0;
      var lM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (lM >>> 26) | 0, lM &= 67108863, H = Math.imul(Fe, ui), q = Math.imul(Fe, Bt), q = q + Math.imul(Ye, ui) | 0, z = Math.imul(Ye, Bt), H = H + Math.imul(ge, fi) | 0, q = q + Math.imul(ge, Ct) | 0, q = q + Math.imul(Ke, fi) | 0, z = z + Math.imul(Ke, Ct) | 0, H = H + Math.imul(re, hi) | 0, q = q + Math.imul(re, Tt) | 0, q = q + Math.imul(oe, hi) | 0, z = z + Math.imul(oe, Tt) | 0, H = H + Math.imul(Xe, di) | 0, q = q + Math.imul(Xe, Ot) | 0, q = q + Math.imul(et, di) | 0, z = z + Math.imul(et, Ot) | 0, H = H + Math.imul(Ze, ci) | 0, q = q + Math.imul(Ze, Dt) | 0, q = q + Math.imul(qe, ci) | 0, z = z + Math.imul(qe, Dt) | 0, H = H + Math.imul(Ae, li) | 0, q = q + Math.imul(Ae, ri) | 0, q = q + Math.imul(ke, li) | 0, z = z + Math.imul(ke, ri) | 0, H = H + Math.imul(Ce, ai) | 0, q = q + Math.imul(Ce, It) | 0, q = q + Math.imul(je, ai) | 0, z = z + Math.imul(je, It) | 0;
      var dM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (dM >>> 26) | 0, dM &= 67108863, H = Math.imul(rt, ui), q = Math.imul(rt, Bt), q = q + Math.imul(tt, ui) | 0, z = Math.imul(tt, Bt), H = H + Math.imul(Fe, fi) | 0, q = q + Math.imul(Fe, Ct) | 0, q = q + Math.imul(Ye, fi) | 0, z = z + Math.imul(Ye, Ct) | 0, H = H + Math.imul(ge, hi) | 0, q = q + Math.imul(ge, Tt) | 0, q = q + Math.imul(Ke, hi) | 0, z = z + Math.imul(Ke, Tt) | 0, H = H + Math.imul(re, di) | 0, q = q + Math.imul(re, Ot) | 0, q = q + Math.imul(oe, di) | 0, z = z + Math.imul(oe, Ot) | 0, H = H + Math.imul(Xe, ci) | 0, q = q + Math.imul(Xe, Dt) | 0, q = q + Math.imul(et, ci) | 0, z = z + Math.imul(et, Dt) | 0, H = H + Math.imul(Ze, li) | 0, q = q + Math.imul(Ze, ri) | 0, q = q + Math.imul(qe, li) | 0, z = z + Math.imul(qe, ri) | 0, H = H + Math.imul(Ae, ai) | 0, q = q + Math.imul(Ae, It) | 0, q = q + Math.imul(ke, ai) | 0, z = z + Math.imul(ke, It) | 0, H = H + Math.imul(Ce, pi) | 0, q = q + Math.imul(Ce, ii) | 0, q = q + Math.imul(je, pi) | 0, z = z + Math.imul(je, ii) | 0;
      var pM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (pM >>> 26) | 0, pM &= 67108863, H = Math.imul(St, ui), q = Math.imul(St, Bt), q = q + Math.imul(ot, ui) | 0, z = Math.imul(ot, Bt), H = H + Math.imul(rt, fi) | 0, q = q + Math.imul(rt, Ct) | 0, q = q + Math.imul(tt, fi) | 0, z = z + Math.imul(tt, Ct) | 0, H = H + Math.imul(Fe, hi) | 0, q = q + Math.imul(Fe, Tt) | 0, q = q + Math.imul(Ye, hi) | 0, z = z + Math.imul(Ye, Tt) | 0, H = H + Math.imul(ge, di) | 0, q = q + Math.imul(ge, Ot) | 0, q = q + Math.imul(Ke, di) | 0, z = z + Math.imul(Ke, Ot) | 0, H = H + Math.imul(re, ci) | 0, q = q + Math.imul(re, Dt) | 0, q = q + Math.imul(oe, ci) | 0, z = z + Math.imul(oe, Dt) | 0, H = H + Math.imul(Xe, li) | 0, q = q + Math.imul(Xe, ri) | 0, q = q + Math.imul(et, li) | 0, z = z + Math.imul(et, ri) | 0, H = H + Math.imul(Ze, ai) | 0, q = q + Math.imul(Ze, It) | 0, q = q + Math.imul(qe, ai) | 0, z = z + Math.imul(qe, It) | 0, H = H + Math.imul(Ae, pi) | 0, q = q + Math.imul(Ae, ii) | 0, q = q + Math.imul(ke, pi) | 0, z = z + Math.imul(ke, ii) | 0, H = H + Math.imul(Ce, gi) | 0, q = q + Math.imul(Ce, ni) | 0, q = q + Math.imul(je, gi) | 0, z = z + Math.imul(je, ni) | 0;
      var yM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (yM >>> 26) | 0, yM &= 67108863, H = Math.imul(oi, ui), q = Math.imul(oi, Bt), q = q + Math.imul(At, ui) | 0, z = Math.imul(At, Bt), H = H + Math.imul(St, fi) | 0, q = q + Math.imul(St, Ct) | 0, q = q + Math.imul(ot, fi) | 0, z = z + Math.imul(ot, Ct) | 0, H = H + Math.imul(rt, hi) | 0, q = q + Math.imul(rt, Tt) | 0, q = q + Math.imul(tt, hi) | 0, z = z + Math.imul(tt, Tt) | 0, H = H + Math.imul(Fe, di) | 0, q = q + Math.imul(Fe, Ot) | 0, q = q + Math.imul(Ye, di) | 0, z = z + Math.imul(Ye, Ot) | 0, H = H + Math.imul(ge, ci) | 0, q = q + Math.imul(ge, Dt) | 0, q = q + Math.imul(Ke, ci) | 0, z = z + Math.imul(Ke, Dt) | 0, H = H + Math.imul(re, li) | 0, q = q + Math.imul(re, ri) | 0, q = q + Math.imul(oe, li) | 0, z = z + Math.imul(oe, ri) | 0, H = H + Math.imul(Xe, ai) | 0, q = q + Math.imul(Xe, It) | 0, q = q + Math.imul(et, ai) | 0, z = z + Math.imul(et, It) | 0, H = H + Math.imul(Ze, pi) | 0, q = q + Math.imul(Ze, ii) | 0, q = q + Math.imul(qe, pi) | 0, z = z + Math.imul(qe, ii) | 0, H = H + Math.imul(Ae, gi) | 0, q = q + Math.imul(Ae, ni) | 0, q = q + Math.imul(ke, gi) | 0, z = z + Math.imul(ke, ni) | 0, H = H + Math.imul(Ce, yi) | 0, q = q + Math.imul(Ce, mi) | 0, q = q + Math.imul(je, yi) | 0, z = z + Math.imul(je, mi) | 0;
      var mM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (mM >>> 26) | 0, mM &= 67108863, H = Math.imul(oi, fi), q = Math.imul(oi, Ct), q = q + Math.imul(At, fi) | 0, z = Math.imul(At, Ct), H = H + Math.imul(St, hi) | 0, q = q + Math.imul(St, Tt) | 0, q = q + Math.imul(ot, hi) | 0, z = z + Math.imul(ot, Tt) | 0, H = H + Math.imul(rt, di) | 0, q = q + Math.imul(rt, Ot) | 0, q = q + Math.imul(tt, di) | 0, z = z + Math.imul(tt, Ot) | 0, H = H + Math.imul(Fe, ci) | 0, q = q + Math.imul(Fe, Dt) | 0, q = q + Math.imul(Ye, ci) | 0, z = z + Math.imul(Ye, Dt) | 0, H = H + Math.imul(ge, li) | 0, q = q + Math.imul(ge, ri) | 0, q = q + Math.imul(Ke, li) | 0, z = z + Math.imul(Ke, ri) | 0, H = H + Math.imul(re, ai) | 0, q = q + Math.imul(re, It) | 0, q = q + Math.imul(oe, ai) | 0, z = z + Math.imul(oe, It) | 0, H = H + Math.imul(Xe, pi) | 0, q = q + Math.imul(Xe, ii) | 0, q = q + Math.imul(et, pi) | 0, z = z + Math.imul(et, ii) | 0, H = H + Math.imul(Ze, gi) | 0, q = q + Math.imul(Ze, ni) | 0, q = q + Math.imul(qe, gi) | 0, z = z + Math.imul(qe, ni) | 0, H = H + Math.imul(Ae, yi) | 0, q = q + Math.imul(Ae, mi) | 0, q = q + Math.imul(ke, yi) | 0, z = z + Math.imul(ke, mi) | 0;
      var gM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (gM >>> 26) | 0, gM &= 67108863, H = Math.imul(oi, hi), q = Math.imul(oi, Tt), q = q + Math.imul(At, hi) | 0, z = Math.imul(At, Tt), H = H + Math.imul(St, di) | 0, q = q + Math.imul(St, Ot) | 0, q = q + Math.imul(ot, di) | 0, z = z + Math.imul(ot, Ot) | 0, H = H + Math.imul(rt, ci) | 0, q = q + Math.imul(rt, Dt) | 0, q = q + Math.imul(tt, ci) | 0, z = z + Math.imul(tt, Dt) | 0, H = H + Math.imul(Fe, li) | 0, q = q + Math.imul(Fe, ri) | 0, q = q + Math.imul(Ye, li) | 0, z = z + Math.imul(Ye, ri) | 0, H = H + Math.imul(ge, ai) | 0, q = q + Math.imul(ge, It) | 0, q = q + Math.imul(Ke, ai) | 0, z = z + Math.imul(Ke, It) | 0, H = H + Math.imul(re, pi) | 0, q = q + Math.imul(re, ii) | 0, q = q + Math.imul(oe, pi) | 0, z = z + Math.imul(oe, ii) | 0, H = H + Math.imul(Xe, gi) | 0, q = q + Math.imul(Xe, ni) | 0, q = q + Math.imul(et, gi) | 0, z = z + Math.imul(et, ni) | 0, H = H + Math.imul(Ze, yi) | 0, q = q + Math.imul(Ze, mi) | 0, q = q + Math.imul(qe, yi) | 0, z = z + Math.imul(qe, mi) | 0;
      var bM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (bM >>> 26) | 0, bM &= 67108863, H = Math.imul(oi, di), q = Math.imul(oi, Ot), q = q + Math.imul(At, di) | 0, z = Math.imul(At, Ot), H = H + Math.imul(St, ci) | 0, q = q + Math.imul(St, Dt) | 0, q = q + Math.imul(ot, ci) | 0, z = z + Math.imul(ot, Dt) | 0, H = H + Math.imul(rt, li) | 0, q = q + Math.imul(rt, ri) | 0, q = q + Math.imul(tt, li) | 0, z = z + Math.imul(tt, ri) | 0, H = H + Math.imul(Fe, ai) | 0, q = q + Math.imul(Fe, It) | 0, q = q + Math.imul(Ye, ai) | 0, z = z + Math.imul(Ye, It) | 0, H = H + Math.imul(ge, pi) | 0, q = q + Math.imul(ge, ii) | 0, q = q + Math.imul(Ke, pi) | 0, z = z + Math.imul(Ke, ii) | 0, H = H + Math.imul(re, gi) | 0, q = q + Math.imul(re, ni) | 0, q = q + Math.imul(oe, gi) | 0, z = z + Math.imul(oe, ni) | 0, H = H + Math.imul(Xe, yi) | 0, q = q + Math.imul(Xe, mi) | 0, q = q + Math.imul(et, yi) | 0, z = z + Math.imul(et, mi) | 0;
      var vM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (vM >>> 26) | 0, vM &= 67108863, H = Math.imul(oi, ci), q = Math.imul(oi, Dt), q = q + Math.imul(At, ci) | 0, z = Math.imul(At, Dt), H = H + Math.imul(St, li) | 0, q = q + Math.imul(St, ri) | 0, q = q + Math.imul(ot, li) | 0, z = z + Math.imul(ot, ri) | 0, H = H + Math.imul(rt, ai) | 0, q = q + Math.imul(rt, It) | 0, q = q + Math.imul(tt, ai) | 0, z = z + Math.imul(tt, It) | 0, H = H + Math.imul(Fe, pi) | 0, q = q + Math.imul(Fe, ii) | 0, q = q + Math.imul(Ye, pi) | 0, z = z + Math.imul(Ye, ii) | 0, H = H + Math.imul(ge, gi) | 0, q = q + Math.imul(ge, ni) | 0, q = q + Math.imul(Ke, gi) | 0, z = z + Math.imul(Ke, ni) | 0, H = H + Math.imul(re, yi) | 0, q = q + Math.imul(re, mi) | 0, q = q + Math.imul(oe, yi) | 0, z = z + Math.imul(oe, mi) | 0;
      var wM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (wM >>> 26) | 0, wM &= 67108863, H = Math.imul(oi, li), q = Math.imul(oi, ri), q = q + Math.imul(At, li) | 0, z = Math.imul(At, ri), H = H + Math.imul(St, ai) | 0, q = q + Math.imul(St, It) | 0, q = q + Math.imul(ot, ai) | 0, z = z + Math.imul(ot, It) | 0, H = H + Math.imul(rt, pi) | 0, q = q + Math.imul(rt, ii) | 0, q = q + Math.imul(tt, pi) | 0, z = z + Math.imul(tt, ii) | 0, H = H + Math.imul(Fe, gi) | 0, q = q + Math.imul(Fe, ni) | 0, q = q + Math.imul(Ye, gi) | 0, z = z + Math.imul(Ye, ni) | 0, H = H + Math.imul(ge, yi) | 0, q = q + Math.imul(ge, mi) | 0, q = q + Math.imul(Ke, yi) | 0, z = z + Math.imul(Ke, mi) | 0;
      var _M = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (_M >>> 26) | 0, _M &= 67108863, H = Math.imul(oi, ai), q = Math.imul(oi, It), q = q + Math.imul(At, ai) | 0, z = Math.imul(At, It), H = H + Math.imul(St, pi) | 0, q = q + Math.imul(St, ii) | 0, q = q + Math.imul(ot, pi) | 0, z = z + Math.imul(ot, ii) | 0, H = H + Math.imul(rt, gi) | 0, q = q + Math.imul(rt, ni) | 0, q = q + Math.imul(tt, gi) | 0, z = z + Math.imul(tt, ni) | 0, H = H + Math.imul(Fe, yi) | 0, q = q + Math.imul(Fe, mi) | 0, q = q + Math.imul(Ye, yi) | 0, z = z + Math.imul(Ye, mi) | 0;
      var SM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (SM >>> 26) | 0, SM &= 67108863, H = Math.imul(oi, pi), q = Math.imul(oi, ii), q = q + Math.imul(At, pi) | 0, z = Math.imul(At, ii), H = H + Math.imul(St, gi) | 0, q = q + Math.imul(St, ni) | 0, q = q + Math.imul(ot, gi) | 0, z = z + Math.imul(ot, ni) | 0, H = H + Math.imul(rt, yi) | 0, q = q + Math.imul(rt, mi) | 0, q = q + Math.imul(tt, yi) | 0, z = z + Math.imul(tt, mi) | 0;
      var EM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (EM >>> 26) | 0, EM &= 67108863, H = Math.imul(oi, gi), q = Math.imul(oi, ni), q = q + Math.imul(At, gi) | 0, z = Math.imul(At, ni), H = H + Math.imul(St, yi) | 0, q = q + Math.imul(St, mi) | 0, q = q + Math.imul(ot, yi) | 0, z = z + Math.imul(ot, mi) | 0;
      var AM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (AM >>> 26) | 0, AM &= 67108863, H = Math.imul(oi, yi), q = Math.imul(oi, mi), q = q + Math.imul(At, yi) | 0, z = Math.imul(At, mi);
      var MM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      return $ = (z + (q >>> 13) | 0) + (MM >>> 26) | 0, MM &= 67108863, F[0] = sM, F[1] = uM, F[2] = fM, F[3] = hM, F[4] = cM, F[5] = lM, F[6] = dM, F[7] = pM, F[8] = yM, F[9] = mM, F[10] = gM, F[11] = bM, F[12] = vM, F[13] = wM, F[14] = _M, F[15] = SM, F[16] = EM, F[17] = AM, F[18] = MM, $ !== 0 && (F[19] = $, U.length++), U;
    };
    Math.imul || (ce = de);
    function be(A, I, U) {
      U.negative = I.negative ^ A.negative, U.length = A.length + I.length;
      for (var X = 0, Q = 0, F = 0; F < U.length - 1; F++) {
        var $ = Q;
        Q = 0;
        for (var H = X & 67108863, q = Math.min(F, I.length - 1), z = Math.max(0, F - A.length + 1); z <= q; z++) {
          var me = F - z, Ce = A.words[me] | 0, je = I.words[z] | 0, Re = Ce * je, Ae = Re & 67108863;
          $ = $ + (Re / 67108864 | 0) | 0, Ae = Ae + H | 0, H = Ae & 67108863, $ = $ + (Ae >>> 26) | 0, Q += $ >>> 26, $ &= 67108863;
        }
        U.words[F] = H, X = $, $ = Q;
      }
      return X !== 0 ? U.words[F] = X : U.length--, U._strip();
    }
    function ve(A, I, U) {
      return be(A, I, U);
    }
    g.prototype.mulTo = function(A, I) {
      var U, X = this.length + A.length;
      return this.length === 10 && A.length === 10 ? U = ce(this, A, I) : X < 63 ? U = de(this, A, I) : X < 1024 ? U = be(this, A, I) : U = ve(this, A, I), U;
    }, g.prototype.mul = function(A) {
      var I = new g(null);
      return I.words = new Array(this.length + A.length), this.mulTo(A, I);
    }, g.prototype.mulf = function(A) {
      var I = new g(null);
      return I.words = new Array(this.length + A.length), ve(this, A, I);
    }, g.prototype.imul = function(A) {
      return this.clone().mulTo(A, this);
    }, g.prototype.imuln = function(A) {
      var I = A < 0;
      I && (A = -A), o(typeof A == "number"), o(A < 67108864);
      for (var U = 0, X = 0; X < this.length; X++) {
        var Q = (this.words[X] | 0) * A, F = (Q & 67108863) + (U & 67108863);
        U >>= 26, U += Q / 67108864 | 0, U += F >>> 26, this.words[X] = F & 67108863;
      }
      return U !== 0 && (this.words[X] = U, this.length++), I ? this.ineg() : this;
    }, g.prototype.muln = function(A) {
      return this.clone().imuln(A);
    }, g.prototype.sqr = function() {
      return this.mul(this);
    }, g.prototype.isqr = function() {
      return this.imul(this.clone());
    }, g.prototype.pow = function(A) {
      var I = fe(A);
      if (I.length === 0)
        return new g(1);
      for (var U = this, X = 0; X < I.length && I[X] === 0; X++, U = U.sqr())
        ;
      if (++X < I.length)
        for (var Q = U.sqr(); X < I.length; X++, Q = Q.sqr())
          I[X] !== 0 && (U = U.mul(Q));
      return U;
    }, g.prototype.iushln = function(A) {
      o(typeof A == "number" && A >= 0);
      var I = A % 26, U = (A - I) / 26, X = 67108863 >>> 26 - I << 26 - I, Q;
      if (I !== 0) {
        var F = 0;
        for (Q = 0; Q < this.length; Q++) {
          var $ = this.words[Q] & X, H = (this.words[Q] | 0) - $ << I;
          this.words[Q] = H | F, F = $ >>> 26 - I;
        }
        F && (this.words[Q] = F, this.length++);
      }
      if (U !== 0) {
        for (Q = this.length - 1; Q >= 0; Q--)
          this.words[Q + U] = this.words[Q];
        for (Q = 0; Q < U; Q++)
          this.words[Q] = 0;
        this.length += U;
      }
      return this._strip();
    }, g.prototype.ishln = function(A) {
      return o(this.negative === 0), this.iushln(A);
    }, g.prototype.iushrn = function(A, I, U) {
      o(typeof A == "number" && A >= 0);
      var X;
      I ? X = (I - I % 26) / 26 : X = 0;
      var Q = A % 26, F = Math.min((A - Q) / 26, this.length), $ = 67108863 ^ 67108863 >>> Q << Q, H = U;
      if (X -= F, X = Math.max(0, X), H) {
        for (var q = 0; q < F; q++)
          H.words[q] = this.words[q];
        H.length = F;
      }
      if (F !== 0)
        if (this.length > F)
          for (this.length -= F, q = 0; q < this.length; q++)
            this.words[q] = this.words[q + F];
        else
          this.words[0] = 0, this.length = 1;
      var z = 0;
      for (q = this.length - 1; q >= 0 && (z !== 0 || q >= X); q--) {
        var me = this.words[q] | 0;
        this.words[q] = z << 26 - Q | me >>> Q, z = me & $;
      }
      return H && z !== 0 && (H.words[H.length++] = z), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, g.prototype.ishrn = function(A, I, U) {
      return o(this.negative === 0), this.iushrn(A, I, U);
    }, g.prototype.shln = function(A) {
      return this.clone().ishln(A);
    }, g.prototype.ushln = function(A) {
      return this.clone().iushln(A);
    }, g.prototype.shrn = function(A) {
      return this.clone().ishrn(A);
    }, g.prototype.ushrn = function(A) {
      return this.clone().iushrn(A);
    }, g.prototype.testn = function(A) {
      o(typeof A == "number" && A >= 0);
      var I = A % 26, U = (A - I) / 26, X = 1 << I;
      if (this.length <= U)
        return !1;
      var Q = this.words[U];
      return !!(Q & X);
    }, g.prototype.imaskn = function(A) {
      o(typeof A == "number" && A >= 0);
      var I = A % 26, U = (A - I) / 26;
      if (o(this.negative === 0, "imaskn works only with positive numbers"), this.length <= U)
        return this;
      if (I !== 0 && U++, this.length = Math.min(U, this.length), I !== 0) {
        var X = 67108863 ^ 67108863 >>> I << I;
        this.words[this.length - 1] &= X;
      }
      return this._strip();
    }, g.prototype.maskn = function(A) {
      return this.clone().imaskn(A);
    }, g.prototype.iaddn = function(A) {
      return o(typeof A == "number"), o(A < 67108864), A < 0 ? this.isubn(-A) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= A ? (this.words[0] = A - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(A), this.negative = 1, this) : this._iaddn(A);
    }, g.prototype._iaddn = function(A) {
      this.words[0] += A;
      for (var I = 0; I < this.length && this.words[I] >= 67108864; I++)
        this.words[I] -= 67108864, I === this.length - 1 ? this.words[I + 1] = 1 : this.words[I + 1]++;
      return this.length = Math.max(this.length, I + 1), this;
    }, g.prototype.isubn = function(A) {
      if (o(typeof A == "number"), o(A < 67108864), A < 0)
        return this.iaddn(-A);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(A), this.negative = 1, this;
      if (this.words[0] -= A, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var I = 0; I < this.length && this.words[I] < 0; I++)
          this.words[I] += 67108864, this.words[I + 1] -= 1;
      return this._strip();
    }, g.prototype.addn = function(A) {
      return this.clone().iaddn(A);
    }, g.prototype.subn = function(A) {
      return this.clone().isubn(A);
    }, g.prototype.iabs = function() {
      return this.negative = 0, this;
    }, g.prototype.abs = function() {
      return this.clone().iabs();
    }, g.prototype._ishlnsubmul = function(A, I, U) {
      var X = A.length + U, Q;
      this._expand(X);
      var F, $ = 0;
      for (Q = 0; Q < A.length; Q++) {
        F = (this.words[Q + U] | 0) + $;
        var H = (A.words[Q] | 0) * I;
        F -= H & 67108863, $ = (F >> 26) - (H / 67108864 | 0), this.words[Q + U] = F & 67108863;
      }
      for (; Q < this.length - U; Q++)
        F = (this.words[Q + U] | 0) + $, $ = F >> 26, this.words[Q + U] = F & 67108863;
      if ($ === 0)
        return this._strip();
      for (o($ === -1), $ = 0, Q = 0; Q < this.length; Q++)
        F = -(this.words[Q] | 0) + $, $ = F >> 26, this.words[Q] = F & 67108863;
      return this.negative = 1, this._strip();
    }, g.prototype._wordDiv = function(A, I) {
      var U = this.length - A.length, X = this.clone(), Q = A, F = Q.words[Q.length - 1] | 0, $ = this._countBits(F);
      U = 26 - $, U !== 0 && (Q = Q.ushln(U), X.iushln(U), F = Q.words[Q.length - 1] | 0);
      var H = X.length - Q.length, q;
      if (I !== "mod") {
        q = new g(null), q.length = H + 1, q.words = new Array(q.length);
        for (var z = 0; z < q.length; z++)
          q.words[z] = 0;
      }
      var me = X.clone()._ishlnsubmul(Q, 1, H);
      me.negative === 0 && (X = me, q && (q.words[H] = 1));
      for (var Ce = H - 1; Ce >= 0; Ce--) {
        var je = (X.words[Q.length + Ce] | 0) * 67108864 + (X.words[Q.length + Ce - 1] | 0);
        for (je = Math.min(je / F | 0, 67108863), X._ishlnsubmul(Q, je, Ce); X.negative !== 0; )
          je--, X.negative = 0, X._ishlnsubmul(Q, 1, Ce), X.isZero() || (X.negative ^= 1);
        q && (q.words[Ce] = je);
      }
      return q && q._strip(), X._strip(), I !== "div" && U !== 0 && X.iushrn(U), {
        div: q || null,
        mod: X
      };
    }, g.prototype.divmod = function(A, I, U) {
      if (o(!A.isZero()), this.isZero())
        return {
          div: new g(0),
          mod: new g(0)
        };
      var X, Q, F;
      return this.negative !== 0 && A.negative === 0 ? (F = this.neg().divmod(A, I), I !== "mod" && (X = F.div.neg()), I !== "div" && (Q = F.mod.neg(), U && Q.negative !== 0 && Q.iadd(A)), {
        div: X,
        mod: Q
      }) : this.negative === 0 && A.negative !== 0 ? (F = this.divmod(A.neg(), I), I !== "mod" && (X = F.div.neg()), {
        div: X,
        mod: F.mod
      }) : this.negative & A.negative ? (F = this.neg().divmod(A.neg(), I), I !== "div" && (Q = F.mod.neg(), U && Q.negative !== 0 && Q.isub(A)), {
        div: F.div,
        mod: Q
      }) : A.length > this.length || this.cmp(A) < 0 ? {
        div: new g(0),
        mod: this
      } : A.length === 1 ? I === "div" ? {
        div: this.divn(A.words[0]),
        mod: null
      } : I === "mod" ? {
        div: null,
        mod: new g(this.modrn(A.words[0]))
      } : {
        div: this.divn(A.words[0]),
        mod: new g(this.modrn(A.words[0]))
      } : this._wordDiv(A, I);
    }, g.prototype.div = function(A) {
      return this.divmod(A, "div", !1).div;
    }, g.prototype.mod = function(A) {
      return this.divmod(A, "mod", !1).mod;
    }, g.prototype.umod = function(A) {
      return this.divmod(A, "mod", !0).mod;
    }, g.prototype.divRound = function(A) {
      var I = this.divmod(A);
      if (I.mod.isZero())
        return I.div;
      var U = I.div.negative !== 0 ? I.mod.isub(A) : I.mod, X = A.ushrn(1), Q = A.andln(1), F = U.cmp(X);
      return F < 0 || Q === 1 && F === 0 ? I.div : I.div.negative !== 0 ? I.div.isubn(1) : I.div.iaddn(1);
    }, g.prototype.modrn = function(A) {
      var I = A < 0;
      I && (A = -A), o(A <= 67108863);
      for (var U = (1 << 26) % A, X = 0, Q = this.length - 1; Q >= 0; Q--)
        X = (U * X + (this.words[Q] | 0)) % A;
      return I ? -X : X;
    }, g.prototype.modn = function(A) {
      return this.modrn(A);
    }, g.prototype.idivn = function(A) {
      var I = A < 0;
      I && (A = -A), o(A <= 67108863);
      for (var U = 0, X = this.length - 1; X >= 0; X--) {
        var Q = (this.words[X] | 0) + U * 67108864;
        this.words[X] = Q / A | 0, U = Q % A;
      }
      return this._strip(), I ? this.ineg() : this;
    }, g.prototype.divn = function(A) {
      return this.clone().idivn(A);
    }, g.prototype.egcd = function(A) {
      o(A.negative === 0), o(!A.isZero());
      var I = this, U = A.clone();
      I.negative !== 0 ? I = I.umod(A) : I = I.clone();
      for (var X = new g(1), Q = new g(0), F = new g(0), $ = new g(1), H = 0; I.isEven() && U.isEven(); )
        I.iushrn(1), U.iushrn(1), ++H;
      for (var q = U.clone(), z = I.clone(); !I.isZero(); ) {
        for (var me = 0, Ce = 1; !(I.words[0] & Ce) && me < 26; ++me, Ce <<= 1)
          ;
        if (me > 0)
          for (I.iushrn(me); me-- > 0; )
            (X.isOdd() || Q.isOdd()) && (X.iadd(q), Q.isub(z)), X.iushrn(1), Q.iushrn(1);
        for (var je = 0, Re = 1; !(U.words[0] & Re) && je < 26; ++je, Re <<= 1)
          ;
        if (je > 0)
          for (U.iushrn(je); je-- > 0; )
            (F.isOdd() || $.isOdd()) && (F.iadd(q), $.isub(z)), F.iushrn(1), $.iushrn(1);
        I.cmp(U) >= 0 ? (I.isub(U), X.isub(F), Q.isub($)) : (U.isub(I), F.isub(X), $.isub(Q));
      }
      return {
        a: F,
        b: $,
        gcd: U.iushln(H)
      };
    }, g.prototype._invmp = function(A) {
      o(A.negative === 0), o(!A.isZero());
      var I = this, U = A.clone();
      I.negative !== 0 ? I = I.umod(A) : I = I.clone();
      for (var X = new g(1), Q = new g(0), F = U.clone(); I.cmpn(1) > 0 && U.cmpn(1) > 0; ) {
        for (var $ = 0, H = 1; !(I.words[0] & H) && $ < 26; ++$, H <<= 1)
          ;
        if ($ > 0)
          for (I.iushrn($); $-- > 0; )
            X.isOdd() && X.iadd(F), X.iushrn(1);
        for (var q = 0, z = 1; !(U.words[0] & z) && q < 26; ++q, z <<= 1)
          ;
        if (q > 0)
          for (U.iushrn(q); q-- > 0; )
            Q.isOdd() && Q.iadd(F), Q.iushrn(1);
        I.cmp(U) >= 0 ? (I.isub(U), X.isub(Q)) : (U.isub(I), Q.isub(X));
      }
      var me;
      return I.cmpn(1) === 0 ? me = X : me = Q, me.cmpn(0) < 0 && me.iadd(A), me;
    }, g.prototype.gcd = function(A) {
      if (this.isZero())
        return A.abs();
      if (A.isZero())
        return this.abs();
      var I = this.clone(), U = A.clone();
      I.negative = 0, U.negative = 0;
      for (var X = 0; I.isEven() && U.isEven(); X++)
        I.iushrn(1), U.iushrn(1);
      do {
        for (; I.isEven(); )
          I.iushrn(1);
        for (; U.isEven(); )
          U.iushrn(1);
        var Q = I.cmp(U);
        if (Q < 0) {
          var F = I;
          I = U, U = F;
        } else if (Q === 0 || U.cmpn(1) === 0)
          break;
        I.isub(U);
      } while (!0);
      return U.iushln(X);
    }, g.prototype.invm = function(A) {
      return this.egcd(A).a.umod(A);
    }, g.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, g.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, g.prototype.andln = function(A) {
      return this.words[0] & A;
    }, g.prototype.bincn = function(A) {
      o(typeof A == "number");
      var I = A % 26, U = (A - I) / 26, X = 1 << I;
      if (this.length <= U)
        return this._expand(U + 1), this.words[U] |= X, this;
      for (var Q = X, F = U; Q !== 0 && F < this.length; F++) {
        var $ = this.words[F] | 0;
        $ += Q, Q = $ >>> 26, $ &= 67108863, this.words[F] = $;
      }
      return Q !== 0 && (this.words[F] = Q, this.length++), this;
    }, g.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, g.prototype.cmpn = function(A) {
      var I = A < 0;
      if (this.negative !== 0 && !I)
        return -1;
      if (this.negative === 0 && I)
        return 1;
      this._strip();
      var U;
      if (this.length > 1)
        U = 1;
      else {
        I && (A = -A), o(A <= 67108863, "Number is too big");
        var X = this.words[0] | 0;
        U = X === A ? 0 : X < A ? -1 : 1;
      }
      return this.negative !== 0 ? -U | 0 : U;
    }, g.prototype.cmp = function(A) {
      if (this.negative !== 0 && A.negative === 0)
        return -1;
      if (this.negative === 0 && A.negative !== 0)
        return 1;
      var I = this.ucmp(A);
      return this.negative !== 0 ? -I | 0 : I;
    }, g.prototype.ucmp = function(A) {
      if (this.length > A.length)
        return 1;
      if (this.length < A.length)
        return -1;
      for (var I = 0, U = this.length - 1; U >= 0; U--) {
        var X = this.words[U] | 0, Q = A.words[U] | 0;
        if (X !== Q) {
          X < Q ? I = -1 : X > Q && (I = 1);
          break;
        }
      }
      return I;
    }, g.prototype.gtn = function(A) {
      return this.cmpn(A) === 1;
    }, g.prototype.gt = function(A) {
      return this.cmp(A) === 1;
    }, g.prototype.gten = function(A) {
      return this.cmpn(A) >= 0;
    }, g.prototype.gte = function(A) {
      return this.cmp(A) >= 0;
    }, g.prototype.ltn = function(A) {
      return this.cmpn(A) === -1;
    }, g.prototype.lt = function(A) {
      return this.cmp(A) === -1;
    }, g.prototype.lten = function(A) {
      return this.cmpn(A) <= 0;
    }, g.prototype.lte = function(A) {
      return this.cmp(A) <= 0;
    }, g.prototype.eqn = function(A) {
      return this.cmpn(A) === 0;
    }, g.prototype.eq = function(A) {
      return this.cmp(A) === 0;
    }, g.red = function(A) {
      return new J(A);
    }, g.prototype.toRed = function(A) {
      return o(!this.red, "Already a number in reduction context"), o(this.negative === 0, "red works only with positives"), A.convertTo(this)._forceRed(A);
    }, g.prototype.fromRed = function() {
      return o(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, g.prototype._forceRed = function(A) {
      return this.red = A, this;
    }, g.prototype.forceRed = function(A) {
      return o(!this.red, "Already a number in reduction context"), this._forceRed(A);
    }, g.prototype.redAdd = function(A) {
      return o(this.red, "redAdd works only with red numbers"), this.red.add(this, A);
    }, g.prototype.redIAdd = function(A) {
      return o(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, A);
    }, g.prototype.redSub = function(A) {
      return o(this.red, "redSub works only with red numbers"), this.red.sub(this, A);
    }, g.prototype.redISub = function(A) {
      return o(this.red, "redISub works only with red numbers"), this.red.isub(this, A);
    }, g.prototype.redShl = function(A) {
      return o(this.red, "redShl works only with red numbers"), this.red.shl(this, A);
    }, g.prototype.redMul = function(A) {
      return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, A), this.red.mul(this, A);
    }, g.prototype.redIMul = function(A) {
      return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, A), this.red.imul(this, A);
    }, g.prototype.redSqr = function() {
      return o(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, g.prototype.redISqr = function() {
      return o(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, g.prototype.redSqrt = function() {
      return o(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, g.prototype.redInvm = function() {
      return o(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, g.prototype.redNeg = function() {
      return o(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, g.prototype.redPow = function(A) {
      return o(this.red && !A.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, A);
    };
    var Pe = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ue(A, I) {
      this.name = A, this.p = new g(I, 16), this.n = this.p.bitLength(), this.k = new g(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Ue.prototype._tmp = function() {
      var A = new g(null);
      return A.words = new Array(Math.ceil(this.n / 13)), A;
    }, Ue.prototype.ireduce = function(A) {
      var I = A, U;
      do
        this.split(I, this.tmp), I = this.imulK(I), I = I.iadd(this.tmp), U = I.bitLength();
      while (U > this.n);
      var X = U < this.n ? -1 : I.ucmp(this.p);
      return X === 0 ? (I.words[0] = 0, I.length = 1) : X > 0 ? I.isub(this.p) : I.strip !== void 0 ? I.strip() : I._strip(), I;
    }, Ue.prototype.split = function(A, I) {
      A.iushrn(this.n, 0, I);
    }, Ue.prototype.imulK = function(A) {
      return A.imul(this.k);
    };
    function ze() {
      Ue.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    S(ze, Ue), ze.prototype.split = function(A, I) {
      for (var U = 4194303, X = Math.min(A.length, 9), Q = 0; Q < X; Q++)
        I.words[Q] = A.words[Q];
      if (I.length = X, A.length <= 9) {
        A.words[0] = 0, A.length = 1;
        return;
      }
      var F = A.words[9];
      for (I.words[I.length++] = F & U, Q = 10; Q < A.length; Q++) {
        var $ = A.words[Q] | 0;
        A.words[Q - 10] = ($ & U) << 4 | F >>> 22, F = $;
      }
      F >>>= 22, A.words[Q - 10] = F, F === 0 && A.length > 10 ? A.length -= 10 : A.length -= 9;
    }, ze.prototype.imulK = function(A) {
      A.words[A.length] = 0, A.words[A.length + 1] = 0, A.length += 2;
      for (var I = 0, U = 0; U < A.length; U++) {
        var X = A.words[U] | 0;
        I += X * 977, A.words[U] = I & 67108863, I = X * 64 + (I / 67108864 | 0);
      }
      return A.words[A.length - 1] === 0 && (A.length--, A.words[A.length - 1] === 0 && A.length--), A;
    };
    function Le() {
      Ue.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    S(Le, Ue);
    function Ne() {
      Ue.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    S(Ne, Ue);
    function $e() {
      Ue.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    S($e, Ue), $e.prototype.imulK = function(A) {
      for (var I = 0, U = 0; U < A.length; U++) {
        var X = (A.words[U] | 0) * 19 + I, Q = X & 67108863;
        X >>>= 26, A.words[U] = Q, I = X;
      }
      return I !== 0 && (A.words[A.length++] = I), A;
    }, g._prime = function(A) {
      if (Pe[A])
        return Pe[A];
      var I;
      if (A === "k256")
        I = new ze();
      else if (A === "p224")
        I = new Le();
      else if (A === "p192")
        I = new Ne();
      else if (A === "p25519")
        I = new $e();
      else
        throw new Error("Unknown prime " + A);
      return Pe[A] = I, I;
    };
    function J(A) {
      if (typeof A == "string") {
        var I = g._prime(A);
        this.m = I.p, this.prime = I;
      } else
        o(A.gtn(1), "modulus must be greater than 1"), this.m = A, this.prime = null;
    }
    J.prototype._verify1 = function(A) {
      o(A.negative === 0, "red works only with positives"), o(A.red, "red works only with red numbers");
    }, J.prototype._verify2 = function(A, I) {
      o((A.negative | I.negative) === 0, "red works only with positives"), o(
        A.red && A.red === I.red,
        "red works only with red numbers"
      );
    }, J.prototype.imod = function(A) {
      return this.prime ? this.prime.ireduce(A)._forceRed(this) : (D(A, A.umod(this.m)._forceRed(this)), A);
    }, J.prototype.neg = function(A) {
      return A.isZero() ? A.clone() : this.m.sub(A)._forceRed(this);
    }, J.prototype.add = function(A, I) {
      this._verify2(A, I);
      var U = A.add(I);
      return U.cmp(this.m) >= 0 && U.isub(this.m), U._forceRed(this);
    }, J.prototype.iadd = function(A, I) {
      this._verify2(A, I);
      var U = A.iadd(I);
      return U.cmp(this.m) >= 0 && U.isub(this.m), U;
    }, J.prototype.sub = function(A, I) {
      this._verify2(A, I);
      var U = A.sub(I);
      return U.cmpn(0) < 0 && U.iadd(this.m), U._forceRed(this);
    }, J.prototype.isub = function(A, I) {
      this._verify2(A, I);
      var U = A.isub(I);
      return U.cmpn(0) < 0 && U.iadd(this.m), U;
    }, J.prototype.shl = function(A, I) {
      return this._verify1(A), this.imod(A.ushln(I));
    }, J.prototype.imul = function(A, I) {
      return this._verify2(A, I), this.imod(A.imul(I));
    }, J.prototype.mul = function(A, I) {
      return this._verify2(A, I), this.imod(A.mul(I));
    }, J.prototype.isqr = function(A) {
      return this.imul(A, A.clone());
    }, J.prototype.sqr = function(A) {
      return this.mul(A, A);
    }, J.prototype.sqrt = function(A) {
      if (A.isZero())
        return A.clone();
      var I = this.m.andln(3);
      if (o(I % 2 === 1), I === 3) {
        var U = this.m.add(new g(1)).iushrn(2);
        return this.pow(A, U);
      }
      for (var X = this.m.subn(1), Q = 0; !X.isZero() && X.andln(1) === 0; )
        Q++, X.iushrn(1);
      o(!X.isZero());
      var F = new g(1).toRed(this), $ = F.redNeg(), H = this.m.subn(1).iushrn(1), q = this.m.bitLength();
      for (q = new g(2 * q * q).toRed(this); this.pow(q, H).cmp($) !== 0; )
        q.redIAdd($);
      for (var z = this.pow(q, X), me = this.pow(A, X.addn(1).iushrn(1)), Ce = this.pow(A, X), je = Q; Ce.cmp(F) !== 0; ) {
        for (var Re = Ce, Ae = 0; Re.cmp(F) !== 0; Ae++)
          Re = Re.redSqr();
        o(Ae < je);
        var ke = this.pow(z, new g(1).iushln(je - Ae - 1));
        me = me.redMul(ke), z = ke.redSqr(), Ce = Ce.redMul(z), je = Ae;
      }
      return me;
    }, J.prototype.invm = function(A) {
      var I = A._invmp(this.m);
      return I.negative !== 0 ? (I.negative = 0, this.imod(I).redNeg()) : this.imod(I);
    }, J.prototype.pow = function(A, I) {
      if (I.isZero())
        return new g(1).toRed(this);
      if (I.cmpn(1) === 0)
        return A.clone();
      var U = 4, X = new Array(1 << U);
      X[0] = new g(1).toRed(this), X[1] = A;
      for (var Q = 2; Q < X.length; Q++)
        X[Q] = this.mul(X[Q - 1], A);
      var F = X[0], $ = 0, H = 0, q = I.bitLength() % 26;
      for (q === 0 && (q = 26), Q = I.length - 1; Q >= 0; Q--) {
        for (var z = I.words[Q], me = q - 1; me >= 0; me--) {
          var Ce = z >> me & 1;
          if (F !== X[0] && (F = this.sqr(F)), Ce === 0 && $ === 0) {
            H = 0;
            continue;
          }
          $ <<= 1, $ |= Ce, H++, !(H !== U && (Q !== 0 || me !== 0)) && (F = this.mul(F, X[$]), H = 0, $ = 0);
        }
        q = 26;
      }
      return F;
    }, J.prototype.convertTo = function(A) {
      var I = A.umod(this.m);
      return I === A ? I.clone() : I;
    }, J.prototype.convertFrom = function(A) {
      var I = A.clone();
      return I.red = null, I;
    }, g.mont = function(A) {
      return new ne(A);
    };
    function ne(A) {
      J.call(this, A), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new g(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    S(ne, J), ne.prototype.convertTo = function(A) {
      return this.imod(A.ushln(this.shift));
    }, ne.prototype.convertFrom = function(A) {
      var I = this.imod(A.mul(this.rinv));
      return I.red = null, I;
    }, ne.prototype.imul = function(A, I) {
      if (A.isZero() || I.isZero())
        return A.words[0] = 0, A.length = 1, A;
      var U = A.imul(I), X = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Q = U.isub(X).iushrn(this.shift), F = Q;
      return Q.cmp(this.m) >= 0 ? F = Q.isub(this.m) : Q.cmpn(0) < 0 && (F = Q.iadd(this.m)), F._forceRed(this);
    }, ne.prototype.mul = function(A, I) {
      if (A.isZero() || I.isZero())
        return new g(0)._forceRed(this);
      var U = A.mul(I), X = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Q = U.isub(X).iushrn(this.shift), F = Q;
      return Q.cmp(this.m) >= 0 ? F = Q.isub(this.m) : Q.cmpn(0) < 0 && (F = Q.iadd(this.m)), F._forceRed(this);
    }, ne.prototype.invm = function(A) {
      var I = this.imod(A._invmp(this.m).mul(this.r2));
      return I._forceRed(this);
    };
  })(e, Me);
})(ah);
var g3 = ah.exports, Ea = g3, m3 = Ua;
function b3(e) {
  var t = Wv(e), h = t.toRed(Ea.mont(e.modulus)).redPow(new Ea(e.publicExponent)).fromRed();
  return { blinder: h, unblinder: t.invm(e.modulus) };
}
function Wv(e) {
  var t = e.modulus.byteLength(), h;
  do
    h = new Ea(m3(t));
  while (h.cmp(e.modulus) >= 0 || !h.umod(e.prime1) || !h.umod(e.prime2));
  return h;
}
function Yv(e, t) {
  var h = b3(t), o = t.modulus.byteLength(), S = new Ea(e).mul(h.blinder).umod(t.modulus), g = S.toRed(Ea.mont(t.prime1)), B = S.toRed(Ea.mont(t.prime2)), M = t.coefficient, O = t.prime1, P = t.prime2, D = g.redPow(t.exponent1).fromRed(), Z = B.redPow(t.exponent2).fromRed(), Y = D.isub(Z).imul(M).umod(O).imul(P);
  return Z.iadd(Y).imul(h.unblinder).umod(t.modulus).toArrayLike(pe.Buffer, "be", o);
}
Yv.getr = Wv;
var sh = Yv, Co = {};
const x3 = "elliptic", _3 = "6.5.4", E3 = "EC cryptography", S3 = "lib/elliptic.js", w3 = [
  "lib"
], C3 = {
  lint: "eslint lib test",
  "lint:fix": "npm run lint -- --fix",
  unit: "istanbul test _mocha --reporter=spec test/index.js",
  test: "npm run lint && npm run unit",
  version: "grunt dist && git add dist/"
}, A3 = {
  type: "git",
  url: "git@github.com:indutny/elliptic"
}, B3 = [
  "EC",
  "Elliptic",
  "curve",
  "Cryptography"
], I3 = "Fedor Indutny <fedor@indutny.com>", T3 = "MIT", M3 = {
  url: "https://github.com/indutny/elliptic/issues"
}, R3 = "https://github.com/indutny/elliptic", N3 = {
  brfs: "^2.0.2",
  coveralls: "^3.1.0",
  eslint: "^7.6.0",
  grunt: "^1.2.1",
  "grunt-browserify": "^5.3.0",
  "grunt-cli": "^1.3.2",
  "grunt-contrib-connect": "^3.0.0",
  "grunt-contrib-copy": "^1.0.0",
  "grunt-contrib-uglify": "^5.0.0",
  "grunt-mocha-istanbul": "^5.0.2",
  "grunt-saucelabs": "^9.0.1",
  istanbul: "^0.4.5",
  mocha: "^8.0.1"
}, D3 = {
  "bn.js": "^4.11.9",
  brorand: "^1.1.0",
  "hash.js": "^1.0.0",
  "hmac-drbg": "^1.0.1",
  inherits: "^2.0.4",
  "minimalistic-assert": "^1.0.1",
  "minimalistic-crypto-utils": "^1.0.1"
}, O3 = {
  name: x3,
  version: _3,
  description: E3,
  main: S3,
  files: w3,
  scripts: C3,
  repository: A3,
  keywords: B3,
  author: I3,
  license: T3,
  bugs: M3,
  homepage: R3,
  devDependencies: N3,
  dependencies: D3
};
var Pr = {}, fh = {};
(function(e) {
  var t = e;
  function h(g, B) {
    if (Array.isArray(g))
      return g.slice();
    if (!g)
      return [];
    var M = [];
    if (typeof g != "string") {
      for (var O = 0; O < g.length; O++)
        M[O] = g[O] | 0;
      return M;
    }
    if (B === "hex") {
      g = g.replace(/[^a-z0-9]+/ig, ""), g.length % 2 !== 0 && (g = "0" + g);
      for (var O = 0; O < g.length; O += 2)
        M.push(parseInt(g[O] + g[O + 1], 16));
    } else
      for (var O = 0; O < g.length; O++) {
        var P = g.charCodeAt(O), D = P >> 8, Z = P & 255;
        D ? M.push(D, Z) : M.push(Z);
      }
    return M;
  }
  t.toArray = h;
  function o(g) {
    return g.length === 1 ? "0" + g : g;
  }
  t.zero2 = o;
  function S(g) {
    for (var B = "", M = 0; M < g.length; M++)
      B += o(g[M].toString(16));
    return B;
  }
  t.toHex = S, t.encode = function(g, B) {
    return B === "hex" ? S(g) : g;
  };
})(fh);
(function(e) {
  var t = e, h = rr, o = Qr, S = fh;
  t.assert = o, t.toArray = S.toArray, t.zero2 = S.zero2, t.toHex = S.toHex, t.encode = S.encode;
  function g(D, Z, Y) {
    var ee = new Array(Math.max(D.bitLength(), Y) + 1);
    ee.fill(0);
    for (var ie = 1 << Z + 1, ue = D.clone(), fe = 0; fe < ee.length; fe++) {
      var de, ce = ue.andln(ie - 1);
      ue.isOdd() ? (ce > (ie >> 1) - 1 ? de = (ie >> 1) - ce : de = ce, ue.isubn(de)) : de = 0, ee[fe] = de, ue.iushrn(1);
    }
    return ee;
  }
  t.getNAF = g;
  function B(D, Z) {
    var Y = [
      [],
      []
    ];
    D = D.clone(), Z = Z.clone();
    for (var ee = 0, ie = 0, ue; D.cmpn(-ee) > 0 || Z.cmpn(-ie) > 0; ) {
      var fe = D.andln(3) + ee & 3, de = Z.andln(3) + ie & 3;
      fe === 3 && (fe = -1), de === 3 && (de = -1);
      var ce;
      fe & 1 ? (ue = D.andln(7) + ee & 7, (ue === 3 || ue === 5) && de === 2 ? ce = -fe : ce = fe) : ce = 0, Y[0].push(ce);
      var be;
      de & 1 ? (ue = Z.andln(7) + ie & 7, (ue === 3 || ue === 5) && fe === 2 ? be = -de : be = de) : be = 0, Y[1].push(be), 2 * ee === ce + 1 && (ee = 1 - ee), 2 * ie === be + 1 && (ie = 1 - ie), D.iushrn(1), Z.iushrn(1);
    }
    return Y;
  }
  t.getJSF = B;
  function M(D, Z, Y) {
    var ee = "_" + Z;
    D.prototype[Z] = function() {
      return this[ee] !== void 0 ? this[ee] : this[ee] = Y.call(this);
    };
  }
  t.cachedProperty = M;
  function O(D) {
    return typeof D == "string" ? t.toArray(D, "hex") : D;
  }
  t.parseBytes = O;
  function P(D) {
    return new h(D, "hex", "le");
  }
  t.intFromLE = P;
})(Pr);
var oh = {}, kn = rr, V0 = Pr, Rs = V0.getNAF, P3 = V0.getJSF, Ns = V0.assert;
function Rn(e, t) {
  this.type = e, this.p = new kn(t.p, 16), this.red = t.prime ? kn.red(t.prime) : kn.mont(this.p), this.zero = new kn(0).toRed(this.red), this.one = new kn(1).toRed(this.red), this.two = new kn(2).toRed(this.red), this.n = t.n && new kn(t.n, 16), this.g = t.g && this.pointFromJSON(t.g, t.gRed), this._wnafT1 = new Array(4), this._wnafT2 = new Array(4), this._wnafT3 = new Array(4), this._wnafT4 = new Array(4), this._bitLength = this.n ? this.n.bitLength() : 0;
  var h = this.n && this.p.div(this.n);
  !h || h.cmpn(100) > 0 ? this.redN = null : (this._maxwellTrick = !0, this.redN = this.n.toRed(this.red));
}
var vf = Rn;
Rn.prototype.point = function() {
  throw new Error("Not implemented");
};
Rn.prototype.validate = function() {
  throw new Error("Not implemented");
};
Rn.prototype._fixedNafMul = function(e, t) {
  Ns(e.precomputed);
  var h = e._getDoubles(), o = Rs(t, 1, this._bitLength), S = (1 << h.step + 1) - (h.step % 2 === 0 ? 2 : 1);
  S /= 3;
  var g = [], B, M;
  for (B = 0; B < o.length; B += h.step) {
    M = 0;
    for (var O = B + h.step - 1; O >= B; O--)
      M = (M << 1) + o[O];
    g.push(M);
  }
  for (var P = this.jpoint(null, null, null), D = this.jpoint(null, null, null), Z = S; Z > 0; Z--) {
    for (B = 0; B < g.length; B++)
      M = g[B], M === Z ? D = D.mixedAdd(h.points[B]) : M === -Z && (D = D.mixedAdd(h.points[B].neg()));
    P = P.add(D);
  }
  return P.toP();
};
Rn.prototype._wnafMul = function(e, t) {
  var h = 4, o = e._getNAFPoints(h);
  h = o.wnd;
  for (var S = o.points, g = Rs(t, h, this._bitLength), B = this.jpoint(null, null, null), M = g.length - 1; M >= 0; M--) {
    for (var O = 0; M >= 0 && g[M] === 0; M--)
      O++;
    if (M >= 0 && O++, B = B.dblp(O), M < 0)
      break;
    var P = g[M];
    Ns(P !== 0), e.type === "affine" ? P > 0 ? B = B.mixedAdd(S[P - 1 >> 1]) : B = B.mixedAdd(S[-P - 1 >> 1].neg()) : P > 0 ? B = B.add(S[P - 1 >> 1]) : B = B.add(S[-P - 1 >> 1].neg());
  }
  return e.type === "affine" ? B.toP() : B;
};
Rn.prototype._wnafMulAdd = function(e, t, h, o, S) {
  var g = this._wnafT1, B = this._wnafT2, M = this._wnafT3, O = 0, P, D, Z;
  for (P = 0; P < o; P++) {
    Z = t[P];
    var Y = Z._getNAFPoints(e);
    g[P] = Y.wnd, B[P] = Y.points;
  }
  for (P = o - 1; P >= 1; P -= 2) {
    var ee = P - 1, ie = P;
    if (g[ee] !== 1 || g[ie] !== 1) {
      M[ee] = Rs(h[ee], g[ee], this._bitLength), M[ie] = Rs(h[ie], g[ie], this._bitLength), O = Math.max(M[ee].length, O), O = Math.max(M[ie].length, O);
      continue;
    }
    var ue = [
      t[ee],
      /* 1 */
      null,
      /* 3 */
      null,
      /* 5 */
      t[ie]
      /* 7 */
    ];
    t[ee].y.cmp(t[ie].y) === 0 ? (ue[1] = t[ee].add(t[ie]), ue[2] = t[ee].toJ().mixedAdd(t[ie].neg())) : t[ee].y.cmp(t[ie].y.redNeg()) === 0 ? (ue[1] = t[ee].toJ().mixedAdd(t[ie]), ue[2] = t[ee].add(t[ie].neg())) : (ue[1] = t[ee].toJ().mixedAdd(t[ie]), ue[2] = t[ee].toJ().mixedAdd(t[ie].neg()));
    var fe = [
      -3,
      /* -1 -1 */
      -1,
      /* -1 0 */
      -5,
      /* -1 1 */
      -7,
      /* 0 -1 */
      0,
      /* 0 0 */
      7,
      /* 0 1 */
      5,
      /* 1 -1 */
      1,
      /* 1 0 */
      3
      /* 1 1 */
    ], de = P3(h[ee], h[ie]);
    for (O = Math.max(de[0].length, O), M[ee] = new Array(O), M[ie] = new Array(O), D = 0; D < O; D++) {
      var ce = de[0][D] | 0, be = de[1][D] | 0;
      M[ee][D] = fe[(ce + 1) * 3 + (be + 1)], M[ie][D] = 0, B[ee] = ue;
    }
  }
  var ve = this.jpoint(null, null, null), Pe = this._wnafT4;
  for (P = O; P >= 0; P--) {
    for (var Ue = 0; P >= 0; ) {
      var ze = !0;
      for (D = 0; D < o; D++)
        Pe[D] = M[D][P] | 0, Pe[D] !== 0 && (ze = !1);
      if (!ze)
        break;
      Ue++, P--;
    }
    if (P >= 0 && Ue++, ve = ve.dblp(Ue), P < 0)
      break;
    for (D = 0; D < o; D++) {
      var Le = Pe[D];
      Le !== 0 && (Le > 0 ? Z = B[D][Le - 1 >> 1] : Le < 0 && (Z = B[D][-Le - 1 >> 1].neg()), Z.type === "affine" ? ve = ve.mixedAdd(Z) : ve = ve.add(Z));
    }
  }
  for (P = 0; P < o; P++)
    B[P] = null;
  return S ? ve : ve.toP();
};
function Jr(e, t) {
  this.curve = e, this.type = t, this.precomputed = null;
}
Rn.BasePoint = Jr;
Jr.prototype.eq = function() {
  throw new Error("Not implemented");
};
Jr.prototype.validate = function() {
  return this.curve.validate(this);
};
Rn.prototype.decodePoint = function(e, t) {
  e = V0.toArray(e, t);
  var h = this.p.byteLength();
  if ((e[0] === 4 || e[0] === 6 || e[0] === 7) && e.length - 1 === 2 * h) {
    e[0] === 6 ? Ns(e[e.length - 1] % 2 === 0) : e[0] === 7 && Ns(e[e.length - 1] % 2 === 1);
    var o = this.point(
      e.slice(1, 1 + h),
      e.slice(1 + h, 1 + 2 * h)
    );
    return o;
  } else if ((e[0] === 2 || e[0] === 3) && e.length - 1 === h)
    return this.pointFromX(e.slice(1, 1 + h), e[0] === 3);
  throw new Error("Unknown point format");
};
Jr.prototype.encodeCompressed = function(e) {
  return this.encode(e, !0);
};
Jr.prototype._encode = function(e) {
  var t = this.curve.p.byteLength(), h = this.getX().toArray("be", t);
  return e ? [this.getY().isEven() ? 2 : 3].concat(h) : [4].concat(h, this.getY().toArray("be", t));
};
Jr.prototype.encode = function(e, t) {
  return V0.encode(this._encode(t), e);
};
Jr.prototype.precompute = function(e) {
  if (this.precomputed)
    return this;
  var t = {
    doubles: null,
    naf: null,
    beta: null
  };
  return t.naf = this._getNAFPoints(8), t.doubles = this._getDoubles(4, e), t.beta = this._getBeta(), this.precomputed = t, this;
};
Jr.prototype._hasDoubles = function(e) {
  if (!this.precomputed)
    return !1;
  var t = this.precomputed.doubles;
  return t ? t.points.length >= Math.ceil((e.bitLength() + 1) / t.step) : !1;
};
Jr.prototype._getDoubles = function(e, t) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;
  for (var h = [this], o = this, S = 0; S < t; S += e) {
    for (var g = 0; g < e; g++)
      o = o.dbl();
    h.push(o);
  }
  return {
    step: e,
    points: h
  };
};
Jr.prototype._getNAFPoints = function(e) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;
  for (var t = [this], h = (1 << e) - 1, o = h === 1 ? null : this.dbl(), S = 1; S < h; S++)
    t[S] = t[S - 1].add(o);
  return {
    wnd: e,
    points: t
  };
};
Jr.prototype._getBeta = function() {
  return null;
};
Jr.prototype.dblp = function(e) {
  for (var t = this, h = 0; h < e; h++)
    t = t.dbl();
  return t;
};
var L3 = Pr, Vt = rr, uh = ut, Va = vf, k3 = L3.assert;
function ei(e) {
  Va.call(this, "short", e), this.a = new Vt(e.a, 16).toRed(this.red), this.b = new Vt(e.b, 16).toRed(this.red), this.tinv = this.two.redInvm(), this.zeroA = this.a.fromRed().cmpn(0) === 0, this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0, this.endo = this._getEndomorphism(e), this._endoWnafT1 = new Array(4), this._endoWnafT2 = new Array(4);
}
uh(ei, Va);
var U3 = ei;
ei.prototype._getEndomorphism = function(e) {
  if (!(!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)) {
    var t, h;
    if (e.beta)
      t = new Vt(e.beta, 16).toRed(this.red);
    else {
      var o = this._getEndoRoots(this.p);
      t = o[0].cmp(o[1]) < 0 ? o[0] : o[1], t = t.toRed(this.red);
    }
    if (e.lambda)
      h = new Vt(e.lambda, 16);
    else {
      var S = this._getEndoRoots(this.n);
      this.g.mul(S[0]).x.cmp(this.g.x.redMul(t)) === 0 ? h = S[0] : (h = S[1], k3(this.g.mul(h).x.cmp(this.g.x.redMul(t)) === 0));
    }
    var g;
    return e.basis ? g = e.basis.map(function(B) {
      return {
        a: new Vt(B.a, 16),
        b: new Vt(B.b, 16)
      };
    }) : g = this._getEndoBasis(h), {
      beta: t,
      lambda: h,
      basis: g
    };
  }
};
ei.prototype._getEndoRoots = function(e) {
  var t = e === this.p ? this.red : Vt.mont(e), h = new Vt(2).toRed(t).redInvm(), o = h.redNeg(), S = new Vt(3).toRed(t).redNeg().redSqrt().redMul(h), g = o.redAdd(S).fromRed(), B = o.redSub(S).fromRed();
  return [g, B];
};
ei.prototype._getEndoBasis = function(e) {
  for (var t = this.n.ushrn(Math.floor(this.n.bitLength() / 2)), h = e, o = this.n.clone(), S = new Vt(1), g = new Vt(0), B = new Vt(0), M = new Vt(1), O, P, D, Z, Y, ee, ie, ue = 0, fe, de; h.cmpn(0) !== 0; ) {
    var ce = o.div(h);
    fe = o.sub(ce.mul(h)), de = B.sub(ce.mul(S));
    var be = M.sub(ce.mul(g));
    if (!D && fe.cmp(t) < 0)
      O = ie.neg(), P = S, D = fe.neg(), Z = de;
    else if (D && ++ue === 2)
      break;
    ie = fe, o = h, h = fe, B = S, S = de, M = g, g = be;
  }
  Y = fe.neg(), ee = de;
  var ve = D.sqr().add(Z.sqr()), Pe = Y.sqr().add(ee.sqr());
  return Pe.cmp(ve) >= 0 && (Y = O, ee = P), D.negative && (D = D.neg(), Z = Z.neg()), Y.negative && (Y = Y.neg(), ee = ee.neg()), [
    { a: D, b: Z },
    { a: Y, b: ee }
  ];
};
ei.prototype._endoSplit = function(e) {
  var t = this.endo.basis, h = t[0], o = t[1], S = o.b.mul(e).divRound(this.n), g = h.b.neg().mul(e).divRound(this.n), B = S.mul(h.a), M = g.mul(o.a), O = S.mul(h.b), P = g.mul(o.b), D = e.sub(B).sub(M), Z = O.add(P).neg();
  return { k1: D, k2: Z };
};
ei.prototype.pointFromX = function(e, t) {
  e = new Vt(e, 16), e.red || (e = e.toRed(this.red));
  var h = e.redSqr().redMul(e).redIAdd(e.redMul(this.a)).redIAdd(this.b), o = h.redSqrt();
  if (o.redSqr().redSub(h).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var S = o.fromRed().isOdd();
  return (t && !S || !t && S) && (o = o.redNeg()), this.point(e, o);
};
ei.prototype.validate = function(e) {
  if (e.inf)
    return !0;
  var t = e.x, h = e.y, o = this.a.redMul(t), S = t.redSqr().redMul(t).redIAdd(o).redIAdd(this.b);
  return h.redSqr().redISub(S).cmpn(0) === 0;
};
ei.prototype._endoWnafMulAdd = function(e, t, h) {
  for (var o = this._endoWnafT1, S = this._endoWnafT2, g = 0; g < e.length; g++) {
    var B = this._endoSplit(t[g]), M = e[g], O = M._getBeta();
    B.k1.negative && (B.k1.ineg(), M = M.neg(!0)), B.k2.negative && (B.k2.ineg(), O = O.neg(!0)), o[g * 2] = M, o[g * 2 + 1] = O, S[g * 2] = B.k1, S[g * 2 + 1] = B.k2;
  }
  for (var P = this._wnafMulAdd(1, o, S, g * 2, h), D = 0; D < g * 2; D++)
    o[D] = null, S[D] = null;
  return P;
};
function ir(e, t, h, o) {
  Va.BasePoint.call(this, e, "affine"), t === null && h === null ? (this.x = null, this.y = null, this.inf = !0) : (this.x = new Vt(t, 16), this.y = new Vt(h, 16), o && (this.x.forceRed(this.curve.red), this.y.forceRed(this.curve.red)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.inf = !1);
}
uh(ir, Va.BasePoint);
ei.prototype.point = function(e, t, h) {
  return new ir(this, e, t, h);
};
ei.prototype.pointFromJSON = function(e, t) {
  return ir.fromJSON(this, e, t);
};
ir.prototype._getBeta = function() {
  if (this.curve.endo) {
    var e = this.precomputed;
    if (e && e.beta)
      return e.beta;
    var t = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (e) {
      var h = this.curve, o = function(S) {
        return h.point(S.x.redMul(h.endo.beta), S.y);
      };
      e.beta = t, t.precomputed = {
        beta: null,
        naf: e.naf && {
          wnd: e.naf.wnd,
          points: e.naf.points.map(o)
        },
        doubles: e.doubles && {
          step: e.doubles.step,
          points: e.doubles.points.map(o)
        }
      };
    }
    return t;
  }
};
ir.prototype.toJSON = function() {
  return this.precomputed ? [this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1)
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1)
    }
  }] : [this.x, this.y];
};
ir.fromJSON = function(e, t, h) {
  typeof t == "string" && (t = JSON.parse(t));
  var o = e.point(t[0], t[1], h);
  if (!t[2])
    return o;
  function S(B) {
    return e.point(B[0], B[1], h);
  }
  var g = t[2];
  return o.precomputed = {
    beta: null,
    doubles: g.doubles && {
      step: g.doubles.step,
      points: [o].concat(g.doubles.points.map(S))
    },
    naf: g.naf && {
      wnd: g.naf.wnd,
      points: [o].concat(g.naf.points.map(S))
    }
  }, o;
};
ir.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
};
ir.prototype.isInfinity = function() {
  return this.inf;
};
ir.prototype.add = function(e) {
  if (this.inf)
    return e;
  if (e.inf)
    return this;
  if (this.eq(e))
    return this.dbl();
  if (this.neg().eq(e))
    return this.curve.point(null, null);
  if (this.x.cmp(e.x) === 0)
    return this.curve.point(null, null);
  var t = this.y.redSub(e.y);
  t.cmpn(0) !== 0 && (t = t.redMul(this.x.redSub(e.x).redInvm()));
  var h = t.redSqr().redISub(this.x).redISub(e.x), o = t.redMul(this.x.redSub(h)).redISub(this.y);
  return this.curve.point(h, o);
};
ir.prototype.dbl = function() {
  if (this.inf)
    return this;
  var e = this.y.redAdd(this.y);
  if (e.cmpn(0) === 0)
    return this.curve.point(null, null);
  var t = this.curve.a, h = this.x.redSqr(), o = e.redInvm(), S = h.redAdd(h).redIAdd(h).redIAdd(t).redMul(o), g = S.redSqr().redISub(this.x.redAdd(this.x)), B = S.redMul(this.x.redSub(g)).redISub(this.y);
  return this.curve.point(g, B);
};
ir.prototype.getX = function() {
  return this.x.fromRed();
};
ir.prototype.getY = function() {
  return this.y.fromRed();
};
ir.prototype.mul = function(e) {
  return e = new Vt(e, 16), this.isInfinity() ? this : this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve.endo ? this.curve._endoWnafMulAdd([this], [e]) : this.curve._wnafMul(this, e);
};
ir.prototype.mulAdd = function(e, t, h) {
  var o = [this, t], S = [e, h];
  return this.curve.endo ? this.curve._endoWnafMulAdd(o, S) : this.curve._wnafMulAdd(1, o, S, 2);
};
ir.prototype.jmulAdd = function(e, t, h) {
  var o = [this, t], S = [e, h];
  return this.curve.endo ? this.curve._endoWnafMulAdd(o, S, !0) : this.curve._wnafMulAdd(1, o, S, 2, !0);
};
ir.prototype.eq = function(e) {
  return this === e || this.inf === e.inf && (this.inf || this.x.cmp(e.x) === 0 && this.y.cmp(e.y) === 0);
};
ir.prototype.neg = function(e) {
  if (this.inf)
    return this;
  var t = this.curve.point(this.x, this.y.redNeg());
  if (e && this.precomputed) {
    var h = this.precomputed, o = function(S) {
      return S.neg();
    };
    t.precomputed = {
      naf: h.naf && {
        wnd: h.naf.wnd,
        points: h.naf.points.map(o)
      },
      doubles: h.doubles && {
        step: h.doubles.step,
        points: h.doubles.points.map(o)
      }
    };
  }
  return t;
};
ir.prototype.toJ = function() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);
  var e = this.curve.jpoint(this.x, this.y, this.curve.one);
  return e;
};
function fr(e, t, h, o) {
  Va.BasePoint.call(this, e, "jacobian"), t === null && h === null && o === null ? (this.x = this.curve.one, this.y = this.curve.one, this.z = new Vt(0)) : (this.x = new Vt(t, 16), this.y = new Vt(h, 16), this.z = new Vt(o, 16)), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.zOne = this.z === this.curve.one;
}
uh(fr, Va.BasePoint);
ei.prototype.jpoint = function(e, t, h) {
  return new fr(this, e, t, h);
};
fr.prototype.toP = function() {
  if (this.isInfinity())
    return this.curve.point(null, null);
  var e = this.z.redInvm(), t = e.redSqr(), h = this.x.redMul(t), o = this.y.redMul(t).redMul(e);
  return this.curve.point(h, o);
};
fr.prototype.neg = function() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};
fr.prototype.add = function(e) {
  if (this.isInfinity())
    return e;
  if (e.isInfinity())
    return this;
  var t = e.z.redSqr(), h = this.z.redSqr(), o = this.x.redMul(t), S = e.x.redMul(h), g = this.y.redMul(t.redMul(e.z)), B = e.y.redMul(h.redMul(this.z)), M = o.redSub(S), O = g.redSub(B);
  if (M.cmpn(0) === 0)
    return O.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var P = M.redSqr(), D = P.redMul(M), Z = o.redMul(P), Y = O.redSqr().redIAdd(D).redISub(Z).redISub(Z), ee = O.redMul(Z.redISub(Y)).redISub(g.redMul(D)), ie = this.z.redMul(e.z).redMul(M);
  return this.curve.jpoint(Y, ee, ie);
};
fr.prototype.mixedAdd = function(e) {
  if (this.isInfinity())
    return e.toJ();
  if (e.isInfinity())
    return this;
  var t = this.z.redSqr(), h = this.x, o = e.x.redMul(t), S = this.y, g = e.y.redMul(t).redMul(this.z), B = h.redSub(o), M = S.redSub(g);
  if (B.cmpn(0) === 0)
    return M.cmpn(0) !== 0 ? this.curve.jpoint(null, null, null) : this.dbl();
  var O = B.redSqr(), P = O.redMul(B), D = h.redMul(O), Z = M.redSqr().redIAdd(P).redISub(D).redISub(D), Y = M.redMul(D.redISub(Z)).redISub(S.redMul(P)), ee = this.z.redMul(B);
  return this.curve.jpoint(Z, Y, ee);
};
fr.prototype.dblp = function(e) {
  if (e === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!e)
    return this.dbl();
  var t;
  if (this.curve.zeroA || this.curve.threeA) {
    var h = this;
    for (t = 0; t < e; t++)
      h = h.dbl();
    return h;
  }
  var o = this.curve.a, S = this.curve.tinv, g = this.x, B = this.y, M = this.z, O = M.redSqr().redSqr(), P = B.redAdd(B);
  for (t = 0; t < e; t++) {
    var D = g.redSqr(), Z = P.redSqr(), Y = Z.redSqr(), ee = D.redAdd(D).redIAdd(D).redIAdd(o.redMul(O)), ie = g.redMul(Z), ue = ee.redSqr().redISub(ie.redAdd(ie)), fe = ie.redISub(ue), de = ee.redMul(fe);
    de = de.redIAdd(de).redISub(Y);
    var ce = P.redMul(M);
    t + 1 < e && (O = O.redMul(Y)), g = ue, M = ce, P = de;
  }
  return this.curve.jpoint(g, P.redMul(S), M);
};
fr.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.zeroA ? this._zeroDbl() : this.curve.threeA ? this._threeDbl() : this._dbl();
};
fr.prototype._zeroDbl = function() {
  var e, t, h;
  if (this.zOne) {
    var o = this.x.redSqr(), S = this.y.redSqr(), g = S.redSqr(), B = this.x.redAdd(S).redSqr().redISub(o).redISub(g);
    B = B.redIAdd(B);
    var M = o.redAdd(o).redIAdd(o), O = M.redSqr().redISub(B).redISub(B), P = g.redIAdd(g);
    P = P.redIAdd(P), P = P.redIAdd(P), e = O, t = M.redMul(B.redISub(O)).redISub(P), h = this.y.redAdd(this.y);
  } else {
    var D = this.x.redSqr(), Z = this.y.redSqr(), Y = Z.redSqr(), ee = this.x.redAdd(Z).redSqr().redISub(D).redISub(Y);
    ee = ee.redIAdd(ee);
    var ie = D.redAdd(D).redIAdd(D), ue = ie.redSqr(), fe = Y.redIAdd(Y);
    fe = fe.redIAdd(fe), fe = fe.redIAdd(fe), e = ue.redISub(ee).redISub(ee), t = ie.redMul(ee.redISub(e)).redISub(fe), h = this.y.redMul(this.z), h = h.redIAdd(h);
  }
  return this.curve.jpoint(e, t, h);
};
fr.prototype._threeDbl = function() {
  var e, t, h;
  if (this.zOne) {
    var o = this.x.redSqr(), S = this.y.redSqr(), g = S.redSqr(), B = this.x.redAdd(S).redSqr().redISub(o).redISub(g);
    B = B.redIAdd(B);
    var M = o.redAdd(o).redIAdd(o).redIAdd(this.curve.a), O = M.redSqr().redISub(B).redISub(B);
    e = O;
    var P = g.redIAdd(g);
    P = P.redIAdd(P), P = P.redIAdd(P), t = M.redMul(B.redISub(O)).redISub(P), h = this.y.redAdd(this.y);
  } else {
    var D = this.z.redSqr(), Z = this.y.redSqr(), Y = this.x.redMul(Z), ee = this.x.redSub(D).redMul(this.x.redAdd(D));
    ee = ee.redAdd(ee).redIAdd(ee);
    var ie = Y.redIAdd(Y);
    ie = ie.redIAdd(ie);
    var ue = ie.redAdd(ie);
    e = ee.redSqr().redISub(ue), h = this.y.redAdd(this.z).redSqr().redISub(Z).redISub(D);
    var fe = Z.redSqr();
    fe = fe.redIAdd(fe), fe = fe.redIAdd(fe), fe = fe.redIAdd(fe), t = ee.redMul(ie.redISub(e)).redISub(fe);
  }
  return this.curve.jpoint(e, t, h);
};
fr.prototype._dbl = function() {
  var e = this.curve.a, t = this.x, h = this.y, o = this.z, S = o.redSqr().redSqr(), g = t.redSqr(), B = h.redSqr(), M = g.redAdd(g).redIAdd(g).redIAdd(e.redMul(S)), O = t.redAdd(t);
  O = O.redIAdd(O);
  var P = O.redMul(B), D = M.redSqr().redISub(P.redAdd(P)), Z = P.redISub(D), Y = B.redSqr();
  Y = Y.redIAdd(Y), Y = Y.redIAdd(Y), Y = Y.redIAdd(Y);
  var ee = M.redMul(Z).redISub(Y), ie = h.redAdd(h).redMul(o);
  return this.curve.jpoint(D, ee, ie);
};
fr.prototype.trpl = function() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);
  var e = this.x.redSqr(), t = this.y.redSqr(), h = this.z.redSqr(), o = t.redSqr(), S = e.redAdd(e).redIAdd(e), g = S.redSqr(), B = this.x.redAdd(t).redSqr().redISub(e).redISub(o);
  B = B.redIAdd(B), B = B.redAdd(B).redIAdd(B), B = B.redISub(g);
  var M = B.redSqr(), O = o.redIAdd(o);
  O = O.redIAdd(O), O = O.redIAdd(O), O = O.redIAdd(O);
  var P = S.redIAdd(B).redSqr().redISub(g).redISub(M).redISub(O), D = t.redMul(P);
  D = D.redIAdd(D), D = D.redIAdd(D);
  var Z = this.x.redMul(M).redISub(D);
  Z = Z.redIAdd(Z), Z = Z.redIAdd(Z);
  var Y = this.y.redMul(P.redMul(O.redISub(P)).redISub(B.redMul(M)));
  Y = Y.redIAdd(Y), Y = Y.redIAdd(Y), Y = Y.redIAdd(Y);
  var ee = this.z.redAdd(B).redSqr().redISub(h).redISub(M);
  return this.curve.jpoint(Z, Y, ee);
};
fr.prototype.mul = function(e, t) {
  return e = new Vt(e, t), this.curve._wnafMul(this, e);
};
fr.prototype.eq = function(e) {
  if (e.type === "affine")
    return this.eq(e.toJ());
  if (this === e)
    return !0;
  var t = this.z.redSqr(), h = e.z.redSqr();
  if (this.x.redMul(h).redISub(e.x.redMul(t)).cmpn(0) !== 0)
    return !1;
  var o = t.redMul(this.z), S = h.redMul(e.z);
  return this.y.redMul(S).redISub(e.y.redMul(o)).cmpn(0) === 0;
};
fr.prototype.eqXToP = function(e) {
  var t = this.z.redSqr(), h = e.toRed(this.curve.red).redMul(t);
  if (this.x.cmp(h) === 0)
    return !0;
  for (var o = e.clone(), S = this.curve.redN.redMul(t); ; ) {
    if (o.iadd(this.curve.n), o.cmp(this.curve.p) >= 0)
      return !1;
    if (h.redIAdd(S), this.x.cmp(h) === 0)
      return !0;
  }
};
fr.prototype.inspect = function() {
  return this.isInfinity() ? "<EC JPoint Infinity>" : "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
};
fr.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
var ya = rr, Xv = ut, yf = vf, F3 = Pr;
function Ka(e) {
  yf.call(this, "mont", e), this.a = new ya(e.a, 16).toRed(this.red), this.b = new ya(e.b, 16).toRed(this.red), this.i4 = new ya(4).toRed(this.red).redInvm(), this.two = new ya(2).toRed(this.red), this.a24 = this.i4.redMul(this.a.redAdd(this.two));
}
Xv(Ka, yf);
var q3 = Ka;
Ka.prototype.validate = function(e) {
  var t = e.normalize().x, h = t.redSqr(), o = h.redMul(t).redAdd(h.redMul(this.a)).redAdd(t), S = o.redSqrt();
  return S.redSqr().cmp(o) === 0;
};
function er(e, t, h) {
  yf.BasePoint.call(this, e, "projective"), t === null && h === null ? (this.x = this.curve.one, this.z = this.curve.zero) : (this.x = new ya(t, 16), this.z = new ya(h, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)));
}
Xv(er, yf.BasePoint);
Ka.prototype.decodePoint = function(e, t) {
  return this.point(F3.toArray(e, t), 1);
};
Ka.prototype.point = function(e, t) {
  return new er(this, e, t);
};
Ka.prototype.pointFromJSON = function(e) {
  return er.fromJSON(this, e);
};
er.prototype.precompute = function() {
};
er.prototype._encode = function() {
  return this.getX().toArray("be", this.curve.p.byteLength());
};
er.fromJSON = function(e, t) {
  return new er(e, t[0], t[1] || e.one);
};
er.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
er.prototype.isInfinity = function() {
  return this.z.cmpn(0) === 0;
};
er.prototype.dbl = function() {
  var e = this.x.redAdd(this.z), t = e.redSqr(), h = this.x.redSub(this.z), o = h.redSqr(), S = t.redSub(o), g = t.redMul(o), B = S.redMul(o.redAdd(this.curve.a24.redMul(S)));
  return this.curve.point(g, B);
};
er.prototype.add = function() {
  throw new Error("Not supported on Montgomery curve");
};
er.prototype.diffAdd = function(e, t) {
  var h = this.x.redAdd(this.z), o = this.x.redSub(this.z), S = e.x.redAdd(e.z), g = e.x.redSub(e.z), B = g.redMul(h), M = S.redMul(o), O = t.z.redMul(B.redAdd(M).redSqr()), P = t.x.redMul(B.redISub(M).redSqr());
  return this.curve.point(O, P);
};
er.prototype.mul = function(e) {
  for (var t = e.clone(), h = this, o = this.curve.point(null, null), S = this, g = []; t.cmpn(0) !== 0; t.iushrn(1))
    g.push(t.andln(1));
  for (var B = g.length - 1; B >= 0; B--)
    g[B] === 0 ? (h = h.diffAdd(o, S), o = o.dbl()) : (o = h.diffAdd(o, S), h = h.dbl());
  return o;
};
er.prototype.mulAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
er.prototype.jumlAdd = function() {
  throw new Error("Not supported on Montgomery curve");
};
er.prototype.eq = function(e) {
  return this.getX().cmp(e.getX()) === 0;
};
er.prototype.normalize = function() {
  return this.x = this.x.redMul(this.z.redInvm()), this.z = this.curve.one, this;
};
er.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
var V3 = Pr, tn = rr, Qv = ut, gf = vf, K3 = V3.assert;
function ji(e) {
  this.twisted = (e.a | 0) !== 1, this.mOneA = this.twisted && (e.a | 0) === -1, this.extended = this.mOneA, gf.call(this, "edwards", e), this.a = new tn(e.a, 16).umod(this.red.m), this.a = this.a.toRed(this.red), this.c = new tn(e.c, 16).toRed(this.red), this.c2 = this.c.redSqr(), this.d = new tn(e.d, 16).toRed(this.red), this.dd = this.d.redAdd(this.d), K3(!this.twisted || this.c.fromRed().cmpn(1) === 0), this.oneC = (e.c | 0) === 1;
}
Qv(ji, gf);
var $3 = ji;
ji.prototype._mulA = function(e) {
  return this.mOneA ? e.redNeg() : this.a.redMul(e);
};
ji.prototype._mulC = function(e) {
  return this.oneC ? e : this.c.redMul(e);
};
ji.prototype.jpoint = function(e, t, h, o) {
  return this.point(e, t, h, o);
};
ji.prototype.pointFromX = function(e, t) {
  e = new tn(e, 16), e.red || (e = e.toRed(this.red));
  var h = e.redSqr(), o = this.c2.redSub(this.a.redMul(h)), S = this.one.redSub(this.c2.redMul(this.d).redMul(h)), g = o.redMul(S.redInvm()), B = g.redSqrt();
  if (B.redSqr().redSub(g).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  var M = B.fromRed().isOdd();
  return (t && !M || !t && M) && (B = B.redNeg()), this.point(e, B);
};
ji.prototype.pointFromY = function(e, t) {
  e = new tn(e, 16), e.red || (e = e.toRed(this.red));
  var h = e.redSqr(), o = h.redSub(this.c2), S = h.redMul(this.d).redMul(this.c2).redSub(this.a), g = o.redMul(S.redInvm());
  if (g.cmp(this.zero) === 0) {
    if (t)
      throw new Error("invalid point");
    return this.point(this.zero, e);
  }
  var B = g.redSqrt();
  if (B.redSqr().redSub(g).cmp(this.zero) !== 0)
    throw new Error("invalid point");
  return B.fromRed().isOdd() !== t && (B = B.redNeg()), this.point(B, e);
};
ji.prototype.validate = function(e) {
  if (e.isInfinity())
    return !0;
  e.normalize();
  var t = e.x.redSqr(), h = e.y.redSqr(), o = t.redMul(this.a).redAdd(h), S = this.c2.redMul(this.one.redAdd(this.d.redMul(t).redMul(h)));
  return o.cmp(S) === 0;
};
function kt(e, t, h, o, S) {
  gf.BasePoint.call(this, e, "projective"), t === null && h === null && o === null ? (this.x = this.curve.zero, this.y = this.curve.one, this.z = this.curve.one, this.t = this.curve.zero, this.zOne = !0) : (this.x = new tn(t, 16), this.y = new tn(h, 16), this.z = o ? new tn(o, 16) : this.curve.one, this.t = S && new tn(S, 16), this.x.red || (this.x = this.x.toRed(this.curve.red)), this.y.red || (this.y = this.y.toRed(this.curve.red)), this.z.red || (this.z = this.z.toRed(this.curve.red)), this.t && !this.t.red && (this.t = this.t.toRed(this.curve.red)), this.zOne = this.z === this.curve.one, this.curve.extended && !this.t && (this.t = this.x.redMul(this.y), this.zOne || (this.t = this.t.redMul(this.z.redInvm()))));
}
Qv(kt, gf.BasePoint);
ji.prototype.pointFromJSON = function(e) {
  return kt.fromJSON(this, e);
};
ji.prototype.point = function(e, t, h, o) {
  return new kt(this, e, t, h, o);
};
kt.fromJSON = function(e, t) {
  return new kt(e, t[0], t[1], t[2]);
};
kt.prototype.inspect = function() {
  return this.isInfinity() ? "<EC Point Infinity>" : "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
};
kt.prototype.isInfinity = function() {
  return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
};
kt.prototype._extDbl = function() {
  var e = this.x.redSqr(), t = this.y.redSqr(), h = this.z.redSqr();
  h = h.redIAdd(h);
  var o = this.curve._mulA(e), S = this.x.redAdd(this.y).redSqr().redISub(e).redISub(t), g = o.redAdd(t), B = g.redSub(h), M = o.redSub(t), O = S.redMul(B), P = g.redMul(M), D = S.redMul(M), Z = B.redMul(g);
  return this.curve.point(O, P, Z, D);
};
kt.prototype._projDbl = function() {
  var e = this.x.redAdd(this.y).redSqr(), t = this.x.redSqr(), h = this.y.redSqr(), o, S, g, B, M, O;
  if (this.curve.twisted) {
    B = this.curve._mulA(t);
    var P = B.redAdd(h);
    this.zOne ? (o = e.redSub(t).redSub(h).redMul(P.redSub(this.curve.two)), S = P.redMul(B.redSub(h)), g = P.redSqr().redSub(P).redSub(P)) : (M = this.z.redSqr(), O = P.redSub(M).redISub(M), o = e.redSub(t).redISub(h).redMul(O), S = P.redMul(B.redSub(h)), g = P.redMul(O));
  } else
    B = t.redAdd(h), M = this.curve._mulC(this.z).redSqr(), O = B.redSub(M).redSub(M), o = this.curve._mulC(e.redISub(B)).redMul(O), S = this.curve._mulC(B).redMul(t.redISub(h)), g = B.redMul(O);
  return this.curve.point(o, S, g);
};
kt.prototype.dbl = function() {
  return this.isInfinity() ? this : this.curve.extended ? this._extDbl() : this._projDbl();
};
kt.prototype._extAdd = function(e) {
  var t = this.y.redSub(this.x).redMul(e.y.redSub(e.x)), h = this.y.redAdd(this.x).redMul(e.y.redAdd(e.x)), o = this.t.redMul(this.curve.dd).redMul(e.t), S = this.z.redMul(e.z.redAdd(e.z)), g = h.redSub(t), B = S.redSub(o), M = S.redAdd(o), O = h.redAdd(t), P = g.redMul(B), D = M.redMul(O), Z = g.redMul(O), Y = B.redMul(M);
  return this.curve.point(P, D, Y, Z);
};
kt.prototype._projAdd = function(e) {
  var t = this.z.redMul(e.z), h = t.redSqr(), o = this.x.redMul(e.x), S = this.y.redMul(e.y), g = this.curve.d.redMul(o).redMul(S), B = h.redSub(g), M = h.redAdd(g), O = this.x.redAdd(this.y).redMul(e.x.redAdd(e.y)).redISub(o).redISub(S), P = t.redMul(B).redMul(O), D, Z;
  return this.curve.twisted ? (D = t.redMul(M).redMul(S.redSub(this.curve._mulA(o))), Z = B.redMul(M)) : (D = t.redMul(M).redMul(S.redSub(o)), Z = this.curve._mulC(B).redMul(M)), this.curve.point(P, D, Z);
};
kt.prototype.add = function(e) {
  return this.isInfinity() ? e : e.isInfinity() ? this : this.curve.extended ? this._extAdd(e) : this._projAdd(e);
};
kt.prototype.mul = function(e) {
  return this._hasDoubles(e) ? this.curve._fixedNafMul(this, e) : this.curve._wnafMul(this, e);
};
kt.prototype.mulAdd = function(e, t, h) {
  return this.curve._wnafMulAdd(1, [this, t], [e, h], 2, !1);
};
kt.prototype.jmulAdd = function(e, t, h) {
  return this.curve._wnafMulAdd(1, [this, t], [e, h], 2, !0);
};
kt.prototype.normalize = function() {
  if (this.zOne)
    return this;
  var e = this.z.redInvm();
  return this.x = this.x.redMul(e), this.y = this.y.redMul(e), this.t && (this.t = this.t.redMul(e)), this.z = this.curve.one, this.zOne = !0, this;
};
kt.prototype.neg = function() {
  return this.curve.point(
    this.x.redNeg(),
    this.y,
    this.z,
    this.t && this.t.redNeg()
  );
};
kt.prototype.getX = function() {
  return this.normalize(), this.x.fromRed();
};
kt.prototype.getY = function() {
  return this.normalize(), this.y.fromRed();
};
kt.prototype.eq = function(e) {
  return this === e || this.getX().cmp(e.getX()) === 0 && this.getY().cmp(e.getY()) === 0;
};
kt.prototype.eqXToP = function(e) {
  var t = e.toRed(this.curve.red).redMul(this.z);
  if (this.x.cmp(t) === 0)
    return !0;
  for (var h = e.clone(), o = this.curve.redN.redMul(this.z); ; ) {
    if (h.iadd(this.curve.n), h.cmp(this.curve.p) >= 0)
      return !1;
    if (t.redIAdd(o), this.x.cmp(t) === 0)
      return !0;
  }
};
kt.prototype.toP = kt.prototype.normalize;
kt.prototype.mixedAdd = kt.prototype.add;
(function(e) {
  var t = e;
  t.base = vf, t.short = U3, t.mont = q3, t.edwards = $3;
})(oh);
var mf = {}, bf = {}, gt = {}, H3 = Qr, G3 = ut;
gt.inherits = G3;
function z3(e, t) {
  return (e.charCodeAt(t) & 64512) !== 55296 || t < 0 || t + 1 >= e.length ? !1 : (e.charCodeAt(t + 1) & 64512) === 56320;
}
function j3(e, t) {
  if (Array.isArray(e))
    return e.slice();
  if (!e)
    return [];
  var h = [];
  if (typeof e == "string")
    if (t) {
      if (t === "hex")
        for (e = e.replace(/[^a-z0-9]+/ig, ""), e.length % 2 !== 0 && (e = "0" + e), S = 0; S < e.length; S += 2)
          h.push(parseInt(e[S] + e[S + 1], 16));
    } else
      for (var o = 0, S = 0; S < e.length; S++) {
        var g = e.charCodeAt(S);
        g < 128 ? h[o++] = g : g < 2048 ? (h[o++] = g >> 6 | 192, h[o++] = g & 63 | 128) : z3(e, S) ? (g = 65536 + ((g & 1023) << 10) + (e.charCodeAt(++S) & 1023), h[o++] = g >> 18 | 240, h[o++] = g >> 12 & 63 | 128, h[o++] = g >> 6 & 63 | 128, h[o++] = g & 63 | 128) : (h[o++] = g >> 12 | 224, h[o++] = g >> 6 & 63 | 128, h[o++] = g & 63 | 128);
      }
  else
    for (S = 0; S < e.length; S++)
      h[S] = e[S] | 0;
  return h;
}
gt.toArray = j3;
function W3(e) {
  for (var t = "", h = 0; h < e.length; h++)
    t += Jv(e[h].toString(16));
  return t;
}
gt.toHex = W3;
function Zv(e) {
  var t = e >>> 24 | e >>> 8 & 65280 | e << 8 & 16711680 | (e & 255) << 24;
  return t >>> 0;
}
gt.htonl = Zv;
function Y3(e, t) {
  for (var h = "", o = 0; o < e.length; o++) {
    var S = e[o];
    t === "little" && (S = Zv(S)), h += ey(S.toString(16));
  }
  return h;
}
gt.toHex32 = Y3;
function Jv(e) {
  return e.length === 1 ? "0" + e : e;
}
gt.zero2 = Jv;
function ey(e) {
  return e.length === 7 ? "0" + e : e.length === 6 ? "00" + e : e.length === 5 ? "000" + e : e.length === 4 ? "0000" + e : e.length === 3 ? "00000" + e : e.length === 2 ? "000000" + e : e.length === 1 ? "0000000" + e : e;
}
gt.zero8 = ey;
function X3(e, t, h, o) {
  var S = h - t;
  H3(S % 4 === 0);
  for (var g = new Array(S / 4), B = 0, M = t; B < g.length; B++, M += 4) {
    var O;
    o === "big" ? O = e[M] << 24 | e[M + 1] << 16 | e[M + 2] << 8 | e[M + 3] : O = e[M + 3] << 24 | e[M + 2] << 16 | e[M + 1] << 8 | e[M], g[B] = O >>> 0;
  }
  return g;
}
gt.join32 = X3;
function Q3(e, t) {
  for (var h = new Array(e.length * 4), o = 0, S = 0; o < e.length; o++, S += 4) {
    var g = e[o];
    t === "big" ? (h[S] = g >>> 24, h[S + 1] = g >>> 16 & 255, h[S + 2] = g >>> 8 & 255, h[S + 3] = g & 255) : (h[S + 3] = g >>> 24, h[S + 2] = g >>> 16 & 255, h[S + 1] = g >>> 8 & 255, h[S] = g & 255);
  }
  return h;
}
gt.split32 = Q3;
function Z3(e, t) {
  return e >>> t | e << 32 - t;
}
gt.rotr32 = Z3;
function J3(e, t) {
  return e << t | e >>> 32 - t;
}
gt.rotl32 = J3;
function e6(e, t) {
  return e + t >>> 0;
}
gt.sum32 = e6;
function t6(e, t, h) {
  return e + t + h >>> 0;
}
gt.sum32_3 = t6;
function r6(e, t, h, o) {
  return e + t + h + o >>> 0;
}
gt.sum32_4 = r6;
function i6(e, t, h, o, S) {
  return e + t + h + o + S >>> 0;
}
gt.sum32_5 = i6;
function n6(e, t, h, o) {
  var S = e[t], g = e[t + 1], B = o + g >>> 0, M = (B < o ? 1 : 0) + h + S;
  e[t] = M >>> 0, e[t + 1] = B;
}
gt.sum64 = n6;
function a6(e, t, h, o) {
  var S = t + o >>> 0, g = (S < t ? 1 : 0) + e + h;
  return g >>> 0;
}
gt.sum64_hi = a6;
function s6(e, t, h, o) {
  var S = t + o;
  return S >>> 0;
}
gt.sum64_lo = s6;
function f6(e, t, h, o, S, g, B, M) {
  var O = 0, P = t;
  P = P + o >>> 0, O += P < t ? 1 : 0, P = P + g >>> 0, O += P < g ? 1 : 0, P = P + M >>> 0, O += P < M ? 1 : 0;
  var D = e + h + S + B + O;
  return D >>> 0;
}
gt.sum64_4_hi = f6;
function o6(e, t, h, o, S, g, B, M) {
  var O = t + o + g + M;
  return O >>> 0;
}
gt.sum64_4_lo = o6;
function u6(e, t, h, o, S, g, B, M, O, P) {
  var D = 0, Z = t;
  Z = Z + o >>> 0, D += Z < t ? 1 : 0, Z = Z + g >>> 0, D += Z < g ? 1 : 0, Z = Z + M >>> 0, D += Z < M ? 1 : 0, Z = Z + P >>> 0, D += Z < P ? 1 : 0;
  var Y = e + h + S + B + O + D;
  return Y >>> 0;
}
gt.sum64_5_hi = u6;
function c6(e, t, h, o, S, g, B, M, O, P) {
  var D = t + o + g + M + P;
  return D >>> 0;
}
gt.sum64_5_lo = c6;
function h6(e, t, h) {
  var o = t << 32 - h | e >>> h;
  return o >>> 0;
}
gt.rotr64_hi = h6;
function l6(e, t, h) {
  var o = e << 32 - h | t >>> h;
  return o >>> 0;
}
gt.rotr64_lo = l6;
function d6(e, t, h) {
  return e >>> h;
}
gt.shr64_hi = d6;
function p6(e, t, h) {
  var o = e << 32 - h | t >>> h;
  return o >>> 0;
}
gt.shr64_lo = p6;
var $a = {}, jl = gt, v6 = Qr;
function xf() {
  this.pending = null, this.pendingTotal = 0, this.blockSize = this.constructor.blockSize, this.outSize = this.constructor.outSize, this.hmacStrength = this.constructor.hmacStrength, this.padLength = this.constructor.padLength / 8, this.endian = "big", this._delta8 = this.blockSize / 8, this._delta32 = this.blockSize / 32;
}
$a.BlockHash = xf;
xf.prototype.update = function(e, t) {
  if (e = jl.toArray(e, t), this.pending ? this.pending = this.pending.concat(e) : this.pending = e, this.pendingTotal += e.length, this.pending.length >= this._delta8) {
    e = this.pending;
    var h = e.length % this._delta8;
    this.pending = e.slice(e.length - h, e.length), this.pending.length === 0 && (this.pending = null), e = jl.join32(e, 0, e.length - h, this.endian);
    for (var o = 0; o < e.length; o += this._delta32)
      this._update(e, o, o + this._delta32);
  }
  return this;
};
xf.prototype.digest = function(e) {
  return this.update(this._pad()), v6(this.pending === null), this._digest(e);
};
xf.prototype._pad = function() {
  var e = this.pendingTotal, t = this._delta8, h = t - (e + this.padLength) % t, o = new Array(h + this.padLength);
  o[0] = 128;
  for (var S = 1; S < h; S++)
    o[S] = 0;
  if (e <<= 3, this.endian === "big") {
    for (var g = 8; g < this.padLength; g++)
      o[S++] = 0;
    o[S++] = 0, o[S++] = 0, o[S++] = 0, o[S++] = 0, o[S++] = e >>> 24 & 255, o[S++] = e >>> 16 & 255, o[S++] = e >>> 8 & 255, o[S++] = e & 255;
  } else
    for (o[S++] = e & 255, o[S++] = e >>> 8 & 255, o[S++] = e >>> 16 & 255, o[S++] = e >>> 24 & 255, o[S++] = 0, o[S++] = 0, o[S++] = 0, o[S++] = 0, g = 8; g < this.padLength; g++)
      o[S++] = 0;
  return o;
};
var Ha = {}, Wi = {}, y6 = gt, qi = y6.rotr32;
function g6(e, t, h, o) {
  if (e === 0)
    return ty(t, h, o);
  if (e === 1 || e === 3)
    return iy(t, h, o);
  if (e === 2)
    return ry(t, h, o);
}
Wi.ft_1 = g6;
function ty(e, t, h) {
  return e & t ^ ~e & h;
}
Wi.ch32 = ty;
function ry(e, t, h) {
  return e & t ^ e & h ^ t & h;
}
Wi.maj32 = ry;
function iy(e, t, h) {
  return e ^ t ^ h;
}
Wi.p32 = iy;
function m6(e) {
  return qi(e, 2) ^ qi(e, 13) ^ qi(e, 22);
}
Wi.s0_256 = m6;
function b6(e) {
  return qi(e, 6) ^ qi(e, 11) ^ qi(e, 25);
}
Wi.s1_256 = b6;
function x6(e) {
  return qi(e, 7) ^ qi(e, 18) ^ e >>> 3;
}
Wi.g0_256 = x6;
function _6(e) {
  return qi(e, 17) ^ qi(e, 19) ^ e >>> 10;
}
Wi.g1_256 = _6;
var Ba = gt, E6 = $a, S6 = Wi, Ao = Ba.rotl32, c0 = Ba.sum32, w6 = Ba.sum32_5, C6 = S6.ft_1, ny = E6.BlockHash, A6 = [
  1518500249,
  1859775393,
  2400959708,
  3395469782
];
function Hi() {
  if (!(this instanceof Hi))
    return new Hi();
  ny.call(this), this.h = [
    1732584193,
    4023233417,
    2562383102,
    271733878,
    3285377520
  ], this.W = new Array(80);
}
Ba.inherits(Hi, ny);
var B6 = Hi;
Hi.blockSize = 512;
Hi.outSize = 160;
Hi.hmacStrength = 80;
Hi.padLength = 64;
Hi.prototype._update = function(e, t) {
  for (var h = this.W, o = 0; o < 16; o++)
    h[o] = e[t + o];
  for (; o < h.length; o++)
    h[o] = Ao(h[o - 3] ^ h[o - 8] ^ h[o - 14] ^ h[o - 16], 1);
  var S = this.h[0], g = this.h[1], B = this.h[2], M = this.h[3], O = this.h[4];
  for (o = 0; o < h.length; o++) {
    var P = ~~(o / 20), D = w6(Ao(S, 5), C6(P, g, B, M), O, h[o], A6[P]);
    O = M, M = B, B = Ao(g, 30), g = S, S = D;
  }
  this.h[0] = c0(this.h[0], S), this.h[1] = c0(this.h[1], g), this.h[2] = c0(this.h[2], B), this.h[3] = c0(this.h[3], M), this.h[4] = c0(this.h[4], O);
};
Hi.prototype._digest = function(e) {
  return e === "hex" ? Ba.toHex32(this.h, "big") : Ba.split32(this.h, "big");
};
var Ia = gt, I6 = $a, Ga = Wi, T6 = Qr, bi = Ia.sum32, M6 = Ia.sum32_4, R6 = Ia.sum32_5, N6 = Ga.ch32, D6 = Ga.maj32, O6 = Ga.s0_256, P6 = Ga.s1_256, L6 = Ga.g0_256, k6 = Ga.g1_256, ay = I6.BlockHash, U6 = [
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
];
function Gi() {
  if (!(this instanceof Gi))
    return new Gi();
  ay.call(this), this.h = [
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ], this.k = U6, this.W = new Array(64);
}
Ia.inherits(Gi, ay);
var sy = Gi;
Gi.blockSize = 512;
Gi.outSize = 256;
Gi.hmacStrength = 192;
Gi.padLength = 64;
Gi.prototype._update = function(e, t) {
  for (var h = this.W, o = 0; o < 16; o++)
    h[o] = e[t + o];
  for (; o < h.length; o++)
    h[o] = M6(k6(h[o - 2]), h[o - 7], L6(h[o - 15]), h[o - 16]);
  var S = this.h[0], g = this.h[1], B = this.h[2], M = this.h[3], O = this.h[4], P = this.h[5], D = this.h[6], Z = this.h[7];
  for (T6(this.k.length === h.length), o = 0; o < h.length; o++) {
    var Y = R6(Z, P6(O), N6(O, P, D), this.k[o], h[o]), ee = bi(O6(S), D6(S, g, B));
    Z = D, D = P, P = O, O = bi(M, Y), M = B, B = g, g = S, S = bi(Y, ee);
  }
  this.h[0] = bi(this.h[0], S), this.h[1] = bi(this.h[1], g), this.h[2] = bi(this.h[2], B), this.h[3] = bi(this.h[3], M), this.h[4] = bi(this.h[4], O), this.h[5] = bi(this.h[5], P), this.h[6] = bi(this.h[6], D), this.h[7] = bi(this.h[7], Z);
};
Gi.prototype._digest = function(e) {
  return e === "hex" ? Ia.toHex32(this.h, "big") : Ia.split32(this.h, "big");
};
var oc = gt, fy = sy;
function on() {
  if (!(this instanceof on))
    return new on();
  fy.call(this), this.h = [
    3238371032,
    914150663,
    812702999,
    4144912697,
    4290775857,
    1750603025,
    1694076839,
    3204075428
  ];
}
oc.inherits(on, fy);
var F6 = on;
on.blockSize = 512;
on.outSize = 224;
on.hmacStrength = 192;
on.padLength = 64;
on.prototype._digest = function(e) {
  return e === "hex" ? oc.toHex32(this.h.slice(0, 7), "big") : oc.split32(this.h.slice(0, 7), "big");
};
var Br = gt, q6 = $a, V6 = Qr, Vi = Br.rotr64_hi, Ki = Br.rotr64_lo, oy = Br.shr64_hi, uy = Br.shr64_lo, hn = Br.sum64, Bo = Br.sum64_hi, Io = Br.sum64_lo, K6 = Br.sum64_4_hi, $6 = Br.sum64_4_lo, H6 = Br.sum64_5_hi, G6 = Br.sum64_5_lo, cy = q6.BlockHash, z6 = [
  1116352408,
  3609767458,
  1899447441,
  602891725,
  3049323471,
  3964484399,
  3921009573,
  2173295548,
  961987163,
  4081628472,
  1508970993,
  3053834265,
  2453635748,
  2937671579,
  2870763221,
  3664609560,
  3624381080,
  2734883394,
  310598401,
  1164996542,
  607225278,
  1323610764,
  1426881987,
  3590304994,
  1925078388,
  4068182383,
  2162078206,
  991336113,
  2614888103,
  633803317,
  3248222580,
  3479774868,
  3835390401,
  2666613458,
  4022224774,
  944711139,
  264347078,
  2341262773,
  604807628,
  2007800933,
  770255983,
  1495990901,
  1249150122,
  1856431235,
  1555081692,
  3175218132,
  1996064986,
  2198950837,
  2554220882,
  3999719339,
  2821834349,
  766784016,
  2952996808,
  2566594879,
  3210313671,
  3203337956,
  3336571891,
  1034457026,
  3584528711,
  2466948901,
  113926993,
  3758326383,
  338241895,
  168717936,
  666307205,
  1188179964,
  773529912,
  1546045734,
  1294757372,
  1522805485,
  1396182291,
  2643833823,
  1695183700,
  2343527390,
  1986661051,
  1014477480,
  2177026350,
  1206759142,
  2456956037,
  344077627,
  2730485921,
  1290863460,
  2820302411,
  3158454273,
  3259730800,
  3505952657,
  3345764771,
  106217008,
  3516065817,
  3606008344,
  3600352804,
  1432725776,
  4094571909,
  1467031594,
  275423344,
  851169720,
  430227734,
  3100823752,
  506948616,
  1363258195,
  659060556,
  3750685593,
  883997877,
  3785050280,
  958139571,
  3318307427,
  1322822218,
  3812723403,
  1537002063,
  2003034995,
  1747873779,
  3602036899,
  1955562222,
  1575990012,
  2024104815,
  1125592928,
  2227730452,
  2716904306,
  2361852424,
  442776044,
  2428436474,
  593698344,
  2756734187,
  3733110249,
  3204031479,
  2999351573,
  3329325298,
  3815920427,
  3391569614,
  3928383900,
  3515267271,
  566280711,
  3940187606,
  3454069534,
  4118630271,
  4000239992,
  116418474,
  1914138554,
  174292421,
  2731055270,
  289380356,
  3203993006,
  460393269,
  320620315,
  685471733,
  587496836,
  852142971,
  1086792851,
  1017036298,
  365543100,
  1126000580,
  2618297676,
  1288033470,
  3409855158,
  1501505948,
  4234509866,
  1607167915,
  987167468,
  1816402316,
  1246189591
];
function wi() {
  if (!(this instanceof wi))
    return new wi();
  cy.call(this), this.h = [
    1779033703,
    4089235720,
    3144134277,
    2227873595,
    1013904242,
    4271175723,
    2773480762,
    1595750129,
    1359893119,
    2917565137,
    2600822924,
    725511199,
    528734635,
    4215389547,
    1541459225,
    327033209
  ], this.k = z6, this.W = new Array(160);
}
Br.inherits(wi, cy);
var hy = wi;
wi.blockSize = 1024;
wi.outSize = 512;
wi.hmacStrength = 192;
wi.padLength = 128;
wi.prototype._prepareBlock = function(e, t) {
  for (var h = this.W, o = 0; o < 32; o++)
    h[o] = e[t + o];
  for (; o < h.length; o += 2) {
    var S = i8(h[o - 4], h[o - 3]), g = n8(h[o - 4], h[o - 3]), B = h[o - 14], M = h[o - 13], O = t8(h[o - 30], h[o - 29]), P = r8(h[o - 30], h[o - 29]), D = h[o - 32], Z = h[o - 31];
    h[o] = K6(
      S,
      g,
      B,
      M,
      O,
      P,
      D,
      Z
    ), h[o + 1] = $6(
      S,
      g,
      B,
      M,
      O,
      P,
      D,
      Z
    );
  }
};
wi.prototype._update = function(e, t) {
  this._prepareBlock(e, t);
  var h = this.W, o = this.h[0], S = this.h[1], g = this.h[2], B = this.h[3], M = this.h[4], O = this.h[5], P = this.h[6], D = this.h[7], Z = this.h[8], Y = this.h[9], ee = this.h[10], ie = this.h[11], ue = this.h[12], fe = this.h[13], de = this.h[14], ce = this.h[15];
  V6(this.k.length === h.length);
  for (var be = 0; be < h.length; be += 2) {
    var ve = de, Pe = ce, Ue = J6(Z, Y), ze = e8(Z, Y), Le = j6(Z, Y, ee, ie, ue), Ne = W6(Z, Y, ee, ie, ue, fe), $e = this.k[be], J = this.k[be + 1], ne = h[be], A = h[be + 1], I = H6(
      ve,
      Pe,
      Ue,
      ze,
      Le,
      Ne,
      $e,
      J,
      ne,
      A
    ), U = G6(
      ve,
      Pe,
      Ue,
      ze,
      Le,
      Ne,
      $e,
      J,
      ne,
      A
    );
    ve = Q6(o, S), Pe = Z6(o, S), Ue = Y6(o, S, g, B, M), ze = X6(o, S, g, B, M, O);
    var X = Bo(ve, Pe, Ue, ze), Q = Io(ve, Pe, Ue, ze);
    de = ue, ce = fe, ue = ee, fe = ie, ee = Z, ie = Y, Z = Bo(P, D, I, U), Y = Io(D, D, I, U), P = M, D = O, M = g, O = B, g = o, B = S, o = Bo(I, U, X, Q), S = Io(I, U, X, Q);
  }
  hn(this.h, 0, o, S), hn(this.h, 2, g, B), hn(this.h, 4, M, O), hn(this.h, 6, P, D), hn(this.h, 8, Z, Y), hn(this.h, 10, ee, ie), hn(this.h, 12, ue, fe), hn(this.h, 14, de, ce);
};
wi.prototype._digest = function(e) {
  return e === "hex" ? Br.toHex32(this.h, "big") : Br.split32(this.h, "big");
};
function j6(e, t, h, o, S) {
  var g = e & h ^ ~e & S;
  return g < 0 && (g += 4294967296), g;
}
function W6(e, t, h, o, S, g) {
  var B = t & o ^ ~t & g;
  return B < 0 && (B += 4294967296), B;
}
function Y6(e, t, h, o, S) {
  var g = e & h ^ e & S ^ h & S;
  return g < 0 && (g += 4294967296), g;
}
function X6(e, t, h, o, S, g) {
  var B = t & o ^ t & g ^ o & g;
  return B < 0 && (B += 4294967296), B;
}
function Q6(e, t) {
  var h = Vi(e, t, 28), o = Vi(t, e, 2), S = Vi(t, e, 7), g = h ^ o ^ S;
  return g < 0 && (g += 4294967296), g;
}
function Z6(e, t) {
  var h = Ki(e, t, 28), o = Ki(t, e, 2), S = Ki(t, e, 7), g = h ^ o ^ S;
  return g < 0 && (g += 4294967296), g;
}
function J6(e, t) {
  var h = Vi(e, t, 14), o = Vi(e, t, 18), S = Vi(t, e, 9), g = h ^ o ^ S;
  return g < 0 && (g += 4294967296), g;
}
function e8(e, t) {
  var h = Ki(e, t, 14), o = Ki(e, t, 18), S = Ki(t, e, 9), g = h ^ o ^ S;
  return g < 0 && (g += 4294967296), g;
}
function t8(e, t) {
  var h = Vi(e, t, 1), o = Vi(e, t, 8), S = oy(e, t, 7), g = h ^ o ^ S;
  return g < 0 && (g += 4294967296), g;
}
function r8(e, t) {
  var h = Ki(e, t, 1), o = Ki(e, t, 8), S = uy(e, t, 7), g = h ^ o ^ S;
  return g < 0 && (g += 4294967296), g;
}
function i8(e, t) {
  var h = Vi(e, t, 19), o = Vi(t, e, 29), S = oy(e, t, 6), g = h ^ o ^ S;
  return g < 0 && (g += 4294967296), g;
}
function n8(e, t) {
  var h = Ki(e, t, 19), o = Ki(t, e, 29), S = uy(e, t, 6), g = h ^ o ^ S;
  return g < 0 && (g += 4294967296), g;
}
var uc = gt, ly = hy;
function un() {
  if (!(this instanceof un))
    return new un();
  ly.call(this), this.h = [
    3418070365,
    3238371032,
    1654270250,
    914150663,
    2438529370,
    812702999,
    355462360,
    4144912697,
    1731405415,
    4290775857,
    2394180231,
    1750603025,
    3675008525,
    1694076839,
    1203062813,
    3204075428
  ];
}
uc.inherits(un, ly);
var a8 = un;
un.blockSize = 1024;
un.outSize = 384;
un.hmacStrength = 192;
un.padLength = 128;
un.prototype._digest = function(e) {
  return e === "hex" ? uc.toHex32(this.h.slice(0, 12), "big") : uc.split32(this.h.slice(0, 12), "big");
};
Ha.sha1 = B6;
Ha.sha224 = F6;
Ha.sha256 = sy;
Ha.sha384 = a8;
Ha.sha512 = hy;
var dy = {}, Jn = gt, s8 = $a, J0 = Jn.rotl32, Wl = Jn.sum32, h0 = Jn.sum32_3, Yl = Jn.sum32_4, py = s8.BlockHash;
function zi() {
  if (!(this instanceof zi))
    return new zi();
  py.call(this), this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520], this.endian = "little";
}
Jn.inherits(zi, py);
dy.ripemd160 = zi;
zi.blockSize = 512;
zi.outSize = 160;
zi.hmacStrength = 192;
zi.padLength = 64;
zi.prototype._update = function(e, t) {
  for (var h = this.h[0], o = this.h[1], S = this.h[2], g = this.h[3], B = this.h[4], M = h, O = o, P = S, D = g, Z = B, Y = 0; Y < 80; Y++) {
    var ee = Wl(
      J0(
        Yl(h, Xl(Y, o, S, g), e[u8[Y] + t], f8(Y)),
        h8[Y]
      ),
      B
    );
    h = B, B = g, g = J0(S, 10), S = o, o = ee, ee = Wl(
      J0(
        Yl(M, Xl(79 - Y, O, P, D), e[c8[Y] + t], o8(Y)),
        l8[Y]
      ),
      Z
    ), M = Z, Z = D, D = J0(P, 10), P = O, O = ee;
  }
  ee = h0(this.h[1], S, D), this.h[1] = h0(this.h[2], g, Z), this.h[2] = h0(this.h[3], B, M), this.h[3] = h0(this.h[4], h, O), this.h[4] = h0(this.h[0], o, P), this.h[0] = ee;
};
zi.prototype._digest = function(e) {
  return e === "hex" ? Jn.toHex32(this.h, "little") : Jn.split32(this.h, "little");
};
function Xl(e, t, h, o) {
  return e <= 15 ? t ^ h ^ o : e <= 31 ? t & h | ~t & o : e <= 47 ? (t | ~h) ^ o : e <= 63 ? t & o | h & ~o : t ^ (h | ~o);
}
function f8(e) {
  return e <= 15 ? 0 : e <= 31 ? 1518500249 : e <= 47 ? 1859775393 : e <= 63 ? 2400959708 : 2840853838;
}
function o8(e) {
  return e <= 15 ? 1352829926 : e <= 31 ? 1548603684 : e <= 47 ? 1836072691 : e <= 63 ? 2053994217 : 0;
}
var u8 = [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  7,
  4,
  13,
  1,
  10,
  6,
  15,
  3,
  12,
  0,
  9,
  5,
  2,
  14,
  11,
  8,
  3,
  10,
  14,
  4,
  9,
  15,
  8,
  1,
  2,
  7,
  0,
  6,
  13,
  11,
  5,
  12,
  1,
  9,
  11,
  10,
  0,
  8,
  12,
  4,
  13,
  3,
  7,
  15,
  14,
  5,
  6,
  2,
  4,
  0,
  5,
  9,
  7,
  12,
  2,
  10,
  14,
  1,
  3,
  8,
  11,
  6,
  15,
  13
], c8 = [
  5,
  14,
  7,
  0,
  9,
  2,
  11,
  4,
  13,
  6,
  15,
  8,
  1,
  10,
  3,
  12,
  6,
  11,
  3,
  7,
  0,
  13,
  5,
  10,
  14,
  15,
  8,
  12,
  4,
  9,
  1,
  2,
  15,
  5,
  1,
  3,
  7,
  14,
  6,
  9,
  11,
  8,
  12,
  2,
  10,
  0,
  4,
  13,
  8,
  6,
  4,
  1,
  3,
  11,
  15,
  0,
  5,
  12,
  2,
  13,
  9,
  7,
  10,
  14,
  12,
  15,
  10,
  4,
  1,
  5,
  8,
  7,
  6,
  2,
  13,
  14,
  0,
  3,
  9,
  11
], h8 = [
  11,
  14,
  15,
  12,
  5,
  8,
  7,
  9,
  11,
  13,
  14,
  15,
  6,
  7,
  9,
  8,
  7,
  6,
  8,
  13,
  11,
  9,
  7,
  15,
  7,
  12,
  15,
  9,
  11,
  7,
  13,
  12,
  11,
  13,
  6,
  7,
  14,
  9,
  13,
  15,
  14,
  8,
  13,
  6,
  5,
  12,
  7,
  5,
  11,
  12,
  14,
  15,
  14,
  15,
  9,
  8,
  9,
  14,
  5,
  6,
  8,
  6,
  5,
  12,
  9,
  15,
  5,
  11,
  6,
  8,
  13,
  12,
  5,
  12,
  13,
  14,
  11,
  8,
  5,
  6
], l8 = [
  8,
  9,
  9,
  11,
  13,
  15,
  15,
  5,
  7,
  7,
  8,
  11,
  14,
  14,
  12,
  6,
  9,
  13,
  15,
  7,
  12,
  8,
  9,
  11,
  7,
  7,
  12,
  7,
  6,
  15,
  13,
  11,
  9,
  7,
  15,
  11,
  8,
  6,
  6,
  14,
  12,
  13,
  5,
  14,
  13,
  13,
  7,
  5,
  15,
  5,
  8,
  11,
  14,
  14,
  6,
  14,
  6,
  9,
  12,
  9,
  12,
  5,
  15,
  8,
  8,
  5,
  12,
  9,
  12,
  5,
  14,
  6,
  8,
  13,
  6,
  5,
  15,
  13,
  11,
  11
], d8 = gt, p8 = Qr;
function Ta(e, t, h) {
  if (!(this instanceof Ta))
    return new Ta(e, t, h);
  this.Hash = e, this.blockSize = e.blockSize / 8, this.outSize = e.outSize / 8, this.inner = null, this.outer = null, this._init(d8.toArray(t, h));
}
var v8 = Ta;
Ta.prototype._init = function(e) {
  e.length > this.blockSize && (e = new this.Hash().update(e).digest()), p8(e.length <= this.blockSize);
  for (var t = e.length; t < this.blockSize; t++)
    e.push(0);
  for (t = 0; t < e.length; t++)
    e[t] ^= 54;
  for (this.inner = new this.Hash().update(e), t = 0; t < e.length; t++)
    e[t] ^= 106;
  this.outer = new this.Hash().update(e);
};
Ta.prototype.update = function(e, t) {
  return this.inner.update(e, t), this;
};
Ta.prototype.digest = function(e) {
  return this.outer.update(this.inner.digest()), this.outer.digest(e);
};
(function(e) {
  var t = e;
  t.utils = gt, t.common = $a, t.sha = Ha, t.ripemd = dy, t.hmac = v8, t.sha1 = t.sha.sha1, t.sha256 = t.sha.sha256, t.sha224 = t.sha.sha224, t.sha384 = t.sha.sha384, t.sha512 = t.sha.sha512, t.ripemd160 = t.ripemd.ripemd160;
})(bf);
var To, Ql;
function y8() {
  return Ql || (Ql = 1, To = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  }), To;
}
(function(e) {
  var t = e, h = bf, o = oh, S = Pr, g = S.assert;
  function B(P) {
    P.type === "short" ? this.curve = new o.short(P) : P.type === "edwards" ? this.curve = new o.edwards(P) : this.curve = new o.mont(P), this.g = this.curve.g, this.n = this.curve.n, this.hash = P.hash, g(this.g.validate(), "Invalid curve"), g(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  t.PresetCurve = B;
  function M(P, D) {
    Object.defineProperty(t, P, {
      configurable: !0,
      enumerable: !0,
      get: function() {
        var Z = new B(D);
        return Object.defineProperty(t, P, {
          configurable: !0,
          enumerable: !0,
          value: Z
        }), Z;
      }
    });
  }
  M("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: h.sha256,
    gRed: !1,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  }), M("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: h.sha256,
    gRed: !1,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  }), M("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: h.sha256,
    gRed: !1,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  }), M("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: h.sha384,
    gRed: !1,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  }), M("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: h.sha512,
    gRed: !1,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  }), M("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: h.sha256,
    gRed: !1,
    g: [
      "9"
    ]
  }), M("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    // -121665 * (121666^(-1)) (mod P)
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: h.sha256,
    gRed: !1,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      // 4/5
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var O;
  try {
    O = y8();
  } catch {
    O = void 0;
  }
  M("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: h.sha256,
    // Precomputed endomorphism
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: !1,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      O
    ]
  });
})(mf);
var g8 = bf, Wn = fh, vy = Qr;
function Cn(e) {
  if (!(this instanceof Cn))
    return new Cn(e);
  this.hash = e.hash, this.predResist = !!e.predResist, this.outLen = this.hash.outSize, this.minEntropy = e.minEntropy || this.hash.hmacStrength, this._reseed = null, this.reseedInterval = null, this.K = null, this.V = null;
  var t = Wn.toArray(e.entropy, e.entropyEnc || "hex"), h = Wn.toArray(e.nonce, e.nonceEnc || "hex"), o = Wn.toArray(e.pers, e.persEnc || "hex");
  vy(
    t.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._init(t, h, o);
}
var m8 = Cn;
Cn.prototype._init = function(e, t, h) {
  var o = e.concat(t).concat(h);
  this.K = new Array(this.outLen / 8), this.V = new Array(this.outLen / 8);
  for (var S = 0; S < this.V.length; S++)
    this.K[S] = 0, this.V[S] = 1;
  this._update(o), this._reseed = 1, this.reseedInterval = 281474976710656;
};
Cn.prototype._hmac = function() {
  return new g8.hmac(this.hash, this.K);
};
Cn.prototype._update = function(e) {
  var t = this._hmac().update(this.V).update([0]);
  e && (t = t.update(e)), this.K = t.digest(), this.V = this._hmac().update(this.V).digest(), e && (this.K = this._hmac().update(this.V).update([1]).update(e).digest(), this.V = this._hmac().update(this.V).digest());
};
Cn.prototype.reseed = function(e, t, h, o) {
  typeof t != "string" && (o = h, h = t, t = null), e = Wn.toArray(e, t), h = Wn.toArray(h, o), vy(
    e.length >= this.minEntropy / 8,
    "Not enough entropy. Minimum is: " + this.minEntropy + " bits"
  ), this._update(e.concat(h || [])), this._reseed = 1;
};
Cn.prototype.generate = function(e, t, h, o) {
  if (this._reseed > this.reseedInterval)
    throw new Error("Reseed is required");
  typeof t != "string" && (o = h, h = t, t = null), h && (h = Wn.toArray(h, o || "hex"), this._update(h));
  for (var S = []; S.length < e; )
    this.V = this._hmac().update(this.V).digest(), S = S.concat(this.V);
  var g = S.slice(0, e);
  return this._update(h), this._reseed++, Wn.encode(g, t);
};
var b8 = rr, x8 = Pr, cc = x8.assert;
function dr(e, t) {
  this.ec = e, this.priv = null, this.pub = null, t.priv && this._importPrivate(t.priv, t.privEnc), t.pub && this._importPublic(t.pub, t.pubEnc);
}
var _8 = dr;
dr.fromPublic = function(e, t, h) {
  return t instanceof dr ? t : new dr(e, {
    pub: t,
    pubEnc: h
  });
};
dr.fromPrivate = function(e, t, h) {
  return t instanceof dr ? t : new dr(e, {
    priv: t,
    privEnc: h
  });
};
dr.prototype.validate = function() {
  var e = this.getPublic();
  return e.isInfinity() ? { result: !1, reason: "Invalid public key" } : e.validate() ? e.mul(this.ec.curve.n).isInfinity() ? { result: !0, reason: null } : { result: !1, reason: "Public key * N != O" } : { result: !1, reason: "Public key is not a point" };
};
dr.prototype.getPublic = function(e, t) {
  return typeof e == "string" && (t = e, e = null), this.pub || (this.pub = this.ec.g.mul(this.priv)), t ? this.pub.encode(t, e) : this.pub;
};
dr.prototype.getPrivate = function(e) {
  return e === "hex" ? this.priv.toString(16, 2) : this.priv;
};
dr.prototype._importPrivate = function(e, t) {
  this.priv = new b8(e, t || 16), this.priv = this.priv.umod(this.ec.curve.n);
};
dr.prototype._importPublic = function(e, t) {
  if (e.x || e.y) {
    this.ec.curve.type === "mont" ? cc(e.x, "Need x coordinate") : (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") && cc(e.x && e.y, "Need both x and y coordinate"), this.pub = this.ec.curve.point(e.x, e.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(e, t);
};
dr.prototype.derive = function(e) {
  return e.validate() || cc(e.validate(), "public point not validated"), e.mul(this.priv).getX();
};
dr.prototype.sign = function(e, t, h) {
  return this.ec.sign(e, this, t, h);
};
dr.prototype.verify = function(e, t) {
  return this.ec.verify(e, t, this);
};
dr.prototype.inspect = function() {
  return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
};
var Ds = rr, ch = Pr, E8 = ch.assert;
function _f(e, t) {
  if (e instanceof _f)
    return e;
  this._importDER(e, t) || (E8(e.r && e.s, "Signature without r or s"), this.r = new Ds(e.r, 16), this.s = new Ds(e.s, 16), e.recoveryParam === void 0 ? this.recoveryParam = null : this.recoveryParam = e.recoveryParam);
}
var S8 = _f;
function w8() {
  this.place = 0;
}
function Mo(e, t) {
  var h = e[t.place++];
  if (!(h & 128))
    return h;
  var o = h & 15;
  if (o === 0 || o > 4)
    return !1;
  for (var S = 0, g = 0, B = t.place; g < o; g++, B++)
    S <<= 8, S |= e[B], S >>>= 0;
  return S <= 127 ? !1 : (t.place = B, S);
}
function Zl(e) {
  for (var t = 0, h = e.length - 1; !e[t] && !(e[t + 1] & 128) && t < h; )
    t++;
  return t === 0 ? e : e.slice(t);
}
_f.prototype._importDER = function(e, t) {
  e = ch.toArray(e, t);
  var h = new w8();
  if (e[h.place++] !== 48)
    return !1;
  var o = Mo(e, h);
  if (o === !1 || o + h.place !== e.length || e[h.place++] !== 2)
    return !1;
  var S = Mo(e, h);
  if (S === !1)
    return !1;
  var g = e.slice(h.place, S + h.place);
  if (h.place += S, e[h.place++] !== 2)
    return !1;
  var B = Mo(e, h);
  if (B === !1 || e.length !== B + h.place)
    return !1;
  var M = e.slice(h.place, B + h.place);
  if (g[0] === 0)
    if (g[1] & 128)
      g = g.slice(1);
    else
      return !1;
  if (M[0] === 0)
    if (M[1] & 128)
      M = M.slice(1);
    else
      return !1;
  return this.r = new Ds(g), this.s = new Ds(M), this.recoveryParam = null, !0;
};
function Ro(e, t) {
  if (t < 128) {
    e.push(t);
    return;
  }
  var h = 1 + (Math.log(t) / Math.LN2 >>> 3);
  for (e.push(h | 128); --h; )
    e.push(t >>> (h << 3) & 255);
  e.push(t);
}
_f.prototype.toDER = function(e) {
  var t = this.r.toArray(), h = this.s.toArray();
  for (t[0] & 128 && (t = [0].concat(t)), h[0] & 128 && (h = [0].concat(h)), t = Zl(t), h = Zl(h); !h[0] && !(h[1] & 128); )
    h = h.slice(1);
  var o = [2];
  Ro(o, t.length), o = o.concat(t), o.push(2), Ro(o, h.length);
  var S = o.concat(h), g = [48];
  return Ro(g, S.length), g = g.concat(S), ch.encode(g, e);
};
var No, Jl;
function C8() {
  if (Jl)
    return No;
  Jl = 1;
  var e = rr, t = m8, h = Pr, o = mf, S = nh(), g = h.assert, B = _8, M = S8;
  function O(P) {
    if (!(this instanceof O))
      return new O(P);
    typeof P == "string" && (g(
      Object.prototype.hasOwnProperty.call(o, P),
      "Unknown curve " + P
    ), P = o[P]), P instanceof o.PresetCurve && (P = { curve: P }), this.curve = P.curve.curve, this.n = this.curve.n, this.nh = this.n.ushrn(1), this.g = this.curve.g, this.g = P.curve.g, this.g.precompute(P.curve.n.bitLength() + 1), this.hash = P.hash || P.curve.hash;
  }
  return No = O, O.prototype.keyPair = function(P) {
    return new B(this, P);
  }, O.prototype.keyFromPrivate = function(P, D) {
    return B.fromPrivate(this, P, D);
  }, O.prototype.keyFromPublic = function(P, D) {
    return B.fromPublic(this, P, D);
  }, O.prototype.genKeyPair = function(P) {
    P || (P = {});
    for (var D = new t({
      hash: this.hash,
      pers: P.pers,
      persEnc: P.persEnc || "utf8",
      entropy: P.entropy || S(this.hash.hmacStrength),
      entropyEnc: P.entropy && P.entropyEnc || "utf8",
      nonce: this.n.toArray()
    }), Z = this.n.byteLength(), Y = this.n.sub(new e(2)); ; ) {
      var ee = new e(D.generate(Z));
      if (!(ee.cmp(Y) > 0))
        return ee.iaddn(1), this.keyFromPrivate(ee);
    }
  }, O.prototype._truncateToN = function(P, D) {
    var Z = P.byteLength() * 8 - this.n.bitLength();
    return Z > 0 && (P = P.ushrn(Z)), !D && P.cmp(this.n) >= 0 ? P.sub(this.n) : P;
  }, O.prototype.sign = function(P, D, Z, Y) {
    typeof Z == "object" && (Y = Z, Z = null), Y || (Y = {}), D = this.keyFromPrivate(D, Z), P = this._truncateToN(new e(P, 16));
    for (var ee = this.n.byteLength(), ie = D.getPrivate().toArray("be", ee), ue = P.toArray("be", ee), fe = new t({
      hash: this.hash,
      entropy: ie,
      nonce: ue,
      pers: Y.pers,
      persEnc: Y.persEnc || "utf8"
    }), de = this.n.sub(new e(1)), ce = 0; ; ce++) {
      var be = Y.k ? Y.k(ce) : new e(fe.generate(this.n.byteLength()));
      if (be = this._truncateToN(be, !0), !(be.cmpn(1) <= 0 || be.cmp(de) >= 0)) {
        var ve = this.g.mul(be);
        if (!ve.isInfinity()) {
          var Pe = ve.getX(), Ue = Pe.umod(this.n);
          if (Ue.cmpn(0) !== 0) {
            var ze = be.invm(this.n).mul(Ue.mul(D.getPrivate()).iadd(P));
            if (ze = ze.umod(this.n), ze.cmpn(0) !== 0) {
              var Le = (ve.getY().isOdd() ? 1 : 0) | (Pe.cmp(Ue) !== 0 ? 2 : 0);
              return Y.canonical && ze.cmp(this.nh) > 0 && (ze = this.n.sub(ze), Le ^= 1), new M({ r: Ue, s: ze, recoveryParam: Le });
            }
          }
        }
      }
    }
  }, O.prototype.verify = function(P, D, Z, Y) {
    P = this._truncateToN(new e(P, 16)), Z = this.keyFromPublic(Z, Y), D = new M(D, "hex");
    var ee = D.r, ie = D.s;
    if (ee.cmpn(1) < 0 || ee.cmp(this.n) >= 0 || ie.cmpn(1) < 0 || ie.cmp(this.n) >= 0)
      return !1;
    var ue = ie.invm(this.n), fe = ue.mul(P).umod(this.n), de = ue.mul(ee).umod(this.n), ce;
    return this.curve._maxwellTrick ? (ce = this.g.jmulAdd(fe, Z.getPublic(), de), ce.isInfinity() ? !1 : ce.eqXToP(ee)) : (ce = this.g.mulAdd(fe, Z.getPublic(), de), ce.isInfinity() ? !1 : ce.getX().umod(this.n).cmp(ee) === 0);
  }, O.prototype.recoverPubKey = function(P, D, Z, Y) {
    g((3 & Z) === Z, "The recovery param is more than two bits"), D = new M(D, Y);
    var ee = this.n, ie = new e(P), ue = D.r, fe = D.s, de = Z & 1, ce = Z >> 1;
    if (ue.cmp(this.curve.p.umod(this.curve.n)) >= 0 && ce)
      throw new Error("Unable to find sencond key candinate");
    ce ? ue = this.curve.pointFromX(ue.add(this.curve.n), de) : ue = this.curve.pointFromX(ue, de);
    var be = D.r.invm(ee), ve = ee.sub(ie).mul(be).umod(ee), Pe = fe.mul(be).umod(ee);
    return this.g.mulAdd(ve, ue, Pe);
  }, O.prototype.getKeyRecoveryParam = function(P, D, Z, Y) {
    if (D = new M(D, Y), D.recoveryParam !== null)
      return D.recoveryParam;
    for (var ee = 0; ee < 4; ee++) {
      var ie;
      try {
        ie = this.recoverPubKey(P, D, ee);
      } catch {
        continue;
      }
      if (ie.eq(Z))
        return ee;
    }
    throw new Error("Unable to find valid recovery factor");
  }, No;
}
var K0 = Pr, yy = K0.assert, ed = K0.parseBytes, za = K0.cachedProperty;
function Zt(e, t) {
  this.eddsa = e, this._secret = ed(t.secret), e.isPoint(t.pub) ? this._pub = t.pub : this._pubBytes = ed(t.pub);
}
Zt.fromPublic = function(e, t) {
  return t instanceof Zt ? t : new Zt(e, { pub: t });
};
Zt.fromSecret = function(e, t) {
  return t instanceof Zt ? t : new Zt(e, { secret: t });
};
Zt.prototype.secret = function() {
  return this._secret;
};
za(Zt, "pubBytes", function() {
  return this.eddsa.encodePoint(this.pub());
});
za(Zt, "pub", function() {
  return this._pubBytes ? this.eddsa.decodePoint(this._pubBytes) : this.eddsa.g.mul(this.priv());
});
za(Zt, "privBytes", function() {
  var e = this.eddsa, t = this.hash(), h = e.encodingLength - 1, o = t.slice(0, e.encodingLength);
  return o[0] &= 248, o[h] &= 127, o[h] |= 64, o;
});
za(Zt, "priv", function() {
  return this.eddsa.decodeInt(this.privBytes());
});
za(Zt, "hash", function() {
  return this.eddsa.hash().update(this.secret()).digest();
});
za(Zt, "messagePrefix", function() {
  return this.hash().slice(this.eddsa.encodingLength);
});
Zt.prototype.sign = function(e) {
  return yy(this._secret, "KeyPair can only verify"), this.eddsa.sign(e, this);
};
Zt.prototype.verify = function(e, t) {
  return this.eddsa.verify(e, t, this);
};
Zt.prototype.getSecret = function(e) {
  return yy(this._secret, "KeyPair is public only"), K0.encode(this.secret(), e);
};
Zt.prototype.getPublic = function(e) {
  return K0.encode(this.pubBytes(), e);
};
var A8 = Zt, B8 = rr, Ef = Pr, I8 = Ef.assert, Sf = Ef.cachedProperty, T8 = Ef.parseBytes;
function na(e, t) {
  this.eddsa = e, typeof t != "object" && (t = T8(t)), Array.isArray(t) && (t = {
    R: t.slice(0, e.encodingLength),
    S: t.slice(e.encodingLength)
  }), I8(t.R && t.S, "Signature without R or S"), e.isPoint(t.R) && (this._R = t.R), t.S instanceof B8 && (this._S = t.S), this._Rencoded = Array.isArray(t.R) ? t.R : t.Rencoded, this._Sencoded = Array.isArray(t.S) ? t.S : t.Sencoded;
}
Sf(na, "S", function() {
  return this.eddsa.decodeInt(this.Sencoded());
});
Sf(na, "R", function() {
  return this.eddsa.decodePoint(this.Rencoded());
});
Sf(na, "Rencoded", function() {
  return this.eddsa.encodePoint(this.R());
});
Sf(na, "Sencoded", function() {
  return this.eddsa.encodeInt(this.S());
});
na.prototype.toBytes = function() {
  return this.Rencoded().concat(this.Sencoded());
};
na.prototype.toHex = function() {
  return Ef.encode(this.toBytes(), "hex").toUpperCase();
};
var M8 = na, R8 = bf, N8 = mf, Ma = Pr, D8 = Ma.assert, gy = Ma.parseBytes, my = A8, td = M8;
function Ir(e) {
  if (D8(e === "ed25519", "only tested with ed25519 so far"), !(this instanceof Ir))
    return new Ir(e);
  e = N8[e].curve, this.curve = e, this.g = e.g, this.g.precompute(e.n.bitLength() + 1), this.pointClass = e.point().constructor, this.encodingLength = Math.ceil(e.n.bitLength() / 8), this.hash = R8.sha512;
}
var O8 = Ir;
Ir.prototype.sign = function(e, t) {
  e = gy(e);
  var h = this.keyFromSecret(t), o = this.hashInt(h.messagePrefix(), e), S = this.g.mul(o), g = this.encodePoint(S), B = this.hashInt(g, h.pubBytes(), e).mul(h.priv()), M = o.add(B).umod(this.curve.n);
  return this.makeSignature({ R: S, S: M, Rencoded: g });
};
Ir.prototype.verify = function(e, t, h) {
  e = gy(e), t = this.makeSignature(t);
  var o = this.keyFromPublic(h), S = this.hashInt(t.Rencoded(), o.pubBytes(), e), g = this.g.mul(t.S()), B = t.R().add(o.pub().mul(S));
  return B.eq(g);
};
Ir.prototype.hashInt = function() {
  for (var e = this.hash(), t = 0; t < arguments.length; t++)
    e.update(arguments[t]);
  return Ma.intFromLE(e.digest()).umod(this.curve.n);
};
Ir.prototype.keyFromPublic = function(e) {
  return my.fromPublic(this, e);
};
Ir.prototype.keyFromSecret = function(e) {
  return my.fromSecret(this, e);
};
Ir.prototype.makeSignature = function(e) {
  return e instanceof td ? e : new td(this, e);
};
Ir.prototype.encodePoint = function(e) {
  var t = e.getY().toArray("le", this.encodingLength);
  return t[this.encodingLength - 1] |= e.getX().isOdd() ? 128 : 0, t;
};
Ir.prototype.decodePoint = function(e) {
  e = Ma.parseBytes(e);
  var t = e.length - 1, h = e.slice(0, t).concat(e[t] & -129), o = (e[t] & 128) !== 0, S = Ma.intFromLE(h);
  return this.curve.pointFromY(S, o);
};
Ir.prototype.encodeInt = function(e) {
  return e.toArray("le", this.encodingLength);
};
Ir.prototype.decodeInt = function(e) {
  return Ma.intFromLE(e);
};
Ir.prototype.isPoint = function(e) {
  return e instanceof this.pointClass;
};
var rd;
function hh() {
  return rd || (rd = 1, function(e) {
    var t = e;
    t.version = O3.version, t.utils = Pr, t.rand = nh(), t.curve = oh, t.curves = mf, t.ec = C8(), t.eddsa = O8;
  }(Co)), Co;
}
var lh = { exports: {} };
(function(e) {
  (function(t, h) {
    function o(A, I) {
      if (!A)
        throw new Error(I || "Assertion failed");
    }
    function S(A, I) {
      A.super_ = I;
      var U = function() {
      };
      U.prototype = I.prototype, A.prototype = new U(), A.prototype.constructor = A;
    }
    function g(A, I, U) {
      if (g.isBN(A))
        return A;
      this.negative = 0, this.words = null, this.length = 0, this.red = null, A !== null && ((I === "le" || I === "be") && (U = I, I = 10), this._init(A || 0, I || 10, U || "be"));
    }
    typeof t == "object" ? t.exports = g : h.BN = g, g.BN = g, g.wordSize = 26;
    var B;
    try {
      typeof window < "u" && typeof window.Buffer < "u" ? B = window.Buffer : B = pe.Buffer;
    } catch {
    }
    g.isBN = function(A) {
      return A instanceof g ? !0 : A !== null && typeof A == "object" && A.constructor.wordSize === g.wordSize && Array.isArray(A.words);
    }, g.max = function(A, I) {
      return A.cmp(I) > 0 ? A : I;
    }, g.min = function(A, I) {
      return A.cmp(I) < 0 ? A : I;
    }, g.prototype._init = function(A, I, U) {
      if (typeof A == "number")
        return this._initNumber(A, I, U);
      if (typeof A == "object")
        return this._initArray(A, I, U);
      I === "hex" && (I = 16), o(I === (I | 0) && I >= 2 && I <= 36), A = A.toString().replace(/\s+/g, "");
      var X = 0;
      A[0] === "-" && (X++, this.negative = 1), X < A.length && (I === 16 ? this._parseHex(A, X, U) : (this._parseBase(A, I, X), U === "le" && this._initArray(this.toArray(), I, U)));
    }, g.prototype._initNumber = function(A, I, U) {
      A < 0 && (this.negative = 1, A = -A), A < 67108864 ? (this.words = [A & 67108863], this.length = 1) : A < 4503599627370496 ? (this.words = [
        A & 67108863,
        A / 67108864 & 67108863
      ], this.length = 2) : (o(A < 9007199254740992), this.words = [
        A & 67108863,
        A / 67108864 & 67108863,
        1
      ], this.length = 3), U === "le" && this._initArray(this.toArray(), I, U);
    }, g.prototype._initArray = function(A, I, U) {
      if (o(typeof A.length == "number"), A.length <= 0)
        return this.words = [0], this.length = 1, this;
      this.length = Math.ceil(A.length / 3), this.words = new Array(this.length);
      for (var X = 0; X < this.length; X++)
        this.words[X] = 0;
      var Q, F, $ = 0;
      if (U === "be")
        for (X = A.length - 1, Q = 0; X >= 0; X -= 3)
          F = A[X] | A[X - 1] << 8 | A[X - 2] << 16, this.words[Q] |= F << $ & 67108863, this.words[Q + 1] = F >>> 26 - $ & 67108863, $ += 24, $ >= 26 && ($ -= 26, Q++);
      else if (U === "le")
        for (X = 0, Q = 0; X < A.length; X += 3)
          F = A[X] | A[X + 1] << 8 | A[X + 2] << 16, this.words[Q] |= F << $ & 67108863, this.words[Q + 1] = F >>> 26 - $ & 67108863, $ += 24, $ >= 26 && ($ -= 26, Q++);
      return this._strip();
    };
    function M(A, I) {
      var U = A.charCodeAt(I);
      if (U >= 48 && U <= 57)
        return U - 48;
      if (U >= 65 && U <= 70)
        return U - 55;
      if (U >= 97 && U <= 102)
        return U - 87;
      o(!1, "Invalid character in " + A);
    }
    function O(A, I, U) {
      var X = M(A, U);
      return U - 1 >= I && (X |= M(A, U - 1) << 4), X;
    }
    g.prototype._parseHex = function(A, I, U) {
      this.length = Math.ceil((A.length - I) / 6), this.words = new Array(this.length);
      for (var X = 0; X < this.length; X++)
        this.words[X] = 0;
      var Q = 0, F = 0, $;
      if (U === "be")
        for (X = A.length - 1; X >= I; X -= 2)
          $ = O(A, I, X) << Q, this.words[F] |= $ & 67108863, Q >= 18 ? (Q -= 18, F += 1, this.words[F] |= $ >>> 26) : Q += 8;
      else {
        var H = A.length - I;
        for (X = H % 2 === 0 ? I + 1 : I; X < A.length; X += 2)
          $ = O(A, I, X) << Q, this.words[F] |= $ & 67108863, Q >= 18 ? (Q -= 18, F += 1, this.words[F] |= $ >>> 26) : Q += 8;
      }
      this._strip();
    };
    function P(A, I, U, X) {
      for (var Q = 0, F = 0, $ = Math.min(A.length, U), H = I; H < $; H++) {
        var q = A.charCodeAt(H) - 48;
        Q *= X, q >= 49 ? F = q - 49 + 10 : q >= 17 ? F = q - 17 + 10 : F = q, o(q >= 0 && F < X, "Invalid character"), Q += F;
      }
      return Q;
    }
    g.prototype._parseBase = function(A, I, U) {
      this.words = [0], this.length = 1;
      for (var X = 0, Q = 1; Q <= 67108863; Q *= I)
        X++;
      X--, Q = Q / I | 0;
      for (var F = A.length - U, $ = F % X, H = Math.min(F, F - $) + U, q = 0, z = U; z < H; z += X)
        q = P(A, z, z + X, I), this.imuln(Q), this.words[0] + q < 67108864 ? this.words[0] += q : this._iaddn(q);
      if ($ !== 0) {
        var me = 1;
        for (q = P(A, z, A.length, I), z = 0; z < $; z++)
          me *= I;
        this.imuln(me), this.words[0] + q < 67108864 ? this.words[0] += q : this._iaddn(q);
      }
      this._strip();
    }, g.prototype.copy = function(A) {
      A.words = new Array(this.length);
      for (var I = 0; I < this.length; I++)
        A.words[I] = this.words[I];
      A.length = this.length, A.negative = this.negative, A.red = this.red;
    };
    function D(A, I) {
      A.words = I.words, A.length = I.length, A.negative = I.negative, A.red = I.red;
    }
    if (g.prototype._move = function(A) {
      D(A, this);
    }, g.prototype.clone = function() {
      var A = new g(null);
      return this.copy(A), A;
    }, g.prototype._expand = function(A) {
      for (; this.length < A; )
        this.words[this.length++] = 0;
      return this;
    }, g.prototype._strip = function() {
      for (; this.length > 1 && this.words[this.length - 1] === 0; )
        this.length--;
      return this._normSign();
    }, g.prototype._normSign = function() {
      return this.length === 1 && this.words[0] === 0 && (this.negative = 0), this;
    }, typeof Symbol < "u" && typeof Symbol.for == "function")
      try {
        g.prototype[Symbol.for("nodejs.util.inspect.custom")] = Z;
      } catch {
        g.prototype.inspect = Z;
      }
    else
      g.prototype.inspect = Z;
    function Z() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    }
    var Y = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ], ee = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ], ie = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    g.prototype.toString = function(A, I) {
      A = A || 10, I = I | 0 || 1;
      var U;
      if (A === 16 || A === "hex") {
        U = "";
        for (var X = 0, Q = 0, F = 0; F < this.length; F++) {
          var $ = this.words[F], H = (($ << X | Q) & 16777215).toString(16);
          Q = $ >>> 24 - X & 16777215, X += 2, X >= 26 && (X -= 26, F--), Q !== 0 || F !== this.length - 1 ? U = Y[6 - H.length] + H + U : U = H + U;
        }
        for (Q !== 0 && (U = Q.toString(16) + U); U.length % I !== 0; )
          U = "0" + U;
        return this.negative !== 0 && (U = "-" + U), U;
      }
      if (A === (A | 0) && A >= 2 && A <= 36) {
        var q = ee[A], z = ie[A];
        U = "";
        var me = this.clone();
        for (me.negative = 0; !me.isZero(); ) {
          var Ce = me.modrn(z).toString(A);
          me = me.idivn(z), me.isZero() ? U = Ce + U : U = Y[q - Ce.length] + Ce + U;
        }
        for (this.isZero() && (U = "0" + U); U.length % I !== 0; )
          U = "0" + U;
        return this.negative !== 0 && (U = "-" + U), U;
      }
      o(!1, "Base should be between 2 and 36");
    }, g.prototype.toNumber = function() {
      var A = this.words[0];
      return this.length === 2 ? A += this.words[1] * 67108864 : this.length === 3 && this.words[2] === 1 ? A += 4503599627370496 + this.words[1] * 67108864 : this.length > 2 && o(!1, "Number can only safely store up to 53 bits"), this.negative !== 0 ? -A : A;
    }, g.prototype.toJSON = function() {
      return this.toString(16, 2);
    }, B && (g.prototype.toBuffer = function(A, I) {
      return this.toArrayLike(B, A, I);
    }), g.prototype.toArray = function(A, I) {
      return this.toArrayLike(Array, A, I);
    };
    var ue = function(A, I) {
      return A.allocUnsafe ? A.allocUnsafe(I) : new A(I);
    };
    g.prototype.toArrayLike = function(A, I, U) {
      this._strip();
      var X = this.byteLength(), Q = U || Math.max(1, X);
      o(X <= Q, "byte array longer than desired length"), o(Q > 0, "Requested array length <= 0");
      var F = ue(A, Q), $ = I === "le" ? "LE" : "BE";
      return this["_toArrayLike" + $](F, X), F;
    }, g.prototype._toArrayLikeLE = function(A, I) {
      for (var U = 0, X = 0, Q = 0, F = 0; Q < this.length; Q++) {
        var $ = this.words[Q] << F | X;
        A[U++] = $ & 255, U < A.length && (A[U++] = $ >> 8 & 255), U < A.length && (A[U++] = $ >> 16 & 255), F === 6 ? (U < A.length && (A[U++] = $ >> 24 & 255), X = 0, F = 0) : (X = $ >>> 24, F += 2);
      }
      if (U < A.length)
        for (A[U++] = X; U < A.length; )
          A[U++] = 0;
    }, g.prototype._toArrayLikeBE = function(A, I) {
      for (var U = A.length - 1, X = 0, Q = 0, F = 0; Q < this.length; Q++) {
        var $ = this.words[Q] << F | X;
        A[U--] = $ & 255, U >= 0 && (A[U--] = $ >> 8 & 255), U >= 0 && (A[U--] = $ >> 16 & 255), F === 6 ? (U >= 0 && (A[U--] = $ >> 24 & 255), X = 0, F = 0) : (X = $ >>> 24, F += 2);
      }
      if (U >= 0)
        for (A[U--] = X; U >= 0; )
          A[U--] = 0;
    }, Math.clz32 ? g.prototype._countBits = function(A) {
      return 32 - Math.clz32(A);
    } : g.prototype._countBits = function(A) {
      var I = A, U = 0;
      return I >= 4096 && (U += 13, I >>>= 13), I >= 64 && (U += 7, I >>>= 7), I >= 8 && (U += 4, I >>>= 4), I >= 2 && (U += 2, I >>>= 2), U + I;
    }, g.prototype._zeroBits = function(A) {
      if (A === 0)
        return 26;
      var I = A, U = 0;
      return I & 8191 || (U += 13, I >>>= 13), I & 127 || (U += 7, I >>>= 7), I & 15 || (U += 4, I >>>= 4), I & 3 || (U += 2, I >>>= 2), I & 1 || U++, U;
    }, g.prototype.bitLength = function() {
      var A = this.words[this.length - 1], I = this._countBits(A);
      return (this.length - 1) * 26 + I;
    };
    function fe(A) {
      for (var I = new Array(A.bitLength()), U = 0; U < I.length; U++) {
        var X = U / 26 | 0, Q = U % 26;
        I[U] = A.words[X] >>> Q & 1;
      }
      return I;
    }
    g.prototype.zeroBits = function() {
      if (this.isZero())
        return 0;
      for (var A = 0, I = 0; I < this.length; I++) {
        var U = this._zeroBits(this.words[I]);
        if (A += U, U !== 26)
          break;
      }
      return A;
    }, g.prototype.byteLength = function() {
      return Math.ceil(this.bitLength() / 8);
    }, g.prototype.toTwos = function(A) {
      return this.negative !== 0 ? this.abs().inotn(A).iaddn(1) : this.clone();
    }, g.prototype.fromTwos = function(A) {
      return this.testn(A - 1) ? this.notn(A).iaddn(1).ineg() : this.clone();
    }, g.prototype.isNeg = function() {
      return this.negative !== 0;
    }, g.prototype.neg = function() {
      return this.clone().ineg();
    }, g.prototype.ineg = function() {
      return this.isZero() || (this.negative ^= 1), this;
    }, g.prototype.iuor = function(A) {
      for (; this.length < A.length; )
        this.words[this.length++] = 0;
      for (var I = 0; I < A.length; I++)
        this.words[I] = this.words[I] | A.words[I];
      return this._strip();
    }, g.prototype.ior = function(A) {
      return o((this.negative | A.negative) === 0), this.iuor(A);
    }, g.prototype.or = function(A) {
      return this.length > A.length ? this.clone().ior(A) : A.clone().ior(this);
    }, g.prototype.uor = function(A) {
      return this.length > A.length ? this.clone().iuor(A) : A.clone().iuor(this);
    }, g.prototype.iuand = function(A) {
      var I;
      this.length > A.length ? I = A : I = this;
      for (var U = 0; U < I.length; U++)
        this.words[U] = this.words[U] & A.words[U];
      return this.length = I.length, this._strip();
    }, g.prototype.iand = function(A) {
      return o((this.negative | A.negative) === 0), this.iuand(A);
    }, g.prototype.and = function(A) {
      return this.length > A.length ? this.clone().iand(A) : A.clone().iand(this);
    }, g.prototype.uand = function(A) {
      return this.length > A.length ? this.clone().iuand(A) : A.clone().iuand(this);
    }, g.prototype.iuxor = function(A) {
      var I, U;
      this.length > A.length ? (I = this, U = A) : (I = A, U = this);
      for (var X = 0; X < U.length; X++)
        this.words[X] = I.words[X] ^ U.words[X];
      if (this !== I)
        for (; X < I.length; X++)
          this.words[X] = I.words[X];
      return this.length = I.length, this._strip();
    }, g.prototype.ixor = function(A) {
      return o((this.negative | A.negative) === 0), this.iuxor(A);
    }, g.prototype.xor = function(A) {
      return this.length > A.length ? this.clone().ixor(A) : A.clone().ixor(this);
    }, g.prototype.uxor = function(A) {
      return this.length > A.length ? this.clone().iuxor(A) : A.clone().iuxor(this);
    }, g.prototype.inotn = function(A) {
      o(typeof A == "number" && A >= 0);
      var I = Math.ceil(A / 26) | 0, U = A % 26;
      this._expand(I), U > 0 && I--;
      for (var X = 0; X < I; X++)
        this.words[X] = ~this.words[X] & 67108863;
      return U > 0 && (this.words[X] = ~this.words[X] & 67108863 >> 26 - U), this._strip();
    }, g.prototype.notn = function(A) {
      return this.clone().inotn(A);
    }, g.prototype.setn = function(A, I) {
      o(typeof A == "number" && A >= 0);
      var U = A / 26 | 0, X = A % 26;
      return this._expand(U + 1), I ? this.words[U] = this.words[U] | 1 << X : this.words[U] = this.words[U] & ~(1 << X), this._strip();
    }, g.prototype.iadd = function(A) {
      var I;
      if (this.negative !== 0 && A.negative === 0)
        return this.negative = 0, I = this.isub(A), this.negative ^= 1, this._normSign();
      if (this.negative === 0 && A.negative !== 0)
        return A.negative = 0, I = this.isub(A), A.negative = 1, I._normSign();
      var U, X;
      this.length > A.length ? (U = this, X = A) : (U = A, X = this);
      for (var Q = 0, F = 0; F < X.length; F++)
        I = (U.words[F] | 0) + (X.words[F] | 0) + Q, this.words[F] = I & 67108863, Q = I >>> 26;
      for (; Q !== 0 && F < U.length; F++)
        I = (U.words[F] | 0) + Q, this.words[F] = I & 67108863, Q = I >>> 26;
      if (this.length = U.length, Q !== 0)
        this.words[this.length] = Q, this.length++;
      else if (U !== this)
        for (; F < U.length; F++)
          this.words[F] = U.words[F];
      return this;
    }, g.prototype.add = function(A) {
      var I;
      return A.negative !== 0 && this.negative === 0 ? (A.negative = 0, I = this.sub(A), A.negative ^= 1, I) : A.negative === 0 && this.negative !== 0 ? (this.negative = 0, I = A.sub(this), this.negative = 1, I) : this.length > A.length ? this.clone().iadd(A) : A.clone().iadd(this);
    }, g.prototype.isub = function(A) {
      if (A.negative !== 0) {
        A.negative = 0;
        var I = this.iadd(A);
        return A.negative = 1, I._normSign();
      } else if (this.negative !== 0)
        return this.negative = 0, this.iadd(A), this.negative = 1, this._normSign();
      var U = this.cmp(A);
      if (U === 0)
        return this.negative = 0, this.length = 1, this.words[0] = 0, this;
      var X, Q;
      U > 0 ? (X = this, Q = A) : (X = A, Q = this);
      for (var F = 0, $ = 0; $ < Q.length; $++)
        I = (X.words[$] | 0) - (Q.words[$] | 0) + F, F = I >> 26, this.words[$] = I & 67108863;
      for (; F !== 0 && $ < X.length; $++)
        I = (X.words[$] | 0) + F, F = I >> 26, this.words[$] = I & 67108863;
      if (F === 0 && $ < X.length && X !== this)
        for (; $ < X.length; $++)
          this.words[$] = X.words[$];
      return this.length = Math.max(this.length, $), X !== this && (this.negative = 1), this._strip();
    }, g.prototype.sub = function(A) {
      return this.clone().isub(A);
    };
    function de(A, I, U) {
      U.negative = I.negative ^ A.negative;
      var X = A.length + I.length | 0;
      U.length = X, X = X - 1 | 0;
      var Q = A.words[0] | 0, F = I.words[0] | 0, $ = Q * F, H = $ & 67108863, q = $ / 67108864 | 0;
      U.words[0] = H;
      for (var z = 1; z < X; z++) {
        for (var me = q >>> 26, Ce = q & 67108863, je = Math.min(z, I.length - 1), Re = Math.max(0, z - A.length + 1); Re <= je; Re++) {
          var Ae = z - Re | 0;
          Q = A.words[Ae] | 0, F = I.words[Re] | 0, $ = Q * F + Ce, me += $ / 67108864 | 0, Ce = $ & 67108863;
        }
        U.words[z] = Ce | 0, q = me | 0;
      }
      return q !== 0 ? U.words[z] = q | 0 : U.length--, U._strip();
    }
    var ce = function(A, I, U) {
      var X = A.words, Q = I.words, F = U.words, $ = 0, H, q, z, me = X[0] | 0, Ce = me & 8191, je = me >>> 13, Re = X[1] | 0, Ae = Re & 8191, ke = Re >>> 13, Qe = X[2] | 0, Ze = Qe & 8191, qe = Qe >>> 13, Oe = X[3] | 0, Xe = Oe & 8191, et = Oe >>> 13, nt = X[4] | 0, re = nt & 8191, oe = nt >>> 13, le = X[5] | 0, ge = le & 8191, Ke = le >>> 13, Je = X[6] | 0, Fe = Je & 8191, Ye = Je >>> 13, it = X[7] | 0, rt = it & 8191, tt = it >>> 13, vt = X[8] | 0, St = vt & 8191, ot = vt >>> 13, si = X[9] | 0, oi = si & 8191, At = si >>> 13, Nn = Q[0] | 0, ui = Nn & 8191, Bt = Nn >>> 13, vi = Q[1] | 0, fi = vi & 8191, Ct = vi >>> 13, rM = Q[2] | 0, hi = rM & 8191, Tt = rM >>> 13, Dn = Q[3] | 0, di = Dn & 8191, Ot = Dn >>> 13, iM = Q[4] | 0, ci = iM & 8191, Dt = iM >>> 13, nM = Q[5] | 0, li = nM & 8191, ri = nM >>> 13, eM = Q[6] | 0, ai = eM & 8191, It = eM >>> 13, tM = Q[7] | 0, pi = tM & 8191, ii = tM >>> 13, oM = Q[8] | 0, gi = oM & 8191, ni = oM >>> 13, aM = Q[9] | 0, yi = aM & 8191, mi = aM >>> 13;
      U.negative = A.negative ^ I.negative, U.length = 19, H = Math.imul(Ce, ui), q = Math.imul(Ce, Bt), q = q + Math.imul(je, ui) | 0, z = Math.imul(je, Bt);
      var sM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (sM >>> 26) | 0, sM &= 67108863, H = Math.imul(Ae, ui), q = Math.imul(Ae, Bt), q = q + Math.imul(ke, ui) | 0, z = Math.imul(ke, Bt), H = H + Math.imul(Ce, fi) | 0, q = q + Math.imul(Ce, Ct) | 0, q = q + Math.imul(je, fi) | 0, z = z + Math.imul(je, Ct) | 0;
      var uM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (uM >>> 26) | 0, uM &= 67108863, H = Math.imul(Ze, ui), q = Math.imul(Ze, Bt), q = q + Math.imul(qe, ui) | 0, z = Math.imul(qe, Bt), H = H + Math.imul(Ae, fi) | 0, q = q + Math.imul(Ae, Ct) | 0, q = q + Math.imul(ke, fi) | 0, z = z + Math.imul(ke, Ct) | 0, H = H + Math.imul(Ce, hi) | 0, q = q + Math.imul(Ce, Tt) | 0, q = q + Math.imul(je, hi) | 0, z = z + Math.imul(je, Tt) | 0;
      var fM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (fM >>> 26) | 0, fM &= 67108863, H = Math.imul(Xe, ui), q = Math.imul(Xe, Bt), q = q + Math.imul(et, ui) | 0, z = Math.imul(et, Bt), H = H + Math.imul(Ze, fi) | 0, q = q + Math.imul(Ze, Ct) | 0, q = q + Math.imul(qe, fi) | 0, z = z + Math.imul(qe, Ct) | 0, H = H + Math.imul(Ae, hi) | 0, q = q + Math.imul(Ae, Tt) | 0, q = q + Math.imul(ke, hi) | 0, z = z + Math.imul(ke, Tt) | 0, H = H + Math.imul(Ce, di) | 0, q = q + Math.imul(Ce, Ot) | 0, q = q + Math.imul(je, di) | 0, z = z + Math.imul(je, Ot) | 0;
      var hM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (hM >>> 26) | 0, hM &= 67108863, H = Math.imul(re, ui), q = Math.imul(re, Bt), q = q + Math.imul(oe, ui) | 0, z = Math.imul(oe, Bt), H = H + Math.imul(Xe, fi) | 0, q = q + Math.imul(Xe, Ct) | 0, q = q + Math.imul(et, fi) | 0, z = z + Math.imul(et, Ct) | 0, H = H + Math.imul(Ze, hi) | 0, q = q + Math.imul(Ze, Tt) | 0, q = q + Math.imul(qe, hi) | 0, z = z + Math.imul(qe, Tt) | 0, H = H + Math.imul(Ae, di) | 0, q = q + Math.imul(Ae, Ot) | 0, q = q + Math.imul(ke, di) | 0, z = z + Math.imul(ke, Ot) | 0, H = H + Math.imul(Ce, ci) | 0, q = q + Math.imul(Ce, Dt) | 0, q = q + Math.imul(je, ci) | 0, z = z + Math.imul(je, Dt) | 0;
      var cM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (cM >>> 26) | 0, cM &= 67108863, H = Math.imul(ge, ui), q = Math.imul(ge, Bt), q = q + Math.imul(Ke, ui) | 0, z = Math.imul(Ke, Bt), H = H + Math.imul(re, fi) | 0, q = q + Math.imul(re, Ct) | 0, q = q + Math.imul(oe, fi) | 0, z = z + Math.imul(oe, Ct) | 0, H = H + Math.imul(Xe, hi) | 0, q = q + Math.imul(Xe, Tt) | 0, q = q + Math.imul(et, hi) | 0, z = z + Math.imul(et, Tt) | 0, H = H + Math.imul(Ze, di) | 0, q = q + Math.imul(Ze, Ot) | 0, q = q + Math.imul(qe, di) | 0, z = z + Math.imul(qe, Ot) | 0, H = H + Math.imul(Ae, ci) | 0, q = q + Math.imul(Ae, Dt) | 0, q = q + Math.imul(ke, ci) | 0, z = z + Math.imul(ke, Dt) | 0, H = H + Math.imul(Ce, li) | 0, q = q + Math.imul(Ce, ri) | 0, q = q + Math.imul(je, li) | 0, z = z + Math.imul(je, ri) | 0;
      var lM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (lM >>> 26) | 0, lM &= 67108863, H = Math.imul(Fe, ui), q = Math.imul(Fe, Bt), q = q + Math.imul(Ye, ui) | 0, z = Math.imul(Ye, Bt), H = H + Math.imul(ge, fi) | 0, q = q + Math.imul(ge, Ct) | 0, q = q + Math.imul(Ke, fi) | 0, z = z + Math.imul(Ke, Ct) | 0, H = H + Math.imul(re, hi) | 0, q = q + Math.imul(re, Tt) | 0, q = q + Math.imul(oe, hi) | 0, z = z + Math.imul(oe, Tt) | 0, H = H + Math.imul(Xe, di) | 0, q = q + Math.imul(Xe, Ot) | 0, q = q + Math.imul(et, di) | 0, z = z + Math.imul(et, Ot) | 0, H = H + Math.imul(Ze, ci) | 0, q = q + Math.imul(Ze, Dt) | 0, q = q + Math.imul(qe, ci) | 0, z = z + Math.imul(qe, Dt) | 0, H = H + Math.imul(Ae, li) | 0, q = q + Math.imul(Ae, ri) | 0, q = q + Math.imul(ke, li) | 0, z = z + Math.imul(ke, ri) | 0, H = H + Math.imul(Ce, ai) | 0, q = q + Math.imul(Ce, It) | 0, q = q + Math.imul(je, ai) | 0, z = z + Math.imul(je, It) | 0;
      var dM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (dM >>> 26) | 0, dM &= 67108863, H = Math.imul(rt, ui), q = Math.imul(rt, Bt), q = q + Math.imul(tt, ui) | 0, z = Math.imul(tt, Bt), H = H + Math.imul(Fe, fi) | 0, q = q + Math.imul(Fe, Ct) | 0, q = q + Math.imul(Ye, fi) | 0, z = z + Math.imul(Ye, Ct) | 0, H = H + Math.imul(ge, hi) | 0, q = q + Math.imul(ge, Tt) | 0, q = q + Math.imul(Ke, hi) | 0, z = z + Math.imul(Ke, Tt) | 0, H = H + Math.imul(re, di) | 0, q = q + Math.imul(re, Ot) | 0, q = q + Math.imul(oe, di) | 0, z = z + Math.imul(oe, Ot) | 0, H = H + Math.imul(Xe, ci) | 0, q = q + Math.imul(Xe, Dt) | 0, q = q + Math.imul(et, ci) | 0, z = z + Math.imul(et, Dt) | 0, H = H + Math.imul(Ze, li) | 0, q = q + Math.imul(Ze, ri) | 0, q = q + Math.imul(qe, li) | 0, z = z + Math.imul(qe, ri) | 0, H = H + Math.imul(Ae, ai) | 0, q = q + Math.imul(Ae, It) | 0, q = q + Math.imul(ke, ai) | 0, z = z + Math.imul(ke, It) | 0, H = H + Math.imul(Ce, pi) | 0, q = q + Math.imul(Ce, ii) | 0, q = q + Math.imul(je, pi) | 0, z = z + Math.imul(je, ii) | 0;
      var pM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (pM >>> 26) | 0, pM &= 67108863, H = Math.imul(St, ui), q = Math.imul(St, Bt), q = q + Math.imul(ot, ui) | 0, z = Math.imul(ot, Bt), H = H + Math.imul(rt, fi) | 0, q = q + Math.imul(rt, Ct) | 0, q = q + Math.imul(tt, fi) | 0, z = z + Math.imul(tt, Ct) | 0, H = H + Math.imul(Fe, hi) | 0, q = q + Math.imul(Fe, Tt) | 0, q = q + Math.imul(Ye, hi) | 0, z = z + Math.imul(Ye, Tt) | 0, H = H + Math.imul(ge, di) | 0, q = q + Math.imul(ge, Ot) | 0, q = q + Math.imul(Ke, di) | 0, z = z + Math.imul(Ke, Ot) | 0, H = H + Math.imul(re, ci) | 0, q = q + Math.imul(re, Dt) | 0, q = q + Math.imul(oe, ci) | 0, z = z + Math.imul(oe, Dt) | 0, H = H + Math.imul(Xe, li) | 0, q = q + Math.imul(Xe, ri) | 0, q = q + Math.imul(et, li) | 0, z = z + Math.imul(et, ri) | 0, H = H + Math.imul(Ze, ai) | 0, q = q + Math.imul(Ze, It) | 0, q = q + Math.imul(qe, ai) | 0, z = z + Math.imul(qe, It) | 0, H = H + Math.imul(Ae, pi) | 0, q = q + Math.imul(Ae, ii) | 0, q = q + Math.imul(ke, pi) | 0, z = z + Math.imul(ke, ii) | 0, H = H + Math.imul(Ce, gi) | 0, q = q + Math.imul(Ce, ni) | 0, q = q + Math.imul(je, gi) | 0, z = z + Math.imul(je, ni) | 0;
      var yM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (yM >>> 26) | 0, yM &= 67108863, H = Math.imul(oi, ui), q = Math.imul(oi, Bt), q = q + Math.imul(At, ui) | 0, z = Math.imul(At, Bt), H = H + Math.imul(St, fi) | 0, q = q + Math.imul(St, Ct) | 0, q = q + Math.imul(ot, fi) | 0, z = z + Math.imul(ot, Ct) | 0, H = H + Math.imul(rt, hi) | 0, q = q + Math.imul(rt, Tt) | 0, q = q + Math.imul(tt, hi) | 0, z = z + Math.imul(tt, Tt) | 0, H = H + Math.imul(Fe, di) | 0, q = q + Math.imul(Fe, Ot) | 0, q = q + Math.imul(Ye, di) | 0, z = z + Math.imul(Ye, Ot) | 0, H = H + Math.imul(ge, ci) | 0, q = q + Math.imul(ge, Dt) | 0, q = q + Math.imul(Ke, ci) | 0, z = z + Math.imul(Ke, Dt) | 0, H = H + Math.imul(re, li) | 0, q = q + Math.imul(re, ri) | 0, q = q + Math.imul(oe, li) | 0, z = z + Math.imul(oe, ri) | 0, H = H + Math.imul(Xe, ai) | 0, q = q + Math.imul(Xe, It) | 0, q = q + Math.imul(et, ai) | 0, z = z + Math.imul(et, It) | 0, H = H + Math.imul(Ze, pi) | 0, q = q + Math.imul(Ze, ii) | 0, q = q + Math.imul(qe, pi) | 0, z = z + Math.imul(qe, ii) | 0, H = H + Math.imul(Ae, gi) | 0, q = q + Math.imul(Ae, ni) | 0, q = q + Math.imul(ke, gi) | 0, z = z + Math.imul(ke, ni) | 0, H = H + Math.imul(Ce, yi) | 0, q = q + Math.imul(Ce, mi) | 0, q = q + Math.imul(je, yi) | 0, z = z + Math.imul(je, mi) | 0;
      var mM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (mM >>> 26) | 0, mM &= 67108863, H = Math.imul(oi, fi), q = Math.imul(oi, Ct), q = q + Math.imul(At, fi) | 0, z = Math.imul(At, Ct), H = H + Math.imul(St, hi) | 0, q = q + Math.imul(St, Tt) | 0, q = q + Math.imul(ot, hi) | 0, z = z + Math.imul(ot, Tt) | 0, H = H + Math.imul(rt, di) | 0, q = q + Math.imul(rt, Ot) | 0, q = q + Math.imul(tt, di) | 0, z = z + Math.imul(tt, Ot) | 0, H = H + Math.imul(Fe, ci) | 0, q = q + Math.imul(Fe, Dt) | 0, q = q + Math.imul(Ye, ci) | 0, z = z + Math.imul(Ye, Dt) | 0, H = H + Math.imul(ge, li) | 0, q = q + Math.imul(ge, ri) | 0, q = q + Math.imul(Ke, li) | 0, z = z + Math.imul(Ke, ri) | 0, H = H + Math.imul(re, ai) | 0, q = q + Math.imul(re, It) | 0, q = q + Math.imul(oe, ai) | 0, z = z + Math.imul(oe, It) | 0, H = H + Math.imul(Xe, pi) | 0, q = q + Math.imul(Xe, ii) | 0, q = q + Math.imul(et, pi) | 0, z = z + Math.imul(et, ii) | 0, H = H + Math.imul(Ze, gi) | 0, q = q + Math.imul(Ze, ni) | 0, q = q + Math.imul(qe, gi) | 0, z = z + Math.imul(qe, ni) | 0, H = H + Math.imul(Ae, yi) | 0, q = q + Math.imul(Ae, mi) | 0, q = q + Math.imul(ke, yi) | 0, z = z + Math.imul(ke, mi) | 0;
      var gM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (gM >>> 26) | 0, gM &= 67108863, H = Math.imul(oi, hi), q = Math.imul(oi, Tt), q = q + Math.imul(At, hi) | 0, z = Math.imul(At, Tt), H = H + Math.imul(St, di) | 0, q = q + Math.imul(St, Ot) | 0, q = q + Math.imul(ot, di) | 0, z = z + Math.imul(ot, Ot) | 0, H = H + Math.imul(rt, ci) | 0, q = q + Math.imul(rt, Dt) | 0, q = q + Math.imul(tt, ci) | 0, z = z + Math.imul(tt, Dt) | 0, H = H + Math.imul(Fe, li) | 0, q = q + Math.imul(Fe, ri) | 0, q = q + Math.imul(Ye, li) | 0, z = z + Math.imul(Ye, ri) | 0, H = H + Math.imul(ge, ai) | 0, q = q + Math.imul(ge, It) | 0, q = q + Math.imul(Ke, ai) | 0, z = z + Math.imul(Ke, It) | 0, H = H + Math.imul(re, pi) | 0, q = q + Math.imul(re, ii) | 0, q = q + Math.imul(oe, pi) | 0, z = z + Math.imul(oe, ii) | 0, H = H + Math.imul(Xe, gi) | 0, q = q + Math.imul(Xe, ni) | 0, q = q + Math.imul(et, gi) | 0, z = z + Math.imul(et, ni) | 0, H = H + Math.imul(Ze, yi) | 0, q = q + Math.imul(Ze, mi) | 0, q = q + Math.imul(qe, yi) | 0, z = z + Math.imul(qe, mi) | 0;
      var bM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (bM >>> 26) | 0, bM &= 67108863, H = Math.imul(oi, di), q = Math.imul(oi, Ot), q = q + Math.imul(At, di) | 0, z = Math.imul(At, Ot), H = H + Math.imul(St, ci) | 0, q = q + Math.imul(St, Dt) | 0, q = q + Math.imul(ot, ci) | 0, z = z + Math.imul(ot, Dt) | 0, H = H + Math.imul(rt, li) | 0, q = q + Math.imul(rt, ri) | 0, q = q + Math.imul(tt, li) | 0, z = z + Math.imul(tt, ri) | 0, H = H + Math.imul(Fe, ai) | 0, q = q + Math.imul(Fe, It) | 0, q = q + Math.imul(Ye, ai) | 0, z = z + Math.imul(Ye, It) | 0, H = H + Math.imul(ge, pi) | 0, q = q + Math.imul(ge, ii) | 0, q = q + Math.imul(Ke, pi) | 0, z = z + Math.imul(Ke, ii) | 0, H = H + Math.imul(re, gi) | 0, q = q + Math.imul(re, ni) | 0, q = q + Math.imul(oe, gi) | 0, z = z + Math.imul(oe, ni) | 0, H = H + Math.imul(Xe, yi) | 0, q = q + Math.imul(Xe, mi) | 0, q = q + Math.imul(et, yi) | 0, z = z + Math.imul(et, mi) | 0;
      var vM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (vM >>> 26) | 0, vM &= 67108863, H = Math.imul(oi, ci), q = Math.imul(oi, Dt), q = q + Math.imul(At, ci) | 0, z = Math.imul(At, Dt), H = H + Math.imul(St, li) | 0, q = q + Math.imul(St, ri) | 0, q = q + Math.imul(ot, li) | 0, z = z + Math.imul(ot, ri) | 0, H = H + Math.imul(rt, ai) | 0, q = q + Math.imul(rt, It) | 0, q = q + Math.imul(tt, ai) | 0, z = z + Math.imul(tt, It) | 0, H = H + Math.imul(Fe, pi) | 0, q = q + Math.imul(Fe, ii) | 0, q = q + Math.imul(Ye, pi) | 0, z = z + Math.imul(Ye, ii) | 0, H = H + Math.imul(ge, gi) | 0, q = q + Math.imul(ge, ni) | 0, q = q + Math.imul(Ke, gi) | 0, z = z + Math.imul(Ke, ni) | 0, H = H + Math.imul(re, yi) | 0, q = q + Math.imul(re, mi) | 0, q = q + Math.imul(oe, yi) | 0, z = z + Math.imul(oe, mi) | 0;
      var wM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (wM >>> 26) | 0, wM &= 67108863, H = Math.imul(oi, li), q = Math.imul(oi, ri), q = q + Math.imul(At, li) | 0, z = Math.imul(At, ri), H = H + Math.imul(St, ai) | 0, q = q + Math.imul(St, It) | 0, q = q + Math.imul(ot, ai) | 0, z = z + Math.imul(ot, It) | 0, H = H + Math.imul(rt, pi) | 0, q = q + Math.imul(rt, ii) | 0, q = q + Math.imul(tt, pi) | 0, z = z + Math.imul(tt, ii) | 0, H = H + Math.imul(Fe, gi) | 0, q = q + Math.imul(Fe, ni) | 0, q = q + Math.imul(Ye, gi) | 0, z = z + Math.imul(Ye, ni) | 0, H = H + Math.imul(ge, yi) | 0, q = q + Math.imul(ge, mi) | 0, q = q + Math.imul(Ke, yi) | 0, z = z + Math.imul(Ke, mi) | 0;
      var _M = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (_M >>> 26) | 0, _M &= 67108863, H = Math.imul(oi, ai), q = Math.imul(oi, It), q = q + Math.imul(At, ai) | 0, z = Math.imul(At, It), H = H + Math.imul(St, pi) | 0, q = q + Math.imul(St, ii) | 0, q = q + Math.imul(ot, pi) | 0, z = z + Math.imul(ot, ii) | 0, H = H + Math.imul(rt, gi) | 0, q = q + Math.imul(rt, ni) | 0, q = q + Math.imul(tt, gi) | 0, z = z + Math.imul(tt, ni) | 0, H = H + Math.imul(Fe, yi) | 0, q = q + Math.imul(Fe, mi) | 0, q = q + Math.imul(Ye, yi) | 0, z = z + Math.imul(Ye, mi) | 0;
      var SM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (SM >>> 26) | 0, SM &= 67108863, H = Math.imul(oi, pi), q = Math.imul(oi, ii), q = q + Math.imul(At, pi) | 0, z = Math.imul(At, ii), H = H + Math.imul(St, gi) | 0, q = q + Math.imul(St, ni) | 0, q = q + Math.imul(ot, gi) | 0, z = z + Math.imul(ot, ni) | 0, H = H + Math.imul(rt, yi) | 0, q = q + Math.imul(rt, mi) | 0, q = q + Math.imul(tt, yi) | 0, z = z + Math.imul(tt, mi) | 0;
      var EM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (EM >>> 26) | 0, EM &= 67108863, H = Math.imul(oi, gi), q = Math.imul(oi, ni), q = q + Math.imul(At, gi) | 0, z = Math.imul(At, ni), H = H + Math.imul(St, yi) | 0, q = q + Math.imul(St, mi) | 0, q = q + Math.imul(ot, yi) | 0, z = z + Math.imul(ot, mi) | 0;
      var AM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      $ = (z + (q >>> 13) | 0) + (AM >>> 26) | 0, AM &= 67108863, H = Math.imul(oi, yi), q = Math.imul(oi, mi), q = q + Math.imul(At, yi) | 0, z = Math.imul(At, mi);
      var MM = ($ + H | 0) + ((q & 8191) << 13) | 0;
      return $ = (z + (q >>> 13) | 0) + (MM >>> 26) | 0, MM &= 67108863, F[0] = sM, F[1] = uM, F[2] = fM, F[3] = hM, F[4] = cM, F[5] = lM, F[6] = dM, F[7] = pM, F[8] = yM, F[9] = mM, F[10] = gM, F[11] = bM, F[12] = vM, F[13] = wM, F[14] = _M, F[15] = SM, F[16] = EM, F[17] = AM, F[18] = MM, $ !== 0 && (F[19] = $, U.length++), U;
    };
    Math.imul || (ce = de);
    function be(A, I, U) {
      U.negative = I.negative ^ A.negative, U.length = A.length + I.length;
      for (var X = 0, Q = 0, F = 0; F < U.length - 1; F++) {
        var $ = Q;
        Q = 0;
        for (var H = X & 67108863, q = Math.min(F, I.length - 1), z = Math.max(0, F - A.length + 1); z <= q; z++) {
          var me = F - z, Ce = A.words[me] | 0, je = I.words[z] | 0, Re = Ce * je, Ae = Re & 67108863;
          $ = $ + (Re / 67108864 | 0) | 0, Ae = Ae + H | 0, H = Ae & 67108863, $ = $ + (Ae >>> 26) | 0, Q += $ >>> 26, $ &= 67108863;
        }
        U.words[F] = H, X = $, $ = Q;
      }
      return X !== 0 ? U.words[F] = X : U.length--, U._strip();
    }
    function ve(A, I, U) {
      return be(A, I, U);
    }
    g.prototype.mulTo = function(A, I) {
      var U, X = this.length + A.length;
      return this.length === 10 && A.length === 10 ? U = ce(this, A, I) : X < 63 ? U = de(this, A, I) : X < 1024 ? U = be(this, A, I) : U = ve(this, A, I), U;
    }, g.prototype.mul = function(A) {
      var I = new g(null);
      return I.words = new Array(this.length + A.length), this.mulTo(A, I);
    }, g.prototype.mulf = function(A) {
      var I = new g(null);
      return I.words = new Array(this.length + A.length), ve(this, A, I);
    }, g.prototype.imul = function(A) {
      return this.clone().mulTo(A, this);
    }, g.prototype.imuln = function(A) {
      var I = A < 0;
      I && (A = -A), o(typeof A == "number"), o(A < 67108864);
      for (var U = 0, X = 0; X < this.length; X++) {
        var Q = (this.words[X] | 0) * A, F = (Q & 67108863) + (U & 67108863);
        U >>= 26, U += Q / 67108864 | 0, U += F >>> 26, this.words[X] = F & 67108863;
      }
      return U !== 0 && (this.words[X] = U, this.length++), I ? this.ineg() : this;
    }, g.prototype.muln = function(A) {
      return this.clone().imuln(A);
    }, g.prototype.sqr = function() {
      return this.mul(this);
    }, g.prototype.isqr = function() {
      return this.imul(this.clone());
    }, g.prototype.pow = function(A) {
      var I = fe(A);
      if (I.length === 0)
        return new g(1);
      for (var U = this, X = 0; X < I.length && I[X] === 0; X++, U = U.sqr())
        ;
      if (++X < I.length)
        for (var Q = U.sqr(); X < I.length; X++, Q = Q.sqr())
          I[X] !== 0 && (U = U.mul(Q));
      return U;
    }, g.prototype.iushln = function(A) {
      o(typeof A == "number" && A >= 0);
      var I = A % 26, U = (A - I) / 26, X = 67108863 >>> 26 - I << 26 - I, Q;
      if (I !== 0) {
        var F = 0;
        for (Q = 0; Q < this.length; Q++) {
          var $ = this.words[Q] & X, H = (this.words[Q] | 0) - $ << I;
          this.words[Q] = H | F, F = $ >>> 26 - I;
        }
        F && (this.words[Q] = F, this.length++);
      }
      if (U !== 0) {
        for (Q = this.length - 1; Q >= 0; Q--)
          this.words[Q + U] = this.words[Q];
        for (Q = 0; Q < U; Q++)
          this.words[Q] = 0;
        this.length += U;
      }
      return this._strip();
    }, g.prototype.ishln = function(A) {
      return o(this.negative === 0), this.iushln(A);
    }, g.prototype.iushrn = function(A, I, U) {
      o(typeof A == "number" && A >= 0);
      var X;
      I ? X = (I - I % 26) / 26 : X = 0;
      var Q = A % 26, F = Math.min((A - Q) / 26, this.length), $ = 67108863 ^ 67108863 >>> Q << Q, H = U;
      if (X -= F, X = Math.max(0, X), H) {
        for (var q = 0; q < F; q++)
          H.words[q] = this.words[q];
        H.length = F;
      }
      if (F !== 0)
        if (this.length > F)
          for (this.length -= F, q = 0; q < this.length; q++)
            this.words[q] = this.words[q + F];
        else
          this.words[0] = 0, this.length = 1;
      var z = 0;
      for (q = this.length - 1; q >= 0 && (z !== 0 || q >= X); q--) {
        var me = this.words[q] | 0;
        this.words[q] = z << 26 - Q | me >>> Q, z = me & $;
      }
      return H && z !== 0 && (H.words[H.length++] = z), this.length === 0 && (this.words[0] = 0, this.length = 1), this._strip();
    }, g.prototype.ishrn = function(A, I, U) {
      return o(this.negative === 0), this.iushrn(A, I, U);
    }, g.prototype.shln = function(A) {
      return this.clone().ishln(A);
    }, g.prototype.ushln = function(A) {
      return this.clone().iushln(A);
    }, g.prototype.shrn = function(A) {
      return this.clone().ishrn(A);
    }, g.prototype.ushrn = function(A) {
      return this.clone().iushrn(A);
    }, g.prototype.testn = function(A) {
      o(typeof A == "number" && A >= 0);
      var I = A % 26, U = (A - I) / 26, X = 1 << I;
      if (this.length <= U)
        return !1;
      var Q = this.words[U];
      return !!(Q & X);
    }, g.prototype.imaskn = function(A) {
      o(typeof A == "number" && A >= 0);
      var I = A % 26, U = (A - I) / 26;
      if (o(this.negative === 0, "imaskn works only with positive numbers"), this.length <= U)
        return this;
      if (I !== 0 && U++, this.length = Math.min(U, this.length), I !== 0) {
        var X = 67108863 ^ 67108863 >>> I << I;
        this.words[this.length - 1] &= X;
      }
      return this._strip();
    }, g.prototype.maskn = function(A) {
      return this.clone().imaskn(A);
    }, g.prototype.iaddn = function(A) {
      return o(typeof A == "number"), o(A < 67108864), A < 0 ? this.isubn(-A) : this.negative !== 0 ? this.length === 1 && (this.words[0] | 0) <= A ? (this.words[0] = A - (this.words[0] | 0), this.negative = 0, this) : (this.negative = 0, this.isubn(A), this.negative = 1, this) : this._iaddn(A);
    }, g.prototype._iaddn = function(A) {
      this.words[0] += A;
      for (var I = 0; I < this.length && this.words[I] >= 67108864; I++)
        this.words[I] -= 67108864, I === this.length - 1 ? this.words[I + 1] = 1 : this.words[I + 1]++;
      return this.length = Math.max(this.length, I + 1), this;
    }, g.prototype.isubn = function(A) {
      if (o(typeof A == "number"), o(A < 67108864), A < 0)
        return this.iaddn(-A);
      if (this.negative !== 0)
        return this.negative = 0, this.iaddn(A), this.negative = 1, this;
      if (this.words[0] -= A, this.length === 1 && this.words[0] < 0)
        this.words[0] = -this.words[0], this.negative = 1;
      else
        for (var I = 0; I < this.length && this.words[I] < 0; I++)
          this.words[I] += 67108864, this.words[I + 1] -= 1;
      return this._strip();
    }, g.prototype.addn = function(A) {
      return this.clone().iaddn(A);
    }, g.prototype.subn = function(A) {
      return this.clone().isubn(A);
    }, g.prototype.iabs = function() {
      return this.negative = 0, this;
    }, g.prototype.abs = function() {
      return this.clone().iabs();
    }, g.prototype._ishlnsubmul = function(A, I, U) {
      var X = A.length + U, Q;
      this._expand(X);
      var F, $ = 0;
      for (Q = 0; Q < A.length; Q++) {
        F = (this.words[Q + U] | 0) + $;
        var H = (A.words[Q] | 0) * I;
        F -= H & 67108863, $ = (F >> 26) - (H / 67108864 | 0), this.words[Q + U] = F & 67108863;
      }
      for (; Q < this.length - U; Q++)
        F = (this.words[Q + U] | 0) + $, $ = F >> 26, this.words[Q + U] = F & 67108863;
      if ($ === 0)
        return this._strip();
      for (o($ === -1), $ = 0, Q = 0; Q < this.length; Q++)
        F = -(this.words[Q] | 0) + $, $ = F >> 26, this.words[Q] = F & 67108863;
      return this.negative = 1, this._strip();
    }, g.prototype._wordDiv = function(A, I) {
      var U = this.length - A.length, X = this.clone(), Q = A, F = Q.words[Q.length - 1] | 0, $ = this._countBits(F);
      U = 26 - $, U !== 0 && (Q = Q.ushln(U), X.iushln(U), F = Q.words[Q.length - 1] | 0);
      var H = X.length - Q.length, q;
      if (I !== "mod") {
        q = new g(null), q.length = H + 1, q.words = new Array(q.length);
        for (var z = 0; z < q.length; z++)
          q.words[z] = 0;
      }
      var me = X.clone()._ishlnsubmul(Q, 1, H);
      me.negative === 0 && (X = me, q && (q.words[H] = 1));
      for (var Ce = H - 1; Ce >= 0; Ce--) {
        var je = (X.words[Q.length + Ce] | 0) * 67108864 + (X.words[Q.length + Ce - 1] | 0);
        for (je = Math.min(je / F | 0, 67108863), X._ishlnsubmul(Q, je, Ce); X.negative !== 0; )
          je--, X.negative = 0, X._ishlnsubmul(Q, 1, Ce), X.isZero() || (X.negative ^= 1);
        q && (q.words[Ce] = je);
      }
      return q && q._strip(), X._strip(), I !== "div" && U !== 0 && X.iushrn(U), {
        div: q || null,
        mod: X
      };
    }, g.prototype.divmod = function(A, I, U) {
      if (o(!A.isZero()), this.isZero())
        return {
          div: new g(0),
          mod: new g(0)
        };
      var X, Q, F;
      return this.negative !== 0 && A.negative === 0 ? (F = this.neg().divmod(A, I), I !== "mod" && (X = F.div.neg()), I !== "div" && (Q = F.mod.neg(), U && Q.negative !== 0 && Q.iadd(A)), {
        div: X,
        mod: Q
      }) : this.negative === 0 && A.negative !== 0 ? (F = this.divmod(A.neg(), I), I !== "mod" && (X = F.div.neg()), {
        div: X,
        mod: F.mod
      }) : this.negative & A.negative ? (F = this.neg().divmod(A.neg(), I), I !== "div" && (Q = F.mod.neg(), U && Q.negative !== 0 && Q.isub(A)), {
        div: F.div,
        mod: Q
      }) : A.length > this.length || this.cmp(A) < 0 ? {
        div: new g(0),
        mod: this
      } : A.length === 1 ? I === "div" ? {
        div: this.divn(A.words[0]),
        mod: null
      } : I === "mod" ? {
        div: null,
        mod: new g(this.modrn(A.words[0]))
      } : {
        div: this.divn(A.words[0]),
        mod: new g(this.modrn(A.words[0]))
      } : this._wordDiv(A, I);
    }, g.prototype.div = function(A) {
      return this.divmod(A, "div", !1).div;
    }, g.prototype.mod = function(A) {
      return this.divmod(A, "mod", !1).mod;
    }, g.prototype.umod = function(A) {
      return this.divmod(A, "mod", !0).mod;
    }, g.prototype.divRound = function(A) {
      var I = this.divmod(A);
      if (I.mod.isZero())
        return I.div;
      var U = I.div.negative !== 0 ? I.mod.isub(A) : I.mod, X = A.ushrn(1), Q = A.andln(1), F = U.cmp(X);
      return F < 0 || Q === 1 && F === 0 ? I.div : I.div.negative !== 0 ? I.div.isubn(1) : I.div.iaddn(1);
    }, g.prototype.modrn = function(A) {
      var I = A < 0;
      I && (A = -A), o(A <= 67108863);
      for (var U = (1 << 26) % A, X = 0, Q = this.length - 1; Q >= 0; Q--)
        X = (U * X + (this.words[Q] | 0)) % A;
      return I ? -X : X;
    }, g.prototype.modn = function(A) {
      return this.modrn(A);
    }, g.prototype.idivn = function(A) {
      var I = A < 0;
      I && (A = -A), o(A <= 67108863);
      for (var U = 0, X = this.length - 1; X >= 0; X--) {
        var Q = (this.words[X] | 0) + U * 67108864;
        this.words[X] = Q / A | 0, U = Q % A;
      }
      return this._strip(), I ? this.ineg() : this;
    }, g.prototype.divn = function(A) {
      return this.clone().idivn(A);
    }, g.prototype.egcd = function(A) {
      o(A.negative === 0), o(!A.isZero());
      var I = this, U = A.clone();
      I.negative !== 0 ? I = I.umod(A) : I = I.clone();
      for (var X = new g(1), Q = new g(0), F = new g(0), $ = new g(1), H = 0; I.isEven() && U.isEven(); )
        I.iushrn(1), U.iushrn(1), ++H;
      for (var q = U.clone(), z = I.clone(); !I.isZero(); ) {
        for (var me = 0, Ce = 1; !(I.words[0] & Ce) && me < 26; ++me, Ce <<= 1)
          ;
        if (me > 0)
          for (I.iushrn(me); me-- > 0; )
            (X.isOdd() || Q.isOdd()) && (X.iadd(q), Q.isub(z)), X.iushrn(1), Q.iushrn(1);
        for (var je = 0, Re = 1; !(U.words[0] & Re) && je < 26; ++je, Re <<= 1)
          ;
        if (je > 0)
          for (U.iushrn(je); je-- > 0; )
            (F.isOdd() || $.isOdd()) && (F.iadd(q), $.isub(z)), F.iushrn(1), $.iushrn(1);
        I.cmp(U) >= 0 ? (I.isub(U), X.isub(F), Q.isub($)) : (U.isub(I), F.isub(X), $.isub(Q));
      }
      return {
        a: F,
        b: $,
        gcd: U.iushln(H)
      };
    }, g.prototype._invmp = function(A) {
      o(A.negative === 0), o(!A.isZero());
      var I = this, U = A.clone();
      I.negative !== 0 ? I = I.umod(A) : I = I.clone();
      for (var X = new g(1), Q = new g(0), F = U.clone(); I.cmpn(1) > 0 && U.cmpn(1) > 0; ) {
        for (var $ = 0, H = 1; !(I.words[0] & H) && $ < 26; ++$, H <<= 1)
          ;
        if ($ > 0)
          for (I.iushrn($); $-- > 0; )
            X.isOdd() && X.iadd(F), X.iushrn(1);
        for (var q = 0, z = 1; !(U.words[0] & z) && q < 26; ++q, z <<= 1)
          ;
        if (q > 0)
          for (U.iushrn(q); q-- > 0; )
            Q.isOdd() && Q.iadd(F), Q.iushrn(1);
        I.cmp(U) >= 0 ? (I.isub(U), X.isub(Q)) : (U.isub(I), Q.isub(X));
      }
      var me;
      return I.cmpn(1) === 0 ? me = X : me = Q, me.cmpn(0) < 0 && me.iadd(A), me;
    }, g.prototype.gcd = function(A) {
      if (this.isZero())
        return A.abs();
      if (A.isZero())
        return this.abs();
      var I = this.clone(), U = A.clone();
      I.negative = 0, U.negative = 0;
      for (var X = 0; I.isEven() && U.isEven(); X++)
        I.iushrn(1), U.iushrn(1);
      do {
        for (; I.isEven(); )
          I.iushrn(1);
        for (; U.isEven(); )
          U.iushrn(1);
        var Q = I.cmp(U);
        if (Q < 0) {
          var F = I;
          I = U, U = F;
        } else if (Q === 0 || U.cmpn(1) === 0)
          break;
        I.isub(U);
      } while (!0);
      return U.iushln(X);
    }, g.prototype.invm = function(A) {
      return this.egcd(A).a.umod(A);
    }, g.prototype.isEven = function() {
      return (this.words[0] & 1) === 0;
    }, g.prototype.isOdd = function() {
      return (this.words[0] & 1) === 1;
    }, g.prototype.andln = function(A) {
      return this.words[0] & A;
    }, g.prototype.bincn = function(A) {
      o(typeof A == "number");
      var I = A % 26, U = (A - I) / 26, X = 1 << I;
      if (this.length <= U)
        return this._expand(U + 1), this.words[U] |= X, this;
      for (var Q = X, F = U; Q !== 0 && F < this.length; F++) {
        var $ = this.words[F] | 0;
        $ += Q, Q = $ >>> 26, $ &= 67108863, this.words[F] = $;
      }
      return Q !== 0 && (this.words[F] = Q, this.length++), this;
    }, g.prototype.isZero = function() {
      return this.length === 1 && this.words[0] === 0;
    }, g.prototype.cmpn = function(A) {
      var I = A < 0;
      if (this.negative !== 0 && !I)
        return -1;
      if (this.negative === 0 && I)
        return 1;
      this._strip();
      var U;
      if (this.length > 1)
        U = 1;
      else {
        I && (A = -A), o(A <= 67108863, "Number is too big");
        var X = this.words[0] | 0;
        U = X === A ? 0 : X < A ? -1 : 1;
      }
      return this.negative !== 0 ? -U | 0 : U;
    }, g.prototype.cmp = function(A) {
      if (this.negative !== 0 && A.negative === 0)
        return -1;
      if (this.negative === 0 && A.negative !== 0)
        return 1;
      var I = this.ucmp(A);
      return this.negative !== 0 ? -I | 0 : I;
    }, g.prototype.ucmp = function(A) {
      if (this.length > A.length)
        return 1;
      if (this.length < A.length)
        return -1;
      for (var I = 0, U = this.length - 1; U >= 0; U--) {
        var X = this.words[U] | 0, Q = A.words[U] | 0;
        if (X !== Q) {
          X < Q ? I = -1 : X > Q && (I = 1);
          break;
        }
      }
      return I;
    }, g.prototype.gtn = function(A) {
      return this.cmpn(A) === 1;
    }, g.prototype.gt = function(A) {
      return this.cmp(A) === 1;
    }, g.prototype.gten = function(A) {
      return this.cmpn(A) >= 0;
    }, g.prototype.gte = function(A) {
      return this.cmp(A) >= 0;
    }, g.prototype.ltn = function(A) {
      return this.cmpn(A) === -1;
    }, g.prototype.lt = function(A) {
      return this.cmp(A) === -1;
    }, g.prototype.lten = function(A) {
      return this.cmpn(A) <= 0;
    }, g.prototype.lte = function(A) {
      return this.cmp(A) <= 0;
    }, g.prototype.eqn = function(A) {
      return this.cmpn(A) === 0;
    }, g.prototype.eq = function(A) {
      return this.cmp(A) === 0;
    }, g.red = function(A) {
      return new J(A);
    }, g.prototype.toRed = function(A) {
      return o(!this.red, "Already a number in reduction context"), o(this.negative === 0, "red works only with positives"), A.convertTo(this)._forceRed(A);
    }, g.prototype.fromRed = function() {
      return o(this.red, "fromRed works only with numbers in reduction context"), this.red.convertFrom(this);
    }, g.prototype._forceRed = function(A) {
      return this.red = A, this;
    }, g.prototype.forceRed = function(A) {
      return o(!this.red, "Already a number in reduction context"), this._forceRed(A);
    }, g.prototype.redAdd = function(A) {
      return o(this.red, "redAdd works only with red numbers"), this.red.add(this, A);
    }, g.prototype.redIAdd = function(A) {
      return o(this.red, "redIAdd works only with red numbers"), this.red.iadd(this, A);
    }, g.prototype.redSub = function(A) {
      return o(this.red, "redSub works only with red numbers"), this.red.sub(this, A);
    }, g.prototype.redISub = function(A) {
      return o(this.red, "redISub works only with red numbers"), this.red.isub(this, A);
    }, g.prototype.redShl = function(A) {
      return o(this.red, "redShl works only with red numbers"), this.red.shl(this, A);
    }, g.prototype.redMul = function(A) {
      return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, A), this.red.mul(this, A);
    }, g.prototype.redIMul = function(A) {
      return o(this.red, "redMul works only with red numbers"), this.red._verify2(this, A), this.red.imul(this, A);
    }, g.prototype.redSqr = function() {
      return o(this.red, "redSqr works only with red numbers"), this.red._verify1(this), this.red.sqr(this);
    }, g.prototype.redISqr = function() {
      return o(this.red, "redISqr works only with red numbers"), this.red._verify1(this), this.red.isqr(this);
    }, g.prototype.redSqrt = function() {
      return o(this.red, "redSqrt works only with red numbers"), this.red._verify1(this), this.red.sqrt(this);
    }, g.prototype.redInvm = function() {
      return o(this.red, "redInvm works only with red numbers"), this.red._verify1(this), this.red.invm(this);
    }, g.prototype.redNeg = function() {
      return o(this.red, "redNeg works only with red numbers"), this.red._verify1(this), this.red.neg(this);
    }, g.prototype.redPow = function(A) {
      return o(this.red && !A.red, "redPow(normalNum)"), this.red._verify1(this), this.red.pow(this, A);
    };
    var Pe = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function Ue(A, I) {
      this.name = A, this.p = new g(I, 16), this.n = this.p.bitLength(), this.k = new g(1).iushln(this.n).isub(this.p), this.tmp = this._tmp();
    }
    Ue.prototype._tmp = function() {
      var A = new g(null);
      return A.words = new Array(Math.ceil(this.n / 13)), A;
    }, Ue.prototype.ireduce = function(A) {
      var I = A, U;
      do
        this.split(I, this.tmp), I = this.imulK(I), I = I.iadd(this.tmp), U = I.bitLength();
      while (U > this.n);
      var X = U < this.n ? -1 : I.ucmp(this.p);
      return X === 0 ? (I.words[0] = 0, I.length = 1) : X > 0 ? I.isub(this.p) : I.strip !== void 0 ? I.strip() : I._strip(), I;
    }, Ue.prototype.split = function(A, I) {
      A.iushrn(this.n, 0, I);
    }, Ue.prototype.imulK = function(A) {
      return A.imul(this.k);
    };
    function ze() {
      Ue.call(
        this,
        "k256",
        "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f"
      );
    }
    S(ze, Ue), ze.prototype.split = function(A, I) {
      for (var U = 4194303, X = Math.min(A.length, 9), Q = 0; Q < X; Q++)
        I.words[Q] = A.words[Q];
      if (I.length = X, A.length <= 9) {
        A.words[0] = 0, A.length = 1;
        return;
      }
      var F = A.words[9];
      for (I.words[I.length++] = F & U, Q = 10; Q < A.length; Q++) {
        var $ = A.words[Q] | 0;
        A.words[Q - 10] = ($ & U) << 4 | F >>> 22, F = $;
      }
      F >>>= 22, A.words[Q - 10] = F, F === 0 && A.length > 10 ? A.length -= 10 : A.length -= 9;
    }, ze.prototype.imulK = function(A) {
      A.words[A.length] = 0, A.words[A.length + 1] = 0, A.length += 2;
      for (var I = 0, U = 0; U < A.length; U++) {
        var X = A.words[U] | 0;
        I += X * 977, A.words[U] = I & 67108863, I = X * 64 + (I / 67108864 | 0);
      }
      return A.words[A.length - 1] === 0 && (A.length--, A.words[A.length - 1] === 0 && A.length--), A;
    };
    function Le() {
      Ue.call(
        this,
        "p224",
        "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001"
      );
    }
    S(Le, Ue);
    function Ne() {
      Ue.call(
        this,
        "p192",
        "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff"
      );
    }
    S(Ne, Ue);
    function $e() {
      Ue.call(
        this,
        "25519",
        "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed"
      );
    }
    S($e, Ue), $e.prototype.imulK = function(A) {
      for (var I = 0, U = 0; U < A.length; U++) {
        var X = (A.words[U] | 0) * 19 + I, Q = X & 67108863;
        X >>>= 26, A.words[U] = Q, I = X;
      }
      return I !== 0 && (A.words[A.length++] = I), A;
    }, g._prime = function(A) {
      if (Pe[A])
        return Pe[A];
      var I;
      if (A === "k256")
        I = new ze();
      else if (A === "p224")
        I = new Le();
      else if (A === "p192")
        I = new Ne();
      else if (A === "p25519")
        I = new $e();
      else
        throw new Error("Unknown prime " + A);
      return Pe[A] = I, I;
    };
    function J(A) {
      if (typeof A == "string") {
        var I = g._prime(A);
        this.m = I.p, this.prime = I;
      } else
        o(A.gtn(1), "modulus must be greater than 1"), this.m = A, this.prime = null;
    }
    J.prototype._verify1 = function(A) {
      o(A.negative === 0, "red works only with positives"), o(A.red, "red works only with red numbers");
    }, J.prototype._verify2 = function(A, I) {
      o((A.negative | I.negative) === 0, "red works only with positives"), o(
        A.red && A.red === I.red,
        "red works only with red numbers"
      );
    }, J.prototype.imod = function(A) {
      return this.prime ? this.prime.ireduce(A)._forceRed(this) : (D(A, A.umod(this.m)._forceRed(this)), A);
    }, J.prototype.neg = function(A) {
      return A.isZero() ? A.clone() : this.m.sub(A)._forceRed(this);
    }, J.prototype.add = function(A, I) {
      this._verify2(A, I);
      var U = A.add(I);
      return U.cmp(this.m) >= 0 && U.isub(this.m), U._forceRed(this);
    }, J.prototype.iadd = function(A, I) {
      this._verify2(A, I);
      var U = A.iadd(I);
      return U.cmp(this.m) >= 0 && U.isub(this.m), U;
    }, J.prototype.sub = function(A, I) {
      this._verify2(A, I);
      var U = A.sub(I);
      return U.cmpn(0) < 0 && U.iadd(this.m), U._forceRed(this);
    }, J.prototype.isub = function(A, I) {
      this._verify2(A, I);
      var U = A.isub(I);
      return U.cmpn(0) < 0 && U.iadd(this.m), U;
    }, J.prototype.shl = function(A, I) {
      return this._verify1(A), this.imod(A.ushln(I));
    }, J.prototype.imul = function(A, I) {
      return this._verify2(A, I), this.imod(A.imul(I));
    }, J.prototype.mul = function(A, I) {
      return this._verify2(A, I), this.imod(A.mul(I));
    }, J.prototype.isqr = function(A) {
      return this.imul(A, A.clone());
    }, J.prototype.sqr = function(A) {
      return this.mul(A, A);
    }, J.prototype.sqrt = function(A) {
      if (A.isZero())
        return A.clone();
      var I = this.m.andln(3);
      if (o(I % 2 === 1), I === 3) {
        var U = this.m.add(new g(1)).iushrn(2);
        return this.pow(A, U);
      }
      for (var X = this.m.subn(1), Q = 0; !X.isZero() && X.andln(1) === 0; )
        Q++, X.iushrn(1);
      o(!X.isZero());
      var F = new g(1).toRed(this), $ = F.redNeg(), H = this.m.subn(1).iushrn(1), q = this.m.bitLength();
      for (q = new g(2 * q * q).toRed(this); this.pow(q, H).cmp($) !== 0; )
        q.redIAdd($);
      for (var z = this.pow(q, X), me = this.pow(A, X.addn(1).iushrn(1)), Ce = this.pow(A, X), je = Q; Ce.cmp(F) !== 0; ) {
        for (var Re = Ce, Ae = 0; Re.cmp(F) !== 0; Ae++)
          Re = Re.redSqr();
        o(Ae < je);
        var ke = this.pow(z, new g(1).iushln(je - Ae - 1));
        me = me.redMul(ke), z = ke.redSqr(), Ce = Ce.redMul(z), je = Ae;
      }
      return me;
    }, J.prototype.invm = function(A) {
      var I = A._invmp(this.m);
      return I.negative !== 0 ? (I.negative = 0, this.imod(I).redNeg()) : this.imod(I);
    }, J.prototype.pow = function(A, I) {
      if (I.isZero())
        return new g(1).toRed(this);
      if (I.cmpn(1) === 0)
        return A.clone();
      var U = 4, X = new Array(1 << U);
      X[0] = new g(1).toRed(this), X[1] = A;
      for (var Q = 2; Q < X.length; Q++)
        X[Q] = this.mul(X[Q - 1], A);
      var F = X[0], $ = 0, H = 0, q = I.bitLength() % 26;
      for (q === 0 && (q = 26), Q = I.length - 1; Q >= 0; Q--) {
        for (var z = I.words[Q], me = q - 1; me >= 0; me--) {
          var Ce = z >> me & 1;
          if (F !== X[0] && (F = this.sqr(F)), Ce === 0 && $ === 0) {
            H = 0;
            continue;
          }
          $ <<= 1, $ |= Ce, H++, !(H !== U && (Q !== 0 || me !== 0)) && (F = this.mul(F, X[$]), H = 0, $ = 0);
        }
        q = 26;
      }
      return F;
    }, J.prototype.convertTo = function(A) {
      var I = A.umod(this.m);
      return I === A ? I.clone() : I;
    }, J.prototype.convertFrom = function(A) {
      var I = A.clone();
      return I.red = null, I;
    }, g.mont = function(A) {
      return new ne(A);
    };
    function ne(A) {
      J.call(this, A), this.shift = this.m.bitLength(), this.shift % 26 !== 0 && (this.shift += 26 - this.shift % 26), this.r = new g(1).iushln(this.shift), this.r2 = this.imod(this.r.sqr()), this.rinv = this.r._invmp(this.m), this.minv = this.rinv.mul(this.r).isubn(1).div(this.m), this.minv = this.minv.umod(this.r), this.minv = this.r.sub(this.minv);
    }
    S(ne, J), ne.prototype.convertTo = function(A) {
      return this.imod(A.ushln(this.shift));
    }, ne.prototype.convertFrom = function(A) {
      var I = this.imod(A.mul(this.rinv));
      return I.red = null, I;
    }, ne.prototype.imul = function(A, I) {
      if (A.isZero() || I.isZero())
        return A.words[0] = 0, A.length = 1, A;
      var U = A.imul(I), X = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Q = U.isub(X).iushrn(this.shift), F = Q;
      return Q.cmp(this.m) >= 0 ? F = Q.isub(this.m) : Q.cmpn(0) < 0 && (F = Q.iadd(this.m)), F._forceRed(this);
    }, ne.prototype.mul = function(A, I) {
      if (A.isZero() || I.isZero())
        return new g(0)._forceRed(this);
      var U = A.mul(I), X = U.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m), Q = U.isub(X).iushrn(this.shift), F = Q;
      return Q.cmp(this.m) >= 0 ? F = Q.isub(this.m) : Q.cmpn(0) < 0 && (F = Q.iadd(this.m)), F._forceRed(this);
    }, ne.prototype.invm = function(A) {
      var I = this.imod(A._invmp(this.m).mul(this.r2));
      return I._forceRed(this);
    };
  })(e, Me);
})(lh);
var by = lh.exports, Ai = {}, dh = {}, xy = {}, ph = {}, xs = pe, Sa = xs.Buffer, qr = {}, Vr;
for (Vr in xs)
  xs.hasOwnProperty(Vr) && (Vr === "SlowBuffer" || Vr === "Buffer" || (qr[Vr] = xs[Vr]));
var wa = qr.Buffer = {};
for (Vr in Sa)
  Sa.hasOwnProperty(Vr) && (Vr === "allocUnsafe" || Vr === "allocUnsafeSlow" || (wa[Vr] = Sa[Vr]));
qr.Buffer.prototype = Sa.prototype;
(!wa.from || wa.from === Uint8Array.from) && (wa.from = function(e, t, h) {
  if (typeof e == "number")
    throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof e);
  if (e && typeof e.length > "u")
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof e);
  return Sa(e, t, h);
});
wa.alloc || (wa.alloc = function(e, t, h) {
  if (typeof e != "number")
    throw new TypeError('The "size" argument must be of type number. Received type ' + typeof e);
  if (e < 0 || e >= 2 * (1 << 30))
    throw new RangeError('The value "' + e + '" is invalid for option "size"');
  var o = Sa(e);
  return !t || t.length === 0 ? o.fill(0) : typeof h == "string" ? o.fill(t, h) : o.fill(t), o;
});
if (!qr.kStringMaxLength)
  try {
    qr.kStringMaxLength = Ve.binding("buffer").kStringMaxLength;
  } catch {
  }
qr.constants || (qr.constants = {
  MAX_LENGTH: qr.kMaxLength
}, qr.kStringMaxLength && (qr.constants.MAX_STRING_LENGTH = qr.kStringMaxLength));
var $0 = qr, wf = {};
const P8 = ut;
function ti(e) {
  this._reporterState = {
    obj: null,
    path: [],
    options: e || {},
    errors: []
  };
}
wf.Reporter = ti;
ti.prototype.isError = function(e) {
  return e instanceof Ra;
};
ti.prototype.save = function() {
  const e = this._reporterState;
  return { obj: e.obj, pathLen: e.path.length };
};
ti.prototype.restore = function(e) {
  const t = this._reporterState;
  t.obj = e.obj, t.path = t.path.slice(0, e.pathLen);
};
ti.prototype.enterKey = function(e) {
  return this._reporterState.path.push(e);
};
ti.prototype.exitKey = function(e) {
  const t = this._reporterState;
  t.path = t.path.slice(0, e - 1);
};
ti.prototype.leaveKey = function(e, t, h) {
  const o = this._reporterState;
  this.exitKey(e), o.obj !== null && (o.obj[t] = h);
};
ti.prototype.path = function() {
  return this._reporterState.path.join("/");
};
ti.prototype.enterObject = function() {
  const e = this._reporterState, t = e.obj;
  return e.obj = {}, t;
};
ti.prototype.leaveObject = function(e) {
  const t = this._reporterState, h = t.obj;
  return t.obj = e, h;
};
ti.prototype.error = function(e) {
  let t;
  const h = this._reporterState, o = e instanceof Ra;
  if (o ? t = e : t = new Ra(h.path.map(function(S) {
    return "[" + JSON.stringify(S) + "]";
  }).join(""), e.message || e, e.stack), !h.options.partial)
    throw t;
  return o || h.errors.push(t), t;
};
ti.prototype.wrapResult = function(e) {
  const t = this._reporterState;
  return t.options.partial ? {
    result: this.isError(e) ? null : e,
    errors: t.errors
  } : e;
};
function Ra(e, t) {
  this.path = e, this.rethrow(t);
}
P8(Ra, Error);
Ra.prototype.rethrow = function(e) {
  if (this.message = e + " at: " + (this.path || "(shallow)"), Error.captureStackTrace && Error.captureStackTrace(this, Ra), !this.stack)
    try {
      throw new Error(this.message);
    } catch (t) {
      this.stack = t.stack;
    }
  return this;
};
var ea = {};
const L8 = ut, Cf = wf.Reporter, Na = $0.Buffer;
function Yr(e, t) {
  if (Cf.call(this, t), !Na.isBuffer(e)) {
    this.error("Input not Buffer");
    return;
  }
  this.base = e, this.offset = 0, this.length = e.length;
}
L8(Yr, Cf);
ea.DecoderBuffer = Yr;
Yr.isDecoderBuffer = function(e) {
  return e instanceof Yr ? !0 : typeof e == "object" && Na.isBuffer(e.base) && e.constructor.name === "DecoderBuffer" && typeof e.offset == "number" && typeof e.length == "number" && typeof e.save == "function" && typeof e.restore == "function" && typeof e.isEmpty == "function" && typeof e.readUInt8 == "function" && typeof e.skip == "function" && typeof e.raw == "function";
};
Yr.prototype.save = function() {
  return { offset: this.offset, reporter: Cf.prototype.save.call(this) };
};
Yr.prototype.restore = function(e) {
  const t = new Yr(this.base);
  return t.offset = e.offset, t.length = this.offset, this.offset = e.offset, Cf.prototype.restore.call(this, e.reporter), t;
};
Yr.prototype.isEmpty = function() {
  return this.offset === this.length;
};
Yr.prototype.readUInt8 = function(e) {
  return this.offset + 1 <= this.length ? this.base.readUInt8(this.offset++, !0) : this.error(e || "DecoderBuffer overrun");
};
Yr.prototype.skip = function(e, t) {
  if (!(this.offset + e <= this.length))
    return this.error(t || "DecoderBuffer overrun");
  const h = new Yr(this.base);
  return h._reporterState = this._reporterState, h.offset = this.offset, h.length = this.offset + e, this.offset += e, h;
};
Yr.prototype.raw = function(e) {
  return this.base.slice(e ? e.offset : this.offset, this.length);
};
function Da(e, t) {
  if (Array.isArray(e))
    this.length = 0, this.value = e.map(function(h) {
      return Da.isEncoderBuffer(h) || (h = new Da(h, t)), this.length += h.length, h;
    }, this);
  else if (typeof e == "number") {
    if (!(0 <= e && e <= 255))
      return t.error("non-byte EncoderBuffer value");
    this.value = e, this.length = 1;
  } else if (typeof e == "string")
    this.value = e, this.length = Na.byteLength(e);
  else if (Na.isBuffer(e))
    this.value = e, this.length = e.length;
  else
    return t.error("Unsupported type: " + typeof e);
}
ea.EncoderBuffer = Da;
Da.isEncoderBuffer = function(e) {
  return e instanceof Da ? !0 : typeof e == "object" && e.constructor.name === "EncoderBuffer" && typeof e.length == "number" && typeof e.join == "function";
};
Da.prototype.join = function(e, t) {
  return e || (e = Na.alloc(this.length)), t || (t = 0), this.length === 0 || (Array.isArray(this.value) ? this.value.forEach(function(h) {
    h.join(e, t), t += h.length;
  }) : (typeof this.value == "number" ? e[t] = this.value : typeof this.value == "string" ? e.write(this.value, t) : Na.isBuffer(this.value) && this.value.copy(e, t), t += this.length)), e;
};
const k8 = wf.Reporter, U8 = ea.EncoderBuffer, F8 = ea.DecoderBuffer, xr = Qr, _y = [
  "seq",
  "seqof",
  "set",
  "setof",
  "objid",
  "bool",
  "gentime",
  "utctime",
  "null_",
  "enum",
  "int",
  "objDesc",
  "bitstr",
  "bmpstr",
  "charstr",
  "genstr",
  "graphstr",
  "ia5str",
  "iso646str",
  "numstr",
  "octstr",
  "printstr",
  "t61str",
  "unistr",
  "utf8str",
  "videostr"
], q8 = [
  "key",
  "obj",
  "use",
  "optional",
  "explicit",
  "implicit",
  "def",
  "choice",
  "any",
  "contains"
].concat(_y), V8 = [
  "_peekTag",
  "_decodeTag",
  "_use",
  "_decodeStr",
  "_decodeObjid",
  "_decodeTime",
  "_decodeNull",
  "_decodeInt",
  "_decodeBool",
  "_decodeList",
  "_encodeComposite",
  "_encodeStr",
  "_encodeObjid",
  "_encodeTime",
  "_encodeNull",
  "_encodeInt",
  "_encodeBool"
];
function Rt(e, t, h) {
  const o = {};
  this._baseState = o, o.name = h, o.enc = e, o.parent = t || null, o.children = null, o.tag = null, o.args = null, o.reverseArgs = null, o.choice = null, o.optional = !1, o.any = !1, o.obj = !1, o.use = null, o.useDecoder = null, o.key = null, o.default = null, o.explicit = null, o.implicit = null, o.contains = null, o.parent || (o.children = [], this._wrap());
}
var vh = Rt;
const K8 = [
  "enc",
  "parent",
  "children",
  "tag",
  "args",
  "reverseArgs",
  "choice",
  "optional",
  "any",
  "obj",
  "use",
  "alteredUse",
  "key",
  "default",
  "explicit",
  "implicit",
  "contains"
];
Rt.prototype.clone = function() {
  const e = this._baseState, t = {};
  K8.forEach(function(o) {
    t[o] = e[o];
  });
  const h = new this.constructor(t.parent);
  return h._baseState = t, h;
};
Rt.prototype._wrap = function() {
  const e = this._baseState;
  q8.forEach(function(t) {
    this[t] = function() {
      const h = new this.constructor(this);
      return e.children.push(h), h[t].apply(h, arguments);
    };
  }, this);
};
Rt.prototype._init = function(e) {
  const t = this._baseState;
  xr(t.parent === null), e.call(this), t.children = t.children.filter(function(h) {
    return h._baseState.parent === this;
  }, this), xr.equal(t.children.length, 1, "Root node can have only one child");
};
Rt.prototype._useArgs = function(e) {
  const t = this._baseState, h = e.filter(function(o) {
    return o instanceof this.constructor;
  }, this);
  e = e.filter(function(o) {
    return !(o instanceof this.constructor);
  }, this), h.length !== 0 && (xr(t.children === null), t.children = h, h.forEach(function(o) {
    o._baseState.parent = this;
  }, this)), e.length !== 0 && (xr(t.args === null), t.args = e, t.reverseArgs = e.map(function(o) {
    if (typeof o != "object" || o.constructor !== Object)
      return o;
    const S = {};
    return Object.keys(o).forEach(function(g) {
      g == (g | 0) && (g |= 0);
      const B = o[g];
      S[B] = g;
    }), S;
  }));
};
V8.forEach(function(e) {
  Rt.prototype[e] = function() {
    const t = this._baseState;
    throw new Error(e + " not implemented for encoding: " + t.enc);
  };
});
_y.forEach(function(e) {
  Rt.prototype[e] = function() {
    const t = this._baseState, h = Array.prototype.slice.call(arguments);
    return xr(t.tag === null), t.tag = e, this._useArgs(h), this;
  };
});
Rt.prototype.use = function(e) {
  xr(e);
  const t = this._baseState;
  return xr(t.use === null), t.use = e, this;
};
Rt.prototype.optional = function() {
  const e = this._baseState;
  return e.optional = !0, this;
};
Rt.prototype.def = function(e) {
  const t = this._baseState;
  return xr(t.default === null), t.default = e, t.optional = !0, this;
};
Rt.prototype.explicit = function(e) {
  const t = this._baseState;
  return xr(t.explicit === null && t.implicit === null), t.explicit = e, this;
};
Rt.prototype.implicit = function(e) {
  const t = this._baseState;
  return xr(t.explicit === null && t.implicit === null), t.implicit = e, this;
};
Rt.prototype.obj = function() {
  const e = this._baseState, t = Array.prototype.slice.call(arguments);
  return e.obj = !0, t.length !== 0 && this._useArgs(t), this;
};
Rt.prototype.key = function(e) {
  const t = this._baseState;
  return xr(t.key === null), t.key = e, this;
};
Rt.prototype.any = function() {
  const e = this._baseState;
  return e.any = !0, this;
};
Rt.prototype.choice = function(e) {
  const t = this._baseState;
  return xr(t.choice === null), t.choice = e, this._useArgs(Object.keys(e).map(function(h) {
    return e[h];
  })), this;
};
Rt.prototype.contains = function(e) {
  const t = this._baseState;
  return xr(t.use === null), t.contains = e, this;
};
Rt.prototype._decode = function(e, t) {
  const h = this._baseState;
  if (h.parent === null)
    return e.wrapResult(h.children[0]._decode(e, t));
  let o = h.default, S = !0, g = null;
  if (h.key !== null && (g = e.enterKey(h.key)), h.optional) {
    let M = null;
    if (h.explicit !== null ? M = h.explicit : h.implicit !== null ? M = h.implicit : h.tag !== null && (M = h.tag), M === null && !h.any) {
      const O = e.save();
      try {
        h.choice === null ? this._decodeGeneric(h.tag, e, t) : this._decodeChoice(e, t), S = !0;
      } catch {
        S = !1;
      }
      e.restore(O);
    } else if (S = this._peekTag(e, M, h.any), e.isError(S))
      return S;
  }
  let B;
  if (h.obj && S && (B = e.enterObject()), S) {
    if (h.explicit !== null) {
      const O = this._decodeTag(e, h.explicit);
      if (e.isError(O))
        return O;
      e = O;
    }
    const M = e.offset;
    if (h.use === null && h.choice === null) {
      let O;
      h.any && (O = e.save());
      const P = this._decodeTag(
        e,
        h.implicit !== null ? h.implicit : h.tag,
        h.any
      );
      if (e.isError(P))
        return P;
      h.any ? o = e.raw(O) : e = P;
    }
    if (t && t.track && h.tag !== null && t.track(e.path(), M, e.length, "tagged"), t && t.track && h.tag !== null && t.track(e.path(), e.offset, e.length, "content"), h.any || (h.choice === null ? o = this._decodeGeneric(h.tag, e, t) : o = this._decodeChoice(e, t)), e.isError(o))
      return o;
    if (!h.any && h.choice === null && h.children !== null && h.children.forEach(function(O) {
      O._decode(e, t);
    }), h.contains && (h.tag === "octstr" || h.tag === "bitstr")) {
      const O = new F8(o);
      o = this._getUse(h.contains, e._reporterState.obj)._decode(O, t);
    }
  }
  return h.obj && S && (o = e.leaveObject(B)), h.key !== null && (o !== null || S === !0) ? e.leaveKey(g, h.key, o) : g !== null && e.exitKey(g), o;
};
Rt.prototype._decodeGeneric = function(e, t, h) {
  const o = this._baseState;
  return e === "seq" || e === "set" ? null : e === "seqof" || e === "setof" ? this._decodeList(t, e, o.args[0], h) : /str$/.test(e) ? this._decodeStr(t, e, h) : e === "objid" && o.args ? this._decodeObjid(t, o.args[0], o.args[1], h) : e === "objid" ? this._decodeObjid(t, null, null, h) : e === "gentime" || e === "utctime" ? this._decodeTime(t, e, h) : e === "null_" ? this._decodeNull(t, h) : e === "bool" ? this._decodeBool(t, h) : e === "objDesc" ? this._decodeStr(t, e, h) : e === "int" || e === "enum" ? this._decodeInt(t, o.args && o.args[0], h) : o.use !== null ? this._getUse(o.use, t._reporterState.obj)._decode(t, h) : t.error("unknown tag: " + e);
};
Rt.prototype._getUse = function(e, t) {
  const h = this._baseState;
  return h.useDecoder = this._use(e, t), xr(h.useDecoder._baseState.parent === null), h.useDecoder = h.useDecoder._baseState.children[0], h.implicit !== h.useDecoder._baseState.implicit && (h.useDecoder = h.useDecoder.clone(), h.useDecoder._baseState.implicit = h.implicit), h.useDecoder;
};
Rt.prototype._decodeChoice = function(e, t) {
  const h = this._baseState;
  let o = null, S = !1;
  return Object.keys(h.choice).some(function(g) {
    const B = e.save(), M = h.choice[g];
    try {
      const O = M._decode(e, t);
      if (e.isError(O))
        return !1;
      o = { type: g, value: O }, S = !0;
    } catch {
      return e.restore(B), !1;
    }
    return !0;
  }, this), S ? o : e.error("Choice not matched");
};
Rt.prototype._createEncoderBuffer = function(e) {
  return new U8(e, this.reporter);
};
Rt.prototype._encode = function(e, t, h) {
  const o = this._baseState;
  if (o.default !== null && o.default === e)
    return;
  const S = this._encodeValue(e, t, h);
  if (S !== void 0 && !this._skipDefault(S, t, h))
    return S;
};
Rt.prototype._encodeValue = function(e, t, h) {
  const o = this._baseState;
  if (o.parent === null)
    return o.children[0]._encode(e, t || new k8());
  let S = null;
  if (this.reporter = t, o.optional && e === void 0)
    if (o.default !== null)
      e = o.default;
    else
      return;
  let g = null, B = !1;
  if (o.any)
    S = this._createEncoderBuffer(e);
  else if (o.choice)
    S = this._encodeChoice(e, t);
  else if (o.contains)
    g = this._getUse(o.contains, h)._encode(e, t), B = !0;
  else if (o.children)
    g = o.children.map(function(M) {
      if (M._baseState.tag === "null_")
        return M._encode(null, t, e);
      if (M._baseState.key === null)
        return t.error("Child should have a key");
      const O = t.enterKey(M._baseState.key);
      if (typeof e != "object")
        return t.error("Child expected, but input is not object");
      const P = M._encode(e[M._baseState.key], t, e);
      return t.leaveKey(O), P;
    }, this).filter(function(M) {
      return M;
    }), g = this._createEncoderBuffer(g);
  else if (o.tag === "seqof" || o.tag === "setof") {
    if (!(o.args && o.args.length === 1))
      return t.error("Too many args for : " + o.tag);
    if (!Array.isArray(e))
      return t.error("seqof/setof, but data is not Array");
    const M = this.clone();
    M._baseState.implicit = null, g = this._createEncoderBuffer(e.map(function(O) {
      const P = this._baseState;
      return this._getUse(P.args[0], e)._encode(O, t);
    }, M));
  } else
    o.use !== null ? S = this._getUse(o.use, h)._encode(e, t) : (g = this._encodePrimitive(o.tag, e), B = !0);
  if (!o.any && o.choice === null) {
    const M = o.implicit !== null ? o.implicit : o.tag, O = o.implicit === null ? "universal" : "context";
    M === null ? o.use === null && t.error("Tag could be omitted only for .use()") : o.use === null && (S = this._encodeComposite(M, B, O, g));
  }
  return o.explicit !== null && (S = this._encodeComposite(o.explicit, !1, "context", S)), S;
};
Rt.prototype._encodeChoice = function(e, t) {
  const h = this._baseState, o = h.choice[e.type];
  return o || xr(
    !1,
    e.type + " not found in " + JSON.stringify(Object.keys(h.choice))
  ), o._encode(e.value, t);
};
Rt.prototype._encodePrimitive = function(e, t) {
  const h = this._baseState;
  if (/str$/.test(e))
    return this._encodeStr(t, e);
  if (e === "objid" && h.args)
    return this._encodeObjid(t, h.reverseArgs[0], h.args[1]);
  if (e === "objid")
    return this._encodeObjid(t, null, null);
  if (e === "gentime" || e === "utctime")
    return this._encodeTime(t, e);
  if (e === "null_")
    return this._encodeNull();
  if (e === "int" || e === "enum")
    return this._encodeInt(t, h.args && h.reverseArgs[0]);
  if (e === "bool")
    return this._encodeBool(t);
  if (e === "objDesc")
    return this._encodeStr(t, e);
  throw new Error("Unsupported tag: " + e);
};
Rt.prototype._isNumstr = function(e) {
  return /^[0-9 ]*$/.test(e);
};
Rt.prototype._isPrintstr = function(e) {
  return /^[A-Za-z0-9 '()+,-./:=?]*$/.test(e);
};
var Af = {};
(function(e) {
  function t(h) {
    const o = {};
    return Object.keys(h).forEach(function(S) {
      (S | 0) == S && (S = S | 0);
      const g = h[S];
      o[g] = S;
    }), o;
  }
  e.tagClass = {
    0: "universal",
    1: "application",
    2: "context",
    3: "private"
  }, e.tagClassByName = t(e.tagClass), e.tag = {
    0: "end",
    1: "bool",
    2: "int",
    3: "bitstr",
    4: "octstr",
    5: "null_",
    6: "objid",
    7: "objDesc",
    8: "external",
    9: "real",
    10: "enum",
    11: "embed",
    12: "utf8str",
    13: "relativeOid",
    16: "seq",
    17: "set",
    18: "numstr",
    19: "printstr",
    20: "t61str",
    21: "videostr",
    22: "ia5str",
    23: "utctime",
    24: "gentime",
    25: "graphstr",
    26: "iso646str",
    27: "genstr",
    28: "unistr",
    29: "charstr",
    30: "bmpstr"
  }, e.tagByName = t(e.tag);
})(Af);
const $8 = ut, Ji = $0.Buffer, Ey = vh, Do = Af;
function Sy(e) {
  this.enc = "der", this.name = e.name, this.entity = e, this.tree = new Bi(), this.tree._init(e.body);
}
var wy = Sy;
Sy.prototype.encode = function(e, t) {
  return this.tree._encode(e, t).join();
};
function Bi(e) {
  Ey.call(this, "der", e);
}
$8(Bi, Ey);
Bi.prototype._encodeComposite = function(e, t, h, o) {
  const S = H8(e, t, h, this.reporter);
  if (o.length < 128) {
    const M = Ji.alloc(2);
    return M[0] = S, M[1] = o.length, this._createEncoderBuffer([M, o]);
  }
  let g = 1;
  for (let M = o.length; M >= 256; M >>= 8)
    g++;
  const B = Ji.alloc(2 + g);
  B[0] = S, B[1] = 128 | g;
  for (let M = 1 + g, O = o.length; O > 0; M--, O >>= 8)
    B[M] = O & 255;
  return this._createEncoderBuffer([B, o]);
};
Bi.prototype._encodeStr = function(e, t) {
  if (t === "bitstr")
    return this._createEncoderBuffer([e.unused | 0, e.data]);
  if (t === "bmpstr") {
    const h = Ji.alloc(e.length * 2);
    for (let o = 0; o < e.length; o++)
      h.writeUInt16BE(e.charCodeAt(o), o * 2);
    return this._createEncoderBuffer(h);
  } else
    return t === "numstr" ? this._isNumstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: numstr supports only digits and space") : t === "printstr" ? this._isPrintstr(e) ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: printstr supports only latin upper and lower case letters, digits, space, apostrophe, left and rigth parenthesis, plus sign, comma, hyphen, dot, slash, colon, equal sign, question mark") : /str$/.test(t) ? this._createEncoderBuffer(e) : t === "objDesc" ? this._createEncoderBuffer(e) : this.reporter.error("Encoding of string type: " + t + " unsupported");
};
Bi.prototype._encodeObjid = function(e, t, h) {
  if (typeof e == "string") {
    if (!t)
      return this.reporter.error("string objid given, but no values map found");
    if (!t.hasOwnProperty(e))
      return this.reporter.error("objid not found in values map");
    e = t[e].split(/[\s.]+/g);
    for (let B = 0; B < e.length; B++)
      e[B] |= 0;
  } else if (Array.isArray(e)) {
    e = e.slice();
    for (let B = 0; B < e.length; B++)
      e[B] |= 0;
  }
  if (!Array.isArray(e))
    return this.reporter.error("objid() should be either array or string, got: " + JSON.stringify(e));
  if (!h) {
    if (e[1] >= 40)
      return this.reporter.error("Second objid identifier OOB");
    e.splice(0, 2, e[0] * 40 + e[1]);
  }
  let o = 0;
  for (let B = 0; B < e.length; B++) {
    let M = e[B];
    for (o++; M >= 128; M >>= 7)
      o++;
  }
  const S = Ji.alloc(o);
  let g = S.length - 1;
  for (let B = e.length - 1; B >= 0; B--) {
    let M = e[B];
    for (S[g--] = M & 127; (M >>= 7) > 0; )
      S[g--] = 128 | M & 127;
  }
  return this._createEncoderBuffer(S);
};
function kr(e) {
  return e < 10 ? "0" + e : e;
}
Bi.prototype._encodeTime = function(e, t) {
  let h;
  const o = new Date(e);
  return t === "gentime" ? h = [
    kr(o.getUTCFullYear()),
    kr(o.getUTCMonth() + 1),
    kr(o.getUTCDate()),
    kr(o.getUTCHours()),
    kr(o.getUTCMinutes()),
    kr(o.getUTCSeconds()),
    "Z"
  ].join("") : t === "utctime" ? h = [
    kr(o.getUTCFullYear() % 100),
    kr(o.getUTCMonth() + 1),
    kr(o.getUTCDate()),
    kr(o.getUTCHours()),
    kr(o.getUTCMinutes()),
    kr(o.getUTCSeconds()),
    "Z"
  ].join("") : this.reporter.error("Encoding " + t + " time is not supported yet"), this._encodeStr(h, "octstr");
};
Bi.prototype._encodeNull = function() {
  return this._createEncoderBuffer("");
};
Bi.prototype._encodeInt = function(e, t) {
  if (typeof e == "string") {
    if (!t)
      return this.reporter.error("String int or enum given, but no values map");
    if (!t.hasOwnProperty(e))
      return this.reporter.error("Values map doesn't contain: " + JSON.stringify(e));
    e = t[e];
  }
  if (typeof e != "number" && !Ji.isBuffer(e)) {
    const S = e.toArray();
    !e.sign && S[0] & 128 && S.unshift(0), e = Ji.from(S);
  }
  if (Ji.isBuffer(e)) {
    let S = e.length;
    e.length === 0 && S++;
    const g = Ji.alloc(S);
    return e.copy(g), e.length === 0 && (g[0] = 0), this._createEncoderBuffer(g);
  }
  if (e < 128)
    return this._createEncoderBuffer(e);
  if (e < 256)
    return this._createEncoderBuffer([0, e]);
  let h = 1;
  for (let S = e; S >= 256; S >>= 8)
    h++;
  const o = new Array(h);
  for (let S = o.length - 1; S >= 0; S--)
    o[S] = e & 255, e >>= 8;
  return o[0] & 128 && o.unshift(0), this._createEncoderBuffer(Ji.from(o));
};
Bi.prototype._encodeBool = function(e) {
  return this._createEncoderBuffer(e ? 255 : 0);
};
Bi.prototype._use = function(e, t) {
  return typeof e == "function" && (e = e(t)), e._getEncoder("der").tree;
};
Bi.prototype._skipDefault = function(e, t, h) {
  const o = this._baseState;
  let S;
  if (o.default === null)
    return !1;
  const g = e.join();
  if (o.defaultBuffer === void 0 && (o.defaultBuffer = this._encodeValue(o.default, t, h).join()), g.length !== o.defaultBuffer.length)
    return !1;
  for (S = 0; S < g.length; S++)
    if (g[S] !== o.defaultBuffer[S])
      return !1;
  return !0;
};
function H8(e, t, h, o) {
  let S;
  if (e === "seqof" ? e = "seq" : e === "setof" && (e = "set"), Do.tagByName.hasOwnProperty(e))
    S = Do.tagByName[e];
  else if (typeof e == "number" && (e | 0) === e)
    S = e;
  else
    return o.error("Unknown tag: " + e);
  return S >= 31 ? o.error("Multi-octet tag encoding unsupported") : (t || (S |= 32), S |= Do.tagClassByName[h || "universal"] << 6, S);
}
const G8 = ut, yh = wy;
function gh(e) {
  yh.call(this, e), this.enc = "pem";
}
G8(gh, yh);
var z8 = gh;
gh.prototype.encode = function(e, t) {
  const h = yh.prototype.encode.call(this, e).toString("base64"), o = ["-----BEGIN " + t.label + "-----"];
  for (let S = 0; S < h.length; S += 64)
    o.push(h.slice(S, S + 64));
  return o.push("-----END " + t.label + "-----"), o.join(`
`);
};
(function(e) {
  const t = e;
  t.der = wy, t.pem = z8;
})(ph);
var mh = {};
const j8 = ut, W8 = rr, id = ea.DecoderBuffer, Cy = vh, nd = Af;
function Ay(e) {
  this.enc = "der", this.name = e.name, this.entity = e, this.tree = new Lr(), this.tree._init(e.body);
}
var By = Ay;
Ay.prototype.decode = function(e, t) {
  return id.isDecoderBuffer(e) || (e = new id(e, t)), this.tree._decode(e, t);
};
function Lr(e) {
  Cy.call(this, "der", e);
}
j8(Lr, Cy);
Lr.prototype._peekTag = function(e, t, h) {
  if (e.isEmpty())
    return !1;
  const o = e.save(), S = bh(e, 'Failed to peek tag: "' + t + '"');
  return e.isError(S) ? S : (e.restore(o), S.tag === t || S.tagStr === t || S.tagStr + "of" === t || h);
};
Lr.prototype._decodeTag = function(e, t, h) {
  const o = bh(
    e,
    'Failed to decode tag of "' + t + '"'
  );
  if (e.isError(o))
    return o;
  let S = Iy(
    e,
    o.primitive,
    'Failed to get length of "' + t + '"'
  );
  if (e.isError(S))
    return S;
  if (!h && o.tag !== t && o.tagStr !== t && o.tagStr + "of" !== t)
    return e.error('Failed to match tag: "' + t + '"');
  if (o.primitive || S !== null)
    return e.skip(S, 'Failed to match body of: "' + t + '"');
  const g = e.save(), B = this._skipUntilEnd(
    e,
    'Failed to skip indefinite length body: "' + this.tag + '"'
  );
  return e.isError(B) ? B : (S = e.offset - g.offset, e.restore(g), e.skip(S, 'Failed to match body of: "' + t + '"'));
};
Lr.prototype._skipUntilEnd = function(e, t) {
  for (; ; ) {
    const h = bh(e, t);
    if (e.isError(h))
      return h;
    const o = Iy(e, h.primitive, t);
    if (e.isError(o))
      return o;
    let S;
    if (h.primitive || o !== null ? S = e.skip(o) : S = this._skipUntilEnd(e, t), e.isError(S))
      return S;
    if (h.tagStr === "end")
      break;
  }
};
Lr.prototype._decodeList = function(e, t, h, o) {
  const S = [];
  for (; !e.isEmpty(); ) {
    const g = this._peekTag(e, "end");
    if (e.isError(g))
      return g;
    const B = h.decode(e, "der", o);
    if (e.isError(B) && g)
      break;
    S.push(B);
  }
  return S;
};
Lr.prototype._decodeStr = function(e, t) {
  if (t === "bitstr") {
    const h = e.readUInt8();
    return e.isError(h) ? h : { unused: h, data: e.raw() };
  } else if (t === "bmpstr") {
    const h = e.raw();
    if (h.length % 2 === 1)
      return e.error("Decoding of string type: bmpstr length mismatch");
    let o = "";
    for (let S = 0; S < h.length / 2; S++)
      o += String.fromCharCode(h.readUInt16BE(S * 2));
    return o;
  } else if (t === "numstr") {
    const h = e.raw().toString("ascii");
    return this._isNumstr(h) ? h : e.error("Decoding of string type: numstr unsupported characters");
  } else {
    if (t === "octstr" || t === "objDesc")
      return e.raw();
    if (t === "printstr") {
      const h = e.raw().toString("ascii");
      return this._isPrintstr(h) ? h : e.error("Decoding of string type: printstr unsupported characters");
    } else
      return /str$/.test(t) ? e.raw().toString() : e.error("Decoding of string type: " + t + " unsupported");
  }
};
Lr.prototype._decodeObjid = function(e, t, h) {
  let o;
  const S = [];
  let g = 0, B = 0;
  for (; !e.isEmpty(); )
    B = e.readUInt8(), g <<= 7, g |= B & 127, B & 128 || (S.push(g), g = 0);
  B & 128 && S.push(g);
  const M = S[0] / 40 | 0, O = S[0] % 40;
  if (h ? o = S : o = [M, O].concat(S.slice(1)), t) {
    let P = t[o.join(" ")];
    P === void 0 && (P = t[o.join(".")]), P !== void 0 && (o = P);
  }
  return o;
};
Lr.prototype._decodeTime = function(e, t) {
  const h = e.raw().toString();
  let o, S, g, B, M, O;
  if (t === "gentime")
    o = h.slice(0, 4) | 0, S = h.slice(4, 6) | 0, g = h.slice(6, 8) | 0, B = h.slice(8, 10) | 0, M = h.slice(10, 12) | 0, O = h.slice(12, 14) | 0;
  else if (t === "utctime")
    o = h.slice(0, 2) | 0, S = h.slice(2, 4) | 0, g = h.slice(4, 6) | 0, B = h.slice(6, 8) | 0, M = h.slice(8, 10) | 0, O = h.slice(10, 12) | 0, o < 70 ? o = 2e3 + o : o = 1900 + o;
  else
    return e.error("Decoding " + t + " time is not supported yet");
  return Date.UTC(o, S - 1, g, B, M, O, 0);
};
Lr.prototype._decodeNull = function() {
  return null;
};
Lr.prototype._decodeBool = function(e) {
  const t = e.readUInt8();
  return e.isError(t) ? t : t !== 0;
};
Lr.prototype._decodeInt = function(e, t) {
  const h = e.raw();
  let o = new W8(h);
  return t && (o = t[o.toString(10)] || o), o;
};
Lr.prototype._use = function(e, t) {
  return typeof e == "function" && (e = e(t)), e._getDecoder("der").tree;
};
function bh(e, t) {
  let h = e.readUInt8(t);
  if (e.isError(h))
    return h;
  const o = nd.tagClass[h >> 6], S = (h & 32) === 0;
  if ((h & 31) === 31) {
    let B = h;
    for (h = 0; (B & 128) === 128; ) {
      if (B = e.readUInt8(t), e.isError(B))
        return B;
      h <<= 7, h |= B & 127;
    }
  } else
    h &= 31;
  const g = nd.tag[h];
  return {
    cls: o,
    primitive: S,
    tag: h,
    tagStr: g
  };
}
function Iy(e, t, h) {
  let o = e.readUInt8(h);
  if (e.isError(o))
    return o;
  if (!t && o === 128)
    return null;
  if (!(o & 128))
    return o;
  const S = o & 127;
  if (S > 4)
    return e.error("length octect is too long");
  o = 0;
  for (let g = 0; g < S; g++) {
    o <<= 8;
    const B = e.readUInt8(h);
    if (e.isError(B))
      return B;
    o |= B;
  }
  return o;
}
const Y8 = ut, X8 = $0.Buffer, xh = By;
function _h(e) {
  xh.call(this, e), this.enc = "pem";
}
Y8(_h, xh);
var Q8 = _h;
_h.prototype.decode = function(e, t) {
  const h = e.toString().split(/[\r\n]+/g), o = t.label.toUpperCase(), S = /^-----(BEGIN|END) ([^-]+)-----$/;
  let g = -1, B = -1;
  for (let P = 0; P < h.length; P++) {
    const D = h[P].match(S);
    if (D !== null && D[2] === o)
      if (g === -1) {
        if (D[1] !== "BEGIN")
          break;
        g = P;
      } else {
        if (D[1] !== "END")
          break;
        B = P;
        break;
      }
  }
  if (g === -1 || B === -1)
    throw new Error("PEM section not found for: " + o);
  const M = h.slice(g + 1, B).join("");
  M.replace(/[^a-z0-9+/=]+/gi, "");
  const O = X8.from(M, "base64");
  return xh.prototype.decode.call(this, O, t);
};
(function(e) {
  const t = e;
  t.der = By, t.pem = Q8;
})(mh);
(function(e) {
  const t = ph, h = mh, o = ut, S = e;
  S.define = function(B, M) {
    return new g(B, M);
  };
  function g(B, M) {
    this.name = B, this.body = M, this.decoders = {}, this.encoders = {};
  }
  g.prototype._createNamed = function(B) {
    const M = this.name;
    function O(P) {
      this._initNamed(P, M);
    }
    return o(O, B), O.prototype._initNamed = function(P, D) {
      B.call(this, P, D);
    }, new O(this);
  }, g.prototype._getDecoder = function(B) {
    return B = B || "der", this.decoders.hasOwnProperty(B) || (this.decoders[B] = this._createNamed(h[B])), this.decoders[B];
  }, g.prototype.decode = function(B, M, O) {
    return this._getDecoder(M).decode(B, O);
  }, g.prototype._getEncoder = function(B) {
    return B = B || "der", this.encoders.hasOwnProperty(B) || (this.encoders[B] = this._createNamed(t[B])), this.encoders[B];
  }, g.prototype.encode = function(B, M, O) {
    return this._getEncoder(M).encode(B, O);
  };
})(xy);
var Ty = {};
(function(e) {
  const t = e;
  t.Reporter = wf.Reporter, t.DecoderBuffer = ea.DecoderBuffer, t.EncoderBuffer = ea.EncoderBuffer, t.Node = vh;
})(Ty);
var My = {};
(function(e) {
  const t = e;
  t._reverse = function(h) {
    const o = {};
    return Object.keys(h).forEach(function(S) {
      (S | 0) == S && (S = S | 0);
      const g = h[S];
      o[g] = S;
    }), o;
  }, t.der = Af;
})(My);
(function(e) {
  const t = e;
  t.bignum = rr, t.define = xy.define, t.base = Ty, t.constants = My, t.decoders = mh, t.encoders = ph;
})(dh);
var Ii = dh, ad = Ii.define("Time", function() {
  this.choice({
    utcTime: this.utctime(),
    generalTime: this.gentime()
  });
}), Z8 = Ii.define("AttributeTypeValue", function() {
  this.seq().obj(
    this.key("type").objid(),
    this.key("value").any()
  );
}), Eh = Ii.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("parameters").optional(),
    this.key("curve").objid().optional()
  );
}), J8 = Ii.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(Eh),
    this.key("subjectPublicKey").bitstr()
  );
}), e5 = Ii.define("RelativeDistinguishedName", function() {
  this.setof(Z8);
}), t5 = Ii.define("RDNSequence", function() {
  this.seqof(e5);
}), sd = Ii.define("Name", function() {
  this.choice({
    rdnSequence: this.use(t5)
  });
}), r5 = Ii.define("Validity", function() {
  this.seq().obj(
    this.key("notBefore").use(ad),
    this.key("notAfter").use(ad)
  );
}), i5 = Ii.define("Extension", function() {
  this.seq().obj(
    this.key("extnID").objid(),
    this.key("critical").bool().def(!1),
    this.key("extnValue").octstr()
  );
}), n5 = Ii.define("TBSCertificate", function() {
  this.seq().obj(
    this.key("version").explicit(0).int().optional(),
    this.key("serialNumber").int(),
    this.key("signature").use(Eh),
    this.key("issuer").use(sd),
    this.key("validity").use(r5),
    this.key("subject").use(sd),
    this.key("subjectPublicKeyInfo").use(J8),
    this.key("issuerUniqueID").implicit(1).bitstr().optional(),
    this.key("subjectUniqueID").implicit(2).bitstr().optional(),
    this.key("extensions").explicit(3).seqof(i5).optional()
  );
}), a5 = Ii.define("X509Certificate", function() {
  this.seq().obj(
    this.key("tbsCertificate").use(n5),
    this.key("signatureAlgorithm").use(Eh),
    this.key("signatureValue").bitstr()
  );
}), s5 = a5, Ti = dh;
Ai.certificate = s5;
var f5 = Ti.define("RSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("modulus").int(),
    this.key("publicExponent").int(),
    this.key("privateExponent").int(),
    this.key("prime1").int(),
    this.key("prime2").int(),
    this.key("exponent1").int(),
    this.key("exponent2").int(),
    this.key("coefficient").int()
  );
});
Ai.RSAPrivateKey = f5;
var o5 = Ti.define("RSAPublicKey", function() {
  this.seq().obj(
    this.key("modulus").int(),
    this.key("publicExponent").int()
  );
});
Ai.RSAPublicKey = o5;
var u5 = Ti.define("SubjectPublicKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").use(Ry),
    this.key("subjectPublicKey").bitstr()
  );
});
Ai.PublicKey = u5;
var Ry = Ti.define("AlgorithmIdentifier", function() {
  this.seq().obj(
    this.key("algorithm").objid(),
    this.key("none").null_().optional(),
    this.key("curve").objid().optional(),
    this.key("params").seq().obj(
      this.key("p").int(),
      this.key("q").int(),
      this.key("g").int()
    ).optional()
  );
}), c5 = Ti.define("PrivateKeyInfo", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("algorithm").use(Ry),
    this.key("subjectPrivateKey").octstr()
  );
});
Ai.PrivateKey = c5;
var h5 = Ti.define("EncryptedPrivateKeyInfo", function() {
  this.seq().obj(
    this.key("algorithm").seq().obj(
      this.key("id").objid(),
      this.key("decrypt").seq().obj(
        this.key("kde").seq().obj(
          this.key("id").objid(),
          this.key("kdeparams").seq().obj(
            this.key("salt").octstr(),
            this.key("iters").int()
          )
        ),
        this.key("cipher").seq().obj(
          this.key("algo").objid(),
          this.key("iv").octstr()
        )
      )
    ),
    this.key("subjectPrivateKey").octstr()
  );
});
Ai.EncryptedPrivateKey = h5;
var l5 = Ti.define("DSAPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("p").int(),
    this.key("q").int(),
    this.key("g").int(),
    this.key("pub_key").int(),
    this.key("priv_key").int()
  );
});
Ai.DSAPrivateKey = l5;
Ai.DSAparam = Ti.define("DSAparam", function() {
  this.int();
});
var d5 = Ti.define("ECPrivateKey", function() {
  this.seq().obj(
    this.key("version").int(),
    this.key("privateKey").octstr(),
    this.key("parameters").optional().explicit(0).use(p5),
    this.key("publicKey").optional().explicit(1).bitstr()
  );
});
Ai.ECPrivateKey = d5;
var p5 = Ti.define("ECParameters", function() {
  this.choice({
    namedCurve: this.objid()
  });
});
Ai.signature = Ti.define("signature", function() {
  this.seq().obj(
    this.key("r").int(),
    this.key("s").int()
  );
});
const v5 = {
  "2.16.840.1.101.3.4.1.1": "aes-128-ecb",
  "2.16.840.1.101.3.4.1.2": "aes-128-cbc",
  "2.16.840.1.101.3.4.1.3": "aes-128-ofb",
  "2.16.840.1.101.3.4.1.4": "aes-128-cfb",
  "2.16.840.1.101.3.4.1.21": "aes-192-ecb",
  "2.16.840.1.101.3.4.1.22": "aes-192-cbc",
  "2.16.840.1.101.3.4.1.23": "aes-192-ofb",
  "2.16.840.1.101.3.4.1.24": "aes-192-cfb",
  "2.16.840.1.101.3.4.1.41": "aes-256-ecb",
  "2.16.840.1.101.3.4.1.42": "aes-256-cbc",
  "2.16.840.1.101.3.4.1.43": "aes-256-ofb",
  "2.16.840.1.101.3.4.1.44": "aes-256-cfb"
};
var y5 = /Proc-Type: 4,ENCRYPTED[\n\r]+DEK-Info: AES-((?:128)|(?:192)|(?:256))-CBC,([0-9A-H]+)[\n\r]+([0-9A-z\n\r+/=]+)[\n\r]+/m, g5 = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----/m, m5 = /^-----BEGIN ((?:.*? KEY)|CERTIFICATE)-----([0-9A-z\n\r+/=]+)-----END \1-----$/m, b5 = lf, x5 = Dr, es = ct.Buffer, _5 = function(e, t) {
  var h = e.toString(), o = h.match(y5), S;
  if (o) {
    var g = "aes" + o[1], B = es.from(o[2], "hex"), M = es.from(o[3].replace(/[\r\n]/g, ""), "base64"), O = b5(t, B.slice(0, 8), parseInt(o[1], 10)).key, P = [], D = x5.createDecipheriv(g, O, B);
    P.push(D.update(M)), P.push(D.final()), S = es.concat(P);
  } else {
    var Z = h.match(m5);
    S = es.from(Z[2].replace(/[\r\n]/g, ""), "base64");
  }
  var Y = h.match(g5)[1];
  return {
    tag: Y,
    data: S
  };
}, Sr = Ai, E5 = v5, S5 = _5, w5 = Dr, C5 = uf, hc = ct.Buffer, Bf = Ny;
function Ny(e) {
  var t;
  typeof e == "object" && !hc.isBuffer(e) && (t = e.passphrase, e = e.key), typeof e == "string" && (e = hc.from(e));
  var h = S5(e, t), o = h.tag, S = h.data, g, B;
  switch (o) {
    case "CERTIFICATE":
      B = Sr.certificate.decode(S, "der").tbsCertificate.subjectPublicKeyInfo;
    case "PUBLIC KEY":
      switch (B || (B = Sr.PublicKey.decode(S, "der")), g = B.algorithm.algorithm.join("."), g) {
        case "1.2.840.113549.1.1.1":
          return Sr.RSAPublicKey.decode(B.subjectPublicKey.data, "der");
        case "1.2.840.10045.2.1":
          return B.subjectPrivateKey = B.subjectPublicKey, {
            type: "ec",
            data: B
          };
        case "1.2.840.10040.4.1":
          return B.algorithm.params.pub_key = Sr.DSAparam.decode(B.subjectPublicKey.data, "der"), {
            type: "dsa",
            data: B.algorithm.params
          };
        default:
          throw new Error("unknown key id " + g);
      }
    case "ENCRYPTED PRIVATE KEY":
      S = Sr.EncryptedPrivateKey.decode(S, "der"), S = A5(S, t);
    case "PRIVATE KEY":
      switch (B = Sr.PrivateKey.decode(S, "der"), g = B.algorithm.algorithm.join("."), g) {
        case "1.2.840.113549.1.1.1":
          return Sr.RSAPrivateKey.decode(B.subjectPrivateKey, "der");
        case "1.2.840.10045.2.1":
          return {
            curve: B.algorithm.curve,
            privateKey: Sr.ECPrivateKey.decode(B.subjectPrivateKey, "der").privateKey
          };
        case "1.2.840.10040.4.1":
          return B.algorithm.params.priv_key = Sr.DSAparam.decode(B.subjectPrivateKey, "der"), {
            type: "dsa",
            params: B.algorithm.params
          };
        default:
          throw new Error("unknown key id " + g);
      }
    case "RSA PUBLIC KEY":
      return Sr.RSAPublicKey.decode(S, "der");
    case "RSA PRIVATE KEY":
      return Sr.RSAPrivateKey.decode(S, "der");
    case "DSA PRIVATE KEY":
      return {
        type: "dsa",
        params: Sr.DSAPrivateKey.decode(S, "der")
      };
    case "EC PRIVATE KEY":
      return S = Sr.ECPrivateKey.decode(S, "der"), {
        curve: S.parameters.value,
        privateKey: S.privateKey
      };
    default:
      throw new Error("unknown key type " + o);
  }
}
Ny.signature = Sr.signature;
function A5(e, t) {
  var h = e.algorithm.decrypt.kde.kdeparams.salt, o = parseInt(e.algorithm.decrypt.kde.kdeparams.iters.toString(), 10), S = E5[e.algorithm.decrypt.cipher.algo.join(".")], g = e.algorithm.decrypt.cipher.iv, B = e.subjectPrivateKey, M = parseInt(S.split("-")[1], 10) / 8, O = C5.pbkdf2Sync(t, h, o, M, "sha1"), P = w5.createDecipheriv(S, O, g), D = [];
  return D.push(P.update(B)), D.push(P.final()), hc.concat(D);
}
const Dy = {
  "1.3.132.0.10": "secp256k1",
  "1.3.132.0.33": "p224",
  "1.2.840.10045.3.1.1": "p192",
  "1.2.840.10045.3.1.7": "p256",
  "1.3.132.0.34": "p384",
  "1.3.132.0.35": "p521"
};
var fd;
function B5() {
  if (fd)
    return u0.exports;
  fd = 1;
  var e = ct.Buffer, t = iv, h = sh, o = hh().ec, S = by, g = Bf, B = Dy;
  function M(fe, de, ce, be, ve) {
    var Pe = g(de);
    if (Pe.curve) {
      if (be !== "ecdsa" && be !== "ecdsa/rsa")
        throw new Error("wrong private key type");
      return O(fe, Pe);
    } else if (Pe.type === "dsa") {
      if (be !== "dsa")
        throw new Error("wrong private key type");
      return P(fe, Pe, ce);
    } else if (be !== "rsa" && be !== "ecdsa/rsa")
      throw new Error("wrong private key type");
    fe = e.concat([ve, fe]);
    for (var Ue = Pe.modulus.byteLength(), ze = [0, 1]; fe.length + ze.length + 1 < Ue; )
      ze.push(255);
    ze.push(0);
    for (var Le = -1; ++Le < fe.length; )
      ze.push(fe[Le]);
    var Ne = h(ze, Pe);
    return Ne;
  }
  function O(fe, de) {
    var ce = B[de.curve.join(".")];
    if (!ce)
      throw new Error("unknown curve " + de.curve.join("."));
    var be = new o(ce), ve = be.keyFromPrivate(de.privateKey), Pe = ve.sign(fe);
    return e.from(Pe.toDER());
  }
  function P(fe, de, ce) {
    for (var be = de.params.priv_key, ve = de.params.p, Pe = de.params.q, Ue = de.params.g, ze = new S(0), Le, Ne = Y(fe, Pe).mod(Pe), $e = !1, J = Z(be, Pe, fe, ce); $e === !1; )
      Le = ie(Pe, J, ce), ze = ue(Ue, Le, ve, Pe), $e = Le.invm(Pe).imul(Ne.add(be.mul(ze))).mod(Pe), $e.cmpn(0) === 0 && ($e = !1, ze = new S(0));
    return D(ze, $e);
  }
  function D(fe, de) {
    fe = fe.toArray(), de = de.toArray(), fe[0] & 128 && (fe = [0].concat(fe)), de[0] & 128 && (de = [0].concat(de));
    var ce = fe.length + de.length + 4, be = [48, ce, 2, fe.length];
    return be = be.concat(fe, [2, de.length], de), e.from(be);
  }
  function Z(fe, de, ce, be) {
    if (fe = e.from(fe.toArray()), fe.length < de.byteLength()) {
      var ve = e.alloc(de.byteLength() - fe.length);
      fe = e.concat([ve, fe]);
    }
    var Pe = ce.length, Ue = ee(ce, de), ze = e.alloc(Pe);
    ze.fill(1);
    var Le = e.alloc(Pe);
    return Le = t(be, Le).update(ze).update(e.from([0])).update(fe).update(Ue).digest(), ze = t(be, Le).update(ze).digest(), Le = t(be, Le).update(ze).update(e.from([1])).update(fe).update(Ue).digest(), ze = t(be, Le).update(ze).digest(), { k: Le, v: ze };
  }
  function Y(fe, de) {
    var ce = new S(fe), be = (fe.length << 3) - de.bitLength();
    return be > 0 && ce.ishrn(be), ce;
  }
  function ee(fe, de) {
    fe = Y(fe, de), fe = fe.mod(de);
    var ce = e.from(fe.toArray());
    if (ce.length < de.byteLength()) {
      var be = e.alloc(de.byteLength() - ce.length);
      ce = e.concat([be, ce]);
    }
    return ce;
  }
  function ie(fe, de, ce) {
    var be, ve;
    do {
      for (be = e.alloc(0); be.length * 8 < fe.bitLength(); )
        de.v = t(ce, de.k).update(de.v).digest(), be = e.concat([be, de.v]);
      ve = Y(be, fe), de.k = t(ce, de.k).update(de.v).update(e.from([0])).digest(), de.v = t(ce, de.k).update(de.v).digest();
    } while (ve.cmp(fe) !== -1);
    return ve;
  }
  function ue(fe, de, ce, be) {
    return fe.toRed(S.mont(ce)).redPow(de).fromRed().mod(be);
  }
  return u0.exports = M, u0.exports.getKey = Z, u0.exports.makeKey = ie, u0.exports;
}
var Oo, od;
function I5() {
  if (od)
    return Oo;
  od = 1;
  var e = ct.Buffer, t = by, h = hh().ec, o = Bf, S = Dy;
  function g(P, D, Z, Y, ee) {
    var ie = o(Z);
    if (ie.type === "ec") {
      if (Y !== "ecdsa" && Y !== "ecdsa/rsa")
        throw new Error("wrong public key type");
      return B(P, D, ie);
    } else if (ie.type === "dsa") {
      if (Y !== "dsa")
        throw new Error("wrong public key type");
      return M(P, D, ie);
    } else if (Y !== "rsa" && Y !== "ecdsa/rsa")
      throw new Error("wrong public key type");
    D = e.concat([ee, D]);
    for (var ue = ie.modulus.byteLength(), fe = [1], de = 0; D.length + fe.length + 2 < ue; )
      fe.push(255), de++;
    fe.push(0);
    for (var ce = -1; ++ce < D.length; )
      fe.push(D[ce]);
    fe = e.from(fe);
    var be = t.mont(ie.modulus);
    P = new t(P).toRed(be), P = P.redPow(new t(ie.publicExponent)), P = e.from(P.fromRed().toArray());
    var ve = de < 8 ? 1 : 0;
    for (ue = Math.min(P.length, fe.length), P.length !== fe.length && (ve = 1), ce = -1; ++ce < ue; )
      ve |= P[ce] ^ fe[ce];
    return ve === 0;
  }
  function B(P, D, Z) {
    var Y = S[Z.data.algorithm.curve.join(".")];
    if (!Y)
      throw new Error("unknown curve " + Z.data.algorithm.curve.join("."));
    var ee = new h(Y), ie = Z.data.subjectPrivateKey.data;
    return ee.verify(D, P, ie);
  }
  function M(P, D, Z) {
    var Y = Z.data.p, ee = Z.data.q, ie = Z.data.g, ue = Z.data.pub_key, fe = o.signature.decode(P, "der"), de = fe.s, ce = fe.r;
    O(de, ee), O(ce, ee);
    var be = t.mont(Y), ve = de.invm(ee), Pe = ie.toRed(be).redPow(new t(D).mul(ve).mod(ee)).fromRed().mul(ue.toRed(be).redPow(ce.mul(ve).mod(ee)).fromRed()).mod(Y).mod(ee);
    return Pe.cmp(ce) === 0;
  }
  function O(P, D) {
    if (P.cmpn(0) <= 0)
      throw new Error("invalid sig");
    if (P.cmp(D) >= D)
      throw new Error("invalid sig");
  }
  return Oo = g, Oo;
}
var Po, ud;
function T5() {
  if (ud)
    return Po;
  ud = 1;
  var e = ct.Buffer, t = P0, h = U1, o = ut, S = B5(), g = I5(), B = nv;
  Object.keys(B).forEach(function(Z) {
    B[Z].id = e.from(B[Z].id, "hex"), B[Z.toLowerCase()] = B[Z];
  });
  function M(Z) {
    h.Writable.call(this);
    var Y = B[Z];
    if (!Y)
      throw new Error("Unknown message digest");
    this._hashType = Y.hash, this._hash = t(Y.hash), this._tag = Y.id, this._signType = Y.sign;
  }
  o(M, h.Writable), M.prototype._write = function(Z, Y, ee) {
    this._hash.update(Z), ee();
  }, M.prototype.update = function(Z, Y) {
    return typeof Z == "string" && (Z = e.from(Z, Y)), this._hash.update(Z), this;
  }, M.prototype.sign = function(Z, Y) {
    this.end();
    var ee = this._hash.digest(), ie = S(ee, Z, this._hashType, this._signType, this._tag);
    return Y ? ie.toString(Y) : ie;
  };
  function O(Z) {
    h.Writable.call(this);
    var Y = B[Z];
    if (!Y)
      throw new Error("Unknown message digest");
    this._hash = t(Y.hash), this._tag = Y.id, this._signType = Y.sign;
  }
  o(O, h.Writable), O.prototype._write = function(Z, Y, ee) {
    this._hash.update(Z), ee();
  }, O.prototype.update = function(Z, Y) {
    return typeof Z == "string" && (Z = e.from(Z, Y)), this._hash.update(Z), this;
  }, O.prototype.verify = function(Z, Y, ee) {
    typeof Y == "string" && (Y = e.from(Y, ee)), this.end();
    var ie = this._hash.digest();
    return g(Y, ie, Z, this._signType, this._tag);
  };
  function P(Z) {
    return new M(Z);
  }
  function D(Z) {
    return new O(Z);
  }
  return Po = {
    Sign: P,
    Verify: D,
    createSign: P,
    createVerify: D
  }, Po;
}
var Lo, cd;
function M5() {
  if (cd)
    return Lo;
  cd = 1;
  var e = hh(), t = rr;
  Lo = function(g) {
    return new o(g);
  };
  var h = {
    secp256k1: {
      name: "secp256k1",
      byteLength: 32
    },
    secp224r1: {
      name: "p224",
      byteLength: 28
    },
    prime256v1: {
      name: "p256",
      byteLength: 32
    },
    prime192v1: {
      name: "p192",
      byteLength: 24
    },
    ed25519: {
      name: "ed25519",
      byteLength: 32
    },
    secp384r1: {
      name: "p384",
      byteLength: 48
    },
    secp521r1: {
      name: "p521",
      byteLength: 66
    }
  };
  h.p224 = h.secp224r1, h.p256 = h.secp256r1 = h.prime256v1, h.p192 = h.secp192r1 = h.prime192v1, h.p384 = h.secp384r1, h.p521 = h.secp521r1;
  function o(g) {
    this.curveType = h[g], this.curveType || (this.curveType = {
      name: g
    }), this.curve = new e.ec(this.curveType.name), this.keys = void 0;
  }
  o.prototype.generateKeys = function(g, B) {
    return this.keys = this.curve.genKeyPair(), this.getPublicKey(g, B);
  }, o.prototype.computeSecret = function(g, B, M) {
    B = B || "utf8", pe.Buffer.isBuffer(g) || (g = new pe.Buffer(g, B));
    var O = this.curve.keyFromPublic(g).getPublic(), P = O.mul(this.keys.getPrivate()).getX();
    return S(P, M, this.curveType.byteLength);
  }, o.prototype.getPublicKey = function(g, B) {
    var M = this.keys.getPublic(B === "compressed", !0);
    return B === "hybrid" && (M[M.length - 1] % 2 ? M[0] = 7 : M[0] = 6), S(M, g);
  }, o.prototype.getPrivateKey = function(g) {
    return S(this.keys.getPrivate(), g);
  }, o.prototype.setPublicKey = function(g, B) {
    return B = B || "utf8", pe.Buffer.isBuffer(g) || (g = new pe.Buffer(g, B)), this.keys._importPublic(g), this;
  }, o.prototype.setPrivateKey = function(g, B) {
    B = B || "utf8", pe.Buffer.isBuffer(g) || (g = new pe.Buffer(g, B));
    var M = new t(g);
    return M = M.toString(16), this.keys = this.curve.genKeyPair(), this.keys._importPrivate(M), this;
  };
  function S(g, B, M) {
    Array.isArray(g) || (g = g.toArray());
    var O = new pe.Buffer(g);
    if (M && O.length < M) {
      var P = new pe.Buffer(M - O.length);
      P.fill(0), O = pe.Buffer.concat([P, O]);
    }
    return B ? O.toString(B) : O;
  }
  return Lo;
}
var Oy = {}, R5 = P0, lc = ct.Buffer, Py = function(e, t) {
  for (var h = lc.alloc(0), o = 0, S; h.length < t; )
    S = N5(o++), h = lc.concat([h, R5("sha1").update(e).update(S).digest()]);
  return h.slice(0, t);
};
function N5(e) {
  var t = lc.allocUnsafe(4);
  return t.writeUInt32BE(e, 0), t;
}
var Ly = function(e, t) {
  for (var h = e.length, o = -1; ++o < h; )
    e[o] ^= t[o];
  return e;
}, hd = rr, D5 = ct.Buffer;
function O5(e, t) {
  return D5.from(e.toRed(hd.mont(t.modulus)).redPow(new hd(t.publicExponent)).fromRed().toArray());
}
var ky = O5, P5 = Bf, dc = Ua, L5 = P0, ld = Py, dd = Ly, Sh = rr, k5 = ky, U5 = sh, _i = ct.Buffer, F5 = function(e, t, h) {
  var o;
  e.padding ? o = e.padding : h ? o = 1 : o = 4;
  var S = P5(e), g;
  if (o === 4)
    g = q5(S, t);
  else if (o === 1)
    g = V5(S, t, h);
  else if (o === 3) {
    if (g = new Sh(t), g.cmp(S.modulus) >= 0)
      throw new Error("data too long for modulus");
  } else
    throw new Error("unknown padding");
  return h ? U5(g, S) : k5(g, S);
};
function q5(e, t) {
  var h = e.modulus.byteLength(), o = t.length, S = L5("sha1").update(_i.alloc(0)).digest(), g = S.length, B = 2 * g;
  if (o > h - B - 2)
    throw new Error("message too long");
  var M = _i.alloc(h - o - B - 2), O = h - g - 1, P = dc(g), D = dd(_i.concat([S, M, _i.alloc(1, 1), t], O), ld(P, O)), Z = dd(P, ld(D, g));
  return new Sh(_i.concat([_i.alloc(1), Z, D], h));
}
function V5(e, t, h) {
  var o = t.length, S = e.modulus.byteLength();
  if (o > S - 11)
    throw new Error("message too long");
  var g;
  return h ? g = _i.alloc(S - o - 3, 255) : g = K5(S - o - 3), new Sh(_i.concat([_i.from([0, h ? 1 : 2]), g, _i.alloc(1), t], S));
}
function K5(e) {
  for (var t = _i.allocUnsafe(e), h = 0, o = dc(e * 2), S = 0, g; h < e; )
    S === o.length && (o = dc(e * 2), S = 0), g = o[S++], g && (t[h++] = g);
  return t;
}
var $5 = Bf, pd = Py, vd = Ly, yd = rr, H5 = sh, G5 = P0, z5 = ky, I0 = ct.Buffer, j5 = function(e, t, h) {
  var o;
  e.padding ? o = e.padding : h ? o = 1 : o = 4;
  var S = $5(e), g = S.modulus.byteLength();
  if (t.length > g || new yd(t).cmp(S.modulus) >= 0)
    throw new Error("decryption error");
  var B;
  h ? B = z5(new yd(t), S) : B = H5(t, S);
  var M = I0.alloc(g - B.length);
  if (B = I0.concat([M, B], g), o === 4)
    return W5(S, B);
  if (o === 1)
    return Y5(S, B, h);
  if (o === 3)
    return B;
  throw new Error("unknown padding");
};
function W5(e, t) {
  var h = e.modulus.byteLength(), o = G5("sha1").update(I0.alloc(0)).digest(), S = o.length;
  if (t[0] !== 0)
    throw new Error("decryption error");
  var g = t.slice(1, S + 1), B = t.slice(S + 1), M = vd(g, pd(B, S)), O = vd(B, pd(M, h - S - 1));
  if (X5(o, O.slice(0, S)))
    throw new Error("decryption error");
  for (var P = S; O[P] === 0; )
    P++;
  if (O[P++] !== 1)
    throw new Error("decryption error");
  return O.slice(P);
}
function Y5(e, t, h) {
  for (var o = t.slice(0, 2), S = 2, g = 0; t[S++] !== 0; )
    if (S >= t.length) {
      g++;
      break;
    }
  var B = t.slice(2, S - 1);
  if ((o.toString("hex") !== "0002" && !h || o.toString("hex") !== "0001" && h) && g++, B.length < 8 && g++, g)
    throw new Error("decryption error");
  return t.slice(S);
}
function X5(e, t) {
  e = I0.from(e), t = I0.from(t);
  var h = 0, o = e.length;
  e.length !== t.length && (h++, o = Math.min(e.length, t.length));
  for (var S = -1; ++S < o; )
    h += e[S] ^ t[S];
  return h;
}
(function(e) {
  e.publicEncrypt = F5, e.privateDecrypt = j5, e.privateEncrypt = function(t, h) {
    return e.publicEncrypt(t, h, !0);
  }, e.publicDecrypt = function(t, h) {
    return e.privateDecrypt(t, h, !0);
  };
})(Oy);
var m0 = {};
function gd() {
  throw new Error(`secure random number generation not supported by this browser
use chrome, FireFox or Internet Explorer 11`);
}
var Uy = ct, md = Ua, Fy = Uy.Buffer, qy = Uy.kMaxLength, pc = Me.crypto || Me.msCrypto, Vy = Math.pow(2, 32) - 1;
function Ky(e, t) {
  if (typeof e != "number" || e !== e)
    throw new TypeError("offset must be a number");
  if (e > Vy || e < 0)
    throw new TypeError("offset must be a uint32");
  if (e > qy || e > t)
    throw new RangeError("offset out of range");
}
function $y(e, t, h) {
  if (typeof e != "number" || e !== e)
    throw new TypeError("size must be a number");
  if (e > Vy || e < 0)
    throw new TypeError("size must be a uint32");
  if (e + t > h || e > qy)
    throw new RangeError("buffer too small");
}
pc && pc.getRandomValues || !Ve.browser ? (m0.randomFill = Q5, m0.randomFillSync = Z5) : (m0.randomFill = gd, m0.randomFillSync = gd);
function Q5(e, t, h, o) {
  if (!Fy.isBuffer(e) && !(e instanceof Me.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  if (typeof t == "function")
    o = t, t = 0, h = e.length;
  else if (typeof h == "function")
    o = h, h = e.length - t;
  else if (typeof o != "function")
    throw new TypeError('"cb" argument must be a function');
  return Ky(t, e.length), $y(h, t, e.length), Hy(e, t, h, o);
}
function Hy(e, t, h, o) {
  if (Ve.browser) {
    var S = e.buffer, g = new Uint8Array(S, t, h);
    if (pc.getRandomValues(g), o) {
      Ve.nextTick(function() {
        o(null, e);
      });
      return;
    }
    return e;
  }
  if (o) {
    md(h, function(M, O) {
      if (M)
        return o(M);
      O.copy(e, t), o(null, e);
    });
    return;
  }
  var B = md(h);
  return B.copy(e, t), e;
}
function Z5(e, t, h) {
  if (typeof t > "u" && (t = 0), !Fy.isBuffer(e) && !(e instanceof Me.Uint8Array))
    throw new TypeError('"buf" argument must be a Buffer or Uint8Array');
  return Ky(t, e.length), h === void 0 && (h = e.length - t), $y(h, t, e.length), Hy(e, t, h);
}
var bd;
function _r() {
  if (bd)
    return st;
  bd = 1, st.randomBytes = st.rng = st.pseudoRandomBytes = st.prng = Ua, st.createHash = st.Hash = P0, st.createHmac = st.Hmac = iv;
  var e = Ux, t = Object.keys(e), h = ["sha1", "sha224", "sha256", "sha384", "sha512", "md5", "rmd160"].concat(t);
  st.getHashes = function() {
    return h;
  };
  var o = uf;
  st.pbkdf2 = o.pbkdf2, st.pbkdf2Sync = o.pbkdf2Sync;
  var S = Si;
  st.Cipher = S.Cipher, st.createCipher = S.createCipher, st.Cipheriv = S.Cipheriv, st.createCipheriv = S.createCipheriv, st.Decipher = S.Decipher, st.createDecipher = S.createDecipher, st.Decipheriv = S.Decipheriv, st.createDecipheriv = S.createDecipheriv, st.getCiphers = S.getCiphers, st.listCiphers = S.listCiphers;
  var g = y3();
  st.DiffieHellmanGroup = g.DiffieHellmanGroup, st.createDiffieHellmanGroup = g.createDiffieHellmanGroup, st.getDiffieHellman = g.getDiffieHellman, st.createDiffieHellman = g.createDiffieHellman, st.DiffieHellman = g.DiffieHellman;
  var B = T5();
  st.createSign = B.createSign, st.Sign = B.Sign, st.createVerify = B.createVerify, st.Verify = B.Verify, st.createECDH = M5();
  var M = Oy;
  st.publicEncrypt = M.publicEncrypt, st.privateEncrypt = M.privateEncrypt, st.publicDecrypt = M.publicDecrypt, st.privateDecrypt = M.privateDecrypt;
  var O = m0;
  return st.randomFill = O.randomFill, st.randomFillSync = O.randomFillSync, st.createCredentials = function() {
    throw new Error([
      "sorry, createCredentials is not implemented yet",
      "we accept pull requests",
      "https://github.com/crypto-browserify/crypto-browserify"
    ].join(`
`));
  }, st.constants = {
    DH_CHECK_P_NOT_SAFE_PRIME: 2,
    DH_CHECK_P_NOT_PRIME: 1,
    DH_UNABLE_TO_CHECK_GENERATOR: 4,
    DH_NOT_SUITABLE_GENERATOR: 8,
    NPN_ENABLED: 1,
    ALPN_ENABLED: 1,
    RSA_PKCS1_PADDING: 1,
    RSA_SSLV23_PADDING: 2,
    RSA_NO_PADDING: 3,
    RSA_PKCS1_OAEP_PADDING: 4,
    RSA_X931_PADDING: 5,
    RSA_PKCS1_PSS_PADDING: 6,
    POINT_CONVERSION_COMPRESSED: 2,
    POINT_CONVERSION_UNCOMPRESSED: 4,
    POINT_CONVERSION_HYBRID: 6
  }, st;
}
var xd;
function xt() {
  return xd || (xd = 1, function(e, t) {
    (function(h, o) {
      e.exports = o();
    })(Me, function() {
      var h = h || function(o, S) {
        var g;
        if (typeof window < "u" && window.crypto && (g = window.crypto), typeof self < "u" && self.crypto && (g = self.crypto), typeof globalThis < "u" && globalThis.crypto && (g = globalThis.crypto), !g && typeof window < "u" && window.msCrypto && (g = window.msCrypto), !g && typeof Me < "u" && Me.crypto && (g = Me.crypto), !g && typeof bg == "function")
          try {
            g = _r();
          } catch {
          }
        var B = function() {
          if (g) {
            if (typeof g.getRandomValues == "function")
              try {
                return g.getRandomValues(new Uint32Array(1))[0];
              } catch {
              }
            if (typeof g.randomBytes == "function")
              try {
                return g.randomBytes(4).readInt32LE();
              } catch {
              }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        }, M = Object.create || /* @__PURE__ */ function() {
          function ce() {
          }
          return function(be) {
            var ve;
            return ce.prototype = be, ve = new ce(), ce.prototype = null, ve;
          };
        }(), O = {}, P = O.lib = {}, D = P.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(ce) {
              var be = M(this);
              return ce && be.mixIn(ce), (!be.hasOwnProperty("init") || this.init === be.init) && (be.init = function() {
                be.$super.init.apply(this, arguments);
              }), be.init.prototype = be, be.$super = this, be;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var ce = this.extend();
              return ce.init.apply(ce, arguments), ce;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(ce) {
              for (var be in ce)
                ce.hasOwnProperty(be) && (this[be] = ce[be]);
              ce.hasOwnProperty("toString") && (this.toString = ce.toString);
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }(), Z = P.WordArray = D.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(ce, be) {
            ce = this.words = ce || [], be != S ? this.sigBytes = be : this.sigBytes = ce.length * 4;
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(ce) {
            return (ce || ee).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(ce) {
            var be = this.words, ve = ce.words, Pe = this.sigBytes, Ue = ce.sigBytes;
            if (this.clamp(), Pe % 4)
              for (var ze = 0; ze < Ue; ze++) {
                var Le = ve[ze >>> 2] >>> 24 - ze % 4 * 8 & 255;
                be[Pe + ze >>> 2] |= Le << 24 - (Pe + ze) % 4 * 8;
              }
            else
              for (var Ne = 0; Ne < Ue; Ne += 4)
                be[Pe + Ne >>> 2] = ve[Ne >>> 2];
            return this.sigBytes += Ue, this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var ce = this.words, be = this.sigBytes;
            ce[be >>> 2] &= 4294967295 << 32 - be % 4 * 8, ce.length = o.ceil(be / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var ce = D.clone.call(this);
            return ce.words = this.words.slice(0), ce;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(ce) {
            for (var be = [], ve = 0; ve < ce; ve += 4)
              be.push(B());
            return new Z.init(be, ce);
          }
        }), Y = O.enc = {}, ee = Y.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(ce) {
            for (var be = ce.words, ve = ce.sigBytes, Pe = [], Ue = 0; Ue < ve; Ue++) {
              var ze = be[Ue >>> 2] >>> 24 - Ue % 4 * 8 & 255;
              Pe.push((ze >>> 4).toString(16)), Pe.push((ze & 15).toString(16));
            }
            return Pe.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(ce) {
            for (var be = ce.length, ve = [], Pe = 0; Pe < be; Pe += 2)
              ve[Pe >>> 3] |= parseInt(ce.substr(Pe, 2), 16) << 24 - Pe % 8 * 4;
            return new Z.init(ve, be / 2);
          }
        }, ie = Y.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(ce) {
            for (var be = ce.words, ve = ce.sigBytes, Pe = [], Ue = 0; Ue < ve; Ue++) {
              var ze = be[Ue >>> 2] >>> 24 - Ue % 4 * 8 & 255;
              Pe.push(String.fromCharCode(ze));
            }
            return Pe.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(ce) {
            for (var be = ce.length, ve = [], Pe = 0; Pe < be; Pe++)
              ve[Pe >>> 2] |= (ce.charCodeAt(Pe) & 255) << 24 - Pe % 4 * 8;
            return new Z.init(ve, be);
          }
        }, ue = Y.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(ce) {
            try {
              return decodeURIComponent(escape(ie.stringify(ce)));
            } catch {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(ce) {
            return ie.parse(unescape(encodeURIComponent(ce)));
          }
        }, fe = P.BufferedBlockAlgorithm = D.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new Z.init(), this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(ce) {
            typeof ce == "string" && (ce = ue.parse(ce)), this._data.concat(ce), this._nDataBytes += ce.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(ce) {
            var be, ve = this._data, Pe = ve.words, Ue = ve.sigBytes, ze = this.blockSize, Le = ze * 4, Ne = Ue / Le;
            ce ? Ne = o.ceil(Ne) : Ne = o.max((Ne | 0) - this._minBufferSize, 0);
            var $e = Ne * ze, J = o.min($e * 4, Ue);
            if ($e) {
              for (var ne = 0; ne < $e; ne += ze)
                this._doProcessBlock(Pe, ne);
              be = Pe.splice(0, $e), ve.sigBytes -= J;
            }
            return new Z.init(be, J);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var ce = D.clone.call(this);
            return ce._data = this._data.clone(), ce;
          },
          _minBufferSize: 0
        });
        P.Hasher = fe.extend({
          /**
           * Configuration options.
           */
          cfg: D.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(ce) {
            this.cfg = this.cfg.extend(ce), this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            fe.reset.call(this), this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(ce) {
            return this._append(ce), this._process(), this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(ce) {
            ce && this._append(ce);
            var be = this._doFinalize();
            return be;
          },
          blockSize: 16,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(ce) {
            return function(be, ve) {
              return new ce.init(ve).finalize(be);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(ce) {
            return function(be, ve) {
              return new de.HMAC.init(ce, ve).finalize(be);
            };
          }
        });
        var de = O.algo = {};
        return O;
      }(Math);
      return h;
    });
  }(zf)), zf.exports;
}
var ko = { exports: {} }, _d;
function If() {
  return _d || (_d = 1, function(e, t) {
    (function(h, o) {
      e.exports = o(xt());
    })(Me, function(h) {
      return function(o) {
        var S = h, g = S.lib, B = g.Base, M = g.WordArray, O = S.x64 = {};
        O.Word = B.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(P, D) {
            this.high = P, this.low = D;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        }), O.WordArray = B.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(P, D) {
            P = this.words = P || [], D != o ? this.sigBytes = D : this.sigBytes = P.length * 8;
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            for (var P = this.words, D = P.length, Z = [], Y = 0; Y < D; Y++) {
              var ee = P[Y];
              Z.push(ee.high), Z.push(ee.low);
            }
            return M.create(Z, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            for (var P = B.clone.call(this), D = P.words = this.words.slice(0), Z = D.length, Y = 0; Y < Z; Y++)
              D[Y] = D[Y].clone();
            return P;
          }
        });
      }(), h;
    });
  }(ko)), ko.exports;
}
var Uo = { exports: {} }, Ed;
function J5() {
  return Ed || (Ed = 1, function(e, t) {
    (function(h, o) {
      e.exports = o(xt());
    })(Me, function(h) {
      return function() {
        if (typeof ArrayBuffer == "function") {
          var o = h, S = o.lib, g = S.WordArray, B = g.init, M = g.init = function(O) {
            if (O instanceof ArrayBuffer && (O = new Uint8Array(O)), (O instanceof Int8Array || typeof Uint8ClampedArray < "u" && O instanceof Uint8ClampedArray || O instanceof Int16Array || O instanceof Uint16Array || O instanceof Int32Array || O instanceof Uint32Array || O instanceof Float32Array || O instanceof Float64Array) && (O = new Uint8Array(O.buffer, O.byteOffset, O.byteLength)), O instanceof Uint8Array) {
              for (var P = O.byteLength, D = [], Z = 0; Z < P; Z++)
                D[Z >>> 2] |= O[Z] << 24 - Z % 4 * 8;
              B.call(this, D, P);
            } else
              B.apply(this, arguments);
          };
          M.prototype = g;
        }
      }(), h.lib.WordArray;
    });
  }(Uo)), Uo.exports;
}
var Fo = { exports: {} }, Sd;
function e_() {
  return Sd || (Sd = 1, function(e, t) {
    (function(h, o) {
      e.exports = o(xt());
    })(Me, function(h) {
      return function() {
        var o = h, S = o.lib, g = S.WordArray, B = o.enc;
        B.Utf16 = B.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: function(O) {
            for (var P = O.words, D = O.sigBytes, Z = [], Y = 0; Y < D; Y += 2) {
              var ee = P[Y >>> 2] >>> 16 - Y % 4 * 8 & 65535;
              Z.push(String.fromCharCode(ee));
            }
            return Z.join("");
          },
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: function(O) {
            for (var P = O.length, D = [], Z = 0; Z < P; Z++)
              D[Z >>> 1] |= O.charCodeAt(Z) << 16 - Z % 2 * 16;
            return g.create(D, P * 2);
          }
        }, B.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: function(O) {
            for (var P = O.words, D = O.sigBytes, Z = [], Y = 0; Y < D; Y += 2) {
              var ee = M(P[Y >>> 2] >>> 16 - Y % 4 * 8 & 65535);
              Z.push(String.fromCharCode(ee));
            }
            return Z.join("");
          },
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: function(O) {
            for (var P = O.length, D = [], Z = 0; Z < P; Z++)
              D[Z >>> 1] |= M(O.charCodeAt(Z) << 16 - Z % 2 * 16);
            return g.create(D, P * 2);
          }
        };
        function M(O) {
          return O << 8 & 4278255360 | O >>> 8 & 16711935;
        }
      }(), h.enc.Utf16;
    });
  }(Fo)), Fo.exports;
}
var qo = { exports: {} }, wd;
function ja() {
  return wd || (wd = 1, function(e, t) {
    (function(h, o) {
      e.exports = o(xt());
    })(Me, function(h) {
      return function() {
        var o = h, S = o.lib, g = S.WordArray, B = o.enc;
        B.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(O) {
            var P = O.words, D = O.sigBytes, Z = this._map;
            O.clamp();
            for (var Y = [], ee = 0; ee < D; ee += 3)
              for (var ie = P[ee >>> 2] >>> 24 - ee % 4 * 8 & 255, ue = P[ee + 1 >>> 2] >>> 24 - (ee + 1) % 4 * 8 & 255, fe = P[ee + 2 >>> 2] >>> 24 - (ee + 2) % 4 * 8 & 255, de = ie << 16 | ue << 8 | fe, ce = 0; ce < 4 && ee + ce * 0.75 < D; ce++)
                Y.push(Z.charAt(de >>> 6 * (3 - ce) & 63));
            var be = Z.charAt(64);
            if (be)
              for (; Y.length % 4; )
                Y.push(be);
            return Y.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(O) {
            var P = O.length, D = this._map, Z = this._reverseMap;
            if (!Z) {
              Z = this._reverseMap = [];
              for (var Y = 0; Y < D.length; Y++)
                Z[D.charCodeAt(Y)] = Y;
            }
            var ee = D.charAt(64);
            if (ee) {
              var ie = O.indexOf(ee);
              ie !== -1 && (P = ie);
            }
            return M(O, P, Z);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function M(O, P, D) {
          for (var Z = [], Y = 0, ee = 0; ee < P; ee++)
            if (ee % 4) {
              var ie = D[O.charCodeAt(ee - 1)] << ee % 4 * 2, ue = D[O.charCodeAt(ee)] >>> 6 - ee % 4 * 2, fe = ie | ue;
              Z[Y >>> 2] |= fe << 24 - Y % 4 * 8, Y++;
            }
          return g.create(Z, Y);
        }
      }(), h.enc.Base64;
    });
  }(qo)), qo.exports;
}
var Vo = { exports: {} }, Cd;
function t_() {
  return Cd || (Cd = 1, function(e, t) {
    (function(h, o) {
      e.exports = o(xt());
    })(Me, function(h) {
      return function() {
        var o = h, S = o.lib, g = S.WordArray, B = o.enc;
        B.Base64url = {
          /**
           * Converts a word array to a Base64url string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {string} The Base64url string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
           */
          stringify: function(O, P = !0) {
            var D = O.words, Z = O.sigBytes, Y = P ? this._safe_map : this._map;
            O.clamp();
            for (var ee = [], ie = 0; ie < Z; ie += 3)
              for (var ue = D[ie >>> 2] >>> 24 - ie % 4 * 8 & 255, fe = D[ie + 1 >>> 2] >>> 24 - (ie + 1) % 4 * 8 & 255, de = D[ie + 2 >>> 2] >>> 24 - (ie + 2) % 4 * 8 & 255, ce = ue << 16 | fe << 8 | de, be = 0; be < 4 && ie + be * 0.75 < Z; be++)
                ee.push(Y.charAt(ce >>> 6 * (3 - be) & 63));
            var ve = Y.charAt(64);
            if (ve)
              for (; ee.length % 4; )
                ee.push(ve);
            return ee.join("");
          },
          /**
           * Converts a Base64url string to a word array.
           *
           * @param {string} base64Str The Base64url string.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
           */
          parse: function(O, P = !0) {
            var D = O.length, Z = P ? this._safe_map : this._map, Y = this._reverseMap;
            if (!Y) {
              Y = this._reverseMap = [];
              for (var ee = 0; ee < Z.length; ee++)
                Y[Z.charCodeAt(ee)] = ee;
            }
            var ie = Z.charAt(64);
            if (ie) {
              var ue = O.indexOf(ie);
              ue !== -1 && (D = ue);
            }
            return M(O, D, Y);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function M(O, P, D) {
          for (var Z = [], Y = 0, ee = 0; ee < P; ee++)
            if (ee % 4) {
              var ie = D[O.charCodeAt(ee - 1)] << ee % 4 * 2, ue = D[O.charCodeAt(ee)] >>> 6 - ee % 4 * 2, fe = ie | ue;
              Z[Y >>> 2] |= fe << 24 - Y % 4 * 8, Y++;
            }
          return g.create(Z, Y);
        }
      }(), h.enc.Base64url;
    });
  }(Vo)), Vo.exports;
}
var Ko = { exports: {} }, Ad;
function Wa() {
  return Ad || (Ad = 1, function(e, t) {
    (function(h, o) {
      e.exports = o(xt());
    })(Me, function(h) {
      return function(o) {
        var S = h, g = S.lib, B = g.WordArray, M = g.Hasher, O = S.algo, P = [];
        (function() {
          for (var ue = 0; ue < 64; ue++)
            P[ue] = o.abs(o.sin(ue + 1)) * 4294967296 | 0;
        })();
        var D = O.MD5 = M.extend({
          _doReset: function() {
            this._hash = new B.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(ue, fe) {
            for (var de = 0; de < 16; de++) {
              var ce = fe + de, be = ue[ce];
              ue[ce] = (be << 8 | be >>> 24) & 16711935 | (be << 24 | be >>> 8) & 4278255360;
            }
            var ve = this._hash.words, Pe = ue[fe + 0], Ue = ue[fe + 1], ze = ue[fe + 2], Le = ue[fe + 3], Ne = ue[fe + 4], $e = ue[fe + 5], J = ue[fe + 6], ne = ue[fe + 7], A = ue[fe + 8], I = ue[fe + 9], U = ue[fe + 10], X = ue[fe + 11], Q = ue[fe + 12], F = ue[fe + 13], $ = ue[fe + 14], H = ue[fe + 15], q = ve[0], z = ve[1], me = ve[2], Ce = ve[3];
            q = Z(q, z, me, Ce, Pe, 7, P[0]), Ce = Z(Ce, q, z, me, Ue, 12, P[1]), me = Z(me, Ce, q, z, ze, 17, P[2]), z = Z(z, me, Ce, q, Le, 22, P[3]), q = Z(q, z, me, Ce, Ne, 7, P[4]), Ce = Z(Ce, q, z, me, $e, 12, P[5]), me = Z(me, Ce, q, z, J, 17, P[6]), z = Z(z, me, Ce, q, ne, 22, P[7]), q = Z(q, z, me, Ce, A, 7, P[8]), Ce = Z(Ce, q, z, me, I, 12, P[9]), me = Z(me, Ce, q, z, U, 17, P[10]), z = Z(z, me, Ce, q, X, 22, P[11]), q = Z(q, z, me, Ce, Q, 7, P[12]), Ce = Z(Ce, q, z, me, F, 12, P[13]), me = Z(me, Ce, q, z, $, 17, P[14]), z = Z(z, me, Ce, q, H, 22, P[15]), q = Y(q, z, me, Ce, Ue, 5, P[16]), Ce = Y(Ce, q, z, me, J, 9, P[17]), me = Y(me, Ce, q, z, X, 14, P[18]), z = Y(z, me, Ce, q, Pe, 20, P[19]), q = Y(q, z, me, Ce, $e, 5, P[20]), Ce = Y(Ce, q, z, me, U, 9, P[21]), me = Y(me, Ce, q, z, H, 14, P[22]), z = Y(z, me, Ce, q, Ne, 20, P[23]), q = Y(q, z, me, Ce, I, 5, P[24]), Ce = Y(Ce, q, z, me, $, 9, P[25]), me = Y(me, Ce, q, z, Le, 14, P[26]), z = Y(z, me, Ce, q, A, 20, P[27]), q = Y(q, z, me, Ce, F, 5, P[28]), Ce = Y(Ce, q, z, me, ze, 9, P[29]), me = Y(me, Ce, q, z, ne, 14, P[30]), z = Y(z, me, Ce, q, Q, 20, P[31]), q = ee(q, z, me, Ce, $e, 4, P[32]), Ce = ee(Ce, q, z, me, A, 11, P[33]), me = ee(me, Ce, q, z, X, 16, P[34]), z = ee(z, me, Ce, q, $, 23, P[35]), q = ee(q, z, me, Ce, Ue, 4, P[36]), Ce = ee(Ce, q, z, me, Ne, 11, P[37]), me = ee(me, Ce, q, z, ne, 16, P[38]), z = ee(z, me, Ce, q, U, 23, P[39]), q = ee(q, z, me, Ce, F, 4, P[40]), Ce = ee(Ce, q, z, me, Pe, 11, P[41]), me = ee(me, Ce, q, z, Le, 16, P[42]), z = ee(z, me, Ce, q, J, 23, P[43]), q = ee(q, z, me, Ce, I, 4, P[44]), Ce = ee(Ce, q, z, me, Q, 11, P[45]), me = ee(me, Ce, q, z, H, 16, P[46]), z = ee(z, me, Ce, q, ze, 23, P[47]), q = ie(q, z, me, Ce, Pe, 6, P[48]), Ce = ie(Ce, q, z, me, ne, 10, P[49]), me = ie(me, Ce, q, z, $, 15, P[50]), z = ie(z, me, Ce, q, $e, 21, P[51]), q = ie(q, z, me, Ce, Q, 6, P[52]), Ce = ie(Ce, q, z, me, Le, 10, P[53]), me = ie(me, Ce, q, z, U, 15, P[54]), z = ie(z, me, Ce, q, Ue, 21, P[55]), q = ie(q, z, me, Ce, A, 6, P[56]), Ce = ie(Ce, q, z, me, H, 10, P[57]), me = ie(me, Ce, q, z, J, 15, P[58]), z = ie(z, me, Ce, q, F, 21, P[59]), q = ie(q, z, me, Ce, Ne, 6, P[60]), Ce = ie(Ce, q, z, me, X, 10, P[61]), me = ie(me, Ce, q, z, ze, 15, P[62]), z = ie(z, me, Ce, q, I, 21, P[63]), ve[0] = ve[0] + q | 0, ve[1] = ve[1] + z | 0, ve[2] = ve[2] + me | 0, ve[3] = ve[3] + Ce | 0;
          },
          _doFinalize: function() {
            var ue = this._data, fe = ue.words, de = this._nDataBytes * 8, ce = ue.sigBytes * 8;
            fe[ce >>> 5] |= 128 << 24 - ce % 32;
            var be = o.floor(de / 4294967296), ve = de;
            fe[(ce + 64 >>> 9 << 4) + 15] = (be << 8 | be >>> 24) & 16711935 | (be << 24 | be >>> 8) & 4278255360, fe[(ce + 64 >>> 9 << 4) + 14] = (ve << 8 | ve >>> 24) & 16711935 | (ve << 24 | ve >>> 8) & 4278255360, ue.sigBytes = (fe.length + 1) * 4, this._process();
            for (var Pe = this._hash, Ue = Pe.words, ze = 0; ze < 4; ze++) {
              var Le = Ue[ze];
              Ue[ze] = (Le << 8 | Le >>> 24) & 16711935 | (Le << 24 | Le >>> 8) & 4278255360;
            }
            return Pe;
          },
          clone: function() {
            var ue = M.clone.call(this);
            return ue._hash = this._hash.clone(), ue;
          }
        });
        function Z(ue, fe, de, ce, be, ve, Pe) {
          var Ue = ue + (fe & de | ~fe & ce) + be + Pe;
          return (Ue << ve | Ue >>> 32 - ve) + fe;
        }
        function Y(ue, fe, de, ce, be, ve, Pe) {
          var Ue = ue + (fe & ce | de & ~ce) + be + Pe;
          return (Ue << ve | Ue >>> 32 - ve) + fe;
        }
        function ee(ue, fe, de, ce, be, ve, Pe) {
          var Ue = ue + (fe ^ de ^ ce) + be + Pe;
          return (Ue << ve | Ue >>> 32 - ve) + fe;
        }
        function ie(ue, fe, de, ce, be, ve, Pe) {
          var Ue = ue + (de ^ (fe | ~ce)) + be + Pe;
          return (Ue << ve | Ue >>> 32 - ve) + fe;
        }
        S.MD5 = M._createHelper(D), S.HmacMD5 = M._createHmacHelper(D);
      }(Math), h.MD5;
    });
  }(Ko)), Ko.exports;
}
var $o = { exports: {} }, Bd;
function wh() {
  return Bd || (Bd = 1, function(e, t) {
    (function(h, o) {
      e.exports = o(xt());
    })(Me, function(h) {
      return function() {
        var o = h, S = o.lib, g = S.WordArray, B = S.Hasher, M = o.algo, O = [], P = M.SHA1 = B.extend({
          _doReset: function() {
            this._hash = new g.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(D, Z) {
            for (var Y = this._hash.words, ee = Y[0], ie = Y[1], ue = Y[2], fe = Y[3], de = Y[4], ce = 0; ce < 80; ce++) {
              if (ce < 16)
                O[ce] = D[Z + ce] | 0;
              else {
                var be = O[ce - 3] ^ O[ce - 8] ^ O[ce - 14] ^ O[ce - 16];
                O[ce] = be << 1 | be >>> 31;
              }
              var ve = (ee << 5 | ee >>> 27) + de + O[ce];
              ce < 20 ? ve += (ie & ue | ~ie & fe) + 1518500249 : ce < 40 ? ve += (ie ^ ue ^ fe) + 1859775393 : ce < 60 ? ve += (ie & ue | ie & fe | ue & fe) - 1894007588 : ve += (ie ^ ue ^ fe) - 899497514, de = fe, fe = ue, ue = ie << 30 | ie >>> 2, ie = ee, ee = ve;
            }
            Y[0] = Y[0] + ee | 0, Y[1] = Y[1] + ie | 0, Y[2] = Y[2] + ue | 0, Y[3] = Y[3] + fe | 0, Y[4] = Y[4] + de | 0;
          },
          _doFinalize: function() {
            var D = this._data, Z = D.words, Y = this._nDataBytes * 8, ee = D.sigBytes * 8;
            return Z[ee >>> 5] |= 128 << 24 - ee % 32, Z[(ee + 64 >>> 9 << 4) + 14] = Math.floor(Y / 4294967296), Z[(ee + 64 >>> 9 << 4) + 15] = Y, D.sigBytes = Z.length * 4, this._process(), this._hash;
          },
          clone: function() {
            var D = B.clone.call(this);
            return D._hash = this._hash.clone(), D;
          }
        });
        o.SHA1 = B._createHelper(P), o.HmacSHA1 = B._createHmacHelper(P);
      }(), h.SHA1;
    });
  }($o)), $o.exports;
}
var Ho = { exports: {} }, Id;
function Gy() {
  return Id || (Id = 1, function(e, t) {
    (function(h, o) {
      e.exports = o(xt());
    })(Me, function(h) {
      return function(o) {
        var S = h, g = S.lib, B = g.WordArray, M = g.Hasher, O = S.algo, P = [], D = [];
        (function() {
          function ee(de) {
            for (var ce = o.sqrt(de), be = 2; be <= ce; be++)
              if (!(de % be))
                return !1;
            return !0;
          }
          function ie(de) {
            return (de - (de | 0)) * 4294967296 | 0;
          }
          for (var ue = 2, fe = 0; fe < 64; )
            ee(ue) && (fe < 8 && (P[fe] = ie(o.pow(ue, 1 / 2))), D[fe] = ie(o.pow(ue, 1 / 3)), fe++), ue++;
        })();
        var Z = [], Y = O.SHA256 = M.extend({
          _doReset: function() {
            this._hash = new B.init(P.slice(0));
          },
          _doProcessBlock: function(ee, ie) {
            for (var ue = this._hash.words, fe = ue[0], de = ue[1], ce = ue[2], be = ue[3], ve = ue[4], Pe = ue[5], Ue = ue[6], ze = ue[7], Le = 0; Le < 64; Le++) {
              if (Le < 16)
                Z[Le] = ee[ie + Le] | 0;
              else {
                var Ne = Z[Le - 15], $e = (Ne << 25 | Ne >>> 7) ^ (Ne << 14 | Ne >>> 18) ^ Ne >>> 3, J = Z[Le - 2], ne = (J << 15 | J >>> 17) ^ (J << 13 | J >>> 19) ^ J >>> 10;
                Z[Le] = $e + Z[Le - 7] + ne + Z[Le - 16];
              }
              var A = ve & Pe ^ ~ve & Ue, I = fe & de ^ fe & ce ^ de & ce, U = (fe << 30 | fe >>> 2) ^ (fe << 19 | fe >>> 13) ^ (fe << 10 | fe >>> 22), X = (ve << 26 | ve >>> 6) ^ (ve << 21 | ve >>> 11) ^ (ve << 7 | ve >>> 25), Q = ze + X + A + D[Le] + Z[Le], F = U + I;
              ze = Ue, Ue = Pe, Pe = ve, ve = be + Q | 0, be = ce, ce = de, de = fe, fe = Q + F | 0;
            }
            ue[0] = ue[0] + fe | 0, ue[1] = ue[1] + de | 0, ue[2] = ue[2] + ce | 0, ue[3] = ue[3] + be | 0, ue[4] = ue[4] + ve | 0, ue[5] = ue[5] + Pe | 0, ue[6] = ue[6] + Ue | 0, ue[7] = ue[7] + ze | 0;
          },
          _doFinalize: function() {
            var ee = this._data, ie = ee.words, ue = this._nDataBytes * 8, fe = ee.sigBytes * 8;
            return ie[fe >>> 5] |= 128 << 24 - fe % 32, ie[(fe + 64 >>> 9 << 4) + 14] = o.floor(ue / 4294967296), ie[(fe + 64 >>> 9 << 4) + 15] = ue, ee.sigBytes = ie.length * 4, this._process(), this._hash;
          },
          clone: function() {
            var ee = M.clone.call(this);
            return ee._hash = this._hash.clone(), ee;
          }
        });
        S.SHA256 = M._createHelper(Y), S.HmacSHA256 = M._createHmacHelper(Y);
      }(Math), h.SHA256;
    });
  }(Ho)), Ho.exports;
}
var Go = { exports: {} }, Td;
function r_() {
  return Td || (Td = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), Gy());
    })(Me, function(h) {
      return function() {
        var o = h, S = o.lib, g = S.WordArray, B = o.algo, M = B.SHA256, O = B.SHA224 = M.extend({
          _doReset: function() {
            this._hash = new g.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var P = M._doFinalize.call(this);
            return P.sigBytes -= 4, P;
          }
        });
        o.SHA224 = M._createHelper(O), o.HmacSHA224 = M._createHmacHelper(O);
      }(), h.SHA224;
    });
  }(Go)), Go.exports;
}
var zo = { exports: {} }, Md;
function zy() {
  return Md || (Md = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), If());
    })(Me, function(h) {
      return function() {
        var o = h, S = o.lib, g = S.Hasher, B = o.x64, M = B.Word, O = B.WordArray, P = o.algo;
        function D() {
          return M.create.apply(M, arguments);
        }
        var Z = [
          D(1116352408, 3609767458),
          D(1899447441, 602891725),
          D(3049323471, 3964484399),
          D(3921009573, 2173295548),
          D(961987163, 4081628472),
          D(1508970993, 3053834265),
          D(2453635748, 2937671579),
          D(2870763221, 3664609560),
          D(3624381080, 2734883394),
          D(310598401, 1164996542),
          D(607225278, 1323610764),
          D(1426881987, 3590304994),
          D(1925078388, 4068182383),
          D(2162078206, 991336113),
          D(2614888103, 633803317),
          D(3248222580, 3479774868),
          D(3835390401, 2666613458),
          D(4022224774, 944711139),
          D(264347078, 2341262773),
          D(604807628, 2007800933),
          D(770255983, 1495990901),
          D(1249150122, 1856431235),
          D(1555081692, 3175218132),
          D(1996064986, 2198950837),
          D(2554220882, 3999719339),
          D(2821834349, 766784016),
          D(2952996808, 2566594879),
          D(3210313671, 3203337956),
          D(3336571891, 1034457026),
          D(3584528711, 2466948901),
          D(113926993, 3758326383),
          D(338241895, 168717936),
          D(666307205, 1188179964),
          D(773529912, 1546045734),
          D(1294757372, 1522805485),
          D(1396182291, 2643833823),
          D(1695183700, 2343527390),
          D(1986661051, 1014477480),
          D(2177026350, 1206759142),
          D(2456956037, 344077627),
          D(2730485921, 1290863460),
          D(2820302411, 3158454273),
          D(3259730800, 3505952657),
          D(3345764771, 106217008),
          D(3516065817, 3606008344),
          D(3600352804, 1432725776),
          D(4094571909, 1467031594),
          D(275423344, 851169720),
          D(430227734, 3100823752),
          D(506948616, 1363258195),
          D(659060556, 3750685593),
          D(883997877, 3785050280),
          D(958139571, 3318307427),
          D(1322822218, 3812723403),
          D(1537002063, 2003034995),
          D(1747873779, 3602036899),
          D(1955562222, 1575990012),
          D(2024104815, 1125592928),
          D(2227730452, 2716904306),
          D(2361852424, 442776044),
          D(2428436474, 593698344),
          D(2756734187, 3733110249),
          D(3204031479, 2999351573),
          D(3329325298, 3815920427),
          D(3391569614, 3928383900),
          D(3515267271, 566280711),
          D(3940187606, 3454069534),
          D(4118630271, 4000239992),
          D(116418474, 1914138554),
          D(174292421, 2731055270),
          D(289380356, 3203993006),
          D(460393269, 320620315),
          D(685471733, 587496836),
          D(852142971, 1086792851),
          D(1017036298, 365543100),
          D(1126000580, 2618297676),
          D(1288033470, 3409855158),
          D(1501505948, 4234509866),
          D(1607167915, 987167468),
          D(1816402316, 1246189591)
        ], Y = [];
        (function() {
          for (var ie = 0; ie < 80; ie++)
            Y[ie] = D();
        })();
        var ee = P.SHA512 = g.extend({
          _doReset: function() {
            this._hash = new O.init([
              new M.init(1779033703, 4089235720),
              new M.init(3144134277, 2227873595),
              new M.init(1013904242, 4271175723),
              new M.init(2773480762, 1595750129),
              new M.init(1359893119, 2917565137),
              new M.init(2600822924, 725511199),
              new M.init(528734635, 4215389547),
              new M.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(ie, ue) {
            for (var fe = this._hash.words, de = fe[0], ce = fe[1], be = fe[2], ve = fe[3], Pe = fe[4], Ue = fe[5], ze = fe[6], Le = fe[7], Ne = de.high, $e = de.low, J = ce.high, ne = ce.low, A = be.high, I = be.low, U = ve.high, X = ve.low, Q = Pe.high, F = Pe.low, $ = Ue.high, H = Ue.low, q = ze.high, z = ze.low, me = Le.high, Ce = Le.low, je = Ne, Re = $e, Ae = J, ke = ne, Qe = A, Ze = I, qe = U, Oe = X, Xe = Q, et = F, nt = $, re = H, oe = q, le = z, ge = me, Ke = Ce, Je = 0; Je < 80; Je++) {
              var Fe, Ye, it = Y[Je];
              if (Je < 16)
                Ye = it.high = ie[ue + Je * 2] | 0, Fe = it.low = ie[ue + Je * 2 + 1] | 0;
              else {
                var rt = Y[Je - 15], tt = rt.high, vt = rt.low, St = (tt >>> 1 | vt << 31) ^ (tt >>> 8 | vt << 24) ^ tt >>> 7, ot = (vt >>> 1 | tt << 31) ^ (vt >>> 8 | tt << 24) ^ (vt >>> 7 | tt << 25), si = Y[Je - 2], oi = si.high, At = si.low, Nn = (oi >>> 19 | At << 13) ^ (oi << 3 | At >>> 29) ^ oi >>> 6, ui = (At >>> 19 | oi << 13) ^ (At << 3 | oi >>> 29) ^ (At >>> 6 | oi << 26), Bt = Y[Je - 7], vi = Bt.high, fi = Bt.low, Ct = Y[Je - 16], rM = Ct.high, hi = Ct.low;
                Fe = ot + fi, Ye = St + vi + (Fe >>> 0 < ot >>> 0 ? 1 : 0), Fe = Fe + ui, Ye = Ye + Nn + (Fe >>> 0 < ui >>> 0 ? 1 : 0), Fe = Fe + hi, Ye = Ye + rM + (Fe >>> 0 < hi >>> 0 ? 1 : 0), it.high = Ye, it.low = Fe;
              }
              var Tt = Xe & nt ^ ~Xe & oe, Dn = et & re ^ ~et & le, di = je & Ae ^ je & Qe ^ Ae & Qe, Ot = Re & ke ^ Re & Ze ^ ke & Ze, iM = (je >>> 28 | Re << 4) ^ (je << 30 | Re >>> 2) ^ (je << 25 | Re >>> 7), ci = (Re >>> 28 | je << 4) ^ (Re << 30 | je >>> 2) ^ (Re << 25 | je >>> 7), Dt = (Xe >>> 14 | et << 18) ^ (Xe >>> 18 | et << 14) ^ (Xe << 23 | et >>> 9), nM = (et >>> 14 | Xe << 18) ^ (et >>> 18 | Xe << 14) ^ (et << 23 | Xe >>> 9), li = Z[Je], ri = li.high, eM = li.low, ai = Ke + nM, It = ge + Dt + (ai >>> 0 < Ke >>> 0 ? 1 : 0), ai = ai + Dn, It = It + Tt + (ai >>> 0 < Dn >>> 0 ? 1 : 0), ai = ai + eM, It = It + ri + (ai >>> 0 < eM >>> 0 ? 1 : 0), ai = ai + Fe, It = It + Ye + (ai >>> 0 < Fe >>> 0 ? 1 : 0), tM = ci + Ot, pi = iM + di + (tM >>> 0 < ci >>> 0 ? 1 : 0);
              ge = oe, Ke = le, oe = nt, le = re, nt = Xe, re = et, et = Oe + ai | 0, Xe = qe + It + (et >>> 0 < Oe >>> 0 ? 1 : 0) | 0, qe = Qe, Oe = Ze, Qe = Ae, Ze = ke, Ae = je, ke = Re, Re = ai + tM | 0, je = It + pi + (Re >>> 0 < ai >>> 0 ? 1 : 0) | 0;
            }
            $e = de.low = $e + Re, de.high = Ne + je + ($e >>> 0 < Re >>> 0 ? 1 : 0), ne = ce.low = ne + ke, ce.high = J + Ae + (ne >>> 0 < ke >>> 0 ? 1 : 0), I = be.low = I + Ze, be.high = A + Qe + (I >>> 0 < Ze >>> 0 ? 1 : 0), X = ve.low = X + Oe, ve.high = U + qe + (X >>> 0 < Oe >>> 0 ? 1 : 0), F = Pe.low = F + et, Pe.high = Q + Xe + (F >>> 0 < et >>> 0 ? 1 : 0), H = Ue.low = H + re, Ue.high = $ + nt + (H >>> 0 < re >>> 0 ? 1 : 0), z = ze.low = z + le, ze.high = q + oe + (z >>> 0 < le >>> 0 ? 1 : 0), Ce = Le.low = Ce + Ke, Le.high = me + ge + (Ce >>> 0 < Ke >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var ie = this._data, ue = ie.words, fe = this._nDataBytes * 8, de = ie.sigBytes * 8;
            ue[de >>> 5] |= 128 << 24 - de % 32, ue[(de + 128 >>> 10 << 5) + 30] = Math.floor(fe / 4294967296), ue[(de + 128 >>> 10 << 5) + 31] = fe, ie.sigBytes = ue.length * 4, this._process();
            var ce = this._hash.toX32();
            return ce;
          },
          clone: function() {
            var ie = g.clone.call(this);
            return ie._hash = this._hash.clone(), ie;
          },
          blockSize: 1024 / 32
        });
        o.SHA512 = g._createHelper(ee), o.HmacSHA512 = g._createHmacHelper(ee);
      }(), h.SHA512;
    });
  }(zo)), zo.exports;
}
var jo = { exports: {} }, Rd;
function i_() {
  return Rd || (Rd = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), If(), zy());
    })(Me, function(h) {
      return function() {
        var o = h, S = o.x64, g = S.Word, B = S.WordArray, M = o.algo, O = M.SHA512, P = M.SHA384 = O.extend({
          _doReset: function() {
            this._hash = new B.init([
              new g.init(3418070365, 3238371032),
              new g.init(1654270250, 914150663),
              new g.init(2438529370, 812702999),
              new g.init(355462360, 4144912697),
              new g.init(1731405415, 4290775857),
              new g.init(2394180231, 1750603025),
              new g.init(3675008525, 1694076839),
              new g.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var D = O._doFinalize.call(this);
            return D.sigBytes -= 16, D;
          }
        });
        o.SHA384 = O._createHelper(P), o.HmacSHA384 = O._createHmacHelper(P);
      }(), h.SHA384;
    });
  }(jo)), jo.exports;
}
var Wo = { exports: {} }, Nd;
function n_() {
  return Nd || (Nd = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), If());
    })(Me, function(h) {
      return function(o) {
        var S = h, g = S.lib, B = g.WordArray, M = g.Hasher, O = S.x64, P = O.Word, D = S.algo, Z = [], Y = [], ee = [];
        (function() {
          for (var fe = 1, de = 0, ce = 0; ce < 24; ce++) {
            Z[fe + 5 * de] = (ce + 1) * (ce + 2) / 2 % 64;
            var be = de % 5, ve = (2 * fe + 3 * de) % 5;
            fe = be, de = ve;
          }
          for (var fe = 0; fe < 5; fe++)
            for (var de = 0; de < 5; de++)
              Y[fe + 5 * de] = de + (2 * fe + 3 * de) % 5 * 5;
          for (var Pe = 1, Ue = 0; Ue < 24; Ue++) {
            for (var ze = 0, Le = 0, Ne = 0; Ne < 7; Ne++) {
              if (Pe & 1) {
                var $e = (1 << Ne) - 1;
                $e < 32 ? Le ^= 1 << $e : ze ^= 1 << $e - 32;
              }
              Pe & 128 ? Pe = Pe << 1 ^ 113 : Pe <<= 1;
            }
            ee[Ue] = P.create(ze, Le);
          }
        })();
        var ie = [];
        (function() {
          for (var fe = 0; fe < 25; fe++)
            ie[fe] = P.create();
        })();
        var ue = D.SHA3 = M.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: M.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            for (var fe = this._state = [], de = 0; de < 25; de++)
              fe[de] = new P.init();
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(fe, de) {
            for (var ce = this._state, be = this.blockSize / 2, ve = 0; ve < be; ve++) {
              var Pe = fe[de + 2 * ve], Ue = fe[de + 2 * ve + 1];
              Pe = (Pe << 8 | Pe >>> 24) & 16711935 | (Pe << 24 | Pe >>> 8) & 4278255360, Ue = (Ue << 8 | Ue >>> 24) & 16711935 | (Ue << 24 | Ue >>> 8) & 4278255360;
              var ze = ce[ve];
              ze.high ^= Ue, ze.low ^= Pe;
            }
            for (var Le = 0; Le < 24; Le++) {
              for (var Ne = 0; Ne < 5; Ne++) {
                for (var $e = 0, J = 0, ne = 0; ne < 5; ne++) {
                  var ze = ce[Ne + 5 * ne];
                  $e ^= ze.high, J ^= ze.low;
                }
                var A = ie[Ne];
                A.high = $e, A.low = J;
              }
              for (var Ne = 0; Ne < 5; Ne++)
                for (var I = ie[(Ne + 4) % 5], U = ie[(Ne + 1) % 5], X = U.high, Q = U.low, $e = I.high ^ (X << 1 | Q >>> 31), J = I.low ^ (Q << 1 | X >>> 31), ne = 0; ne < 5; ne++) {
                  var ze = ce[Ne + 5 * ne];
                  ze.high ^= $e, ze.low ^= J;
                }
              for (var F = 1; F < 25; F++) {
                var $e, J, ze = ce[F], $ = ze.high, H = ze.low, q = Z[F];
                q < 32 ? ($e = $ << q | H >>> 32 - q, J = H << q | $ >>> 32 - q) : ($e = H << q - 32 | $ >>> 64 - q, J = $ << q - 32 | H >>> 64 - q);
                var z = ie[Y[F]];
                z.high = $e, z.low = J;
              }
              var me = ie[0], Ce = ce[0];
              me.high = Ce.high, me.low = Ce.low;
              for (var Ne = 0; Ne < 5; Ne++)
                for (var ne = 0; ne < 5; ne++) {
                  var F = Ne + 5 * ne, ze = ce[F], je = ie[F], Re = ie[(Ne + 1) % 5 + 5 * ne], Ae = ie[(Ne + 2) % 5 + 5 * ne];
                  ze.high = je.high ^ ~Re.high & Ae.high, ze.low = je.low ^ ~Re.low & Ae.low;
                }
              var ze = ce[0], ke = ee[Le];
              ze.high ^= ke.high, ze.low ^= ke.low;
            }
          },
          _doFinalize: function() {
            var fe = this._data, de = fe.words;
            this._nDataBytes * 8;
            var ce = fe.sigBytes * 8, be = this.blockSize * 32;
            de[ce >>> 5] |= 1 << 24 - ce % 32, de[(o.ceil((ce + 1) / be) * be >>> 5) - 1] |= 128, fe.sigBytes = de.length * 4, this._process();
            for (var ve = this._state, Pe = this.cfg.outputLength / 8, Ue = Pe / 8, ze = [], Le = 0; Le < Ue; Le++) {
              var Ne = ve[Le], $e = Ne.high, J = Ne.low;
              $e = ($e << 8 | $e >>> 24) & 16711935 | ($e << 24 | $e >>> 8) & 4278255360, J = (J << 8 | J >>> 24) & 16711935 | (J << 24 | J >>> 8) & 4278255360, ze.push(J), ze.push($e);
            }
            return new B.init(ze, Pe);
          },
          clone: function() {
            for (var fe = M.clone.call(this), de = fe._state = this._state.slice(0), ce = 0; ce < 25; ce++)
              de[ce] = de[ce].clone();
            return fe;
          }
        });
        S.SHA3 = M._createHelper(ue), S.HmacSHA3 = M._createHmacHelper(ue);
      }(Math), h.SHA3;
    });
  }(Wo)), Wo.exports;
}
var Yo = { exports: {} }, Dd;
function a_() {
  return Dd || (Dd = 1, function(e, t) {
    (function(h, o) {
      e.exports = o(xt());
    })(Me, function(h) {
      /** @preserve
      			(c) 2012 by Cédric Mesnil. All rights reserved.
      
      			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
      
      			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
      			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
      
      			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      			*/
      return function(o) {
        var S = h, g = S.lib, B = g.WordArray, M = g.Hasher, O = S.algo, P = B.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]), D = B.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]), Z = B.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]), Y = B.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]), ee = B.create([0, 1518500249, 1859775393, 2400959708, 2840853838]), ie = B.create([1352829926, 1548603684, 1836072691, 2053994217, 0]), ue = O.RIPEMD160 = M.extend({
          _doReset: function() {
            this._hash = B.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(Ue, ze) {
            for (var Le = 0; Le < 16; Le++) {
              var Ne = ze + Le, $e = Ue[Ne];
              Ue[Ne] = ($e << 8 | $e >>> 24) & 16711935 | ($e << 24 | $e >>> 8) & 4278255360;
            }
            var J = this._hash.words, ne = ee.words, A = ie.words, I = P.words, U = D.words, X = Z.words, Q = Y.words, F, $, H, q, z, me, Ce, je, Re, Ae;
            me = F = J[0], Ce = $ = J[1], je = H = J[2], Re = q = J[3], Ae = z = J[4];
            for (var ke, Le = 0; Le < 80; Le += 1)
              ke = F + Ue[ze + I[Le]] | 0, Le < 16 ? ke += fe($, H, q) + ne[0] : Le < 32 ? ke += de($, H, q) + ne[1] : Le < 48 ? ke += ce($, H, q) + ne[2] : Le < 64 ? ke += be($, H, q) + ne[3] : ke += ve($, H, q) + ne[4], ke = ke | 0, ke = Pe(ke, X[Le]), ke = ke + z | 0, F = z, z = q, q = Pe(H, 10), H = $, $ = ke, ke = me + Ue[ze + U[Le]] | 0, Le < 16 ? ke += ve(Ce, je, Re) + A[0] : Le < 32 ? ke += be(Ce, je, Re) + A[1] : Le < 48 ? ke += ce(Ce, je, Re) + A[2] : Le < 64 ? ke += de(Ce, je, Re) + A[3] : ke += fe(Ce, je, Re) + A[4], ke = ke | 0, ke = Pe(ke, Q[Le]), ke = ke + Ae | 0, me = Ae, Ae = Re, Re = Pe(je, 10), je = Ce, Ce = ke;
            ke = J[1] + H + Re | 0, J[1] = J[2] + q + Ae | 0, J[2] = J[3] + z + me | 0, J[3] = J[4] + F + Ce | 0, J[4] = J[0] + $ + je | 0, J[0] = ke;
          },
          _doFinalize: function() {
            var Ue = this._data, ze = Ue.words, Le = this._nDataBytes * 8, Ne = Ue.sigBytes * 8;
            ze[Ne >>> 5] |= 128 << 24 - Ne % 32, ze[(Ne + 64 >>> 9 << 4) + 14] = (Le << 8 | Le >>> 24) & 16711935 | (Le << 24 | Le >>> 8) & 4278255360, Ue.sigBytes = (ze.length + 1) * 4, this._process();
            for (var $e = this._hash, J = $e.words, ne = 0; ne < 5; ne++) {
              var A = J[ne];
              J[ne] = (A << 8 | A >>> 24) & 16711935 | (A << 24 | A >>> 8) & 4278255360;
            }
            return $e;
          },
          clone: function() {
            var Ue = M.clone.call(this);
            return Ue._hash = this._hash.clone(), Ue;
          }
        });
        function fe(Ue, ze, Le) {
          return Ue ^ ze ^ Le;
        }
        function de(Ue, ze, Le) {
          return Ue & ze | ~Ue & Le;
        }
        function ce(Ue, ze, Le) {
          return (Ue | ~ze) ^ Le;
        }
        function be(Ue, ze, Le) {
          return Ue & Le | ze & ~Le;
        }
        function ve(Ue, ze, Le) {
          return Ue ^ (ze | ~Le);
        }
        function Pe(Ue, ze) {
          return Ue << ze | Ue >>> 32 - ze;
        }
        S.RIPEMD160 = M._createHelper(ue), S.HmacRIPEMD160 = M._createHmacHelper(ue);
      }(), h.RIPEMD160;
    });
  }(Yo)), Yo.exports;
}
var Xo = { exports: {} }, Od;
function Ch() {
  return Od || (Od = 1, function(e, t) {
    (function(h, o) {
      e.exports = o(xt());
    })(Me, function(h) {
      (function() {
        var o = h, S = o.lib, g = S.Base, B = o.enc, M = B.Utf8, O = o.algo;
        O.HMAC = g.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(P, D) {
            P = this._hasher = new P.init(), typeof D == "string" && (D = M.parse(D));
            var Z = P.blockSize, Y = Z * 4;
            D.sigBytes > Y && (D = P.finalize(D)), D.clamp();
            for (var ee = this._oKey = D.clone(), ie = this._iKey = D.clone(), ue = ee.words, fe = ie.words, de = 0; de < Z; de++)
              ue[de] ^= 1549556828, fe[de] ^= 909522486;
            ee.sigBytes = ie.sigBytes = Y, this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var P = this._hasher;
            P.reset(), P.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(P) {
            return this._hasher.update(P), this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(P) {
            var D = this._hasher, Z = D.finalize(P);
            D.reset();
            var Y = D.finalize(this._oKey.clone().concat(Z));
            return Y;
          }
        });
      })();
    });
  }(Xo)), Xo.exports;
}
var Qo = { exports: {} }, Pd;
function s_() {
  return Pd || (Pd = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), wh(), Ch());
    })(Me, function(h) {
      return function() {
        var o = h, S = o.lib, g = S.Base, B = S.WordArray, M = o.algo, O = M.SHA1, P = M.HMAC, D = M.PBKDF2 = g.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA1
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: g.extend({
            keySize: 128 / 32,
            hasher: O,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: function(Z) {
            this.cfg = this.cfg.extend(Z);
          },
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(Z, Y) {
            for (var ee = this.cfg, ie = P.create(ee.hasher, Z), ue = B.create(), fe = B.create([1]), de = ue.words, ce = fe.words, be = ee.keySize, ve = ee.iterations; de.length < be; ) {
              var Pe = ie.update(Y).finalize(fe);
              ie.reset();
              for (var Ue = Pe.words, ze = Ue.length, Le = Pe, Ne = 1; Ne < ve; Ne++) {
                Le = ie.finalize(Le), ie.reset();
                for (var $e = Le.words, J = 0; J < ze; J++)
                  Ue[J] ^= $e[J];
              }
              ue.concat(Pe), ce[0]++;
            }
            return ue.sigBytes = be * 4, ue;
          }
        });
        o.PBKDF2 = function(Z, Y, ee) {
          return D.create(ee).compute(Z, Y);
        };
      }(), h.PBKDF2;
    });
  }(Qo)), Qo.exports;
}
var Zo = { exports: {} }, Ld;
function aa() {
  return Ld || (Ld = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), wh(), Ch());
    })(Me, function(h) {
      return function() {
        var o = h, S = o.lib, g = S.Base, B = S.WordArray, M = o.algo, O = M.MD5, P = M.EvpKDF = g.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: g.extend({
            keySize: 128 / 32,
            hasher: O,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(D) {
            this.cfg = this.cfg.extend(D);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(D, Z) {
            for (var Y, ee = this.cfg, ie = ee.hasher.create(), ue = B.create(), fe = ue.words, de = ee.keySize, ce = ee.iterations; fe.length < de; ) {
              Y && ie.update(Y), Y = ie.update(D).finalize(Z), ie.reset();
              for (var be = 1; be < ce; be++)
                Y = ie.finalize(Y), ie.reset();
              ue.concat(Y);
            }
            return ue.sigBytes = de * 4, ue;
          }
        });
        o.EvpKDF = function(D, Z, Y) {
          return P.create(Y).compute(D, Z);
        };
      }(), h.EvpKDF;
    });
  }(Zo)), Zo.exports;
}
var Jo = { exports: {} }, kd;
function or() {
  return kd || (kd = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), aa());
    })(Me, function(h) {
      h.lib.Cipher || function(o) {
        var S = h, g = S.lib, B = g.Base, M = g.WordArray, O = g.BufferedBlockAlgorithm, P = S.enc;
        P.Utf8;
        var D = P.Base64, Z = S.algo, Y = Z.EvpKDF, ee = g.Cipher = O.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: B.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function($e, J) {
            return this.create(this._ENC_XFORM_MODE, $e, J);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function($e, J) {
            return this.create(this._DEC_XFORM_MODE, $e, J);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function($e, J, ne) {
            this.cfg = this.cfg.extend(ne), this._xformMode = $e, this._key = J, this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            O.reset.call(this), this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function($e) {
            return this._append($e), this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function($e) {
            $e && this._append($e);
            var J = this._doFinalize();
            return J;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: /* @__PURE__ */ function() {
            function $e(J) {
              return typeof J == "string" ? Ne : Ue;
            }
            return function(J) {
              return {
                encrypt: function(ne, A, I) {
                  return $e(A).encrypt(J, ne, A, I);
                },
                decrypt: function(ne, A, I) {
                  return $e(A).decrypt(J, ne, A, I);
                }
              };
            };
          }()
        });
        g.StreamCipher = ee.extend({
          _doFinalize: function() {
            var $e = this._process(!0);
            return $e;
          },
          blockSize: 1
        });
        var ie = S.mode = {}, ue = g.BlockCipherMode = B.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function($e, J) {
            return this.Encryptor.create($e, J);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function($e, J) {
            return this.Decryptor.create($e, J);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function($e, J) {
            this._cipher = $e, this._iv = J;
          }
        }), fe = ie.CBC = function() {
          var $e = ue.extend();
          $e.Encryptor = $e.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(ne, A) {
              var I = this._cipher, U = I.blockSize;
              J.call(this, ne, A, U), I.encryptBlock(ne, A), this._prevBlock = ne.slice(A, A + U);
            }
          }), $e.Decryptor = $e.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(ne, A) {
              var I = this._cipher, U = I.blockSize, X = ne.slice(A, A + U);
              I.decryptBlock(ne, A), J.call(this, ne, A, U), this._prevBlock = X;
            }
          });
          function J(ne, A, I) {
            var U, X = this._iv;
            X ? (U = X, this._iv = o) : U = this._prevBlock;
            for (var Q = 0; Q < I; Q++)
              ne[A + Q] ^= U[Q];
          }
          return $e;
        }(), de = S.pad = {}, ce = de.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function($e, J) {
            for (var ne = J * 4, A = ne - $e.sigBytes % ne, I = A << 24 | A << 16 | A << 8 | A, U = [], X = 0; X < A; X += 4)
              U.push(I);
            var Q = M.create(U, A);
            $e.concat(Q);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function($e) {
            var J = $e.words[$e.sigBytes - 1 >>> 2] & 255;
            $e.sigBytes -= J;
          }
        };
        g.BlockCipher = ee.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: ee.cfg.extend({
            mode: fe,
            padding: ce
          }),
          reset: function() {
            var $e;
            ee.reset.call(this);
            var J = this.cfg, ne = J.iv, A = J.mode;
            this._xformMode == this._ENC_XFORM_MODE ? $e = A.createEncryptor : ($e = A.createDecryptor, this._minBufferSize = 1), this._mode && this._mode.__creator == $e ? this._mode.init(this, ne && ne.words) : (this._mode = $e.call(A, this, ne && ne.words), this._mode.__creator = $e);
          },
          _doProcessBlock: function($e, J) {
            this._mode.processBlock($e, J);
          },
          _doFinalize: function() {
            var $e, J = this.cfg.padding;
            return this._xformMode == this._ENC_XFORM_MODE ? (J.pad(this._data, this.blockSize), $e = this._process(!0)) : ($e = this._process(!0), J.unpad($e)), $e;
          },
          blockSize: 128 / 32
        });
        var be = g.CipherParams = B.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function($e) {
            this.mixIn($e);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function($e) {
            return ($e || this.formatter).stringify(this);
          }
        }), ve = S.format = {}, Pe = ve.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function($e) {
            var J, ne = $e.ciphertext, A = $e.salt;
            return A ? J = M.create([1398893684, 1701076831]).concat(A).concat(ne) : J = ne, J.toString(D);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function($e) {
            var J, ne = D.parse($e), A = ne.words;
            return A[0] == 1398893684 && A[1] == 1701076831 && (J = M.create(A.slice(2, 4)), A.splice(0, 4), ne.sigBytes -= 16), be.create({ ciphertext: ne, salt: J });
          }
        }, Ue = g.SerializableCipher = B.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: B.extend({
            format: Pe
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function($e, J, ne, A) {
            A = this.cfg.extend(A);
            var I = $e.createEncryptor(ne, A), U = I.finalize(J), X = I.cfg;
            return be.create({
              ciphertext: U,
              key: ne,
              iv: X.iv,
              algorithm: $e,
              mode: X.mode,
              padding: X.padding,
              blockSize: $e.blockSize,
              formatter: A.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function($e, J, ne, A) {
            A = this.cfg.extend(A), J = this._parse(J, A.format);
            var I = $e.createDecryptor(ne, A).finalize(J.ciphertext);
            return I;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function($e, J) {
            return typeof $e == "string" ? J.parse($e, this) : $e;
          }
        }), ze = S.kdf = {}, Le = ze.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function($e, J, ne, A) {
            A || (A = M.random(64 / 8));
            var I = Y.create({ keySize: J + ne }).compute($e, A), U = M.create(I.words.slice(J), ne * 4);
            return I.sigBytes = J * 4, be.create({ key: I, iv: U, salt: A });
          }
        }, Ne = g.PasswordBasedCipher = Ue.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: Ue.cfg.extend({
            kdf: Le
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function($e, J, ne, A) {
            A = this.cfg.extend(A);
            var I = A.kdf.execute(ne, $e.keySize, $e.ivSize);
            A.iv = I.iv;
            var U = Ue.encrypt.call(this, $e, J, I.key, A);
            return U.mixIn(I), U;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function($e, J, ne, A) {
            A = this.cfg.extend(A), J = this._parse(J, A.format);
            var I = A.kdf.execute(ne, $e.keySize, $e.ivSize, J.salt);
            A.iv = I.iv;
            var U = Ue.decrypt.call(this, $e, J, I.key, A);
            return U;
          }
        });
      }();
    });
  }(Jo)), Jo.exports;
}
var eu = { exports: {} }, Ud;
function f_() {
  return Ud || (Ud = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), or());
    })(Me, function(h) {
      return h.mode.CFB = function() {
        var o = h.lib.BlockCipherMode.extend();
        o.Encryptor = o.extend({
          processBlock: function(g, B) {
            var M = this._cipher, O = M.blockSize;
            S.call(this, g, B, O, M), this._prevBlock = g.slice(B, B + O);
          }
        }), o.Decryptor = o.extend({
          processBlock: function(g, B) {
            var M = this._cipher, O = M.blockSize, P = g.slice(B, B + O);
            S.call(this, g, B, O, M), this._prevBlock = P;
          }
        });
        function S(g, B, M, O) {
          var P, D = this._iv;
          D ? (P = D.slice(0), this._iv = void 0) : P = this._prevBlock, O.encryptBlock(P, 0);
          for (var Z = 0; Z < M; Z++)
            g[B + Z] ^= P[Z];
        }
        return o;
      }(), h.mode.CFB;
    });
  }(eu)), eu.exports;
}
var tu = { exports: {} }, Fd;
function o_() {
  return Fd || (Fd = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), or());
    })(Me, function(h) {
      return h.mode.CTR = function() {
        var o = h.lib.BlockCipherMode.extend(), S = o.Encryptor = o.extend({
          processBlock: function(g, B) {
            var M = this._cipher, O = M.blockSize, P = this._iv, D = this._counter;
            P && (D = this._counter = P.slice(0), this._iv = void 0);
            var Z = D.slice(0);
            M.encryptBlock(Z, 0), D[O - 1] = D[O - 1] + 1 | 0;
            for (var Y = 0; Y < O; Y++)
              g[B + Y] ^= Z[Y];
          }
        });
        return o.Decryptor = S, o;
      }(), h.mode.CTR;
    });
  }(tu)), tu.exports;
}
var ru = { exports: {} }, qd;
function u_() {
  return qd || (qd = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), or());
    })(Me, function(h) {
      /** @preserve
       * Counter block mode compatible with  Dr Brian Gladman fileenc.c
       * derived from CryptoJS.mode.CTR
       * Jan Hruby jhruby.web@gmail.com
       */
      return h.mode.CTRGladman = function() {
        var o = h.lib.BlockCipherMode.extend();
        function S(M) {
          if ((M >> 24 & 255) === 255) {
            var O = M >> 16 & 255, P = M >> 8 & 255, D = M & 255;
            O === 255 ? (O = 0, P === 255 ? (P = 0, D === 255 ? D = 0 : ++D) : ++P) : ++O, M = 0, M += O << 16, M += P << 8, M += D;
          } else
            M += 1 << 24;
          return M;
        }
        function g(M) {
          return (M[0] = S(M[0])) === 0 && (M[1] = S(M[1])), M;
        }
        var B = o.Encryptor = o.extend({
          processBlock: function(M, O) {
            var P = this._cipher, D = P.blockSize, Z = this._iv, Y = this._counter;
            Z && (Y = this._counter = Z.slice(0), this._iv = void 0), g(Y);
            var ee = Y.slice(0);
            P.encryptBlock(ee, 0);
            for (var ie = 0; ie < D; ie++)
              M[O + ie] ^= ee[ie];
          }
        });
        return o.Decryptor = B, o;
      }(), h.mode.CTRGladman;
    });
  }(ru)), ru.exports;
}
var iu = { exports: {} }, Vd;
function c_() {
  return Vd || (Vd = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), or());
    })(Me, function(h) {
      return h.mode.OFB = function() {
        var o = h.lib.BlockCipherMode.extend(), S = o.Encryptor = o.extend({
          processBlock: function(g, B) {
            var M = this._cipher, O = M.blockSize, P = this._iv, D = this._keystream;
            P && (D = this._keystream = P.slice(0), this._iv = void 0), M.encryptBlock(D, 0);
            for (var Z = 0; Z < O; Z++)
              g[B + Z] ^= D[Z];
          }
        });
        return o.Decryptor = S, o;
      }(), h.mode.OFB;
    });
  }(iu)), iu.exports;
}
var nu = { exports: {} }, Kd;
function h_() {
  return Kd || (Kd = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), or());
    })(Me, function(h) {
      return h.mode.ECB = function() {
        var o = h.lib.BlockCipherMode.extend();
        return o.Encryptor = o.extend({
          processBlock: function(S, g) {
            this._cipher.encryptBlock(S, g);
          }
        }), o.Decryptor = o.extend({
          processBlock: function(S, g) {
            this._cipher.decryptBlock(S, g);
          }
        }), o;
      }(), h.mode.ECB;
    });
  }(nu)), nu.exports;
}
var au = { exports: {} }, $d;
function l_() {
  return $d || ($d = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), or());
    })(Me, function(h) {
      return h.pad.AnsiX923 = {
        pad: function(o, S) {
          var g = o.sigBytes, B = S * 4, M = B - g % B, O = g + M - 1;
          o.clamp(), o.words[O >>> 2] |= M << 24 - O % 4 * 8, o.sigBytes += M;
        },
        unpad: function(o) {
          var S = o.words[o.sigBytes - 1 >>> 2] & 255;
          o.sigBytes -= S;
        }
      }, h.pad.Ansix923;
    });
  }(au)), au.exports;
}
var su = { exports: {} }, Hd;
function d_() {
  return Hd || (Hd = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), or());
    })(Me, function(h) {
      return h.pad.Iso10126 = {
        pad: function(o, S) {
          var g = S * 4, B = g - o.sigBytes % g;
          o.concat(h.lib.WordArray.random(B - 1)).concat(h.lib.WordArray.create([B << 24], 1));
        },
        unpad: function(o) {
          var S = o.words[o.sigBytes - 1 >>> 2] & 255;
          o.sigBytes -= S;
        }
      }, h.pad.Iso10126;
    });
  }(su)), su.exports;
}
var fu = { exports: {} }, Gd;
function p_() {
  return Gd || (Gd = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), or());
    })(Me, function(h) {
      return h.pad.Iso97971 = {
        pad: function(o, S) {
          o.concat(h.lib.WordArray.create([2147483648], 1)), h.pad.ZeroPadding.pad(o, S);
        },
        unpad: function(o) {
          h.pad.ZeroPadding.unpad(o), o.sigBytes--;
        }
      }, h.pad.Iso97971;
    });
  }(fu)), fu.exports;
}
var ou = { exports: {} }, zd;
function v_() {
  return zd || (zd = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), or());
    })(Me, function(h) {
      return h.pad.ZeroPadding = {
        pad: function(o, S) {
          var g = S * 4;
          o.clamp(), o.sigBytes += g - (o.sigBytes % g || g);
        },
        unpad: function(o) {
          for (var S = o.words, g = o.sigBytes - 1, g = o.sigBytes - 1; g >= 0; g--)
            if (S[g >>> 2] >>> 24 - g % 4 * 8 & 255) {
              o.sigBytes = g + 1;
              break;
            }
        }
      }, h.pad.ZeroPadding;
    });
  }(ou)), ou.exports;
}
var uu = { exports: {} }, jd;
function y_() {
  return jd || (jd = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), or());
    })(Me, function(h) {
      return h.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      }, h.pad.NoPadding;
    });
  }(uu)), uu.exports;
}
var cu = { exports: {} }, Wd;
function g_() {
  return Wd || (Wd = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), or());
    })(Me, function(h) {
      return function(o) {
        var S = h, g = S.lib, B = g.CipherParams, M = S.enc, O = M.Hex, P = S.format;
        P.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: function(D) {
            return D.ciphertext.toString(O);
          },
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: function(D) {
            var Z = O.parse(D);
            return B.create({ ciphertext: Z });
          }
        };
      }(), h.format.Hex;
    });
  }(cu)), cu.exports;
}
var hu = { exports: {} }, Yd;
function m_() {
  return Yd || (Yd = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), ja(), Wa(), aa(), or());
    })(Me, function(h) {
      return function() {
        var o = h, S = o.lib, g = S.BlockCipher, B = o.algo, M = [], O = [], P = [], D = [], Z = [], Y = [], ee = [], ie = [], ue = [], fe = [];
        (function() {
          for (var be = [], ve = 0; ve < 256; ve++)
            ve < 128 ? be[ve] = ve << 1 : be[ve] = ve << 1 ^ 283;
          for (var Pe = 0, Ue = 0, ve = 0; ve < 256; ve++) {
            var ze = Ue ^ Ue << 1 ^ Ue << 2 ^ Ue << 3 ^ Ue << 4;
            ze = ze >>> 8 ^ ze & 255 ^ 99, M[Pe] = ze, O[ze] = Pe;
            var Le = be[Pe], Ne = be[Le], $e = be[Ne], J = be[ze] * 257 ^ ze * 16843008;
            P[Pe] = J << 24 | J >>> 8, D[Pe] = J << 16 | J >>> 16, Z[Pe] = J << 8 | J >>> 24, Y[Pe] = J;
            var J = $e * 16843009 ^ Ne * 65537 ^ Le * 257 ^ Pe * 16843008;
            ee[ze] = J << 24 | J >>> 8, ie[ze] = J << 16 | J >>> 16, ue[ze] = J << 8 | J >>> 24, fe[ze] = J, Pe ? (Pe = Le ^ be[be[be[$e ^ Le]]], Ue ^= be[be[Ue]]) : Pe = Ue = 1;
          }
        })();
        var de = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54], ce = B.AES = g.extend({
          _doReset: function() {
            var be;
            if (!(this._nRounds && this._keyPriorReset === this._key)) {
              for (var ve = this._keyPriorReset = this._key, Pe = ve.words, Ue = ve.sigBytes / 4, ze = this._nRounds = Ue + 6, Le = (ze + 1) * 4, Ne = this._keySchedule = [], $e = 0; $e < Le; $e++)
                $e < Ue ? Ne[$e] = Pe[$e] : (be = Ne[$e - 1], $e % Ue ? Ue > 6 && $e % Ue == 4 && (be = M[be >>> 24] << 24 | M[be >>> 16 & 255] << 16 | M[be >>> 8 & 255] << 8 | M[be & 255]) : (be = be << 8 | be >>> 24, be = M[be >>> 24] << 24 | M[be >>> 16 & 255] << 16 | M[be >>> 8 & 255] << 8 | M[be & 255], be ^= de[$e / Ue | 0] << 24), Ne[$e] = Ne[$e - Ue] ^ be);
              for (var J = this._invKeySchedule = [], ne = 0; ne < Le; ne++) {
                var $e = Le - ne;
                if (ne % 4)
                  var be = Ne[$e];
                else
                  var be = Ne[$e - 4];
                ne < 4 || $e <= 4 ? J[ne] = be : J[ne] = ee[M[be >>> 24]] ^ ie[M[be >>> 16 & 255]] ^ ue[M[be >>> 8 & 255]] ^ fe[M[be & 255]];
              }
            }
          },
          encryptBlock: function(be, ve) {
            this._doCryptBlock(be, ve, this._keySchedule, P, D, Z, Y, M);
          },
          decryptBlock: function(be, ve) {
            var Pe = be[ve + 1];
            be[ve + 1] = be[ve + 3], be[ve + 3] = Pe, this._doCryptBlock(be, ve, this._invKeySchedule, ee, ie, ue, fe, O);
            var Pe = be[ve + 1];
            be[ve + 1] = be[ve + 3], be[ve + 3] = Pe;
          },
          _doCryptBlock: function(be, ve, Pe, Ue, ze, Le, Ne, $e) {
            for (var J = this._nRounds, ne = be[ve] ^ Pe[0], A = be[ve + 1] ^ Pe[1], I = be[ve + 2] ^ Pe[2], U = be[ve + 3] ^ Pe[3], X = 4, Q = 1; Q < J; Q++) {
              var F = Ue[ne >>> 24] ^ ze[A >>> 16 & 255] ^ Le[I >>> 8 & 255] ^ Ne[U & 255] ^ Pe[X++], $ = Ue[A >>> 24] ^ ze[I >>> 16 & 255] ^ Le[U >>> 8 & 255] ^ Ne[ne & 255] ^ Pe[X++], H = Ue[I >>> 24] ^ ze[U >>> 16 & 255] ^ Le[ne >>> 8 & 255] ^ Ne[A & 255] ^ Pe[X++], q = Ue[U >>> 24] ^ ze[ne >>> 16 & 255] ^ Le[A >>> 8 & 255] ^ Ne[I & 255] ^ Pe[X++];
              ne = F, A = $, I = H, U = q;
            }
            var F = ($e[ne >>> 24] << 24 | $e[A >>> 16 & 255] << 16 | $e[I >>> 8 & 255] << 8 | $e[U & 255]) ^ Pe[X++], $ = ($e[A >>> 24] << 24 | $e[I >>> 16 & 255] << 16 | $e[U >>> 8 & 255] << 8 | $e[ne & 255]) ^ Pe[X++], H = ($e[I >>> 24] << 24 | $e[U >>> 16 & 255] << 16 | $e[ne >>> 8 & 255] << 8 | $e[A & 255]) ^ Pe[X++], q = ($e[U >>> 24] << 24 | $e[ne >>> 16 & 255] << 16 | $e[A >>> 8 & 255] << 8 | $e[I & 255]) ^ Pe[X++];
            be[ve] = F, be[ve + 1] = $, be[ve + 2] = H, be[ve + 3] = q;
          },
          keySize: 256 / 32
        });
        o.AES = g._createHelper(ce);
      }(), h.AES;
    });
  }(hu)), hu.exports;
}
var lu = { exports: {} }, Xd;
function b_() {
  return Xd || (Xd = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), ja(), Wa(), aa(), or());
    })(Me, function(h) {
      return function() {
        var o = h, S = o.lib, g = S.WordArray, B = S.BlockCipher, M = o.algo, O = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ], P = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ], D = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28], Z = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ], Y = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ], ee = M.DES = B.extend({
          _doReset: function() {
            for (var de = this._key, ce = de.words, be = [], ve = 0; ve < 56; ve++) {
              var Pe = O[ve] - 1;
              be[ve] = ce[Pe >>> 5] >>> 31 - Pe % 32 & 1;
            }
            for (var Ue = this._subKeys = [], ze = 0; ze < 16; ze++) {
              for (var Le = Ue[ze] = [], Ne = D[ze], ve = 0; ve < 24; ve++)
                Le[ve / 6 | 0] |= be[(P[ve] - 1 + Ne) % 28] << 31 - ve % 6, Le[4 + (ve / 6 | 0)] |= be[28 + (P[ve + 24] - 1 + Ne) % 28] << 31 - ve % 6;
              Le[0] = Le[0] << 1 | Le[0] >>> 31;
              for (var ve = 1; ve < 7; ve++)
                Le[ve] = Le[ve] >>> (ve - 1) * 4 + 3;
              Le[7] = Le[7] << 5 | Le[7] >>> 27;
            }
            for (var $e = this._invSubKeys = [], ve = 0; ve < 16; ve++)
              $e[ve] = Ue[15 - ve];
          },
          encryptBlock: function(de, ce) {
            this._doCryptBlock(de, ce, this._subKeys);
          },
          decryptBlock: function(de, ce) {
            this._doCryptBlock(de, ce, this._invSubKeys);
          },
          _doCryptBlock: function(de, ce, be) {
            this._lBlock = de[ce], this._rBlock = de[ce + 1], ie.call(this, 4, 252645135), ie.call(this, 16, 65535), ue.call(this, 2, 858993459), ue.call(this, 8, 16711935), ie.call(this, 1, 1431655765);
            for (var ve = 0; ve < 16; ve++) {
              for (var Pe = be[ve], Ue = this._lBlock, ze = this._rBlock, Le = 0, Ne = 0; Ne < 8; Ne++)
                Le |= Z[Ne][((ze ^ Pe[Ne]) & Y[Ne]) >>> 0];
              this._lBlock = ze, this._rBlock = Ue ^ Le;
            }
            var $e = this._lBlock;
            this._lBlock = this._rBlock, this._rBlock = $e, ie.call(this, 1, 1431655765), ue.call(this, 8, 16711935), ue.call(this, 2, 858993459), ie.call(this, 16, 65535), ie.call(this, 4, 252645135), de[ce] = this._lBlock, de[ce + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function ie(de, ce) {
          var be = (this._lBlock >>> de ^ this._rBlock) & ce;
          this._rBlock ^= be, this._lBlock ^= be << de;
        }
        function ue(de, ce) {
          var be = (this._rBlock >>> de ^ this._lBlock) & ce;
          this._lBlock ^= be, this._rBlock ^= be << de;
        }
        o.DES = B._createHelper(ee);
        var fe = M.TripleDES = B.extend({
          _doReset: function() {
            var de = this._key, ce = de.words;
            if (ce.length !== 2 && ce.length !== 4 && ce.length < 6)
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            var be = ce.slice(0, 2), ve = ce.length < 4 ? ce.slice(0, 2) : ce.slice(2, 4), Pe = ce.length < 6 ? ce.slice(0, 2) : ce.slice(4, 6);
            this._des1 = ee.createEncryptor(g.create(be)), this._des2 = ee.createEncryptor(g.create(ve)), this._des3 = ee.createEncryptor(g.create(Pe));
          },
          encryptBlock: function(de, ce) {
            this._des1.encryptBlock(de, ce), this._des2.decryptBlock(de, ce), this._des3.encryptBlock(de, ce);
          },
          decryptBlock: function(de, ce) {
            this._des3.decryptBlock(de, ce), this._des2.encryptBlock(de, ce), this._des1.decryptBlock(de, ce);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        o.TripleDES = B._createHelper(fe);
      }(), h.TripleDES;
    });
  }(lu)), lu.exports;
}
var du = { exports: {} }, Qd;
function x_() {
  return Qd || (Qd = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), ja(), Wa(), aa(), or());
    })(Me, function(h) {
      return function() {
        var o = h, S = o.lib, g = S.StreamCipher, B = o.algo, M = B.RC4 = g.extend({
          _doReset: function() {
            for (var D = this._key, Z = D.words, Y = D.sigBytes, ee = this._S = [], ie = 0; ie < 256; ie++)
              ee[ie] = ie;
            for (var ie = 0, ue = 0; ie < 256; ie++) {
              var fe = ie % Y, de = Z[fe >>> 2] >>> 24 - fe % 4 * 8 & 255;
              ue = (ue + ee[ie] + de) % 256;
              var ce = ee[ie];
              ee[ie] = ee[ue], ee[ue] = ce;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(D, Z) {
            D[Z] ^= O.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function O() {
          for (var D = this._S, Z = this._i, Y = this._j, ee = 0, ie = 0; ie < 4; ie++) {
            Z = (Z + 1) % 256, Y = (Y + D[Z]) % 256;
            var ue = D[Z];
            D[Z] = D[Y], D[Y] = ue, ee |= D[(D[Z] + D[Y]) % 256] << 24 - ie * 8;
          }
          return this._i = Z, this._j = Y, ee;
        }
        o.RC4 = g._createHelper(M);
        var P = B.RC4Drop = M.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: M.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            M._doReset.call(this);
            for (var D = this.cfg.drop; D > 0; D--)
              O.call(this);
          }
        });
        o.RC4Drop = g._createHelper(P);
      }(), h.RC4;
    });
  }(du)), du.exports;
}
var pu = { exports: {} }, Zd;
function __() {
  return Zd || (Zd = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), ja(), Wa(), aa(), or());
    })(Me, function(h) {
      return function() {
        var o = h, S = o.lib, g = S.StreamCipher, B = o.algo, M = [], O = [], P = [], D = B.Rabbit = g.extend({
          _doReset: function() {
            for (var Y = this._key.words, ee = this.cfg.iv, ie = 0; ie < 4; ie++)
              Y[ie] = (Y[ie] << 8 | Y[ie] >>> 24) & 16711935 | (Y[ie] << 24 | Y[ie] >>> 8) & 4278255360;
            var ue = this._X = [
              Y[0],
              Y[3] << 16 | Y[2] >>> 16,
              Y[1],
              Y[0] << 16 | Y[3] >>> 16,
              Y[2],
              Y[1] << 16 | Y[0] >>> 16,
              Y[3],
              Y[2] << 16 | Y[1] >>> 16
            ], fe = this._C = [
              Y[2] << 16 | Y[2] >>> 16,
              Y[0] & 4294901760 | Y[1] & 65535,
              Y[3] << 16 | Y[3] >>> 16,
              Y[1] & 4294901760 | Y[2] & 65535,
              Y[0] << 16 | Y[0] >>> 16,
              Y[2] & 4294901760 | Y[3] & 65535,
              Y[1] << 16 | Y[1] >>> 16,
              Y[3] & 4294901760 | Y[0] & 65535
            ];
            this._b = 0;
            for (var ie = 0; ie < 4; ie++)
              Z.call(this);
            for (var ie = 0; ie < 8; ie++)
              fe[ie] ^= ue[ie + 4 & 7];
            if (ee) {
              var de = ee.words, ce = de[0], be = de[1], ve = (ce << 8 | ce >>> 24) & 16711935 | (ce << 24 | ce >>> 8) & 4278255360, Pe = (be << 8 | be >>> 24) & 16711935 | (be << 24 | be >>> 8) & 4278255360, Ue = ve >>> 16 | Pe & 4294901760, ze = Pe << 16 | ve & 65535;
              fe[0] ^= ve, fe[1] ^= Ue, fe[2] ^= Pe, fe[3] ^= ze, fe[4] ^= ve, fe[5] ^= Ue, fe[6] ^= Pe, fe[7] ^= ze;
              for (var ie = 0; ie < 4; ie++)
                Z.call(this);
            }
          },
          _doProcessBlock: function(Y, ee) {
            var ie = this._X;
            Z.call(this), M[0] = ie[0] ^ ie[5] >>> 16 ^ ie[3] << 16, M[1] = ie[2] ^ ie[7] >>> 16 ^ ie[5] << 16, M[2] = ie[4] ^ ie[1] >>> 16 ^ ie[7] << 16, M[3] = ie[6] ^ ie[3] >>> 16 ^ ie[1] << 16;
            for (var ue = 0; ue < 4; ue++)
              M[ue] = (M[ue] << 8 | M[ue] >>> 24) & 16711935 | (M[ue] << 24 | M[ue] >>> 8) & 4278255360, Y[ee + ue] ^= M[ue];
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function Z() {
          for (var Y = this._X, ee = this._C, ie = 0; ie < 8; ie++)
            O[ie] = ee[ie];
          ee[0] = ee[0] + 1295307597 + this._b | 0, ee[1] = ee[1] + 3545052371 + (ee[0] >>> 0 < O[0] >>> 0 ? 1 : 0) | 0, ee[2] = ee[2] + 886263092 + (ee[1] >>> 0 < O[1] >>> 0 ? 1 : 0) | 0, ee[3] = ee[3] + 1295307597 + (ee[2] >>> 0 < O[2] >>> 0 ? 1 : 0) | 0, ee[4] = ee[4] + 3545052371 + (ee[3] >>> 0 < O[3] >>> 0 ? 1 : 0) | 0, ee[5] = ee[5] + 886263092 + (ee[4] >>> 0 < O[4] >>> 0 ? 1 : 0) | 0, ee[6] = ee[6] + 1295307597 + (ee[5] >>> 0 < O[5] >>> 0 ? 1 : 0) | 0, ee[7] = ee[7] + 3545052371 + (ee[6] >>> 0 < O[6] >>> 0 ? 1 : 0) | 0, this._b = ee[7] >>> 0 < O[7] >>> 0 ? 1 : 0;
          for (var ie = 0; ie < 8; ie++) {
            var ue = Y[ie] + ee[ie], fe = ue & 65535, de = ue >>> 16, ce = ((fe * fe >>> 17) + fe * de >>> 15) + de * de, be = ((ue & 4294901760) * ue | 0) + ((ue & 65535) * ue | 0);
            P[ie] = ce ^ be;
          }
          Y[0] = P[0] + (P[7] << 16 | P[7] >>> 16) + (P[6] << 16 | P[6] >>> 16) | 0, Y[1] = P[1] + (P[0] << 8 | P[0] >>> 24) + P[7] | 0, Y[2] = P[2] + (P[1] << 16 | P[1] >>> 16) + (P[0] << 16 | P[0] >>> 16) | 0, Y[3] = P[3] + (P[2] << 8 | P[2] >>> 24) + P[1] | 0, Y[4] = P[4] + (P[3] << 16 | P[3] >>> 16) + (P[2] << 16 | P[2] >>> 16) | 0, Y[5] = P[5] + (P[4] << 8 | P[4] >>> 24) + P[3] | 0, Y[6] = P[6] + (P[5] << 16 | P[5] >>> 16) + (P[4] << 16 | P[4] >>> 16) | 0, Y[7] = P[7] + (P[6] << 8 | P[6] >>> 24) + P[5] | 0;
        }
        o.Rabbit = g._createHelper(D);
      }(), h.Rabbit;
    });
  }(pu)), pu.exports;
}
var vu = { exports: {} }, Jd;
function E_() {
  return Jd || (Jd = 1, function(e, t) {
    (function(h, o, S) {
      e.exports = o(xt(), ja(), Wa(), aa(), or());
    })(Me, function(h) {
      return function() {
        var o = h, S = o.lib, g = S.StreamCipher, B = o.algo, M = [], O = [], P = [], D = B.RabbitLegacy = g.extend({
          _doReset: function() {
            var Y = this._key.words, ee = this.cfg.iv, ie = this._X = [
              Y[0],
              Y[3] << 16 | Y[2] >>> 16,
              Y[1],
              Y[0] << 16 | Y[3] >>> 16,
              Y[2],
              Y[1] << 16 | Y[0] >>> 16,
              Y[3],
              Y[2] << 16 | Y[1] >>> 16
            ], ue = this._C = [
              Y[2] << 16 | Y[2] >>> 16,
              Y[0] & 4294901760 | Y[1] & 65535,
              Y[3] << 16 | Y[3] >>> 16,
              Y[1] & 4294901760 | Y[2] & 65535,
              Y[0] << 16 | Y[0] >>> 16,
              Y[2] & 4294901760 | Y[3] & 65535,
              Y[1] << 16 | Y[1] >>> 16,
              Y[3] & 4294901760 | Y[0] & 65535
            ];
            this._b = 0;
            for (var fe = 0; fe < 4; fe++)
              Z.call(this);
            for (var fe = 0; fe < 8; fe++)
              ue[fe] ^= ie[fe + 4 & 7];
            if (ee) {
              var de = ee.words, ce = de[0], be = de[1], ve = (ce << 8 | ce >>> 24) & 16711935 | (ce << 24 | ce >>> 8) & 4278255360, Pe = (be << 8 | be >>> 24) & 16711935 | (be << 24 | be >>> 8) & 4278255360, Ue = ve >>> 16 | Pe & 4294901760, ze = Pe << 16 | ve & 65535;
              ue[0] ^= ve, ue[1] ^= Ue, ue[2] ^= Pe, ue[3] ^= ze, ue[4] ^= ve, ue[5] ^= Ue, ue[6] ^= Pe, ue[7] ^= ze;
              for (var fe = 0; fe < 4; fe++)
                Z.call(this);
            }
          },
          _doProcessBlock: function(Y, ee) {
            var ie = this._X;
            Z.call(this), M[0] = ie[0] ^ ie[5] >>> 16 ^ ie[3] << 16, M[1] = ie[2] ^ ie[7] >>> 16 ^ ie[5] << 16, M[2] = ie[4] ^ ie[1] >>> 16 ^ ie[7] << 16, M[3] = ie[6] ^ ie[3] >>> 16 ^ ie[1] << 16;
            for (var ue = 0; ue < 4; ue++)
              M[ue] = (M[ue] << 8 | M[ue] >>> 24) & 16711935 | (M[ue] << 24 | M[ue] >>> 8) & 4278255360, Y[ee + ue] ^= M[ue];
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function Z() {
          for (var Y = this._X, ee = this._C, ie = 0; ie < 8; ie++)
            O[ie] = ee[ie];
          ee[0] = ee[0] + 1295307597 + this._b | 0, ee[1] = ee[1] + 3545052371 + (ee[0] >>> 0 < O[0] >>> 0 ? 1 : 0) | 0, ee[2] = ee[2] + 886263092 + (ee[1] >>> 0 < O[1] >>> 0 ? 1 : 0) | 0, ee[3] = ee[3] + 1295307597 + (ee[2] >>> 0 < O[2] >>> 0 ? 1 : 0) | 0, ee[4] = ee[4] + 3545052371 + (ee[3] >>> 0 < O[3] >>> 0 ? 1 : 0) | 0, ee[5] = ee[5] + 886263092 + (ee[4] >>> 0 < O[4] >>> 0 ? 1 : 0) | 0, ee[6] = ee[6] + 1295307597 + (ee[5] >>> 0 < O[5] >>> 0 ? 1 : 0) | 0, ee[7] = ee[7] + 3545052371 + (ee[6] >>> 0 < O[6] >>> 0 ? 1 : 0) | 0, this._b = ee[7] >>> 0 < O[7] >>> 0 ? 1 : 0;
          for (var ie = 0; ie < 8; ie++) {
            var ue = Y[ie] + ee[ie], fe = ue & 65535, de = ue >>> 16, ce = ((fe * fe >>> 17) + fe * de >>> 15) + de * de, be = ((ue & 4294901760) * ue | 0) + ((ue & 65535) * ue | 0);
            P[ie] = ce ^ be;
          }
          Y[0] = P[0] + (P[7] << 16 | P[7] >>> 16) + (P[6] << 16 | P[6] >>> 16) | 0, Y[1] = P[1] + (P[0] << 8 | P[0] >>> 24) + P[7] | 0, Y[2] = P[2] + (P[1] << 16 | P[1] >>> 16) + (P[0] << 16 | P[0] >>> 16) | 0, Y[3] = P[3] + (P[2] << 8 | P[2] >>> 24) + P[1] | 0, Y[4] = P[4] + (P[3] << 16 | P[3] >>> 16) + (P[2] << 16 | P[2] >>> 16) | 0, Y[5] = P[5] + (P[4] << 8 | P[4] >>> 24) + P[3] | 0, Y[6] = P[6] + (P[5] << 16 | P[5] >>> 16) + (P[4] << 16 | P[4] >>> 16) | 0, Y[7] = P[7] + (P[6] << 8 | P[6] >>> 24) + P[5] | 0;
        }
        o.RabbitLegacy = g._createHelper(D);
      }(), h.RabbitLegacy;
    });
  }(vu)), vu.exports;
}
(function(e, t) {
  (function(h, o, S) {
    e.exports = o(xt(), If(), J5(), e_(), ja(), t_(), Wa(), wh(), Gy(), r_(), zy(), i_(), n_(), a_(), Ch(), s_(), aa(), or(), f_(), o_(), u_(), c_(), h_(), l_(), d_(), p_(), v_(), y_(), g_(), m_(), b_(), x_(), __(), E_());
  })(Me, function(h) {
    return h;
  });
})(u1);
var S_ = u1.exports;
const Cr = /* @__PURE__ */ Gs(S_), w_ = 0, C_ = 1, A_ = 2, B_ = 61440, I_ = 32768, T_ = 16384, M_ = 8192, R_ = 24576, N_ = 4096, D_ = 40960, O_ = 49152, P_ = 512, L_ = 2048, k_ = 131072, U_ = 1024, F_ = 8, q_ = 1048576, V_ = 256, K_ = 128, $_ = 2097152, H_ = 4, G_ = 448, z_ = 256, j_ = 128, W_ = 64, Y_ = 56, X_ = 32, Q_ = 16, Z_ = 8, J_ = 7, eE = 4, tE = 2, rE = 1, iE = 7, nE = 13, aE = 48, sE = 49, fE = 47, oE = 35, uE = 37, cE = 9, hE = 94, lE = 16, dE = 89, pE = 10, vE = 53, yE = 61, gE = 54, mE = 11, bE = 39, xE = 33, _E = 69, EE = 17, SE = 14, wE = 27, CE = 65, AE = 90, BE = 92, IE = 36, TE = 4, ME = 22, RE = 5, NE = 56, DE = 21, OE = 62, PE = 24, LE = 31, kE = 40, UE = 95, FE = 63, qE = 50, VE = 52, KE = 51, $E = 23, HE = 55, GE = 96, zE = 19, jE = 2, WE = 8, YE = 77, XE = 97, QE = 12, ZE = 91, JE = 42, eS = 28, tS = 98, rS = 99, iS = 78, nS = 57, aS = 20, sS = 66, fS = 38, oS = 45, uS = 25, cS = 6, hS = 102, lS = 84, dS = 1, pS = 32, vS = 100, yS = 43, gS = 41, mS = 34, bS = 30, xS = 29, _S = 3, ES = 70, SS = 101, wS = 60, CS = 26, AS = 35, BS = 18, IS = 1, TS = 2, MS = 3, RS = 4, NS = 5, DS = 6, OS = 6, PS = 10, LS = 8, kS = 9, US = 30, FS = 11, qS = 31, VS = 13, KS = 14, $S = 15, HS = 20, GS = 19, zS = 17, jS = 18, WS = 21, YS = 22, XS = 16, QS = 24, ZS = 25, JS = 26, ew = 27, tw = 28, rw = 23, iw = 12, nw = 2147486719, aw = 262144, sw = 4194304, fw = 32768, ow = 8192, uw = 2147483648, cw = 2048, hw = 0, lw = 4, dw = 32, pw = 1, vw = 0, yw = 536870912, gw = 2, mw = 1073741824, bw = 8, xw = 131072, _w = 4096, Ew = 65536, Sw = 16777216, ww = 33554432, Cw = 16384, Aw = 67108864, Bw = 268435456, Iw = 134217728, Tw = 0, Mw = 0, Rw = 1048576, Nw = 524288, Dw = 128, Ow = 0, Pw = 512, Lw = 256, kw = 8388608, Uw = 2, Fw = 4, qw = 8, Vw = 16, Kw = 32, $w = 64, Hw = 128, Gw = 256, zw = 512, jw = 1024, Ww = 65535, Yw = 0, Xw = 2, Qw = 1, Zw = 4, Jw = 8, e7 = 1, t7 = 1, r7 = 2, i7 = 3, n7 = 4, a7 = 5, s7 = 6, f7 = 2, o7 = 4, u7 = 6, c7 = 0, h7 = 4, l7 = 2, d7 = 1, p7 = 4, Ah = {
  O_RDONLY: w_,
  O_WRONLY: C_,
  O_RDWR: A_,
  S_IFMT: B_,
  S_IFREG: I_,
  S_IFDIR: T_,
  S_IFCHR: M_,
  S_IFBLK: R_,
  S_IFIFO: N_,
  S_IFLNK: D_,
  S_IFSOCK: O_,
  O_CREAT: P_,
  O_EXCL: L_,
  O_NOCTTY: k_,
  O_TRUNC: U_,
  O_APPEND: F_,
  O_DIRECTORY: q_,
  O_NOFOLLOW: V_,
  O_SYNC: K_,
  O_SYMLINK: $_,
  O_NONBLOCK: H_,
  S_IRWXU: G_,
  S_IRUSR: z_,
  S_IWUSR: j_,
  S_IXUSR: W_,
  S_IRWXG: Y_,
  S_IRGRP: X_,
  S_IWGRP: Q_,
  S_IXGRP: Z_,
  S_IRWXO: J_,
  S_IROTH: eE,
  S_IWOTH: tE,
  S_IXOTH: rE,
  E2BIG: iE,
  EACCES: nE,
  EADDRINUSE: aE,
  EADDRNOTAVAIL: sE,
  EAFNOSUPPORT: fE,
  EAGAIN: oE,
  EALREADY: uE,
  EBADF: cE,
  EBADMSG: hE,
  EBUSY: lE,
  ECANCELED: dE,
  ECHILD: pE,
  ECONNABORTED: vE,
  ECONNREFUSED: yE,
  ECONNRESET: gE,
  EDEADLK: mE,
  EDESTADDRREQ: bE,
  EDOM: xE,
  EDQUOT: _E,
  EEXIST: EE,
  EFAULT: SE,
  EFBIG: wE,
  EHOSTUNREACH: CE,
  EIDRM: AE,
  EILSEQ: BE,
  EINPROGRESS: IE,
  EINTR: TE,
  EINVAL: ME,
  EIO: RE,
  EISCONN: NE,
  EISDIR: DE,
  ELOOP: OE,
  EMFILE: PE,
  EMLINK: LE,
  EMSGSIZE: kE,
  EMULTIHOP: UE,
  ENAMETOOLONG: FE,
  ENETDOWN: qE,
  ENETRESET: VE,
  ENETUNREACH: KE,
  ENFILE: $E,
  ENOBUFS: HE,
  ENODATA: GE,
  ENODEV: zE,
  ENOENT: jE,
  ENOEXEC: WE,
  ENOLCK: YE,
  ENOLINK: XE,
  ENOMEM: QE,
  ENOMSG: ZE,
  ENOPROTOOPT: JE,
  ENOSPC: eS,
  ENOSR: tS,
  ENOSTR: rS,
  ENOSYS: iS,
  ENOTCONN: nS,
  ENOTDIR: aS,
  ENOTEMPTY: sS,
  ENOTSOCK: fS,
  ENOTSUP: oS,
  ENOTTY: uS,
  ENXIO: cS,
  EOPNOTSUPP: hS,
  EOVERFLOW: lS,
  EPERM: dS,
  EPIPE: pS,
  EPROTO: vS,
  EPROTONOSUPPORT: yS,
  EPROTOTYPE: gS,
  ERANGE: mS,
  EROFS: bS,
  ESPIPE: xS,
  ESRCH: _S,
  ESTALE: ES,
  ETIME: SS,
  ETIMEDOUT: wS,
  ETXTBSY: CS,
  EWOULDBLOCK: AS,
  EXDEV: BS,
  SIGHUP: IS,
  SIGINT: TS,
  SIGQUIT: MS,
  SIGILL: RS,
  SIGTRAP: NS,
  SIGABRT: DS,
  SIGIOT: OS,
  SIGBUS: PS,
  SIGFPE: LS,
  SIGKILL: kS,
  SIGUSR1: US,
  SIGSEGV: FS,
  SIGUSR2: qS,
  SIGPIPE: VS,
  SIGALRM: KS,
  SIGTERM: $S,
  SIGCHLD: HS,
  SIGCONT: GS,
  SIGSTOP: zS,
  SIGTSTP: jS,
  SIGTTIN: WS,
  SIGTTOU: YS,
  SIGURG: XS,
  SIGXCPU: QS,
  SIGXFSZ: ZS,
  SIGVTALRM: JS,
  SIGPROF: ew,
  SIGWINCH: tw,
  SIGIO: rw,
  SIGSYS: iw,
  SSL_OP_ALL: nw,
  SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION: aw,
  SSL_OP_CIPHER_SERVER_PREFERENCE: sw,
  SSL_OP_CISCO_ANYCONNECT: fw,
  SSL_OP_COOKIE_EXCHANGE: ow,
  SSL_OP_CRYPTOPRO_TLSEXT_BUG: uw,
  SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS: cw,
  SSL_OP_EPHEMERAL_RSA: hw,
  SSL_OP_LEGACY_SERVER_CONNECT: lw,
  SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER: dw,
  SSL_OP_MICROSOFT_SESS_ID_BUG: pw,
  SSL_OP_MSIE_SSLV2_RSA_PADDING: vw,
  SSL_OP_NETSCAPE_CA_DN_BUG: yw,
  SSL_OP_NETSCAPE_CHALLENGE_BUG: gw,
  SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG: mw,
  SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG: bw,
  SSL_OP_NO_COMPRESSION: xw,
  SSL_OP_NO_QUERY_MTU: _w,
  SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION: Ew,
  SSL_OP_NO_SSLv2: Sw,
  SSL_OP_NO_SSLv3: ww,
  SSL_OP_NO_TICKET: Cw,
  SSL_OP_NO_TLSv1: Aw,
  SSL_OP_NO_TLSv1_1: Bw,
  SSL_OP_NO_TLSv1_2: Iw,
  SSL_OP_PKCS1_CHECK_1: Tw,
  SSL_OP_PKCS1_CHECK_2: Mw,
  SSL_OP_SINGLE_DH_USE: Rw,
  SSL_OP_SINGLE_ECDH_USE: Nw,
  SSL_OP_SSLEAY_080_CLIENT_DH_BUG: Dw,
  SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG: Ow,
  SSL_OP_TLS_BLOCK_PADDING_BUG: Pw,
  SSL_OP_TLS_D5_BUG: Lw,
  SSL_OP_TLS_ROLLBACK_BUG: kw,
  ENGINE_METHOD_DSA: Uw,
  ENGINE_METHOD_DH: Fw,
  ENGINE_METHOD_RAND: qw,
  ENGINE_METHOD_ECDH: Vw,
  ENGINE_METHOD_ECDSA: Kw,
  ENGINE_METHOD_CIPHERS: $w,
  ENGINE_METHOD_DIGESTS: Hw,
  ENGINE_METHOD_STORE: Gw,
  ENGINE_METHOD_PKEY_METHS: zw,
  ENGINE_METHOD_PKEY_ASN1_METHS: jw,
  ENGINE_METHOD_ALL: Ww,
  ENGINE_METHOD_NONE: Yw,
  DH_CHECK_P_NOT_SAFE_PRIME: Xw,
  DH_CHECK_P_NOT_PRIME: Qw,
  DH_UNABLE_TO_CHECK_GENERATOR: Zw,
  DH_NOT_SUITABLE_GENERATOR: Jw,
  NPN_ENABLED: e7,
  RSA_PKCS1_PADDING: t7,
  RSA_SSLV23_PADDING: r7,
  RSA_NO_PADDING: i7,
  RSA_PKCS1_OAEP_PADDING: n7,
  RSA_X931_PADDING: a7,
  RSA_PKCS1_PSS_PADDING: s7,
  POINT_CONVERSION_COMPRESSED: f7,
  POINT_CONVERSION_UNCOMPRESSED: o7,
  POINT_CONVERSION_HYBRID: u7,
  F_OK: c7,
  R_OK: h7,
  W_OK: l7,
  X_OK: d7,
  UV_UDP_REUSEADDR: p7
};
var Bh = {}, tr = {};
_r();
tr.linebrk = function(e, t) {
  for (var h = "", o = 0; o + t < e.length; )
    h += e.substring(o, o + t) + `
`, o += t;
  return h + e.substring(o, e.length);
};
tr.detectEnvironment = function() {
  return typeof window < "u" && window && !(Ve && Ve.title === "node") ? "browser" : "node";
};
tr.get32IntFromBuffer = function(e, t) {
  t = t || 0;
  var h = 0;
  if ((h = e.length - t) > 0) {
    if (h >= 4)
      return e.readUIntBE(t, h);
    for (var o = 0, S = t + h, g = 0; S > t; S--, g += 2)
      o += e[S - 1] * Math.pow(16, g);
    return o;
  } else
    return NaN;
};
tr._ = {
  isObject: function(e) {
    var t = typeof e;
    return !!e && (t == "object" || t == "function");
  },
  isString: function(e) {
    return typeof e == "string" || e instanceof String;
  },
  isNumber: function(e) {
    return typeof e == "number" || !isNaN(parseFloat(e)) && isFinite(e);
  },
  /**
   * Returns copy of `obj` without `removeProp` field.
   * @param obj
   * @param removeProp
   * @returns Object
   */
  omit: function(e, t) {
    var h = {};
    for (var o in e)
      !e.hasOwnProperty(o) || o === t || (h[o] = e[o]);
    return h;
  }
};
tr.trimSurroundingText = function(e, t, h) {
  var o = 0, S = e.length, g = e.indexOf(t);
  g >= 0 && (o = g + t.length);
  var B = e.indexOf(h, g);
  return B >= 0 && (S = B), e.substring(o, S);
};
var v7 = _r(), y7 = tr._, Ya;
function Ee(e, t) {
  e != null && (typeof e == "number" ? this.fromNumber(e, t) : pe.Buffer.isBuffer(e) ? this.fromBuffer(e) : t == null && typeof e != "string" ? this.fromByteArray(e) : this.fromString(e, t));
}
function mt() {
  return new Ee(null);
}
function g7(e, t, h, o, S, g) {
  for (var B = t & 16383, M = t >> 14; --g >= 0; ) {
    var O = this[e] & 16383, P = this[e++] >> 14, D = M * O + P * B;
    O = B * O + ((D & 16383) << 14) + h[o] + S, S = (O >> 28) + (D >> 14) + M * P, h[o++] = O & 268435455;
  }
  return S;
}
Ee.prototype.am = g7;
Ya = 28;
Ee.prototype.DB = Ya;
Ee.prototype.DM = (1 << Ya) - 1;
Ee.prototype.DV = 1 << Ya;
var Ih = 52;
Ee.prototype.FV = Math.pow(2, Ih);
Ee.prototype.F1 = Ih - Ya;
Ee.prototype.F2 = 2 * Ya - Ih;
var m7 = "0123456789abcdefghijklmnopqrstuvwxyz", Tf = new Array(), Xa, Kr;
Xa = 48;
for (Kr = 0; Kr <= 9; ++Kr)
  Tf[Xa++] = Kr;
Xa = 97;
for (Kr = 10; Kr < 36; ++Kr)
  Tf[Xa++] = Kr;
Xa = 65;
for (Kr = 10; Kr < 36; ++Kr)
  Tf[Xa++] = Kr;
function vc(e) {
  return m7.charAt(e);
}
function jy(e, t) {
  var h = Tf[e.charCodeAt(t)];
  return h ?? -1;
}
function b7(e) {
  for (var t = this.t - 1; t >= 0; --t)
    e[t] = this[t];
  e.t = this.t, e.s = this.s;
}
function x7(e) {
  this.t = 1, this.s = e < 0 ? -1 : 0, e > 0 ? this[0] = e : e < -1 ? this[0] = e + DV : this.t = 0;
}
function vn(e) {
  var t = mt();
  return t.fromInt(e), t;
}
function _7(e, t, h) {
  var o;
  switch (t) {
    case 2:
      o = 1;
      break;
    case 4:
      o = 2;
      break;
    case 8:
      o = 3;
      break;
    case 16:
      o = 4;
      break;
    case 32:
      o = 5;
      break;
    case 256:
      o = 8;
      break;
    default:
      this.fromRadix(e, t);
      return;
  }
  this.t = 0, this.s = 0;
  for (var S = e.length, g = !1, B = 0; --S >= 0; ) {
    var M = o == 8 ? e[S] & 255 : jy(e, S);
    if (M < 0) {
      e.charAt(S) == "-" && (g = !0);
      continue;
    }
    g = !1, B === 0 ? this[this.t++] = M : B + o > this.DB ? (this[this.t - 1] |= (M & (1 << this.DB - B) - 1) << B, this[this.t++] = M >> this.DB - B) : this[this.t - 1] |= M << B, B += o, B >= this.DB && (B -= this.DB);
  }
  !h && o == 8 && e[0] & 128 && (this.s = -1, B > 0 && (this[this.t - 1] |= (1 << this.DB - B) - 1 << B)), this.clamp(), g && Ee.ZERO.subTo(this, this);
}
function E7(e, t) {
  this.fromString(e, 256, t);
}
function S7(e) {
  this.fromString(e, 256, !0);
}
function w7() {
  for (var e = this.s & this.DM; this.t > 0 && this[this.t - 1] == e; )
    --this.t;
}
function C7(e) {
  if (this.s < 0)
    return "-" + this.negate().toString(e);
  var t;
  if (e == 16)
    t = 4;
  else if (e == 8)
    t = 3;
  else if (e == 2)
    t = 1;
  else if (e == 32)
    t = 5;
  else if (e == 4)
    t = 2;
  else
    return this.toRadix(e);
  var h = (1 << t) - 1, o, S = !1, g = "", B = this.t, M = this.DB - B * this.DB % t;
  if (B-- > 0)
    for (M < this.DB && (o = this[B] >> M) > 0 && (S = !0, g = vc(o)); B >= 0; )
      M < t ? (o = (this[B] & (1 << M) - 1) << t - M, o |= this[--B] >> (M += this.DB - t)) : (o = this[B] >> (M -= t) & h, M <= 0 && (M += this.DB, --B)), o > 0 && (S = !0), S && (g += vc(o));
  return S ? g : "0";
}
function A7() {
  var e = mt();
  return Ee.ZERO.subTo(this, e), e;
}
function B7() {
  return this.s < 0 ? this.negate() : this;
}
function I7(e) {
  var t = this.s - e.s;
  if (t != 0)
    return t;
  var h = this.t;
  if (t = h - e.t, t != 0)
    return this.s < 0 ? -t : t;
  for (; --h >= 0; )
    if ((t = this[h] - e[h]) != 0)
      return t;
  return 0;
}
function Mf(e) {
  var t = 1, h;
  return (h = e >>> 16) != 0 && (e = h, t += 16), (h = e >> 8) != 0 && (e = h, t += 8), (h = e >> 4) != 0 && (e = h, t += 4), (h = e >> 2) != 0 && (e = h, t += 2), (h = e >> 1) != 0 && (e = h, t += 1), t;
}
function T7() {
  return this.t <= 0 ? 0 : this.DB * (this.t - 1) + Mf(this[this.t - 1] ^ this.s & this.DM);
}
function M7(e, t) {
  var h;
  for (h = this.t - 1; h >= 0; --h)
    t[h + e] = this[h];
  for (h = e - 1; h >= 0; --h)
    t[h] = 0;
  t.t = this.t + e, t.s = this.s;
}
function R7(e, t) {
  for (var h = e; h < this.t; ++h)
    t[h - e] = this[h];
  t.t = Math.max(this.t - e, 0), t.s = this.s;
}
function N7(e, t) {
  var h = e % this.DB, o = this.DB - h, S = (1 << o) - 1, g = Math.floor(e / this.DB), B = this.s << h & this.DM, M;
  for (M = this.t - 1; M >= 0; --M)
    t[M + g + 1] = this[M] >> o | B, B = (this[M] & S) << h;
  for (M = g - 1; M >= 0; --M)
    t[M] = 0;
  t[g] = B, t.t = this.t + g + 1, t.s = this.s, t.clamp();
}
function D7(e, t) {
  t.s = this.s;
  var h = Math.floor(e / this.DB);
  if (h >= this.t) {
    t.t = 0;
    return;
  }
  var o = e % this.DB, S = this.DB - o, g = (1 << o) - 1;
  t[0] = this[h] >> o;
  for (var B = h + 1; B < this.t; ++B)
    t[B - h - 1] |= (this[B] & g) << S, t[B - h] = this[B] >> o;
  o > 0 && (t[this.t - h - 1] |= (this.s & g) << S), t.t = this.t - h, t.clamp();
}
function O7(e, t) {
  for (var h = 0, o = 0, S = Math.min(e.t, this.t); h < S; )
    o += this[h] - e[h], t[h++] = o & this.DM, o >>= this.DB;
  if (e.t < this.t) {
    for (o -= e.s; h < this.t; )
      o += this[h], t[h++] = o & this.DM, o >>= this.DB;
    o += this.s;
  } else {
    for (o += this.s; h < e.t; )
      o -= e[h], t[h++] = o & this.DM, o >>= this.DB;
    o -= e.s;
  }
  t.s = o < 0 ? -1 : 0, o < -1 ? t[h++] = this.DV + o : o > 0 && (t[h++] = o), t.t = h, t.clamp();
}
function P7(e, t) {
  var h = this.abs(), o = e.abs(), S = h.t;
  for (t.t = S + o.t; --S >= 0; )
    t[S] = 0;
  for (S = 0; S < o.t; ++S)
    t[S + h.t] = h.am(0, o[S], t, S, 0, h.t);
  t.s = 0, t.clamp(), this.s != e.s && Ee.ZERO.subTo(t, t);
}
function L7(e) {
  for (var t = this.abs(), h = e.t = 2 * t.t; --h >= 0; )
    e[h] = 0;
  for (h = 0; h < t.t - 1; ++h) {
    var o = t.am(h, t[h], e, 2 * h, 0, 1);
    (e[h + t.t] += t.am(h + 1, 2 * t[h], e, 2 * h + 1, o, t.t - h - 1)) >= t.DV && (e[h + t.t] -= t.DV, e[h + t.t + 1] = 1);
  }
  e.t > 0 && (e[e.t - 1] += t.am(h, t[h], e, 2 * h, 0, 1)), e.s = 0, e.clamp();
}
function k7(e, t, h) {
  var o = e.abs();
  if (!(o.t <= 0)) {
    var S = this.abs();
    if (S.t < o.t) {
      t != null && t.fromInt(0), h != null && this.copyTo(h);
      return;
    }
    h == null && (h = mt());
    var g = mt(), B = this.s, M = e.s, O = this.DB - Mf(o[o.t - 1]);
    O > 0 ? (o.lShiftTo(O, g), S.lShiftTo(O, h)) : (o.copyTo(g), S.copyTo(h));
    var P = g.t, D = g[P - 1];
    if (D !== 0) {
      var Z = D * (1 << this.F1) + (P > 1 ? g[P - 2] >> this.F2 : 0), Y = this.FV / Z, ee = (1 << this.F1) / Z, ie = 1 << this.F2, ue = h.t, fe = ue - P, de = t ?? mt();
      for (g.dlShiftTo(fe, de), h.compareTo(de) >= 0 && (h[h.t++] = 1, h.subTo(de, h)), Ee.ONE.dlShiftTo(P, de), de.subTo(g, g); g.t < P; )
        g[g.t++] = 0;
      for (; --fe >= 0; ) {
        var ce = h[--ue] == D ? this.DM : Math.floor(h[ue] * Y + (h[ue - 1] + ie) * ee);
        if ((h[ue] += g.am(0, ce, h, fe, 0, P)) < ce)
          for (g.dlShiftTo(fe, de), h.subTo(de, h); h[ue] < --ce; )
            h.subTo(de, h);
      }
      t != null && (h.drShiftTo(P, t), B != M && Ee.ZERO.subTo(t, t)), h.t = P, h.clamp(), O > 0 && h.rShiftTo(O, h), B < 0 && Ee.ZERO.subTo(h, h);
    }
  }
}
function U7(e) {
  var t = mt();
  return this.abs().divRemTo(e, null, t), this.s < 0 && t.compareTo(Ee.ZERO) > 0 && e.subTo(t, t), t;
}
function sa(e) {
  this.m = e;
}
function F7(e) {
  return e.s < 0 || e.compareTo(this.m) >= 0 ? e.mod(this.m) : e;
}
function q7(e) {
  return e;
}
function V7(e) {
  e.divRemTo(this.m, null, e);
}
function K7(e, t, h) {
  e.multiplyTo(t, h), this.reduce(h);
}
function $7(e, t) {
  e.squareTo(t), this.reduce(t);
}
sa.prototype.convert = F7;
sa.prototype.revert = q7;
sa.prototype.reduce = V7;
sa.prototype.mulTo = K7;
sa.prototype.sqrTo = $7;
function H7() {
  if (this.t < 1)
    return 0;
  var e = this[0];
  if (!(e & 1))
    return 0;
  var t = e & 3;
  return t = t * (2 - (e & 15) * t) & 15, t = t * (2 - (e & 255) * t) & 255, t = t * (2 - ((e & 65535) * t & 65535)) & 65535, t = t * (2 - e * t % this.DV) % this.DV, t > 0 ? this.DV - t : -t;
}
function fa(e) {
  this.m = e, this.mp = e.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << e.DB - 15) - 1, this.mt2 = 2 * e.t;
}
function G7(e) {
  var t = mt();
  return e.abs().dlShiftTo(this.m.t, t), t.divRemTo(this.m, null, t), e.s < 0 && t.compareTo(Ee.ZERO) > 0 && this.m.subTo(t, t), t;
}
function z7(e) {
  var t = mt();
  return e.copyTo(t), this.reduce(t), t;
}
function j7(e) {
  for (; e.t <= this.mt2; )
    e[e.t++] = 0;
  for (var t = 0; t < this.m.t; ++t) {
    var h = e[t] & 32767, o = h * this.mpl + ((h * this.mph + (e[t] >> 15) * this.mpl & this.um) << 15) & e.DM;
    for (h = t + this.m.t, e[h] += this.m.am(0, o, e, t, 0, this.m.t); e[h] >= e.DV; )
      e[h] -= e.DV, e[++h]++;
  }
  e.clamp(), e.drShiftTo(this.m.t, e), e.compareTo(this.m) >= 0 && e.subTo(this.m, e);
}
function W7(e, t) {
  e.squareTo(t), this.reduce(t);
}
function Y7(e, t, h) {
  e.multiplyTo(t, h), this.reduce(h);
}
fa.prototype.convert = G7;
fa.prototype.revert = z7;
fa.prototype.reduce = j7;
fa.prototype.mulTo = Y7;
fa.prototype.sqrTo = W7;
function X7() {
  return (this.t > 0 ? this[0] & 1 : this.s) === 0;
}
function Q7(e, t) {
  if (e > 4294967295 || e < 1)
    return Ee.ONE;
  var h = mt(), o = mt(), S = t.convert(this), g = Mf(e) - 1;
  for (S.copyTo(h); --g >= 0; )
    if (t.sqrTo(h, o), (e & 1 << g) > 0)
      t.mulTo(o, S, h);
    else {
      var B = h;
      h = o, o = B;
    }
  return t.revert(h);
}
function Z7(e, t) {
  var h;
  return e < 256 || t.isEven() ? h = new sa(t) : h = new fa(t), this.exp(e, h);
}
function J7() {
  var e = mt();
  return this.copyTo(e), e;
}
function e9() {
  if (this.s < 0) {
    if (this.t == 1)
      return this[0] - this.DV;
    if (this.t === 0)
      return -1;
  } else {
    if (this.t == 1)
      return this[0];
    if (this.t === 0)
      return 0;
  }
  return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
}
function t9() {
  return this.t == 0 ? this.s : this[0] << 24 >> 24;
}
function r9() {
  return this.t == 0 ? this.s : this[0] << 16 >> 16;
}
function i9(e) {
  return Math.floor(Math.LN2 * this.DB / Math.log(e));
}
function n9() {
  return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this[0] <= 0 ? 0 : 1;
}
function a9(e) {
  if (e == null && (e = 10), this.signum() === 0 || e < 2 || e > 36)
    return "0";
  var t = this.chunkSize(e), h = Math.pow(e, t), o = vn(h), S = mt(), g = mt(), B = "";
  for (this.divRemTo(o, S, g); S.signum() > 0; )
    B = (h + g.intValue()).toString(e).substr(1) + B, S.divRemTo(o, S, g);
  return g.intValue().toString(e) + B;
}
function s9(e, t) {
  this.fromInt(0), t == null && (t = 10);
  for (var h = this.chunkSize(t), o = Math.pow(t, h), S = !1, g = 0, B = 0, M = 0; M < e.length; ++M) {
    var O = jy(e, M);
    if (O < 0) {
      e.charAt(M) == "-" && this.signum() === 0 && (S = !0);
      continue;
    }
    B = t * B + O, ++g >= h && (this.dMultiply(o), this.dAddOffset(B, 0), g = 0, B = 0);
  }
  g > 0 && (this.dMultiply(Math.pow(t, g)), this.dAddOffset(B, 0)), S && Ee.ZERO.subTo(this, this);
}
function f9(e, t) {
  if (typeof t == "number")
    if (e < 2)
      this.fromInt(1);
    else
      for (this.fromNumber(e), this.testBit(e - 1) || this.bitwiseTo(Ee.ONE.shiftLeft(e - 1), Th, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(t); )
        this.dAddOffset(2, 0), this.bitLength() > e && this.subTo(Ee.ONE.shiftLeft(e - 1), this);
  else {
    var h = v7.randomBytes((e >> 3) + 1), o = e & 7;
    o > 0 ? h[0] &= (1 << o) - 1 : h[0] = 0, this.fromByteArray(h);
  }
}
function o9() {
  var e = this.t, t = new Array();
  t[0] = this.s;
  var h = this.DB - e * this.DB % 8, o, S = 0;
  if (e-- > 0)
    for (h < this.DB && (o = this[e] >> h) != (this.s & this.DM) >> h && (t[S++] = o | this.s << this.DB - h); e >= 0; )
      h < 8 ? (o = (this[e] & (1 << h) - 1) << 8 - h, o |= this[--e] >> (h += this.DB - 8)) : (o = this[e] >> (h -= 8) & 255, h <= 0 && (h += this.DB, --e)), o & 128 && (o |= -256), S === 0 && (this.s & 128) != (o & 128) && ++S, (S > 0 || o != this.s) && (t[S++] = o);
  return t;
}
function u9(e) {
  var t = pe.Buffer.from(this.toByteArray());
  if (e === !0 && t[0] === 0)
    t = t.slice(1);
  else if (y7.isNumber(e)) {
    if (t.length > e) {
      for (var h = 0; h < t.length - e; h++)
        if (t[h] !== 0)
          return null;
      return t.slice(t.length - e);
    } else if (t.length < e) {
      var o = pe.Buffer.alloc(e);
      return o.fill(0, 0, e - t.length), t.copy(o, e - t.length), o;
    }
  }
  return t;
}
function c9(e) {
  return this.compareTo(e) == 0;
}
function h9(e) {
  return this.compareTo(e) < 0 ? this : e;
}
function l9(e) {
  return this.compareTo(e) > 0 ? this : e;
}
function d9(e, t, h) {
  var o, S, g = Math.min(e.t, this.t);
  for (o = 0; o < g; ++o)
    h[o] = t(this[o], e[o]);
  if (e.t < this.t) {
    for (S = e.s & this.DM, o = g; o < this.t; ++o)
      h[o] = t(this[o], S);
    h.t = this.t;
  } else {
    for (S = this.s & this.DM, o = g; o < e.t; ++o)
      h[o] = t(S, e[o]);
    h.t = e.t;
  }
  h.s = t(this.s, e.s), h.clamp();
}
function p9(e, t) {
  return e & t;
}
function v9(e) {
  var t = mt();
  return this.bitwiseTo(e, p9, t), t;
}
function Th(e, t) {
  return e | t;
}
function y9(e) {
  var t = mt();
  return this.bitwiseTo(e, Th, t), t;
}
function Wy(e, t) {
  return e ^ t;
}
function g9(e) {
  var t = mt();
  return this.bitwiseTo(e, Wy, t), t;
}
function Yy(e, t) {
  return e & ~t;
}
function m9(e) {
  var t = mt();
  return this.bitwiseTo(e, Yy, t), t;
}
function b9() {
  for (var e = mt(), t = 0; t < this.t; ++t)
    e[t] = this.DM & ~this[t];
  return e.t = this.t, e.s = ~this.s, e;
}
function x9(e) {
  var t = mt();
  return e < 0 ? this.rShiftTo(-e, t) : this.lShiftTo(e, t), t;
}
function _9(e) {
  var t = mt();
  return e < 0 ? this.lShiftTo(-e, t) : this.rShiftTo(e, t), t;
}
function E9(e) {
  if (e === 0)
    return -1;
  var t = 0;
  return e & 65535 || (e >>= 16, t += 16), e & 255 || (e >>= 8, t += 8), e & 15 || (e >>= 4, t += 4), e & 3 || (e >>= 2, t += 2), e & 1 || ++t, t;
}
function S9() {
  for (var e = 0; e < this.t; ++e)
    if (this[e] != 0)
      return e * this.DB + E9(this[e]);
  return this.s < 0 ? this.t * this.DB : -1;
}
function w9(e) {
  for (var t = 0; e != 0; )
    e &= e - 1, ++t;
  return t;
}
function C9() {
  for (var e = 0, t = this.s & this.DM, h = 0; h < this.t; ++h)
    e += w9(this[h] ^ t);
  return e;
}
function A9(e) {
  var t = Math.floor(e / this.DB);
  return t >= this.t ? this.s != 0 : (this[t] & 1 << e % this.DB) != 0;
}
function B9(e, t) {
  var h = Ee.ONE.shiftLeft(e);
  return this.bitwiseTo(h, t, h), h;
}
function I9(e) {
  return this.changeBit(e, Th);
}
function T9(e) {
  return this.changeBit(e, Yy);
}
function M9(e) {
  return this.changeBit(e, Wy);
}
function R9(e, t) {
  for (var h = 0, o = 0, S = Math.min(e.t, this.t); h < S; )
    o += this[h] + e[h], t[h++] = o & this.DM, o >>= this.DB;
  if (e.t < this.t) {
    for (o += e.s; h < this.t; )
      o += this[h], t[h++] = o & this.DM, o >>= this.DB;
    o += this.s;
  } else {
    for (o += this.s; h < e.t; )
      o += e[h], t[h++] = o & this.DM, o >>= this.DB;
    o += e.s;
  }
  t.s = o < 0 ? -1 : 0, o > 0 ? t[h++] = o : o < -1 && (t[h++] = this.DV + o), t.t = h, t.clamp();
}
function N9(e) {
  var t = mt();
  return this.addTo(e, t), t;
}
function D9(e) {
  var t = mt();
  return this.subTo(e, t), t;
}
function O9(e) {
  var t = mt();
  return this.multiplyTo(e, t), t;
}
function P9() {
  var e = mt();
  return this.squareTo(e), e;
}
function L9(e) {
  var t = mt();
  return this.divRemTo(e, t, null), t;
}
function k9(e) {
  var t = mt();
  return this.divRemTo(e, null, t), t;
}
function U9(e) {
  var t = mt(), h = mt();
  return this.divRemTo(e, t, h), new Array(t, h);
}
function F9(e) {
  this[this.t] = this.am(0, e - 1, this, 0, 0, this.t), ++this.t, this.clamp();
}
function q9(e, t) {
  if (e !== 0) {
    for (; this.t <= t; )
      this[this.t++] = 0;
    for (this[t] += e; this[t] >= this.DV; )
      this[t] -= this.DV, ++t >= this.t && (this[this.t++] = 0), ++this[t];
  }
}
function H0() {
}
function Xy(e) {
  return e;
}
function V9(e, t, h) {
  e.multiplyTo(t, h);
}
function K9(e, t) {
  e.squareTo(t);
}
H0.prototype.convert = Xy;
H0.prototype.revert = Xy;
H0.prototype.mulTo = V9;
H0.prototype.sqrTo = K9;
function $9(e) {
  return this.exp(e, new H0());
}
function H9(e, t, h) {
  var o = Math.min(this.t + e.t, t);
  for (h.s = 0, h.t = o; o > 0; )
    h[--o] = 0;
  var S;
  for (S = h.t - this.t; o < S; ++o)
    h[o + this.t] = this.am(0, e[o], h, o, 0, this.t);
  for (S = Math.min(e.t, t); o < S; ++o)
    this.am(0, e[o], h, o, 0, t - o);
  h.clamp();
}
function G9(e, t, h) {
  --t;
  var o = h.t = this.t + e.t - t;
  for (h.s = 0; --o >= 0; )
    h[o] = 0;
  for (o = Math.max(t - this.t, 0); o < e.t; ++o)
    h[this.t + o - t] = this.am(t - o, e[o], h, 0, 0, this.t + o - t);
  h.clamp(), h.drShiftTo(1, h);
}
function Qa(e) {
  this.r2 = mt(), this.q3 = mt(), Ee.ONE.dlShiftTo(2 * e.t, this.r2), this.mu = this.r2.divide(e), this.m = e;
}
function z9(e) {
  if (e.s < 0 || e.t > 2 * this.m.t)
    return e.mod(this.m);
  if (e.compareTo(this.m) < 0)
    return e;
  var t = mt();
  return e.copyTo(t), this.reduce(t), t;
}
function j9(e) {
  return e;
}
function W9(e) {
  for (e.drShiftTo(this.m.t - 1, this.r2), e.t > this.m.t + 1 && (e.t = this.m.t + 1, e.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); e.compareTo(this.r2) < 0; )
    e.dAddOffset(1, this.m.t + 1);
  for (e.subTo(this.r2, e); e.compareTo(this.m) >= 0; )
    e.subTo(this.m, e);
}
function Y9(e, t) {
  e.squareTo(t), this.reduce(t);
}
function X9(e, t, h) {
  e.multiplyTo(t, h), this.reduce(h);
}
Qa.prototype.convert = z9;
Qa.prototype.revert = j9;
Qa.prototype.reduce = W9;
Qa.prototype.mulTo = X9;
Qa.prototype.sqrTo = Y9;
function Q9(e, t) {
  var h = e.bitLength(), o, S = vn(1), g;
  if (h <= 0)
    return S;
  h < 18 ? o = 1 : h < 48 ? o = 3 : h < 144 ? o = 4 : h < 768 ? o = 5 : o = 6, h < 8 ? g = new sa(t) : t.isEven() ? g = new Qa(t) : g = new fa(t);
  var B = new Array(), M = 3, O = o - 1, P = (1 << o) - 1;
  if (B[1] = g.convert(this), o > 1) {
    var D = mt();
    for (g.sqrTo(B[1], D); M <= P; )
      B[M] = mt(), g.mulTo(D, B[M - 2], B[M]), M += 2;
  }
  var Z = e.t - 1, Y, ee = !0, ie = mt(), ue;
  for (h = Mf(e[Z]) - 1; Z >= 0; ) {
    for (h >= O ? Y = e[Z] >> h - O & P : (Y = (e[Z] & (1 << h + 1) - 1) << O - h, Z > 0 && (Y |= e[Z - 1] >> this.DB + h - O)), M = o; !(Y & 1); )
      Y >>= 1, --M;
    if ((h -= M) < 0 && (h += this.DB, --Z), ee)
      B[Y].copyTo(S), ee = !1;
    else {
      for (; M > 1; )
        g.sqrTo(S, ie), g.sqrTo(ie, S), M -= 2;
      M > 0 ? g.sqrTo(S, ie) : (ue = S, S = ie, ie = ue), g.mulTo(ie, B[Y], S);
    }
    for (; Z >= 0 && !(e[Z] & 1 << h); )
      g.sqrTo(S, ie), ue = S, S = ie, ie = ue, --h < 0 && (h = this.DB - 1, --Z);
  }
  return g.revert(S);
}
function Z9(e) {
  var t = this.s < 0 ? this.negate() : this.clone(), h = e.s < 0 ? e.negate() : e.clone();
  if (t.compareTo(h) < 0) {
    var o = t;
    t = h, h = o;
  }
  var S = t.getLowestSetBit(), g = h.getLowestSetBit();
  if (g < 0)
    return t;
  for (S < g && (g = S), g > 0 && (t.rShiftTo(g, t), h.rShiftTo(g, h)); t.signum() > 0; )
    (S = t.getLowestSetBit()) > 0 && t.rShiftTo(S, t), (S = h.getLowestSetBit()) > 0 && h.rShiftTo(S, h), t.compareTo(h) >= 0 ? (t.subTo(h, t), t.rShiftTo(1, t)) : (h.subTo(t, h), h.rShiftTo(1, h));
  return g > 0 && h.lShiftTo(g, h), h;
}
function J9(e) {
  if (e <= 0)
    return 0;
  var t = this.DV % e, h = this.s < 0 ? e - 1 : 0;
  if (this.t > 0)
    if (t === 0)
      h = this[0] % e;
    else
      for (var o = this.t - 1; o >= 0; --o)
        h = (t * h + this[o]) % e;
  return h;
}
function eC(e) {
  var t = e.isEven();
  if (this.isEven() && t || e.signum() === 0)
    return Ee.ZERO;
  for (var h = e.clone(), o = this.clone(), S = vn(1), g = vn(0), B = vn(0), M = vn(1); h.signum() != 0; ) {
    for (; h.isEven(); )
      h.rShiftTo(1, h), t ? ((!S.isEven() || !g.isEven()) && (S.addTo(this, S), g.subTo(e, g)), S.rShiftTo(1, S)) : g.isEven() || g.subTo(e, g), g.rShiftTo(1, g);
    for (; o.isEven(); )
      o.rShiftTo(1, o), t ? ((!B.isEven() || !M.isEven()) && (B.addTo(this, B), M.subTo(e, M)), B.rShiftTo(1, B)) : M.isEven() || M.subTo(e, M), M.rShiftTo(1, M);
    h.compareTo(o) >= 0 ? (h.subTo(o, h), t && S.subTo(B, S), g.subTo(M, g)) : (o.subTo(h, o), t && B.subTo(S, B), M.subTo(g, M));
  }
  if (o.compareTo(Ee.ONE) != 0)
    return Ee.ZERO;
  if (M.compareTo(e) >= 0)
    return M.subtract(e);
  if (M.signum() < 0)
    M.addTo(e, M);
  else
    return M;
  return M.signum() < 0 ? M.add(e) : M;
}
var gr = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997], tC = (1 << 26) / gr[gr.length - 1];
function rC(e) {
  var t, h = this.abs();
  if (h.t == 1 && h[0] <= gr[gr.length - 1]) {
    for (t = 0; t < gr.length; ++t)
      if (h[0] == gr[t])
        return !0;
    return !1;
  }
  if (h.isEven())
    return !1;
  for (t = 1; t < gr.length; ) {
    for (var o = gr[t], S = t + 1; S < gr.length && o < tC; )
      o *= gr[S++];
    for (o = h.modInt(o); t < S; )
      if (o % gr[t++] === 0)
        return !1;
  }
  return h.millerRabin(e);
}
function iC(e) {
  var t = this.subtract(Ee.ONE), h = t.getLowestSetBit();
  if (h <= 0)
    return !1;
  var o = t.shiftRight(h);
  e = e + 1 >> 1, e > gr.length && (e = gr.length);
  for (var S = mt(), g = 0; g < e; ++g) {
    S.fromInt(gr[Math.floor(Math.random() * gr.length)]);
    var B = S.modPow(o, this);
    if (B.compareTo(Ee.ONE) != 0 && B.compareTo(t) != 0) {
      for (var M = 1; M++ < h && B.compareTo(t) != 0; )
        if (B = B.modPowInt(2, this), B.compareTo(Ee.ONE) === 0)
          return !1;
      if (B.compareTo(t) != 0)
        return !1;
    }
  }
  return !0;
}
Ee.prototype.copyTo = b7;
Ee.prototype.fromInt = x7;
Ee.prototype.fromString = _7;
Ee.prototype.fromByteArray = E7;
Ee.prototype.fromBuffer = S7;
Ee.prototype.clamp = w7;
Ee.prototype.dlShiftTo = M7;
Ee.prototype.drShiftTo = R7;
Ee.prototype.lShiftTo = N7;
Ee.prototype.rShiftTo = D7;
Ee.prototype.subTo = O7;
Ee.prototype.multiplyTo = P7;
Ee.prototype.squareTo = L7;
Ee.prototype.divRemTo = k7;
Ee.prototype.invDigit = H7;
Ee.prototype.isEven = X7;
Ee.prototype.exp = Q7;
Ee.prototype.chunkSize = i9;
Ee.prototype.toRadix = a9;
Ee.prototype.fromRadix = s9;
Ee.prototype.fromNumber = f9;
Ee.prototype.bitwiseTo = d9;
Ee.prototype.changeBit = B9;
Ee.prototype.addTo = R9;
Ee.prototype.dMultiply = F9;
Ee.prototype.dAddOffset = q9;
Ee.prototype.multiplyLowerTo = H9;
Ee.prototype.multiplyUpperTo = G9;
Ee.prototype.modInt = J9;
Ee.prototype.millerRabin = iC;
Ee.prototype.toString = C7;
Ee.prototype.negate = A7;
Ee.prototype.abs = B7;
Ee.prototype.compareTo = I7;
Ee.prototype.bitLength = T7;
Ee.prototype.mod = U7;
Ee.prototype.modPowInt = Z7;
Ee.prototype.clone = J7;
Ee.prototype.intValue = e9;
Ee.prototype.byteValue = t9;
Ee.prototype.shortValue = r9;
Ee.prototype.signum = n9;
Ee.prototype.toByteArray = o9;
Ee.prototype.toBuffer = u9;
Ee.prototype.equals = c9;
Ee.prototype.min = h9;
Ee.prototype.max = l9;
Ee.prototype.and = v9;
Ee.prototype.or = y9;
Ee.prototype.xor = g9;
Ee.prototype.andNot = m9;
Ee.prototype.not = b9;
Ee.prototype.shiftLeft = x9;
Ee.prototype.shiftRight = _9;
Ee.prototype.getLowestSetBit = S9;
Ee.prototype.bitCount = C9;
Ee.prototype.testBit = A9;
Ee.prototype.setBit = I9;
Ee.prototype.clearBit = T9;
Ee.prototype.flipBit = M9;
Ee.prototype.add = N9;
Ee.prototype.subtract = D9;
Ee.prototype.multiply = O9;
Ee.prototype.divide = L9;
Ee.prototype.remainder = k9;
Ee.prototype.divideAndRemainder = U9;
Ee.prototype.modPow = Q9;
Ee.prototype.modInverse = eC;
Ee.prototype.pow = $9;
Ee.prototype.gcd = Z9;
Ee.prototype.isProbablePrime = rC;
Ee.int2char = vc;
Ee.ZERO = vn(0);
Ee.ONE = vn(1);
Ee.prototype.square = P9;
var G0 = Ee, yu = { exports: {} }, Mh = { exports: {} }, ep = G0, la = _r(), ts = Ah, nC = {
  md2: pe.Buffer.from("3020300c06082a864886f70d020205000410", "hex"),
  md5: pe.Buffer.from("3020300c06082a864886f70d020505000410", "hex"),
  sha1: pe.Buffer.from("3021300906052b0e03021a05000414", "hex"),
  sha224: pe.Buffer.from("302d300d06096086480165030402040500041c", "hex"),
  sha256: pe.Buffer.from("3031300d060960864801650304020105000420", "hex"),
  sha384: pe.Buffer.from("3041300d060960864801650304020205000430", "hex"),
  sha512: pe.Buffer.from("3051300d060960864801650304020305000440", "hex"),
  ripemd160: pe.Buffer.from("3021300906052b2403020105000414", "hex"),
  rmd160: pe.Buffer.from("3021300906052b2403020105000414", "hex")
}, tp = {
  ripemd160: "rmd160"
}, rp = "sha256";
Mh.exports = {
  isEncryption: !0,
  isSignature: !0
};
Mh.exports.makeScheme = function(e, t) {
  function h(o, S) {
    this.key = o, this.options = S;
  }
  return h.prototype.maxMessageLength = function() {
    return this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == ts.RSA_NO_PADDING ? this.key.encryptedDataLength : this.key.encryptedDataLength - 11;
  }, h.prototype.encPad = function(o, S) {
    S = S || {};
    var g;
    if (o.length > this.key.maxMessageLength)
      throw new Error("Message too long for RSA (n=" + this.key.encryptedDataLength + ", l=" + o.length + ")");
    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == ts.RSA_NO_PADDING)
      return g = pe.Buffer.alloc(this.key.maxMessageLength - o.length), g.fill(0), pe.Buffer.concat([g, o]);
    if (S.type === 1)
      return g = pe.Buffer.alloc(this.key.encryptedDataLength - o.length - 1), g.fill(255, 0, g.length - 1), g[0] = 1, g[g.length - 1] = 0, pe.Buffer.concat([g, o]);
    g = pe.Buffer.alloc(this.key.encryptedDataLength - o.length), g[0] = 0, g[1] = 2;
    for (var B = la.randomBytes(g.length - 3), M = 0; M < B.length; M++) {
      for (var O = B[M]; O === 0; )
        O = la.randomBytes(1)[0];
      g[M + 2] = O;
    }
    return g[g.length - 1] = 0, pe.Buffer.concat([g, o]);
  }, h.prototype.encUnPad = function(o, S) {
    S = S || {};
    var g = 0;
    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == ts.RSA_NO_PADDING) {
      var B;
      return typeof o.lastIndexOf == "function" ? B = o.slice(o.lastIndexOf("\0") + 1, o.length) : B = o.slice(String.prototype.lastIndexOf.call(o, "\0") + 1, o.length), B;
    }
    if (o.length < 4)
      return null;
    if (S.type === 1) {
      if (o[0] !== 0 || o[1] !== 1)
        return null;
      for (g = 3; o[g] !== 0; )
        if (o[g] != 255 || ++g >= o.length)
          return null;
    } else {
      if (o[0] !== 0 || o[1] !== 2)
        return null;
      for (g = 3; o[g] !== 0; )
        if (++g >= o.length)
          return null;
    }
    return o.slice(g + 1, o.length);
  }, h.prototype.sign = function(o) {
    var S = this.options.signingSchemeOptions.hash || rp;
    if (this.options.environment === "browser") {
      S = tp[S] || S;
      var g = la.createHash(S);
      g.update(o);
      var B = this.pkcs1pad(g.digest(), S), M = this.key.$doPrivate(new ep(B)).toBuffer(this.key.encryptedDataLength);
      return M;
    } else {
      var O = la.createSign("RSA-" + S.toUpperCase());
      return O.update(o), O.sign(this.options.rsaUtils.exportKey("private"));
    }
  }, h.prototype.verify = function(o, S, g) {
    if (this.options.encryptionSchemeOptions && this.options.encryptionSchemeOptions.padding == ts.RSA_NO_PADDING)
      return !1;
    var B = this.options.signingSchemeOptions.hash || rp;
    if (this.options.environment === "browser") {
      B = tp[B] || B, g && (S = pe.Buffer.from(S, g));
      var M = la.createHash(B);
      M.update(o);
      var O = this.pkcs1pad(M.digest(), B), P = this.key.$doPublic(new ep(S));
      return P.toBuffer().toString("hex") == O.toString("hex");
    } else {
      var D = la.createVerify("RSA-" + B.toUpperCase());
      return D.update(o), D.verify(this.options.rsaUtils.exportKey("public"), S, g);
    }
  }, h.prototype.pkcs0pad = function(o) {
    var S = pe.Buffer.alloc(this.key.maxMessageLength - o.length);
    return S.fill(0), pe.Buffer.concat([S, o]);
  }, h.prototype.pkcs0unpad = function(o) {
    var S;
    return typeof o.lastIndexOf == "function" ? S = o.slice(o.lastIndexOf("\0") + 1, o.length) : S = o.slice(String.prototype.lastIndexOf.call(o, "\0") + 1, o.length), S;
  }, h.prototype.pkcs1pad = function(o, S) {
    var g = nC[S];
    if (!g)
      throw Error("Unsupported hash algorithm");
    var B = pe.Buffer.concat([g, o]);
    if (B.length + 10 > this.key.encryptedDataLength)
      throw Error("Key is too short for signing algorithm (" + S + ")");
    var M = pe.Buffer.alloc(this.key.encryptedDataLength - B.length - 1);
    M.fill(255, 0, M.length - 1), M[0] = 1, M[M.length - 1] = 0;
    var O = pe.Buffer.concat([M, B]);
    return O;
  }, new h(e, t);
};
var aC = Mh.exports, Qy = { exports: {} };
(function(e) {
  var t = _r();
  e.exports = {
    isEncryption: !0,
    isSignature: !1
  }, e.exports.digestLength = {
    md4: 16,
    md5: 16,
    ripemd160: 20,
    rmd160: 20,
    sha1: 20,
    sha224: 28,
    sha256: 32,
    sha384: 48,
    sha512: 64
  };
  var h = "sha1";
  e.exports.eme_oaep_mgf1 = function(o, S, g) {
    g = g || h;
    for (var B = e.exports.digestLength[g], M = Math.ceil(S / B), O = pe.Buffer.alloc(B * M), P = pe.Buffer.alloc(4), D = 0; D < M; ++D) {
      var Z = t.createHash(g);
      Z.update(o), P.writeUInt32BE(D, 0), Z.update(P), Z.digest().copy(O, D * B);
    }
    return O.slice(0, S);
  }, e.exports.makeScheme = function(o, S) {
    function g(B, M) {
      this.key = B, this.options = M;
    }
    return g.prototype.maxMessageLength = function() {
      return this.key.encryptedDataLength - 2 * e.exports.digestLength[this.options.encryptionSchemeOptions.hash || h] - 2;
    }, g.prototype.encPad = function(B) {
      var M = this.options.encryptionSchemeOptions.hash || h, O = this.options.encryptionSchemeOptions.mgf || e.exports.eme_oaep_mgf1, P = this.options.encryptionSchemeOptions.label || pe.Buffer.alloc(0), D = this.key.encryptedDataLength, Z = e.exports.digestLength[M];
      if (B.length > D - 2 * Z - 2)
        throw new Error("Message is too long to encode into an encoded message with a length of " + D + " bytes, increaseemLen to fix this error (minimum value for given parameters and options: " + (D - 2 * Z - 2) + ")");
      var Y = t.createHash(M);
      Y.update(P), Y = Y.digest();
      var ee = pe.Buffer.alloc(D - B.length - 2 * Z - 1);
      ee.fill(0), ee[ee.length - 1] = 1;
      for (var ie = pe.Buffer.concat([Y, ee, B]), ue = t.randomBytes(Z), fe = O(ue, ie.length, M), de = 0; de < ie.length; de++)
        ie[de] ^= fe[de];
      for (fe = O(ie, Z, M), de = 0; de < ue.length; de++)
        ue[de] ^= fe[de];
      var ce = pe.Buffer.alloc(1 + ue.length + ie.length);
      return ce[0] = 0, ue.copy(ce, 1), ie.copy(ce, 1 + ue.length), ce;
    }, g.prototype.encUnPad = function(B) {
      var M = this.options.encryptionSchemeOptions.hash || h, O = this.options.encryptionSchemeOptions.mgf || e.exports.eme_oaep_mgf1, P = this.options.encryptionSchemeOptions.label || pe.Buffer.alloc(0), D = e.exports.digestLength[M];
      if (B.length < 2 * D + 2)
        throw new Error("Error decoding message, the supplied message is not long enough to be a valid OAEP encoded message");
      for (var Z = B.slice(1, D + 1), Y = B.slice(1 + D), ee = O(Y, D, M), ie = 0; ie < Z.length; ie++)
        Z[ie] ^= ee[ie];
      for (ee = O(Z, Y.length, M), ie = 0; ie < Y.length; ie++)
        Y[ie] ^= ee[ie];
      var ue = t.createHash(M);
      ue.update(P), ue = ue.digest();
      var fe = Y.slice(0, D);
      if (fe.toString("hex") != ue.toString("hex"))
        throw new Error("Error decoding message, the lHash calculated from the label provided and the lHash in the encrypted data do not match.");
      for (ie = D; Y[ie++] === 0 && ie < Y.length; )
        ;
      if (Y[ie - 1] != 1)
        throw new Error("Error decoding message, there is no padding message separator byte");
      return Y.slice(ie);
    }, new g(o, S);
  };
})(Qy);
var sC = Qy.exports, rs = { exports: {} }, ip;
function fC() {
  if (ip)
    return rs.exports;
  ip = 1;
  var e = G0, t = _r();
  rs.exports = {
    isEncryption: !1,
    isSignature: !0
  };
  var h = "sha1", o = 20;
  return rs.exports.makeScheme = function(S, g) {
    var B = Za().pkcs1_oaep;
    function M(O, P) {
      this.key = O, this.options = P;
    }
    return M.prototype.sign = function(O) {
      var P = t.createHash(this.options.signingSchemeOptions.hash || h);
      P.update(O);
      var D = this.emsa_pss_encode(P.digest(), this.key.keySize - 1);
      return this.key.$doPrivate(new e(D)).toBuffer(this.key.encryptedDataLength);
    }, M.prototype.verify = function(O, P, D) {
      D && (P = pe.Buffer.from(P, D)), P = new e(P);
      var Z = Math.ceil((this.key.keySize - 1) / 8), Y = this.key.$doPublic(P).toBuffer(Z), ee = t.createHash(this.options.signingSchemeOptions.hash || h);
      return ee.update(O), this.emsa_pss_verify(ee.digest(), Y, this.key.keySize - 1);
    }, M.prototype.emsa_pss_encode = function(O, P) {
      var D = this.options.signingSchemeOptions.hash || h, Z = this.options.signingSchemeOptions.mgf || B.eme_oaep_mgf1, Y = this.options.signingSchemeOptions.saltLength || o, ee = B.digestLength[D], ie = Math.ceil(P / 8);
      if (ie < ee + Y + 2)
        throw new Error(
          "Output length passed to emBits(" + P + ") is too small for the options specified(" + D + ", " + Y + "). To fix this issue increase the value of emBits. (minimum size: " + (8 * ee + 8 * Y + 9) + ")"
        );
      var ue = t.randomBytes(Y), fe = pe.Buffer.alloc(8 + ee + Y);
      fe.fill(0, 0, 8), O.copy(fe, 8), ue.copy(fe, 8 + O.length);
      var de = t.createHash(D);
      de.update(fe), de = de.digest();
      var ce = pe.Buffer.alloc(ie - ue.length - ee - 2);
      ce.fill(0);
      var be = pe.Buffer.alloc(ce.length + 1 + ue.length);
      ce.copy(be), be[ce.length] = 1, ue.copy(be, ce.length + 1);
      for (var ve = Z(de, be.length, D), Pe = pe.Buffer.alloc(be.length), Ue = 0; Ue < ve.length; Ue++)
        Pe[Ue] = be[Ue] ^ ve[Ue];
      var ze = 8 * ie - P, Le = 255 ^ 255 >> 8 - ze << 8 - ze;
      Pe[0] = Pe[0] & Le;
      var Ne = pe.Buffer.alloc(Pe.length + de.length + 1);
      return Pe.copy(Ne, 0), de.copy(Ne, Pe.length), Ne[Ne.length - 1] = 188, Ne;
    }, M.prototype.emsa_pss_verify = function(O, P, D) {
      var Z = this.options.signingSchemeOptions.hash || h, Y = this.options.signingSchemeOptions.mgf || B.eme_oaep_mgf1, ee = this.options.signingSchemeOptions.saltLength || o, ie = B.digestLength[Z], ue = Math.ceil(D / 8);
      if (ue < ie + ee + 2 || P[P.length - 1] != 188)
        return !1;
      var fe = pe.Buffer.alloc(ue - ie - 1);
      P.copy(fe, 0, 0, ue - ie - 1);
      for (var de = 0, ce = 0, be = 8 * ue - D; ce < be; ce++)
        de |= 1 << 7 - ce;
      if (fe[0] & de)
        return !1;
      var ve = P.slice(ue - ie - 1, ue - 1), Pe = Y(ve, fe.length, Z);
      for (ce = 0; ce < fe.length; ce++)
        fe[ce] ^= Pe[ce];
      for (be = 8 * ue - D, de = 255 ^ 255 >> 8 - be << 8 - be, fe[0] = fe[0] & de, ce = 0; fe[ce] === 0 && ce < fe.length; ce++)
        ;
      if (fe[ce] != 1)
        return !1;
      var Ue = fe.slice(fe.length - ee), ze = pe.Buffer.alloc(8 + ie + ee);
      ze.fill(0, 0, 8), O.copy(ze, 8), Ue.copy(ze, 8 + O.length);
      var Le = t.createHash(Z);
      return Le.update(ze), Le = Le.digest(), ve.toString("hex") === Le.toString("hex");
    }, new M(S, g);
  }, rs.exports;
}
var np;
function Za() {
  return np || (np = 1, function(e) {
    e.exports = {
      pkcs1: aC,
      pkcs1_oaep: sC,
      pss: fC(),
      /**
       * Check if scheme has padding methods
       * @param scheme {string}
       * @returns {Boolean}
       */
      isEncryption: function(t) {
        return e.exports[t] && e.exports[t].isEncryption;
      },
      /**
       * Check if scheme has sign/verify methods
       * @param scheme {string}
       * @returns {Boolean}
       */
      isSignature: function(t) {
        return e.exports[t] && e.exports[t].isSignature;
      }
    };
  }(yu)), yu.exports;
}
var gu, ap;
function Zy() {
  if (ap)
    return gu;
  ap = 1;
  var e = G0, t = Za();
  return gu = function(h, o) {
    var S = t.pkcs1.makeScheme(h, o);
    return {
      encrypt: function(g, B) {
        var M, O;
        return B ? (M = new e(S.encPad(g, { type: 1 })), O = h.$doPrivate(M)) : (M = new e(h.encryptionScheme.encPad(g)), O = h.$doPublic(M)), O.toBuffer(h.encryptedDataLength);
      },
      decrypt: function(g, B) {
        var M, O = new e(g);
        return B ? (M = h.$doPublic(O), S.encUnPad(M.toBuffer(h.encryptedDataLength), { type: 1 })) : (M = h.$doPrivate(O), h.encryptionScheme.encUnPad(M.toBuffer(h.encryptedDataLength)));
      }
    };
  }, gu;
}
var mu, sp;
function oC() {
  if (sp)
    return mu;
  sp = 1;
  var e = _r(), t = Ah, h = Za();
  return mu = function(o, S) {
    var g = h.pkcs1.makeScheme(o, S);
    return {
      encrypt: function(B, M) {
        var O;
        if (M)
          return O = t.RSA_PKCS1_PADDING, S.encryptionSchemeOptions && S.encryptionSchemeOptions.padding && (O = S.encryptionSchemeOptions.padding), e.privateEncrypt({
            key: S.rsaUtils.exportKey("private"),
            padding: O
          }, B);
        O = t.RSA_PKCS1_OAEP_PADDING, S.encryptionScheme === "pkcs1" && (O = t.RSA_PKCS1_PADDING), S.encryptionSchemeOptions && S.encryptionSchemeOptions.padding && (O = S.encryptionSchemeOptions.padding);
        var P = B;
        return O === t.RSA_NO_PADDING && (P = g.pkcs0pad(B)), e.publicEncrypt({
          key: S.rsaUtils.exportKey("public"),
          padding: O
        }, P);
      },
      decrypt: function(B, M) {
        var O;
        if (M)
          return O = t.RSA_PKCS1_PADDING, S.encryptionSchemeOptions && S.encryptionSchemeOptions.padding && (O = S.encryptionSchemeOptions.padding), e.publicDecrypt({
            key: S.rsaUtils.exportKey("public"),
            padding: O
          }, B);
        O = t.RSA_PKCS1_OAEP_PADDING, S.encryptionScheme === "pkcs1" && (O = t.RSA_PKCS1_PADDING), S.encryptionSchemeOptions && S.encryptionSchemeOptions.padding && (O = S.encryptionSchemeOptions.padding);
        var P = e.privateDecrypt({
          key: S.rsaUtils.exportKey("private"),
          padding: O
        }, B);
        return O === t.RSA_NO_PADDING ? g.pkcs0unpad(P) : P;
      }
    };
  }, mu;
}
var bu, fp;
function uC() {
  if (fp)
    return bu;
  fp = 1;
  var e = _r(), t = Ah, h = Za();
  return bu = function(o, S) {
    var g = Zy()(o, S), B = h.pkcs1.makeScheme(o, S);
    return {
      encrypt: function(M, O) {
        if (O)
          return g.encrypt(M, O);
        var P = t.RSA_PKCS1_OAEP_PADDING;
        S.encryptionScheme === "pkcs1" && (P = t.RSA_PKCS1_PADDING), S.encryptionSchemeOptions && S.encryptionSchemeOptions.padding && (P = S.encryptionSchemeOptions.padding);
        var D = M;
        return P === t.RSA_NO_PADDING && (D = B.pkcs0pad(M)), e.publicEncrypt({
          key: S.rsaUtils.exportKey("public"),
          padding: P
        }, D);
      },
      decrypt: function(M, O) {
        if (O)
          return g.decrypt(M, O);
        var P = t.RSA_PKCS1_OAEP_PADDING;
        S.encryptionScheme === "pkcs1" && (P = t.RSA_PKCS1_PADDING), S.encryptionSchemeOptions && S.encryptionSchemeOptions.padding && (P = S.encryptionSchemeOptions.padding);
        var D = e.privateDecrypt({
          key: S.rsaUtils.exportKey("private"),
          padding: P
        }, M);
        return P === t.RSA_NO_PADDING ? B.pkcs0unpad(D) : D;
      }
    };
  }, bu;
}
var is = _r(), cC = {
  getEngine: function(e, t) {
    var h = Zy();
    return t.environment === "node" && typeof is.publicEncrypt == "function" && typeof is.privateDecrypt == "function" && (typeof is.privateEncrypt == "function" && typeof is.publicDecrypt == "function" ? h = oC() : h = uC()), h(e, t);
  }
}, ns = tr._;
_r();
var zt = G0, op = tr, up = Za(), hC = cC;
Bh.BigInteger = zt;
Bh.Key = function() {
  function e() {
    this.n = null, this.e = 0, this.d = null, this.p = null, this.q = null, this.dmp1 = null, this.dmq1 = null, this.coeff = null;
  }
  return e.prototype.setOptions = function(t) {
    var h = up[t.signingScheme], o = up[t.encryptionScheme];
    h === o ? this.signingScheme = this.encryptionScheme = o.makeScheme(this, t) : (this.encryptionScheme = o.makeScheme(this, t), this.signingScheme = h.makeScheme(this, t)), this.encryptEngine = hC.getEngine(this, t);
  }, e.prototype.generate = function(t, h) {
    var o = t >> 1;
    this.e = parseInt(h, 16);
    for (var S = new zt(h, 16); ; ) {
      for (; this.p = new zt(t - o, 1), !(this.p.subtract(zt.ONE).gcd(S).compareTo(zt.ONE) === 0 && this.p.isProbablePrime(10)); )
        ;
      for (; this.q = new zt(o, 1), !(this.q.subtract(zt.ONE).gcd(S).compareTo(zt.ONE) === 0 && this.q.isProbablePrime(10)); )
        ;
      if (this.p.compareTo(this.q) <= 0) {
        var g = this.p;
        this.p = this.q, this.q = g;
      }
      var B = this.p.subtract(zt.ONE), M = this.q.subtract(zt.ONE), O = B.multiply(M);
      if (O.gcd(S).compareTo(zt.ONE) === 0) {
        if (this.n = this.p.multiply(this.q), this.n.bitLength() < t)
          continue;
        this.d = S.modInverse(O), this.dmp1 = this.d.mod(B), this.dmq1 = this.d.mod(M), this.coeff = this.q.modInverse(this.p);
        break;
      }
    }
    this.$$recalculateCache();
  }, e.prototype.setPrivate = function(t, h, o, S, g, B, M, O) {
    if (t && h && o && t.length > 0 && (ns.isNumber(h) || h.length > 0) && o.length > 0)
      this.n = new zt(t), this.e = ns.isNumber(h) ? h : op.get32IntFromBuffer(h, 0), this.d = new zt(o), S && g && B && M && O && (this.p = new zt(S), this.q = new zt(g), this.dmp1 = new zt(B), this.dmq1 = new zt(M), this.coeff = new zt(O)), this.$$recalculateCache();
    else
      throw Error("Invalid RSA private key");
  }, e.prototype.setPublic = function(t, h) {
    if (t && h && t.length > 0 && (ns.isNumber(h) || h.length > 0))
      this.n = new zt(t), this.e = ns.isNumber(h) ? h : op.get32IntFromBuffer(h, 0), this.$$recalculateCache();
    else
      throw Error("Invalid RSA public key");
  }, e.prototype.$doPrivate = function(t) {
    if (this.p || this.q)
      return t.modPow(this.d, this.n);
    for (var h = t.mod(this.p).modPow(this.dmp1, this.p), o = t.mod(this.q).modPow(this.dmq1, this.q); h.compareTo(o) < 0; )
      h = h.add(this.p);
    return h.subtract(o).multiply(this.coeff).mod(this.p).multiply(this.q).add(o);
  }, e.prototype.$doPublic = function(t) {
    return t.modPowInt(this.e, this.n);
  }, e.prototype.encrypt = function(t, h) {
    var o = [], S = [], g = t.length, B = Math.ceil(g / this.maxMessageLength) || 1, M = Math.ceil(g / B || 1);
    if (B == 1)
      o.push(t);
    else
      for (var O = 0; O < B; O++)
        o.push(t.slice(O * M, (O + 1) * M));
    for (var P = 0; P < o.length; P++)
      S.push(this.encryptEngine.encrypt(o[P], h));
    return pe.Buffer.concat(S);
  }, e.prototype.decrypt = function(t, h) {
    if (t.length % this.encryptedDataLength > 0)
      throw Error("Incorrect data or key");
    for (var o = [], S = 0, g = 0, B = t.length / this.encryptedDataLength, M = 0; M < B; M++)
      S = M * this.encryptedDataLength, g = S + this.encryptedDataLength, o.push(this.encryptEngine.decrypt(t.slice(S, Math.min(g, t.length)), h));
    return pe.Buffer.concat(o);
  }, e.prototype.sign = function(t) {
    return this.signingScheme.sign.apply(this.signingScheme, arguments);
  }, e.prototype.verify = function(t, h, o) {
    return this.signingScheme.verify.apply(this.signingScheme, arguments);
  }, e.prototype.isPrivate = function() {
    return this.n && this.e && this.d && !0 || !1;
  }, e.prototype.isPublic = function(t) {
    return this.n && this.e && !(t && this.d) || !1;
  }, Object.defineProperty(e.prototype, "keySize", {
    get: function() {
      return this.cache.keyBitLength;
    }
  }), Object.defineProperty(e.prototype, "encryptedDataLength", {
    get: function() {
      return this.cache.keyByteLength;
    }
  }), Object.defineProperty(e.prototype, "maxMessageLength", {
    get: function() {
      return this.encryptionScheme.maxMessageLength();
    }
  }), e.prototype.$$recalculateCache = function() {
    this.cache = this.cache || {}, this.cache.keyBitLength = this.n.bitLength(), this.cache.keyByteLength = this.cache.keyBitLength + 6 >> 3;
  }, e;
}();
var Jy = { exports: {} }, Rh = {
  newInvalidAsn1Error: function(e) {
    var t = new Error();
    return t.name = "InvalidAsn1Error", t.message = e || "", t;
  }
}, Nh = {
  EOC: 0,
  Boolean: 1,
  Integer: 2,
  BitString: 3,
  OctetString: 4,
  Null: 5,
  OID: 6,
  ObjectDescriptor: 7,
  External: 8,
  Real: 9,
  // float
  Enumeration: 10,
  PDV: 11,
  Utf8String: 12,
  RelativeOID: 13,
  Sequence: 16,
  Set: 17,
  NumericString: 18,
  PrintableString: 19,
  T61String: 20,
  VideotexString: 21,
  IA5String: 22,
  UTCTime: 23,
  GeneralizedTime: 24,
  GraphicString: 25,
  VisibleString: 26,
  GeneralString: 28,
  UniversalString: 29,
  CharacterString: 30,
  BMPString: 31,
  Constructor: 32,
  Context: 128
}, xu = { exports: {} }, _u = {}, cp;
function e2() {
  if (cp)
    return _u;
  cp = 1;
  function e(ue) {
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? e = function(fe) {
      return typeof fe;
    } : e = function(fe) {
      return fe && typeof Symbol == "function" && fe.constructor === Symbol && fe !== Symbol.prototype ? "symbol" : typeof fe;
    }, e(ue);
  }
  function t(ue, fe) {
    if (!(ue instanceof fe))
      throw new TypeError("Cannot call a class as a function");
  }
  function h(ue, fe) {
    return fe && (e(fe) === "object" || typeof fe == "function") ? fe : o(ue);
  }
  function o(ue) {
    if (ue === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return ue;
  }
  function S(ue) {
    return S = Object.setPrototypeOf ? Object.getPrototypeOf : function(fe) {
      return fe.__proto__ || Object.getPrototypeOf(fe);
    }, S(ue);
  }
  function g(ue, fe) {
    if (typeof fe != "function" && fe !== null)
      throw new TypeError("Super expression must either be null or a function");
    ue.prototype = Object.create(fe && fe.prototype, { constructor: { value: ue, writable: !0, configurable: !0 } }), fe && B(ue, fe);
  }
  function B(ue, fe) {
    return B = Object.setPrototypeOf || function(de, ce) {
      return de.__proto__ = ce, de;
    }, B(ue, fe);
  }
  var M = {}, O, P;
  function D(ue, fe, de) {
    de || (de = Error);
    function ce(ve, Pe, Ue) {
      return typeof fe == "string" ? fe : fe(ve, Pe, Ue);
    }
    var be = /* @__PURE__ */ function(ve) {
      g(Pe, ve);
      function Pe(Ue, ze, Le) {
        var Ne;
        return t(this, Pe), Ne = h(this, S(Pe).call(this, ce(Ue, ze, Le))), Ne.code = ue, Ne;
      }
      return Pe;
    }(de);
    M[ue] = be;
  }
  function Z(ue, fe) {
    if (Array.isArray(ue)) {
      var de = ue.length;
      return ue = ue.map(function(ce) {
        return String(ce);
      }), de > 2 ? "one of ".concat(fe, " ").concat(ue.slice(0, de - 1).join(", "), ", or ") + ue[de - 1] : de === 2 ? "one of ".concat(fe, " ").concat(ue[0], " or ").concat(ue[1]) : "of ".concat(fe, " ").concat(ue[0]);
    } else
      return "of ".concat(fe, " ").concat(String(ue));
  }
  function Y(ue, fe, de) {
    return ue.substr(!de || de < 0 ? 0 : +de, fe.length) === fe;
  }
  function ee(ue, fe, de) {
    return (de === void 0 || de > ue.length) && (de = ue.length), ue.substring(de - fe.length, de) === fe;
  }
  function ie(ue, fe, de) {
    return typeof de != "number" && (de = 0), de + fe.length > ue.length ? !1 : ue.indexOf(fe, de) !== -1;
  }
  return D("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError), D("ERR_INVALID_ARG_TYPE", function(ue, fe, de) {
    O === void 0 && (O = Os()), O(typeof ue == "string", "'name' must be a string");
    var ce;
    typeof fe == "string" && Y(fe, "not ") ? (ce = "must not be", fe = fe.replace(/^not /, "")) : ce = "must be";
    var be;
    if (ee(ue, " argument"))
      be = "The ".concat(ue, " ").concat(ce, " ").concat(Z(fe, "type"));
    else {
      var ve = ie(ue, ".") ? "property" : "argument";
      be = 'The "'.concat(ue, '" ').concat(ve, " ").concat(ce, " ").concat(Z(fe, "type"));
    }
    return be += ". Received type ".concat(e(de)), be;
  }, TypeError), D("ERR_INVALID_ARG_VALUE", function(ue, fe) {
    var de = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
    P === void 0 && (P = wn);
    var ce = P.inspect(fe);
    return ce.length > 128 && (ce = "".concat(ce.slice(0, 128), "...")), "The argument '".concat(ue, "' ").concat(de, ". Received ").concat(ce);
  }, TypeError), D("ERR_INVALID_RETURN_VALUE", function(ue, fe, de) {
    var ce;
    return de && de.constructor && de.constructor.name ? ce = "instance of ".concat(de.constructor.name) : ce = "type ".concat(e(de)), "Expected ".concat(ue, ' to be returned from the "').concat(fe, '"') + " function but got ".concat(ce, ".");
  }, TypeError), D("ERR_MISSING_ARGS", function() {
    for (var ue = arguments.length, fe = new Array(ue), de = 0; de < ue; de++)
      fe[de] = arguments[de];
    O === void 0 && (O = Os()), O(fe.length > 0, "At least one arg needs to be specified");
    var ce = "The ", be = fe.length;
    switch (fe = fe.map(function(ve) {
      return '"'.concat(ve, '"');
    }), be) {
      case 1:
        ce += "".concat(fe[0], " argument");
        break;
      case 2:
        ce += "".concat(fe[0], " and ").concat(fe[1], " arguments");
        break;
      default:
        ce += fe.slice(0, be - 1).join(", "), ce += ", and ".concat(fe[be - 1], " arguments");
        break;
    }
    return "".concat(ce, " must be specified");
  }, TypeError), _u.codes = M, _u;
}
var Eu, hp;
function lC() {
  if (hp)
    return Eu;
  hp = 1;
  function e(U) {
    for (var X = 1; X < arguments.length; X++) {
      var Q = arguments[X] != null ? arguments[X] : {}, F = Object.keys(Q);
      typeof Object.getOwnPropertySymbols == "function" && (F = F.concat(Object.getOwnPropertySymbols(Q).filter(function($) {
        return Object.getOwnPropertyDescriptor(Q, $).enumerable;
      }))), F.forEach(function($) {
        t(U, $, Q[$]);
      });
    }
    return U;
  }
  function t(U, X, Q) {
    return X in U ? Object.defineProperty(U, X, { value: Q, enumerable: !0, configurable: !0, writable: !0 }) : U[X] = Q, U;
  }
  function h(U, X) {
    if (!(U instanceof X))
      throw new TypeError("Cannot call a class as a function");
  }
  function o(U, X) {
    for (var Q = 0; Q < X.length; Q++) {
      var F = X[Q];
      F.enumerable = F.enumerable || !1, F.configurable = !0, "value" in F && (F.writable = !0), Object.defineProperty(U, F.key, F);
    }
  }
  function S(U, X, Q) {
    return X && o(U.prototype, X), Q && o(U, Q), U;
  }
  function g(U, X) {
    return X && (ie(X) === "object" || typeof X == "function") ? X : B(U);
  }
  function B(U) {
    if (U === void 0)
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return U;
  }
  function M(U, X) {
    if (typeof X != "function" && X !== null)
      throw new TypeError("Super expression must either be null or a function");
    U.prototype = Object.create(X && X.prototype, { constructor: { value: U, writable: !0, configurable: !0 } }), X && Y(U, X);
  }
  function O(U) {
    var X = typeof Map == "function" ? /* @__PURE__ */ new Map() : void 0;
    return O = function(Q) {
      if (Q === null || !Z(Q))
        return Q;
      if (typeof Q != "function")
        throw new TypeError("Super expression must either be null or a function");
      if (typeof X < "u") {
        if (X.has(Q))
          return X.get(Q);
        X.set(Q, F);
      }
      function F() {
        return D(Q, arguments, ee(this).constructor);
      }
      return F.prototype = Object.create(Q.prototype, { constructor: { value: F, enumerable: !1, writable: !0, configurable: !0 } }), Y(F, Q);
    }, O(U);
  }
  function P() {
    if (typeof Reflect > "u" || !Reflect.construct || Reflect.construct.sham)
      return !1;
    if (typeof Proxy == "function")
      return !0;
    try {
      return Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      })), !0;
    } catch {
      return !1;
    }
  }
  function D(U, X, Q) {
    return P() ? D = Reflect.construct : D = function(F, $, H) {
      var q = [null];
      q.push.apply(q, $);
      var z = Function.bind.apply(F, q), me = new z();
      return H && Y(me, H.prototype), me;
    }, D.apply(null, arguments);
  }
  function Z(U) {
    return Function.toString.call(U).indexOf("[native code]") !== -1;
  }
  function Y(U, X) {
    return Y = Object.setPrototypeOf || function(Q, F) {
      return Q.__proto__ = F, Q;
    }, Y(U, X);
  }
  function ee(U) {
    return ee = Object.setPrototypeOf ? Object.getPrototypeOf : function(X) {
      return X.__proto__ || Object.getPrototypeOf(X);
    }, ee(U);
  }
  function ie(U) {
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? ie = function(X) {
      return typeof X;
    } : ie = function(X) {
      return X && typeof Symbol == "function" && X.constructor === Symbol && X !== Symbol.prototype ? "symbol" : typeof X;
    }, ie(U);
  }
  var ue = wn, fe = ue.inspect, de = e2(), ce = de.codes.ERR_INVALID_ARG_TYPE;
  function be(U, X, Q) {
    return (Q === void 0 || Q > U.length) && (Q = U.length), U.substring(Q - X.length, Q) === X;
  }
  function ve(U, X) {
    if (X = Math.floor(X), U.length == 0 || X == 0)
      return "";
    var Q = U.length * X;
    for (X = Math.floor(Math.log(X) / Math.log(2)); X; )
      U += U, X--;
    return U += U.substring(0, Q - U.length), U;
  }
  var Pe = "", Ue = "", ze = "", Le = "", Ne = {
    deepStrictEqual: "Expected values to be strictly deep-equal:",
    strictEqual: "Expected values to be strictly equal:",
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: "Expected values to be loosely deep-equal:",
    equal: "Expected values to be loosely equal:",
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notEqual: 'Expected "actual" to be loosely unequal to:',
    notIdentical: "Values identical but not reference-equal:"
  }, $e = 10;
  function J(U) {
    var X = Object.keys(U), Q = Object.create(Object.getPrototypeOf(U));
    return X.forEach(function(F) {
      Q[F] = U[F];
    }), Object.defineProperty(Q, "message", {
      value: U.message
    }), Q;
  }
  function ne(U) {
    return fe(U, {
      compact: !1,
      customInspect: !1,
      depth: 1e3,
      maxArrayLength: 1 / 0,
      // Assert compares only enumerable properties (with a few exceptions).
      showHidden: !1,
      // Having a long line as error is better than wrapping the line for
      // comparison for now.
      // TODO(BridgeAR): `breakLength` should be limited as soon as soon as we
      // have meta information about the inspected properties (i.e., know where
      // in what line the property starts and ends).
      breakLength: 1 / 0,
      // Assert does not detect proxies currently.
      showProxy: !1,
      sorted: !0,
      // Inspect getters as we also check them when comparing entries.
      getters: !0
    });
  }
  function A(U, X, Q) {
    var F = "", $ = "", H = 0, q = "", z = !1, me = ne(U), Ce = me.split(`
`), je = ne(X).split(`
`), Re = 0, Ae = "";
    if (Q === "strictEqual" && ie(U) === "object" && ie(X) === "object" && U !== null && X !== null && (Q = "strictEqualObject"), Ce.length === 1 && je.length === 1 && Ce[0] !== je[0]) {
      var ke = Ce[0].length + je[0].length;
      if (ke <= $e) {
        if ((ie(U) !== "object" || U === null) && (ie(X) !== "object" || X === null) && (U !== 0 || X !== 0))
          return "".concat(Ne[Q], `

`) + "".concat(Ce[0], " !== ").concat(je[0], `
`);
      } else if (Q !== "strictEqualObject") {
        var Qe = Ve.stderr && Ve.stderr.isTTY ? Ve.stderr.columns : 80;
        if (ke < Qe) {
          for (; Ce[0][Re] === je[0][Re]; )
            Re++;
          Re > 2 && (Ae = `
  `.concat(ve(" ", Re), "^"), Re = 0);
        }
      }
    }
    for (var Ze = Ce[Ce.length - 1], qe = je[je.length - 1]; Ze === qe && (Re++ < 2 ? q = `
  `.concat(Ze).concat(q) : F = Ze, Ce.pop(), je.pop(), !(Ce.length === 0 || je.length === 0)); )
      Ze = Ce[Ce.length - 1], qe = je[je.length - 1];
    var Oe = Math.max(Ce.length, je.length);
    if (Oe === 0) {
      var Xe = me.split(`
`);
      if (Xe.length > 30)
        for (Xe[26] = "".concat(Pe, "...").concat(Le); Xe.length > 27; )
          Xe.pop();
      return "".concat(Ne.notIdentical, `

`).concat(Xe.join(`
`), `
`);
    }
    Re > 3 && (q = `
`.concat(Pe, "...").concat(Le).concat(q), z = !0), F !== "" && (q = `
  `.concat(F).concat(q), F = "");
    var et = 0, nt = Ne[Q] + `
`.concat(Ue, "+ actual").concat(Le, " ").concat(ze, "- expected").concat(Le), re = " ".concat(Pe, "...").concat(Le, " Lines skipped");
    for (Re = 0; Re < Oe; Re++) {
      var oe = Re - H;
      if (Ce.length < Re + 1)
        oe > 1 && Re > 2 && (oe > 4 ? ($ += `
`.concat(Pe, "...").concat(Le), z = !0) : oe > 3 && ($ += `
  `.concat(je[Re - 2]), et++), $ += `
  `.concat(je[Re - 1]), et++), H = Re, F += `
`.concat(ze, "-").concat(Le, " ").concat(je[Re]), et++;
      else if (je.length < Re + 1)
        oe > 1 && Re > 2 && (oe > 4 ? ($ += `
`.concat(Pe, "...").concat(Le), z = !0) : oe > 3 && ($ += `
  `.concat(Ce[Re - 2]), et++), $ += `
  `.concat(Ce[Re - 1]), et++), H = Re, $ += `
`.concat(Ue, "+").concat(Le, " ").concat(Ce[Re]), et++;
      else {
        var le = je[Re], ge = Ce[Re], Ke = ge !== le && (!be(ge, ",") || ge.slice(0, -1) !== le);
        Ke && be(le, ",") && le.slice(0, -1) === ge && (Ke = !1, ge += ","), Ke ? (oe > 1 && Re > 2 && (oe > 4 ? ($ += `
`.concat(Pe, "...").concat(Le), z = !0) : oe > 3 && ($ += `
  `.concat(Ce[Re - 2]), et++), $ += `
  `.concat(Ce[Re - 1]), et++), H = Re, $ += `
`.concat(Ue, "+").concat(Le, " ").concat(ge), F += `
`.concat(ze, "-").concat(Le, " ").concat(le), et += 2) : ($ += F, F = "", (oe === 1 || Re === 0) && ($ += `
  `.concat(ge), et++));
      }
      if (et > 20 && Re < Oe - 2)
        return "".concat(nt).concat(re, `
`).concat($, `
`).concat(Pe, "...").concat(Le).concat(F, `
`) + "".concat(Pe, "...").concat(Le);
    }
    return "".concat(nt).concat(z ? re : "", `
`).concat($).concat(F).concat(q).concat(Ae);
  }
  var I = /* @__PURE__ */ function(U) {
    M(X, U);
    function X(Q) {
      var F;
      if (h(this, X), ie(Q) !== "object" || Q === null)
        throw new ce("options", "Object", Q);
      var $ = Q.message, H = Q.operator, q = Q.stackStartFn, z = Q.actual, me = Q.expected, Ce = Error.stackTraceLimit;
      if (Error.stackTraceLimit = 0, $ != null)
        F = g(this, ee(X).call(this, String($)));
      else if (Ve.stderr && Ve.stderr.isTTY && (Ve.stderr && Ve.stderr.getColorDepth && Ve.stderr.getColorDepth() !== 1 ? (Pe = "\x1B[34m", Ue = "\x1B[32m", Le = "\x1B[39m", ze = "\x1B[31m") : (Pe = "", Ue = "", Le = "", ze = "")), ie(z) === "object" && z !== null && ie(me) === "object" && me !== null && "stack" in z && z instanceof Error && "stack" in me && me instanceof Error && (z = J(z), me = J(me)), H === "deepStrictEqual" || H === "strictEqual")
        F = g(this, ee(X).call(this, A(z, me, H)));
      else if (H === "notDeepStrictEqual" || H === "notStrictEqual") {
        var je = Ne[H], Re = ne(z).split(`
`);
        if (H === "notStrictEqual" && ie(z) === "object" && z !== null && (je = Ne.notStrictEqualObject), Re.length > 30)
          for (Re[26] = "".concat(Pe, "...").concat(Le); Re.length > 27; )
            Re.pop();
        Re.length === 1 ? F = g(this, ee(X).call(this, "".concat(je, " ").concat(Re[0]))) : F = g(this, ee(X).call(this, "".concat(je, `

`).concat(Re.join(`
`), `
`)));
      } else {
        var Ae = ne(z), ke = "", Qe = Ne[H];
        H === "notDeepEqual" || H === "notEqual" ? (Ae = "".concat(Ne[H], `

`).concat(Ae), Ae.length > 1024 && (Ae = "".concat(Ae.slice(0, 1021), "..."))) : (ke = "".concat(ne(me)), Ae.length > 512 && (Ae = "".concat(Ae.slice(0, 509), "...")), ke.length > 512 && (ke = "".concat(ke.slice(0, 509), "...")), H === "deepEqual" || H === "equal" ? Ae = "".concat(Qe, `

`).concat(Ae, `

should equal

`) : ke = " ".concat(H, " ").concat(ke)), F = g(this, ee(X).call(this, "".concat(Ae).concat(ke)));
      }
      return Error.stackTraceLimit = Ce, F.generatedMessage = !$, Object.defineProperty(B(F), "name", {
        value: "AssertionError [ERR_ASSERTION]",
        enumerable: !1,
        writable: !0,
        configurable: !0
      }), F.code = "ERR_ASSERTION", F.actual = z, F.expected = me, F.operator = H, Error.captureStackTrace && Error.captureStackTrace(B(F), q), F.stack, F.name = "AssertionError", g(F);
    }
    return S(X, [{
      key: "toString",
      value: function() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      }
    }, {
      key: fe.custom,
      value: function(Q, F) {
        return fe(this, e({}, F, {
          customInspect: !1,
          depth: 0
        }));
      }
    }]), X;
  }(O(Error));
  return Eu = I, Eu;
}
var Su, lp;
function dC() {
  if (lp)
    return Su;
  lp = 1;
  function e(h, o) {
    if (h == null)
      throw new TypeError("Cannot convert first argument to object");
    for (var S = Object(h), g = 1; g < arguments.length; g++) {
      var B = arguments[g];
      if (B != null)
        for (var M = Object.keys(Object(B)), O = 0, P = M.length; O < P; O++) {
          var D = M[O], Z = Object.getOwnPropertyDescriptor(B, D);
          Z !== void 0 && Z.enumerable && (S[D] = B[D]);
        }
    }
    return S;
  }
  function t() {
    Object.assign || Object.defineProperty(Object, "assign", {
      enumerable: !1,
      configurable: !0,
      writable: !0,
      value: e
    });
  }
  return Su = {
    assign: e,
    polyfill: t
  }, Su;
}
var wu, dp;
function t2() {
  if (dp)
    return wu;
  dp = 1;
  var e = Object.prototype.toString;
  return wu = function(t) {
    var h = e.call(t), o = h === "[object Arguments]";
    return o || (o = h !== "[object Array]" && t !== null && typeof t == "object" && typeof t.length == "number" && t.length >= 0 && e.call(t.callee) === "[object Function]"), o;
  }, wu;
}
var Cu, pp;
function pC() {
  if (pp)
    return Cu;
  pp = 1;
  var e;
  if (!Object.keys) {
    var t = Object.prototype.hasOwnProperty, h = Object.prototype.toString, o = t2(), S = Object.prototype.propertyIsEnumerable, g = !S.call({ toString: null }, "toString"), B = S.call(function() {
    }, "prototype"), M = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ], O = function(Y) {
      var ee = Y.constructor;
      return ee && ee.prototype === Y;
    }, P = {
      $applicationCache: !0,
      $console: !0,
      $external: !0,
      $frame: !0,
      $frameElement: !0,
      $frames: !0,
      $innerHeight: !0,
      $innerWidth: !0,
      $onmozfullscreenchange: !0,
      $onmozfullscreenerror: !0,
      $outerHeight: !0,
      $outerWidth: !0,
      $pageXOffset: !0,
      $pageYOffset: !0,
      $parent: !0,
      $scrollLeft: !0,
      $scrollTop: !0,
      $scrollX: !0,
      $scrollY: !0,
      $self: !0,
      $webkitIndexedDB: !0,
      $webkitStorageInfo: !0,
      $window: !0
    }, D = function() {
      if (typeof window > "u")
        return !1;
      for (var Y in window)
        try {
          if (!P["$" + Y] && t.call(window, Y) && window[Y] !== null && typeof window[Y] == "object")
            try {
              O(window[Y]);
            } catch {
              return !0;
            }
        } catch {
          return !0;
        }
      return !1;
    }(), Z = function(Y) {
      if (typeof window > "u" || !D)
        return O(Y);
      try {
        return O(Y);
      } catch {
        return !1;
      }
    };
    e = function(Y) {
      var ee = Y !== null && typeof Y == "object", ie = h.call(Y) === "[object Function]", ue = o(Y), fe = ee && h.call(Y) === "[object String]", de = [];
      if (!ee && !ie && !ue)
        throw new TypeError("Object.keys called on a non-object");
      var ce = B && ie;
      if (fe && Y.length > 0 && !t.call(Y, 0))
        for (var be = 0; be < Y.length; ++be)
          de.push(String(be));
      if (ue && Y.length > 0)
        for (var ve = 0; ve < Y.length; ++ve)
          de.push(String(ve));
      else
        for (var Pe in Y)
          !(ce && Pe === "prototype") && t.call(Y, Pe) && de.push(String(Pe));
      if (g)
        for (var Ue = Z(Y), ze = 0; ze < M.length; ++ze)
          !(Ue && M[ze] === "constructor") && t.call(Y, M[ze]) && de.push(M[ze]);
      return de;
    };
  }
  return Cu = e, Cu;
}
var Au, vp;
function vC() {
  if (vp)
    return Au;
  vp = 1;
  var e = Array.prototype.slice, t = t2(), h = Object.keys, o = h ? function(g) {
    return h(g);
  } : pC(), S = Object.keys;
  return o.shim = function() {
    if (Object.keys) {
      var g = function() {
        var B = Object.keys(arguments);
        return B && B.length === arguments.length;
      }(1, 2);
      g || (Object.keys = function(B) {
        return t(B) ? S(e.call(B)) : S(B);
      });
    } else
      Object.keys = o;
    return Object.keys || o;
  }, Au = o, Au;
}
var Bu, yp;
function yC() {
  if (yp)
    return Bu;
  yp = 1;
  var e = Ws(), t = e("%Object.defineProperty%", !0), h = function() {
    if (t)
      try {
        return t({}, "a", { value: 1 }), !0;
      } catch {
        return !1;
      }
    return !1;
  };
  return h.hasArrayLengthDefineBug = function() {
    if (!h())
      return null;
    try {
      return t([], "length", { value: 1 }).length !== 1;
    } catch {
      return !0;
    }
  }, Bu = h, Bu;
}
var Iu, gp;
function Rf() {
  if (gp)
    return Iu;
  gp = 1;
  var e = vC(), t = typeof Symbol == "function" && typeof Symbol("foo") == "symbol", h = Object.prototype.toString, o = Array.prototype.concat, S = Object.defineProperty, g = function(D) {
    return typeof D == "function" && h.call(D) === "[object Function]";
  }, B = yC()(), M = S && B, O = function(D, Z, Y, ee) {
    if (Z in D) {
      if (ee === !0) {
        if (D[Z] === Y)
          return;
      } else if (!g(ee) || !ee())
        return;
    }
    M ? S(D, Z, {
      configurable: !0,
      enumerable: !1,
      value: Y,
      writable: !0
    }) : D[Z] = Y;
  }, P = function(D, Z) {
    var Y = arguments.length > 2 ? arguments[2] : {}, ee = e(Z);
    t && (ee = o.call(ee, Object.getOwnPropertySymbols(Z)));
    for (var ie = 0; ie < ee.length; ie += 1)
      O(D, ee[ie], Z[ee[ie]], Y[ee[ie]]);
  };
  return P.supportsDescriptors = !!M, Iu = P, Iu;
}
var Tu, mp;
function r2() {
  if (mp)
    return Tu;
  mp = 1;
  var e = function(t) {
    return t !== t;
  };
  return Tu = function(t, h) {
    return t === 0 && h === 0 ? 1 / t === 1 / h : !!(t === h || e(t) && e(h));
  }, Tu;
}
var Mu, bp;
function i2() {
  if (bp)
    return Mu;
  bp = 1;
  var e = r2();
  return Mu = function() {
    return typeof Object.is == "function" ? Object.is : e;
  }, Mu;
}
var Ru, xp;
function gC() {
  if (xp)
    return Ru;
  xp = 1;
  var e = i2(), t = Rf();
  return Ru = function() {
    var h = e();
    return t(Object, { is: h }, {
      is: function() {
        return Object.is !== h;
      }
    }), h;
  }, Ru;
}
var Nu, _p;
function n2() {
  if (_p)
    return Nu;
  _p = 1;
  var e = Rf(), t = Ys(), h = r2(), o = i2(), S = gC(), g = t(o(), Object);
  return e(g, {
    getPolyfill: o,
    implementation: h,
    shim: S
  }), Nu = g, Nu;
}
var Du, Ep;
function a2() {
  return Ep || (Ep = 1, Du = function(e) {
    return e !== e;
  }), Du;
}
var Ou, Sp;
function s2() {
  if (Sp)
    return Ou;
  Sp = 1;
  var e = a2();
  return Ou = function() {
    return Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a") ? Number.isNaN : e;
  }, Ou;
}
var Pu, wp;
function mC() {
  if (wp)
    return Pu;
  wp = 1;
  var e = Rf(), t = s2();
  return Pu = function() {
    var h = t();
    return e(Number, { isNaN: h }, {
      isNaN: function() {
        return Number.isNaN !== h;
      }
    }), h;
  }, Pu;
}
var Lu, Cp;
function bC() {
  if (Cp)
    return Lu;
  Cp = 1;
  var e = Ys(), t = Rf(), h = a2(), o = s2(), S = mC(), g = e(o(), Number);
  return t(g, {
    getPolyfill: o,
    implementation: h,
    shim: S
  }), Lu = g, Lu;
}
var ku, Ap;
function xC() {
  if (Ap)
    return ku;
  Ap = 1;
  function e(Fe, Ye) {
    return o(Fe) || h(Fe, Ye) || t();
  }
  function t() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }
  function h(Fe, Ye) {
    var it = [], rt = !0, tt = !1, vt = void 0;
    try {
      for (var St = Fe[Symbol.iterator](), ot; !(rt = (ot = St.next()).done) && (it.push(ot.value), !(Ye && it.length === Ye)); rt = !0)
        ;
    } catch (si) {
      tt = !0, vt = si;
    } finally {
      try {
        !rt && St.return != null && St.return();
      } finally {
        if (tt)
          throw vt;
      }
    }
    return it;
  }
  function o(Fe) {
    if (Array.isArray(Fe))
      return Fe;
  }
  function S(Fe) {
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? S = function(Ye) {
      return typeof Ye;
    } : S = function(Ye) {
      return Ye && typeof Symbol == "function" && Ye.constructor === Symbol && Ye !== Symbol.prototype ? "symbol" : typeof Ye;
    }, S(Fe);
  }
  var g = /a/g.flags !== void 0, B = function(Fe) {
    var Ye = [];
    return Fe.forEach(function(it) {
      return Ye.push(it);
    }), Ye;
  }, M = function(Fe) {
    var Ye = [];
    return Fe.forEach(function(it, rt) {
      return Ye.push([rt, it]);
    }), Ye;
  }, O = Object.is ? Object.is : n2(), P = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
  }, D = Number.isNaN ? Number.isNaN : bC();
  function Z(Fe) {
    return Fe.call.bind(Fe);
  }
  var Y = Z(Object.prototype.hasOwnProperty), ee = Z(Object.prototype.propertyIsEnumerable), ie = Z(Object.prototype.toString), ue = wn.types, fe = ue.isAnyArrayBuffer, de = ue.isArrayBufferView, ce = ue.isDate, be = ue.isMap, ve = ue.isRegExp, Pe = ue.isSet, Ue = ue.isNativeError, ze = ue.isBoxedPrimitive, Le = ue.isNumberObject, Ne = ue.isStringObject, $e = ue.isBooleanObject, J = ue.isBigIntObject, ne = ue.isSymbolObject, A = ue.isFloat32Array, I = ue.isFloat64Array;
  function U(Fe) {
    if (Fe.length === 0 || Fe.length > 10)
      return !0;
    for (var Ye = 0; Ye < Fe.length; Ye++) {
      var it = Fe.charCodeAt(Ye);
      if (it < 48 || it > 57)
        return !0;
    }
    return Fe.length === 10 && Fe >= Math.pow(2, 32);
  }
  function X(Fe) {
    return Object.keys(Fe).filter(U).concat(P(Fe).filter(Object.prototype.propertyIsEnumerable.bind(Fe)));
  }
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  function Q(Fe, Ye) {
    if (Fe === Ye)
      return 0;
    for (var it = Fe.length, rt = Ye.length, tt = 0, vt = Math.min(it, rt); tt < vt; ++tt)
      if (Fe[tt] !== Ye[tt]) {
        it = Fe[tt], rt = Ye[tt];
        break;
      }
    return it < rt ? -1 : rt < it ? 1 : 0;
  }
  var F = !0, $ = !1, H = 0, q = 1, z = 2, me = 3;
  function Ce(Fe, Ye) {
    return g ? Fe.source === Ye.source && Fe.flags === Ye.flags : RegExp.prototype.toString.call(Fe) === RegExp.prototype.toString.call(Ye);
  }
  function je(Fe, Ye) {
    if (Fe.byteLength !== Ye.byteLength)
      return !1;
    for (var it = 0; it < Fe.byteLength; it++)
      if (Fe[it] !== Ye[it])
        return !1;
    return !0;
  }
  function Re(Fe, Ye) {
    return Fe.byteLength !== Ye.byteLength ? !1 : Q(new Uint8Array(Fe.buffer, Fe.byteOffset, Fe.byteLength), new Uint8Array(Ye.buffer, Ye.byteOffset, Ye.byteLength)) === 0;
  }
  function Ae(Fe, Ye) {
    return Fe.byteLength === Ye.byteLength && Q(new Uint8Array(Fe), new Uint8Array(Ye)) === 0;
  }
  function ke(Fe, Ye) {
    return Le(Fe) ? Le(Ye) && O(Number.prototype.valueOf.call(Fe), Number.prototype.valueOf.call(Ye)) : Ne(Fe) ? Ne(Ye) && String.prototype.valueOf.call(Fe) === String.prototype.valueOf.call(Ye) : $e(Fe) ? $e(Ye) && Boolean.prototype.valueOf.call(Fe) === Boolean.prototype.valueOf.call(Ye) : J(Fe) ? J(Ye) && BigInt.prototype.valueOf.call(Fe) === BigInt.prototype.valueOf.call(Ye) : ne(Ye) && Symbol.prototype.valueOf.call(Fe) === Symbol.prototype.valueOf.call(Ye);
  }
  function Qe(Fe, Ye, it, rt) {
    if (Fe === Ye)
      return Fe !== 0 ? !0 : it ? O(Fe, Ye) : !0;
    if (it) {
      if (S(Fe) !== "object")
        return typeof Fe == "number" && D(Fe) && D(Ye);
      if (S(Ye) !== "object" || Fe === null || Ye === null || Object.getPrototypeOf(Fe) !== Object.getPrototypeOf(Ye))
        return !1;
    } else {
      if (Fe === null || S(Fe) !== "object")
        return Ye === null || S(Ye) !== "object" ? Fe == Ye : !1;
      if (Ye === null || S(Ye) !== "object")
        return !1;
    }
    var tt = ie(Fe), vt = ie(Ye);
    if (tt !== vt)
      return !1;
    if (Array.isArray(Fe)) {
      if (Fe.length !== Ye.length)
        return !1;
      var St = X(Fe), ot = X(Ye);
      return St.length !== ot.length ? !1 : qe(Fe, Ye, it, rt, q, St);
    }
    if (tt === "[object Object]" && (!be(Fe) && be(Ye) || !Pe(Fe) && Pe(Ye)))
      return !1;
    if (ce(Fe)) {
      if (!ce(Ye) || Date.prototype.getTime.call(Fe) !== Date.prototype.getTime.call(Ye))
        return !1;
    } else if (ve(Fe)) {
      if (!ve(Ye) || !Ce(Fe, Ye))
        return !1;
    } else if (Ue(Fe) || Fe instanceof Error) {
      if (Fe.message !== Ye.message || Fe.name !== Ye.name)
        return !1;
    } else if (de(Fe)) {
      if (!it && (A(Fe) || I(Fe))) {
        if (!je(Fe, Ye))
          return !1;
      } else if (!Re(Fe, Ye))
        return !1;
      var si = X(Fe), oi = X(Ye);
      return si.length !== oi.length ? !1 : qe(Fe, Ye, it, rt, H, si);
    } else {
      if (Pe(Fe))
        return !Pe(Ye) || Fe.size !== Ye.size ? !1 : qe(Fe, Ye, it, rt, z);
      if (be(Fe))
        return !be(Ye) || Fe.size !== Ye.size ? !1 : qe(Fe, Ye, it, rt, me);
      if (fe(Fe)) {
        if (!Ae(Fe, Ye))
          return !1;
      } else if (ze(Fe) && !ke(Fe, Ye))
        return !1;
    }
    return qe(Fe, Ye, it, rt, H);
  }
  function Ze(Fe, Ye) {
    return Ye.filter(function(it) {
      return ee(Fe, it);
    });
  }
  function qe(Fe, Ye, it, rt, tt, vt) {
    if (arguments.length === 5) {
      vt = Object.keys(Fe);
      var St = Object.keys(Ye);
      if (vt.length !== St.length)
        return !1;
    }
    for (var ot = 0; ot < vt.length; ot++)
      if (!Y(Ye, vt[ot]))
        return !1;
    if (it && arguments.length === 5) {
      var si = P(Fe);
      if (si.length !== 0) {
        var oi = 0;
        for (ot = 0; ot < si.length; ot++) {
          var At = si[ot];
          if (ee(Fe, At)) {
            if (!ee(Ye, At))
              return !1;
            vt.push(At), oi++;
          } else if (ee(Ye, At))
            return !1;
        }
        var Nn = P(Ye);
        if (si.length !== Nn.length && Ze(Ye, Nn).length !== oi)
          return !1;
      } else {
        var ui = P(Ye);
        if (ui.length !== 0 && Ze(Ye, ui).length !== 0)
          return !1;
      }
    }
    if (vt.length === 0 && (tt === H || tt === q && Fe.length === 0 || Fe.size === 0))
      return !0;
    if (rt === void 0)
      rt = {
        val1: /* @__PURE__ */ new Map(),
        val2: /* @__PURE__ */ new Map(),
        position: 0
      };
    else {
      var Bt = rt.val1.get(Fe);
      if (Bt !== void 0) {
        var vi = rt.val2.get(Ye);
        if (vi !== void 0)
          return Bt === vi;
      }
      rt.position++;
    }
    rt.val1.set(Fe, rt.position), rt.val2.set(Ye, rt.position);
    var fi = ge(Fe, Ye, it, vt, rt, tt);
    return rt.val1.delete(Fe), rt.val2.delete(Ye), fi;
  }
  function Oe(Fe, Ye, it, rt) {
    for (var tt = B(Fe), vt = 0; vt < tt.length; vt++) {
      var St = tt[vt];
      if (Qe(Ye, St, it, rt))
        return Fe.delete(St), !0;
    }
    return !1;
  }
  function Xe(Fe) {
    switch (S(Fe)) {
      case "undefined":
        return null;
      case "object":
        return;
      case "symbol":
        return !1;
      case "string":
        Fe = +Fe;
      case "number":
        if (D(Fe))
          return !1;
    }
    return !0;
  }
  function et(Fe, Ye, it) {
    var rt = Xe(it);
    return rt ?? (Ye.has(rt) && !Fe.has(rt));
  }
  function nt(Fe, Ye, it, rt, tt) {
    var vt = Xe(it);
    if (vt != null)
      return vt;
    var St = Ye.get(vt);
    return St === void 0 && !Ye.has(vt) || !Qe(rt, St, !1, tt) ? !1 : !Fe.has(vt) && Qe(rt, St, !1, tt);
  }
  function re(Fe, Ye, it, rt) {
    for (var tt = null, vt = B(Fe), St = 0; St < vt.length; St++) {
      var ot = vt[St];
      if (S(ot) === "object" && ot !== null)
        tt === null && (tt = /* @__PURE__ */ new Set()), tt.add(ot);
      else if (!Ye.has(ot)) {
        if (it || !et(Fe, Ye, ot))
          return !1;
        tt === null && (tt = /* @__PURE__ */ new Set()), tt.add(ot);
      }
    }
    if (tt !== null) {
      for (var si = B(Ye), oi = 0; oi < si.length; oi++) {
        var At = si[oi];
        if (S(At) === "object" && At !== null) {
          if (!Oe(tt, At, it, rt))
            return !1;
        } else if (!it && !Fe.has(At) && !Oe(tt, At, it, rt))
          return !1;
      }
      return tt.size === 0;
    }
    return !0;
  }
  function oe(Fe, Ye, it, rt, tt, vt) {
    for (var St = B(Fe), ot = 0; ot < St.length; ot++) {
      var si = St[ot];
      if (Qe(it, si, tt, vt) && Qe(rt, Ye.get(si), tt, vt))
        return Fe.delete(si), !0;
    }
    return !1;
  }
  function le(Fe, Ye, it, rt) {
    for (var tt = null, vt = M(Fe), St = 0; St < vt.length; St++) {
      var ot = e(vt[St], 2), si = ot[0], oi = ot[1];
      if (S(si) === "object" && si !== null)
        tt === null && (tt = /* @__PURE__ */ new Set()), tt.add(si);
      else {
        var At = Ye.get(si);
        if (At === void 0 && !Ye.has(si) || !Qe(oi, At, it, rt)) {
          if (it || !nt(Fe, Ye, si, oi, rt))
            return !1;
          tt === null && (tt = /* @__PURE__ */ new Set()), tt.add(si);
        }
      }
    }
    if (tt !== null) {
      for (var Nn = M(Ye), ui = 0; ui < Nn.length; ui++) {
        var Bt = e(Nn[ui], 2), si = Bt[0], vi = Bt[1];
        if (S(si) === "object" && si !== null) {
          if (!oe(tt, Fe, si, vi, it, rt))
            return !1;
        } else if (!it && (!Fe.has(si) || !Qe(Fe.get(si), vi, !1, rt)) && !oe(tt, Fe, si, vi, !1, rt))
          return !1;
      }
      return tt.size === 0;
    }
    return !0;
  }
  function ge(Fe, Ye, it, rt, tt, vt) {
    var St = 0;
    if (vt === z) {
      if (!re(Fe, Ye, it, tt))
        return !1;
    } else if (vt === me) {
      if (!le(Fe, Ye, it, tt))
        return !1;
    } else if (vt === q)
      for (; St < Fe.length; St++)
        if (Y(Fe, St)) {
          if (!Y(Ye, St) || !Qe(Fe[St], Ye[St], it, tt))
            return !1;
        } else {
          if (Y(Ye, St))
            return !1;
          for (var ot = Object.keys(Fe); St < ot.length; St++) {
            var si = ot[St];
            if (!Y(Ye, si) || !Qe(Fe[si], Ye[si], it, tt))
              return !1;
          }
          return ot.length === Object.keys(Ye).length;
        }
    for (St = 0; St < rt.length; St++) {
      var oi = rt[St];
      if (!Qe(Fe[oi], Ye[oi], it, tt))
        return !1;
    }
    return !0;
  }
  function Ke(Fe, Ye) {
    return Qe(Fe, Ye, $);
  }
  function Je(Fe, Ye) {
    return Qe(Fe, Ye, F);
  }
  return ku = {
    isDeepEqual: Ke,
    isDeepStrictEqual: Je
  }, ku;
}
var Bp;
function Os() {
  if (Bp)
    return xu.exports;
  Bp = 1;
  function e(q) {
    return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? e = function(z) {
      return typeof z;
    } : e = function(z) {
      return z && typeof Symbol == "function" && z.constructor === Symbol && z !== Symbol.prototype ? "symbol" : typeof z;
    }, e(q);
  }
  function t(q, z) {
    if (!(q instanceof z))
      throw new TypeError("Cannot call a class as a function");
  }
  var h = e2(), o = h.codes, S = o.ERR_AMBIGUOUS_ARGUMENT, g = o.ERR_INVALID_ARG_TYPE, B = o.ERR_INVALID_ARG_VALUE, M = o.ERR_INVALID_RETURN_VALUE, O = o.ERR_MISSING_ARGS, P = lC(), D = wn, Z = D.inspect, Y = wn.types, ee = Y.isPromise, ie = Y.isRegExp, ue = Object.assign ? Object.assign : dC().assign, fe = Object.is ? Object.is : n2(), de, ce;
  function be() {
    var q = xC();
    de = q.isDeepEqual, ce = q.isDeepStrictEqual;
  }
  var ve = !1, Pe = xu.exports = $e, Ue = {};
  function ze(q) {
    throw q.message instanceof Error ? q.message : new P(q);
  }
  function Le(q, z, me, Ce, je) {
    var Re = arguments.length, Ae;
    if (Re === 0)
      Ae = "Failed";
    else if (Re === 1)
      me = q, q = void 0;
    else {
      if (ve === !1) {
        ve = !0;
        var ke = Ve.emitWarning ? Ve.emitWarning : console.warn.bind(console);
        ke("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      Re === 2 && (Ce = "!=");
    }
    if (me instanceof Error)
      throw me;
    var Qe = {
      actual: q,
      expected: z,
      operator: Ce === void 0 ? "fail" : Ce,
      stackStartFn: je || Le
    };
    me !== void 0 && (Qe.message = me);
    var Ze = new P(Qe);
    throw Ae && (Ze.message = Ae, Ze.generatedMessage = !0), Ze;
  }
  Pe.fail = Le, Pe.AssertionError = P;
  function Ne(q, z, me, Ce) {
    if (!me) {
      var je = !1;
      if (z === 0)
        je = !0, Ce = "No value argument passed to `assert.ok()`";
      else if (Ce instanceof Error)
        throw Ce;
      var Re = new P({
        actual: me,
        expected: !0,
        message: Ce,
        operator: "==",
        stackStartFn: q
      });
      throw Re.generatedMessage = je, Re;
    }
  }
  function $e() {
    for (var q = arguments.length, z = new Array(q), me = 0; me < q; me++)
      z[me] = arguments[me];
    Ne.apply(void 0, [$e, z.length].concat(z));
  }
  Pe.ok = $e, Pe.equal = function q(z, me, Ce) {
    if (arguments.length < 2)
      throw new O("actual", "expected");
    z != me && ze({
      actual: z,
      expected: me,
      message: Ce,
      operator: "==",
      stackStartFn: q
    });
  }, Pe.notEqual = function q(z, me, Ce) {
    if (arguments.length < 2)
      throw new O("actual", "expected");
    z == me && ze({
      actual: z,
      expected: me,
      message: Ce,
      operator: "!=",
      stackStartFn: q
    });
  }, Pe.deepEqual = function q(z, me, Ce) {
    if (arguments.length < 2)
      throw new O("actual", "expected");
    de === void 0 && be(), de(z, me) || ze({
      actual: z,
      expected: me,
      message: Ce,
      operator: "deepEqual",
      stackStartFn: q
    });
  }, Pe.notDeepEqual = function q(z, me, Ce) {
    if (arguments.length < 2)
      throw new O("actual", "expected");
    de === void 0 && be(), de(z, me) && ze({
      actual: z,
      expected: me,
      message: Ce,
      operator: "notDeepEqual",
      stackStartFn: q
    });
  }, Pe.deepStrictEqual = function q(z, me, Ce) {
    if (arguments.length < 2)
      throw new O("actual", "expected");
    de === void 0 && be(), ce(z, me) || ze({
      actual: z,
      expected: me,
      message: Ce,
      operator: "deepStrictEqual",
      stackStartFn: q
    });
  }, Pe.notDeepStrictEqual = J;
  function J(q, z, me) {
    if (arguments.length < 2)
      throw new O("actual", "expected");
    de === void 0 && be(), ce(q, z) && ze({
      actual: q,
      expected: z,
      message: me,
      operator: "notDeepStrictEqual",
      stackStartFn: J
    });
  }
  Pe.strictEqual = function q(z, me, Ce) {
    if (arguments.length < 2)
      throw new O("actual", "expected");
    fe(z, me) || ze({
      actual: z,
      expected: me,
      message: Ce,
      operator: "strictEqual",
      stackStartFn: q
    });
  }, Pe.notStrictEqual = function q(z, me, Ce) {
    if (arguments.length < 2)
      throw new O("actual", "expected");
    fe(z, me) && ze({
      actual: z,
      expected: me,
      message: Ce,
      operator: "notStrictEqual",
      stackStartFn: q
    });
  };
  var ne = function q(z, me, Ce) {
    var je = this;
    t(this, q), me.forEach(function(Re) {
      Re in z && (Ce !== void 0 && typeof Ce[Re] == "string" && ie(z[Re]) && z[Re].test(Ce[Re]) ? je[Re] = Ce[Re] : je[Re] = z[Re]);
    });
  };
  function A(q, z, me, Ce, je, Re) {
    if (!(me in q) || !ce(q[me], z[me])) {
      if (!Ce) {
        var Ae = new ne(q, je), ke = new ne(z, je, q), Qe = new P({
          actual: Ae,
          expected: ke,
          operator: "deepStrictEqual",
          stackStartFn: Re
        });
        throw Qe.actual = q, Qe.expected = z, Qe.operator = Re.name, Qe;
      }
      ze({
        actual: q,
        expected: z,
        message: Ce,
        operator: Re.name,
        stackStartFn: Re
      });
    }
  }
  function I(q, z, me, Ce) {
    if (typeof z != "function") {
      if (ie(z))
        return z.test(q);
      if (arguments.length === 2)
        throw new g("expected", ["Function", "RegExp"], z);
      if (e(q) !== "object" || q === null) {
        var je = new P({
          actual: q,
          expected: z,
          message: me,
          operator: "deepStrictEqual",
          stackStartFn: Ce
        });
        throw je.operator = Ce.name, je;
      }
      var Re = Object.keys(z);
      if (z instanceof Error)
        Re.push("name", "message");
      else if (Re.length === 0)
        throw new B("error", z, "may not be an empty object");
      return de === void 0 && be(), Re.forEach(function(Ae) {
        typeof q[Ae] == "string" && ie(z[Ae]) && z[Ae].test(q[Ae]) || A(q, z, Ae, me, Re, Ce);
      }), !0;
    }
    return z.prototype !== void 0 && q instanceof z ? !0 : Error.isPrototypeOf(z) ? !1 : z.call({}, q) === !0;
  }
  function U(q) {
    if (typeof q != "function")
      throw new g("fn", "Function", q);
    try {
      q();
    } catch (z) {
      return z;
    }
    return Ue;
  }
  function X(q) {
    return ee(q) || q !== null && e(q) === "object" && typeof q.then == "function" && typeof q.catch == "function";
  }
  function Q(q) {
    return Promise.resolve().then(function() {
      var z;
      if (typeof q == "function") {
        if (z = q(), !X(z))
          throw new M("instance of Promise", "promiseFn", z);
      } else if (X(q))
        z = q;
      else
        throw new g("promiseFn", ["Function", "Promise"], q);
      return Promise.resolve().then(function() {
        return z;
      }).then(function() {
        return Ue;
      }).catch(function(me) {
        return me;
      });
    });
  }
  function F(q, z, me, Ce) {
    if (typeof me == "string") {
      if (arguments.length === 4)
        throw new g("error", ["Object", "Error", "Function", "RegExp"], me);
      if (e(z) === "object" && z !== null) {
        if (z.message === me)
          throw new S("error/message", 'The error message "'.concat(z.message, '" is identical to the message.'));
      } else if (z === me)
        throw new S("error/message", 'The error "'.concat(z, '" is identical to the message.'));
      Ce = me, me = void 0;
    } else if (me != null && e(me) !== "object" && typeof me != "function")
      throw new g("error", ["Object", "Error", "Function", "RegExp"], me);
    if (z === Ue) {
      var je = "";
      me && me.name && (je += " (".concat(me.name, ")")), je += Ce ? ": ".concat(Ce) : ".";
      var Re = q.name === "rejects" ? "rejection" : "exception";
      ze({
        actual: void 0,
        expected: me,
        operator: q.name,
        message: "Missing expected ".concat(Re).concat(je),
        stackStartFn: q
      });
    }
    if (me && !I(z, me, Ce, q))
      throw z;
  }
  function $(q, z, me, Ce) {
    if (z !== Ue) {
      if (typeof me == "string" && (Ce = me, me = void 0), !me || I(z, me)) {
        var je = Ce ? ": ".concat(Ce) : ".", Re = q.name === "doesNotReject" ? "rejection" : "exception";
        ze({
          actual: z,
          expected: me,
          operator: q.name,
          message: "Got unwanted ".concat(Re).concat(je, `
`) + 'Actual message: "'.concat(z && z.message, '"'),
          stackStartFn: q
        });
      }
      throw z;
    }
  }
  Pe.throws = function q(z) {
    for (var me = arguments.length, Ce = new Array(me > 1 ? me - 1 : 0), je = 1; je < me; je++)
      Ce[je - 1] = arguments[je];
    F.apply(void 0, [q, U(z)].concat(Ce));
  }, Pe.rejects = function q(z) {
    for (var me = arguments.length, Ce = new Array(me > 1 ? me - 1 : 0), je = 1; je < me; je++)
      Ce[je - 1] = arguments[je];
    return Q(z).then(function(Re) {
      return F.apply(void 0, [q, Re].concat(Ce));
    });
  }, Pe.doesNotThrow = function q(z) {
    for (var me = arguments.length, Ce = new Array(me > 1 ? me - 1 : 0), je = 1; je < me; je++)
      Ce[je - 1] = arguments[je];
    $.apply(void 0, [q, U(z)].concat(Ce));
  }, Pe.doesNotReject = function q(z) {
    for (var me = arguments.length, Ce = new Array(me > 1 ? me - 1 : 0), je = 1; je < me; je++)
      Ce[je - 1] = arguments[je];
    return Q(z).then(function(Re) {
      return $.apply(void 0, [q, Re].concat(Ce));
    });
  }, Pe.ifError = function q(z) {
    if (z != null) {
      var me = "ifError got unwanted exception: ";
      e(z) === "object" && typeof z.message == "string" ? z.message.length === 0 && z.constructor ? me += z.constructor.name : me += z.message : me += Z(z);
      var Ce = new P({
        actual: z,
        expected: null,
        operator: "ifError",
        message: me,
        stackStartFn: q
      }), je = z.stack;
      if (typeof je == "string") {
        var Re = je.split(`
`);
        Re.shift();
        for (var Ae = Ce.stack.split(`
`), ke = 0; ke < Re.length; ke++) {
          var Qe = Ae.indexOf(Re[ke]);
          if (Qe !== -1) {
            Ae = Ae.slice(0, Qe);
            break;
          }
        }
        Ce.stack = "".concat(Ae.join(`
`), `
`).concat(Re.join(`
`));
      }
      throw Ce;
    }
  };
  function H() {
    for (var q = arguments.length, z = new Array(q), me = 0; me < q; me++)
      z[me] = arguments[me];
    Ne.apply(void 0, [H, z.length].concat(z));
  }
  return Pe.strict = ue(H, Pe, {
    equal: Pe.strictEqual,
    deepEqual: Pe.deepStrictEqual,
    notEqual: Pe.notStrictEqual,
    notDeepEqual: Pe.notDeepStrictEqual
  }), Pe.strict.strict = Pe.strict, xu.exports;
}
var _C = Os(), f2 = $0.Buffer, z0 = Nh, EC = Rh, Oa = EC.newInvalidAsn1Error;
function Er(e) {
  if (!e || !f2.isBuffer(e))
    throw new TypeError("data must be a node Buffer");
  this._buf = e, this._size = e.length, this._len = 0, this._offset = 0;
}
Object.defineProperty(Er.prototype, "length", {
  enumerable: !0,
  get: function() {
    return this._len;
  }
});
Object.defineProperty(Er.prototype, "offset", {
  enumerable: !0,
  get: function() {
    return this._offset;
  }
});
Object.defineProperty(Er.prototype, "remain", {
  get: function() {
    return this._size - this._offset;
  }
});
Object.defineProperty(Er.prototype, "buffer", {
  get: function() {
    return this._buf.slice(this._offset);
  }
});
Er.prototype.readByte = function(e) {
  if (this._size - this._offset < 1)
    return null;
  var t = this._buf[this._offset] & 255;
  return e || (this._offset += 1), t;
};
Er.prototype.peek = function() {
  return this.readByte(!0);
};
Er.prototype.readLength = function(e) {
  if (e === void 0 && (e = this._offset), e >= this._size)
    return null;
  var t = this._buf[e++] & 255;
  if (t === null)
    return null;
  if ((t & 128) === 128) {
    if (t &= 127, t === 0)
      throw Oa("Indefinite length not supported");
    if (t > 4)
      throw Oa("encoding too long");
    if (this._size - e < t)
      return null;
    this._len = 0;
    for (var h = 0; h < t; h++)
      this._len = (this._len << 8) + (this._buf[e++] & 255);
  } else
    this._len = t;
  return e;
};
Er.prototype.readSequence = function(e) {
  var t = this.peek();
  if (t === null)
    return null;
  if (e !== void 0 && e !== t)
    throw Oa("Expected 0x" + e.toString(16) + ": got 0x" + t.toString(16));
  var h = this.readLength(this._offset + 1);
  return h === null ? null : (this._offset = h, t);
};
Er.prototype.readInt = function() {
  return this._readTag(z0.Integer);
};
Er.prototype.readBoolean = function() {
  return this._readTag(z0.Boolean) !== 0;
};
Er.prototype.readEnumeration = function() {
  return this._readTag(z0.Enumeration);
};
Er.prototype.readString = function(e, t) {
  e || (e = z0.OctetString);
  var h = this.peek();
  if (h === null)
    return null;
  if (h !== e)
    throw Oa("Expected 0x" + e.toString(16) + ": got 0x" + h.toString(16));
  var o = this.readLength(this._offset + 1);
  if (o === null || this.length > this._size - o)
    return null;
  if (this._offset = o, this.length === 0)
    return t ? f2.alloc(0) : "";
  var S = this._buf.slice(this._offset, this._offset + this.length);
  return this._offset += this.length, t ? S : S.toString("utf8");
};
Er.prototype.readOID = function(e) {
  e || (e = z0.OID);
  var t = this.readString(e, !0);
  if (t === null)
    return null;
  for (var h = [], o = 0, S = 0; S < t.length; S++) {
    var g = t[S] & 255;
    o <<= 7, o += g & 127, g & 128 || (h.push(o), o = 0);
  }
  return o = h.shift(), h.unshift(o % 40), h.unshift(o / 40 >> 0), h.join(".");
};
Er.prototype._readTag = function(e) {
  _C.ok(e !== void 0);
  var t = this.peek();
  if (t === null)
    return null;
  if (t !== e)
    throw Oa("Expected 0x" + e.toString(16) + ": got 0x" + t.toString(16));
  var h = this.readLength(this._offset + 1);
  if (h === null)
    return null;
  if (this.length > 4)
    throw Oa("Integer too long: " + this.length);
  if (this.length > this._size - h)
    return null;
  this._offset = h;
  for (var o = this._buf[this._offset], S = 0, g = 0; g < this.length; g++)
    S <<= 8, S |= this._buf[this._offset++] & 255;
  return (o & 128) === 128 && g !== 4 && (S -= 1 << g * 8), S >> 0;
};
var SC = Er, yn = Os(), Nf = $0.Buffer, An = Nh, wC = Rh, Df = wC.newInvalidAsn1Error, CC = {
  size: 1024,
  growthFactor: 8
};
function AC(e, t) {
  yn.ok(e), yn.equal(typeof e, "object"), yn.ok(t), yn.equal(typeof t, "object");
  var h = Object.getOwnPropertyNames(e);
  return h.forEach(function(o) {
    if (!t[o]) {
      var S = Object.getOwnPropertyDescriptor(e, o);
      Object.defineProperty(t, o, S);
    }
  }), t;
}
function pr(e) {
  e = AC(CC, e || {}), this._buf = Nf.alloc(e.size || 1024), this._size = this._buf.length, this._offset = 0, this._options = e, this._seq = [];
}
Object.defineProperty(pr.prototype, "buffer", {
  get: function() {
    if (this._seq.length)
      throw Df(this._seq.length + " unended sequence(s)");
    return this._buf.slice(0, this._offset);
  }
});
pr.prototype.writeByte = function(e) {
  if (typeof e != "number")
    throw new TypeError("argument must be a Number");
  this._ensure(1), this._buf[this._offset++] = e;
};
pr.prototype.writeInt = function(e, t) {
  if (typeof e != "number")
    throw new TypeError("argument must be a Number");
  typeof t != "number" && (t = An.Integer);
  for (var h = 4; (!(e & 4286578688) || (e & 4286578688) === -8388608) && h > 1; )
    h--, e <<= 8;
  if (h > 4)
    throw Df("BER ints cannot be > 0xffffffff");
  for (this._ensure(2 + h), this._buf[this._offset++] = t, this._buf[this._offset++] = h; h-- > 0; )
    this._buf[this._offset++] = (e & 4278190080) >>> 24, e <<= 8;
};
pr.prototype.writeNull = function() {
  this.writeByte(An.Null), this.writeByte(0);
};
pr.prototype.writeEnumeration = function(e, t) {
  if (typeof e != "number")
    throw new TypeError("argument must be a Number");
  return typeof t != "number" && (t = An.Enumeration), this.writeInt(e, t);
};
pr.prototype.writeBoolean = function(e, t) {
  if (typeof e != "boolean")
    throw new TypeError("argument must be a Boolean");
  typeof t != "number" && (t = An.Boolean), this._ensure(3), this._buf[this._offset++] = t, this._buf[this._offset++] = 1, this._buf[this._offset++] = e ? 255 : 0;
};
pr.prototype.writeString = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("argument must be a string (was: " + typeof e + ")");
  typeof t != "number" && (t = An.OctetString);
  var h = Nf.byteLength(e);
  this.writeByte(t), this.writeLength(h), h && (this._ensure(h), this._buf.write(e, this._offset), this._offset += h);
};
pr.prototype.writeBuffer = function(e, t) {
  if (typeof t != "number")
    throw new TypeError("tag must be a number");
  if (!Nf.isBuffer(e))
    throw new TypeError("argument must be a buffer");
  this.writeByte(t), this.writeLength(e.length), this._ensure(e.length), e.copy(this._buf, this._offset, 0, e.length), this._offset += e.length;
};
pr.prototype.writeStringArray = function(e) {
  if (!e instanceof Array)
    throw new TypeError("argument must be an Array[String]");
  var t = this;
  e.forEach(function(h) {
    t.writeString(h);
  });
};
pr.prototype.writeOID = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("argument must be a string");
  if (typeof t != "number" && (t = An.OID), !/^([0-9]+\.){3,}[0-9]+$/.test(e))
    throw new Error("argument is not a valid OID string");
  function h(B, M) {
    M < 128 ? B.push(M) : M < 16384 ? (B.push(M >>> 7 | 128), B.push(M & 127)) : M < 2097152 ? (B.push(M >>> 14 | 128), B.push((M >>> 7 | 128) & 255), B.push(M & 127)) : M < 268435456 ? (B.push(M >>> 21 | 128), B.push((M >>> 14 | 128) & 255), B.push((M >>> 7 | 128) & 255), B.push(M & 127)) : (B.push((M >>> 28 | 128) & 255), B.push((M >>> 21 | 128) & 255), B.push((M >>> 14 | 128) & 255), B.push((M >>> 7 | 128) & 255), B.push(M & 127));
  }
  var o = e.split("."), S = [];
  S.push(parseInt(o[0], 10) * 40 + parseInt(o[1], 10)), o.slice(2).forEach(function(B) {
    h(S, parseInt(B, 10));
  });
  var g = this;
  this._ensure(2 + S.length), this.writeByte(t), this.writeLength(S.length), S.forEach(function(B) {
    g.writeByte(B);
  });
};
pr.prototype.writeLength = function(e) {
  if (typeof e != "number")
    throw new TypeError("argument must be a Number");
  if (this._ensure(4), e <= 127)
    this._buf[this._offset++] = e;
  else if (e <= 255)
    this._buf[this._offset++] = 129, this._buf[this._offset++] = e;
  else if (e <= 65535)
    this._buf[this._offset++] = 130, this._buf[this._offset++] = e >> 8, this._buf[this._offset++] = e;
  else if (e <= 16777215)
    this._buf[this._offset++] = 131, this._buf[this._offset++] = e >> 16, this._buf[this._offset++] = e >> 8, this._buf[this._offset++] = e;
  else
    throw Df("Length too long (> 4 bytes)");
};
pr.prototype.startSequence = function(e) {
  typeof e != "number" && (e = An.Sequence | An.Constructor), this.writeByte(e), this._seq.push(this._offset), this._ensure(3), this._offset += 3;
};
pr.prototype.endSequence = function() {
  var e = this._seq.pop(), t = e + 3, h = this._offset - t;
  if (h <= 127)
    this._shift(t, h, -2), this._buf[e] = h;
  else if (h <= 255)
    this._shift(t, h, -1), this._buf[e] = 129, this._buf[e + 1] = h;
  else if (h <= 65535)
    this._buf[e] = 130, this._buf[e + 1] = h >> 8, this._buf[e + 2] = h;
  else if (h <= 16777215)
    this._shift(t, h, 1), this._buf[e] = 131, this._buf[e + 1] = h >> 16, this._buf[e + 2] = h >> 8, this._buf[e + 3] = h;
  else
    throw Df("Sequence too long");
};
pr.prototype._shift = function(e, t, h) {
  yn.ok(e !== void 0), yn.ok(t !== void 0), yn.ok(h), this._buf.copy(this._buf, e + h, e, e + t), this._offset += h;
};
pr.prototype._ensure = function(e) {
  if (yn.ok(e), this._size - this._offset < e) {
    var t = this._size * this._options.growthFactor;
    t - this._offset < e && (t += e);
    var h = Nf.alloc(t);
    this._buf.copy(h, 0, 0, this._offset), this._buf = h, this._size = t;
  }
};
var BC = pr;
(function(e) {
  var t = Rh, h = Nh, o = SC, S = BC;
  e.exports = {
    Reader: o,
    Writer: S
  };
  for (var g in h)
    h.hasOwnProperty(g) && (e.exports[g] = h[g]);
  for (var B in t)
    t.hasOwnProperty(B) && (e.exports[B] = t[B]);
})(Jy);
var IC = Jy.exports, Uu = IC, Dh = {
  Ber: Uu,
  BerReader: Uu.Reader,
  BerWriter: Uu.Writer
}, o2 = { exports: {} }, u2 = { exports: {} };
(function(e) {
  var t = Dh.Ber, h = tr._, o = tr;
  const S = "-----BEGIN RSA PRIVATE KEY-----", g = "-----END RSA PRIVATE KEY-----", B = "-----BEGIN RSA PUBLIC KEY-----", M = "-----END RSA PUBLIC KEY-----";
  e.exports = {
    privateExport: function(O, P) {
      P = P || {};
      var D = O.n.toBuffer(), Z = O.d.toBuffer(), Y = O.p.toBuffer(), ee = O.q.toBuffer(), ie = O.dmp1.toBuffer(), ue = O.dmq1.toBuffer(), fe = O.coeff.toBuffer(), de = D.length + Z.length + Y.length + ee.length + ie.length + ue.length + fe.length + 512, ce = new t.Writer({ size: de });
      return ce.startSequence(), ce.writeInt(0), ce.writeBuffer(D, 2), ce.writeInt(O.e), ce.writeBuffer(Z, 2), ce.writeBuffer(Y, 2), ce.writeBuffer(ee, 2), ce.writeBuffer(ie, 2), ce.writeBuffer(ue, 2), ce.writeBuffer(fe, 2), ce.endSequence(), P.type === "der" ? ce.buffer : S + `
` + o.linebrk(ce.buffer.toString("base64"), 64) + `
` + g;
    },
    privateImport: function(O, P, D) {
      D = D || {};
      var Z;
      if (D.type !== "der")
        if (pe.Buffer.isBuffer(P) && (P = P.toString("utf8")), h.isString(P)) {
          var Y = o.trimSurroundingText(P, S, g).replace(/\s+|\n\r|\n|\r$/gm, "");
          Z = pe.Buffer.from(Y, "base64");
        } else
          throw Error("Unsupported key format");
      else if (pe.Buffer.isBuffer(P))
        Z = P;
      else
        throw Error("Unsupported key format");
      var ee = new t.Reader(Z);
      ee.readSequence(), ee.readString(2, !0), O.setPrivate(
        ee.readString(2, !0),
        // modulus
        ee.readString(2, !0),
        // publicExponent
        ee.readString(2, !0),
        // privateExponent
        ee.readString(2, !0),
        // prime1
        ee.readString(2, !0),
        // prime2
        ee.readString(2, !0),
        // exponent1 -- d mod (p1)
        ee.readString(2, !0),
        // exponent2 -- d mod (q-1)
        ee.readString(2, !0)
        // coefficient -- (inverse of q) mod p
      );
    },
    publicExport: function(O, P) {
      P = P || {};
      var D = O.n.toBuffer(), Z = D.length + 512, Y = new t.Writer({ size: Z });
      return Y.startSequence(), Y.writeBuffer(D, 2), Y.writeInt(O.e), Y.endSequence(), P.type === "der" ? Y.buffer : B + `
` + o.linebrk(Y.buffer.toString("base64"), 64) + `
` + M;
    },
    publicImport: function(O, P, D) {
      D = D || {};
      var Z;
      if (D.type !== "der") {
        if (pe.Buffer.isBuffer(P) && (P = P.toString("utf8")), h.isString(P)) {
          var Y = o.trimSurroundingText(P, B, M).replace(/\s+|\n\r|\n|\r$/gm, "");
          Z = pe.Buffer.from(Y, "base64");
        }
      } else if (pe.Buffer.isBuffer(P))
        Z = P;
      else
        throw Error("Unsupported key format");
      var ee = new t.Reader(Z);
      ee.readSequence(), O.setPublic(
        ee.readString(2, !0),
        // modulus
        ee.readString(2, !0)
        // publicExponent
      );
    },
    /**
     * Trying autodetect and import key
     * @param key
     * @param data
     */
    autoImport: function(O, P) {
      return /^[\S\s]*-----BEGIN RSA PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END RSA PRIVATE KEY-----[\S\s]*$/g.test(P) ? (e.exports.privateImport(O, P), !0) : /^[\S\s]*-----BEGIN RSA PUBLIC KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END RSA PUBLIC KEY-----[\S\s]*$/g.test(P) ? (e.exports.publicImport(O, P), !0) : !1;
    }
  };
})(u2);
var TC = u2.exports, c2 = { exports: {} };
(function(e) {
  var t = Dh.Ber, h = tr._, o = "1.2.840.113549.1.1.1", S = tr;
  const g = "-----BEGIN PRIVATE KEY-----", B = "-----END PRIVATE KEY-----", M = "-----BEGIN PUBLIC KEY-----", O = "-----END PUBLIC KEY-----";
  e.exports = {
    privateExport: function(P, D) {
      D = D || {};
      var Z = P.n.toBuffer(), Y = P.d.toBuffer(), ee = P.p.toBuffer(), ie = P.q.toBuffer(), ue = P.dmp1.toBuffer(), fe = P.dmq1.toBuffer(), de = P.coeff.toBuffer(), ce = Z.length + Y.length + ee.length + ie.length + ue.length + fe.length + de.length + 512, be = new t.Writer({ size: ce });
      be.startSequence(), be.writeInt(0), be.writeBuffer(Z, 2), be.writeInt(P.e), be.writeBuffer(Y, 2), be.writeBuffer(ee, 2), be.writeBuffer(ie, 2), be.writeBuffer(ue, 2), be.writeBuffer(fe, 2), be.writeBuffer(de, 2), be.endSequence();
      var ve = new t.Writer({ size: ce });
      return ve.startSequence(), ve.writeInt(0), ve.startSequence(), ve.writeOID(o), ve.writeNull(), ve.endSequence(), ve.writeBuffer(be.buffer, 4), ve.endSequence(), D.type === "der" ? ve.buffer : g + `
` + S.linebrk(ve.buffer.toString("base64"), 64) + `
` + B;
    },
    privateImport: function(P, D, Z) {
      Z = Z || {};
      var Y;
      if (Z.type !== "der")
        if (pe.Buffer.isBuffer(D) && (D = D.toString("utf8")), h.isString(D)) {
          var ee = S.trimSurroundingText(D, g, B).replace("-----END PRIVATE KEY-----", "").replace(/\s+|\n\r|\n|\r$/gm, "");
          Y = pe.Buffer.from(ee, "base64");
        } else
          throw Error("Unsupported key format");
      else if (pe.Buffer.isBuffer(D))
        Y = D;
      else
        throw Error("Unsupported key format");
      var ie = new t.Reader(Y);
      ie.readSequence(), ie.readInt(0);
      var ue = new t.Reader(ie.readString(48, !0));
      if (ue.readOID(6, !0) !== o)
        throw Error("Invalid Public key format");
      var fe = new t.Reader(ie.readString(4, !0));
      fe.readSequence(), fe.readString(2, !0), P.setPrivate(
        fe.readString(2, !0),
        // modulus
        fe.readString(2, !0),
        // publicExponent
        fe.readString(2, !0),
        // privateExponent
        fe.readString(2, !0),
        // prime1
        fe.readString(2, !0),
        // prime2
        fe.readString(2, !0),
        // exponent1 -- d mod (p1)
        fe.readString(2, !0),
        // exponent2 -- d mod (q-1)
        fe.readString(2, !0)
        // coefficient -- (inverse of q) mod p
      );
    },
    publicExport: function(P, D) {
      D = D || {};
      var Z = P.n.toBuffer(), Y = Z.length + 512, ee = new t.Writer({ size: Y });
      ee.writeByte(0), ee.startSequence(), ee.writeBuffer(Z, 2), ee.writeInt(P.e), ee.endSequence();
      var ie = new t.Writer({ size: Y });
      return ie.startSequence(), ie.startSequence(), ie.writeOID(o), ie.writeNull(), ie.endSequence(), ie.writeBuffer(ee.buffer, 3), ie.endSequence(), D.type === "der" ? ie.buffer : M + `
` + S.linebrk(ie.buffer.toString("base64"), 64) + `
` + O;
    },
    publicImport: function(P, D, Z) {
      Z = Z || {};
      var Y;
      if (Z.type !== "der") {
        if (pe.Buffer.isBuffer(D) && (D = D.toString("utf8")), h.isString(D)) {
          var ee = S.trimSurroundingText(D, M, O).replace(/\s+|\n\r|\n|\r$/gm, "");
          Y = pe.Buffer.from(ee, "base64");
        }
      } else if (pe.Buffer.isBuffer(D))
        Y = D;
      else
        throw Error("Unsupported key format");
      var ie = new t.Reader(Y);
      ie.readSequence();
      var ue = new t.Reader(ie.readString(48, !0));
      if (ue.readOID(6, !0) !== o)
        throw Error("Invalid Public key format");
      var fe = new t.Reader(ie.readString(3, !0));
      fe.readByte(), fe.readSequence(), P.setPublic(
        fe.readString(2, !0),
        // modulus
        fe.readString(2, !0)
        // publicExponent
      );
    },
    /**
     * Trying autodetect and import key
     * @param key
     * @param data
     */
    autoImport: function(P, D) {
      return /^[\S\s]*-----BEGIN PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END PRIVATE KEY-----[\S\s]*$/g.test(D) ? (e.exports.privateImport(P, D), !0) : /^[\S\s]*-----BEGIN PUBLIC KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END PUBLIC KEY-----[\S\s]*$/g.test(D) ? (e.exports.publicImport(P, D), !0) : !1;
    }
  };
})(c2);
var MC = c2.exports, h2 = { exports: {} };
(function(e) {
  tr._, e.exports = {
    privateExport: function(t, h) {
      return {
        n: t.n.toBuffer(),
        e: t.e,
        d: t.d.toBuffer(),
        p: t.p.toBuffer(),
        q: t.q.toBuffer(),
        dmp1: t.dmp1.toBuffer(),
        dmq1: t.dmq1.toBuffer(),
        coeff: t.coeff.toBuffer()
      };
    },
    privateImport: function(t, h, o) {
      if (h.n && h.e && h.d && h.p && h.q && h.dmp1 && h.dmq1 && h.coeff)
        t.setPrivate(
          h.n,
          h.e,
          h.d,
          h.p,
          h.q,
          h.dmp1,
          h.dmq1,
          h.coeff
        );
      else
        throw Error("Invalid key data");
    },
    publicExport: function(t, h) {
      return {
        n: t.n.toBuffer(),
        e: t.e
      };
    },
    publicImport: function(t, h, o) {
      if (h.n && h.e)
        t.setPublic(
          h.n,
          h.e
        );
      else
        throw Error("Invalid key data");
    },
    /**
     * Trying autodetect and import key
     * @param key
     * @param data
     */
    autoImport: function(t, h) {
      return h.n && h.e ? h.d && h.p && h.q && h.dmp1 && h.dmq1 && h.coeff ? (e.exports.privateImport(t, h), !0) : (e.exports.publicImport(t, h), !0) : !1;
    }
  };
})(h2);
var RC = h2.exports, l2 = { exports: {} };
(function(e) {
  var t = tr._, h = tr, o = G0;
  const S = "-----BEGIN OPENSSH PRIVATE KEY-----", g = "-----END OPENSSH PRIVATE KEY-----";
  e.exports = {
    privateExport: function(O, P) {
      const D = O.n.toBuffer();
      let Z = pe.Buffer.alloc(4);
      for (Z.writeUInt32BE(O.e, 0); Z[0] === 0; )
        Z = Z.slice(1);
      const Y = O.d.toBuffer(), ee = O.coeff.toBuffer(), ie = O.p.toBuffer(), ue = O.q.toBuffer();
      let fe;
      typeof O.sshcomment < "u" ? fe = pe.Buffer.from(O.sshcomment) : fe = pe.Buffer.from([]);
      const de = 15 + Z.byteLength + 4 + D.byteLength, ce = 23 + D.byteLength + 4 + Z.byteLength + 4 + Y.byteLength + 4 + ee.byteLength + 4 + ie.byteLength + 4 + ue.byteLength + 4 + fe.byteLength;
      let be = 43 + // 32bit pubkey length
      de + 4 + //32bit private+checksum+comment+padding length
      ce;
      const ve = Math.ceil(ce / 8) * 8 - ce;
      be += ve;
      const Pe = pe.Buffer.alloc(be), Ue = { buf: Pe, off: 0 };
      Pe.write("openssh-key-v1", "utf8"), Pe.writeUInt8(0, 14), Ue.off += 15, M(Ue, pe.Buffer.from("none")), M(Ue, pe.Buffer.from("none")), M(Ue, pe.Buffer.from("")), Ue.off = Ue.buf.writeUInt32BE(1, Ue.off), Ue.off = Ue.buf.writeUInt32BE(de, Ue.off), M(Ue, pe.Buffer.from("ssh-rsa")), M(Ue, Z), M(Ue, D), Ue.off = Ue.buf.writeUInt32BE(
        be - 47 - de,
        Ue.off
      ), Ue.off += 8, M(Ue, pe.Buffer.from("ssh-rsa")), M(Ue, D), M(Ue, Z), M(Ue, Y), M(Ue, ee), M(Ue, ie), M(Ue, ue), M(Ue, fe);
      let ze = 1;
      for (; Ue.off < be; )
        Ue.off = Ue.buf.writeUInt8(ze++, Ue.off);
      return P.type === "der" ? Ue.buf : S + `
` + h.linebrk(Pe.toString("base64"), 70) + `
` + g + `
`;
    },
    privateImport: function(O, P, D) {
      D = D || {};
      var Z;
      if (D.type !== "der")
        if (pe.Buffer.isBuffer(P) && (P = P.toString("utf8")), t.isString(P)) {
          var Y = h.trimSurroundingText(P, S, g).replace(/\s+|\n\r|\n|\r$/gm, "");
          Z = pe.Buffer.from(Y, "base64");
        } else
          throw Error("Unsupported key format");
      else if (pe.Buffer.isBuffer(P))
        Z = P;
      else
        throw Error("Unsupported key format");
      const ee = { buf: Z, off: 0 };
      if (Z.slice(0, 14).toString("ascii") !== "openssh-key-v1")
        throw "Invalid file format.";
      if (ee.off += 15, B(ee).toString("ascii") !== "none" || B(ee).toString("ascii") !== "none" || B(ee).toString("ascii") !== "" || (ee.off += 4, ee.off += 4, B(ee).toString("ascii") !== "ssh-rsa") || (B(ee), B(ee), ee.off += 12, B(ee).toString("ascii") !== "ssh-rsa"))
        throw Error("Unsupported key type");
      const ie = B(ee), ue = B(ee), fe = B(ee), de = B(ee), ce = B(ee), be = B(ee), ve = new o(fe), Pe = new o(be), Ue = new o(ce), ze = ve.mod(Ue.subtract(o.ONE)), Le = ve.mod(Pe.subtract(o.ONE));
      O.setPrivate(
        ie,
        // modulus
        ue,
        // publicExponent
        fe,
        // privateExponent
        ce,
        // prime1
        be,
        // prime2
        ze.toBuffer(),
        // exponent1 -- d mod (p1)
        Le.toBuffer(),
        // exponent2 -- d mod (q-1)
        de
        // coefficient -- (inverse of q) mod p
      ), O.sshcomment = B(ee).toString("ascii");
    },
    publicExport: function(O, P) {
      let D = pe.Buffer.alloc(4);
      for (D.writeUInt32BE(O.e, 0); D[0] === 0; )
        D = D.slice(1);
      const Z = O.n.toBuffer(), Y = pe.Buffer.alloc(
        D.byteLength + 4 + Z.byteLength + 4 + 7 + 4
      ), ee = { buf: Y, off: 0 };
      M(ee, pe.Buffer.from("ssh-rsa")), M(ee, D), M(ee, Z);
      let ie = O.sshcomment || "";
      return P.type === "der" ? ee.buf : "ssh-rsa " + Y.toString("base64") + " " + ie + `
`;
    },
    publicImport: function(O, P, D) {
      D = D || {};
      var Z;
      if (D.type !== "der")
        if (pe.Buffer.isBuffer(P) && (P = P.toString("utf8")), t.isString(P)) {
          if (P.substring(0, 8) !== "ssh-rsa ")
            throw Error("Unsupported key format");
          let fe = P.indexOf(" ", 8);
          fe === -1 ? fe = P.length : O.sshcomment = P.substring(fe + 1).replace(/\s+|\n\r|\n|\r$/gm, "");
          const de = P.substring(8, fe).replace(/\s+|\n\r|\n|\r$/gm, "");
          Z = pe.Buffer.from(de, "base64");
        } else
          throw Error("Unsupported key format");
      else if (pe.Buffer.isBuffer(P))
        Z = P;
      else
        throw Error("Unsupported key format");
      const Y = { buf: Z, off: 0 }, ee = B(Y).toString("ascii");
      if (ee !== "ssh-rsa")
        throw Error("Invalid key type: " + ee);
      const ie = B(Y), ue = B(Y);
      O.setPublic(
        ue,
        ie
      );
    },
    /**
     * Trying autodetect and import key
     * @param key
     * @param data
     */
    autoImport: function(O, P) {
      return /^[\S\s]*-----BEGIN OPENSSH PRIVATE KEY-----\s*(?=(([A-Za-z0-9+/=]+\s*)+))\1-----END OPENSSH PRIVATE KEY-----[\S\s]*$/g.test(P) ? (e.exports.privateImport(O, P), !0) : /^[\S\s]*ssh-rsa \s*(?=(([A-Za-z0-9+/=]+\s*)+))\1[\S\s]*$/g.test(P) ? (e.exports.publicImport(O, P), !0) : !1;
    }
  };
  function B(O) {
    const P = O.buf.readInt32BE(O.off);
    O.off += 4;
    const D = O.buf.slice(O.off, O.off + P);
    return O.off += P, D;
  }
  function M(O, P) {
    O.buf.writeInt32BE(P.byteLength, O.off), O.off += 4, O.off += P.copy(O.buf, O.off);
  }
})(l2);
var NC = l2.exports;
(function(e) {
  tr._;
  function t(h) {
    h = h.split("-");
    for (var o = "private", S = { type: "default" }, g = 1; g < h.length; g++)
      if (h[g])
        switch (h[g]) {
          case "public":
            o = h[g];
            break;
          case "private":
            o = h[g];
            break;
          case "pem":
            S.type = h[g];
            break;
          case "der":
            S.type = h[g];
            break;
        }
    return { scheme: h[0], keyType: o, keyOpt: S };
  }
  e.exports = {
    pkcs1: TC,
    pkcs8: MC,
    components: RC,
    openssh: NC,
    isPrivateExport: function(h) {
      return e.exports[h] && typeof e.exports[h].privateExport == "function";
    },
    isPrivateImport: function(h) {
      return e.exports[h] && typeof e.exports[h].privateImport == "function";
    },
    isPublicExport: function(h) {
      return e.exports[h] && typeof e.exports[h].publicExport == "function";
    },
    isPublicImport: function(h) {
      return e.exports[h] && typeof e.exports[h].publicImport == "function";
    },
    detectAndImport: function(h, o, S) {
      if (S === void 0) {
        for (var g in e.exports)
          if (typeof e.exports[g].autoImport == "function" && e.exports[g].autoImport(h, o))
            return !0;
      } else if (S) {
        var B = t(S);
        if (e.exports[B.scheme])
          B.keyType === "private" ? e.exports[B.scheme].privateImport(h, o, B.keyOpt) : e.exports[B.scheme].publicImport(h, o, B.keyOpt);
        else
          throw Error("Unsupported key format");
      }
      return !1;
    },
    detectAndExport: function(h, o) {
      if (o) {
        var S = t(o);
        if (e.exports[S.scheme])
          if (S.keyType === "private") {
            if (!h.isPrivate())
              throw Error("This is not private key");
            return e.exports[S.scheme].privateExport(h, S.keyOpt);
          } else {
            if (!h.isPublic())
              throw Error("This is not public key");
            return e.exports[S.scheme].publicExport(h, S.keyOpt);
          }
        else
          throw Error("Unsupported key format");
      }
    }
  };
})(o2);
var DC = o2.exports, OC = Bh;
_r();
var Mr = tr._, PC = tr, Ip = Za(), Tp = DC, LC = function() {
  var e = {
    node10: ["md4", "md5", "ripemd160", "sha1", "sha224", "sha256", "sha384", "sha512"],
    node: ["md4", "md5", "ripemd160", "sha1", "sha224", "sha256", "sha384", "sha512"],
    iojs: ["md4", "md5", "ripemd160", "sha1", "sha224", "sha256", "sha384", "sha512"],
    browser: ["md5", "ripemd160", "sha1", "sha256", "sha512"]
  }, t = "pkcs1_oaep", h = "pkcs1", o = "private", S = {
    private: "pkcs1-private-pem",
    "private-der": "pkcs1-private-der",
    public: "pkcs8-public-pem",
    "public-der": "pkcs8-public-der"
  };
  function g(B, M, O) {
    if (!(this instanceof g))
      return new g(B, M, O);
    Mr.isObject(M) && (O = M, M = void 0), this.$options = {
      signingScheme: h,
      signingSchemeOptions: {
        hash: "sha256",
        saltLength: null
      },
      encryptionScheme: t,
      encryptionSchemeOptions: {
        hash: "sha1",
        label: null
      },
      environment: PC.detectEnvironment(),
      rsaUtils: this
    }, this.keyPair = new OC.Key(), this.$cache = {}, pe.Buffer.isBuffer(B) || Mr.isString(B) ? this.importKey(B, M) : Mr.isObject(B) && this.generateKeyPair(B.b, B.e), this.setOptions(O);
  }
  return g.prototype.setOptions = function(B) {
    if (B = B || {}, B.environment && (this.$options.environment = B.environment), B.signingScheme) {
      if (Mr.isString(B.signingScheme)) {
        var M = B.signingScheme.toLowerCase().split("-");
        M.length == 1 ? e.node.indexOf(M[0]) > -1 ? (this.$options.signingSchemeOptions = {
          hash: M[0]
        }, this.$options.signingScheme = h) : (this.$options.signingScheme = M[0], this.$options.signingSchemeOptions = {
          hash: null
        }) : (this.$options.signingSchemeOptions = {
          hash: M[1]
        }, this.$options.signingScheme = M[0]);
      } else
        Mr.isObject(B.signingScheme) && (this.$options.signingScheme = B.signingScheme.scheme || h, this.$options.signingSchemeOptions = Mr.omit(B.signingScheme, "scheme"));
      if (!Ip.isSignature(this.$options.signingScheme))
        throw Error("Unsupported signing scheme");
      if (this.$options.signingSchemeOptions.hash && e[this.$options.environment].indexOf(this.$options.signingSchemeOptions.hash) === -1)
        throw Error("Unsupported hashing algorithm for " + this.$options.environment + " environment");
    }
    if (B.encryptionScheme) {
      if (Mr.isString(B.encryptionScheme) ? (this.$options.encryptionScheme = B.encryptionScheme.toLowerCase(), this.$options.encryptionSchemeOptions = {}) : Mr.isObject(B.encryptionScheme) && (this.$options.encryptionScheme = B.encryptionScheme.scheme || t, this.$options.encryptionSchemeOptions = Mr.omit(B.encryptionScheme, "scheme")), !Ip.isEncryption(this.$options.encryptionScheme))
        throw Error("Unsupported encryption scheme");
      if (this.$options.encryptionSchemeOptions.hash && e[this.$options.environment].indexOf(this.$options.encryptionSchemeOptions.hash) === -1)
        throw Error("Unsupported hashing algorithm for " + this.$options.environment + " environment");
    }
    this.keyPair.setOptions(this.$options);
  }, g.prototype.generateKeyPair = function(B, M) {
    if (B = B || 2048, M = M || 65537, B % 8 !== 0)
      throw Error("Key size must be a multiple of 8.");
    return this.keyPair.generate(B, M.toString(16)), this.$cache = {}, this;
  }, g.prototype.importKey = function(B, M) {
    if (!B)
      throw Error("Empty key given");
    if (M && (M = S[M] || M), !Tp.detectAndImport(this.keyPair, B, M) && M === void 0)
      throw Error("Key format must be specified");
    return this.$cache = {}, this;
  }, g.prototype.exportKey = function(B) {
    return B = B || o, B = S[B] || B, this.$cache[B] || (this.$cache[B] = Tp.detectAndExport(this.keyPair, B)), this.$cache[B];
  }, g.prototype.isPrivate = function() {
    return this.keyPair.isPrivate();
  }, g.prototype.isPublic = function(B) {
    return this.keyPair.isPublic(B);
  }, g.prototype.isEmpty = function(B) {
    return !(this.keyPair.n || this.keyPair.e || this.keyPair.d);
  }, g.prototype.encrypt = function(B, M, O) {
    return this.$$encryptKey(!1, B, M, O);
  }, g.prototype.decrypt = function(B, M) {
    return this.$$decryptKey(!1, B, M);
  }, g.prototype.encryptPrivate = function(B, M, O) {
    return this.$$encryptKey(!0, B, M, O);
  }, g.prototype.decryptPublic = function(B, M) {
    return this.$$decryptKey(!0, B, M);
  }, g.prototype.$$encryptKey = function(B, M, O, P) {
    try {
      var D = this.keyPair.encrypt(this.$getDataForEncrypt(M, P), B);
      return O == "buffer" || !O ? D : D.toString(O);
    } catch (Z) {
      throw Error("Error during encryption. Original error: " + Z);
    }
  }, g.prototype.$$decryptKey = function(B, M, O) {
    try {
      M = Mr.isString(M) ? pe.Buffer.from(M, "base64") : M;
      var P = this.keyPair.decrypt(M, B);
      if (P === null)
        throw Error("Key decrypt method returns null.");
      return this.$getDecryptedData(P, O);
    } catch (D) {
      throw Error("Error during decryption (probably incorrect key). Original error: " + D);
    }
  }, g.prototype.sign = function(B, M, O) {
    if (!this.isPrivate())
      throw Error("This is not private key");
    var P = this.keyPair.sign(this.$getDataForEncrypt(B, O));
    return M && M != "buffer" && (P = P.toString(M)), P;
  }, g.prototype.verify = function(B, M, O, P) {
    if (!this.isPublic())
      throw Error("This is not public key");
    return P = !P || P == "buffer" ? null : P, this.keyPair.verify(this.$getDataForEncrypt(B, O), M, P);
  }, g.prototype.getKeySize = function() {
    return this.keyPair.keySize;
  }, g.prototype.getMaxMessageSize = function() {
    return this.keyPair.maxMessageLength;
  }, g.prototype.$getDataForEncrypt = function(B, M) {
    if (Mr.isString(B) || Mr.isNumber(B))
      return pe.Buffer.from("" + B, M || "utf8");
    if (pe.Buffer.isBuffer(B))
      return B;
    if (Mr.isObject(B))
      return pe.Buffer.from(JSON.stringify(B));
    throw Error("Unexpected data type");
  }, g.prototype.$getDecryptedData = function(B, M) {
    return M = M || "buffer", M == "buffer" ? B : M == "json" ? JSON.parse(B.toString()) : B.toString(M);
  }, g;
}();
const kC = /* @__PURE__ */ Gs(LC);
var ht = {
  // default options
  options: {
    usePureJavaScript: !1
  }
}, Oh = {}, UC = Oh, Mp = {};
Oh.encode = function(e, t, h) {
  if (typeof t != "string")
    throw new TypeError('"alphabet" must be a string.');
  if (h !== void 0 && typeof h != "number")
    throw new TypeError('"maxline" must be a number.');
  var o = "";
  if (!(e instanceof Uint8Array))
    o = FC(e, t);
  else {
    var S = 0, g = t.length, B = t.charAt(0), M = [0];
    for (S = 0; S < e.length; ++S) {
      for (var O = 0, P = e[S]; O < M.length; ++O)
        P += M[O] << 8, M[O] = P % g, P = P / g | 0;
      for (; P > 0; )
        M.push(P % g), P = P / g | 0;
    }
    for (S = 0; e[S] === 0 && S < e.length - 1; ++S)
      o += B;
    for (S = M.length - 1; S >= 0; --S)
      o += t[M[S]];
  }
  if (h) {
    var D = new RegExp(".{1," + h + "}", "g");
    o = o.match(D).join(`\r
`);
  }
  return o;
};
Oh.decode = function(e, t) {
  if (typeof e != "string")
    throw new TypeError('"input" must be a string.');
  if (typeof t != "string")
    throw new TypeError('"alphabet" must be a string.');
  var h = Mp[t];
  if (!h) {
    h = Mp[t] = [];
    for (var o = 0; o < t.length; ++o)
      h[t.charCodeAt(o)] = o;
  }
  e = e.replace(/\s/g, "");
  for (var S = t.length, g = t.charAt(0), B = [0], o = 0; o < e.length; o++) {
    var M = h[e.charCodeAt(o)];
    if (M === void 0)
      return;
    for (var O = 0, P = M; O < B.length; ++O)
      P += B[O] * S, B[O] = P & 255, P >>= 8;
    for (; P > 0; )
      B.push(P & 255), P >>= 8;
  }
  for (var D = 0; e[D] === g && D < e.length - 1; ++D)
    B.push(0);
  return typeof pe.Buffer < "u" ? pe.Buffer.from(B.reverse()) : new Uint8Array(B.reverse());
};
function FC(e, t) {
  var h = 0, o = t.length, S = t.charAt(0), g = [0];
  for (h = 0; h < e.length(); ++h) {
    for (var B = 0, M = e.at(h); B < g.length; ++B)
      M += g[B] << 8, g[B] = M % o, M = M / o | 0;
    for (; M > 0; )
      g.push(M % o), M = M / o | 0;
  }
  var O = "";
  for (h = 0; e.at(h) === 0 && h < e.length() - 1; ++h)
    O += S;
  for (h = g.length - 1; h >= 0; --h)
    O += t[g[h]];
  return O;
}
var Rp = ht, Np = UC, se = Rp.util = Rp.util || {};
(function() {
  if (typeof Ve < "u" && Ve.nextTick && !Ve.browser) {
    se.nextTick = Ve.nextTick, typeof setImmediate == "function" ? se.setImmediate = setImmediate : se.setImmediate = se.nextTick;
    return;
  }
  if (typeof setImmediate == "function") {
    se.setImmediate = function() {
      return setImmediate.apply(void 0, arguments);
    }, se.nextTick = function(B) {
      return setImmediate(B);
    };
    return;
  }
  if (se.setImmediate = function(B) {
    setTimeout(B, 0);
  }, typeof window < "u" && typeof window.postMessage == "function") {
    let B = function(M) {
      if (M.source === window && M.data === e) {
        M.stopPropagation();
        var O = t.slice();
        t.length = 0, O.forEach(function(P) {
          P();
        });
      }
    };
    var e = "forge.setImmediate", t = [];
    se.setImmediate = function(M) {
      t.push(M), t.length === 1 && window.postMessage(e, "*");
    }, window.addEventListener("message", B, !0);
  }
  if (typeof MutationObserver < "u") {
    var h = Date.now(), o = !0, S = document.createElement("div"), t = [];
    new MutationObserver(function() {
      var M = t.slice();
      t.length = 0, M.forEach(function(O) {
        O();
      });
    }).observe(S, { attributes: !0 });
    var g = se.setImmediate;
    se.setImmediate = function(M) {
      Date.now() - h > 15 ? (h = Date.now(), g(M)) : (t.push(M), t.length === 1 && S.setAttribute("a", o = !o));
    };
  }
  se.nextTick = se.setImmediate;
})();
se.isNodejs = typeof Ve < "u" && Ve.versions && Ve.versions.node;
se.globalScope = function() {
  return se.isNodejs ? Me : typeof self > "u" ? window : self;
}();
se.isArray = Array.isArray || function(e) {
  return Object.prototype.toString.call(e) === "[object Array]";
};
se.isArrayBuffer = function(e) {
  return typeof ArrayBuffer < "u" && e instanceof ArrayBuffer;
};
se.isArrayBufferView = function(e) {
  return e && se.isArrayBuffer(e.buffer) && e.byteLength !== void 0;
};
function j0(e) {
  if (!(e === 8 || e === 16 || e === 24 || e === 32))
    throw new Error("Only 8, 16, 24, or 32 bits supported: " + e);
}
se.ByteBuffer = Ph;
function Ph(e) {
  if (this.data = "", this.read = 0, typeof e == "string")
    this.data = e;
  else if (se.isArrayBuffer(e) || se.isArrayBufferView(e))
    if (typeof pe.Buffer < "u" && e instanceof pe.Buffer)
      this.data = e.toString("binary");
    else {
      var t = new Uint8Array(e);
      try {
        this.data = String.fromCharCode.apply(null, t);
      } catch {
        for (var h = 0; h < t.length; ++h)
          this.putByte(t[h]);
      }
    }
  else
    (e instanceof Ph || typeof e == "object" && typeof e.data == "string" && typeof e.read == "number") && (this.data = e.data, this.read = e.read);
  this._constructedStringLength = 0;
}
se.ByteStringBuffer = Ph;
var qC = 4096;
se.ByteStringBuffer.prototype._optimizeConstructedString = function(e) {
  this._constructedStringLength += e, this._constructedStringLength > qC && (this.data.substr(0, 1), this._constructedStringLength = 0);
};
se.ByteStringBuffer.prototype.length = function() {
  return this.data.length - this.read;
};
se.ByteStringBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};
se.ByteStringBuffer.prototype.putByte = function(e) {
  return this.putBytes(String.fromCharCode(e));
};
se.ByteStringBuffer.prototype.fillWithByte = function(e, t) {
  e = String.fromCharCode(e);
  for (var h = this.data; t > 0; )
    t & 1 && (h += e), t >>>= 1, t > 0 && (e += e);
  return this.data = h, this._optimizeConstructedString(t), this;
};
se.ByteStringBuffer.prototype.putBytes = function(e) {
  return this.data += e, this._optimizeConstructedString(e.length), this;
};
se.ByteStringBuffer.prototype.putString = function(e) {
  return this.putBytes(se.encodeUtf8(e));
};
se.ByteStringBuffer.prototype.putInt16 = function(e) {
  return this.putBytes(
    String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e & 255)
  );
};
se.ByteStringBuffer.prototype.putInt24 = function(e) {
  return this.putBytes(
    String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e & 255)
  );
};
se.ByteStringBuffer.prototype.putInt32 = function(e) {
  return this.putBytes(
    String.fromCharCode(e >> 24 & 255) + String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e & 255)
  );
};
se.ByteStringBuffer.prototype.putInt16Le = function(e) {
  return this.putBytes(
    String.fromCharCode(e & 255) + String.fromCharCode(e >> 8 & 255)
  );
};
se.ByteStringBuffer.prototype.putInt24Le = function(e) {
  return this.putBytes(
    String.fromCharCode(e & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e >> 16 & 255)
  );
};
se.ByteStringBuffer.prototype.putInt32Le = function(e) {
  return this.putBytes(
    String.fromCharCode(e & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 24 & 255)
  );
};
se.ByteStringBuffer.prototype.putInt = function(e, t) {
  j0(t);
  var h = "";
  do
    t -= 8, h += String.fromCharCode(e >> t & 255);
  while (t > 0);
  return this.putBytes(h);
};
se.ByteStringBuffer.prototype.putSignedInt = function(e, t) {
  return e < 0 && (e += 2 << t - 1), this.putInt(e, t);
};
se.ByteStringBuffer.prototype.putBuffer = function(e) {
  return this.putBytes(e.getBytes());
};
se.ByteStringBuffer.prototype.getByte = function() {
  return this.data.charCodeAt(this.read++);
};
se.ByteStringBuffer.prototype.getInt16 = function() {
  var e = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
  return this.read += 2, e;
};
se.ByteStringBuffer.prototype.getInt24 = function() {
  var e = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
  return this.read += 3, e;
};
se.ByteStringBuffer.prototype.getInt32 = function() {
  var e = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
  return this.read += 4, e;
};
se.ByteStringBuffer.prototype.getInt16Le = function() {
  var e = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
  return this.read += 2, e;
};
se.ByteStringBuffer.prototype.getInt24Le = function() {
  var e = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
  return this.read += 3, e;
};
se.ByteStringBuffer.prototype.getInt32Le = function() {
  var e = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
  return this.read += 4, e;
};
se.ByteStringBuffer.prototype.getInt = function(e) {
  j0(e);
  var t = 0;
  do
    t = (t << 8) + this.data.charCodeAt(this.read++), e -= 8;
  while (e > 0);
  return t;
};
se.ByteStringBuffer.prototype.getSignedInt = function(e) {
  var t = this.getInt(e), h = 2 << e - 2;
  return t >= h && (t -= h << 1), t;
};
se.ByteStringBuffer.prototype.getBytes = function(e) {
  var t;
  return e ? (e = Math.min(this.length(), e), t = this.data.slice(this.read, this.read + e), this.read += e) : e === 0 ? t = "" : (t = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), t;
};
se.ByteStringBuffer.prototype.bytes = function(e) {
  return typeof e > "u" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + e);
};
se.ByteStringBuffer.prototype.at = function(e) {
  return this.data.charCodeAt(this.read + e);
};
se.ByteStringBuffer.prototype.setAt = function(e, t) {
  return this.data = this.data.substr(0, this.read + e) + String.fromCharCode(t) + this.data.substr(this.read + e + 1), this;
};
se.ByteStringBuffer.prototype.last = function() {
  return this.data.charCodeAt(this.data.length - 1);
};
se.ByteStringBuffer.prototype.copy = function() {
  var e = se.createBuffer(this.data);
  return e.read = this.read, e;
};
se.ByteStringBuffer.prototype.compact = function() {
  return this.read > 0 && (this.data = this.data.slice(this.read), this.read = 0), this;
};
se.ByteStringBuffer.prototype.clear = function() {
  return this.data = "", this.read = 0, this;
};
se.ByteStringBuffer.prototype.truncate = function(e) {
  var t = Math.max(0, this.length() - e);
  return this.data = this.data.substr(this.read, t), this.read = 0, this;
};
se.ByteStringBuffer.prototype.toHex = function() {
  for (var e = "", t = this.read; t < this.data.length; ++t) {
    var h = this.data.charCodeAt(t);
    h < 16 && (e += "0"), e += h.toString(16);
  }
  return e;
};
se.ByteStringBuffer.prototype.toString = function() {
  return se.decodeUtf8(this.bytes());
};
function VC(e, t) {
  t = t || {}, this.read = t.readOffset || 0, this.growSize = t.growSize || 1024;
  var h = se.isArrayBuffer(e), o = se.isArrayBufferView(e);
  if (h || o) {
    h ? this.data = new DataView(e) : this.data = new DataView(e.buffer, e.byteOffset, e.byteLength), this.write = "writeOffset" in t ? t.writeOffset : this.data.byteLength;
    return;
  }
  this.data = new DataView(new ArrayBuffer(0)), this.write = 0, e != null && this.putBytes(e), "writeOffset" in t && (this.write = t.writeOffset);
}
se.DataBuffer = VC;
se.DataBuffer.prototype.length = function() {
  return this.write - this.read;
};
se.DataBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};
se.DataBuffer.prototype.accommodate = function(e, t) {
  if (this.length() >= e)
    return this;
  t = Math.max(t || this.growSize, e);
  var h = new Uint8Array(
    this.data.buffer,
    this.data.byteOffset,
    this.data.byteLength
  ), o = new Uint8Array(this.length() + t);
  return o.set(h), this.data = new DataView(o.buffer), this;
};
se.DataBuffer.prototype.putByte = function(e) {
  return this.accommodate(1), this.data.setUint8(this.write++, e), this;
};
se.DataBuffer.prototype.fillWithByte = function(e, t) {
  this.accommodate(t);
  for (var h = 0; h < t; ++h)
    this.data.setUint8(e);
  return this;
};
se.DataBuffer.prototype.putBytes = function(e, t) {
  if (se.isArrayBufferView(e)) {
    var h = new Uint8Array(e.buffer, e.byteOffset, e.byteLength), o = h.byteLength - h.byteOffset;
    this.accommodate(o);
    var S = new Uint8Array(this.data.buffer, this.write);
    return S.set(h), this.write += o, this;
  }
  if (se.isArrayBuffer(e)) {
    var h = new Uint8Array(e);
    this.accommodate(h.byteLength);
    var S = new Uint8Array(this.data.buffer);
    return S.set(h, this.write), this.write += h.byteLength, this;
  }
  if (e instanceof se.DataBuffer || typeof e == "object" && typeof e.read == "number" && typeof e.write == "number" && se.isArrayBufferView(e.data)) {
    var h = new Uint8Array(e.data.byteLength, e.read, e.length());
    this.accommodate(h.byteLength);
    var S = new Uint8Array(e.data.byteLength, this.write);
    return S.set(h), this.write += h.byteLength, this;
  }
  if (e instanceof se.ByteStringBuffer && (e = e.data, t = "binary"), t = t || "binary", typeof e == "string") {
    var g;
    if (t === "hex")
      return this.accommodate(Math.ceil(e.length / 2)), g = new Uint8Array(this.data.buffer, this.write), this.write += se.binary.hex.decode(e, g, this.write), this;
    if (t === "base64")
      return this.accommodate(Math.ceil(e.length / 4) * 3), g = new Uint8Array(this.data.buffer, this.write), this.write += se.binary.base64.decode(e, g, this.write), this;
    if (t === "utf8" && (e = se.encodeUtf8(e), t = "binary"), t === "binary" || t === "raw")
      return this.accommodate(e.length), g = new Uint8Array(this.data.buffer, this.write), this.write += se.binary.raw.decode(g), this;
    if (t === "utf16")
      return this.accommodate(e.length * 2), g = new Uint16Array(this.data.buffer, this.write), this.write += se.text.utf16.encode(g), this;
    throw new Error("Invalid encoding: " + t);
  }
  throw Error("Invalid parameter: " + e);
};
se.DataBuffer.prototype.putBuffer = function(e) {
  return this.putBytes(e), e.clear(), this;
};
se.DataBuffer.prototype.putString = function(e) {
  return this.putBytes(e, "utf16");
};
se.DataBuffer.prototype.putInt16 = function(e) {
  return this.accommodate(2), this.data.setInt16(this.write, e), this.write += 2, this;
};
se.DataBuffer.prototype.putInt24 = function(e) {
  return this.accommodate(3), this.data.setInt16(this.write, e >> 8 & 65535), this.data.setInt8(this.write, e >> 16 & 255), this.write += 3, this;
};
se.DataBuffer.prototype.putInt32 = function(e) {
  return this.accommodate(4), this.data.setInt32(this.write, e), this.write += 4, this;
};
se.DataBuffer.prototype.putInt16Le = function(e) {
  return this.accommodate(2), this.data.setInt16(this.write, e, !0), this.write += 2, this;
};
se.DataBuffer.prototype.putInt24Le = function(e) {
  return this.accommodate(3), this.data.setInt8(this.write, e >> 16 & 255), this.data.setInt16(this.write, e >> 8 & 65535, !0), this.write += 3, this;
};
se.DataBuffer.prototype.putInt32Le = function(e) {
  return this.accommodate(4), this.data.setInt32(this.write, e, !0), this.write += 4, this;
};
se.DataBuffer.prototype.putInt = function(e, t) {
  j0(t), this.accommodate(t / 8);
  do
    t -= 8, this.data.setInt8(this.write++, e >> t & 255);
  while (t > 0);
  return this;
};
se.DataBuffer.prototype.putSignedInt = function(e, t) {
  return j0(t), this.accommodate(t / 8), e < 0 && (e += 2 << t - 1), this.putInt(e, t);
};
se.DataBuffer.prototype.getByte = function() {
  return this.data.getInt8(this.read++);
};
se.DataBuffer.prototype.getInt16 = function() {
  var e = this.data.getInt16(this.read);
  return this.read += 2, e;
};
se.DataBuffer.prototype.getInt24 = function() {
  var e = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
  return this.read += 3, e;
};
se.DataBuffer.prototype.getInt32 = function() {
  var e = this.data.getInt32(this.read);
  return this.read += 4, e;
};
se.DataBuffer.prototype.getInt16Le = function() {
  var e = this.data.getInt16(this.read, !0);
  return this.read += 2, e;
};
se.DataBuffer.prototype.getInt24Le = function() {
  var e = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, !0) << 8;
  return this.read += 3, e;
};
se.DataBuffer.prototype.getInt32Le = function() {
  var e = this.data.getInt32(this.read, !0);
  return this.read += 4, e;
};
se.DataBuffer.prototype.getInt = function(e) {
  j0(e);
  var t = 0;
  do
    t = (t << 8) + this.data.getInt8(this.read++), e -= 8;
  while (e > 0);
  return t;
};
se.DataBuffer.prototype.getSignedInt = function(e) {
  var t = this.getInt(e), h = 2 << e - 2;
  return t >= h && (t -= h << 1), t;
};
se.DataBuffer.prototype.getBytes = function(e) {
  var t;
  return e ? (e = Math.min(this.length(), e), t = this.data.slice(this.read, this.read + e), this.read += e) : e === 0 ? t = "" : (t = this.read === 0 ? this.data : this.data.slice(this.read), this.clear()), t;
};
se.DataBuffer.prototype.bytes = function(e) {
  return typeof e > "u" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + e);
};
se.DataBuffer.prototype.at = function(e) {
  return this.data.getUint8(this.read + e);
};
se.DataBuffer.prototype.setAt = function(e, t) {
  return this.data.setUint8(e, t), this;
};
se.DataBuffer.prototype.last = function() {
  return this.data.getUint8(this.write - 1);
};
se.DataBuffer.prototype.copy = function() {
  return new se.DataBuffer(this);
};
se.DataBuffer.prototype.compact = function() {
  if (this.read > 0) {
    var e = new Uint8Array(this.data.buffer, this.read), t = new Uint8Array(e.byteLength);
    t.set(e), this.data = new DataView(t), this.write -= this.read, this.read = 0;
  }
  return this;
};
se.DataBuffer.prototype.clear = function() {
  return this.data = new DataView(new ArrayBuffer(0)), this.read = this.write = 0, this;
};
se.DataBuffer.prototype.truncate = function(e) {
  return this.write = Math.max(0, this.length() - e), this.read = Math.min(this.read, this.write), this;
};
se.DataBuffer.prototype.toHex = function() {
  for (var e = "", t = this.read; t < this.data.byteLength; ++t) {
    var h = this.data.getUint8(t);
    h < 16 && (e += "0"), e += h.toString(16);
  }
  return e;
};
se.DataBuffer.prototype.toString = function(e) {
  var t = new Uint8Array(this.data, this.read, this.length());
  if (e = e || "utf8", e === "binary" || e === "raw")
    return se.binary.raw.encode(t);
  if (e === "hex")
    return se.binary.hex.encode(t);
  if (e === "base64")
    return se.binary.base64.encode(t);
  if (e === "utf8")
    return se.text.utf8.decode(t);
  if (e === "utf16")
    return se.text.utf16.decode(t);
  throw new Error("Invalid encoding: " + e);
};
se.createBuffer = function(e, t) {
  return t = t || "raw", e !== void 0 && t === "utf8" && (e = se.encodeUtf8(e)), new se.ByteBuffer(e);
};
se.fillString = function(e, t) {
  for (var h = ""; t > 0; )
    t & 1 && (h += e), t >>>= 1, t > 0 && (e += e);
  return h;
};
se.xorBytes = function(e, t, h) {
  for (var o = "", S = "", g = "", B = 0, M = 0; h > 0; --h, ++B)
    S = e.charCodeAt(B) ^ t.charCodeAt(B), M >= 10 && (o += g, g = "", M = 0), g += String.fromCharCode(S), ++M;
  return o += g, o;
};
se.hexToBytes = function(e) {
  var t = "", h = 0;
  for (e.length & !0 && (h = 1, t += String.fromCharCode(parseInt(e[0], 16))); h < e.length; h += 2)
    t += String.fromCharCode(parseInt(e.substr(h, 2), 16));
  return t;
};
se.bytesToHex = function(e) {
  return se.createBuffer(e).toHex();
};
se.int32ToBytes = function(e) {
  return String.fromCharCode(e >> 24 & 255) + String.fromCharCode(e >> 16 & 255) + String.fromCharCode(e >> 8 & 255) + String.fromCharCode(e & 255);
};
var gn = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", mn = [
  /*43 -43 = 0*/
  /*'+',  1,  2,  3,'/' */
  62,
  -1,
  -1,
  -1,
  63,
  /*'0','1','2','3','4','5','6','7','8','9' */
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  /*15, 16, 17,'=', 19, 20, 21 */
  -1,
  -1,
  -1,
  64,
  -1,
  -1,
  -1,
  /*65 - 43 = 22*/
  /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  /*91 - 43 = 48 */
  /*48, 49, 50, 51, 52, 53 */
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  /*97 - 43 = 54*/
  /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51
], d2 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
se.encode64 = function(e, t) {
  for (var h = "", o = "", S, g, B, M = 0; M < e.length; )
    S = e.charCodeAt(M++), g = e.charCodeAt(M++), B = e.charCodeAt(M++), h += gn.charAt(S >> 2), h += gn.charAt((S & 3) << 4 | g >> 4), isNaN(g) ? h += "==" : (h += gn.charAt((g & 15) << 2 | B >> 6), h += isNaN(B) ? "=" : gn.charAt(B & 63)), t && h.length > t && (o += h.substr(0, t) + `\r
`, h = h.substr(t));
  return o += h, o;
};
se.decode64 = function(e) {
  e = e.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  for (var t = "", h, o, S, g, B = 0; B < e.length; )
    h = mn[e.charCodeAt(B++) - 43], o = mn[e.charCodeAt(B++) - 43], S = mn[e.charCodeAt(B++) - 43], g = mn[e.charCodeAt(B++) - 43], t += String.fromCharCode(h << 2 | o >> 4), S !== 64 && (t += String.fromCharCode((o & 15) << 4 | S >> 2), g !== 64 && (t += String.fromCharCode((S & 3) << 6 | g)));
  return t;
};
se.encodeUtf8 = function(e) {
  return unescape(encodeURIComponent(e));
};
se.decodeUtf8 = function(e) {
  return decodeURIComponent(escape(e));
};
se.binary = {
  raw: {},
  hex: {},
  base64: {},
  base58: {},
  baseN: {
    encode: Np.encode,
    decode: Np.decode
  }
};
se.binary.raw.encode = function(e) {
  return String.fromCharCode.apply(null, e);
};
se.binary.raw.decode = function(e, t, h) {
  var o = t;
  o || (o = new Uint8Array(e.length)), h = h || 0;
  for (var S = h, g = 0; g < e.length; ++g)
    o[S++] = e.charCodeAt(g);
  return t ? S - h : o;
};
se.binary.hex.encode = se.bytesToHex;
se.binary.hex.decode = function(e, t, h) {
  var o = t;
  o || (o = new Uint8Array(Math.ceil(e.length / 2))), h = h || 0;
  var S = 0, g = h;
  for (e.length & 1 && (S = 1, o[g++] = parseInt(e[0], 16)); S < e.length; S += 2)
    o[g++] = parseInt(e.substr(S, 2), 16);
  return t ? g - h : o;
};
se.binary.base64.encode = function(e, t) {
  for (var h = "", o = "", S, g, B, M = 0; M < e.byteLength; )
    S = e[M++], g = e[M++], B = e[M++], h += gn.charAt(S >> 2), h += gn.charAt((S & 3) << 4 | g >> 4), isNaN(g) ? h += "==" : (h += gn.charAt((g & 15) << 2 | B >> 6), h += isNaN(B) ? "=" : gn.charAt(B & 63)), t && h.length > t && (o += h.substr(0, t) + `\r
`, h = h.substr(t));
  return o += h, o;
};
se.binary.base64.decode = function(e, t, h) {
  var o = t;
  o || (o = new Uint8Array(Math.ceil(e.length / 4) * 3)), e = e.replace(/[^A-Za-z0-9\+\/\=]/g, ""), h = h || 0;
  for (var S, g, B, M, O = 0, P = h; O < e.length; )
    S = mn[e.charCodeAt(O++) - 43], g = mn[e.charCodeAt(O++) - 43], B = mn[e.charCodeAt(O++) - 43], M = mn[e.charCodeAt(O++) - 43], o[P++] = S << 2 | g >> 4, B !== 64 && (o[P++] = (g & 15) << 4 | B >> 2, M !== 64 && (o[P++] = (B & 3) << 6 | M));
  return t ? P - h : o.subarray(0, P);
};
se.binary.base58.encode = function(e, t) {
  return se.binary.baseN.encode(e, d2, t);
};
se.binary.base58.decode = function(e, t) {
  return se.binary.baseN.decode(e, d2, t);
};
se.text = {
  utf8: {},
  utf16: {}
};
se.text.utf8.encode = function(e, t, h) {
  e = se.encodeUtf8(e);
  var o = t;
  o || (o = new Uint8Array(e.length)), h = h || 0;
  for (var S = h, g = 0; g < e.length; ++g)
    o[S++] = e.charCodeAt(g);
  return t ? S - h : o;
};
se.text.utf8.decode = function(e) {
  return se.decodeUtf8(String.fromCharCode.apply(null, e));
};
se.text.utf16.encode = function(e, t, h) {
  var o = t;
  o || (o = new Uint8Array(e.length * 2));
  var S = new Uint16Array(o.buffer);
  h = h || 0;
  for (var g = h, B = h, M = 0; M < e.length; ++M)
    S[B++] = e.charCodeAt(M), g += 2;
  return t ? g - h : o;
};
se.text.utf16.decode = function(e) {
  return String.fromCharCode.apply(null, new Uint16Array(e.buffer));
};
se.deflate = function(e, t, h) {
  if (t = se.decode64(e.deflate(se.encode64(t)).rval), h) {
    var o = 2, S = t.charCodeAt(1);
    S & 32 && (o = 6), t = t.substring(o, t.length - 4);
  }
  return t;
};
se.inflate = function(e, t, h) {
  var o = e.inflate(se.encode64(t)).rval;
  return o === null ? null : se.decode64(o);
};
var Lh = function(e, t, h) {
  if (!e)
    throw new Error("WebStorage not available.");
  var o;
  if (h === null ? o = e.removeItem(t) : (h = se.encode64(JSON.stringify(h)), o = e.setItem(t, h)), typeof o < "u" && o.rval !== !0) {
    var S = new Error(o.error.message);
    throw S.id = o.error.id, S.name = o.error.name, S;
  }
}, kh = function(e, t) {
  if (!e)
    throw new Error("WebStorage not available.");
  var h = e.getItem(t);
  if (e.init)
    if (h.rval === null) {
      if (h.error) {
        var o = new Error(h.error.message);
        throw o.id = h.error.id, o.name = h.error.name, o;
      }
      h = null;
    } else
      h = h.rval;
  return h !== null && (h = JSON.parse(se.decode64(h))), h;
}, KC = function(e, t, h, o) {
  var S = kh(e, t);
  S === null && (S = {}), S[h] = o, Lh(e, t, S);
}, $C = function(e, t, h) {
  var o = kh(e, t);
  return o !== null && (o = h in o ? o[h] : null), o;
}, HC = function(e, t, h) {
  var o = kh(e, t);
  if (o !== null && h in o) {
    delete o[h];
    var S = !0;
    for (var g in o) {
      S = !1;
      break;
    }
    S && (o = null), Lh(e, t, o);
  }
}, GC = function(e, t) {
  Lh(e, t, null);
}, Of = function(e, t, h) {
  var o = null;
  typeof h > "u" && (h = ["web", "flash"]);
  var S, g = !1, B = null;
  for (var M in h) {
    S = h[M];
    try {
      if (S === "flash" || S === "both") {
        if (t[0] === null)
          throw new Error("Flash local storage not available.");
        o = e.apply(this, t), g = S === "flash";
      }
      (S === "web" || S === "both") && (t[0] = localStorage, o = e.apply(this, t), g = !0);
    } catch (O) {
      B = O;
    }
    if (g)
      break;
  }
  if (!g)
    throw B;
  return o;
};
se.setItem = function(e, t, h, o, S) {
  Of(KC, arguments, S);
};
se.getItem = function(e, t, h, o) {
  return Of($C, arguments, o);
};
se.removeItem = function(e, t, h, o) {
  Of(HC, arguments, o);
};
se.clearItems = function(e, t, h) {
  Of(GC, arguments, h);
};
se.isEmpty = function(e) {
  for (var t in e)
    if (e.hasOwnProperty(t))
      return !1;
  return !0;
};
se.format = function(e) {
  for (var t = /%./g, h, o, S = 0, g = [], B = 0; h = t.exec(e); ) {
    o = e.substring(B, t.lastIndex - 2), o.length > 0 && g.push(o), B = t.lastIndex;
    var M = h[0][1];
    switch (M) {
      case "s":
      case "o":
        S < arguments.length ? g.push(arguments[S++ + 1]) : g.push("<?>");
        break;
      case "%":
        g.push("%");
        break;
      default:
        g.push("<%" + M + "?>");
    }
  }
  return g.push(e.substring(B)), g.join("");
};
se.formatNumber = function(e, t, h, o) {
  var S = e, g = isNaN(t = Math.abs(t)) ? 2 : t, B = h === void 0 ? "," : h, M = o === void 0 ? "." : o, O = S < 0 ? "-" : "", P = parseInt(S = Math.abs(+S || 0).toFixed(g), 10) + "", D = P.length > 3 ? P.length % 3 : 0;
  return O + (D ? P.substr(0, D) + M : "") + P.substr(D).replace(/(\d{3})(?=\d)/g, "$1" + M) + (g ? B + Math.abs(S - P).toFixed(g).slice(2) : "");
};
se.formatSize = function(e) {
  return e >= 1073741824 ? e = se.formatNumber(e / 1073741824, 2, ".", "") + " GiB" : e >= 1048576 ? e = se.formatNumber(e / 1048576, 2, ".", "") + " MiB" : e >= 1024 ? e = se.formatNumber(e / 1024, 0) + " KiB" : e = se.formatNumber(e, 0) + " bytes", e;
};
se.bytesFromIP = function(e) {
  return e.indexOf(".") !== -1 ? se.bytesFromIPv4(e) : e.indexOf(":") !== -1 ? se.bytesFromIPv6(e) : null;
};
se.bytesFromIPv4 = function(e) {
  if (e = e.split("."), e.length !== 4)
    return null;
  for (var t = se.createBuffer(), h = 0; h < e.length; ++h) {
    var o = parseInt(e[h], 10);
    if (isNaN(o))
      return null;
    t.putByte(o);
  }
  return t.getBytes();
};
se.bytesFromIPv6 = function(e) {
  var t = 0;
  e = e.split(":").filter(function(B) {
    return B.length === 0 && ++t, !0;
  });
  for (var h = (8 - e.length + t) * 2, o = se.createBuffer(), S = 0; S < 8; ++S) {
    if (!e[S] || e[S].length === 0) {
      o.fillWithByte(0, h), h = 0;
      continue;
    }
    var g = se.hexToBytes(e[S]);
    g.length < 2 && o.putByte(0), o.putBytes(g);
  }
  return o.getBytes();
};
se.bytesToIP = function(e) {
  return e.length === 4 ? se.bytesToIPv4(e) : e.length === 16 ? se.bytesToIPv6(e) : null;
};
se.bytesToIPv4 = function(e) {
  if (e.length !== 4)
    return null;
  for (var t = [], h = 0; h < e.length; ++h)
    t.push(e.charCodeAt(h));
  return t.join(".");
};
se.bytesToIPv6 = function(e) {
  if (e.length !== 16)
    return null;
  for (var t = [], h = [], o = 0, S = 0; S < e.length; S += 2) {
    for (var g = se.bytesToHex(e[S] + e[S + 1]); g[0] === "0" && g !== "0"; )
      g = g.substr(1);
    if (g === "0") {
      var B = h[h.length - 1], M = t.length;
      !B || M !== B.end + 1 ? h.push({ start: M, end: M }) : (B.end = M, B.end - B.start > h[o].end - h[o].start && (o = h.length - 1));
    }
    t.push(g);
  }
  if (h.length > 0) {
    var O = h[o];
    O.end - O.start > 0 && (t.splice(O.start, O.end - O.start + 1, ""), O.start === 0 && t.unshift(""), O.end === 7 && t.push(""));
  }
  return t.join(":");
};
se.estimateCores = function(e, t) {
  if (typeof e == "function" && (t = e, e = {}), e = e || {}, "cores" in se && !e.update)
    return t(null, se.cores);
  if (typeof navigator < "u" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0)
    return se.cores = navigator.hardwareConcurrency, t(null, se.cores);
  if (typeof Worker > "u")
    return se.cores = 1, t(null, se.cores);
  if (typeof Blob > "u")
    return se.cores = 2, t(null, se.cores);
  var h = URL.createObjectURL(new Blob([
    "(",
    (function() {
      self.addEventListener("message", function(B) {
        var M = Date.now(), O = M + 4;
        self.postMessage({ st: M, et: O });
      });
    }).toString(),
    ")()"
  ], { type: "application/javascript" }));
  o([], 5, 16);
  function o(B, M, O) {
    if (M === 0) {
      var P = Math.floor(B.reduce(function(D, Z) {
        return D + Z;
      }, 0) / B.length);
      return se.cores = Math.max(1, P), URL.revokeObjectURL(h), t(null, se.cores);
    }
    S(O, function(D, Z) {
      B.push(g(O, Z)), o(B, M - 1, O);
    });
  }
  function S(B, M) {
    for (var O = [], P = [], D = 0; D < B; ++D) {
      var Z = new Worker(h);
      Z.addEventListener("message", function(Y) {
        if (P.push(Y.data), P.length === B) {
          for (var ee = 0; ee < B; ++ee)
            O[ee].terminate();
          M(null, P);
        }
      }), O.push(Z);
    }
    for (var D = 0; D < B; ++D)
      O[D].postMessage(D);
  }
  function g(B, M) {
    for (var O = [], P = 0; P < B; ++P)
      for (var D = M[P], Z = O[P] = [], Y = 0; Y < B; ++Y)
        if (P !== Y) {
          var ee = M[Y];
          (D.st > ee.st && D.st < ee.et || ee.st > D.st && ee.st < D.et) && Z.push(Y);
        }
    return O.reduce(function(ie, ue) {
      return Math.max(ie, ue.length);
    }, 0);
  }
};
var Jt = ht;
Jt.cipher = Jt.cipher || {};
Jt.cipher.algorithms = Jt.cipher.algorithms || {};
Jt.cipher.createCipher = function(e, t) {
  var h = e;
  if (typeof h == "string" && (h = Jt.cipher.getAlgorithm(h), h && (h = h())), !h)
    throw new Error("Unsupported algorithm: " + e);
  return new Jt.cipher.BlockCipher({
    algorithm: h,
    key: t,
    decrypt: !1
  });
};
Jt.cipher.createDecipher = function(e, t) {
  var h = e;
  if (typeof h == "string" && (h = Jt.cipher.getAlgorithm(h), h && (h = h())), !h)
    throw new Error("Unsupported algorithm: " + e);
  return new Jt.cipher.BlockCipher({
    algorithm: h,
    key: t,
    decrypt: !0
  });
};
Jt.cipher.registerAlgorithm = function(e, t) {
  e = e.toUpperCase(), Jt.cipher.algorithms[e] = t;
};
Jt.cipher.getAlgorithm = function(e) {
  return e = e.toUpperCase(), e in Jt.cipher.algorithms ? Jt.cipher.algorithms[e] : null;
};
var Uh = Jt.cipher.BlockCipher = function(e) {
  this.algorithm = e.algorithm, this.mode = this.algorithm.mode, this.blockSize = this.mode.blockSize, this._finish = !1, this._input = null, this.output = null, this._op = e.decrypt ? this.mode.decrypt : this.mode.encrypt, this._decrypt = e.decrypt, this.algorithm.initialize(e);
};
Uh.prototype.start = function(e) {
  e = e || {};
  var t = {};
  for (var h in e)
    t[h] = e[h];
  t.decrypt = this._decrypt, this._finish = !1, this._input = Jt.util.createBuffer(), this.output = e.output || Jt.util.createBuffer(), this.mode.start(t);
};
Uh.prototype.update = function(e) {
  for (e && this._input.putBuffer(e); !this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish; )
    ;
  this._input.compact();
};
Uh.prototype.finish = function(e) {
  e && (this.mode.name === "ECB" || this.mode.name === "CBC") && (this.mode.pad = function(h) {
    return e(this.blockSize, h, !1);
  }, this.mode.unpad = function(h) {
    return e(this.blockSize, h, !0);
  });
  var t = {};
  return t.decrypt = this._decrypt, t.overflow = this._input.length() % this.blockSize, !(!this._decrypt && this.mode.pad && !this.mode.pad(this._input, t) || (this._finish = !0, this.update(), this._decrypt && this.mode.unpad && !this.mode.unpad(this.output, t)) || this.mode.afterFinish && !this.mode.afterFinish(this.output, t));
};
var Qt = ht;
Qt.cipher = Qt.cipher || {};
var pt = Qt.cipher.modes = Qt.cipher.modes || {};
pt.ecb = function(e) {
  e = e || {}, this.name = "ECB", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
};
pt.ecb.prototype.start = function(e) {
};
pt.ecb.prototype.encrypt = function(e, t, h) {
  if (e.length() < this.blockSize && !(h && e.length() > 0))
    return !0;
  for (var o = 0; o < this._ints; ++o)
    this._inBlock[o] = e.getInt32();
  this.cipher.encrypt(this._inBlock, this._outBlock);
  for (var o = 0; o < this._ints; ++o)
    t.putInt32(this._outBlock[o]);
};
pt.ecb.prototype.decrypt = function(e, t, h) {
  if (e.length() < this.blockSize && !(h && e.length() > 0))
    return !0;
  for (var o = 0; o < this._ints; ++o)
    this._inBlock[o] = e.getInt32();
  this.cipher.decrypt(this._inBlock, this._outBlock);
  for (var o = 0; o < this._ints; ++o)
    t.putInt32(this._outBlock[o]);
};
pt.ecb.prototype.pad = function(e, t) {
  var h = e.length() === this.blockSize ? this.blockSize : this.blockSize - e.length();
  return e.fillWithByte(h, h), !0;
};
pt.ecb.prototype.unpad = function(e, t) {
  if (t.overflow > 0)
    return !1;
  var h = e.length(), o = e.at(h - 1);
  return o > this.blockSize << 2 ? !1 : (e.truncate(o), !0);
};
pt.cbc = function(e) {
  e = e || {}, this.name = "CBC", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints);
};
pt.cbc.prototype.start = function(e) {
  if (e.iv === null) {
    if (!this._prev)
      throw new Error("Invalid IV parameter.");
    this._iv = this._prev.slice(0);
  } else if ("iv" in e)
    this._iv = Pf(e.iv, this.blockSize), this._prev = this._iv.slice(0);
  else
    throw new Error("Invalid IV parameter.");
};
pt.cbc.prototype.encrypt = function(e, t, h) {
  if (e.length() < this.blockSize && !(h && e.length() > 0))
    return !0;
  for (var o = 0; o < this._ints; ++o)
    this._inBlock[o] = this._prev[o] ^ e.getInt32();
  this.cipher.encrypt(this._inBlock, this._outBlock);
  for (var o = 0; o < this._ints; ++o)
    t.putInt32(this._outBlock[o]);
  this._prev = this._outBlock;
};
pt.cbc.prototype.decrypt = function(e, t, h) {
  if (e.length() < this.blockSize && !(h && e.length() > 0))
    return !0;
  for (var o = 0; o < this._ints; ++o)
    this._inBlock[o] = e.getInt32();
  this.cipher.decrypt(this._inBlock, this._outBlock);
  for (var o = 0; o < this._ints; ++o)
    t.putInt32(this._prev[o] ^ this._outBlock[o]);
  this._prev = this._inBlock.slice(0);
};
pt.cbc.prototype.pad = function(e, t) {
  var h = e.length() === this.blockSize ? this.blockSize : this.blockSize - e.length();
  return e.fillWithByte(h, h), !0;
};
pt.cbc.prototype.unpad = function(e, t) {
  if (t.overflow > 0)
    return !1;
  var h = e.length(), o = e.at(h - 1);
  return o > this.blockSize << 2 ? !1 : (e.truncate(o), !0);
};
pt.cfb = function(e) {
  e = e || {}, this.name = "CFB", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialBlock = new Array(this._ints), this._partialOutput = Qt.util.createBuffer(), this._partialBytes = 0;
};
pt.cfb.prototype.start = function(e) {
  if (!("iv" in e))
    throw new Error("Invalid IV parameter.");
  this._iv = Pf(e.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
};
pt.cfb.prototype.encrypt = function(e, t, h) {
  var o = e.length();
  if (o === 0)
    return !0;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && o >= this.blockSize) {
    for (var S = 0; S < this._ints; ++S)
      this._inBlock[S] = e.getInt32() ^ this._outBlock[S], t.putInt32(this._inBlock[S]);
    return;
  }
  var g = (this.blockSize - o) % this.blockSize;
  g > 0 && (g = this.blockSize - g), this._partialOutput.clear();
  for (var S = 0; S < this._ints; ++S)
    this._partialBlock[S] = e.getInt32() ^ this._outBlock[S], this._partialOutput.putInt32(this._partialBlock[S]);
  if (g > 0)
    e.read -= this.blockSize;
  else
    for (var S = 0; S < this._ints; ++S)
      this._inBlock[S] = this._partialBlock[S];
  if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), g > 0 && !h)
    return t.putBytes(this._partialOutput.getBytes(
      g - this._partialBytes
    )), this._partialBytes = g, !0;
  t.putBytes(this._partialOutput.getBytes(
    o - this._partialBytes
  )), this._partialBytes = 0;
};
pt.cfb.prototype.decrypt = function(e, t, h) {
  var o = e.length();
  if (o === 0)
    return !0;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && o >= this.blockSize) {
    for (var S = 0; S < this._ints; ++S)
      this._inBlock[S] = e.getInt32(), t.putInt32(this._inBlock[S] ^ this._outBlock[S]);
    return;
  }
  var g = (this.blockSize - o) % this.blockSize;
  g > 0 && (g = this.blockSize - g), this._partialOutput.clear();
  for (var S = 0; S < this._ints; ++S)
    this._partialBlock[S] = e.getInt32(), this._partialOutput.putInt32(this._partialBlock[S] ^ this._outBlock[S]);
  if (g > 0)
    e.read -= this.blockSize;
  else
    for (var S = 0; S < this._ints; ++S)
      this._inBlock[S] = this._partialBlock[S];
  if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), g > 0 && !h)
    return t.putBytes(this._partialOutput.getBytes(
      g - this._partialBytes
    )), this._partialBytes = g, !0;
  t.putBytes(this._partialOutput.getBytes(
    o - this._partialBytes
  )), this._partialBytes = 0;
};
pt.ofb = function(e) {
  e = e || {}, this.name = "OFB", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = Qt.util.createBuffer(), this._partialBytes = 0;
};
pt.ofb.prototype.start = function(e) {
  if (!("iv" in e))
    throw new Error("Invalid IV parameter.");
  this._iv = Pf(e.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
};
pt.ofb.prototype.encrypt = function(e, t, h) {
  var o = e.length();
  if (e.length() === 0)
    return !0;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && o >= this.blockSize) {
    for (var S = 0; S < this._ints; ++S)
      t.putInt32(e.getInt32() ^ this._outBlock[S]), this._inBlock[S] = this._outBlock[S];
    return;
  }
  var g = (this.blockSize - o) % this.blockSize;
  g > 0 && (g = this.blockSize - g), this._partialOutput.clear();
  for (var S = 0; S < this._ints; ++S)
    this._partialOutput.putInt32(e.getInt32() ^ this._outBlock[S]);
  if (g > 0)
    e.read -= this.blockSize;
  else
    for (var S = 0; S < this._ints; ++S)
      this._inBlock[S] = this._outBlock[S];
  if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), g > 0 && !h)
    return t.putBytes(this._partialOutput.getBytes(
      g - this._partialBytes
    )), this._partialBytes = g, !0;
  t.putBytes(this._partialOutput.getBytes(
    o - this._partialBytes
  )), this._partialBytes = 0;
};
pt.ofb.prototype.decrypt = pt.ofb.prototype.encrypt;
pt.ctr = function(e) {
  e = e || {}, this.name = "CTR", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = null, this._outBlock = new Array(this._ints), this._partialOutput = Qt.util.createBuffer(), this._partialBytes = 0;
};
pt.ctr.prototype.start = function(e) {
  if (!("iv" in e))
    throw new Error("Invalid IV parameter.");
  this._iv = Pf(e.iv, this.blockSize), this._inBlock = this._iv.slice(0), this._partialBytes = 0;
};
pt.ctr.prototype.encrypt = function(e, t, h) {
  var o = e.length();
  if (o === 0)
    return !0;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && o >= this.blockSize)
    for (var S = 0; S < this._ints; ++S)
      t.putInt32(e.getInt32() ^ this._outBlock[S]);
  else {
    var g = (this.blockSize - o) % this.blockSize;
    g > 0 && (g = this.blockSize - g), this._partialOutput.clear();
    for (var S = 0; S < this._ints; ++S)
      this._partialOutput.putInt32(e.getInt32() ^ this._outBlock[S]);
    if (g > 0 && (e.read -= this.blockSize), this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), g > 0 && !h)
      return t.putBytes(this._partialOutput.getBytes(
        g - this._partialBytes
      )), this._partialBytes = g, !0;
    t.putBytes(this._partialOutput.getBytes(
      o - this._partialBytes
    )), this._partialBytes = 0;
  }
  Lf(this._inBlock);
};
pt.ctr.prototype.decrypt = pt.ctr.prototype.encrypt;
pt.gcm = function(e) {
  e = e || {}, this.name = "GCM", this.cipher = e.cipher, this.blockSize = e.blockSize || 16, this._ints = this.blockSize / 4, this._inBlock = new Array(this._ints), this._outBlock = new Array(this._ints), this._partialOutput = Qt.util.createBuffer(), this._partialBytes = 0, this._R = 3774873600;
};
pt.gcm.prototype.start = function(e) {
  if (!("iv" in e))
    throw new Error("Invalid IV parameter.");
  var t = Qt.util.createBuffer(e.iv);
  this._cipherLength = 0;
  var h;
  if ("additionalData" in e ? h = Qt.util.createBuffer(e.additionalData) : h = Qt.util.createBuffer(), "tagLength" in e ? this._tagLength = e.tagLength : this._tagLength = 128, this._tag = null, e.decrypt && (this._tag = Qt.util.createBuffer(e.tag).getBytes(), this._tag.length !== this._tagLength / 8))
    throw new Error("Authentication tag does not match tag length.");
  this._hashBlock = new Array(this._ints), this.tag = null, this._hashSubkey = new Array(this._ints), this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey), this.componentBits = 4, this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
  var o = t.length();
  if (o === 12)
    this._j0 = [t.getInt32(), t.getInt32(), t.getInt32(), 1];
  else {
    for (this._j0 = [0, 0, 0, 0]; t.length() > 0; )
      this._j0 = this.ghash(
        this._hashSubkey,
        this._j0,
        [t.getInt32(), t.getInt32(), t.getInt32(), t.getInt32()]
      );
    this._j0 = this.ghash(
      this._hashSubkey,
      this._j0,
      [0, 0].concat(yc(o * 8))
    );
  }
  this._inBlock = this._j0.slice(0), Lf(this._inBlock), this._partialBytes = 0, h = Qt.util.createBuffer(h), this._aDataLength = yc(h.length() * 8);
  var S = h.length() % this.blockSize;
  for (S && h.fillWithByte(0, this.blockSize - S), this._s = [0, 0, 0, 0]; h.length() > 0; )
    this._s = this.ghash(this._hashSubkey, this._s, [
      h.getInt32(),
      h.getInt32(),
      h.getInt32(),
      h.getInt32()
    ]);
};
pt.gcm.prototype.encrypt = function(e, t, h) {
  var o = e.length();
  if (o === 0)
    return !0;
  if (this.cipher.encrypt(this._inBlock, this._outBlock), this._partialBytes === 0 && o >= this.blockSize) {
    for (var S = 0; S < this._ints; ++S)
      t.putInt32(this._outBlock[S] ^= e.getInt32());
    this._cipherLength += this.blockSize;
  } else {
    var g = (this.blockSize - o) % this.blockSize;
    g > 0 && (g = this.blockSize - g), this._partialOutput.clear();
    for (var S = 0; S < this._ints; ++S)
      this._partialOutput.putInt32(e.getInt32() ^ this._outBlock[S]);
    if (g <= 0 || h) {
      if (h) {
        var B = o % this.blockSize;
        this._cipherLength += B, this._partialOutput.truncate(this.blockSize - B);
      } else
        this._cipherLength += this.blockSize;
      for (var S = 0; S < this._ints; ++S)
        this._outBlock[S] = this._partialOutput.getInt32();
      this._partialOutput.read -= this.blockSize;
    }
    if (this._partialBytes > 0 && this._partialOutput.getBytes(this._partialBytes), g > 0 && !h)
      return e.read -= this.blockSize, t.putBytes(this._partialOutput.getBytes(
        g - this._partialBytes
      )), this._partialBytes = g, !0;
    t.putBytes(this._partialOutput.getBytes(
      o - this._partialBytes
    )), this._partialBytes = 0;
  }
  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock), Lf(this._inBlock);
};
pt.gcm.prototype.decrypt = function(e, t, h) {
  var o = e.length();
  if (o < this.blockSize && !(h && o > 0))
    return !0;
  this.cipher.encrypt(this._inBlock, this._outBlock), Lf(this._inBlock), this._hashBlock[0] = e.getInt32(), this._hashBlock[1] = e.getInt32(), this._hashBlock[2] = e.getInt32(), this._hashBlock[3] = e.getInt32(), this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
  for (var S = 0; S < this._ints; ++S)
    t.putInt32(this._outBlock[S] ^ this._hashBlock[S]);
  o < this.blockSize ? this._cipherLength += o % this.blockSize : this._cipherLength += this.blockSize;
};
pt.gcm.prototype.afterFinish = function(e, t) {
  var h = !0;
  t.decrypt && t.overflow && e.truncate(this.blockSize - t.overflow), this.tag = Qt.util.createBuffer();
  var o = this._aDataLength.concat(yc(this._cipherLength * 8));
  this._s = this.ghash(this._hashSubkey, this._s, o);
  var S = [];
  this.cipher.encrypt(this._j0, S);
  for (var g = 0; g < this._ints; ++g)
    this.tag.putInt32(this._s[g] ^ S[g]);
  return this.tag.truncate(this.tag.length() % (this._tagLength / 8)), t.decrypt && this.tag.bytes() !== this._tag && (h = !1), h;
};
pt.gcm.prototype.multiply = function(e, t) {
  for (var h = [0, 0, 0, 0], o = t.slice(0), S = 0; S < 128; ++S) {
    var g = e[S / 32 | 0] & 1 << 31 - S % 32;
    g && (h[0] ^= o[0], h[1] ^= o[1], h[2] ^= o[2], h[3] ^= o[3]), this.pow(o, o);
  }
  return h;
};
pt.gcm.prototype.pow = function(e, t) {
  for (var h = e[3] & 1, o = 3; o > 0; --o)
    t[o] = e[o] >>> 1 | (e[o - 1] & 1) << 31;
  t[0] = e[0] >>> 1, h && (t[0] ^= this._R);
};
pt.gcm.prototype.tableMultiply = function(e) {
  for (var t = [0, 0, 0, 0], h = 0; h < 32; ++h) {
    var o = h / 8 | 0, S = e[o] >>> (7 - h % 8) * 4 & 15, g = this._m[h][S];
    t[0] ^= g[0], t[1] ^= g[1], t[2] ^= g[2], t[3] ^= g[3];
  }
  return t;
};
pt.gcm.prototype.ghash = function(e, t, h) {
  return t[0] ^= h[0], t[1] ^= h[1], t[2] ^= h[2], t[3] ^= h[3], this.tableMultiply(t);
};
pt.gcm.prototype.generateHashTable = function(e, t) {
  for (var h = 8 / t, o = 4 * h, S = 16 * h, g = new Array(S), B = 0; B < S; ++B) {
    var M = [0, 0, 0, 0], O = B / o | 0, P = (o - 1 - B % o) * t;
    M[O] = 1 << t - 1 << P, g[B] = this.generateSubHashTable(this.multiply(M, e), t);
  }
  return g;
};
pt.gcm.prototype.generateSubHashTable = function(e, t) {
  var h = 1 << t, o = h >>> 1, S = new Array(h);
  S[o] = e.slice(0);
  for (var g = o >>> 1; g > 0; )
    this.pow(S[2 * g], S[g] = []), g >>= 1;
  for (g = 2; g < o; ) {
    for (var B = 1; B < g; ++B) {
      var M = S[g], O = S[B];
      S[g + B] = [
        M[0] ^ O[0],
        M[1] ^ O[1],
        M[2] ^ O[2],
        M[3] ^ O[3]
      ];
    }
    g *= 2;
  }
  for (S[0] = [0, 0, 0, 0], g = o + 1; g < h; ++g) {
    var P = S[g ^ o];
    S[g] = [e[0] ^ P[0], e[1] ^ P[1], e[2] ^ P[2], e[3] ^ P[3]];
  }
  return S;
};
function Pf(e, t) {
  if (typeof e == "string" && (e = Qt.util.createBuffer(e)), Qt.util.isArray(e) && e.length > 4) {
    var h = e;
    e = Qt.util.createBuffer();
    for (var o = 0; o < h.length; ++o)
      e.putByte(h[o]);
  }
  if (e.length() < t)
    throw new Error(
      "Invalid IV length; got " + e.length() + " bytes and expected " + t + " bytes."
    );
  if (!Qt.util.isArray(e)) {
    for (var S = [], g = t / 4, o = 0; o < g; ++o)
      S.push(e.getInt32());
    e = S;
  }
  return e;
}
function Lf(e) {
  e[e.length - 1] = e[e.length - 1] + 1 & 4294967295;
}
function yc(e) {
  return [e / 4294967296 | 0, e & 4294967295];
}
var Lt = ht;
Lt.aes = Lt.aes || {};
Lt.aes.startEncrypting = function(e, t, h, o) {
  var S = kf({
    key: e,
    output: h,
    decrypt: !1,
    mode: o
  });
  return S.start(t), S;
};
Lt.aes.createEncryptionCipher = function(e, t) {
  return kf({
    key: e,
    output: null,
    decrypt: !1,
    mode: t
  });
};
Lt.aes.startDecrypting = function(e, t, h, o) {
  var S = kf({
    key: e,
    output: h,
    decrypt: !0,
    mode: o
  });
  return S.start(t), S;
};
Lt.aes.createDecryptionCipher = function(e, t) {
  return kf({
    key: e,
    output: null,
    decrypt: !0,
    mode: t
  });
};
Lt.aes.Algorithm = function(e, t) {
  Fh || v2();
  var h = this;
  h.name = e, h.mode = new t({
    blockSize: 16,
    cipher: {
      encrypt: function(o, S) {
        return mc(h._w, o, S, !1);
      },
      decrypt: function(o, S) {
        return mc(h._w, o, S, !0);
      }
    }
  }), h._init = !1;
};
Lt.aes.Algorithm.prototype.initialize = function(e) {
  if (!this._init) {
    var t = e.key, h;
    if (typeof t == "string" && (t.length === 16 || t.length === 24 || t.length === 32))
      t = Lt.util.createBuffer(t);
    else if (Lt.util.isArray(t) && (t.length === 16 || t.length === 24 || t.length === 32)) {
      h = t, t = Lt.util.createBuffer();
      for (var o = 0; o < h.length; ++o)
        t.putByte(h[o]);
    }
    if (!Lt.util.isArray(t)) {
      h = t, t = [];
      var S = h.length();
      if (S === 16 || S === 24 || S === 32) {
        S = S >>> 2;
        for (var o = 0; o < S; ++o)
          t.push(h.getInt32());
      }
    }
    if (!Lt.util.isArray(t) || !(t.length === 4 || t.length === 6 || t.length === 8))
      throw new Error("Invalid key parameter.");
    var g = this.mode.name, B = ["CFB", "OFB", "CTR", "GCM"].indexOf(g) !== -1;
    this._w = y2(t, e.decrypt && !B), this._init = !0;
  }
};
Lt.aes._expandKey = function(e, t) {
  return Fh || v2(), y2(e, t);
};
Lt.aes._updateBlock = mc;
Ja("AES-ECB", Lt.cipher.modes.ecb);
Ja("AES-CBC", Lt.cipher.modes.cbc);
Ja("AES-CFB", Lt.cipher.modes.cfb);
Ja("AES-OFB", Lt.cipher.modes.ofb);
Ja("AES-CTR", Lt.cipher.modes.ctr);
Ja("AES-GCM", Lt.cipher.modes.gcm);
function Ja(e, t) {
  var h = function() {
    return new Lt.aes.Algorithm(e, t);
  };
  Lt.cipher.registerAlgorithm(e, h);
}
var Fh = !1, da = 4, vr, gc, p2, jn, Ei;
function v2() {
  Fh = !0, p2 = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
  for (var e = new Array(256), t = 0; t < 128; ++t)
    e[t] = t << 1, e[t + 128] = t + 128 << 1 ^ 283;
  vr = new Array(256), gc = new Array(256), jn = new Array(4), Ei = new Array(4);
  for (var t = 0; t < 4; ++t)
    jn[t] = new Array(256), Ei[t] = new Array(256);
  for (var h = 0, o = 0, S, g, B, M, O, P, D, t = 0; t < 256; ++t) {
    M = o ^ o << 1 ^ o << 2 ^ o << 3 ^ o << 4, M = M >> 8 ^ M & 255 ^ 99, vr[h] = M, gc[M] = h, O = e[M], S = e[h], g = e[S], B = e[g], P = O << 24 ^ // 2
    M << 16 ^ // 1
    M << 8 ^ // 1
    (M ^ O), D = (S ^ g ^ B) << 24 ^ // E (14)
    (h ^ B) << 16 ^ // 9
    (h ^ g ^ B) << 8 ^ // D (13)
    (h ^ S ^ B);
    for (var Z = 0; Z < 4; ++Z)
      jn[Z][h] = P, Ei[Z][M] = D, P = P << 24 | P >>> 8, D = D << 24 | D >>> 8;
    h === 0 ? h = o = 1 : (h = S ^ e[e[e[S ^ B]]], o ^= e[e[o]]);
  }
}
function y2(e, t) {
  for (var h = e.slice(0), o, S = 1, g = h.length, B = g + 6 + 1, M = da * B, O = g; O < M; ++O)
    o = h[O - 1], O % g === 0 ? (o = vr[o >>> 16 & 255] << 24 ^ vr[o >>> 8 & 255] << 16 ^ vr[o & 255] << 8 ^ vr[o >>> 24] ^ p2[S] << 24, S++) : g > 6 && O % g === 4 && (o = vr[o >>> 24] << 24 ^ vr[o >>> 16 & 255] << 16 ^ vr[o >>> 8 & 255] << 8 ^ vr[o & 255]), h[O] = h[O - g] ^ o;
  if (t) {
    var P, D = Ei[0], Z = Ei[1], Y = Ei[2], ee = Ei[3], ie = h.slice(0);
    M = h.length;
    for (var O = 0, ue = M - da; O < M; O += da, ue -= da)
      if (O === 0 || O === M - da)
        ie[O] = h[ue], ie[O + 1] = h[ue + 3], ie[O + 2] = h[ue + 2], ie[O + 3] = h[ue + 1];
      else
        for (var fe = 0; fe < da; ++fe)
          P = h[ue + fe], ie[O + (3 & -fe)] = D[vr[P >>> 24]] ^ Z[vr[P >>> 16 & 255]] ^ Y[vr[P >>> 8 & 255]] ^ ee[vr[P & 255]];
    h = ie;
  }
  return h;
}
function mc(e, t, h, o) {
  var S = e.length / 4 - 1, g, B, M, O, P;
  o ? (g = Ei[0], B = Ei[1], M = Ei[2], O = Ei[3], P = gc) : (g = jn[0], B = jn[1], M = jn[2], O = jn[3], P = vr);
  var D, Z, Y, ee, ie, ue, fe;
  D = t[0] ^ e[0], Z = t[o ? 3 : 1] ^ e[1], Y = t[2] ^ e[2], ee = t[o ? 1 : 3] ^ e[3];
  for (var de = 3, ce = 1; ce < S; ++ce)
    ie = g[D >>> 24] ^ B[Z >>> 16 & 255] ^ M[Y >>> 8 & 255] ^ O[ee & 255] ^ e[++de], ue = g[Z >>> 24] ^ B[Y >>> 16 & 255] ^ M[ee >>> 8 & 255] ^ O[D & 255] ^ e[++de], fe = g[Y >>> 24] ^ B[ee >>> 16 & 255] ^ M[D >>> 8 & 255] ^ O[Z & 255] ^ e[++de], ee = g[ee >>> 24] ^ B[D >>> 16 & 255] ^ M[Z >>> 8 & 255] ^ O[Y & 255] ^ e[++de], D = ie, Z = ue, Y = fe;
  h[0] = P[D >>> 24] << 24 ^ P[Z >>> 16 & 255] << 16 ^ P[Y >>> 8 & 255] << 8 ^ P[ee & 255] ^ e[++de], h[o ? 3 : 1] = P[Z >>> 24] << 24 ^ P[Y >>> 16 & 255] << 16 ^ P[ee >>> 8 & 255] << 8 ^ P[D & 255] ^ e[++de], h[2] = P[Y >>> 24] << 24 ^ P[ee >>> 16 & 255] << 16 ^ P[D >>> 8 & 255] << 8 ^ P[Z & 255] ^ e[++de], h[o ? 1 : 3] = P[ee >>> 24] << 24 ^ P[D >>> 16 & 255] << 16 ^ P[Z >>> 8 & 255] << 8 ^ P[Y & 255] ^ e[++de];
}
function kf(e) {
  e = e || {};
  var t = (e.mode || "CBC").toUpperCase(), h = "AES-" + t, o;
  e.decrypt ? o = Lt.cipher.createDecipher(h, e.key) : o = Lt.cipher.createCipher(h, e.key);
  var S = o.start;
  return o.start = function(g, B) {
    var M = null;
    B instanceof Lt.util.ByteBuffer && (M = B, B = {}), B = B || {}, B.output = M, B.iv = g, S.call(o, B);
  }, o;
}
var E0 = ht;
E0.pki = E0.pki || {};
var bc = E0.pki.oids = E0.oids = E0.oids || {};
function Se(e, t) {
  bc[e] = t, bc[t] = e;
}
function wt(e, t) {
  bc[e] = t;
}
Se("1.2.840.113549.1.1.1", "rsaEncryption");
Se("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
Se("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
Se("1.2.840.113549.1.1.7", "RSAES-OAEP");
Se("1.2.840.113549.1.1.8", "mgf1");
Se("1.2.840.113549.1.1.9", "pSpecified");
Se("1.2.840.113549.1.1.10", "RSASSA-PSS");
Se("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
Se("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
Se("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
Se("1.3.101.112", "EdDSA25519");
Se("1.2.840.10040.4.3", "dsa-with-sha1");
Se("1.3.14.3.2.7", "desCBC");
Se("1.3.14.3.2.26", "sha1");
Se("1.3.14.3.2.29", "sha1WithRSASignature");
Se("2.16.840.1.101.3.4.2.1", "sha256");
Se("2.16.840.1.101.3.4.2.2", "sha384");
Se("2.16.840.1.101.3.4.2.3", "sha512");
Se("2.16.840.1.101.3.4.2.4", "sha224");
Se("2.16.840.1.101.3.4.2.5", "sha512-224");
Se("2.16.840.1.101.3.4.2.6", "sha512-256");
Se("1.2.840.113549.2.2", "md2");
Se("1.2.840.113549.2.5", "md5");
Se("1.2.840.113549.1.7.1", "data");
Se("1.2.840.113549.1.7.2", "signedData");
Se("1.2.840.113549.1.7.3", "envelopedData");
Se("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
Se("1.2.840.113549.1.7.5", "digestedData");
Se("1.2.840.113549.1.7.6", "encryptedData");
Se("1.2.840.113549.1.9.1", "emailAddress");
Se("1.2.840.113549.1.9.2", "unstructuredName");
Se("1.2.840.113549.1.9.3", "contentType");
Se("1.2.840.113549.1.9.4", "messageDigest");
Se("1.2.840.113549.1.9.5", "signingTime");
Se("1.2.840.113549.1.9.6", "counterSignature");
Se("1.2.840.113549.1.9.7", "challengePassword");
Se("1.2.840.113549.1.9.8", "unstructuredAddress");
Se("1.2.840.113549.1.9.14", "extensionRequest");
Se("1.2.840.113549.1.9.20", "friendlyName");
Se("1.2.840.113549.1.9.21", "localKeyId");
Se("1.2.840.113549.1.9.22.1", "x509Certificate");
Se("1.2.840.113549.1.12.10.1.1", "keyBag");
Se("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
Se("1.2.840.113549.1.12.10.1.3", "certBag");
Se("1.2.840.113549.1.12.10.1.4", "crlBag");
Se("1.2.840.113549.1.12.10.1.5", "secretBag");
Se("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
Se("1.2.840.113549.1.5.13", "pkcs5PBES2");
Se("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
Se("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
Se("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
Se("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
Se("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
Se("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
Se("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
Se("1.2.840.113549.2.7", "hmacWithSHA1");
Se("1.2.840.113549.2.8", "hmacWithSHA224");
Se("1.2.840.113549.2.9", "hmacWithSHA256");
Se("1.2.840.113549.2.10", "hmacWithSHA384");
Se("1.2.840.113549.2.11", "hmacWithSHA512");
Se("1.2.840.113549.3.7", "des-EDE3-CBC");
Se("2.16.840.1.101.3.4.1.2", "aes128-CBC");
Se("2.16.840.1.101.3.4.1.22", "aes192-CBC");
Se("2.16.840.1.101.3.4.1.42", "aes256-CBC");
Se("2.5.4.3", "commonName");
Se("2.5.4.4", "surname");
Se("2.5.4.5", "serialNumber");
Se("2.5.4.6", "countryName");
Se("2.5.4.7", "localityName");
Se("2.5.4.8", "stateOrProvinceName");
Se("2.5.4.9", "streetAddress");
Se("2.5.4.10", "organizationName");
Se("2.5.4.11", "organizationalUnitName");
Se("2.5.4.12", "title");
Se("2.5.4.13", "description");
Se("2.5.4.15", "businessCategory");
Se("2.5.4.17", "postalCode");
Se("2.5.4.42", "givenName");
Se("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
Se("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
Se("2.16.840.1.113730.1.1", "nsCertType");
Se("2.16.840.1.113730.1.13", "nsComment");
wt("2.5.29.1", "authorityKeyIdentifier");
wt("2.5.29.2", "keyAttributes");
wt("2.5.29.3", "certificatePolicies");
wt("2.5.29.4", "keyUsageRestriction");
wt("2.5.29.5", "policyMapping");
wt("2.5.29.6", "subtreesConstraint");
wt("2.5.29.7", "subjectAltName");
wt("2.5.29.8", "issuerAltName");
wt("2.5.29.9", "subjectDirectoryAttributes");
wt("2.5.29.10", "basicConstraints");
wt("2.5.29.11", "nameConstraints");
wt("2.5.29.12", "policyConstraints");
wt("2.5.29.13", "basicConstraints");
Se("2.5.29.14", "subjectKeyIdentifier");
Se("2.5.29.15", "keyUsage");
wt("2.5.29.16", "privateKeyUsagePeriod");
Se("2.5.29.17", "subjectAltName");
Se("2.5.29.18", "issuerAltName");
Se("2.5.29.19", "basicConstraints");
wt("2.5.29.20", "cRLNumber");
wt("2.5.29.21", "cRLReason");
wt("2.5.29.22", "expirationDate");
wt("2.5.29.23", "instructionCode");
wt("2.5.29.24", "invalidityDate");
wt("2.5.29.25", "cRLDistributionPoints");
wt("2.5.29.26", "issuingDistributionPoint");
wt("2.5.29.27", "deltaCRLIndicator");
wt("2.5.29.28", "issuingDistributionPoint");
wt("2.5.29.29", "certificateIssuer");
wt("2.5.29.30", "nameConstraints");
Se("2.5.29.31", "cRLDistributionPoints");
Se("2.5.29.32", "certificatePolicies");
wt("2.5.29.33", "policyMappings");
wt("2.5.29.34", "policyConstraints");
Se("2.5.29.35", "authorityKeyIdentifier");
wt("2.5.29.36", "policyConstraints");
Se("2.5.29.37", "extKeyUsage");
wt("2.5.29.46", "freshestCRL");
wt("2.5.29.54", "inhibitAnyPolicy");
Se("1.3.6.1.4.1.11129.2.4.2", "timestampList");
Se("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
Se("1.3.6.1.5.5.7.3.1", "serverAuth");
Se("1.3.6.1.5.5.7.3.2", "clientAuth");
Se("1.3.6.1.5.5.7.3.3", "codeSigning");
Se("1.3.6.1.5.5.7.3.4", "emailProtection");
Se("1.3.6.1.5.5.7.3.8", "timeStamping");
var Ut = ht, Ie = Ut.asn1 = Ut.asn1 || {};
Ie.Class = {
  UNIVERSAL: 0,
  APPLICATION: 64,
  CONTEXT_SPECIFIC: 128,
  PRIVATE: 192
};
Ie.Type = {
  NONE: 0,
  BOOLEAN: 1,
  INTEGER: 2,
  BITSTRING: 3,
  OCTETSTRING: 4,
  NULL: 5,
  OID: 6,
  ODESC: 7,
  EXTERNAL: 8,
  REAL: 9,
  ENUMERATED: 10,
  EMBEDDED: 11,
  UTF8: 12,
  ROID: 13,
  SEQUENCE: 16,
  SET: 17,
  PRINTABLESTRING: 19,
  IA5STRING: 22,
  UTCTIME: 23,
  GENERALIZEDTIME: 24,
  BMPSTRING: 30
};
Ie.create = function(e, t, h, o, S) {
  if (Ut.util.isArray(o)) {
    for (var g = [], B = 0; B < o.length; ++B)
      o[B] !== void 0 && g.push(o[B]);
    o = g;
  }
  var M = {
    tagClass: e,
    type: t,
    constructed: h,
    composed: h || Ut.util.isArray(o),
    value: o
  };
  return S && "bitStringContents" in S && (M.bitStringContents = S.bitStringContents, M.original = Ie.copy(M)), M;
};
Ie.copy = function(e, t) {
  var h;
  if (Ut.util.isArray(e)) {
    h = [];
    for (var o = 0; o < e.length; ++o)
      h.push(Ie.copy(e[o], t));
    return h;
  }
  return typeof e == "string" ? e : (h = {
    tagClass: e.tagClass,
    type: e.type,
    constructed: e.constructed,
    composed: e.composed,
    value: Ie.copy(e.value, t)
  }, t && !t.excludeBitStringContents && (h.bitStringContents = e.bitStringContents), h);
};
Ie.equals = function(e, t, h) {
  if (Ut.util.isArray(e)) {
    if (!Ut.util.isArray(t) || e.length !== t.length)
      return !1;
    for (var o = 0; o < e.length; ++o)
      if (!Ie.equals(e[o], t[o]))
        return !1;
    return !0;
  }
  if (typeof e != typeof t)
    return !1;
  if (typeof e == "string")
    return e === t;
  var S = e.tagClass === t.tagClass && e.type === t.type && e.constructed === t.constructed && e.composed === t.composed && Ie.equals(e.value, t.value);
  return h && h.includeBitStringContents && (S = S && e.bitStringContents === t.bitStringContents), S;
};
Ie.getBerValueLength = function(e) {
  var t = e.getByte();
  if (t !== 128) {
    var h, o = t & 128;
    return o ? h = e.getInt((t & 127) << 3) : h = t, h;
  }
};
function b0(e, t, h) {
  if (h > t) {
    var o = new Error("Too few bytes to parse DER.");
    throw o.available = e.length(), o.remaining = t, o.requested = h, o;
  }
}
var zC = function(e, t) {
  var h = e.getByte();
  if (t--, h !== 128) {
    var o, S = h & 128;
    if (!S)
      o = h;
    else {
      var g = h & 127;
      b0(e, t, g), o = e.getInt(g << 3);
    }
    if (o < 0)
      throw new Error("Negative length: " + o);
    return o;
  }
};
Ie.fromDer = function(e, t) {
  t === void 0 && (t = {
    strict: !0,
    parseAllBytes: !0,
    decodeBitStrings: !0
  }), typeof t == "boolean" && (t = {
    strict: t,
    parseAllBytes: !0,
    decodeBitStrings: !0
  }), "strict" in t || (t.strict = !0), "parseAllBytes" in t || (t.parseAllBytes = !0), "decodeBitStrings" in t || (t.decodeBitStrings = !0), typeof e == "string" && (e = Ut.util.createBuffer(e));
  var h = e.length(), o = _s(e, e.length(), 0, t);
  if (t.parseAllBytes && e.length() !== 0) {
    var S = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
    throw S.byteCount = h, S.remaining = e.length(), S;
  }
  return o;
};
function _s(e, t, h, o) {
  var S;
  b0(e, t, 2);
  var g = e.getByte();
  t--;
  var B = g & 192, M = g & 31;
  S = e.length();
  var O = zC(e, t);
  if (t -= S - e.length(), O !== void 0 && O > t) {
    if (o.strict) {
      var P = new Error("Too few bytes to read ASN.1 value.");
      throw P.available = e.length(), P.remaining = t, P.requested = O, P;
    }
    O = t;
  }
  var D, Z, Y = (g & 32) === 32;
  if (Y)
    if (D = [], O === void 0)
      for (; ; ) {
        if (b0(e, t, 2), e.bytes(2) === "\0\0") {
          e.getBytes(2), t -= 2;
          break;
        }
        S = e.length(), D.push(_s(e, t, h + 1, o)), t -= S - e.length();
      }
    else
      for (; O > 0; )
        S = e.length(), D.push(_s(e, O, h + 1, o)), t -= S - e.length(), O -= S - e.length();
  if (D === void 0 && B === Ie.Class.UNIVERSAL && M === Ie.Type.BITSTRING && (Z = e.bytes(O)), D === void 0 && o.decodeBitStrings && B === Ie.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
  // .. other parts of forge expect to decode OCTET STRINGs manually
  M === Ie.Type.BITSTRING && O > 1) {
    var ee = e.read, ie = t, ue = 0;
    if (M === Ie.Type.BITSTRING && (b0(e, t, 1), ue = e.getByte(), t--), ue === 0)
      try {
        S = e.length();
        var fe = {
          // enforce strict mode to avoid parsing ASN.1 from plain data
          strict: !0,
          decodeBitStrings: !0
        }, de = _s(e, t, h + 1, fe), ce = S - e.length();
        t -= ce, M == Ie.Type.BITSTRING && ce++;
        var be = de.tagClass;
        ce === O && (be === Ie.Class.UNIVERSAL || be === Ie.Class.CONTEXT_SPECIFIC) && (D = [de]);
      } catch {
      }
    D === void 0 && (e.read = ee, t = ie);
  }
  if (D === void 0) {
    if (O === void 0) {
      if (o.strict)
        throw new Error("Non-constructed ASN.1 object of indefinite length.");
      O = t;
    }
    if (M === Ie.Type.BMPSTRING)
      for (D = ""; O > 0; O -= 2)
        b0(e, t, 2), D += String.fromCharCode(e.getInt16()), t -= 2;
    else
      D = e.getBytes(O), t -= O;
  }
  var ve = Z === void 0 ? null : {
    bitStringContents: Z
  };
  return Ie.create(B, M, Y, D, ve);
}
Ie.toDer = function(e) {
  var t = Ut.util.createBuffer(), h = e.tagClass | e.type, o = Ut.util.createBuffer(), S = !1;
  if ("bitStringContents" in e && (S = !0, e.original && (S = Ie.equals(e, e.original))), S)
    o.putBytes(e.bitStringContents);
  else if (e.composed) {
    e.constructed ? h |= 32 : o.putByte(0);
    for (var g = 0; g < e.value.length; ++g)
      e.value[g] !== void 0 && o.putBuffer(Ie.toDer(e.value[g]));
  } else if (e.type === Ie.Type.BMPSTRING)
    for (var g = 0; g < e.value.length; ++g)
      o.putInt16(e.value.charCodeAt(g));
  else
    e.type === Ie.Type.INTEGER && e.value.length > 1 && // leading 0x00 for positive integer
    (e.value.charCodeAt(0) === 0 && !(e.value.charCodeAt(1) & 128) || // leading 0xFF for negative integer
    e.value.charCodeAt(0) === 255 && (e.value.charCodeAt(1) & 128) === 128) ? o.putBytes(e.value.substr(1)) : o.putBytes(e.value);
  if (t.putByte(h), o.length() <= 127)
    t.putByte(o.length() & 127);
  else {
    var B = o.length(), M = "";
    do
      M += String.fromCharCode(B & 255), B = B >>> 8;
    while (B > 0);
    t.putByte(M.length | 128);
    for (var g = M.length - 1; g >= 0; --g)
      t.putByte(M.charCodeAt(g));
  }
  return t.putBuffer(o), t;
};
Ie.oidToDer = function(e) {
  var t = e.split("."), h = Ut.util.createBuffer();
  h.putByte(40 * parseInt(t[0], 10) + parseInt(t[1], 10));
  for (var o, S, g, B, M = 2; M < t.length; ++M) {
    o = !0, S = [], g = parseInt(t[M], 10);
    do
      B = g & 127, g = g >>> 7, o || (B |= 128), S.push(B), o = !1;
    while (g > 0);
    for (var O = S.length - 1; O >= 0; --O)
      h.putByte(S[O]);
  }
  return h;
};
Ie.derToOid = function(e) {
  var t;
  typeof e == "string" && (e = Ut.util.createBuffer(e));
  var h = e.getByte();
  t = Math.floor(h / 40) + "." + h % 40;
  for (var o = 0; e.length() > 0; )
    h = e.getByte(), o = o << 7, h & 128 ? o += h & 127 : (t += "." + (o + h), o = 0);
  return t;
};
Ie.utcTimeToDate = function(e) {
  var t = /* @__PURE__ */ new Date(), h = parseInt(e.substr(0, 2), 10);
  h = h >= 50 ? 1900 + h : 2e3 + h;
  var o = parseInt(e.substr(2, 2), 10) - 1, S = parseInt(e.substr(4, 2), 10), g = parseInt(e.substr(6, 2), 10), B = parseInt(e.substr(8, 2), 10), M = 0;
  if (e.length > 11) {
    var O = e.charAt(10), P = 10;
    O !== "+" && O !== "-" && (M = parseInt(e.substr(10, 2), 10), P += 2);
  }
  if (t.setUTCFullYear(h, o, S), t.setUTCHours(g, B, M, 0), P && (O = e.charAt(P), O === "+" || O === "-")) {
    var D = parseInt(e.substr(P + 1, 2), 10), Z = parseInt(e.substr(P + 4, 2), 10), Y = D * 60 + Z;
    Y *= 6e4, O === "+" ? t.setTime(+t - Y) : t.setTime(+t + Y);
  }
  return t;
};
Ie.generalizedTimeToDate = function(e) {
  var t = /* @__PURE__ */ new Date(), h = parseInt(e.substr(0, 4), 10), o = parseInt(e.substr(4, 2), 10) - 1, S = parseInt(e.substr(6, 2), 10), g = parseInt(e.substr(8, 2), 10), B = parseInt(e.substr(10, 2), 10), M = parseInt(e.substr(12, 2), 10), O = 0, P = 0, D = !1;
  e.charAt(e.length - 1) === "Z" && (D = !0);
  var Z = e.length - 5, Y = e.charAt(Z);
  if (Y === "+" || Y === "-") {
    var ee = parseInt(e.substr(Z + 1, 2), 10), ie = parseInt(e.substr(Z + 4, 2), 10);
    P = ee * 60 + ie, P *= 6e4, Y === "+" && (P *= -1), D = !0;
  }
  return e.charAt(14) === "." && (O = parseFloat(e.substr(14), 10) * 1e3), D ? (t.setUTCFullYear(h, o, S), t.setUTCHours(g, B, M, O), t.setTime(+t + P)) : (t.setFullYear(h, o, S), t.setHours(g, B, M, O)), t;
};
Ie.dateToUtcTime = function(e) {
  if (typeof e == "string")
    return e;
  var t = "", h = [];
  h.push(("" + e.getUTCFullYear()).substr(2)), h.push("" + (e.getUTCMonth() + 1)), h.push("" + e.getUTCDate()), h.push("" + e.getUTCHours()), h.push("" + e.getUTCMinutes()), h.push("" + e.getUTCSeconds());
  for (var o = 0; o < h.length; ++o)
    h[o].length < 2 && (t += "0"), t += h[o];
  return t += "Z", t;
};
Ie.dateToGeneralizedTime = function(e) {
  if (typeof e == "string")
    return e;
  var t = "", h = [];
  h.push("" + e.getUTCFullYear()), h.push("" + (e.getUTCMonth() + 1)), h.push("" + e.getUTCDate()), h.push("" + e.getUTCHours()), h.push("" + e.getUTCMinutes()), h.push("" + e.getUTCSeconds());
  for (var o = 0; o < h.length; ++o)
    h[o].length < 2 && (t += "0"), t += h[o];
  return t += "Z", t;
};
Ie.integerToDer = function(e) {
  var t = Ut.util.createBuffer();
  if (e >= -128 && e < 128)
    return t.putSignedInt(e, 8);
  if (e >= -32768 && e < 32768)
    return t.putSignedInt(e, 16);
  if (e >= -8388608 && e < 8388608)
    return t.putSignedInt(e, 24);
  if (e >= -2147483648 && e < 2147483648)
    return t.putSignedInt(e, 32);
  var h = new Error("Integer too large; max is 32-bits.");
  throw h.integer = e, h;
};
Ie.derToInteger = function(e) {
  typeof e == "string" && (e = Ut.util.createBuffer(e));
  var t = e.length() * 8;
  if (t > 32)
    throw new Error("Integer too large; max is 32-bits.");
  return e.getSignedInt(t);
};
Ie.validate = function(e, t, h, o) {
  var S = !1;
  if ((e.tagClass === t.tagClass || typeof t.tagClass > "u") && (e.type === t.type || typeof t.type > "u"))
    if (e.constructed === t.constructed || typeof t.constructed > "u") {
      if (S = !0, t.value && Ut.util.isArray(t.value))
        for (var g = 0, B = 0; S && B < t.value.length; ++B)
          S = t.value[B].optional || !1, e.value[g] && (S = Ie.validate(e.value[g], t.value[B], h, o), S ? ++g : t.value[B].optional && (S = !0)), !S && o && o.push(
            "[" + t.name + '] Tag class "' + t.tagClass + '", type "' + t.type + '" expected value length "' + t.value.length + '", got "' + e.value.length + '"'
          );
      if (S && h && (t.capture && (h[t.capture] = e.value), t.captureAsn1 && (h[t.captureAsn1] = e), t.captureBitStringContents && "bitStringContents" in e && (h[t.captureBitStringContents] = e.bitStringContents), t.captureBitStringValue && "bitStringContents" in e))
        if (e.bitStringContents.length < 2)
          h[t.captureBitStringValue] = "";
        else {
          var M = e.bitStringContents.charCodeAt(0);
          if (M !== 0)
            throw new Error(
              "captureBitStringValue only supported for zero unused bits"
            );
          h[t.captureBitStringValue] = e.bitStringContents.slice(1);
        }
    } else
      o && o.push(
        "[" + t.name + '] Expected constructed "' + t.constructed + '", got "' + e.constructed + '"'
      );
  else
    o && (e.tagClass !== t.tagClass && o.push(
      "[" + t.name + '] Expected tag class "' + t.tagClass + '", got "' + e.tagClass + '"'
    ), e.type !== t.type && o.push(
      "[" + t.name + '] Expected type "' + t.type + '", got "' + e.type + '"'
    ));
  return S;
};
var Dp = /[^\\u0000-\\u00ff]/;
Ie.prettyPrint = function(e, t, h) {
  var o = "";
  t = t || 0, h = h || 2, t > 0 && (o += `
`);
  for (var S = "", g = 0; g < t * h; ++g)
    S += " ";
  switch (o += S + "Tag: ", e.tagClass) {
    case Ie.Class.UNIVERSAL:
      o += "Universal:";
      break;
    case Ie.Class.APPLICATION:
      o += "Application:";
      break;
    case Ie.Class.CONTEXT_SPECIFIC:
      o += "Context-Specific:";
      break;
    case Ie.Class.PRIVATE:
      o += "Private:";
      break;
  }
  if (e.tagClass === Ie.Class.UNIVERSAL)
    switch (o += e.type, e.type) {
      case Ie.Type.NONE:
        o += " (None)";
        break;
      case Ie.Type.BOOLEAN:
        o += " (Boolean)";
        break;
      case Ie.Type.INTEGER:
        o += " (Integer)";
        break;
      case Ie.Type.BITSTRING:
        o += " (Bit string)";
        break;
      case Ie.Type.OCTETSTRING:
        o += " (Octet string)";
        break;
      case Ie.Type.NULL:
        o += " (Null)";
        break;
      case Ie.Type.OID:
        o += " (Object Identifier)";
        break;
      case Ie.Type.ODESC:
        o += " (Object Descriptor)";
        break;
      case Ie.Type.EXTERNAL:
        o += " (External or Instance of)";
        break;
      case Ie.Type.REAL:
        o += " (Real)";
        break;
      case Ie.Type.ENUMERATED:
        o += " (Enumerated)";
        break;
      case Ie.Type.EMBEDDED:
        o += " (Embedded PDV)";
        break;
      case Ie.Type.UTF8:
        o += " (UTF8)";
        break;
      case Ie.Type.ROID:
        o += " (Relative Object Identifier)";
        break;
      case Ie.Type.SEQUENCE:
        o += " (Sequence)";
        break;
      case Ie.Type.SET:
        o += " (Set)";
        break;
      case Ie.Type.PRINTABLESTRING:
        o += " (Printable String)";
        break;
      case Ie.Type.IA5String:
        o += " (IA5String (ASCII))";
        break;
      case Ie.Type.UTCTIME:
        o += " (UTC time)";
        break;
      case Ie.Type.GENERALIZEDTIME:
        o += " (Generalized time)";
        break;
      case Ie.Type.BMPSTRING:
        o += " (BMP String)";
        break;
    }
  else
    o += e.type;
  if (o += `
`, o += S + "Constructed: " + e.constructed + `
`, e.composed) {
    for (var B = 0, M = "", g = 0; g < e.value.length; ++g)
      e.value[g] !== void 0 && (B += 1, M += Ie.prettyPrint(e.value[g], t + 1, h), g + 1 < e.value.length && (M += ","));
    o += S + "Sub values: " + B + M;
  } else {
    if (o += S + "Value: ", e.type === Ie.Type.OID) {
      var O = Ie.derToOid(e.value);
      o += O, Ut.pki && Ut.pki.oids && O in Ut.pki.oids && (o += " (" + Ut.pki.oids[O] + ") ");
    }
    if (e.type === Ie.Type.INTEGER)
      try {
        o += Ie.derToInteger(e.value);
      } catch {
        o += "0x" + Ut.util.bytesToHex(e.value);
      }
    else if (e.type === Ie.Type.BITSTRING) {
      if (e.value.length > 1 ? o += "0x" + Ut.util.bytesToHex(e.value.slice(1)) : o += "(none)", e.value.length > 0) {
        var P = e.value.charCodeAt(0);
        P == 1 ? o += " (1 unused bit shown)" : P > 1 && (o += " (" + P + " unused bits shown)");
      }
    } else if (e.type === Ie.Type.OCTETSTRING)
      Dp.test(e.value) || (o += "(" + e.value + ") "), o += "0x" + Ut.util.bytesToHex(e.value);
    else if (e.type === Ie.Type.UTF8)
      try {
        o += Ut.util.decodeUtf8(e.value);
      } catch (D) {
        if (D.message === "URI malformed")
          o += "0x" + Ut.util.bytesToHex(e.value) + " (malformed UTF8)";
        else
          throw D;
      }
    else
      e.type === Ie.Type.PRINTABLESTRING || e.type === Ie.Type.IA5String ? o += e.value : Dp.test(e.value) ? o += "0x" + Ut.util.bytesToHex(e.value) : e.value.length === 0 ? o += "[null]" : o += e.value;
  }
  return o;
};
var Ps = ht;
Ps.md = Ps.md || {};
Ps.md.algorithms = Ps.md.algorithms || {};
var Zi = ht, jC = Zi.hmac = Zi.hmac || {};
jC.create = function() {
  var e = null, t = null, h = null, o = null, S = {};
  return S.start = function(g, B) {
    if (g !== null)
      if (typeof g == "string")
        if (g = g.toLowerCase(), g in Zi.md.algorithms)
          t = Zi.md.algorithms[g].create();
        else
          throw new Error('Unknown hash algorithm "' + g + '"');
      else
        t = g;
    if (B === null)
      B = e;
    else {
      if (typeof B == "string")
        B = Zi.util.createBuffer(B);
      else if (Zi.util.isArray(B)) {
        var M = B;
        B = Zi.util.createBuffer();
        for (var O = 0; O < M.length; ++O)
          B.putByte(M[O]);
      }
      var P = B.length();
      P > t.blockLength && (t.start(), t.update(B.bytes()), B = t.digest()), h = Zi.util.createBuffer(), o = Zi.util.createBuffer(), P = B.length();
      for (var O = 0; O < P; ++O) {
        var M = B.at(O);
        h.putByte(54 ^ M), o.putByte(92 ^ M);
      }
      if (P < t.blockLength)
        for (var M = t.blockLength - P, O = 0; O < M; ++O)
          h.putByte(54), o.putByte(92);
      e = B, h = h.bytes(), o = o.bytes();
    }
    t.start(), t.update(h);
  }, S.update = function(g) {
    t.update(g);
  }, S.getMac = function() {
    var g = t.digest().bytes();
    return t.start(), t.update(o), t.update(g), t.digest();
  }, S.digest = S.getMac, S;
};
var Li = ht, g2 = Li.md5 = Li.md5 || {};
Li.md.md5 = Li.md.algorithms.md5 = g2;
g2.create = function() {
  m2 || WC();
  var e = null, t = Li.util.createBuffer(), h = new Array(16), o = {
    algorithm: "md5",
    blockLength: 64,
    digestLength: 16,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  return o.start = function() {
    o.messageLength = 0, o.fullMessageLength = o.messageLength64 = [];
    for (var S = o.messageLengthSize / 4, g = 0; g < S; ++g)
      o.fullMessageLength.push(0);
    return t = Li.util.createBuffer(), e = {
      h0: 1732584193,
      h1: 4023233417,
      h2: 2562383102,
      h3: 271733878
    }, o;
  }, o.start(), o.update = function(S, g) {
    g === "utf8" && (S = Li.util.encodeUtf8(S));
    var B = S.length;
    o.messageLength += B, B = [B / 4294967296 >>> 0, B >>> 0];
    for (var M = o.fullMessageLength.length - 1; M >= 0; --M)
      o.fullMessageLength[M] += B[1], B[1] = B[0] + (o.fullMessageLength[M] / 4294967296 >>> 0), o.fullMessageLength[M] = o.fullMessageLength[M] >>> 0, B[0] = B[1] / 4294967296 >>> 0;
    return t.putBytes(S), Op(e, h, t), (t.read > 2048 || t.length() === 0) && t.compact(), o;
  }, o.digest = function() {
    var S = Li.util.createBuffer();
    S.putBytes(t.bytes());
    var g = o.fullMessageLength[o.fullMessageLength.length - 1] + o.messageLengthSize, B = g & o.blockLength - 1;
    S.putBytes(xc.substr(0, o.blockLength - B));
    for (var M, O = 0, P = o.fullMessageLength.length - 1; P >= 0; --P)
      M = o.fullMessageLength[P] * 8 + O, O = M / 4294967296 >>> 0, S.putInt32Le(M >>> 0);
    var D = {
      h0: e.h0,
      h1: e.h1,
      h2: e.h2,
      h3: e.h3
    };
    Op(D, h, S);
    var Z = Li.util.createBuffer();
    return Z.putInt32Le(D.h0), Z.putInt32Le(D.h1), Z.putInt32Le(D.h2), Z.putInt32Le(D.h3), Z;
  }, o;
};
var xc = null, Es = null, x0 = null, ga = null, m2 = !1;
function WC() {
  xc = "", xc += Li.util.fillString("\0", 64), Es = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    1,
    6,
    11,
    0,
    5,
    10,
    15,
    4,
    9,
    14,
    3,
    8,
    13,
    2,
    7,
    12,
    5,
    8,
    11,
    14,
    1,
    4,
    7,
    10,
    13,
    0,
    3,
    6,
    9,
    12,
    15,
    2,
    0,
    7,
    14,
    5,
    12,
    3,
    10,
    1,
    8,
    15,
    6,
    13,
    4,
    11,
    2,
    9
  ], x0 = [
    7,
    12,
    17,
    22,
    7,
    12,
    17,
    22,
    7,
    12,
    17,
    22,
    7,
    12,
    17,
    22,
    5,
    9,
    14,
    20,
    5,
    9,
    14,
    20,
    5,
    9,
    14,
    20,
    5,
    9,
    14,
    20,
    4,
    11,
    16,
    23,
    4,
    11,
    16,
    23,
    4,
    11,
    16,
    23,
    4,
    11,
    16,
    23,
    6,
    10,
    15,
    21,
    6,
    10,
    15,
    21,
    6,
    10,
    15,
    21,
    6,
    10,
    15,
    21
  ], ga = new Array(64);
  for (var e = 0; e < 64; ++e)
    ga[e] = Math.floor(Math.abs(Math.sin(e + 1)) * 4294967296);
  m2 = !0;
}
function Op(e, t, h) {
  for (var o, S, g, B, M, O, P, D, Z = h.length(); Z >= 64; ) {
    for (S = e.h0, g = e.h1, B = e.h2, M = e.h3, D = 0; D < 16; ++D)
      t[D] = h.getInt32Le(), O = M ^ g & (B ^ M), o = S + O + ga[D] + t[D], P = x0[D], S = M, M = B, B = g, g += o << P | o >>> 32 - P;
    for (; D < 32; ++D)
      O = B ^ M & (g ^ B), o = S + O + ga[D] + t[Es[D]], P = x0[D], S = M, M = B, B = g, g += o << P | o >>> 32 - P;
    for (; D < 48; ++D)
      O = g ^ B ^ M, o = S + O + ga[D] + t[Es[D]], P = x0[D], S = M, M = B, B = g, g += o << P | o >>> 32 - P;
    for (; D < 64; ++D)
      O = B ^ (g | ~M), o = S + O + ga[D] + t[Es[D]], P = x0[D], S = M, M = B, B = g, g += o << P | o >>> 32 - P;
    e.h0 = e.h0 + S | 0, e.h1 = e.h1 + g | 0, e.h2 = e.h2 + B | 0, e.h3 = e.h3 + M | 0, Z -= 64;
  }
}
var Ls = ht, b2 = Ls.pem = Ls.pem || {};
b2.encode = function(e, t) {
  t = t || {};
  var h = "-----BEGIN " + e.type + `-----\r
`, o;
  if (e.procType && (o = {
    name: "Proc-Type",
    values: [String(e.procType.version), e.procType.type]
  }, h += as(o)), e.contentDomain && (o = { name: "Content-Domain", values: [e.contentDomain] }, h += as(o)), e.dekInfo && (o = { name: "DEK-Info", values: [e.dekInfo.algorithm] }, e.dekInfo.parameters && o.values.push(e.dekInfo.parameters), h += as(o)), e.headers)
    for (var S = 0; S < e.headers.length; ++S)
      h += as(e.headers[S]);
  return e.procType && (h += `\r
`), h += Ls.util.encode64(e.body, t.maxline || 64) + `\r
`, h += "-----END " + e.type + `-----\r
`, h;
};
b2.decode = function(e) {
  for (var t = [], h = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g, o = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/, S = /\r?\n/, g; g = h.exec(e), !!g; ) {
    var B = g[1];
    B === "NEW CERTIFICATE REQUEST" && (B = "CERTIFICATE REQUEST");
    var M = {
      type: B,
      procType: null,
      contentDomain: null,
      dekInfo: null,
      headers: [],
      body: Ls.util.decode64(g[3])
    };
    if (t.push(M), !!g[2]) {
      for (var O = g[2].split(S), P = 0; g && P < O.length; ) {
        for (var D = O[P].replace(/\s+$/, ""), Z = P + 1; Z < O.length; ++Z) {
          var Y = O[Z];
          if (!/\s/.test(Y[0]))
            break;
          D += Y, P = Z;
        }
        if (g = D.match(o), g) {
          for (var ee = { name: g[1], values: [] }, ie = g[2].split(","), ue = 0; ue < ie.length; ++ue)
            ee.values.push(YC(ie[ue]));
          if (M.procType)
            if (!M.contentDomain && ee.name === "Content-Domain")
              M.contentDomain = ie[0] || "";
            else if (!M.dekInfo && ee.name === "DEK-Info") {
              if (ee.values.length === 0)
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              M.dekInfo = { algorithm: ie[0], parameters: ie[1] || null };
            } else
              M.headers.push(ee);
          else {
            if (ee.name !== "Proc-Type")
              throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
            if (ee.values.length !== 2)
              throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
            M.procType = { version: ie[0], type: ie[1] };
          }
        }
        ++P;
      }
      if (M.procType === "ENCRYPTED" && !M.dekInfo)
        throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
    }
  }
  if (t.length === 0)
    throw new Error("Invalid PEM formatted message.");
  return t;
};
function as(e) {
  for (var t = e.name + ": ", h = [], o = function(O, P) {
    return " " + P;
  }, S = 0; S < e.values.length; ++S)
    h.push(e.values[S].replace(/^(\S+\r\n)/, o));
  t += h.join(",") + `\r
`;
  for (var g = 0, B = -1, S = 0; S < t.length; ++S, ++g)
    if (g > 65 && B !== -1) {
      var M = t[B];
      M === "," ? (++B, t = t.substr(0, B) + `\r
 ` + t.substr(B)) : t = t.substr(0, B) + `\r
` + M + t.substr(B + 1), g = S - B - 1, B = -1, ++S;
    } else
      (t[S] === " " || t[S] === "	" || t[S] === ",") && (B = S);
  return t;
}
function YC(e) {
  return e.replace(/^\s+/, "");
}
var qt = ht;
qt.des = qt.des || {};
qt.des.startEncrypting = function(e, t, h, o) {
  var S = Uf({
    key: e,
    output: h,
    decrypt: !1,
    mode: o || (t === null ? "ECB" : "CBC")
  });
  return S.start(t), S;
};
qt.des.createEncryptionCipher = function(e, t) {
  return Uf({
    key: e,
    output: null,
    decrypt: !1,
    mode: t
  });
};
qt.des.startDecrypting = function(e, t, h, o) {
  var S = Uf({
    key: e,
    output: h,
    decrypt: !0,
    mode: o || (t === null ? "ECB" : "CBC")
  });
  return S.start(t), S;
};
qt.des.createDecryptionCipher = function(e, t) {
  return Uf({
    key: e,
    output: null,
    decrypt: !0,
    mode: t
  });
};
qt.des.Algorithm = function(e, t) {
  var h = this;
  h.name = e, h.mode = new t({
    blockSize: 8,
    cipher: {
      encrypt: function(o, S) {
        return Pp(h._keys, o, S, !1);
      },
      decrypt: function(o, S) {
        return Pp(h._keys, o, S, !0);
      }
    }
  }), h._init = !1;
};
qt.des.Algorithm.prototype.initialize = function(e) {
  if (!this._init) {
    var t = qt.util.createBuffer(e.key);
    if (this.name.indexOf("3DES") === 0 && t.length() !== 24)
      throw new Error("Invalid Triple-DES key size: " + t.length() * 8);
    this._keys = nA(t), this._init = !0;
  }
};
Yi("DES-ECB", qt.cipher.modes.ecb);
Yi("DES-CBC", qt.cipher.modes.cbc);
Yi("DES-CFB", qt.cipher.modes.cfb);
Yi("DES-OFB", qt.cipher.modes.ofb);
Yi("DES-CTR", qt.cipher.modes.ctr);
Yi("3DES-ECB", qt.cipher.modes.ecb);
Yi("3DES-CBC", qt.cipher.modes.cbc);
Yi("3DES-CFB", qt.cipher.modes.cfb);
Yi("3DES-OFB", qt.cipher.modes.ofb);
Yi("3DES-CTR", qt.cipher.modes.ctr);
function Yi(e, t) {
  var h = function() {
    return new qt.des.Algorithm(e, t);
  };
  qt.cipher.registerAlgorithm(e, h);
}
var XC = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756], QC = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344], ZC = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584], JC = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928], eA = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080], tA = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312], rA = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154], iA = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
function nA(e) {
  for (var t = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], h = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], o = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], S = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], g = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], B = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], M = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], O = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], P = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], D = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], Z = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], Y = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], ee = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], ie = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261], ue = e.length() > 8 ? 3 : 1, fe = [], de = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0], ce = 0, be, ve = 0; ve < ue; ve++) {
    var Pe = e.getInt32(), Ue = e.getInt32();
    be = (Pe >>> 4 ^ Ue) & 252645135, Ue ^= be, Pe ^= be << 4, be = (Ue >>> -16 ^ Pe) & 65535, Pe ^= be, Ue ^= be << -16, be = (Pe >>> 2 ^ Ue) & 858993459, Ue ^= be, Pe ^= be << 2, be = (Ue >>> -16 ^ Pe) & 65535, Pe ^= be, Ue ^= be << -16, be = (Pe >>> 1 ^ Ue) & 1431655765, Ue ^= be, Pe ^= be << 1, be = (Ue >>> 8 ^ Pe) & 16711935, Pe ^= be, Ue ^= be << 8, be = (Pe >>> 1 ^ Ue) & 1431655765, Ue ^= be, Pe ^= be << 1, be = Pe << 8 | Ue >>> 20 & 240, Pe = Ue << 24 | Ue << 8 & 16711680 | Ue >>> 8 & 65280 | Ue >>> 24 & 240, Ue = be;
    for (var ze = 0; ze < de.length; ++ze) {
      de[ze] ? (Pe = Pe << 2 | Pe >>> 26, Ue = Ue << 2 | Ue >>> 26) : (Pe = Pe << 1 | Pe >>> 27, Ue = Ue << 1 | Ue >>> 27), Pe &= -15, Ue &= -15;
      var Le = t[Pe >>> 28] | h[Pe >>> 24 & 15] | o[Pe >>> 20 & 15] | S[Pe >>> 16 & 15] | g[Pe >>> 12 & 15] | B[Pe >>> 8 & 15] | M[Pe >>> 4 & 15], Ne = O[Ue >>> 28] | P[Ue >>> 24 & 15] | D[Ue >>> 20 & 15] | Z[Ue >>> 16 & 15] | Y[Ue >>> 12 & 15] | ee[Ue >>> 8 & 15] | ie[Ue >>> 4 & 15];
      be = (Ne >>> 16 ^ Le) & 65535, fe[ce++] = Le ^ be, fe[ce++] = Ne ^ be << 16;
    }
  }
  return fe;
}
function Pp(e, t, h, o) {
  var S = e.length === 32 ? 3 : 9, g;
  S === 3 ? g = o ? [30, -2, -2] : [0, 32, 2] : g = o ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
  var B, M = t[0], O = t[1];
  B = (M >>> 4 ^ O) & 252645135, O ^= B, M ^= B << 4, B = (M >>> 16 ^ O) & 65535, O ^= B, M ^= B << 16, B = (O >>> 2 ^ M) & 858993459, M ^= B, O ^= B << 2, B = (O >>> 8 ^ M) & 16711935, M ^= B, O ^= B << 8, B = (M >>> 1 ^ O) & 1431655765, O ^= B, M ^= B << 1, M = M << 1 | M >>> 31, O = O << 1 | O >>> 31;
  for (var P = 0; P < S; P += 3) {
    for (var D = g[P + 1], Z = g[P + 2], Y = g[P]; Y != D; Y += Z) {
      var ee = O ^ e[Y], ie = (O >>> 4 | O << 28) ^ e[Y + 1];
      B = M, M = O, O = B ^ (QC[ee >>> 24 & 63] | JC[ee >>> 16 & 63] | tA[ee >>> 8 & 63] | iA[ee & 63] | XC[ie >>> 24 & 63] | ZC[ie >>> 16 & 63] | eA[ie >>> 8 & 63] | rA[ie & 63]);
    }
    B = M, M = O, O = B;
  }
  M = M >>> 1 | M << 31, O = O >>> 1 | O << 31, B = (M >>> 1 ^ O) & 1431655765, O ^= B, M ^= B << 1, B = (O >>> 8 ^ M) & 16711935, M ^= B, O ^= B << 8, B = (O >>> 2 ^ M) & 858993459, M ^= B, O ^= B << 2, B = (M >>> 16 ^ O) & 65535, O ^= B, M ^= B << 16, B = (M >>> 4 ^ O) & 252645135, O ^= B, M ^= B << 4, h[0] = M, h[1] = O;
}
function Uf(e) {
  e = e || {};
  var t = (e.mode || "CBC").toUpperCase(), h = "DES-" + t, o;
  e.decrypt ? o = qt.cipher.createDecipher(h, e.key) : o = qt.cipher.createCipher(h, e.key);
  var S = o.start;
  return o.start = function(g, B) {
    var M = null;
    B instanceof qt.util.ByteBuffer && (M = B, B = {}), B = B || {}, B.output = M, B.iv = g, S.call(o, B);
  }, o;
}
var yr = ht, aA = yr.pkcs5 = yr.pkcs5 || {}, Qi;
yr.util.isNodejs && !yr.options.usePureJavaScript && (Qi = _r());
yr.pbkdf2 = aA.pbkdf2 = function(e, t, h, o, S, g) {
  if (typeof S == "function" && (g = S, S = null), yr.util.isNodejs && !yr.options.usePureJavaScript && Qi.pbkdf2 && (S === null || typeof S != "object") && (Qi.pbkdf2Sync.length > 4 || !S || S === "sha1"))
    return typeof S != "string" && (S = "sha1"), e = pe.Buffer.from(e, "binary"), t = pe.Buffer.from(t, "binary"), g ? Qi.pbkdf2Sync.length === 4 ? Qi.pbkdf2(e, t, h, o, function(be, ve) {
      if (be)
        return g(be);
      g(null, ve.toString("binary"));
    }) : Qi.pbkdf2(e, t, h, o, S, function(be, ve) {
      if (be)
        return g(be);
      g(null, ve.toString("binary"));
    }) : Qi.pbkdf2Sync.length === 4 ? Qi.pbkdf2Sync(e, t, h, o).toString("binary") : Qi.pbkdf2Sync(e, t, h, o, S).toString("binary");
  if ((typeof S > "u" || S === null) && (S = "sha1"), typeof S == "string") {
    if (!(S in yr.md.algorithms))
      throw new Error("Unknown hash algorithm: " + S);
    S = yr.md[S].create();
  }
  var B = S.digestLength;
  if (o > 4294967295 * B) {
    var M = new Error("Derived key is too long.");
    if (g)
      return g(M);
    throw M;
  }
  var O = Math.ceil(o / B), P = o - (O - 1) * B, D = yr.hmac.create();
  D.start(S, e);
  var Z = "", Y, ee, ie;
  if (!g) {
    for (var ue = 1; ue <= O; ++ue) {
      D.start(null, null), D.update(t), D.update(yr.util.int32ToBytes(ue)), Y = ie = D.digest().getBytes();
      for (var fe = 2; fe <= h; ++fe)
        D.start(null, null), D.update(ie), ee = D.digest().getBytes(), Y = yr.util.xorBytes(Y, ee, B), ie = ee;
      Z += ue < O ? Y : Y.substr(0, P);
    }
    return Z;
  }
  var ue = 1, fe;
  function de() {
    if (ue > O)
      return g(null, Z);
    D.start(null, null), D.update(t), D.update(yr.util.int32ToBytes(ue)), Y = ie = D.digest().getBytes(), fe = 2, ce();
  }
  function ce() {
    if (fe <= h)
      return D.start(null, null), D.update(ie), ee = D.digest().getBytes(), Y = yr.util.xorBytes(Y, ee, B), ie = ee, ++fe, yr.util.setImmediate(ce);
    Z += ue < O ? Y : Y.substr(0, P), ++ue, de();
  }
  de();
};
var ki = ht, x2 = ki.sha256 = ki.sha256 || {};
ki.md.sha256 = ki.md.algorithms.sha256 = x2;
x2.create = function() {
  _2 || sA();
  var e = null, t = ki.util.createBuffer(), h = new Array(64), o = {
    algorithm: "sha256",
    blockLength: 64,
    digestLength: 32,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  return o.start = function() {
    o.messageLength = 0, o.fullMessageLength = o.messageLength64 = [];
    for (var S = o.messageLengthSize / 4, g = 0; g < S; ++g)
      o.fullMessageLength.push(0);
    return t = ki.util.createBuffer(), e = {
      h0: 1779033703,
      h1: 3144134277,
      h2: 1013904242,
      h3: 2773480762,
      h4: 1359893119,
      h5: 2600822924,
      h6: 528734635,
      h7: 1541459225
    }, o;
  }, o.start(), o.update = function(S, g) {
    g === "utf8" && (S = ki.util.encodeUtf8(S));
    var B = S.length;
    o.messageLength += B, B = [B / 4294967296 >>> 0, B >>> 0];
    for (var M = o.fullMessageLength.length - 1; M >= 0; --M)
      o.fullMessageLength[M] += B[1], B[1] = B[0] + (o.fullMessageLength[M] / 4294967296 >>> 0), o.fullMessageLength[M] = o.fullMessageLength[M] >>> 0, B[0] = B[1] / 4294967296 >>> 0;
    return t.putBytes(S), Lp(e, h, t), (t.read > 2048 || t.length() === 0) && t.compact(), o;
  }, o.digest = function() {
    var S = ki.util.createBuffer();
    S.putBytes(t.bytes());
    var g = o.fullMessageLength[o.fullMessageLength.length - 1] + o.messageLengthSize, B = g & o.blockLength - 1;
    S.putBytes(_c.substr(0, o.blockLength - B));
    for (var M, O, P = o.fullMessageLength[0] * 8, D = 0; D < o.fullMessageLength.length - 1; ++D)
      M = o.fullMessageLength[D + 1] * 8, O = M / 4294967296 >>> 0, P += O, S.putInt32(P >>> 0), P = M >>> 0;
    S.putInt32(P);
    var Z = {
      h0: e.h0,
      h1: e.h1,
      h2: e.h2,
      h3: e.h3,
      h4: e.h4,
      h5: e.h5,
      h6: e.h6,
      h7: e.h7
    };
    Lp(Z, h, S);
    var Y = ki.util.createBuffer();
    return Y.putInt32(Z.h0), Y.putInt32(Z.h1), Y.putInt32(Z.h2), Y.putInt32(Z.h3), Y.putInt32(Z.h4), Y.putInt32(Z.h5), Y.putInt32(Z.h6), Y.putInt32(Z.h7), Y;
  }, o;
};
var _c = null, _2 = !1, E2 = null;
function sA() {
  _c = "", _c += ki.util.fillString("\0", 64), E2 = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], _2 = !0;
}
function Lp(e, t, h) {
  for (var o, S, g, B, M, O, P, D, Z, Y, ee, ie, ue, fe, de, ce = h.length(); ce >= 64; ) {
    for (P = 0; P < 16; ++P)
      t[P] = h.getInt32();
    for (; P < 64; ++P)
      o = t[P - 2], o = (o >>> 17 | o << 15) ^ (o >>> 19 | o << 13) ^ o >>> 10, S = t[P - 15], S = (S >>> 7 | S << 25) ^ (S >>> 18 | S << 14) ^ S >>> 3, t[P] = o + t[P - 7] + S + t[P - 16] | 0;
    for (D = e.h0, Z = e.h1, Y = e.h2, ee = e.h3, ie = e.h4, ue = e.h5, fe = e.h6, de = e.h7, P = 0; P < 64; ++P)
      B = (ie >>> 6 | ie << 26) ^ (ie >>> 11 | ie << 21) ^ (ie >>> 25 | ie << 7), M = fe ^ ie & (ue ^ fe), g = (D >>> 2 | D << 30) ^ (D >>> 13 | D << 19) ^ (D >>> 22 | D << 10), O = D & Z | Y & (D ^ Z), o = de + B + M + E2[P] + t[P], S = g + O, de = fe, fe = ue, ue = ie, ie = ee + o >>> 0, ee = Y, Y = Z, Z = D, D = o + S >>> 0;
    e.h0 = e.h0 + D | 0, e.h1 = e.h1 + Z | 0, e.h2 = e.h2 + Y | 0, e.h3 = e.h3 + ee | 0, e.h4 = e.h4 + ie | 0, e.h5 = e.h5 + ue | 0, e.h6 = e.h6 + fe | 0, e.h7 = e.h7 + de | 0, ce -= 64;
  }
}
var Di = ht, Ss = null;
Di.util.isNodejs && !Di.options.usePureJavaScript && !Ve.versions["node-webkit"] && (Ss = _r());
var fA = Di.prng = Di.prng || {};
fA.create = function(e) {
  for (var t = {
    plugin: e,
    key: null,
    seed: null,
    time: null,
    // number of reseeds so far
    reseeds: 0,
    // amount of data generated so far
    generated: 0,
    // no initial key bytes
    keyBytes: ""
  }, h = e.md, o = new Array(32), S = 0; S < 32; ++S)
    o[S] = h.create();
  t.pools = o, t.pool = 0, t.generate = function(P, D) {
    if (!D)
      return t.generateSync(P);
    var Z = t.plugin.cipher, Y = t.plugin.increment, ee = t.plugin.formatKey, ie = t.plugin.formatSeed, ue = Di.util.createBuffer();
    t.key = null, fe();
    function fe(de) {
      if (de)
        return D(de);
      if (ue.length() >= P)
        return D(null, ue.getBytes(P));
      if (t.generated > 1048575 && (t.key = null), t.key === null)
        return Di.util.nextTick(function() {
          g(fe);
        });
      var ce = Z(t.key, t.seed);
      t.generated += ce.length, ue.putBytes(ce), t.key = ee(Z(t.key, Y(t.seed))), t.seed = ie(Z(t.key, t.seed)), Di.util.setImmediate(fe);
    }
  }, t.generateSync = function(P) {
    var D = t.plugin.cipher, Z = t.plugin.increment, Y = t.plugin.formatKey, ee = t.plugin.formatSeed;
    t.key = null;
    for (var ie = Di.util.createBuffer(); ie.length() < P; ) {
      t.generated > 1048575 && (t.key = null), t.key === null && B();
      var ue = D(t.key, t.seed);
      t.generated += ue.length, ie.putBytes(ue), t.key = Y(D(t.key, Z(t.seed))), t.seed = ee(D(t.key, t.seed));
    }
    return ie.getBytes(P);
  };
  function g(P) {
    if (t.pools[0].messageLength >= 32)
      return M(), P();
    var D = 32 - t.pools[0].messageLength << 5;
    t.seedFile(D, function(Z, Y) {
      if (Z)
        return P(Z);
      t.collect(Y), M(), P();
    });
  }
  function B() {
    if (t.pools[0].messageLength >= 32)
      return M();
    var P = 32 - t.pools[0].messageLength << 5;
    t.collect(t.seedFileSync(P)), M();
  }
  function M() {
    t.reseeds = t.reseeds === 4294967295 ? 0 : t.reseeds + 1;
    var P = t.plugin.md.create();
    P.update(t.keyBytes);
    for (var D = 1, Z = 0; Z < 32; ++Z)
      t.reseeds % D === 0 && (P.update(t.pools[Z].digest().getBytes()), t.pools[Z].start()), D = D << 1;
    t.keyBytes = P.digest().getBytes(), P.start(), P.update(t.keyBytes);
    var Y = P.digest().getBytes();
    t.key = t.plugin.formatKey(t.keyBytes), t.seed = t.plugin.formatSeed(Y), t.generated = 0;
  }
  function O(P) {
    var D = null, Z = Di.util.globalScope, Y = Z.crypto || Z.msCrypto;
    Y && Y.getRandomValues && (D = function(Pe) {
      return Y.getRandomValues(Pe);
    });
    var ee = Di.util.createBuffer();
    if (D)
      for (; ee.length() < P; ) {
        var ie = Math.max(1, Math.min(P - ee.length(), 65536) / 4), ue = new Uint32Array(Math.floor(ie));
        try {
          D(ue);
          for (var fe = 0; fe < ue.length; ++fe)
            ee.putInt32(ue[fe]);
        } catch (Pe) {
          if (!(typeof QuotaExceededError < "u" && Pe instanceof QuotaExceededError))
            throw Pe;
        }
      }
    if (ee.length() < P)
      for (var de, ce, be, ve = Math.floor(Math.random() * 65536); ee.length() < P; ) {
        ce = 16807 * (ve & 65535), de = 16807 * (ve >> 16), ce += (de & 32767) << 16, ce += de >> 15, ce = (ce & 2147483647) + (ce >> 31), ve = ce & 4294967295;
        for (var fe = 0; fe < 3; ++fe)
          be = ve >>> (fe << 3), be ^= Math.floor(Math.random() * 256), ee.putByte(be & 255);
      }
    return ee.getBytes(P);
  }
  return Ss ? (t.seedFile = function(P, D) {
    Ss.randomBytes(P, function(Z, Y) {
      if (Z)
        return D(Z);
      D(null, Y.toString());
    });
  }, t.seedFileSync = function(P) {
    return Ss.randomBytes(P).toString();
  }) : (t.seedFile = function(P, D) {
    try {
      D(null, O(P));
    } catch (Z) {
      D(Z);
    }
  }, t.seedFileSync = O), t.collect = function(P) {
    for (var D = P.length, Z = 0; Z < D; ++Z)
      t.pools[t.pool].update(P.substr(Z, 1)), t.pool = t.pool === 31 ? 0 : t.pool + 1;
  }, t.collectInt = function(P, D) {
    for (var Z = "", Y = 0; Y < D; Y += 8)
      Z += String.fromCharCode(P >> Y & 255);
    t.collect(Z);
  }, t.registerWorker = function(P) {
    if (P === self)
      t.seedFile = function(Z, Y) {
        function ee(ie) {
          var ue = ie.data;
          ue.forge && ue.forge.prng && (self.removeEventListener("message", ee), Y(ue.forge.prng.err, ue.forge.prng.bytes));
        }
        self.addEventListener("message", ee), self.postMessage({ forge: { prng: { needed: Z } } });
      };
    else {
      var D = function(Z) {
        var Y = Z.data;
        Y.forge && Y.forge.prng && t.seedFile(Y.forge.prng.needed, function(ee, ie) {
          P.postMessage({ forge: { prng: { err: ee, bytes: ie } } });
        });
      };
      P.addEventListener("message", D);
    }
  }, t;
};
var Yt = ht;
(function() {
  if (Yt.random && Yt.random.getBytes) {
    Yt.random;
    return;
  }
  (function(e) {
    var t = {}, h = new Array(4), o = Yt.util.createBuffer();
    t.formatKey = function(Z) {
      var Y = Yt.util.createBuffer(Z);
      return Z = new Array(4), Z[0] = Y.getInt32(), Z[1] = Y.getInt32(), Z[2] = Y.getInt32(), Z[3] = Y.getInt32(), Yt.aes._expandKey(Z, !1);
    }, t.formatSeed = function(Z) {
      var Y = Yt.util.createBuffer(Z);
      return Z = new Array(4), Z[0] = Y.getInt32(), Z[1] = Y.getInt32(), Z[2] = Y.getInt32(), Z[3] = Y.getInt32(), Z;
    }, t.cipher = function(Z, Y) {
      return Yt.aes._updateBlock(Z, Y, h, !1), o.putInt32(h[0]), o.putInt32(h[1]), o.putInt32(h[2]), o.putInt32(h[3]), o.getBytes();
    }, t.increment = function(Z) {
      return ++Z[3], Z;
    }, t.md = Yt.md.sha256;
    function S() {
      var Z = Yt.prng.create(t);
      return Z.getBytes = function(Y, ee) {
        return Z.generate(Y, ee);
      }, Z.getBytesSync = function(Y) {
        return Z.generate(Y);
      }, Z;
    }
    var g = S(), B = null, M = Yt.util.globalScope, O = M.crypto || M.msCrypto;
    if (O && O.getRandomValues && (B = function(Z) {
      return O.getRandomValues(Z);
    }), Yt.options.usePureJavaScript || !Yt.util.isNodejs && !B) {
      if (g.collectInt(+/* @__PURE__ */ new Date(), 32), typeof navigator < "u") {
        var P = "";
        for (var D in navigator)
          try {
            typeof navigator[D] == "string" && (P += navigator[D]);
          } catch {
          }
        g.collect(P), P = null;
      }
      e && (e().mousemove(function(Z) {
        g.collectInt(Z.clientX, 16), g.collectInt(Z.clientY, 16);
      }), e().keypress(function(Z) {
        g.collectInt(Z.charCode, 8);
      }));
    }
    if (!Yt.random)
      Yt.random = g;
    else
      for (var D in g)
        Yt.random[D] = g[D];
    Yt.random.createInstance = S, Yt.random;
  })(typeof jQuery < "u" ? jQuery : null);
})();
var Ar = ht, Fu = [
  217,
  120,
  249,
  196,
  25,
  221,
  181,
  237,
  40,
  233,
  253,
  121,
  74,
  160,
  216,
  157,
  198,
  126,
  55,
  131,
  43,
  118,
  83,
  142,
  98,
  76,
  100,
  136,
  68,
  139,
  251,
  162,
  23,
  154,
  89,
  245,
  135,
  179,
  79,
  19,
  97,
  69,
  109,
  141,
  9,
  129,
  125,
  50,
  189,
  143,
  64,
  235,
  134,
  183,
  123,
  11,
  240,
  149,
  33,
  34,
  92,
  107,
  78,
  130,
  84,
  214,
  101,
  147,
  206,
  96,
  178,
  28,
  115,
  86,
  192,
  20,
  167,
  140,
  241,
  220,
  18,
  117,
  202,
  31,
  59,
  190,
  228,
  209,
  66,
  61,
  212,
  48,
  163,
  60,
  182,
  38,
  111,
  191,
  14,
  218,
  70,
  105,
  7,
  87,
  39,
  242,
  29,
  155,
  188,
  148,
  67,
  3,
  248,
  17,
  199,
  246,
  144,
  239,
  62,
  231,
  6,
  195,
  213,
  47,
  200,
  102,
  30,
  215,
  8,
  232,
  234,
  222,
  128,
  82,
  238,
  247,
  132,
  170,
  114,
  172,
  53,
  77,
  106,
  42,
  150,
  26,
  210,
  113,
  90,
  21,
  73,
  116,
  75,
  159,
  208,
  94,
  4,
  24,
  164,
  236,
  194,
  224,
  65,
  110,
  15,
  81,
  203,
  204,
  36,
  145,
  175,
  80,
  161,
  244,
  112,
  57,
  153,
  124,
  58,
  133,
  35,
  184,
  180,
  122,
  252,
  2,
  54,
  91,
  37,
  85,
  151,
  49,
  45,
  93,
  250,
  152,
  227,
  138,
  146,
  174,
  5,
  223,
  41,
  16,
  103,
  108,
  186,
  201,
  211,
  0,
  230,
  207,
  225,
  158,
  168,
  44,
  99,
  22,
  1,
  63,
  88,
  226,
  137,
  169,
  13,
  56,
  52,
  27,
  171,
  51,
  255,
  176,
  187,
  72,
  12,
  95,
  185,
  177,
  205,
  46,
  197,
  243,
  219,
  71,
  229,
  165,
  156,
  119,
  10,
  166,
  32,
  104,
  254,
  127,
  193,
  173
], kp = [1, 2, 3, 5], oA = function(e, t) {
  return e << t & 65535 | (e & 65535) >> 16 - t;
}, uA = function(e, t) {
  return (e & 65535) >> t | e << 16 - t & 65535;
};
Ar.rc2 = Ar.rc2 || {};
Ar.rc2.expandKey = function(e, t) {
  typeof e == "string" && (e = Ar.util.createBuffer(e)), t = t || 128;
  var h = e, o = e.length(), S = t, g = Math.ceil(S / 8), B = 255 >> (S & 7), M;
  for (M = o; M < 128; M++)
    h.putByte(Fu[h.at(M - 1) + h.at(M - o) & 255]);
  for (h.setAt(128 - g, Fu[h.at(128 - g) & B]), M = 127 - g; M >= 0; M--)
    h.setAt(M, Fu[h.at(M + 1) ^ h.at(M + g)]);
  return h;
};
var S2 = function(e, t, h) {
  var o = !1, S = null, g = null, B = null, M, O, P, D, Z = [];
  for (e = Ar.rc2.expandKey(e, t), P = 0; P < 64; P++)
    Z.push(e.getInt16Le());
  h ? (M = function(ie) {
    for (P = 0; P < 4; P++)
      ie[P] += Z[D] + (ie[(P + 3) % 4] & ie[(P + 2) % 4]) + (~ie[(P + 3) % 4] & ie[(P + 1) % 4]), ie[P] = oA(ie[P], kp[P]), D++;
  }, O = function(ie) {
    for (P = 0; P < 4; P++)
      ie[P] += Z[ie[(P + 3) % 4] & 63];
  }) : (M = function(ie) {
    for (P = 3; P >= 0; P--)
      ie[P] = uA(ie[P], kp[P]), ie[P] -= Z[D] + (ie[(P + 3) % 4] & ie[(P + 2) % 4]) + (~ie[(P + 3) % 4] & ie[(P + 1) % 4]), D--;
  }, O = function(ie) {
    for (P = 3; P >= 0; P--)
      ie[P] -= Z[ie[(P + 3) % 4] & 63];
  });
  var Y = function(ie) {
    var ue = [];
    for (P = 0; P < 4; P++) {
      var fe = S.getInt16Le();
      B !== null && (h ? fe ^= B.getInt16Le() : B.putInt16Le(fe)), ue.push(fe & 65535);
    }
    D = h ? 0 : 63;
    for (var de = 0; de < ie.length; de++)
      for (var ce = 0; ce < ie[de][0]; ce++)
        ie[de][1](ue);
    for (P = 0; P < 4; P++)
      B !== null && (h ? B.putInt16Le(ue[P]) : ue[P] ^= B.getInt16Le()), g.putInt16Le(ue[P]);
  }, ee = null;
  return ee = {
    /**
     * Starts or restarts the encryption or decryption process, whichever
     * was previously configured.
     *
     * To use the cipher in CBC mode, iv may be given either as a string
     * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
     *
     * @param iv the initialization vector to use, null for ECB mode.
     * @param output the output the buffer to write to, null to create one.
     */
    start: function(ie, ue) {
      ie && typeof ie == "string" && (ie = Ar.util.createBuffer(ie)), o = !1, S = Ar.util.createBuffer(), g = ue || new Ar.util.createBuffer(), B = ie, ee.output = g;
    },
    /**
     * Updates the next block.
     *
     * @param input the buffer to read from.
     */
    update: function(ie) {
      for (o || S.putBuffer(ie); S.length() >= 8; )
        Y([
          [5, M],
          [1, O],
          [6, M],
          [1, O],
          [5, M]
        ]);
    },
    /**
     * Finishes encrypting or decrypting.
     *
     * @param pad a padding function to use, null for PKCS#7 padding,
     *           signature(blockSize, buffer, decrypt).
     *
     * @return true if successful, false on error.
     */
    finish: function(ie) {
      var ue = !0;
      if (h)
        if (ie)
          ue = ie(8, S, !h);
        else {
          var fe = S.length() === 8 ? 8 : 8 - S.length();
          S.fillWithByte(fe, fe);
        }
      if (ue && (o = !0, ee.update()), !h && (ue = S.length() === 0, ue))
        if (ie)
          ue = ie(8, g, !h);
        else {
          var de = g.length(), ce = g.at(de - 1);
          ce > de ? ue = !1 : g.truncate(ce);
        }
      return ue;
    }
  }, ee;
};
Ar.rc2.startEncrypting = function(e, t, h) {
  var o = Ar.rc2.createEncryptionCipher(e, 128);
  return o.start(t, h), o;
};
Ar.rc2.createEncryptionCipher = function(e, t) {
  return S2(e, t, !0);
};
Ar.rc2.startDecrypting = function(e, t, h) {
  var o = Ar.rc2.createDecryptionCipher(e, 128);
  return o.start(t, h), o;
};
Ar.rc2.createDecryptionCipher = function(e, t) {
  return S2(e, t, !1);
};
var Ec = ht;
Ec.jsbn = Ec.jsbn || {};
var rn;
function _e(e, t, h) {
  this.data = [], e != null && (typeof e == "number" ? this.fromNumber(e, t, h) : t == null && typeof e != "string" ? this.fromString(e, 256) : this.fromString(e, t));
}
Ec.jsbn.BigInteger = _e;
function Et() {
  return new _e(null);
}
function cA(e, t, h, o, S, g) {
  for (; --g >= 0; ) {
    var B = t * this.data[e++] + h.data[o] + S;
    S = Math.floor(B / 67108864), h.data[o++] = B & 67108863;
  }
  return S;
}
function hA(e, t, h, o, S, g) {
  for (var B = t & 32767, M = t >> 15; --g >= 0; ) {
    var O = this.data[e] & 32767, P = this.data[e++] >> 15, D = M * O + P * B;
    O = B * O + ((D & 32767) << 15) + h.data[o] + (S & 1073741823), S = (O >>> 30) + (D >>> 15) + M * P + (S >>> 30), h.data[o++] = O & 1073741823;
  }
  return S;
}
function Up(e, t, h, o, S, g) {
  for (var B = t & 16383, M = t >> 14; --g >= 0; ) {
    var O = this.data[e] & 16383, P = this.data[e++] >> 14, D = M * O + P * B;
    O = B * O + ((D & 16383) << 14) + h.data[o] + S, S = (O >> 28) + (D >> 14) + M * P, h.data[o++] = O & 268435455;
  }
  return S;
}
typeof navigator > "u" ? (_e.prototype.am = Up, rn = 28) : navigator.appName == "Microsoft Internet Explorer" ? (_e.prototype.am = hA, rn = 30) : navigator.appName != "Netscape" ? (_e.prototype.am = cA, rn = 26) : (_e.prototype.am = Up, rn = 28);
_e.prototype.DB = rn;
_e.prototype.DM = (1 << rn) - 1;
_e.prototype.DV = 1 << rn;
var qh = 52;
_e.prototype.FV = Math.pow(2, qh);
_e.prototype.F1 = qh - rn;
_e.prototype.F2 = 2 * rn - qh;
var lA = "0123456789abcdefghijklmnopqrstuvwxyz", Ff = new Array(), e0, $r;
e0 = 48;
for ($r = 0; $r <= 9; ++$r)
  Ff[e0++] = $r;
e0 = 97;
for ($r = 10; $r < 36; ++$r)
  Ff[e0++] = $r;
e0 = 65;
for ($r = 10; $r < 36; ++$r)
  Ff[e0++] = $r;
function Fp(e) {
  return lA.charAt(e);
}
function w2(e, t) {
  var h = Ff[e.charCodeAt(t)];
  return h ?? -1;
}
function dA(e) {
  for (var t = this.t - 1; t >= 0; --t)
    e.data[t] = this.data[t];
  e.t = this.t, e.s = this.s;
}
function pA(e) {
  this.t = 1, this.s = e < 0 ? -1 : 0, e > 0 ? this.data[0] = e : e < -1 ? this.data[0] = e + this.DV : this.t = 0;
}
function bn(e) {
  var t = Et();
  return t.fromInt(e), t;
}
function vA(e, t) {
  var h;
  if (t == 16)
    h = 4;
  else if (t == 8)
    h = 3;
  else if (t == 256)
    h = 8;
  else if (t == 2)
    h = 1;
  else if (t == 32)
    h = 5;
  else if (t == 4)
    h = 2;
  else {
    this.fromRadix(e, t);
    return;
  }
  this.t = 0, this.s = 0;
  for (var o = e.length, S = !1, g = 0; --o >= 0; ) {
    var B = h == 8 ? e[o] & 255 : w2(e, o);
    if (B < 0) {
      e.charAt(o) == "-" && (S = !0);
      continue;
    }
    S = !1, g == 0 ? this.data[this.t++] = B : g + h > this.DB ? (this.data[this.t - 1] |= (B & (1 << this.DB - g) - 1) << g, this.data[this.t++] = B >> this.DB - g) : this.data[this.t - 1] |= B << g, g += h, g >= this.DB && (g -= this.DB);
  }
  h == 8 && e[0] & 128 && (this.s = -1, g > 0 && (this.data[this.t - 1] |= (1 << this.DB - g) - 1 << g)), this.clamp(), S && _e.ZERO.subTo(this, this);
}
function yA() {
  for (var e = this.s & this.DM; this.t > 0 && this.data[this.t - 1] == e; )
    --this.t;
}
function gA(e) {
  if (this.s < 0)
    return "-" + this.negate().toString(e);
  var t;
  if (e == 16)
    t = 4;
  else if (e == 8)
    t = 3;
  else if (e == 2)
    t = 1;
  else if (e == 32)
    t = 5;
  else if (e == 4)
    t = 2;
  else
    return this.toRadix(e);
  var h = (1 << t) - 1, o, S = !1, g = "", B = this.t, M = this.DB - B * this.DB % t;
  if (B-- > 0)
    for (M < this.DB && (o = this.data[B] >> M) > 0 && (S = !0, g = Fp(o)); B >= 0; )
      M < t ? (o = (this.data[B] & (1 << M) - 1) << t - M, o |= this.data[--B] >> (M += this.DB - t)) : (o = this.data[B] >> (M -= t) & h, M <= 0 && (M += this.DB, --B)), o > 0 && (S = !0), S && (g += Fp(o));
  return S ? g : "0";
}
function mA() {
  var e = Et();
  return _e.ZERO.subTo(this, e), e;
}
function bA() {
  return this.s < 0 ? this.negate() : this;
}
function xA(e) {
  var t = this.s - e.s;
  if (t != 0)
    return t;
  var h = this.t;
  if (t = h - e.t, t != 0)
    return this.s < 0 ? -t : t;
  for (; --h >= 0; )
    if ((t = this.data[h] - e.data[h]) != 0)
      return t;
  return 0;
}
function qf(e) {
  var t = 1, h;
  return (h = e >>> 16) != 0 && (e = h, t += 16), (h = e >> 8) != 0 && (e = h, t += 8), (h = e >> 4) != 0 && (e = h, t += 4), (h = e >> 2) != 0 && (e = h, t += 2), (h = e >> 1) != 0 && (e = h, t += 1), t;
}
function _A() {
  return this.t <= 0 ? 0 : this.DB * (this.t - 1) + qf(this.data[this.t - 1] ^ this.s & this.DM);
}
function EA(e, t) {
  var h;
  for (h = this.t - 1; h >= 0; --h)
    t.data[h + e] = this.data[h];
  for (h = e - 1; h >= 0; --h)
    t.data[h] = 0;
  t.t = this.t + e, t.s = this.s;
}
function SA(e, t) {
  for (var h = e; h < this.t; ++h)
    t.data[h - e] = this.data[h];
  t.t = Math.max(this.t - e, 0), t.s = this.s;
}
function wA(e, t) {
  var h = e % this.DB, o = this.DB - h, S = (1 << o) - 1, g = Math.floor(e / this.DB), B = this.s << h & this.DM, M;
  for (M = this.t - 1; M >= 0; --M)
    t.data[M + g + 1] = this.data[M] >> o | B, B = (this.data[M] & S) << h;
  for (M = g - 1; M >= 0; --M)
    t.data[M] = 0;
  t.data[g] = B, t.t = this.t + g + 1, t.s = this.s, t.clamp();
}
function CA(e, t) {
  t.s = this.s;
  var h = Math.floor(e / this.DB);
  if (h >= this.t) {
    t.t = 0;
    return;
  }
  var o = e % this.DB, S = this.DB - o, g = (1 << o) - 1;
  t.data[0] = this.data[h] >> o;
  for (var B = h + 1; B < this.t; ++B)
    t.data[B - h - 1] |= (this.data[B] & g) << S, t.data[B - h] = this.data[B] >> o;
  o > 0 && (t.data[this.t - h - 1] |= (this.s & g) << S), t.t = this.t - h, t.clamp();
}
function AA(e, t) {
  for (var h = 0, o = 0, S = Math.min(e.t, this.t); h < S; )
    o += this.data[h] - e.data[h], t.data[h++] = o & this.DM, o >>= this.DB;
  if (e.t < this.t) {
    for (o -= e.s; h < this.t; )
      o += this.data[h], t.data[h++] = o & this.DM, o >>= this.DB;
    o += this.s;
  } else {
    for (o += this.s; h < e.t; )
      o -= e.data[h], t.data[h++] = o & this.DM, o >>= this.DB;
    o -= e.s;
  }
  t.s = o < 0 ? -1 : 0, o < -1 ? t.data[h++] = this.DV + o : o > 0 && (t.data[h++] = o), t.t = h, t.clamp();
}
function BA(e, t) {
  var h = this.abs(), o = e.abs(), S = h.t;
  for (t.t = S + o.t; --S >= 0; )
    t.data[S] = 0;
  for (S = 0; S < o.t; ++S)
    t.data[S + h.t] = h.am(0, o.data[S], t, S, 0, h.t);
  t.s = 0, t.clamp(), this.s != e.s && _e.ZERO.subTo(t, t);
}
function IA(e) {
  for (var t = this.abs(), h = e.t = 2 * t.t; --h >= 0; )
    e.data[h] = 0;
  for (h = 0; h < t.t - 1; ++h) {
    var o = t.am(h, t.data[h], e, 2 * h, 0, 1);
    (e.data[h + t.t] += t.am(h + 1, 2 * t.data[h], e, 2 * h + 1, o, t.t - h - 1)) >= t.DV && (e.data[h + t.t] -= t.DV, e.data[h + t.t + 1] = 1);
  }
  e.t > 0 && (e.data[e.t - 1] += t.am(h, t.data[h], e, 2 * h, 0, 1)), e.s = 0, e.clamp();
}
function TA(e, t, h) {
  var o = e.abs();
  if (!(o.t <= 0)) {
    var S = this.abs();
    if (S.t < o.t) {
      t != null && t.fromInt(0), h != null && this.copyTo(h);
      return;
    }
    h == null && (h = Et());
    var g = Et(), B = this.s, M = e.s, O = this.DB - qf(o.data[o.t - 1]);
    O > 0 ? (o.lShiftTo(O, g), S.lShiftTo(O, h)) : (o.copyTo(g), S.copyTo(h));
    var P = g.t, D = g.data[P - 1];
    if (D != 0) {
      var Z = D * (1 << this.F1) + (P > 1 ? g.data[P - 2] >> this.F2 : 0), Y = this.FV / Z, ee = (1 << this.F1) / Z, ie = 1 << this.F2, ue = h.t, fe = ue - P, de = t ?? Et();
      for (g.dlShiftTo(fe, de), h.compareTo(de) >= 0 && (h.data[h.t++] = 1, h.subTo(de, h)), _e.ONE.dlShiftTo(P, de), de.subTo(g, g); g.t < P; )
        g.data[g.t++] = 0;
      for (; --fe >= 0; ) {
        var ce = h.data[--ue] == D ? this.DM : Math.floor(h.data[ue] * Y + (h.data[ue - 1] + ie) * ee);
        if ((h.data[ue] += g.am(0, ce, h, fe, 0, P)) < ce)
          for (g.dlShiftTo(fe, de), h.subTo(de, h); h.data[ue] < --ce; )
            h.subTo(de, h);
      }
      t != null && (h.drShiftTo(P, t), B != M && _e.ZERO.subTo(t, t)), h.t = P, h.clamp(), O > 0 && h.rShiftTo(O, h), B < 0 && _e.ZERO.subTo(h, h);
    }
  }
}
function MA(e) {
  var t = Et();
  return this.abs().divRemTo(e, null, t), this.s < 0 && t.compareTo(_e.ZERO) > 0 && e.subTo(t, t), t;
}
function oa(e) {
  this.m = e;
}
function RA(e) {
  return e.s < 0 || e.compareTo(this.m) >= 0 ? e.mod(this.m) : e;
}
function NA(e) {
  return e;
}
function DA(e) {
  e.divRemTo(this.m, null, e);
}
function OA(e, t, h) {
  e.multiplyTo(t, h), this.reduce(h);
}
function PA(e, t) {
  e.squareTo(t), this.reduce(t);
}
oa.prototype.convert = RA;
oa.prototype.revert = NA;
oa.prototype.reduce = DA;
oa.prototype.mulTo = OA;
oa.prototype.sqrTo = PA;
function LA() {
  if (this.t < 1)
    return 0;
  var e = this.data[0];
  if (!(e & 1))
    return 0;
  var t = e & 3;
  return t = t * (2 - (e & 15) * t) & 15, t = t * (2 - (e & 255) * t) & 255, t = t * (2 - ((e & 65535) * t & 65535)) & 65535, t = t * (2 - e * t % this.DV) % this.DV, t > 0 ? this.DV - t : -t;
}
function ua(e) {
  this.m = e, this.mp = e.invDigit(), this.mpl = this.mp & 32767, this.mph = this.mp >> 15, this.um = (1 << e.DB - 15) - 1, this.mt2 = 2 * e.t;
}
function kA(e) {
  var t = Et();
  return e.abs().dlShiftTo(this.m.t, t), t.divRemTo(this.m, null, t), e.s < 0 && t.compareTo(_e.ZERO) > 0 && this.m.subTo(t, t), t;
}
function UA(e) {
  var t = Et();
  return e.copyTo(t), this.reduce(t), t;
}
function FA(e) {
  for (; e.t <= this.mt2; )
    e.data[e.t++] = 0;
  for (var t = 0; t < this.m.t; ++t) {
    var h = e.data[t] & 32767, o = h * this.mpl + ((h * this.mph + (e.data[t] >> 15) * this.mpl & this.um) << 15) & e.DM;
    for (h = t + this.m.t, e.data[h] += this.m.am(0, o, e, t, 0, this.m.t); e.data[h] >= e.DV; )
      e.data[h] -= e.DV, e.data[++h]++;
  }
  e.clamp(), e.drShiftTo(this.m.t, e), e.compareTo(this.m) >= 0 && e.subTo(this.m, e);
}
function qA(e, t) {
  e.squareTo(t), this.reduce(t);
}
function VA(e, t, h) {
  e.multiplyTo(t, h), this.reduce(h);
}
ua.prototype.convert = kA;
ua.prototype.revert = UA;
ua.prototype.reduce = FA;
ua.prototype.mulTo = VA;
ua.prototype.sqrTo = qA;
function KA() {
  return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
}
function $A(e, t) {
  if (e > 4294967295 || e < 1)
    return _e.ONE;
  var h = Et(), o = Et(), S = t.convert(this), g = qf(e) - 1;
  for (S.copyTo(h); --g >= 0; )
    if (t.sqrTo(h, o), (e & 1 << g) > 0)
      t.mulTo(o, S, h);
    else {
      var B = h;
      h = o, o = B;
    }
  return t.revert(h);
}
function HA(e, t) {
  var h;
  return e < 256 || t.isEven() ? h = new oa(t) : h = new ua(t), this.exp(e, h);
}
_e.prototype.copyTo = dA;
_e.prototype.fromInt = pA;
_e.prototype.fromString = vA;
_e.prototype.clamp = yA;
_e.prototype.dlShiftTo = EA;
_e.prototype.drShiftTo = SA;
_e.prototype.lShiftTo = wA;
_e.prototype.rShiftTo = CA;
_e.prototype.subTo = AA;
_e.prototype.multiplyTo = BA;
_e.prototype.squareTo = IA;
_e.prototype.divRemTo = TA;
_e.prototype.invDigit = LA;
_e.prototype.isEven = KA;
_e.prototype.exp = $A;
_e.prototype.toString = gA;
_e.prototype.negate = mA;
_e.prototype.abs = bA;
_e.prototype.compareTo = xA;
_e.prototype.bitLength = _A;
_e.prototype.mod = MA;
_e.prototype.modPowInt = HA;
_e.ZERO = bn(0);
_e.ONE = bn(1);
function GA() {
  var e = Et();
  return this.copyTo(e), e;
}
function zA() {
  if (this.s < 0) {
    if (this.t == 1)
      return this.data[0] - this.DV;
    if (this.t == 0)
      return -1;
  } else {
    if (this.t == 1)
      return this.data[0];
    if (this.t == 0)
      return 0;
  }
  return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
}
function jA() {
  return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
}
function WA() {
  return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
}
function YA(e) {
  return Math.floor(Math.LN2 * this.DB / Math.log(e));
}
function XA() {
  return this.s < 0 ? -1 : this.t <= 0 || this.t == 1 && this.data[0] <= 0 ? 0 : 1;
}
function QA(e) {
  if (e == null && (e = 10), this.signum() == 0 || e < 2 || e > 36)
    return "0";
  var t = this.chunkSize(e), h = Math.pow(e, t), o = bn(h), S = Et(), g = Et(), B = "";
  for (this.divRemTo(o, S, g); S.signum() > 0; )
    B = (h + g.intValue()).toString(e).substr(1) + B, S.divRemTo(o, S, g);
  return g.intValue().toString(e) + B;
}
function ZA(e, t) {
  this.fromInt(0), t == null && (t = 10);
  for (var h = this.chunkSize(t), o = Math.pow(t, h), S = !1, g = 0, B = 0, M = 0; M < e.length; ++M) {
    var O = w2(e, M);
    if (O < 0) {
      e.charAt(M) == "-" && this.signum() == 0 && (S = !0);
      continue;
    }
    B = t * B + O, ++g >= h && (this.dMultiply(o), this.dAddOffset(B, 0), g = 0, B = 0);
  }
  g > 0 && (this.dMultiply(Math.pow(t, g)), this.dAddOffset(B, 0)), S && _e.ZERO.subTo(this, this);
}
function JA(e, t, h) {
  if (typeof t == "number")
    if (e < 2)
      this.fromInt(1);
    else
      for (this.fromNumber(e, h), this.testBit(e - 1) || this.bitwiseTo(_e.ONE.shiftLeft(e - 1), Vh, this), this.isEven() && this.dAddOffset(1, 0); !this.isProbablePrime(t); )
        this.dAddOffset(2, 0), this.bitLength() > e && this.subTo(_e.ONE.shiftLeft(e - 1), this);
  else {
    var o = new Array(), S = e & 7;
    o.length = (e >> 3) + 1, t.nextBytes(o), S > 0 ? o[0] &= (1 << S) - 1 : o[0] = 0, this.fromString(o, 256);
  }
}
function eB() {
  var e = this.t, t = new Array();
  t[0] = this.s;
  var h = this.DB - e * this.DB % 8, o, S = 0;
  if (e-- > 0)
    for (h < this.DB && (o = this.data[e] >> h) != (this.s & this.DM) >> h && (t[S++] = o | this.s << this.DB - h); e >= 0; )
      h < 8 ? (o = (this.data[e] & (1 << h) - 1) << 8 - h, o |= this.data[--e] >> (h += this.DB - 8)) : (o = this.data[e] >> (h -= 8) & 255, h <= 0 && (h += this.DB, --e)), o & 128 && (o |= -256), S == 0 && (this.s & 128) != (o & 128) && ++S, (S > 0 || o != this.s) && (t[S++] = o);
  return t;
}
function tB(e) {
  return this.compareTo(e) == 0;
}
function rB(e) {
  return this.compareTo(e) < 0 ? this : e;
}
function iB(e) {
  return this.compareTo(e) > 0 ? this : e;
}
function nB(e, t, h) {
  var o, S, g = Math.min(e.t, this.t);
  for (o = 0; o < g; ++o)
    h.data[o] = t(this.data[o], e.data[o]);
  if (e.t < this.t) {
    for (S = e.s & this.DM, o = g; o < this.t; ++o)
      h.data[o] = t(this.data[o], S);
    h.t = this.t;
  } else {
    for (S = this.s & this.DM, o = g; o < e.t; ++o)
      h.data[o] = t(S, e.data[o]);
    h.t = e.t;
  }
  h.s = t(this.s, e.s), h.clamp();
}
function aB(e, t) {
  return e & t;
}
function sB(e) {
  var t = Et();
  return this.bitwiseTo(e, aB, t), t;
}
function Vh(e, t) {
  return e | t;
}
function fB(e) {
  var t = Et();
  return this.bitwiseTo(e, Vh, t), t;
}
function C2(e, t) {
  return e ^ t;
}
function oB(e) {
  var t = Et();
  return this.bitwiseTo(e, C2, t), t;
}
function A2(e, t) {
  return e & ~t;
}
function uB(e) {
  var t = Et();
  return this.bitwiseTo(e, A2, t), t;
}
function cB() {
  for (var e = Et(), t = 0; t < this.t; ++t)
    e.data[t] = this.DM & ~this.data[t];
  return e.t = this.t, e.s = ~this.s, e;
}
function hB(e) {
  var t = Et();
  return e < 0 ? this.rShiftTo(-e, t) : this.lShiftTo(e, t), t;
}
function lB(e) {
  var t = Et();
  return e < 0 ? this.lShiftTo(-e, t) : this.rShiftTo(e, t), t;
}
function dB(e) {
  if (e == 0)
    return -1;
  var t = 0;
  return e & 65535 || (e >>= 16, t += 16), e & 255 || (e >>= 8, t += 8), e & 15 || (e >>= 4, t += 4), e & 3 || (e >>= 2, t += 2), e & 1 || ++t, t;
}
function pB() {
  for (var e = 0; e < this.t; ++e)
    if (this.data[e] != 0)
      return e * this.DB + dB(this.data[e]);
  return this.s < 0 ? this.t * this.DB : -1;
}
function vB(e) {
  for (var t = 0; e != 0; )
    e &= e - 1, ++t;
  return t;
}
function yB() {
  for (var e = 0, t = this.s & this.DM, h = 0; h < this.t; ++h)
    e += vB(this.data[h] ^ t);
  return e;
}
function gB(e) {
  var t = Math.floor(e / this.DB);
  return t >= this.t ? this.s != 0 : (this.data[t] & 1 << e % this.DB) != 0;
}
function mB(e, t) {
  var h = _e.ONE.shiftLeft(e);
  return this.bitwiseTo(h, t, h), h;
}
function bB(e) {
  return this.changeBit(e, Vh);
}
function xB(e) {
  return this.changeBit(e, A2);
}
function _B(e) {
  return this.changeBit(e, C2);
}
function EB(e, t) {
  for (var h = 0, o = 0, S = Math.min(e.t, this.t); h < S; )
    o += this.data[h] + e.data[h], t.data[h++] = o & this.DM, o >>= this.DB;
  if (e.t < this.t) {
    for (o += e.s; h < this.t; )
      o += this.data[h], t.data[h++] = o & this.DM, o >>= this.DB;
    o += this.s;
  } else {
    for (o += this.s; h < e.t; )
      o += e.data[h], t.data[h++] = o & this.DM, o >>= this.DB;
    o += e.s;
  }
  t.s = o < 0 ? -1 : 0, o > 0 ? t.data[h++] = o : o < -1 && (t.data[h++] = this.DV + o), t.t = h, t.clamp();
}
function SB(e) {
  var t = Et();
  return this.addTo(e, t), t;
}
function wB(e) {
  var t = Et();
  return this.subTo(e, t), t;
}
function CB(e) {
  var t = Et();
  return this.multiplyTo(e, t), t;
}
function AB(e) {
  var t = Et();
  return this.divRemTo(e, t, null), t;
}
function BB(e) {
  var t = Et();
  return this.divRemTo(e, null, t), t;
}
function IB(e) {
  var t = Et(), h = Et();
  return this.divRemTo(e, t, h), new Array(t, h);
}
function TB(e) {
  this.data[this.t] = this.am(0, e - 1, this, 0, 0, this.t), ++this.t, this.clamp();
}
function MB(e, t) {
  if (e != 0) {
    for (; this.t <= t; )
      this.data[this.t++] = 0;
    for (this.data[t] += e; this.data[t] >= this.DV; )
      this.data[t] -= this.DV, ++t >= this.t && (this.data[this.t++] = 0), ++this.data[t];
  }
}
function W0() {
}
function B2(e) {
  return e;
}
function RB(e, t, h) {
  e.multiplyTo(t, h);
}
function NB(e, t) {
  e.squareTo(t);
}
W0.prototype.convert = B2;
W0.prototype.revert = B2;
W0.prototype.mulTo = RB;
W0.prototype.sqrTo = NB;
function DB(e) {
  return this.exp(e, new W0());
}
function OB(e, t, h) {
  var o = Math.min(this.t + e.t, t);
  for (h.s = 0, h.t = o; o > 0; )
    h.data[--o] = 0;
  var S;
  for (S = h.t - this.t; o < S; ++o)
    h.data[o + this.t] = this.am(0, e.data[o], h, o, 0, this.t);
  for (S = Math.min(e.t, t); o < S; ++o)
    this.am(0, e.data[o], h, o, 0, t - o);
  h.clamp();
}
function PB(e, t, h) {
  --t;
  var o = h.t = this.t + e.t - t;
  for (h.s = 0; --o >= 0; )
    h.data[o] = 0;
  for (o = Math.max(t - this.t, 0); o < e.t; ++o)
    h.data[this.t + o - t] = this.am(t - o, e.data[o], h, 0, 0, this.t + o - t);
  h.clamp(), h.drShiftTo(1, h);
}
function t0(e) {
  this.r2 = Et(), this.q3 = Et(), _e.ONE.dlShiftTo(2 * e.t, this.r2), this.mu = this.r2.divide(e), this.m = e;
}
function LB(e) {
  if (e.s < 0 || e.t > 2 * this.m.t)
    return e.mod(this.m);
  if (e.compareTo(this.m) < 0)
    return e;
  var t = Et();
  return e.copyTo(t), this.reduce(t), t;
}
function kB(e) {
  return e;
}
function UB(e) {
  for (e.drShiftTo(this.m.t - 1, this.r2), e.t > this.m.t + 1 && (e.t = this.m.t + 1, e.clamp()), this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3), this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2); e.compareTo(this.r2) < 0; )
    e.dAddOffset(1, this.m.t + 1);
  for (e.subTo(this.r2, e); e.compareTo(this.m) >= 0; )
    e.subTo(this.m, e);
}
function FB(e, t) {
  e.squareTo(t), this.reduce(t);
}
function qB(e, t, h) {
  e.multiplyTo(t, h), this.reduce(h);
}
t0.prototype.convert = LB;
t0.prototype.revert = kB;
t0.prototype.reduce = UB;
t0.prototype.mulTo = qB;
t0.prototype.sqrTo = FB;
function VB(e, t) {
  var h = e.bitLength(), o, S = bn(1), g;
  if (h <= 0)
    return S;
  h < 18 ? o = 1 : h < 48 ? o = 3 : h < 144 ? o = 4 : h < 768 ? o = 5 : o = 6, h < 8 ? g = new oa(t) : t.isEven() ? g = new t0(t) : g = new ua(t);
  var B = new Array(), M = 3, O = o - 1, P = (1 << o) - 1;
  if (B[1] = g.convert(this), o > 1) {
    var D = Et();
    for (g.sqrTo(B[1], D); M <= P; )
      B[M] = Et(), g.mulTo(D, B[M - 2], B[M]), M += 2;
  }
  var Z = e.t - 1, Y, ee = !0, ie = Et(), ue;
  for (h = qf(e.data[Z]) - 1; Z >= 0; ) {
    for (h >= O ? Y = e.data[Z] >> h - O & P : (Y = (e.data[Z] & (1 << h + 1) - 1) << O - h, Z > 0 && (Y |= e.data[Z - 1] >> this.DB + h - O)), M = o; !(Y & 1); )
      Y >>= 1, --M;
    if ((h -= M) < 0 && (h += this.DB, --Z), ee)
      B[Y].copyTo(S), ee = !1;
    else {
      for (; M > 1; )
        g.sqrTo(S, ie), g.sqrTo(ie, S), M -= 2;
      M > 0 ? g.sqrTo(S, ie) : (ue = S, S = ie, ie = ue), g.mulTo(ie, B[Y], S);
    }
    for (; Z >= 0 && !(e.data[Z] & 1 << h); )
      g.sqrTo(S, ie), ue = S, S = ie, ie = ue, --h < 0 && (h = this.DB - 1, --Z);
  }
  return g.revert(S);
}
function KB(e) {
  var t = this.s < 0 ? this.negate() : this.clone(), h = e.s < 0 ? e.negate() : e.clone();
  if (t.compareTo(h) < 0) {
    var o = t;
    t = h, h = o;
  }
  var S = t.getLowestSetBit(), g = h.getLowestSetBit();
  if (g < 0)
    return t;
  for (S < g && (g = S), g > 0 && (t.rShiftTo(g, t), h.rShiftTo(g, h)); t.signum() > 0; )
    (S = t.getLowestSetBit()) > 0 && t.rShiftTo(S, t), (S = h.getLowestSetBit()) > 0 && h.rShiftTo(S, h), t.compareTo(h) >= 0 ? (t.subTo(h, t), t.rShiftTo(1, t)) : (h.subTo(t, h), h.rShiftTo(1, h));
  return g > 0 && h.lShiftTo(g, h), h;
}
function $B(e) {
  if (e <= 0)
    return 0;
  var t = this.DV % e, h = this.s < 0 ? e - 1 : 0;
  if (this.t > 0)
    if (t == 0)
      h = this.data[0] % e;
    else
      for (var o = this.t - 1; o >= 0; --o)
        h = (t * h + this.data[o]) % e;
  return h;
}
function HB(e) {
  var t = e.isEven();
  if (this.isEven() && t || e.signum() == 0)
    return _e.ZERO;
  for (var h = e.clone(), o = this.clone(), S = bn(1), g = bn(0), B = bn(0), M = bn(1); h.signum() != 0; ) {
    for (; h.isEven(); )
      h.rShiftTo(1, h), t ? ((!S.isEven() || !g.isEven()) && (S.addTo(this, S), g.subTo(e, g)), S.rShiftTo(1, S)) : g.isEven() || g.subTo(e, g), g.rShiftTo(1, g);
    for (; o.isEven(); )
      o.rShiftTo(1, o), t ? ((!B.isEven() || !M.isEven()) && (B.addTo(this, B), M.subTo(e, M)), B.rShiftTo(1, B)) : M.isEven() || M.subTo(e, M), M.rShiftTo(1, M);
    h.compareTo(o) >= 0 ? (h.subTo(o, h), t && S.subTo(B, S), g.subTo(M, g)) : (o.subTo(h, o), t && B.subTo(S, B), M.subTo(g, M));
  }
  if (o.compareTo(_e.ONE) != 0)
    return _e.ZERO;
  if (M.compareTo(e) >= 0)
    return M.subtract(e);
  if (M.signum() < 0)
    M.addTo(e, M);
  else
    return M;
  return M.signum() < 0 ? M.add(e) : M;
}
var xi = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509], GB = (1 << 26) / xi[xi.length - 1];
function zB(e) {
  var t, h = this.abs();
  if (h.t == 1 && h.data[0] <= xi[xi.length - 1]) {
    for (t = 0; t < xi.length; ++t)
      if (h.data[0] == xi[t])
        return !0;
    return !1;
  }
  if (h.isEven())
    return !1;
  for (t = 1; t < xi.length; ) {
    for (var o = xi[t], S = t + 1; S < xi.length && o < GB; )
      o *= xi[S++];
    for (o = h.modInt(o); t < S; )
      if (o % xi[t++] == 0)
        return !1;
  }
  return h.millerRabin(e);
}
function jB(e) {
  var t = this.subtract(_e.ONE), h = t.getLowestSetBit();
  if (h <= 0)
    return !1;
  for (var o = t.shiftRight(h), S = WB(), g, B = 0; B < e; ++B) {
    do
      g = new _e(this.bitLength(), S);
    while (g.compareTo(_e.ONE) <= 0 || g.compareTo(t) >= 0);
    var M = g.modPow(o, this);
    if (M.compareTo(_e.ONE) != 0 && M.compareTo(t) != 0) {
      for (var O = 1; O++ < h && M.compareTo(t) != 0; )
        if (M = M.modPowInt(2, this), M.compareTo(_e.ONE) == 0)
          return !1;
      if (M.compareTo(t) != 0)
        return !1;
    }
  }
  return !0;
}
function WB() {
  return {
    // x is an array to fill with bytes
    nextBytes: function(e) {
      for (var t = 0; t < e.length; ++t)
        e[t] = Math.floor(Math.random() * 256);
    }
  };
}
_e.prototype.chunkSize = YA;
_e.prototype.toRadix = QA;
_e.prototype.fromRadix = ZA;
_e.prototype.fromNumber = JA;
_e.prototype.bitwiseTo = nB;
_e.prototype.changeBit = mB;
_e.prototype.addTo = EB;
_e.prototype.dMultiply = TB;
_e.prototype.dAddOffset = MB;
_e.prototype.multiplyLowerTo = OB;
_e.prototype.multiplyUpperTo = PB;
_e.prototype.modInt = $B;
_e.prototype.millerRabin = jB;
_e.prototype.clone = GA;
_e.prototype.intValue = zA;
_e.prototype.byteValue = jA;
_e.prototype.shortValue = WA;
_e.prototype.signum = XA;
_e.prototype.toByteArray = eB;
_e.prototype.equals = tB;
_e.prototype.min = rB;
_e.prototype.max = iB;
_e.prototype.and = sB;
_e.prototype.or = fB;
_e.prototype.xor = oB;
_e.prototype.andNot = uB;
_e.prototype.not = cB;
_e.prototype.shiftLeft = hB;
_e.prototype.shiftRight = lB;
_e.prototype.getLowestSetBit = pB;
_e.prototype.bitCount = yB;
_e.prototype.testBit = gB;
_e.prototype.setBit = bB;
_e.prototype.clearBit = xB;
_e.prototype.flipBit = _B;
_e.prototype.add = SB;
_e.prototype.subtract = wB;
_e.prototype.multiply = CB;
_e.prototype.divide = AB;
_e.prototype.remainder = BB;
_e.prototype.divideAndRemainder = IB;
_e.prototype.modPow = VB;
_e.prototype.modInverse = HB;
_e.prototype.pow = DB;
_e.prototype.gcd = KB;
_e.prototype.isProbablePrime = zB;
var Ui = ht, I2 = Ui.sha1 = Ui.sha1 || {};
Ui.md.sha1 = Ui.md.algorithms.sha1 = I2;
I2.create = function() {
  T2 || YB();
  var e = null, t = Ui.util.createBuffer(), h = new Array(80), o = {
    algorithm: "sha1",
    blockLength: 64,
    digestLength: 20,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  return o.start = function() {
    o.messageLength = 0, o.fullMessageLength = o.messageLength64 = [];
    for (var S = o.messageLengthSize / 4, g = 0; g < S; ++g)
      o.fullMessageLength.push(0);
    return t = Ui.util.createBuffer(), e = {
      h0: 1732584193,
      h1: 4023233417,
      h2: 2562383102,
      h3: 271733878,
      h4: 3285377520
    }, o;
  }, o.start(), o.update = function(S, g) {
    g === "utf8" && (S = Ui.util.encodeUtf8(S));
    var B = S.length;
    o.messageLength += B, B = [B / 4294967296 >>> 0, B >>> 0];
    for (var M = o.fullMessageLength.length - 1; M >= 0; --M)
      o.fullMessageLength[M] += B[1], B[1] = B[0] + (o.fullMessageLength[M] / 4294967296 >>> 0), o.fullMessageLength[M] = o.fullMessageLength[M] >>> 0, B[0] = B[1] / 4294967296 >>> 0;
    return t.putBytes(S), qp(e, h, t), (t.read > 2048 || t.length() === 0) && t.compact(), o;
  }, o.digest = function() {
    var S = Ui.util.createBuffer();
    S.putBytes(t.bytes());
    var g = o.fullMessageLength[o.fullMessageLength.length - 1] + o.messageLengthSize, B = g & o.blockLength - 1;
    S.putBytes(Sc.substr(0, o.blockLength - B));
    for (var M, O, P = o.fullMessageLength[0] * 8, D = 0; D < o.fullMessageLength.length - 1; ++D)
      M = o.fullMessageLength[D + 1] * 8, O = M / 4294967296 >>> 0, P += O, S.putInt32(P >>> 0), P = M >>> 0;
    S.putInt32(P);
    var Z = {
      h0: e.h0,
      h1: e.h1,
      h2: e.h2,
      h3: e.h3,
      h4: e.h4
    };
    qp(Z, h, S);
    var Y = Ui.util.createBuffer();
    return Y.putInt32(Z.h0), Y.putInt32(Z.h1), Y.putInt32(Z.h2), Y.putInt32(Z.h3), Y.putInt32(Z.h4), Y;
  }, o;
};
var Sc = null, T2 = !1;
function YB() {
  Sc = "", Sc += Ui.util.fillString("\0", 64), T2 = !0;
}
function qp(e, t, h) {
  for (var o, S, g, B, M, O, P, D, Z = h.length(); Z >= 64; ) {
    for (S = e.h0, g = e.h1, B = e.h2, M = e.h3, O = e.h4, D = 0; D < 16; ++D)
      o = h.getInt32(), t[D] = o, P = M ^ g & (B ^ M), o = (S << 5 | S >>> 27) + P + O + 1518500249 + o, O = M, M = B, B = (g << 30 | g >>> 2) >>> 0, g = S, S = o;
    for (; D < 20; ++D)
      o = t[D - 3] ^ t[D - 8] ^ t[D - 14] ^ t[D - 16], o = o << 1 | o >>> 31, t[D] = o, P = M ^ g & (B ^ M), o = (S << 5 | S >>> 27) + P + O + 1518500249 + o, O = M, M = B, B = (g << 30 | g >>> 2) >>> 0, g = S, S = o;
    for (; D < 32; ++D)
      o = t[D - 3] ^ t[D - 8] ^ t[D - 14] ^ t[D - 16], o = o << 1 | o >>> 31, t[D] = o, P = g ^ B ^ M, o = (S << 5 | S >>> 27) + P + O + 1859775393 + o, O = M, M = B, B = (g << 30 | g >>> 2) >>> 0, g = S, S = o;
    for (; D < 40; ++D)
      o = t[D - 6] ^ t[D - 16] ^ t[D - 28] ^ t[D - 32], o = o << 2 | o >>> 30, t[D] = o, P = g ^ B ^ M, o = (S << 5 | S >>> 27) + P + O + 1859775393 + o, O = M, M = B, B = (g << 30 | g >>> 2) >>> 0, g = S, S = o;
    for (; D < 60; ++D)
      o = t[D - 6] ^ t[D - 16] ^ t[D - 28] ^ t[D - 32], o = o << 2 | o >>> 30, t[D] = o, P = g & B | M & (g ^ B), o = (S << 5 | S >>> 27) + P + O + 2400959708 + o, O = M, M = B, B = (g << 30 | g >>> 2) >>> 0, g = S, S = o;
    for (; D < 80; ++D)
      o = t[D - 6] ^ t[D - 16] ^ t[D - 28] ^ t[D - 32], o = o << 2 | o >>> 30, t[D] = o, P = g ^ B ^ M, o = (S << 5 | S >>> 27) + P + O + 3395469782 + o, O = M, M = B, B = (g << 30 | g >>> 2) >>> 0, g = S, S = o;
    e.h0 = e.h0 + S | 0, e.h1 = e.h1 + g | 0, e.h2 = e.h2 + B | 0, e.h3 = e.h3 + M | 0, e.h4 = e.h4 + O | 0, Z -= 64;
  }
}
var Fi = ht, M2 = Fi.pkcs1 = Fi.pkcs1 || {};
M2.encode_rsa_oaep = function(e, t, h) {
  var o, S, g, B;
  typeof h == "string" ? (o = h, S = arguments[3] || void 0, g = arguments[4] || void 0) : h && (o = h.label || void 0, S = h.seed || void 0, g = h.md || void 0, h.mgf1 && h.mgf1.md && (B = h.mgf1.md)), g ? g.start() : g = Fi.md.sha1.create(), B || (B = g);
  var M = Math.ceil(e.n.bitLength() / 8), O = M - 2 * g.digestLength - 2;
  if (t.length > O) {
    var P = new Error("RSAES-OAEP input message length is too long.");
    throw P.length = t.length, P.maxLength = O, P;
  }
  o || (o = ""), g.update(o, "raw");
  for (var D = g.digest(), Z = "", Y = O - t.length, ee = 0; ee < Y; ee++)
    Z += "\0";
  var ie = D.getBytes() + Z + "" + t;
  if (!S)
    S = Fi.random.getBytes(g.digestLength);
  else if (S.length !== g.digestLength) {
    var P = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
    throw P.seedLength = S.length, P.digestLength = g.digestLength, P;
  }
  var ue = ks(S, M - g.digestLength - 1, B), fe = Fi.util.xorBytes(ie, ue, ie.length), de = ks(fe, g.digestLength, B), ce = Fi.util.xorBytes(S, de, S.length);
  return "\0" + ce + fe;
};
M2.decode_rsa_oaep = function(e, t, h) {
  var o, S, g;
  typeof h == "string" ? (o = h, S = arguments[3] || void 0) : h && (o = h.label || void 0, S = h.md || void 0, h.mgf1 && h.mgf1.md && (g = h.mgf1.md));
  var B = Math.ceil(e.n.bitLength() / 8);
  if (t.length !== B) {
    var M = new Error("RSAES-OAEP encoded message length is invalid.");
    throw M.length = t.length, M.expectedLength = B, M;
  }
  if (S === void 0 ? S = Fi.md.sha1.create() : S.start(), g || (g = S), B < 2 * S.digestLength + 2)
    throw new Error("RSAES-OAEP key is too short for the hash function.");
  o || (o = ""), S.update(o, "raw");
  for (var O = S.digest().getBytes(), P = t.charAt(0), D = t.substring(1, S.digestLength + 1), Z = t.substring(1 + S.digestLength), Y = ks(Z, S.digestLength, g), ee = Fi.util.xorBytes(D, Y, D.length), ie = ks(ee, B - S.digestLength - 1, g), ue = Fi.util.xorBytes(Z, ie, Z.length), fe = ue.substring(0, S.digestLength), M = P !== "\0", de = 0; de < S.digestLength; ++de)
    M |= O.charAt(de) !== fe.charAt(de);
  for (var ce = 1, be = S.digestLength, ve = S.digestLength; ve < ue.length; ve++) {
    var Pe = ue.charCodeAt(ve), Ue = Pe & 1 ^ 1, ze = ce ? 65534 : 0;
    M |= Pe & ze, ce = ce & Ue, be += ce;
  }
  if (M || ue.charCodeAt(be) !== 1)
    throw new Error("Invalid RSAES-OAEP padding.");
  return ue.substring(be + 1);
};
function ks(e, t, h) {
  h || (h = Fi.md.sha1.create());
  for (var o = "", S = Math.ceil(t / h.digestLength), g = 0; g < S; ++g) {
    var B = String.fromCharCode(
      g >> 24 & 255,
      g >> 16 & 255,
      g >> 8 & 255,
      g & 255
    );
    h.start(), h.update(e + B), o += h.digest().getBytes();
  }
  return o.substring(0, t);
}
var ln = ht;
(function() {
  if (ln.prime) {
    ln.prime;
    return;
  }
  var e = ln.prime = ln.prime || {}, t = ln.jsbn.BigInteger, h = [6, 4, 2, 4, 2, 4, 6, 2], o = new t(null);
  o.fromInt(30);
  var S = function(Z, Y) {
    return Z | Y;
  };
  e.generateProbablePrime = function(Z, Y, ee) {
    typeof Y == "function" && (ee = Y, Y = {}), Y = Y || {};
    var ie = Y.algorithm || "PRIMEINC";
    typeof ie == "string" && (ie = { name: ie }), ie.options = ie.options || {};
    var ue = Y.prng || ln.random, fe = {
      // x is an array to fill with bytes
      nextBytes: function(de) {
        for (var ce = ue.getBytesSync(de.length), be = 0; be < de.length; ++be)
          de[be] = ce.charCodeAt(be);
      }
    };
    if (ie.name === "PRIMEINC")
      return g(Z, fe, ie.options, ee);
    throw new Error("Invalid prime generation algorithm: " + ie.name);
  };
  function g(Z, Y, ee, ie) {
    return "workers" in ee ? O(Z, Y, ee, ie) : B(Z, Y, ee, ie);
  }
  function B(Z, Y, ee, ie) {
    var ue = P(Z, Y), fe = 0, de = D(ue.bitLength());
    "millerRabinTests" in ee && (de = ee.millerRabinTests);
    var ce = 10;
    "maxBlockTime" in ee && (ce = ee.maxBlockTime), M(ue, Z, Y, fe, de, ce, ie);
  }
  function M(Z, Y, ee, ie, ue, fe, de) {
    var ce = +/* @__PURE__ */ new Date();
    do {
      if (Z.bitLength() > Y && (Z = P(Y, ee)), Z.isProbablePrime(ue))
        return de(null, Z);
      Z.dAddOffset(h[ie++ % 8], 0);
    } while (fe < 0 || +/* @__PURE__ */ new Date() - ce < fe);
    ln.util.setImmediate(function() {
      M(Z, Y, ee, ie, ue, fe, de);
    });
  }
  function O(Z, Y, ee, ie) {
    if (typeof Worker > "u")
      return B(Z, Y, ee, ie);
    var ue = P(Z, Y), fe = ee.workers, de = ee.workLoad || 100, ce = de * 30 / 8, be = ee.workerScript || "forge/prime.worker.js";
    if (fe === -1)
      return ln.util.estimateCores(function(Pe, Ue) {
        Pe && (Ue = 2), fe = Ue - 1, ve();
      });
    ve();
    function ve() {
      fe = Math.max(1, fe);
      for (var Pe = [], Ue = 0; Ue < fe; ++Ue)
        Pe[Ue] = new Worker(be);
      for (var Ue = 0; Ue < fe; ++Ue)
        Pe[Ue].addEventListener("message", Le);
      var ze = !1;
      function Le(Ne) {
        if (!ze) {
          var $e = Ne.data;
          if ($e.found) {
            for (var J = 0; J < Pe.length; ++J)
              Pe[J].terminate();
            return ze = !0, ie(null, new t($e.prime, 16));
          }
          ue.bitLength() > Z && (ue = P(Z, Y));
          var ne = ue.toString(16);
          Ne.target.postMessage({
            hex: ne,
            workLoad: de
          }), ue.dAddOffset(ce, 0);
        }
      }
    }
  }
  function P(Z, Y) {
    var ee = new t(Z, Y), ie = Z - 1;
    return ee.testBit(ie) || ee.bitwiseTo(t.ONE.shiftLeft(ie), S, ee), ee.dAddOffset(31 - ee.mod(o).byteValue(), 0), ee;
  }
  function D(Z) {
    return Z <= 100 ? 27 : Z <= 150 ? 18 : Z <= 200 ? 15 : Z <= 250 ? 12 : Z <= 300 ? 9 : Z <= 350 ? 8 : Z <= 400 ? 7 : Z <= 500 ? 6 : Z <= 600 ? 5 : Z <= 800 ? 4 : Z <= 1250 ? 3 : 2;
  }
})();
var He = ht;
if (typeof _t > "u")
  var _t = He.jsbn.BigInteger;
var wc = He.util.isNodejs ? _r() : null, he = He.asn1, Hr = He.util;
He.pki = He.pki || {};
He.pki.rsa = He.rsa = He.rsa || {};
var at = He.pki, XB = [6, 4, 2, 4, 2, 4, 6, 2], QB = {
  // PrivateKeyInfo
  name: "PrivateKeyInfo",
  tagClass: he.Class.UNIVERSAL,
  type: he.Type.SEQUENCE,
  constructed: !0,
  value: [{
    // Version (INTEGER)
    name: "PrivateKeyInfo.version",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyVersion"
  }, {
    // privateKeyAlgorithm
    name: "PrivateKeyInfo.privateKeyAlgorithm",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: he.Class.UNIVERSAL,
      type: he.Type.OID,
      constructed: !1,
      capture: "privateKeyOid"
    }]
  }, {
    // PrivateKey
    name: "PrivateKeyInfo",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.OCTETSTRING,
    constructed: !1,
    capture: "privateKey"
  }]
}, ZB = {
  // RSAPrivateKey
  name: "RSAPrivateKey",
  tagClass: he.Class.UNIVERSAL,
  type: he.Type.SEQUENCE,
  constructed: !0,
  value: [{
    // Version (INTEGER)
    name: "RSAPrivateKey.version",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyVersion"
  }, {
    // modulus (n)
    name: "RSAPrivateKey.modulus",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyModulus"
  }, {
    // publicExponent (e)
    name: "RSAPrivateKey.publicExponent",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyPublicExponent"
  }, {
    // privateExponent (d)
    name: "RSAPrivateKey.privateExponent",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyPrivateExponent"
  }, {
    // prime1 (p)
    name: "RSAPrivateKey.prime1",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyPrime1"
  }, {
    // prime2 (q)
    name: "RSAPrivateKey.prime2",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyPrime2"
  }, {
    // exponent1 (d mod (p-1))
    name: "RSAPrivateKey.exponent1",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyExponent1"
  }, {
    // exponent2 (d mod (q-1))
    name: "RSAPrivateKey.exponent2",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyExponent2"
  }, {
    // coefficient ((inverse of q) mod p)
    name: "RSAPrivateKey.coefficient",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyCoefficient"
  }]
}, JB = {
  // RSAPublicKey
  name: "RSAPublicKey",
  tagClass: he.Class.UNIVERSAL,
  type: he.Type.SEQUENCE,
  constructed: !0,
  value: [{
    // modulus (n)
    name: "RSAPublicKey.modulus",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "publicKeyModulus"
  }, {
    // publicExponent (e)
    name: "RSAPublicKey.exponent",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.INTEGER,
    constructed: !1,
    capture: "publicKeyExponent"
  }]
}, eI = He.pki.rsa.publicKeyValidator = {
  name: "SubjectPublicKeyInfo",
  tagClass: he.Class.UNIVERSAL,
  type: he.Type.SEQUENCE,
  constructed: !0,
  captureAsn1: "subjectPublicKeyInfo",
  value: [{
    name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: he.Class.UNIVERSAL,
      type: he.Type.OID,
      constructed: !1,
      capture: "publicKeyOid"
    }]
  }, {
    // subjectPublicKey
    name: "SubjectPublicKeyInfo.subjectPublicKey",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.BITSTRING,
    constructed: !1,
    value: [{
      // RSAPublicKey
      name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
      tagClass: he.Class.UNIVERSAL,
      type: he.Type.SEQUENCE,
      constructed: !0,
      optional: !0,
      captureAsn1: "rsaPublicKey"
    }]
  }]
}, tI = {
  name: "DigestInfo",
  tagClass: he.Class.UNIVERSAL,
  type: he.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "DigestInfo.DigestAlgorithm",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
      tagClass: he.Class.UNIVERSAL,
      type: he.Type.OID,
      constructed: !1,
      capture: "algorithmIdentifier"
    }, {
      // NULL paramters
      name: "DigestInfo.DigestAlgorithm.parameters",
      tagClass: he.Class.UNIVERSAL,
      type: he.Type.NULL,
      // captured only to check existence for md2 and md5
      capture: "parameters",
      optional: !0,
      constructed: !1
    }]
  }, {
    // digest
    name: "DigestInfo.digest",
    tagClass: he.Class.UNIVERSAL,
    type: he.Type.OCTETSTRING,
    constructed: !1,
    capture: "digest"
  }]
}, rI = function(e) {
  var t;
  if (e.algorithm in at.oids)
    t = at.oids[e.algorithm];
  else {
    var h = new Error("Unknown message digest algorithm.");
    throw h.algorithm = e.algorithm, h;
  }
  var o = he.oidToDer(t).getBytes(), S = he.create(
    he.Class.UNIVERSAL,
    he.Type.SEQUENCE,
    !0,
    []
  ), g = he.create(
    he.Class.UNIVERSAL,
    he.Type.SEQUENCE,
    !0,
    []
  );
  g.value.push(he.create(
    he.Class.UNIVERSAL,
    he.Type.OID,
    !1,
    o
  )), g.value.push(he.create(
    he.Class.UNIVERSAL,
    he.Type.NULL,
    !1,
    ""
  ));
  var B = he.create(
    he.Class.UNIVERSAL,
    he.Type.OCTETSTRING,
    !1,
    e.digest().getBytes()
  );
  return S.value.push(g), S.value.push(B), he.toDer(S).getBytes();
}, R2 = function(e, t, h) {
  if (h)
    return e.modPow(t.e, t.n);
  if (!t.p || !t.q)
    return e.modPow(t.d, t.n);
  t.dP || (t.dP = t.d.mod(t.p.subtract(_t.ONE))), t.dQ || (t.dQ = t.d.mod(t.q.subtract(_t.ONE))), t.qInv || (t.qInv = t.q.modInverse(t.p));
  var o;
  do
    o = new _t(
      He.util.bytesToHex(He.random.getBytes(t.n.bitLength() / 8)),
      16
    );
  while (o.compareTo(t.n) >= 0 || !o.gcd(t.n).equals(_t.ONE));
  e = e.multiply(o.modPow(t.e, t.n)).mod(t.n);
  for (var S = e.mod(t.p).modPow(t.dP, t.p), g = e.mod(t.q).modPow(t.dQ, t.q); S.compareTo(g) < 0; )
    S = S.add(t.p);
  var B = S.subtract(g).multiply(t.qInv).mod(t.p).multiply(t.q).add(g);
  return B = B.multiply(o.modInverse(t.n)).mod(t.n), B;
};
at.rsa.encrypt = function(e, t, h) {
  var o = h, S, g = Math.ceil(t.n.bitLength() / 8);
  h !== !1 && h !== !0 ? (o = h === 2, S = N2(e, t, h)) : (S = He.util.createBuffer(), S.putBytes(e));
  for (var B = new _t(S.toHex(), 16), M = R2(B, t, o), O = M.toString(16), P = He.util.createBuffer(), D = g - Math.ceil(O.length / 2); D > 0; )
    P.putByte(0), --D;
  return P.putBytes(He.util.hexToBytes(O)), P.getBytes();
};
at.rsa.decrypt = function(e, t, h, o) {
  var S = Math.ceil(t.n.bitLength() / 8);
  if (e.length !== S) {
    var g = new Error("Encrypted message length is invalid.");
    throw g.length = e.length, g.expected = S, g;
  }
  var B = new _t(He.util.createBuffer(e).toHex(), 16);
  if (B.compareTo(t.n) >= 0)
    throw new Error("Encrypted message is invalid.");
  for (var M = R2(B, t, h), O = M.toString(16), P = He.util.createBuffer(), D = S - Math.ceil(O.length / 2); D > 0; )
    P.putByte(0), --D;
  return P.putBytes(He.util.hexToBytes(O)), o !== !1 ? Us(P.getBytes(), t, h) : P.getBytes();
};
at.rsa.createKeyPairGenerationState = function(e, t, h) {
  typeof e == "string" && (e = parseInt(e, 10)), e = e || 2048, h = h || {};
  var o = h.prng || He.random, S = {
    // x is an array to fill with bytes
    nextBytes: function(M) {
      for (var O = o.getBytesSync(M.length), P = 0; P < M.length; ++P)
        M[P] = O.charCodeAt(P);
    }
  }, g = h.algorithm || "PRIMEINC", B;
  if (g === "PRIMEINC")
    B = {
      algorithm: g,
      state: 0,
      bits: e,
      rng: S,
      eInt: t || 65537,
      e: new _t(null),
      p: null,
      q: null,
      qBits: e >> 1,
      pBits: e - (e >> 1),
      pqState: 0,
      num: null,
      keys: null
    }, B.e.fromInt(B.eInt);
  else
    throw new Error("Invalid key generation algorithm: " + g);
  return B;
};
at.rsa.stepKeyPairGenerationState = function(e, t) {
  "algorithm" in e || (e.algorithm = "PRIMEINC");
  var h = new _t(null);
  h.fromInt(30);
  for (var o = 0, S = function(Z, Y) {
    return Z | Y;
  }, g = +/* @__PURE__ */ new Date(), B, M = 0; e.keys === null && (t <= 0 || M < t); ) {
    if (e.state === 0) {
      var O = e.p === null ? e.pBits : e.qBits, P = O - 1;
      e.pqState === 0 ? (e.num = new _t(O, e.rng), e.num.testBit(P) || e.num.bitwiseTo(
        _t.ONE.shiftLeft(P),
        S,
        e.num
      ), e.num.dAddOffset(31 - e.num.mod(h).byteValue(), 0), o = 0, ++e.pqState) : e.pqState === 1 ? e.num.bitLength() > O ? e.pqState = 0 : e.num.isProbablePrime(
        nI(e.num.bitLength())
      ) ? ++e.pqState : e.num.dAddOffset(XB[o++ % 8], 0) : e.pqState === 2 ? e.pqState = e.num.subtract(_t.ONE).gcd(e.e).compareTo(_t.ONE) === 0 ? 3 : 0 : e.pqState === 3 && (e.pqState = 0, e.p === null ? e.p = e.num : e.q = e.num, e.p !== null && e.q !== null && ++e.state, e.num = null);
    } else if (e.state === 1)
      e.p.compareTo(e.q) < 0 && (e.num = e.p, e.p = e.q, e.q = e.num), ++e.state;
    else if (e.state === 2)
      e.p1 = e.p.subtract(_t.ONE), e.q1 = e.q.subtract(_t.ONE), e.phi = e.p1.multiply(e.q1), ++e.state;
    else if (e.state === 3)
      e.phi.gcd(e.e).compareTo(_t.ONE) === 0 ? ++e.state : (e.p = null, e.q = null, e.state = 0);
    else if (e.state === 4)
      e.n = e.p.multiply(e.q), e.n.bitLength() === e.bits ? ++e.state : (e.q = null, e.state = 0);
    else if (e.state === 5) {
      var D = e.e.modInverse(e.phi);
      e.keys = {
        privateKey: at.rsa.setPrivateKey(
          e.n,
          e.e,
          D,
          e.p,
          e.q,
          D.mod(e.p1),
          D.mod(e.q1),
          e.q.modInverse(e.p)
        ),
        publicKey: at.rsa.setPublicKey(e.n, e.e)
      };
    }
    B = +/* @__PURE__ */ new Date(), M += B - g, g = B;
  }
  return e.keys !== null;
};
at.rsa.generateKeyPair = function(e, t, h, o) {
  if (arguments.length === 1 ? typeof e == "object" ? (h = e, e = void 0) : typeof e == "function" && (o = e, e = void 0) : arguments.length === 2 ? typeof e == "number" ? typeof t == "function" ? (o = t, t = void 0) : typeof t != "number" && (h = t, t = void 0) : (h = e, o = t, e = void 0, t = void 0) : arguments.length === 3 && (typeof t == "number" ? typeof h == "function" && (o = h, h = void 0) : (o = h, h = t, t = void 0)), h = h || {}, e === void 0 && (e = h.bits || 2048), t === void 0 && (t = h.e || 65537), !He.options.usePureJavaScript && !h.prng && e >= 256 && e <= 16384 && (t === 65537 || t === 3)) {
    if (o) {
      if (Vp("generateKeyPair"))
        return wc.generateKeyPair("rsa", {
          modulusLength: e,
          publicExponent: t,
          publicKeyEncoding: {
            type: "spki",
            format: "pem"
          },
          privateKeyEncoding: {
            type: "pkcs8",
            format: "pem"
          }
        }, function(M, O, P) {
          if (M)
            return o(M);
          o(null, {
            privateKey: at.privateKeyFromPem(P),
            publicKey: at.publicKeyFromPem(O)
          });
        });
      if (Kp("generateKey") && Kp("exportKey"))
        return Hr.globalScope.crypto.subtle.generateKey({
          name: "RSASSA-PKCS1-v1_5",
          modulusLength: e,
          publicExponent: Hp(t),
          hash: { name: "SHA-256" }
        }, !0, ["sign", "verify"]).then(function(M) {
          return Hr.globalScope.crypto.subtle.exportKey(
            "pkcs8",
            M.privateKey
          );
        }).then(void 0, function(M) {
          o(M);
        }).then(function(M) {
          if (M) {
            var O = at.privateKeyFromAsn1(
              he.fromDer(He.util.createBuffer(M))
            );
            o(null, {
              privateKey: O,
              publicKey: at.setRsaPublicKey(O.n, O.e)
            });
          }
        });
      if ($p("generateKey") && $p("exportKey")) {
        var S = Hr.globalScope.msCrypto.subtle.generateKey({
          name: "RSASSA-PKCS1-v1_5",
          modulusLength: e,
          publicExponent: Hp(t),
          hash: { name: "SHA-256" }
        }, !0, ["sign", "verify"]);
        S.oncomplete = function(M) {
          var O = M.target.result, P = Hr.globalScope.msCrypto.subtle.exportKey(
            "pkcs8",
            O.privateKey
          );
          P.oncomplete = function(D) {
            var Z = D.target.result, Y = at.privateKeyFromAsn1(
              he.fromDer(He.util.createBuffer(Z))
            );
            o(null, {
              privateKey: Y,
              publicKey: at.setRsaPublicKey(Y.n, Y.e)
            });
          }, P.onerror = function(D) {
            o(D);
          };
        }, S.onerror = function(M) {
          o(M);
        };
        return;
      }
    } else if (Vp("generateKeyPairSync")) {
      var g = wc.generateKeyPairSync("rsa", {
        modulusLength: e,
        publicExponent: t,
        publicKeyEncoding: {
          type: "spki",
          format: "pem"
        },
        privateKeyEncoding: {
          type: "pkcs8",
          format: "pem"
        }
      });
      return {
        privateKey: at.privateKeyFromPem(g.privateKey),
        publicKey: at.publicKeyFromPem(g.publicKey)
      };
    }
  }
  var B = at.rsa.createKeyPairGenerationState(e, t, h);
  if (!o)
    return at.rsa.stepKeyPairGenerationState(B, 0), B.keys;
  iI(B, h, o);
};
at.setRsaPublicKey = at.rsa.setPublicKey = function(e, t) {
  var h = {
    n: e,
    e: t
  };
  return h.encrypt = function(o, S, g) {
    if (typeof S == "string" ? S = S.toUpperCase() : S === void 0 && (S = "RSAES-PKCS1-V1_5"), S === "RSAES-PKCS1-V1_5")
      S = {
        encode: function(M, O, P) {
          return N2(M, O, 2).getBytes();
        }
      };
    else if (S === "RSA-OAEP" || S === "RSAES-OAEP")
      S = {
        encode: function(M, O) {
          return He.pkcs1.encode_rsa_oaep(O, M, g);
        }
      };
    else if (["RAW", "NONE", "NULL", null].indexOf(S) !== -1)
      S = { encode: function(M) {
        return M;
      } };
    else if (typeof S == "string")
      throw new Error('Unsupported encryption scheme: "' + S + '".');
    var B = S.encode(o, h, !0);
    return at.rsa.encrypt(B, h, !0);
  }, h.verify = function(o, S, g, B) {
    typeof g == "string" ? g = g.toUpperCase() : g === void 0 && (g = "RSASSA-PKCS1-V1_5"), B === void 0 && (B = {
      _parseAllDigestBytes: !0
    }), "_parseAllDigestBytes" in B || (B._parseAllDigestBytes = !0), g === "RSASSA-PKCS1-V1_5" ? g = {
      verify: function(O, P) {
        P = Us(P, h, !0);
        var D = he.fromDer(P, {
          parseAllBytes: B._parseAllDigestBytes
        }), Z = {}, Y = [];
        if (!he.validate(D, tI, Z, Y)) {
          var ee = new Error(
            "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
          );
          throw ee.errors = Y, ee;
        }
        var ie = he.derToOid(Z.algorithmIdentifier);
        if (!(ie === He.oids.md2 || ie === He.oids.md5 || ie === He.oids.sha1 || ie === He.oids.sha224 || ie === He.oids.sha256 || ie === He.oids.sha384 || ie === He.oids.sha512 || ie === He.oids["sha512-224"] || ie === He.oids["sha512-256"])) {
          var ee = new Error(
            "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
          );
          throw ee.oid = ie, ee;
        }
        if ((ie === He.oids.md2 || ie === He.oids.md5) && !("parameters" in Z))
          throw new Error(
            "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters."
          );
        return O === Z.digest;
      }
    } : (g === "NONE" || g === "NULL" || g === null) && (g = {
      verify: function(O, P) {
        return P = Us(P, h, !0), O === P;
      }
    });
    var M = at.rsa.decrypt(S, h, !0, !1);
    return g.verify(o, M, h.n.bitLength());
  }, h;
};
at.setRsaPrivateKey = at.rsa.setPrivateKey = function(e, t, h, o, S, g, B, M) {
  var O = {
    n: e,
    e: t,
    d: h,
    p: o,
    q: S,
    dP: g,
    dQ: B,
    qInv: M
  };
  return O.decrypt = function(P, D, Z) {
    typeof D == "string" ? D = D.toUpperCase() : D === void 0 && (D = "RSAES-PKCS1-V1_5");
    var Y = at.rsa.decrypt(P, O, !1, !1);
    if (D === "RSAES-PKCS1-V1_5")
      D = { decode: Us };
    else if (D === "RSA-OAEP" || D === "RSAES-OAEP")
      D = {
        decode: function(ee, ie) {
          return He.pkcs1.decode_rsa_oaep(ie, ee, Z);
        }
      };
    else if (["RAW", "NONE", "NULL", null].indexOf(D) !== -1)
      D = { decode: function(ee) {
        return ee;
      } };
    else
      throw new Error('Unsupported encryption scheme: "' + D + '".');
    return D.decode(Y, O, !1);
  }, O.sign = function(P, D) {
    var Z = !1;
    typeof D == "string" && (D = D.toUpperCase()), D === void 0 || D === "RSASSA-PKCS1-V1_5" ? (D = { encode: rI }, Z = 1) : (D === "NONE" || D === "NULL" || D === null) && (D = { encode: function() {
      return P;
    } }, Z = 1);
    var Y = D.encode(P, O.n.bitLength());
    return at.rsa.encrypt(Y, O, Z);
  }, O;
};
at.wrapRsaPrivateKey = function(e) {
  return he.create(he.Class.UNIVERSAL, he.Type.SEQUENCE, !0, [
    // version (0)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      he.integerToDer(0).getBytes()
    ),
    // privateKeyAlgorithm
    he.create(he.Class.UNIVERSAL, he.Type.SEQUENCE, !0, [
      he.create(
        he.Class.UNIVERSAL,
        he.Type.OID,
        !1,
        he.oidToDer(at.oids.rsaEncryption).getBytes()
      ),
      he.create(he.Class.UNIVERSAL, he.Type.NULL, !1, "")
    ]),
    // PrivateKey
    he.create(
      he.Class.UNIVERSAL,
      he.Type.OCTETSTRING,
      !1,
      he.toDer(e).getBytes()
    )
  ]);
};
at.privateKeyFromAsn1 = function(e) {
  var t = {}, h = [];
  if (he.validate(e, QB, t, h) && (e = he.fromDer(He.util.createBuffer(t.privateKey))), t = {}, h = [], !he.validate(e, ZB, t, h)) {
    var o = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
    throw o.errors = h, o;
  }
  var S, g, B, M, O, P, D, Z;
  return S = He.util.createBuffer(t.privateKeyModulus).toHex(), g = He.util.createBuffer(t.privateKeyPublicExponent).toHex(), B = He.util.createBuffer(t.privateKeyPrivateExponent).toHex(), M = He.util.createBuffer(t.privateKeyPrime1).toHex(), O = He.util.createBuffer(t.privateKeyPrime2).toHex(), P = He.util.createBuffer(t.privateKeyExponent1).toHex(), D = He.util.createBuffer(t.privateKeyExponent2).toHex(), Z = He.util.createBuffer(t.privateKeyCoefficient).toHex(), at.setRsaPrivateKey(
    new _t(S, 16),
    new _t(g, 16),
    new _t(B, 16),
    new _t(M, 16),
    new _t(O, 16),
    new _t(P, 16),
    new _t(D, 16),
    new _t(Z, 16)
  );
};
at.privateKeyToAsn1 = at.privateKeyToRSAPrivateKey = function(e) {
  return he.create(he.Class.UNIVERSAL, he.Type.SEQUENCE, !0, [
    // version (0 = only 2 primes, 1 multiple primes)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      he.integerToDer(0).getBytes()
    ),
    // modulus (n)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      Mi(e.n)
    ),
    // publicExponent (e)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      Mi(e.e)
    ),
    // privateExponent (d)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      Mi(e.d)
    ),
    // privateKeyPrime1 (p)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      Mi(e.p)
    ),
    // privateKeyPrime2 (q)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      Mi(e.q)
    ),
    // privateKeyExponent1 (dP)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      Mi(e.dP)
    ),
    // privateKeyExponent2 (dQ)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      Mi(e.dQ)
    ),
    // coefficient (qInv)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      Mi(e.qInv)
    )
  ]);
};
at.publicKeyFromAsn1 = function(e) {
  var t = {}, h = [];
  if (he.validate(e, eI, t, h)) {
    var o = he.derToOid(t.publicKeyOid);
    if (o !== at.oids.rsaEncryption) {
      var S = new Error("Cannot read public key. Unknown OID.");
      throw S.oid = o, S;
    }
    e = t.rsaPublicKey;
  }
  if (h = [], !he.validate(e, JB, t, h)) {
    var S = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
    throw S.errors = h, S;
  }
  var g = He.util.createBuffer(t.publicKeyModulus).toHex(), B = He.util.createBuffer(t.publicKeyExponent).toHex();
  return at.setRsaPublicKey(
    new _t(g, 16),
    new _t(B, 16)
  );
};
at.publicKeyToAsn1 = at.publicKeyToSubjectPublicKeyInfo = function(e) {
  return he.create(he.Class.UNIVERSAL, he.Type.SEQUENCE, !0, [
    // AlgorithmIdentifier
    he.create(he.Class.UNIVERSAL, he.Type.SEQUENCE, !0, [
      // algorithm
      he.create(
        he.Class.UNIVERSAL,
        he.Type.OID,
        !1,
        he.oidToDer(at.oids.rsaEncryption).getBytes()
      ),
      // parameters (null)
      he.create(he.Class.UNIVERSAL, he.Type.NULL, !1, "")
    ]),
    // subjectPublicKey
    he.create(he.Class.UNIVERSAL, he.Type.BITSTRING, !1, [
      at.publicKeyToRSAPublicKey(e)
    ])
  ]);
};
at.publicKeyToRSAPublicKey = function(e) {
  return he.create(he.Class.UNIVERSAL, he.Type.SEQUENCE, !0, [
    // modulus (n)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      Mi(e.n)
    ),
    // publicExponent (e)
    he.create(
      he.Class.UNIVERSAL,
      he.Type.INTEGER,
      !1,
      Mi(e.e)
    )
  ]);
};
function N2(e, t, h) {
  var o = He.util.createBuffer(), S = Math.ceil(t.n.bitLength() / 8);
  if (e.length > S - 11) {
    var g = new Error("Message is too long for PKCS#1 v1.5 padding.");
    throw g.length = e.length, g.max = S - 11, g;
  }
  o.putByte(0), o.putByte(h);
  var B = S - 3 - e.length, M;
  if (h === 0 || h === 1) {
    M = h === 0 ? 0 : 255;
    for (var O = 0; O < B; ++O)
      o.putByte(M);
  } else
    for (; B > 0; ) {
      for (var P = 0, D = He.random.getBytes(B), O = 0; O < B; ++O)
        M = D.charCodeAt(O), M === 0 ? ++P : o.putByte(M);
      B = P;
    }
  return o.putByte(0), o.putBytes(e), o;
}
function Us(e, t, h, o) {
  var S = Math.ceil(t.n.bitLength() / 8), g = He.util.createBuffer(e), B = g.getByte(), M = g.getByte();
  if (B !== 0 || h && M !== 0 && M !== 1 || !h && M != 2 || h && M === 0 && typeof o > "u")
    throw new Error("Encryption block is invalid.");
  var O = 0;
  if (M === 0) {
    O = S - 3 - o;
    for (var P = 0; P < O; ++P)
      if (g.getByte() !== 0)
        throw new Error("Encryption block is invalid.");
  } else if (M === 1)
    for (O = 0; g.length() > 1; ) {
      if (g.getByte() !== 255) {
        --g.read;
        break;
      }
      ++O;
    }
  else if (M === 2)
    for (O = 0; g.length() > 1; ) {
      if (g.getByte() === 0) {
        --g.read;
        break;
      }
      ++O;
    }
  var D = g.getByte();
  if (D !== 0 || O !== S - 3 - g.length())
    throw new Error("Encryption block is invalid.");
  return g.getBytes();
}
function iI(e, t, h) {
  typeof t == "function" && (h = t, t = {}), t = t || {};
  var o = {
    algorithm: {
      name: t.algorithm || "PRIMEINC",
      options: {
        workers: t.workers || 2,
        workLoad: t.workLoad || 100,
        workerScript: t.workerScript
      }
    }
  };
  "prng" in t && (o.prng = t.prng), S();
  function S() {
    g(e.pBits, function(M, O) {
      if (M)
        return h(M);
      if (e.p = O, e.q !== null)
        return B(M, e.q);
      g(e.qBits, B);
    });
  }
  function g(M, O) {
    He.prime.generateProbablePrime(M, o, O);
  }
  function B(M, O) {
    if (M)
      return h(M);
    if (e.q = O, e.p.compareTo(e.q) < 0) {
      var P = e.p;
      e.p = e.q, e.q = P;
    }
    if (e.p.subtract(_t.ONE).gcd(e.e).compareTo(_t.ONE) !== 0) {
      e.p = null, S();
      return;
    }
    if (e.q.subtract(_t.ONE).gcd(e.e).compareTo(_t.ONE) !== 0) {
      e.q = null, g(e.qBits, B);
      return;
    }
    if (e.p1 = e.p.subtract(_t.ONE), e.q1 = e.q.subtract(_t.ONE), e.phi = e.p1.multiply(e.q1), e.phi.gcd(e.e).compareTo(_t.ONE) !== 0) {
      e.p = e.q = null, S();
      return;
    }
    if (e.n = e.p.multiply(e.q), e.n.bitLength() !== e.bits) {
      e.q = null, g(e.qBits, B);
      return;
    }
    var D = e.e.modInverse(e.phi);
    e.keys = {
      privateKey: at.rsa.setPrivateKey(
        e.n,
        e.e,
        D,
        e.p,
        e.q,
        D.mod(e.p1),
        D.mod(e.q1),
        e.q.modInverse(e.p)
      ),
      publicKey: at.rsa.setPublicKey(e.n, e.e)
    }, h(null, e.keys);
  }
}
function Mi(e) {
  var t = e.toString(16);
  t[0] >= "8" && (t = "00" + t);
  var h = He.util.hexToBytes(t);
  return h.length > 1 && // leading 0x00 for positive integer
  (h.charCodeAt(0) === 0 && !(h.charCodeAt(1) & 128) || // leading 0xFF for negative integer
  h.charCodeAt(0) === 255 && (h.charCodeAt(1) & 128) === 128) ? h.substr(1) : h;
}
function nI(e) {
  return e <= 100 ? 27 : e <= 150 ? 18 : e <= 200 ? 15 : e <= 250 ? 12 : e <= 300 ? 9 : e <= 350 ? 8 : e <= 400 ? 7 : e <= 500 ? 6 : e <= 600 ? 5 : e <= 800 ? 4 : e <= 1250 ? 3 : 2;
}
function Vp(e) {
  return He.util.isNodejs && typeof wc[e] == "function";
}
function Kp(e) {
  return typeof Hr.globalScope < "u" && typeof Hr.globalScope.crypto == "object" && typeof Hr.globalScope.crypto.subtle == "object" && typeof Hr.globalScope.crypto.subtle[e] == "function";
}
function $p(e) {
  return typeof Hr.globalScope < "u" && typeof Hr.globalScope.msCrypto == "object" && typeof Hr.globalScope.msCrypto.subtle == "object" && typeof Hr.globalScope.msCrypto.subtle[e] == "function";
}
function Hp(e) {
  for (var t = He.util.hexToBytes(e.toString(16)), h = new Uint8Array(t.length), o = 0; o < t.length; ++o)
    h[o] = t.charCodeAt(o);
  return h;
}
var De = ht;
if (typeof aI > "u")
  var aI = De.jsbn.BigInteger;
var ye = De.asn1, ft = De.pki = De.pki || {};
ft.pbe = De.pbe = De.pbe || {};
var Un = ft.oids, sI = {
  name: "EncryptedPrivateKeyInfo",
  tagClass: ye.Class.UNIVERSAL,
  type: ye.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
    tagClass: ye.Class.UNIVERSAL,
    type: ye.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: ye.Class.UNIVERSAL,
      type: ye.Type.OID,
      constructed: !1,
      capture: "encryptionOid"
    }, {
      name: "AlgorithmIdentifier.parameters",
      tagClass: ye.Class.UNIVERSAL,
      type: ye.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: "encryptionParams"
    }]
  }, {
    // encryptedData
    name: "EncryptedPrivateKeyInfo.encryptedData",
    tagClass: ye.Class.UNIVERSAL,
    type: ye.Type.OCTETSTRING,
    constructed: !1,
    capture: "encryptedData"
  }]
}, fI = {
  name: "PBES2Algorithms",
  tagClass: ye.Class.UNIVERSAL,
  type: ye.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "PBES2Algorithms.keyDerivationFunc",
    tagClass: ye.Class.UNIVERSAL,
    type: ye.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "PBES2Algorithms.keyDerivationFunc.oid",
      tagClass: ye.Class.UNIVERSAL,
      type: ye.Type.OID,
      constructed: !1,
      capture: "kdfOid"
    }, {
      name: "PBES2Algorithms.params",
      tagClass: ye.Class.UNIVERSAL,
      type: ye.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "PBES2Algorithms.params.salt",
        tagClass: ye.Class.UNIVERSAL,
        type: ye.Type.OCTETSTRING,
        constructed: !1,
        capture: "kdfSalt"
      }, {
        name: "PBES2Algorithms.params.iterationCount",
        tagClass: ye.Class.UNIVERSAL,
        type: ye.Type.INTEGER,
        constructed: !1,
        capture: "kdfIterationCount"
      }, {
        name: "PBES2Algorithms.params.keyLength",
        tagClass: ye.Class.UNIVERSAL,
        type: ye.Type.INTEGER,
        constructed: !1,
        optional: !0,
        capture: "keyLength"
      }, {
        // prf
        name: "PBES2Algorithms.params.prf",
        tagClass: ye.Class.UNIVERSAL,
        type: ye.Type.SEQUENCE,
        constructed: !0,
        optional: !0,
        value: [{
          name: "PBES2Algorithms.params.prf.algorithm",
          tagClass: ye.Class.UNIVERSAL,
          type: ye.Type.OID,
          constructed: !1,
          capture: "prfOid"
        }]
      }]
    }]
  }, {
    name: "PBES2Algorithms.encryptionScheme",
    tagClass: ye.Class.UNIVERSAL,
    type: ye.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "PBES2Algorithms.encryptionScheme.oid",
      tagClass: ye.Class.UNIVERSAL,
      type: ye.Type.OID,
      constructed: !1,
      capture: "encOid"
    }, {
      name: "PBES2Algorithms.encryptionScheme.iv",
      tagClass: ye.Class.UNIVERSAL,
      type: ye.Type.OCTETSTRING,
      constructed: !1,
      capture: "encIv"
    }]
  }]
}, oI = {
  name: "pkcs-12PbeParams",
  tagClass: ye.Class.UNIVERSAL,
  type: ye.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "pkcs-12PbeParams.salt",
    tagClass: ye.Class.UNIVERSAL,
    type: ye.Type.OCTETSTRING,
    constructed: !1,
    capture: "salt"
  }, {
    name: "pkcs-12PbeParams.iterations",
    tagClass: ye.Class.UNIVERSAL,
    type: ye.Type.INTEGER,
    constructed: !1,
    capture: "iterations"
  }]
};
ft.encryptPrivateKeyInfo = function(e, t, h) {
  h = h || {}, h.saltSize = h.saltSize || 8, h.count = h.count || 2048, h.algorithm = h.algorithm || "aes128", h.prfAlgorithm = h.prfAlgorithm || "sha1";
  var o = De.random.getBytesSync(h.saltSize), S = h.count, g = ye.integerToDer(S), B, M, O;
  if (h.algorithm.indexOf("aes") === 0 || h.algorithm === "des") {
    var P, D, Z;
    switch (h.algorithm) {
      case "aes128":
        B = 16, P = 16, D = Un["aes128-CBC"], Z = De.aes.createEncryptionCipher;
        break;
      case "aes192":
        B = 24, P = 16, D = Un["aes192-CBC"], Z = De.aes.createEncryptionCipher;
        break;
      case "aes256":
        B = 32, P = 16, D = Un["aes256-CBC"], Z = De.aes.createEncryptionCipher;
        break;
      case "des":
        B = 8, P = 8, D = Un.desCBC, Z = De.des.createEncryptionCipher;
        break;
      default:
        var Y = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        throw Y.algorithm = h.algorithm, Y;
    }
    var ee = "hmacWith" + h.prfAlgorithm.toUpperCase(), ie = O2(ee), ue = De.pkcs5.pbkdf2(t, o, S, B, ie), fe = De.random.getBytesSync(P), de = Z(ue);
    de.start(fe), de.update(ye.toDer(e)), de.finish(), O = de.output.getBytes();
    var ce = uI(o, g, B, ee);
    M = ye.create(
      ye.Class.UNIVERSAL,
      ye.Type.SEQUENCE,
      !0,
      [
        ye.create(
          ye.Class.UNIVERSAL,
          ye.Type.OID,
          !1,
          ye.oidToDer(Un.pkcs5PBES2).getBytes()
        ),
        ye.create(ye.Class.UNIVERSAL, ye.Type.SEQUENCE, !0, [
          // keyDerivationFunc
          ye.create(ye.Class.UNIVERSAL, ye.Type.SEQUENCE, !0, [
            ye.create(
              ye.Class.UNIVERSAL,
              ye.Type.OID,
              !1,
              ye.oidToDer(Un.pkcs5PBKDF2).getBytes()
            ),
            // PBKDF2-params
            ce
          ]),
          // encryptionScheme
          ye.create(ye.Class.UNIVERSAL, ye.Type.SEQUENCE, !0, [
            ye.create(
              ye.Class.UNIVERSAL,
              ye.Type.OID,
              !1,
              ye.oidToDer(D).getBytes()
            ),
            // iv
            ye.create(
              ye.Class.UNIVERSAL,
              ye.Type.OCTETSTRING,
              !1,
              fe
            )
          ])
        ])
      ]
    );
  } else if (h.algorithm === "3des") {
    B = 24;
    var be = new De.util.ByteBuffer(o), ue = ft.pbe.generatePkcs12Key(t, be, 1, S, B), fe = ft.pbe.generatePkcs12Key(t, be, 2, S, B), de = De.des.createEncryptionCipher(ue);
    de.start(fe), de.update(ye.toDer(e)), de.finish(), O = de.output.getBytes(), M = ye.create(
      ye.Class.UNIVERSAL,
      ye.Type.SEQUENCE,
      !0,
      [
        ye.create(
          ye.Class.UNIVERSAL,
          ye.Type.OID,
          !1,
          ye.oidToDer(Un["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
        ),
        // pkcs-12PbeParams
        ye.create(ye.Class.UNIVERSAL, ye.Type.SEQUENCE, !0, [
          // salt
          ye.create(ye.Class.UNIVERSAL, ye.Type.OCTETSTRING, !1, o),
          // iteration count
          ye.create(
            ye.Class.UNIVERSAL,
            ye.Type.INTEGER,
            !1,
            g.getBytes()
          )
        ])
      ]
    );
  } else {
    var Y = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
    throw Y.algorithm = h.algorithm, Y;
  }
  var ve = ye.create(ye.Class.UNIVERSAL, ye.Type.SEQUENCE, !0, [
    // encryptionAlgorithm
    M,
    // encryptedData
    ye.create(
      ye.Class.UNIVERSAL,
      ye.Type.OCTETSTRING,
      !1,
      O
    )
  ]);
  return ve;
};
ft.decryptPrivateKeyInfo = function(e, t) {
  var h = null, o = {}, S = [];
  if (!ye.validate(e, sI, o, S)) {
    var g = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    throw g.errors = S, g;
  }
  var B = ye.derToOid(o.encryptionOid), M = ft.pbe.getCipher(B, o.encryptionParams, t), O = De.util.createBuffer(o.encryptedData);
  return M.update(O), M.finish() && (h = ye.fromDer(M.output)), h;
};
ft.encryptedPrivateKeyToPem = function(e, t) {
  var h = {
    type: "ENCRYPTED PRIVATE KEY",
    body: ye.toDer(e).getBytes()
  };
  return De.pem.encode(h, { maxline: t });
};
ft.encryptedPrivateKeyFromPem = function(e) {
  var t = De.pem.decode(e)[0];
  if (t.type !== "ENCRYPTED PRIVATE KEY") {
    var h = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
    throw h.headerType = t.type, h;
  }
  if (t.procType && t.procType.type === "ENCRYPTED")
    throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
  return ye.fromDer(t.body);
};
ft.encryptRsaPrivateKey = function(e, t, h) {
  if (h = h || {}, !h.legacy) {
    var o = ft.wrapRsaPrivateKey(ft.privateKeyToAsn1(e));
    return o = ft.encryptPrivateKeyInfo(o, t, h), ft.encryptedPrivateKeyToPem(o);
  }
  var S, g, B, M;
  switch (h.algorithm) {
    case "aes128":
      S = "AES-128-CBC", B = 16, g = De.random.getBytesSync(16), M = De.aes.createEncryptionCipher;
      break;
    case "aes192":
      S = "AES-192-CBC", B = 24, g = De.random.getBytesSync(16), M = De.aes.createEncryptionCipher;
      break;
    case "aes256":
      S = "AES-256-CBC", B = 32, g = De.random.getBytesSync(16), M = De.aes.createEncryptionCipher;
      break;
    case "3des":
      S = "DES-EDE3-CBC", B = 24, g = De.random.getBytesSync(8), M = De.des.createEncryptionCipher;
      break;
    case "des":
      S = "DES-CBC", B = 8, g = De.random.getBytesSync(8), M = De.des.createEncryptionCipher;
      break;
    default:
      var O = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + h.algorithm + '".');
      throw O.algorithm = h.algorithm, O;
  }
  var P = De.pbe.opensslDeriveBytes(t, g.substr(0, 8), B), D = M(P);
  D.start(g), D.update(ye.toDer(ft.privateKeyToAsn1(e))), D.finish();
  var Z = {
    type: "RSA PRIVATE KEY",
    procType: {
      version: "4",
      type: "ENCRYPTED"
    },
    dekInfo: {
      algorithm: S,
      parameters: De.util.bytesToHex(g).toUpperCase()
    },
    body: D.output.getBytes()
  };
  return De.pem.encode(Z);
};
ft.decryptRsaPrivateKey = function(e, t) {
  var h = null, o = De.pem.decode(e)[0];
  if (o.type !== "ENCRYPTED PRIVATE KEY" && o.type !== "PRIVATE KEY" && o.type !== "RSA PRIVATE KEY") {
    var S = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
    throw S.headerType = S, S;
  }
  if (o.procType && o.procType.type === "ENCRYPTED") {
    var g, B;
    switch (o.dekInfo.algorithm) {
      case "DES-CBC":
        g = 8, B = De.des.createDecryptionCipher;
        break;
      case "DES-EDE3-CBC":
        g = 24, B = De.des.createDecryptionCipher;
        break;
      case "AES-128-CBC":
        g = 16, B = De.aes.createDecryptionCipher;
        break;
      case "AES-192-CBC":
        g = 24, B = De.aes.createDecryptionCipher;
        break;
      case "AES-256-CBC":
        g = 32, B = De.aes.createDecryptionCipher;
        break;
      case "RC2-40-CBC":
        g = 5, B = function(Z) {
          return De.rc2.createDecryptionCipher(Z, 40);
        };
        break;
      case "RC2-64-CBC":
        g = 8, B = function(Z) {
          return De.rc2.createDecryptionCipher(Z, 64);
        };
        break;
      case "RC2-128-CBC":
        g = 16, B = function(Z) {
          return De.rc2.createDecryptionCipher(Z, 128);
        };
        break;
      default:
        var S = new Error('Could not decrypt private key; unsupported encryption algorithm "' + o.dekInfo.algorithm + '".');
        throw S.algorithm = o.dekInfo.algorithm, S;
    }
    var M = De.util.hexToBytes(o.dekInfo.parameters), O = De.pbe.opensslDeriveBytes(t, M.substr(0, 8), g), P = B(O);
    if (P.start(M), P.update(De.util.createBuffer(o.body)), P.finish())
      h = P.output.getBytes();
    else
      return h;
  } else
    h = o.body;
  return o.type === "ENCRYPTED PRIVATE KEY" ? h = ft.decryptPrivateKeyInfo(ye.fromDer(h), t) : h = ye.fromDer(h), h !== null && (h = ft.privateKeyFromAsn1(h)), h;
};
ft.pbe.generatePkcs12Key = function(e, t, h, o, S, g) {
  var B, M;
  if (typeof g > "u" || g === null) {
    if (!("sha1" in De.md))
      throw new Error('"sha1" hash algorithm unavailable.');
    g = De.md.sha1.create();
  }
  var O = g.digestLength, P = g.blockLength, D = new De.util.ByteBuffer(), Z = new De.util.ByteBuffer();
  if (e != null) {
    for (M = 0; M < e.length; M++)
      Z.putInt16(e.charCodeAt(M));
    Z.putInt16(0);
  }
  var Y = Z.length(), ee = t.length(), ie = new De.util.ByteBuffer();
  ie.fillWithByte(h, P);
  var ue = P * Math.ceil(ee / P), fe = new De.util.ByteBuffer();
  for (M = 0; M < ue; M++)
    fe.putByte(t.at(M % ee));
  var de = P * Math.ceil(Y / P), ce = new De.util.ByteBuffer();
  for (M = 0; M < de; M++)
    ce.putByte(Z.at(M % Y));
  var be = fe;
  be.putBuffer(ce);
  for (var ve = Math.ceil(S / O), Pe = 1; Pe <= ve; Pe++) {
    var Ue = new De.util.ByteBuffer();
    Ue.putBytes(ie.bytes()), Ue.putBytes(be.bytes());
    for (var ze = 0; ze < o; ze++)
      g.start(), g.update(Ue.getBytes()), Ue = g.digest();
    var Le = new De.util.ByteBuffer();
    for (M = 0; M < P; M++)
      Le.putByte(Ue.at(M % O));
    var Ne = Math.ceil(ee / P) + Math.ceil(Y / P), $e = new De.util.ByteBuffer();
    for (B = 0; B < Ne; B++) {
      var J = new De.util.ByteBuffer(be.getBytes(P)), ne = 511;
      for (M = Le.length() - 1; M >= 0; M--)
        ne = ne >> 8, ne += Le.at(M) + J.at(M), J.setAt(M, ne & 255);
      $e.putBuffer(J);
    }
    be = $e, D.putBuffer(Ue);
  }
  return D.truncate(D.length() - S), D;
};
ft.pbe.getCipher = function(e, t, h) {
  switch (e) {
    case ft.oids.pkcs5PBES2:
      return ft.pbe.getCipherForPBES2(e, t, h);
    case ft.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
    case ft.oids["pbewithSHAAnd40BitRC2-CBC"]:
      return ft.pbe.getCipherForPKCS12PBE(e, t, h);
    default:
      var o = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
      throw o.oid = e, o.supportedOids = [
        "pkcs5PBES2",
        "pbeWithSHAAnd3-KeyTripleDES-CBC",
        "pbewithSHAAnd40BitRC2-CBC"
      ], o;
  }
};
ft.pbe.getCipherForPBES2 = function(e, t, h) {
  var o = {}, S = [];
  if (!ye.validate(t, fI, o, S)) {
    var g = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    throw g.errors = S, g;
  }
  if (e = ye.derToOid(o.kdfOid), e !== ft.oids.pkcs5PBKDF2) {
    var g = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
    throw g.oid = e, g.supportedOids = ["pkcs5PBKDF2"], g;
  }
  if (e = ye.derToOid(o.encOid), e !== ft.oids["aes128-CBC"] && e !== ft.oids["aes192-CBC"] && e !== ft.oids["aes256-CBC"] && e !== ft.oids["des-EDE3-CBC"] && e !== ft.oids.desCBC) {
    var g = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
    throw g.oid = e, g.supportedOids = [
      "aes128-CBC",
      "aes192-CBC",
      "aes256-CBC",
      "des-EDE3-CBC",
      "desCBC"
    ], g;
  }
  var B = o.kdfSalt, M = De.util.createBuffer(o.kdfIterationCount);
  M = M.getInt(M.length() << 3);
  var O, P;
  switch (ft.oids[e]) {
    case "aes128-CBC":
      O = 16, P = De.aes.createDecryptionCipher;
      break;
    case "aes192-CBC":
      O = 24, P = De.aes.createDecryptionCipher;
      break;
    case "aes256-CBC":
      O = 32, P = De.aes.createDecryptionCipher;
      break;
    case "des-EDE3-CBC":
      O = 24, P = De.des.createDecryptionCipher;
      break;
    case "desCBC":
      O = 8, P = De.des.createDecryptionCipher;
      break;
  }
  var D = D2(o.prfOid), Z = De.pkcs5.pbkdf2(h, B, M, O, D), Y = o.encIv, ee = P(Z);
  return ee.start(Y), ee;
};
ft.pbe.getCipherForPKCS12PBE = function(e, t, h) {
  var o = {}, S = [];
  if (!ye.validate(t, oI, o, S)) {
    var g = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    throw g.errors = S, g;
  }
  var B = De.util.createBuffer(o.salt), M = De.util.createBuffer(o.iterations);
  M = M.getInt(M.length() << 3);
  var O, P, D;
  switch (e) {
    case ft.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
      O = 24, P = 8, D = De.des.startDecrypting;
      break;
    case ft.oids["pbewithSHAAnd40BitRC2-CBC"]:
      O = 5, P = 8, D = function(ue, fe) {
        var de = De.rc2.createDecryptionCipher(ue, 40);
        return de.start(fe, null), de;
      };
      break;
    default:
      var g = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
      throw g.oid = e, g;
  }
  var Z = D2(o.prfOid), Y = ft.pbe.generatePkcs12Key(h, B, 1, M, O, Z);
  Z.start();
  var ee = ft.pbe.generatePkcs12Key(h, B, 2, M, P, Z);
  return D(Y, ee);
};
ft.pbe.opensslDeriveBytes = function(e, t, h, o) {
  if (typeof o > "u" || o === null) {
    if (!("md5" in De.md))
      throw new Error('"md5" hash algorithm unavailable.');
    o = De.md.md5.create();
  }
  t === null && (t = "");
  for (var S = [Gp(o, e + t)], g = 16, B = 1; g < h; ++B, g += 16)
    S.push(Gp(o, S[B - 1] + e + t));
  return S.join("").substr(0, h);
};
function Gp(e, t) {
  return e.start().update(t).digest().getBytes();
}
function D2(e) {
  var t;
  if (!e)
    t = "hmacWithSHA1";
  else if (t = ft.oids[ye.derToOid(e)], !t) {
    var h = new Error("Unsupported PRF OID.");
    throw h.oid = e, h.supported = [
      "hmacWithSHA1",
      "hmacWithSHA224",
      "hmacWithSHA256",
      "hmacWithSHA384",
      "hmacWithSHA512"
    ], h;
  }
  return O2(t);
}
function O2(e) {
  var t = De.md;
  switch (e) {
    case "hmacWithSHA224":
      t = De.md.sha512;
    case "hmacWithSHA1":
    case "hmacWithSHA256":
    case "hmacWithSHA384":
    case "hmacWithSHA512":
      e = e.substr(8).toLowerCase();
      break;
    default:
      var h = new Error("Unsupported PRF algorithm.");
      throw h.algorithm = e, h.supported = [
        "hmacWithSHA1",
        "hmacWithSHA224",
        "hmacWithSHA256",
        "hmacWithSHA384",
        "hmacWithSHA512"
      ], h;
  }
  if (!t || !(e in t))
    throw new Error("Unknown hash algorithm: " + e);
  return t[e].create();
}
function uI(e, t, h, o) {
  var S = ye.create(ye.Class.UNIVERSAL, ye.Type.SEQUENCE, !0, [
    // salt
    ye.create(
      ye.Class.UNIVERSAL,
      ye.Type.OCTETSTRING,
      !1,
      e
    ),
    // iteration count
    ye.create(
      ye.Class.UNIVERSAL,
      ye.Type.INTEGER,
      !1,
      t.getBytes()
    )
  ]);
  return o !== "hmacWithSHA1" && S.value.push(
    // key length
    ye.create(
      ye.Class.UNIVERSAL,
      ye.Type.INTEGER,
      !1,
      De.util.hexToBytes(h.toString(16))
    ),
    // AlgorithmIdentifier
    ye.create(ye.Class.UNIVERSAL, ye.Type.SEQUENCE, !0, [
      // algorithm
      ye.create(
        ye.Class.UNIVERSAL,
        ye.Type.OID,
        !1,
        ye.oidToDer(ft.oids[o]).getBytes()
      ),
      // parameters (null)
      ye.create(ye.Class.UNIVERSAL, ye.Type.NULL, !1, "")
    ])
  ), S;
}
var Pa = ht, Te = Pa.asn1, r0 = Pa.pkcs7asn1 = Pa.pkcs7asn1 || {};
Pa.pkcs7 = Pa.pkcs7 || {};
Pa.pkcs7.asn1 = r0;
var P2 = {
  name: "ContentInfo",
  tagClass: Te.Class.UNIVERSAL,
  type: Te.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "ContentInfo.ContentType",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.OID,
    constructed: !1,
    capture: "contentType"
  }, {
    name: "ContentInfo.content",
    tagClass: Te.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: !0,
    optional: !0,
    captureAsn1: "content"
  }]
};
r0.contentInfoValidator = P2;
var L2 = {
  name: "EncryptedContentInfo",
  tagClass: Te.Class.UNIVERSAL,
  type: Te.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "EncryptedContentInfo.contentType",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.OID,
    constructed: !1,
    capture: "contentType"
  }, {
    name: "EncryptedContentInfo.contentEncryptionAlgorithm",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
      tagClass: Te.Class.UNIVERSAL,
      type: Te.Type.OID,
      constructed: !1,
      capture: "encAlgorithm"
    }, {
      name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
      tagClass: Te.Class.UNIVERSAL,
      captureAsn1: "encParameter"
    }]
  }, {
    name: "EncryptedContentInfo.encryptedContent",
    tagClass: Te.Class.CONTEXT_SPECIFIC,
    type: 0,
    /* The PKCS#7 structure output by OpenSSL somewhat differs from what
     * other implementations do generate.
     *
     * OpenSSL generates a structure like this:
     * SEQUENCE {
     *    ...
     *    [0]
     *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *       ...
     * }
     *
     * Whereas other implementations (and this PKCS#7 module) generate:
     * SEQUENCE {
     *    ...
     *    [0] {
     *       OCTET STRING
     *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *          ...
     *    }
     * }
     *
     * In order to support both, we just capture the context specific
     * field here.  The OCTET STRING bit is removed below.
     */
    capture: "encryptedContent",
    captureAsn1: "encryptedContentAsn1"
  }]
};
r0.envelopedDataValidator = {
  name: "EnvelopedData",
  tagClass: Te.Class.UNIVERSAL,
  type: Te.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "EnvelopedData.Version",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.INTEGER,
    constructed: !1,
    capture: "version"
  }, {
    name: "EnvelopedData.RecipientInfos",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.SET,
    constructed: !0,
    captureAsn1: "recipientInfos"
  }].concat(L2)
};
r0.encryptedDataValidator = {
  name: "EncryptedData",
  tagClass: Te.Class.UNIVERSAL,
  type: Te.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "EncryptedData.Version",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.INTEGER,
    constructed: !1,
    capture: "version"
  }].concat(L2)
};
var cI = {
  name: "SignerInfo",
  tagClass: Te.Class.UNIVERSAL,
  type: Te.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "SignerInfo.version",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.INTEGER,
    constructed: !1
  }, {
    name: "SignerInfo.issuerAndSerialNumber",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "SignerInfo.issuerAndSerialNumber.issuer",
      tagClass: Te.Class.UNIVERSAL,
      type: Te.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: "issuer"
    }, {
      name: "SignerInfo.issuerAndSerialNumber.serialNumber",
      tagClass: Te.Class.UNIVERSAL,
      type: Te.Type.INTEGER,
      constructed: !1,
      capture: "serial"
    }]
  }, {
    name: "SignerInfo.digestAlgorithm",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "SignerInfo.digestAlgorithm.algorithm",
      tagClass: Te.Class.UNIVERSAL,
      type: Te.Type.OID,
      constructed: !1,
      capture: "digestAlgorithm"
    }, {
      name: "SignerInfo.digestAlgorithm.parameter",
      tagClass: Te.Class.UNIVERSAL,
      constructed: !1,
      captureAsn1: "digestParameter",
      optional: !0
    }]
  }, {
    name: "SignerInfo.authenticatedAttributes",
    tagClass: Te.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: !0,
    optional: !0,
    capture: "authenticatedAttributes"
  }, {
    name: "SignerInfo.digestEncryptionAlgorithm",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.SEQUENCE,
    constructed: !0,
    capture: "signatureAlgorithm"
  }, {
    name: "SignerInfo.encryptedDigest",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.OCTETSTRING,
    constructed: !1,
    capture: "signature"
  }, {
    name: "SignerInfo.unauthenticatedAttributes",
    tagClass: Te.Class.CONTEXT_SPECIFIC,
    type: 1,
    constructed: !0,
    optional: !0,
    capture: "unauthenticatedAttributes"
  }]
};
r0.signedDataValidator = {
  name: "SignedData",
  tagClass: Te.Class.UNIVERSAL,
  type: Te.Type.SEQUENCE,
  constructed: !0,
  value: [
    {
      name: "SignedData.Version",
      tagClass: Te.Class.UNIVERSAL,
      type: Te.Type.INTEGER,
      constructed: !1,
      capture: "version"
    },
    {
      name: "SignedData.DigestAlgorithms",
      tagClass: Te.Class.UNIVERSAL,
      type: Te.Type.SET,
      constructed: !0,
      captureAsn1: "digestAlgorithms"
    },
    P2,
    {
      name: "SignedData.Certificates",
      tagClass: Te.Class.CONTEXT_SPECIFIC,
      type: 0,
      optional: !0,
      captureAsn1: "certificates"
    },
    {
      name: "SignedData.CertificateRevocationLists",
      tagClass: Te.Class.CONTEXT_SPECIFIC,
      type: 1,
      optional: !0,
      captureAsn1: "crls"
    },
    {
      name: "SignedData.SignerInfos",
      tagClass: Te.Class.UNIVERSAL,
      type: Te.Type.SET,
      capture: "signerInfos",
      optional: !0,
      value: [cI]
    }
  ]
};
r0.recipientInfoValidator = {
  name: "RecipientInfo",
  tagClass: Te.Class.UNIVERSAL,
  type: Te.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "RecipientInfo.version",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.INTEGER,
    constructed: !1,
    capture: "version"
  }, {
    name: "RecipientInfo.issuerAndSerial",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "RecipientInfo.issuerAndSerial.issuer",
      tagClass: Te.Class.UNIVERSAL,
      type: Te.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: "issuer"
    }, {
      name: "RecipientInfo.issuerAndSerial.serialNumber",
      tagClass: Te.Class.UNIVERSAL,
      type: Te.Type.INTEGER,
      constructed: !1,
      capture: "serial"
    }]
  }, {
    name: "RecipientInfo.keyEncryptionAlgorithm",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
      tagClass: Te.Class.UNIVERSAL,
      type: Te.Type.OID,
      constructed: !1,
      capture: "encAlgorithm"
    }, {
      name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
      tagClass: Te.Class.UNIVERSAL,
      constructed: !1,
      captureAsn1: "encParameter",
      optional: !0
    }]
  }, {
    name: "RecipientInfo.encryptedKey",
    tagClass: Te.Class.UNIVERSAL,
    type: Te.Type.OCTETSTRING,
    constructed: !1,
    capture: "encKey"
  }]
};
var Yn = ht;
Yn.mgf = Yn.mgf || {};
var hI = Yn.mgf.mgf1 = Yn.mgf1 = Yn.mgf1 || {};
hI.create = function(e) {
  var t = {
    /**
     * Generate mask of specified length.
     *
     * @param {String} seed The seed for mask generation.
     * @param maskLen Number of bytes to generate.
     * @return {String} The generated mask.
     */
    generate: function(h, o) {
      for (var S = new Yn.util.ByteBuffer(), g = Math.ceil(o / e.digestLength), B = 0; B < g; B++) {
        var M = new Yn.util.ByteBuffer();
        M.putInt32(B), e.start(), e.update(h + M.getBytes()), S.putBuffer(e.digest());
      }
      return S.truncate(S.length() - o), S.getBytes();
    }
  };
  return t;
};
var Fs = ht;
Fs.mgf = Fs.mgf || {};
Fs.mgf.mgf1 = Fs.mgf1;
var Vn = ht, lI = Vn.pss = Vn.pss || {};
lI.create = function(e) {
  arguments.length === 3 && (e = {
    md: arguments[0],
    mgf: arguments[1],
    saltLength: arguments[2]
  });
  var t = e.md, h = e.mgf, o = t.digestLength, S = e.salt || null;
  typeof S == "string" && (S = Vn.util.createBuffer(S));
  var g;
  if ("saltLength" in e)
    g = e.saltLength;
  else if (S !== null)
    g = S.length();
  else
    throw new Error("Salt length not specified or specific salt not given.");
  if (S !== null && S.length() !== g)
    throw new Error("Given salt length does not match length of given salt.");
  var B = e.prng || Vn.random, M = {};
  return M.encode = function(O, P) {
    var D, Z = P - 1, Y = Math.ceil(Z / 8), ee = O.digest().getBytes();
    if (Y < o + g + 2)
      throw new Error("Message is too long to encrypt.");
    var ie;
    S === null ? ie = B.getBytesSync(g) : ie = S.bytes();
    var ue = new Vn.util.ByteBuffer();
    ue.fillWithByte(0, 8), ue.putBytes(ee), ue.putBytes(ie), t.start(), t.update(ue.getBytes());
    var fe = t.digest().getBytes(), de = new Vn.util.ByteBuffer();
    de.fillWithByte(0, Y - g - o - 2), de.putByte(1), de.putBytes(ie);
    var ce = de.getBytes(), be = Y - o - 1, ve = h.generate(fe, be), Pe = "";
    for (D = 0; D < be; D++)
      Pe += String.fromCharCode(ce.charCodeAt(D) ^ ve.charCodeAt(D));
    var Ue = 65280 >> 8 * Y - Z & 255;
    return Pe = String.fromCharCode(Pe.charCodeAt(0) & ~Ue) + Pe.substr(1), Pe + fe + "¼";
  }, M.verify = function(O, P, D) {
    var Z, Y = D - 1, ee = Math.ceil(Y / 8);
    if (P = P.substr(-ee), ee < o + g + 2)
      throw new Error("Inconsistent parameters to PSS signature verification.");
    if (P.charCodeAt(ee - 1) !== 188)
      throw new Error("Encoded message does not end in 0xBC.");
    var ie = ee - o - 1, ue = P.substr(0, ie), fe = P.substr(ie, o), de = 65280 >> 8 * ee - Y & 255;
    if (ue.charCodeAt(0) & de)
      throw new Error("Bits beyond keysize not zero as expected.");
    var ce = h.generate(fe, ie), be = "";
    for (Z = 0; Z < ie; Z++)
      be += String.fromCharCode(ue.charCodeAt(Z) ^ ce.charCodeAt(Z));
    be = String.fromCharCode(be.charCodeAt(0) & ~de) + be.substr(1);
    var ve = ee - o - g - 2;
    for (Z = 0; Z < ve; Z++)
      if (be.charCodeAt(Z) !== 0)
        throw new Error("Leftmost octets not zero as expected");
    if (be.charCodeAt(ve) !== 1)
      throw new Error("Inconsistent PSS signature, 0x01 marker not found");
    var Pe = be.substr(-g), Ue = new Vn.util.ByteBuffer();
    Ue.fillWithByte(0, 8), Ue.putBytes(O), Ue.putBytes(Pe), t.start(), t.update(Ue.getBytes());
    var ze = t.digest().getBytes();
    return fe === ze;
  }, M;
};
var Ge = ht, V = Ge.asn1, we = Ge.pki = Ge.pki || {}, bt = we.oids, Kt = {};
Kt.CN = bt.commonName;
Kt.commonName = "CN";
Kt.C = bt.countryName;
Kt.countryName = "C";
Kt.L = bt.localityName;
Kt.localityName = "L";
Kt.ST = bt.stateOrProvinceName;
Kt.stateOrProvinceName = "ST";
Kt.O = bt.organizationName;
Kt.organizationName = "O";
Kt.OU = bt.organizationalUnitName;
Kt.organizationalUnitName = "OU";
Kt.E = bt.emailAddress;
Kt.emailAddress = "E";
var k2 = Ge.pki.rsa.publicKeyValidator, dI = {
  name: "Certificate",
  tagClass: V.Class.UNIVERSAL,
  type: V.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "Certificate.TBSCertificate",
    tagClass: V.Class.UNIVERSAL,
    type: V.Type.SEQUENCE,
    constructed: !0,
    captureAsn1: "tbsCertificate",
    value: [
      {
        name: "Certificate.TBSCertificate.version",
        tagClass: V.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: !0,
        optional: !0,
        value: [{
          name: "Certificate.TBSCertificate.version.integer",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.INTEGER,
          constructed: !1,
          capture: "certVersion"
        }]
      },
      {
        name: "Certificate.TBSCertificate.serialNumber",
        tagClass: V.Class.UNIVERSAL,
        type: V.Type.INTEGER,
        constructed: !1,
        capture: "certSerialNumber"
      },
      {
        name: "Certificate.TBSCertificate.signature",
        tagClass: V.Class.UNIVERSAL,
        type: V.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "Certificate.TBSCertificate.signature.algorithm",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.OID,
          constructed: !1,
          capture: "certinfoSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: V.Class.UNIVERSAL,
          optional: !0,
          captureAsn1: "certinfoSignatureParams"
        }]
      },
      {
        name: "Certificate.TBSCertificate.issuer",
        tagClass: V.Class.UNIVERSAL,
        type: V.Type.SEQUENCE,
        constructed: !0,
        captureAsn1: "certIssuer"
      },
      {
        name: "Certificate.TBSCertificate.validity",
        tagClass: V.Class.UNIVERSAL,
        type: V.Type.SEQUENCE,
        constructed: !0,
        // Note: UTC and generalized times may both appear so the capture
        // names are based on their detected order, the names used below
        // are only for the common case, which validity time really means
        // "notBefore" and which means "notAfter" will be determined by order
        value: [{
          // notBefore (Time) (UTC time case)
          name: "Certificate.TBSCertificate.validity.notBefore (utc)",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.UTCTIME,
          constructed: !1,
          optional: !0,
          capture: "certValidity1UTCTime"
        }, {
          // notBefore (Time) (generalized time case)
          name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.GENERALIZEDTIME,
          constructed: !1,
          optional: !0,
          capture: "certValidity2GeneralizedTime"
        }, {
          // notAfter (Time) (only UTC time is supported)
          name: "Certificate.TBSCertificate.validity.notAfter (utc)",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.UTCTIME,
          constructed: !1,
          optional: !0,
          capture: "certValidity3UTCTime"
        }, {
          // notAfter (Time) (only UTC time is supported)
          name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.GENERALIZEDTIME,
          constructed: !1,
          optional: !0,
          capture: "certValidity4GeneralizedTime"
        }]
      },
      {
        // Name (subject) (RDNSequence)
        name: "Certificate.TBSCertificate.subject",
        tagClass: V.Class.UNIVERSAL,
        type: V.Type.SEQUENCE,
        constructed: !0,
        captureAsn1: "certSubject"
      },
      // SubjectPublicKeyInfo
      k2,
      {
        // issuerUniqueID (optional)
        name: "Certificate.TBSCertificate.issuerUniqueID",
        tagClass: V.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: !0,
        optional: !0,
        value: [{
          name: "Certificate.TBSCertificate.issuerUniqueID.id",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.BITSTRING,
          constructed: !1,
          // TODO: support arbitrary bit length ids
          captureBitStringValue: "certIssuerUniqueId"
        }]
      },
      {
        // subjectUniqueID (optional)
        name: "Certificate.TBSCertificate.subjectUniqueID",
        tagClass: V.Class.CONTEXT_SPECIFIC,
        type: 2,
        constructed: !0,
        optional: !0,
        value: [{
          name: "Certificate.TBSCertificate.subjectUniqueID.id",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.BITSTRING,
          constructed: !1,
          // TODO: support arbitrary bit length ids
          captureBitStringValue: "certSubjectUniqueId"
        }]
      },
      {
        // Extensions (optional)
        name: "Certificate.TBSCertificate.extensions",
        tagClass: V.Class.CONTEXT_SPECIFIC,
        type: 3,
        constructed: !0,
        captureAsn1: "certExtensions",
        optional: !0
      }
    ]
  }, {
    // AlgorithmIdentifier (signature algorithm)
    name: "Certificate.signatureAlgorithm",
    tagClass: V.Class.UNIVERSAL,
    type: V.Type.SEQUENCE,
    constructed: !0,
    value: [{
      // algorithm
      name: "Certificate.signatureAlgorithm.algorithm",
      tagClass: V.Class.UNIVERSAL,
      type: V.Type.OID,
      constructed: !1,
      capture: "certSignatureOid"
    }, {
      name: "Certificate.TBSCertificate.signature.parameters",
      tagClass: V.Class.UNIVERSAL,
      optional: !0,
      captureAsn1: "certSignatureParams"
    }]
  }, {
    // SignatureValue
    name: "Certificate.signatureValue",
    tagClass: V.Class.UNIVERSAL,
    type: V.Type.BITSTRING,
    constructed: !1,
    captureBitStringValue: "certSignature"
  }]
}, pI = {
  name: "rsapss",
  tagClass: V.Class.UNIVERSAL,
  type: V.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "rsapss.hashAlgorithm",
    tagClass: V.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: !0,
    value: [{
      name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
      tagClass: V.Class.UNIVERSAL,
      type: V.Class.SEQUENCE,
      constructed: !0,
      optional: !0,
      value: [{
        name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
        tagClass: V.Class.UNIVERSAL,
        type: V.Type.OID,
        constructed: !1,
        capture: "hashOid"
        /* parameter block omitted, for SHA1 NULL anyhow. */
      }]
    }]
  }, {
    name: "rsapss.maskGenAlgorithm",
    tagClass: V.Class.CONTEXT_SPECIFIC,
    type: 1,
    constructed: !0,
    value: [{
      name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
      tagClass: V.Class.UNIVERSAL,
      type: V.Class.SEQUENCE,
      constructed: !0,
      optional: !0,
      value: [{
        name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
        tagClass: V.Class.UNIVERSAL,
        type: V.Type.OID,
        constructed: !1,
        capture: "maskGenOid"
      }, {
        name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
        tagClass: V.Class.UNIVERSAL,
        type: V.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.OID,
          constructed: !1,
          capture: "maskGenHashOid"
          /* parameter block omitted, for SHA1 NULL anyhow. */
        }]
      }]
    }]
  }, {
    name: "rsapss.saltLength",
    tagClass: V.Class.CONTEXT_SPECIFIC,
    type: 2,
    optional: !0,
    value: [{
      name: "rsapss.saltLength.saltLength",
      tagClass: V.Class.UNIVERSAL,
      type: V.Class.INTEGER,
      constructed: !1,
      capture: "saltLength"
    }]
  }, {
    name: "rsapss.trailerField",
    tagClass: V.Class.CONTEXT_SPECIFIC,
    type: 3,
    optional: !0,
    value: [{
      name: "rsapss.trailer.trailer",
      tagClass: V.Class.UNIVERSAL,
      type: V.Class.INTEGER,
      constructed: !1,
      capture: "trailer"
    }]
  }]
}, vI = {
  name: "CertificationRequestInfo",
  tagClass: V.Class.UNIVERSAL,
  type: V.Type.SEQUENCE,
  constructed: !0,
  captureAsn1: "certificationRequestInfo",
  value: [
    {
      name: "CertificationRequestInfo.integer",
      tagClass: V.Class.UNIVERSAL,
      type: V.Type.INTEGER,
      constructed: !1,
      capture: "certificationRequestInfoVersion"
    },
    {
      // Name (subject) (RDNSequence)
      name: "CertificationRequestInfo.subject",
      tagClass: V.Class.UNIVERSAL,
      type: V.Type.SEQUENCE,
      constructed: !0,
      captureAsn1: "certificationRequestInfoSubject"
    },
    // SubjectPublicKeyInfo
    k2,
    {
      name: "CertificationRequestInfo.attributes",
      tagClass: V.Class.CONTEXT_SPECIFIC,
      type: 0,
      constructed: !0,
      optional: !0,
      capture: "certificationRequestInfoAttributes",
      value: [{
        name: "CertificationRequestInfo.attributes",
        tagClass: V.Class.UNIVERSAL,
        type: V.Type.SEQUENCE,
        constructed: !0,
        value: [{
          name: "CertificationRequestInfo.attributes.type",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.OID,
          constructed: !1
        }, {
          name: "CertificationRequestInfo.attributes.value",
          tagClass: V.Class.UNIVERSAL,
          type: V.Type.SET,
          constructed: !0
        }]
      }]
    }
  ]
}, yI = {
  name: "CertificationRequest",
  tagClass: V.Class.UNIVERSAL,
  type: V.Type.SEQUENCE,
  constructed: !0,
  captureAsn1: "csr",
  value: [
    vI,
    {
      // AlgorithmIdentifier (signature algorithm)
      name: "CertificationRequest.signatureAlgorithm",
      tagClass: V.Class.UNIVERSAL,
      type: V.Type.SEQUENCE,
      constructed: !0,
      value: [{
        // algorithm
        name: "CertificationRequest.signatureAlgorithm.algorithm",
        tagClass: V.Class.UNIVERSAL,
        type: V.Type.OID,
        constructed: !1,
        capture: "csrSignatureOid"
      }, {
        name: "CertificationRequest.signatureAlgorithm.parameters",
        tagClass: V.Class.UNIVERSAL,
        optional: !0,
        captureAsn1: "csrSignatureParams"
      }]
    },
    {
      // signature
      name: "CertificationRequest.signature",
      tagClass: V.Class.UNIVERSAL,
      type: V.Type.BITSTRING,
      constructed: !1,
      captureBitStringValue: "csrSignature"
    }
  ]
};
we.RDNAttributesAsArray = function(e, t) {
  for (var h = [], o, S, g, B = 0; B < e.value.length; ++B) {
    o = e.value[B];
    for (var M = 0; M < o.value.length; ++M)
      g = {}, S = o.value[M], g.type = V.derToOid(S.value[0].value), g.value = S.value[1].value, g.valueTagClass = S.value[1].type, g.type in bt && (g.name = bt[g.type], g.name in Kt && (g.shortName = Kt[g.name])), t && (t.update(g.type), t.update(g.value)), h.push(g);
  }
  return h;
};
we.CRIAttributesAsArray = function(e) {
  for (var t = [], h = 0; h < e.length; ++h)
    for (var o = e[h], S = V.derToOid(o.value[0].value), g = o.value[1].value, B = 0; B < g.length; ++B) {
      var M = {};
      if (M.type = S, M.value = g[B].value, M.valueTagClass = g[B].type, M.type in bt && (M.name = bt[M.type], M.name in Kt && (M.shortName = Kt[M.name])), M.type === bt.extensionRequest) {
        M.extensions = [];
        for (var O = 0; O < M.value.length; ++O)
          M.extensions.push(we.certificateExtensionFromAsn1(M.value[O]));
      }
      t.push(M);
    }
  return t;
};
function Bn(e, t) {
  typeof t == "string" && (t = { shortName: t });
  for (var h = null, o, S = 0; h === null && S < e.attributes.length; ++S)
    o = e.attributes[S], (t.type && t.type === o.type || t.name && t.name === o.name || t.shortName && t.shortName === o.shortName) && (h = o);
  return h;
}
var qs = function(e, t, h) {
  var o = {};
  if (e !== bt["RSASSA-PSS"])
    return o;
  h && (o = {
    hash: {
      algorithmOid: bt.sha1
    },
    mgf: {
      algorithmOid: bt.mgf1,
      hash: {
        algorithmOid: bt.sha1
      }
    },
    saltLength: 20
  });
  var S = {}, g = [];
  if (!V.validate(t, pI, S, g)) {
    var B = new Error("Cannot read RSASSA-PSS parameter block.");
    throw B.errors = g, B;
  }
  return S.hashOid !== void 0 && (o.hash = o.hash || {}, o.hash.algorithmOid = V.derToOid(S.hashOid)), S.maskGenOid !== void 0 && (o.mgf = o.mgf || {}, o.mgf.algorithmOid = V.derToOid(S.maskGenOid), o.mgf.hash = o.mgf.hash || {}, o.mgf.hash.algorithmOid = V.derToOid(S.maskGenHashOid)), S.saltLength !== void 0 && (o.saltLength = S.saltLength.charCodeAt(0)), o;
}, Vf = function(e) {
  switch (bt[e.signatureOid]) {
    case "sha1WithRSAEncryption":
    case "sha1WithRSASignature":
      return Ge.md.sha1.create();
    case "md5WithRSAEncryption":
      return Ge.md.md5.create();
    case "sha256WithRSAEncryption":
      return Ge.md.sha256.create();
    case "sha384WithRSAEncryption":
      return Ge.md.sha384.create();
    case "sha512WithRSAEncryption":
      return Ge.md.sha512.create();
    case "RSASSA-PSS":
      return Ge.md.sha256.create();
    default:
      var t = new Error(
        "Could not compute " + e.type + " digest. Unknown signature OID."
      );
      throw t.signatureOid = e.signatureOid, t;
  }
}, U2 = function(e) {
  var t = e.certificate, h;
  switch (t.signatureOid) {
    case bt.sha1WithRSAEncryption:
    case bt.sha1WithRSASignature:
      break;
    case bt["RSASSA-PSS"]:
      var o, S;
      if (o = bt[t.signatureParameters.mgf.hash.algorithmOid], o === void 0 || Ge.md[o] === void 0) {
        var g = new Error("Unsupported MGF hash function.");
        throw g.oid = t.signatureParameters.mgf.hash.algorithmOid, g.name = o, g;
      }
      if (S = bt[t.signatureParameters.mgf.algorithmOid], S === void 0 || Ge.mgf[S] === void 0) {
        var g = new Error("Unsupported MGF function.");
        throw g.oid = t.signatureParameters.mgf.algorithmOid, g.name = S, g;
      }
      if (S = Ge.mgf[S].create(Ge.md[o].create()), o = bt[t.signatureParameters.hash.algorithmOid], o === void 0 || Ge.md[o] === void 0) {
        var g = new Error("Unsupported RSASSA-PSS hash function.");
        throw g.oid = t.signatureParameters.hash.algorithmOid, g.name = o, g;
      }
      h = Ge.pss.create(
        Ge.md[o].create(),
        S,
        t.signatureParameters.saltLength
      );
      break;
  }
  return t.publicKey.verify(
    e.md.digest().getBytes(),
    e.signature,
    h
  );
};
we.certificateFromPem = function(e, t, h) {
  var o = Ge.pem.decode(e)[0];
  if (o.type !== "CERTIFICATE" && o.type !== "X509 CERTIFICATE" && o.type !== "TRUSTED CERTIFICATE") {
    var S = new Error(
      'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
    );
    throw S.headerType = o.type, S;
  }
  if (o.procType && o.procType.type === "ENCRYPTED")
    throw new Error(
      "Could not convert certificate from PEM; PEM is encrypted."
    );
  var g = V.fromDer(o.body, h);
  return we.certificateFromAsn1(g, t);
};
we.certificateToPem = function(e, t) {
  var h = {
    type: "CERTIFICATE",
    body: V.toDer(we.certificateToAsn1(e)).getBytes()
  };
  return Ge.pem.encode(h, { maxline: t });
};
we.publicKeyFromPem = function(e) {
  var t = Ge.pem.decode(e)[0];
  if (t.type !== "PUBLIC KEY" && t.type !== "RSA PUBLIC KEY") {
    var h = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
    throw h.headerType = t.type, h;
  }
  if (t.procType && t.procType.type === "ENCRYPTED")
    throw new Error("Could not convert public key from PEM; PEM is encrypted.");
  var o = V.fromDer(t.body);
  return we.publicKeyFromAsn1(o);
};
we.publicKeyToPem = function(e, t) {
  var h = {
    type: "PUBLIC KEY",
    body: V.toDer(we.publicKeyToAsn1(e)).getBytes()
  };
  return Ge.pem.encode(h, { maxline: t });
};
we.publicKeyToRSAPublicKeyPem = function(e, t) {
  var h = {
    type: "RSA PUBLIC KEY",
    body: V.toDer(we.publicKeyToRSAPublicKey(e)).getBytes()
  };
  return Ge.pem.encode(h, { maxline: t });
};
we.getPublicKeyFingerprint = function(e, t) {
  t = t || {};
  var h = t.md || Ge.md.sha1.create(), o = t.type || "RSAPublicKey", S;
  switch (o) {
    case "RSAPublicKey":
      S = V.toDer(we.publicKeyToRSAPublicKey(e)).getBytes();
      break;
    case "SubjectPublicKeyInfo":
      S = V.toDer(we.publicKeyToAsn1(e)).getBytes();
      break;
    default:
      throw new Error('Unknown fingerprint type "' + t.type + '".');
  }
  h.start(), h.update(S);
  var g = h.digest();
  if (t.encoding === "hex") {
    var B = g.toHex();
    return t.delimiter ? B.match(/.{2}/g).join(t.delimiter) : B;
  } else {
    if (t.encoding === "binary")
      return g.getBytes();
    if (t.encoding)
      throw new Error('Unknown encoding "' + t.encoding + '".');
  }
  return g;
};
we.certificationRequestFromPem = function(e, t, h) {
  var o = Ge.pem.decode(e)[0];
  if (o.type !== "CERTIFICATE REQUEST") {
    var S = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
    throw S.headerType = o.type, S;
  }
  if (o.procType && o.procType.type === "ENCRYPTED")
    throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
  var g = V.fromDer(o.body, h);
  return we.certificationRequestFromAsn1(g, t);
};
we.certificationRequestToPem = function(e, t) {
  var h = {
    type: "CERTIFICATE REQUEST",
    body: V.toDer(we.certificationRequestToAsn1(e)).getBytes()
  };
  return Ge.pem.encode(h, { maxline: t });
};
we.createCertificate = function() {
  var e = {};
  return e.version = 2, e.serialNumber = "00", e.signatureOid = null, e.signature = null, e.siginfo = {}, e.siginfo.algorithmOid = null, e.validity = {}, e.validity.notBefore = /* @__PURE__ */ new Date(), e.validity.notAfter = /* @__PURE__ */ new Date(), e.issuer = {}, e.issuer.getField = function(t) {
    return Bn(e.issuer, t);
  }, e.issuer.addField = function(t) {
    Gr([t]), e.issuer.attributes.push(t);
  }, e.issuer.attributes = [], e.issuer.hash = null, e.subject = {}, e.subject.getField = function(t) {
    return Bn(e.subject, t);
  }, e.subject.addField = function(t) {
    Gr([t]), e.subject.attributes.push(t);
  }, e.subject.attributes = [], e.subject.hash = null, e.extensions = [], e.publicKey = null, e.md = null, e.setSubject = function(t, h) {
    Gr(t), e.subject.attributes = t, delete e.subject.uniqueId, h && (e.subject.uniqueId = h), e.subject.hash = null;
  }, e.setIssuer = function(t, h) {
    Gr(t), e.issuer.attributes = t, delete e.issuer.uniqueId, h && (e.issuer.uniqueId = h), e.issuer.hash = null;
  }, e.setExtensions = function(t) {
    for (var h = 0; h < t.length; ++h)
      F2(t[h], { cert: e });
    e.extensions = t;
  }, e.getExtension = function(t) {
    typeof t == "string" && (t = { name: t });
    for (var h = null, o, S = 0; h === null && S < e.extensions.length; ++S)
      o = e.extensions[S], (t.id && o.id === t.id || t.name && o.name === t.name) && (h = o);
    return h;
  }, e.sign = function(t, h) {
    e.md = h || Ge.md.sha1.create();
    var o = bt[e.md.algorithm + "WithRSAEncryption"];
    if (!o) {
      var S = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
      throw S.algorithm = e.md.algorithm, S;
    }
    e.signatureOid = e.siginfo.algorithmOid = o, e.tbsCertificate = we.getTBSCertificate(e);
    var g = V.toDer(e.tbsCertificate);
    e.md.update(g.getBytes()), e.signature = t.sign(e.md);
  }, e.verify = function(t) {
    var h = !1;
    if (!e.issued(t)) {
      var o = t.issuer, S = e.subject, g = new Error(
        "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
      );
      throw g.expectedIssuer = S.attributes, g.actualIssuer = o.attributes, g;
    }
    var B = t.md;
    if (B === null) {
      B = Vf({
        signatureOid: t.signatureOid,
        type: "certificate"
      });
      var M = t.tbsCertificate || we.getTBSCertificate(t), O = V.toDer(M);
      B.update(O.getBytes());
    }
    return B !== null && (h = U2({
      certificate: e,
      md: B,
      signature: t.signature
    })), h;
  }, e.isIssuer = function(t) {
    var h = !1, o = e.issuer, S = t.subject;
    if (o.hash && S.hash)
      h = o.hash === S.hash;
    else if (o.attributes.length === S.attributes.length) {
      h = !0;
      for (var g, B, M = 0; h && M < o.attributes.length; ++M)
        g = o.attributes[M], B = S.attributes[M], (g.type !== B.type || g.value !== B.value) && (h = !1);
    }
    return h;
  }, e.issued = function(t) {
    return t.isIssuer(e);
  }, e.generateSubjectKeyIdentifier = function() {
    return we.getPublicKeyFingerprint(e.publicKey, { type: "RSAPublicKey" });
  }, e.verifySubjectKeyIdentifier = function() {
    for (var t = bt.subjectKeyIdentifier, h = 0; h < e.extensions.length; ++h) {
      var o = e.extensions[h];
      if (o.id === t) {
        var S = e.generateSubjectKeyIdentifier().getBytes();
        return Ge.util.hexToBytes(o.subjectKeyIdentifier) === S;
      }
    }
    return !1;
  }, e;
};
we.certificateFromAsn1 = function(e, t) {
  var h = {}, o = [];
  if (!V.validate(e, dI, h, o)) {
    var S = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
    throw S.errors = o, S;
  }
  var g = V.derToOid(h.publicKeyOid);
  if (g !== we.oids.rsaEncryption)
    throw new Error("Cannot read public key. OID is not RSA.");
  var B = we.createCertificate();
  B.version = h.certVersion ? h.certVersion.charCodeAt(0) : 0;
  var M = Ge.util.createBuffer(h.certSerialNumber);
  B.serialNumber = M.toHex(), B.signatureOid = Ge.asn1.derToOid(h.certSignatureOid), B.signatureParameters = qs(
    B.signatureOid,
    h.certSignatureParams,
    !0
  ), B.siginfo.algorithmOid = Ge.asn1.derToOid(h.certinfoSignatureOid), B.siginfo.parameters = qs(
    B.siginfo.algorithmOid,
    h.certinfoSignatureParams,
    !1
  ), B.signature = h.certSignature;
  var O = [];
  if (h.certValidity1UTCTime !== void 0 && O.push(V.utcTimeToDate(h.certValidity1UTCTime)), h.certValidity2GeneralizedTime !== void 0 && O.push(V.generalizedTimeToDate(
    h.certValidity2GeneralizedTime
  )), h.certValidity3UTCTime !== void 0 && O.push(V.utcTimeToDate(h.certValidity3UTCTime)), h.certValidity4GeneralizedTime !== void 0 && O.push(V.generalizedTimeToDate(
    h.certValidity4GeneralizedTime
  )), O.length > 2)
    throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
  if (O.length < 2)
    throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
  if (B.validity.notBefore = O[0], B.validity.notAfter = O[1], B.tbsCertificate = h.tbsCertificate, t) {
    B.md = Vf({
      signatureOid: B.signatureOid,
      type: "certificate"
    });
    var P = V.toDer(B.tbsCertificate);
    B.md.update(P.getBytes());
  }
  var D = Ge.md.sha1.create(), Z = V.toDer(h.certIssuer);
  D.update(Z.getBytes()), B.issuer.getField = function(ie) {
    return Bn(B.issuer, ie);
  }, B.issuer.addField = function(ie) {
    Gr([ie]), B.issuer.attributes.push(ie);
  }, B.issuer.attributes = we.RDNAttributesAsArray(h.certIssuer), h.certIssuerUniqueId && (B.issuer.uniqueId = h.certIssuerUniqueId), B.issuer.hash = D.digest().toHex();
  var Y = Ge.md.sha1.create(), ee = V.toDer(h.certSubject);
  return Y.update(ee.getBytes()), B.subject.getField = function(ie) {
    return Bn(B.subject, ie);
  }, B.subject.addField = function(ie) {
    Gr([ie]), B.subject.attributes.push(ie);
  }, B.subject.attributes = we.RDNAttributesAsArray(h.certSubject), h.certSubjectUniqueId && (B.subject.uniqueId = h.certSubjectUniqueId), B.subject.hash = Y.digest().toHex(), h.certExtensions ? B.extensions = we.certificateExtensionsFromAsn1(h.certExtensions) : B.extensions = [], B.publicKey = we.publicKeyFromAsn1(h.subjectPublicKeyInfo), B;
};
we.certificateExtensionsFromAsn1 = function(e) {
  for (var t = [], h = 0; h < e.value.length; ++h)
    for (var o = e.value[h], S = 0; S < o.value.length; ++S)
      t.push(we.certificateExtensionFromAsn1(o.value[S]));
  return t;
};
we.certificateExtensionFromAsn1 = function(e) {
  var t = {};
  if (t.id = V.derToOid(e.value[0].value), t.critical = !1, e.value[1].type === V.Type.BOOLEAN ? (t.critical = e.value[1].value.charCodeAt(0) !== 0, t.value = e.value[2].value) : t.value = e.value[1].value, t.id in bt) {
    if (t.name = bt[t.id], t.name === "keyUsage") {
      var h = V.fromDer(t.value), o = 0, S = 0;
      h.value.length > 1 && (o = h.value.charCodeAt(1), S = h.value.length > 2 ? h.value.charCodeAt(2) : 0), t.digitalSignature = (o & 128) === 128, t.nonRepudiation = (o & 64) === 64, t.keyEncipherment = (o & 32) === 32, t.dataEncipherment = (o & 16) === 16, t.keyAgreement = (o & 8) === 8, t.keyCertSign = (o & 4) === 4, t.cRLSign = (o & 2) === 2, t.encipherOnly = (o & 1) === 1, t.decipherOnly = (S & 128) === 128;
    } else if (t.name === "basicConstraints") {
      var h = V.fromDer(t.value);
      h.value.length > 0 && h.value[0].type === V.Type.BOOLEAN ? t.cA = h.value[0].value.charCodeAt(0) !== 0 : t.cA = !1;
      var g = null;
      h.value.length > 0 && h.value[0].type === V.Type.INTEGER ? g = h.value[0].value : h.value.length > 1 && (g = h.value[1].value), g !== null && (t.pathLenConstraint = V.derToInteger(g));
    } else if (t.name === "extKeyUsage")
      for (var h = V.fromDer(t.value), B = 0; B < h.value.length; ++B) {
        var M = V.derToOid(h.value[B].value);
        M in bt ? t[bt[M]] = !0 : t[M] = !0;
      }
    else if (t.name === "nsCertType") {
      var h = V.fromDer(t.value), o = 0;
      h.value.length > 1 && (o = h.value.charCodeAt(1)), t.client = (o & 128) === 128, t.server = (o & 64) === 64, t.email = (o & 32) === 32, t.objsign = (o & 16) === 16, t.reserved = (o & 8) === 8, t.sslCA = (o & 4) === 4, t.emailCA = (o & 2) === 2, t.objCA = (o & 1) === 1;
    } else if (t.name === "subjectAltName" || t.name === "issuerAltName") {
      t.altNames = [];
      for (var O, h = V.fromDer(t.value), P = 0; P < h.value.length; ++P) {
        O = h.value[P];
        var D = {
          type: O.type,
          value: O.value
        };
        switch (t.altNames.push(D), O.type) {
          case 1:
          case 2:
          case 6:
            break;
          case 7:
            D.ip = Ge.util.bytesToIP(O.value);
            break;
          case 8:
            D.oid = V.derToOid(O.value);
            break;
        }
      }
    } else if (t.name === "subjectKeyIdentifier") {
      var h = V.fromDer(t.value);
      t.subjectKeyIdentifier = Ge.util.bytesToHex(h.value);
    }
  }
  return t;
};
we.certificationRequestFromAsn1 = function(e, t) {
  var h = {}, o = [];
  if (!V.validate(e, yI, h, o)) {
    var S = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
    throw S.errors = o, S;
  }
  var g = V.derToOid(h.publicKeyOid);
  if (g !== we.oids.rsaEncryption)
    throw new Error("Cannot read public key. OID is not RSA.");
  var B = we.createCertificationRequest();
  if (B.version = h.csrVersion ? h.csrVersion.charCodeAt(0) : 0, B.signatureOid = Ge.asn1.derToOid(h.csrSignatureOid), B.signatureParameters = qs(
    B.signatureOid,
    h.csrSignatureParams,
    !0
  ), B.siginfo.algorithmOid = Ge.asn1.derToOid(h.csrSignatureOid), B.siginfo.parameters = qs(
    B.siginfo.algorithmOid,
    h.csrSignatureParams,
    !1
  ), B.signature = h.csrSignature, B.certificationRequestInfo = h.certificationRequestInfo, t) {
    B.md = Vf({
      signatureOid: B.signatureOid,
      type: "certification request"
    });
    var M = V.toDer(B.certificationRequestInfo);
    B.md.update(M.getBytes());
  }
  var O = Ge.md.sha1.create();
  return B.subject.getField = function(P) {
    return Bn(B.subject, P);
  }, B.subject.addField = function(P) {
    Gr([P]), B.subject.attributes.push(P);
  }, B.subject.attributes = we.RDNAttributesAsArray(
    h.certificationRequestInfoSubject,
    O
  ), B.subject.hash = O.digest().toHex(), B.publicKey = we.publicKeyFromAsn1(h.subjectPublicKeyInfo), B.getAttribute = function(P) {
    return Bn(B, P);
  }, B.addAttribute = function(P) {
    Gr([P]), B.attributes.push(P);
  }, B.attributes = we.CRIAttributesAsArray(
    h.certificationRequestInfoAttributes || []
  ), B;
};
we.createCertificationRequest = function() {
  var e = {};
  return e.version = 0, e.signatureOid = null, e.signature = null, e.siginfo = {}, e.siginfo.algorithmOid = null, e.subject = {}, e.subject.getField = function(t) {
    return Bn(e.subject, t);
  }, e.subject.addField = function(t) {
    Gr([t]), e.subject.attributes.push(t);
  }, e.subject.attributes = [], e.subject.hash = null, e.publicKey = null, e.attributes = [], e.getAttribute = function(t) {
    return Bn(e, t);
  }, e.addAttribute = function(t) {
    Gr([t]), e.attributes.push(t);
  }, e.md = null, e.setSubject = function(t) {
    Gr(t), e.subject.attributes = t, e.subject.hash = null;
  }, e.setAttributes = function(t) {
    Gr(t), e.attributes = t;
  }, e.sign = function(t, h) {
    e.md = h || Ge.md.sha1.create();
    var o = bt[e.md.algorithm + "WithRSAEncryption"];
    if (!o) {
      var S = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
      throw S.algorithm = e.md.algorithm, S;
    }
    e.signatureOid = e.siginfo.algorithmOid = o, e.certificationRequestInfo = we.getCertificationRequestInfo(e);
    var g = V.toDer(e.certificationRequestInfo);
    e.md.update(g.getBytes()), e.signature = t.sign(e.md);
  }, e.verify = function() {
    var t = !1, h = e.md;
    if (h === null) {
      h = Vf({
        signatureOid: e.signatureOid,
        type: "certification request"
      });
      var o = e.certificationRequestInfo || we.getCertificationRequestInfo(e), S = V.toDer(o);
      h.update(S.getBytes());
    }
    return h !== null && (t = U2({
      certificate: e,
      md: h,
      signature: e.signature
    })), t;
  }, e;
};
function La(e) {
  for (var t = V.create(
    V.Class.UNIVERSAL,
    V.Type.SEQUENCE,
    !0,
    []
  ), h, o, S = e.attributes, g = 0; g < S.length; ++g) {
    h = S[g];
    var B = h.value, M = V.Type.PRINTABLESTRING;
    "valueTagClass" in h && (M = h.valueTagClass, M === V.Type.UTF8 && (B = Ge.util.encodeUtf8(B))), o = V.create(V.Class.UNIVERSAL, V.Type.SET, !0, [
      V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
        // AttributeType
        V.create(
          V.Class.UNIVERSAL,
          V.Type.OID,
          !1,
          V.oidToDer(h.type).getBytes()
        ),
        // AttributeValue
        V.create(V.Class.UNIVERSAL, M, !1, B)
      ])
    ]), t.value.push(o);
  }
  return t;
}
function Gr(e) {
  for (var t, h = 0; h < e.length; ++h) {
    if (t = e[h], typeof t.name > "u" && (t.type && t.type in we.oids ? t.name = we.oids[t.type] : t.shortName && t.shortName in Kt && (t.name = we.oids[Kt[t.shortName]])), typeof t.type > "u")
      if (t.name && t.name in we.oids)
        t.type = we.oids[t.name];
      else {
        var o = new Error("Attribute type not specified.");
        throw o.attribute = t, o;
      }
    if (typeof t.shortName > "u" && t.name && t.name in Kt && (t.shortName = Kt[t.name]), t.type === bt.extensionRequest && (t.valueConstructed = !0, t.valueTagClass = V.Type.SEQUENCE, !t.value && t.extensions)) {
      t.value = [];
      for (var S = 0; S < t.extensions.length; ++S)
        t.value.push(we.certificateExtensionToAsn1(
          F2(t.extensions[S])
        ));
    }
    if (typeof t.value > "u") {
      var o = new Error("Attribute value not specified.");
      throw o.attribute = t, o;
    }
  }
}
function F2(e, t) {
  if (t = t || {}, typeof e.name > "u" && e.id && e.id in we.oids && (e.name = we.oids[e.id]), typeof e.id > "u")
    if (e.name && e.name in we.oids)
      e.id = we.oids[e.name];
    else {
      var h = new Error("Extension ID not specified.");
      throw h.extension = e, h;
    }
  if (typeof e.value < "u")
    return e;
  if (e.name === "keyUsage") {
    var o = 0, S = 0, g = 0;
    e.digitalSignature && (S |= 128, o = 7), e.nonRepudiation && (S |= 64, o = 6), e.keyEncipherment && (S |= 32, o = 5), e.dataEncipherment && (S |= 16, o = 4), e.keyAgreement && (S |= 8, o = 3), e.keyCertSign && (S |= 4, o = 2), e.cRLSign && (S |= 2, o = 1), e.encipherOnly && (S |= 1, o = 0), e.decipherOnly && (g |= 128, o = 7);
    var B = String.fromCharCode(o);
    g !== 0 ? B += String.fromCharCode(S) + String.fromCharCode(g) : S !== 0 && (B += String.fromCharCode(S)), e.value = V.create(
      V.Class.UNIVERSAL,
      V.Type.BITSTRING,
      !1,
      B
    );
  } else if (e.name === "basicConstraints")
    e.value = V.create(
      V.Class.UNIVERSAL,
      V.Type.SEQUENCE,
      !0,
      []
    ), e.cA && e.value.value.push(V.create(
      V.Class.UNIVERSAL,
      V.Type.BOOLEAN,
      !1,
      "ÿ"
    )), "pathLenConstraint" in e && e.value.value.push(V.create(
      V.Class.UNIVERSAL,
      V.Type.INTEGER,
      !1,
      V.integerToDer(e.pathLenConstraint).getBytes()
    ));
  else if (e.name === "extKeyUsage") {
    e.value = V.create(
      V.Class.UNIVERSAL,
      V.Type.SEQUENCE,
      !0,
      []
    );
    var M = e.value.value;
    for (var O in e)
      e[O] === !0 && (O in bt ? M.push(V.create(
        V.Class.UNIVERSAL,
        V.Type.OID,
        !1,
        V.oidToDer(bt[O]).getBytes()
      )) : O.indexOf(".") !== -1 && M.push(V.create(
        V.Class.UNIVERSAL,
        V.Type.OID,
        !1,
        V.oidToDer(O).getBytes()
      )));
  } else if (e.name === "nsCertType") {
    var o = 0, S = 0;
    e.client && (S |= 128, o = 7), e.server && (S |= 64, o = 6), e.email && (S |= 32, o = 5), e.objsign && (S |= 16, o = 4), e.reserved && (S |= 8, o = 3), e.sslCA && (S |= 4, o = 2), e.emailCA && (S |= 2, o = 1), e.objCA && (S |= 1, o = 0);
    var B = String.fromCharCode(o);
    S !== 0 && (B += String.fromCharCode(S)), e.value = V.create(
      V.Class.UNIVERSAL,
      V.Type.BITSTRING,
      !1,
      B
    );
  } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
    e.value = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, []);
    for (var P, D = 0; D < e.altNames.length; ++D) {
      P = e.altNames[D];
      var B = P.value;
      if (P.type === 7 && P.ip) {
        if (B = Ge.util.bytesFromIP(P.ip), B === null) {
          var h = new Error(
            'Extension "ip" value is not a valid IPv4 or IPv6 address.'
          );
          throw h.extension = e, h;
        }
      } else
        P.type === 8 && (P.oid ? B = V.oidToDer(V.oidToDer(P.oid)) : B = V.oidToDer(B));
      e.value.value.push(V.create(
        V.Class.CONTEXT_SPECIFIC,
        P.type,
        !1,
        B
      ));
    }
  } else if (e.name === "nsComment" && t.cert) {
    if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128)
      throw new Error('Invalid "nsComment" content.');
    e.value = V.create(
      V.Class.UNIVERSAL,
      V.Type.IA5STRING,
      !1,
      e.comment
    );
  } else if (e.name === "subjectKeyIdentifier" && t.cert) {
    var Z = t.cert.generateSubjectKeyIdentifier();
    e.subjectKeyIdentifier = Z.toHex(), e.value = V.create(
      V.Class.UNIVERSAL,
      V.Type.OCTETSTRING,
      !1,
      Z.getBytes()
    );
  } else if (e.name === "authorityKeyIdentifier" && t.cert) {
    e.value = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, []);
    var M = e.value.value;
    if (e.keyIdentifier) {
      var Y = e.keyIdentifier === !0 ? t.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
      M.push(
        V.create(V.Class.CONTEXT_SPECIFIC, 0, !1, Y)
      );
    }
    if (e.authorityCertIssuer) {
      var ee = [
        V.create(V.Class.CONTEXT_SPECIFIC, 4, !0, [
          La(e.authorityCertIssuer === !0 ? t.cert.issuer : e.authorityCertIssuer)
        ])
      ];
      M.push(
        V.create(V.Class.CONTEXT_SPECIFIC, 1, !0, ee)
      );
    }
    if (e.serialNumber) {
      var ie = Ge.util.hexToBytes(e.serialNumber === !0 ? t.cert.serialNumber : e.serialNumber);
      M.push(
        V.create(V.Class.CONTEXT_SPECIFIC, 2, !1, ie)
      );
    }
  } else if (e.name === "cRLDistributionPoints") {
    e.value = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, []);
    for (var M = e.value.value, ue = V.create(
      V.Class.UNIVERSAL,
      V.Type.SEQUENCE,
      !0,
      []
    ), fe = V.create(
      V.Class.CONTEXT_SPECIFIC,
      0,
      !0,
      []
    ), P, D = 0; D < e.altNames.length; ++D) {
      P = e.altNames[D];
      var B = P.value;
      if (P.type === 7 && P.ip) {
        if (B = Ge.util.bytesFromIP(P.ip), B === null) {
          var h = new Error(
            'Extension "ip" value is not a valid IPv4 or IPv6 address.'
          );
          throw h.extension = e, h;
        }
      } else
        P.type === 8 && (P.oid ? B = V.oidToDer(V.oidToDer(P.oid)) : B = V.oidToDer(B));
      fe.value.push(V.create(
        V.Class.CONTEXT_SPECIFIC,
        P.type,
        !1,
        B
      ));
    }
    ue.value.push(V.create(
      V.Class.CONTEXT_SPECIFIC,
      0,
      !0,
      [fe]
    )), M.push(ue);
  }
  if (typeof e.value > "u") {
    var h = new Error("Extension value not specified.");
    throw h.extension = e, h;
  }
  return e;
}
function Kh(e, t) {
  switch (e) {
    case bt["RSASSA-PSS"]:
      var h = [];
      return t.hash.algorithmOid !== void 0 && h.push(V.create(V.Class.CONTEXT_SPECIFIC, 0, !0, [
        V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
          V.create(
            V.Class.UNIVERSAL,
            V.Type.OID,
            !1,
            V.oidToDer(t.hash.algorithmOid).getBytes()
          ),
          V.create(V.Class.UNIVERSAL, V.Type.NULL, !1, "")
        ])
      ])), t.mgf.algorithmOid !== void 0 && h.push(V.create(V.Class.CONTEXT_SPECIFIC, 1, !0, [
        V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
          V.create(
            V.Class.UNIVERSAL,
            V.Type.OID,
            !1,
            V.oidToDer(t.mgf.algorithmOid).getBytes()
          ),
          V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
            V.create(
              V.Class.UNIVERSAL,
              V.Type.OID,
              !1,
              V.oidToDer(t.mgf.hash.algorithmOid).getBytes()
            ),
            V.create(V.Class.UNIVERSAL, V.Type.NULL, !1, "")
          ])
        ])
      ])), t.saltLength !== void 0 && h.push(V.create(V.Class.CONTEXT_SPECIFIC, 2, !0, [
        V.create(
          V.Class.UNIVERSAL,
          V.Type.INTEGER,
          !1,
          V.integerToDer(t.saltLength).getBytes()
        )
      ])), V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, h);
    default:
      return V.create(V.Class.UNIVERSAL, V.Type.NULL, !1, "");
  }
}
function gI(e) {
  var t = V.create(V.Class.CONTEXT_SPECIFIC, 0, !0, []);
  if (e.attributes.length === 0)
    return t;
  for (var h = e.attributes, o = 0; o < h.length; ++o) {
    var S = h[o], g = S.value, B = V.Type.UTF8;
    "valueTagClass" in S && (B = S.valueTagClass), B === V.Type.UTF8 && (g = Ge.util.encodeUtf8(g));
    var M = !1;
    "valueConstructed" in S && (M = S.valueConstructed);
    var O = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
      // AttributeType
      V.create(
        V.Class.UNIVERSAL,
        V.Type.OID,
        !1,
        V.oidToDer(S.type).getBytes()
      ),
      V.create(V.Class.UNIVERSAL, V.Type.SET, !0, [
        // AttributeValue
        V.create(
          V.Class.UNIVERSAL,
          B,
          M,
          g
        )
      ])
    ]);
    t.value.push(O);
  }
  return t;
}
var mI = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z"), bI = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
function zp(e) {
  return e >= mI && e < bI ? V.create(
    V.Class.UNIVERSAL,
    V.Type.UTCTIME,
    !1,
    V.dateToUtcTime(e)
  ) : V.create(
    V.Class.UNIVERSAL,
    V.Type.GENERALIZEDTIME,
    !1,
    V.dateToGeneralizedTime(e)
  );
}
we.getTBSCertificate = function(e) {
  var t = zp(e.validity.notBefore), h = zp(e.validity.notAfter), o = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
    // version
    V.create(V.Class.CONTEXT_SPECIFIC, 0, !0, [
      // integer
      V.create(
        V.Class.UNIVERSAL,
        V.Type.INTEGER,
        !1,
        V.integerToDer(e.version).getBytes()
      )
    ]),
    // serialNumber
    V.create(
      V.Class.UNIVERSAL,
      V.Type.INTEGER,
      !1,
      Ge.util.hexToBytes(e.serialNumber)
    ),
    // signature
    V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
      // algorithm
      V.create(
        V.Class.UNIVERSAL,
        V.Type.OID,
        !1,
        V.oidToDer(e.siginfo.algorithmOid).getBytes()
      ),
      // parameters
      Kh(
        e.siginfo.algorithmOid,
        e.siginfo.parameters
      )
    ]),
    // issuer
    La(e.issuer),
    // validity
    V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
      t,
      h
    ]),
    // subject
    La(e.subject),
    // SubjectPublicKeyInfo
    we.publicKeyToAsn1(e.publicKey)
  ]);
  return e.issuer.uniqueId && o.value.push(
    V.create(V.Class.CONTEXT_SPECIFIC, 1, !0, [
      V.create(
        V.Class.UNIVERSAL,
        V.Type.BITSTRING,
        !1,
        // TODO: support arbitrary bit length ids
        "\0" + e.issuer.uniqueId
      )
    ])
  ), e.subject.uniqueId && o.value.push(
    V.create(V.Class.CONTEXT_SPECIFIC, 2, !0, [
      V.create(
        V.Class.UNIVERSAL,
        V.Type.BITSTRING,
        !1,
        // TODO: support arbitrary bit length ids
        "\0" + e.subject.uniqueId
      )
    ])
  ), e.extensions.length > 0 && o.value.push(we.certificateExtensionsToAsn1(e.extensions)), o;
};
we.getCertificationRequestInfo = function(e) {
  var t = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
    // version
    V.create(
      V.Class.UNIVERSAL,
      V.Type.INTEGER,
      !1,
      V.integerToDer(e.version).getBytes()
    ),
    // subject
    La(e.subject),
    // SubjectPublicKeyInfo
    we.publicKeyToAsn1(e.publicKey),
    // attributes
    gI(e)
  ]);
  return t;
};
we.distinguishedNameToAsn1 = function(e) {
  return La(e);
};
we.certificateToAsn1 = function(e) {
  var t = e.tbsCertificate || we.getTBSCertificate(e);
  return V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
    // TBSCertificate
    t,
    // AlgorithmIdentifier (signature algorithm)
    V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
      // algorithm
      V.create(
        V.Class.UNIVERSAL,
        V.Type.OID,
        !1,
        V.oidToDer(e.signatureOid).getBytes()
      ),
      // parameters
      Kh(e.signatureOid, e.signatureParameters)
    ]),
    // SignatureValue
    V.create(
      V.Class.UNIVERSAL,
      V.Type.BITSTRING,
      !1,
      "\0" + e.signature
    )
  ]);
};
we.certificateExtensionsToAsn1 = function(e) {
  var t = V.create(V.Class.CONTEXT_SPECIFIC, 3, !0, []), h = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, []);
  t.value.push(h);
  for (var o = 0; o < e.length; ++o)
    h.value.push(we.certificateExtensionToAsn1(e[o]));
  return t;
};
we.certificateExtensionToAsn1 = function(e) {
  var t = V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, []);
  t.value.push(V.create(
    V.Class.UNIVERSAL,
    V.Type.OID,
    !1,
    V.oidToDer(e.id).getBytes()
  )), e.critical && t.value.push(V.create(
    V.Class.UNIVERSAL,
    V.Type.BOOLEAN,
    !1,
    "ÿ"
  ));
  var h = e.value;
  return typeof e.value != "string" && (h = V.toDer(h).getBytes()), t.value.push(V.create(
    V.Class.UNIVERSAL,
    V.Type.OCTETSTRING,
    !1,
    h
  )), t;
};
we.certificationRequestToAsn1 = function(e) {
  var t = e.certificationRequestInfo || we.getCertificationRequestInfo(e);
  return V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
    // CertificationRequestInfo
    t,
    // AlgorithmIdentifier (signature algorithm)
    V.create(V.Class.UNIVERSAL, V.Type.SEQUENCE, !0, [
      // algorithm
      V.create(
        V.Class.UNIVERSAL,
        V.Type.OID,
        !1,
        V.oidToDer(e.signatureOid).getBytes()
      ),
      // parameters
      Kh(e.signatureOid, e.signatureParameters)
    ]),
    // signature
    V.create(
      V.Class.UNIVERSAL,
      V.Type.BITSTRING,
      !1,
      "\0" + e.signature
    )
  ]);
};
we.createCaStore = function(e) {
  var t = {
    // stored certificates
    certs: {}
  };
  t.getIssuer = function(B) {
    var M = h(B.issuer);
    return M;
  }, t.addCertificate = function(B) {
    if (typeof B == "string" && (B = Ge.pki.certificateFromPem(B)), o(B.subject), !t.hasCertificate(B))
      if (B.subject.hash in t.certs) {
        var M = t.certs[B.subject.hash];
        Ge.util.isArray(M) || (M = [M]), M.push(B), t.certs[B.subject.hash] = M;
      } else
        t.certs[B.subject.hash] = B;
  }, t.hasCertificate = function(B) {
    typeof B == "string" && (B = Ge.pki.certificateFromPem(B));
    var M = h(B.subject);
    if (!M)
      return !1;
    Ge.util.isArray(M) || (M = [M]);
    for (var O = V.toDer(we.certificateToAsn1(B)).getBytes(), P = 0; P < M.length; ++P) {
      var D = V.toDer(we.certificateToAsn1(M[P])).getBytes();
      if (O === D)
        return !0;
    }
    return !1;
  }, t.listAllCertificates = function() {
    var B = [];
    for (var M in t.certs)
      if (t.certs.hasOwnProperty(M)) {
        var O = t.certs[M];
        if (!Ge.util.isArray(O))
          B.push(O);
        else
          for (var P = 0; P < O.length; ++P)
            B.push(O[P]);
      }
    return B;
  }, t.removeCertificate = function(B) {
    var M;
    if (typeof B == "string" && (B = Ge.pki.certificateFromPem(B)), o(B.subject), !t.hasCertificate(B))
      return null;
    var O = h(B.subject);
    if (!Ge.util.isArray(O))
      return M = t.certs[B.subject.hash], delete t.certs[B.subject.hash], M;
    for (var P = V.toDer(we.certificateToAsn1(B)).getBytes(), D = 0; D < O.length; ++D) {
      var Z = V.toDer(we.certificateToAsn1(O[D])).getBytes();
      P === Z && (M = O[D], O.splice(D, 1));
    }
    return O.length === 0 && delete t.certs[B.subject.hash], M;
  };
  function h(B) {
    return o(B), t.certs[B.hash] || null;
  }
  function o(B) {
    if (!B.hash) {
      var M = Ge.md.sha1.create();
      B.attributes = we.RDNAttributesAsArray(La(B), M), B.hash = M.digest().toHex();
    }
  }
  if (e)
    for (var S = 0; S < e.length; ++S) {
      var g = e[S];
      t.addCertificate(g);
    }
  return t;
};
we.certificateError = {
  bad_certificate: "forge.pki.BadCertificate",
  unsupported_certificate: "forge.pki.UnsupportedCertificate",
  certificate_revoked: "forge.pki.CertificateRevoked",
  certificate_expired: "forge.pki.CertificateExpired",
  certificate_unknown: "forge.pki.CertificateUnknown",
  unknown_ca: "forge.pki.UnknownCertificateAuthority"
};
we.verifyCertificateChain = function(e, t, h) {
  typeof h == "function" && (h = { verify: h }), h = h || {}, t = t.slice(0);
  var o = t.slice(0), S = h.validityCheckDate;
  typeof S > "u" && (S = /* @__PURE__ */ new Date());
  var g = !0, B = null, M = 0;
  do {
    var O = t.shift(), P = null, D = !1;
    if (S && (S < O.validity.notBefore || S > O.validity.notAfter) && (B = {
      message: "Certificate is not valid yet or has expired.",
      error: we.certificateError.certificate_expired,
      notBefore: O.validity.notBefore,
      notAfter: O.validity.notAfter,
      // TODO: we might want to reconsider renaming 'now' to
      // 'validityCheckDate' should this API be changed in the future.
      now: S
    }), B === null) {
      if (P = t[0] || e.getIssuer(O), P === null && O.isIssuer(O) && (D = !0, P = O), P) {
        var Z = P;
        Ge.util.isArray(Z) || (Z = [Z]);
        for (var Y = !1; !Y && Z.length > 0; ) {
          P = Z.shift();
          try {
            Y = P.verify(O);
          } catch {
          }
        }
        Y || (B = {
          message: "Certificate signature is invalid.",
          error: we.certificateError.bad_certificate
        });
      }
      B === null && (!P || D) && !e.hasCertificate(O) && (B = {
        message: "Certificate is not trusted.",
        error: we.certificateError.unknown_ca
      });
    }
    if (B === null && P && !O.isIssuer(P) && (B = {
      message: "Certificate issuer is invalid.",
      error: we.certificateError.bad_certificate
    }), B === null)
      for (var ee = {
        keyUsage: !0,
        basicConstraints: !0
      }, ie = 0; B === null && ie < O.extensions.length; ++ie) {
        var ue = O.extensions[ie];
        ue.critical && !(ue.name in ee) && (B = {
          message: "Certificate has an unsupported critical extension.",
          error: we.certificateError.unsupported_certificate
        });
      }
    if (B === null && (!g || t.length === 0 && (!P || D))) {
      var fe = O.getExtension("basicConstraints"), de = O.getExtension("keyUsage");
      if (de !== null && (!de.keyCertSign || fe === null) && (B = {
        message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
        error: we.certificateError.bad_certificate
      }), B === null && fe !== null && !fe.cA && (B = {
        message: "Certificate basicConstraints indicates the certificate is not a CA.",
        error: we.certificateError.bad_certificate
      }), B === null && de !== null && "pathLenConstraint" in fe) {
        var ce = M - 1;
        ce > fe.pathLenConstraint && (B = {
          message: "Certificate basicConstraints pathLenConstraint violated.",
          error: we.certificateError.bad_certificate
        });
      }
    }
    var be = B === null ? !0 : B.error, ve = h.verify ? h.verify(be, M, o) : be;
    if (ve === !0)
      B = null;
    else
      throw be === !0 && (B = {
        message: "The application rejected the certificate.",
        error: we.certificateError.bad_certificate
      }), (ve || ve === 0) && (typeof ve == "object" && !Ge.util.isArray(ve) ? (ve.message && (B.message = ve.message), ve.error && (B.error = ve.error)) : typeof ve == "string" && (B.error = ve)), B;
    g = !1, ++M;
  } while (t.length > 0);
  return !0;
};
var Pt = ht, te = Pt.asn1, lt = Pt.pki, T0 = Pt.pkcs12 = Pt.pkcs12 || {}, q2 = {
  name: "ContentInfo",
  tagClass: te.Class.UNIVERSAL,
  type: te.Type.SEQUENCE,
  // a ContentInfo
  constructed: !0,
  value: [{
    name: "ContentInfo.contentType",
    tagClass: te.Class.UNIVERSAL,
    type: te.Type.OID,
    constructed: !1,
    capture: "contentType"
  }, {
    name: "ContentInfo.content",
    tagClass: te.Class.CONTEXT_SPECIFIC,
    constructed: !0,
    captureAsn1: "content"
  }]
}, xI = {
  name: "PFX",
  tagClass: te.Class.UNIVERSAL,
  type: te.Type.SEQUENCE,
  constructed: !0,
  value: [
    {
      name: "PFX.version",
      tagClass: te.Class.UNIVERSAL,
      type: te.Type.INTEGER,
      constructed: !1,
      capture: "version"
    },
    q2,
    {
      name: "PFX.macData",
      tagClass: te.Class.UNIVERSAL,
      type: te.Type.SEQUENCE,
      constructed: !0,
      optional: !0,
      captureAsn1: "mac",
      value: [{
        name: "PFX.macData.mac",
        tagClass: te.Class.UNIVERSAL,
        type: te.Type.SEQUENCE,
        // DigestInfo
        constructed: !0,
        value: [{
          name: "PFX.macData.mac.digestAlgorithm",
          tagClass: te.Class.UNIVERSAL,
          type: te.Type.SEQUENCE,
          // DigestAlgorithmIdentifier
          constructed: !0,
          value: [{
            name: "PFX.macData.mac.digestAlgorithm.algorithm",
            tagClass: te.Class.UNIVERSAL,
            type: te.Type.OID,
            constructed: !1,
            capture: "macAlgorithm"
          }, {
            name: "PFX.macData.mac.digestAlgorithm.parameters",
            tagClass: te.Class.UNIVERSAL,
            captureAsn1: "macAlgorithmParameters"
          }]
        }, {
          name: "PFX.macData.mac.digest",
          tagClass: te.Class.UNIVERSAL,
          type: te.Type.OCTETSTRING,
          constructed: !1,
          capture: "macDigest"
        }]
      }, {
        name: "PFX.macData.macSalt",
        tagClass: te.Class.UNIVERSAL,
        type: te.Type.OCTETSTRING,
        constructed: !1,
        capture: "macSalt"
      }, {
        name: "PFX.macData.iterations",
        tagClass: te.Class.UNIVERSAL,
        type: te.Type.INTEGER,
        constructed: !1,
        optional: !0,
        capture: "macIterations"
      }]
    }
  ]
}, _I = {
  name: "SafeBag",
  tagClass: te.Class.UNIVERSAL,
  type: te.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "SafeBag.bagId",
    tagClass: te.Class.UNIVERSAL,
    type: te.Type.OID,
    constructed: !1,
    capture: "bagId"
  }, {
    name: "SafeBag.bagValue",
    tagClass: te.Class.CONTEXT_SPECIFIC,
    constructed: !0,
    captureAsn1: "bagValue"
  }, {
    name: "SafeBag.bagAttributes",
    tagClass: te.Class.UNIVERSAL,
    type: te.Type.SET,
    constructed: !0,
    optional: !0,
    capture: "bagAttributes"
  }]
}, EI = {
  name: "Attribute",
  tagClass: te.Class.UNIVERSAL,
  type: te.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "Attribute.attrId",
    tagClass: te.Class.UNIVERSAL,
    type: te.Type.OID,
    constructed: !1,
    capture: "oid"
  }, {
    name: "Attribute.attrValues",
    tagClass: te.Class.UNIVERSAL,
    type: te.Type.SET,
    constructed: !0,
    capture: "values"
  }]
}, SI = {
  name: "CertBag",
  tagClass: te.Class.UNIVERSAL,
  type: te.Type.SEQUENCE,
  constructed: !0,
  value: [{
    name: "CertBag.certId",
    tagClass: te.Class.UNIVERSAL,
    type: te.Type.OID,
    constructed: !1,
    capture: "certId"
  }, {
    name: "CertBag.certValue",
    tagClass: te.Class.CONTEXT_SPECIFIC,
    constructed: !0,
    /* So far we only support X.509 certificates (which are wrapped in
       an OCTET STRING, hence hard code that here). */
    value: [{
      name: "CertBag.certValue[0]",
      tagClass: te.Class.UNIVERSAL,
      type: te.Class.OCTETSTRING,
      constructed: !1,
      capture: "cert"
    }]
  }]
};
function l0(e, t, h, o) {
  for (var S = [], g = 0; g < e.length; g++)
    for (var B = 0; B < e[g].safeBags.length; B++) {
      var M = e[g].safeBags[B];
      if (!(o !== void 0 && M.type !== o)) {
        if (t === null) {
          S.push(M);
          continue;
        }
        M.attributes[t] !== void 0 && M.attributes[t].indexOf(h) >= 0 && S.push(M);
      }
    }
  return S;
}
T0.pkcs12FromAsn1 = function(e, t, h) {
  typeof t == "string" ? (h = t, t = !0) : t === void 0 && (t = !0);
  var o = {}, S = [];
  if (!te.validate(e, xI, o, S)) {
    var g = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
    throw g.errors = g, g;
  }
  var B = {
    version: o.version.charCodeAt(0),
    safeContents: [],
    /**
     * Gets bags with matching attributes.
     *
     * @param filter the attributes to filter by:
     *          [localKeyId] the localKeyId to search for.
     *          [localKeyIdHex] the localKeyId in hex to search for.
     *          [friendlyName] the friendly name to search for.
     *          [bagType] bag type to narrow each attribute search by.
     *
     * @return a map of attribute type to an array of matching bags or, if no
     *           attribute was given but a bag type, the map key will be the
     *           bag type.
     */
    getBags: function(fe) {
      var de = {}, ce;
      return "localKeyId" in fe ? ce = fe.localKeyId : "localKeyIdHex" in fe && (ce = Pt.util.hexToBytes(fe.localKeyIdHex)), ce === void 0 && !("friendlyName" in fe) && "bagType" in fe && (de[fe.bagType] = l0(
        B.safeContents,
        null,
        null,
        fe.bagType
      )), ce !== void 0 && (de.localKeyId = l0(
        B.safeContents,
        "localKeyId",
        ce,
        fe.bagType
      )), "friendlyName" in fe && (de.friendlyName = l0(
        B.safeContents,
        "friendlyName",
        fe.friendlyName,
        fe.bagType
      )), de;
    },
    /**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching friendlyName attribute.
     *
     * @param friendlyName the friendly name to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching friendlyName attribute.
     */
    getBagsByFriendlyName: function(fe, de) {
      return l0(
        B.safeContents,
        "friendlyName",
        fe,
        de
      );
    },
    /**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching localKeyId attribute.
     *
     * @param localKeyId the localKeyId to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching localKeyId attribute.
     */
    getBagsByLocalKeyId: function(fe, de) {
      return l0(
        B.safeContents,
        "localKeyId",
        fe,
        de
      );
    }
  };
  if (o.version.charCodeAt(0) !== 3) {
    var g = new Error("PKCS#12 PFX of version other than 3 not supported.");
    throw g.version = o.version.charCodeAt(0), g;
  }
  if (te.derToOid(o.contentType) !== lt.oids.data) {
    var g = new Error("Only PKCS#12 PFX in password integrity mode supported.");
    throw g.oid = te.derToOid(o.contentType), g;
  }
  var M = o.content.value[0];
  if (M.tagClass !== te.Class.UNIVERSAL || M.type !== te.Type.OCTETSTRING)
    throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
  if (M = $h(M), o.mac) {
    var O = null, P = 0, D = te.derToOid(o.macAlgorithm);
    switch (D) {
      case lt.oids.sha1:
        O = Pt.md.sha1.create(), P = 20;
        break;
      case lt.oids.sha256:
        O = Pt.md.sha256.create(), P = 32;
        break;
      case lt.oids.sha384:
        O = Pt.md.sha384.create(), P = 48;
        break;
      case lt.oids.sha512:
        O = Pt.md.sha512.create(), P = 64;
        break;
      case lt.oids.md5:
        O = Pt.md.md5.create(), P = 16;
        break;
    }
    if (O === null)
      throw new Error("PKCS#12 uses unsupported MAC algorithm: " + D);
    var Z = new Pt.util.ByteBuffer(o.macSalt), Y = "macIterations" in o ? parseInt(Pt.util.bytesToHex(o.macIterations), 16) : 1, ee = T0.generateKey(
      h,
      Z,
      3,
      Y,
      P,
      O
    ), ie = Pt.hmac.create();
    ie.start(O, ee), ie.update(M.value);
    var ue = ie.getMac();
    if (ue.getBytes() !== o.macDigest)
      throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
  }
  return wI(B, M.value, t, h), B;
};
function $h(e) {
  if (e.composed || e.constructed) {
    for (var t = Pt.util.createBuffer(), h = 0; h < e.value.length; ++h)
      t.putBytes(e.value[h].value);
    e.composed = e.constructed = !1, e.value = t.getBytes();
  }
  return e;
}
function wI(e, t, h, o) {
  if (t = te.fromDer(t, h), t.tagClass !== te.Class.UNIVERSAL || t.type !== te.Type.SEQUENCE || t.constructed !== !0)
    throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
  for (var S = 0; S < t.value.length; S++) {
    var g = t.value[S], B = {}, M = [];
    if (!te.validate(g, q2, B, M)) {
      var O = new Error("Cannot read ContentInfo.");
      throw O.errors = M, O;
    }
    var P = {
      encrypted: !1
    }, D = null, Z = B.content.value[0];
    switch (te.derToOid(B.contentType)) {
      case lt.oids.data:
        if (Z.tagClass !== te.Class.UNIVERSAL || Z.type !== te.Type.OCTETSTRING)
          throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
        D = $h(Z).value;
        break;
      case lt.oids.encryptedData:
        D = CI(Z, o), P.encrypted = !0;
        break;
      default:
        var O = new Error("Unsupported PKCS#12 contentType.");
        throw O.contentType = te.derToOid(B.contentType), O;
    }
    P.safeBags = AI(D, h, o), e.safeContents.push(P);
  }
}
function CI(e, t) {
  var h = {}, o = [];
  if (!te.validate(
    e,
    Pt.pkcs7.asn1.encryptedDataValidator,
    h,
    o
  )) {
    var S = new Error("Cannot read EncryptedContentInfo.");
    throw S.errors = o, S;
  }
  var g = te.derToOid(h.contentType);
  if (g !== lt.oids.data) {
    var S = new Error(
      "PKCS#12 EncryptedContentInfo ContentType is not Data."
    );
    throw S.oid = g, S;
  }
  g = te.derToOid(h.encAlgorithm);
  var B = lt.pbe.getCipher(g, h.encParameter, t), M = $h(h.encryptedContentAsn1), O = Pt.util.createBuffer(M.value);
  if (B.update(O), !B.finish())
    throw new Error("Failed to decrypt PKCS#12 SafeContents.");
  return B.output.getBytes();
}
function AI(e, t, h) {
  if (!t && e.length === 0)
    return [];
  if (e = te.fromDer(e, t), e.tagClass !== te.Class.UNIVERSAL || e.type !== te.Type.SEQUENCE || e.constructed !== !0)
    throw new Error(
      "PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag."
    );
  for (var o = [], S = 0; S < e.value.length; S++) {
    var g = e.value[S], B = {}, M = [];
    if (!te.validate(g, _I, B, M)) {
      var O = new Error("Cannot read SafeBag.");
      throw O.errors = M, O;
    }
    var P = {
      type: te.derToOid(B.bagId),
      attributes: BI(B.bagAttributes)
    };
    o.push(P);
    var D, Z, Y = B.bagValue.value[0];
    switch (P.type) {
      case lt.oids.pkcs8ShroudedKeyBag:
        if (Y = lt.decryptPrivateKeyInfo(Y, h), Y === null)
          throw new Error(
            "Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?"
          );
      case lt.oids.keyBag:
        try {
          P.key = lt.privateKeyFromAsn1(Y);
        } catch {
          P.key = null, P.asn1 = Y;
        }
        continue;
      case lt.oids.certBag:
        D = SI, Z = function() {
          if (te.derToOid(B.certId) !== lt.oids.x509Certificate) {
            var ie = new Error(
              "Unsupported certificate type, only X.509 supported."
            );
            throw ie.oid = te.derToOid(B.certId), ie;
          }
          var ue = te.fromDer(B.cert, t);
          try {
            P.cert = lt.certificateFromAsn1(ue, !0);
          } catch {
            P.cert = null, P.asn1 = ue;
          }
        };
        break;
      default:
        var O = new Error("Unsupported PKCS#12 SafeBag type.");
        throw O.oid = P.type, O;
    }
    if (D !== void 0 && !te.validate(Y, D, B, M)) {
      var O = new Error("Cannot read PKCS#12 " + D.name);
      throw O.errors = M, O;
    }
    Z();
  }
  return o;
}
function BI(e) {
  var t = {};
  if (e !== void 0)
    for (var h = 0; h < e.length; ++h) {
      var o = {}, S = [];
      if (!te.validate(e[h], EI, o, S)) {
        var g = new Error("Cannot read PKCS#12 BagAttribute.");
        throw g.errors = S, g;
      }
      var B = te.derToOid(o.oid);
      if (lt.oids[B] !== void 0) {
        t[lt.oids[B]] = [];
        for (var M = 0; M < o.values.length; ++M)
          t[lt.oids[B]].push(o.values[M].value);
      }
    }
  return t;
}
T0.toPkcs12Asn1 = function(e, t, h, o) {
  o = o || {}, o.saltSize = o.saltSize || 8, o.count = o.count || 2048, o.algorithm = o.algorithm || o.encAlgorithm || "aes128", "useMac" in o || (o.useMac = !0), "localKeyId" in o || (o.localKeyId = null), "generateLocalKeyId" in o || (o.generateLocalKeyId = !0);
  var S = o.localKeyId, g;
  if (S !== null)
    S = Pt.util.hexToBytes(S);
  else if (o.generateLocalKeyId)
    if (t) {
      var B = Pt.util.isArray(t) ? t[0] : t;
      typeof B == "string" && (B = lt.certificateFromPem(B));
      var M = Pt.md.sha1.create();
      M.update(te.toDer(lt.certificateToAsn1(B)).getBytes()), S = M.digest().getBytes();
    } else
      S = Pt.random.getBytes(20);
  var O = [];
  S !== null && O.push(
    // localKeyID
    te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
      // attrId
      te.create(
        te.Class.UNIVERSAL,
        te.Type.OID,
        !1,
        te.oidToDer(lt.oids.localKeyId).getBytes()
      ),
      // attrValues
      te.create(te.Class.UNIVERSAL, te.Type.SET, !0, [
        te.create(
          te.Class.UNIVERSAL,
          te.Type.OCTETSTRING,
          !1,
          S
        )
      ])
    ])
  ), "friendlyName" in o && O.push(
    // friendlyName
    te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
      // attrId
      te.create(
        te.Class.UNIVERSAL,
        te.Type.OID,
        !1,
        te.oidToDer(lt.oids.friendlyName).getBytes()
      ),
      // attrValues
      te.create(te.Class.UNIVERSAL, te.Type.SET, !0, [
        te.create(
          te.Class.UNIVERSAL,
          te.Type.BMPSTRING,
          !1,
          o.friendlyName
        )
      ])
    ])
  ), O.length > 0 && (g = te.create(te.Class.UNIVERSAL, te.Type.SET, !0, O));
  var P = [], D = [];
  t !== null && (Pt.util.isArray(t) ? D = t : D = [t]);
  for (var Z = [], Y = 0; Y < D.length; ++Y) {
    t = D[Y], typeof t == "string" && (t = lt.certificateFromPem(t));
    var ee = Y === 0 ? g : void 0, ie = lt.certificateToAsn1(t), ue = te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
      // bagId
      te.create(
        te.Class.UNIVERSAL,
        te.Type.OID,
        !1,
        te.oidToDer(lt.oids.certBag).getBytes()
      ),
      // bagValue
      te.create(te.Class.CONTEXT_SPECIFIC, 0, !0, [
        // CertBag
        te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
          // certId
          te.create(
            te.Class.UNIVERSAL,
            te.Type.OID,
            !1,
            te.oidToDer(lt.oids.x509Certificate).getBytes()
          ),
          // certValue (x509Certificate)
          te.create(te.Class.CONTEXT_SPECIFIC, 0, !0, [
            te.create(
              te.Class.UNIVERSAL,
              te.Type.OCTETSTRING,
              !1,
              te.toDer(ie).getBytes()
            )
          ])
        ])
      ]),
      // bagAttributes (OPTIONAL)
      ee
    ]);
    Z.push(ue);
  }
  if (Z.length > 0) {
    var fe = te.create(
      te.Class.UNIVERSAL,
      te.Type.SEQUENCE,
      !0,
      Z
    ), de = (
      // PKCS#7 ContentInfo
      te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
        // contentType
        te.create(
          te.Class.UNIVERSAL,
          te.Type.OID,
          !1,
          // OID for the content type is 'data'
          te.oidToDer(lt.oids.data).getBytes()
        ),
        // content
        te.create(te.Class.CONTEXT_SPECIFIC, 0, !0, [
          te.create(
            te.Class.UNIVERSAL,
            te.Type.OCTETSTRING,
            !1,
            te.toDer(fe).getBytes()
          )
        ])
      ])
    );
    P.push(de);
  }
  var ce = null;
  if (e !== null) {
    var be = lt.wrapRsaPrivateKey(lt.privateKeyToAsn1(e));
    h === null ? ce = te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
      // bagId
      te.create(
        te.Class.UNIVERSAL,
        te.Type.OID,
        !1,
        te.oidToDer(lt.oids.keyBag).getBytes()
      ),
      // bagValue
      te.create(te.Class.CONTEXT_SPECIFIC, 0, !0, [
        // PrivateKeyInfo
        be
      ]),
      // bagAttributes (OPTIONAL)
      g
    ]) : ce = te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
      // bagId
      te.create(
        te.Class.UNIVERSAL,
        te.Type.OID,
        !1,
        te.oidToDer(lt.oids.pkcs8ShroudedKeyBag).getBytes()
      ),
      // bagValue
      te.create(te.Class.CONTEXT_SPECIFIC, 0, !0, [
        // EncryptedPrivateKeyInfo
        lt.encryptPrivateKeyInfo(be, h, o)
      ]),
      // bagAttributes (OPTIONAL)
      g
    ]);
    var ve = te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [ce]), Pe = (
      // PKCS#7 ContentInfo
      te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
        // contentType
        te.create(
          te.Class.UNIVERSAL,
          te.Type.OID,
          !1,
          // OID for the content type is 'data'
          te.oidToDer(lt.oids.data).getBytes()
        ),
        // content
        te.create(te.Class.CONTEXT_SPECIFIC, 0, !0, [
          te.create(
            te.Class.UNIVERSAL,
            te.Type.OCTETSTRING,
            !1,
            te.toDer(ve).getBytes()
          )
        ])
      ])
    );
    P.push(Pe);
  }
  var Ue = te.create(
    te.Class.UNIVERSAL,
    te.Type.SEQUENCE,
    !0,
    P
  ), ze;
  if (o.useMac) {
    var M = Pt.md.sha1.create(), Le = new Pt.util.ByteBuffer(
      Pt.random.getBytes(o.saltSize)
    ), Ne = o.count, e = T0.generateKey(h, Le, 3, Ne, 20), $e = Pt.hmac.create();
    $e.start(M, e), $e.update(te.toDer(Ue).getBytes());
    var J = $e.getMac();
    ze = te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
      // mac DigestInfo
      te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
        // digestAlgorithm
        te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
          // algorithm = SHA-1
          te.create(
            te.Class.UNIVERSAL,
            te.Type.OID,
            !1,
            te.oidToDer(lt.oids.sha1).getBytes()
          ),
          // parameters = Null
          te.create(te.Class.UNIVERSAL, te.Type.NULL, !1, "")
        ]),
        // digest
        te.create(
          te.Class.UNIVERSAL,
          te.Type.OCTETSTRING,
          !1,
          J.getBytes()
        )
      ]),
      // macSalt OCTET STRING
      te.create(
        te.Class.UNIVERSAL,
        te.Type.OCTETSTRING,
        !1,
        Le.getBytes()
      ),
      // iterations INTEGER (XXX: Only support count < 65536)
      te.create(
        te.Class.UNIVERSAL,
        te.Type.INTEGER,
        !1,
        te.integerToDer(Ne).getBytes()
      )
    ]);
  }
  return te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
    // version (3)
    te.create(
      te.Class.UNIVERSAL,
      te.Type.INTEGER,
      !1,
      te.integerToDer(3).getBytes()
    ),
    // PKCS#7 ContentInfo
    te.create(te.Class.UNIVERSAL, te.Type.SEQUENCE, !0, [
      // contentType
      te.create(
        te.Class.UNIVERSAL,
        te.Type.OID,
        !1,
        // OID for the content type is 'data'
        te.oidToDer(lt.oids.data).getBytes()
      ),
      // content
      te.create(te.Class.CONTEXT_SPECIFIC, 0, !0, [
        te.create(
          te.Class.UNIVERSAL,
          te.Type.OCTETSTRING,
          !1,
          te.toDer(Ue).getBytes()
        )
      ])
    ]),
    ze
  ]);
};
T0.generateKey = Pt.pbe.generatePkcs12Key;
var In = ht, Hh = In.asn1, ka = In.pki = In.pki || {};
ka.pemToDer = function(e) {
  var t = In.pem.decode(e)[0];
  if (t.procType && t.procType.type === "ENCRYPTED")
    throw new Error("Could not convert PEM to DER; PEM is encrypted.");
  return In.util.createBuffer(t.body);
};
ka.privateKeyFromPem = function(e) {
  var t = In.pem.decode(e)[0];
  if (t.type !== "PRIVATE KEY" && t.type !== "RSA PRIVATE KEY") {
    var h = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
    throw h.headerType = t.type, h;
  }
  if (t.procType && t.procType.type === "ENCRYPTED")
    throw new Error("Could not convert private key from PEM; PEM is encrypted.");
  var o = Hh.fromDer(t.body);
  return ka.privateKeyFromAsn1(o);
};
ka.privateKeyToPem = function(e, t) {
  var h = {
    type: "RSA PRIVATE KEY",
    body: Hh.toDer(ka.privateKeyToAsn1(e)).getBytes()
  };
  return In.pem.encode(h, { maxline: t });
};
ka.privateKeyInfoToPem = function(e, t) {
  var h = {
    type: "PRIVATE KEY",
    body: Hh.toDer(e).getBytes()
  };
  return In.pem.encode(h, { maxline: t });
};
var xe = ht, Kf = function(e, t, h, o) {
  var S = xe.util.createBuffer(), g = e.length >> 1, B = g + (e.length & 1), M = e.substr(0, B), O = e.substr(g, B), P = xe.util.createBuffer(), D = xe.hmac.create();
  h = t + h;
  var Z = Math.ceil(o / 16), Y = Math.ceil(o / 20);
  D.start("MD5", M);
  var ee = xe.util.createBuffer();
  P.putBytes(h);
  for (var ie = 0; ie < Z; ++ie)
    D.start(null, null), D.update(P.getBytes()), P.putBuffer(D.digest()), D.start(null, null), D.update(P.bytes() + h), ee.putBuffer(D.digest());
  D.start("SHA1", O);
  var ue = xe.util.createBuffer();
  P.clear(), P.putBytes(h);
  for (var ie = 0; ie < Y; ++ie)
    D.start(null, null), D.update(P.getBytes()), P.putBuffer(D.digest()), D.start(null, null), D.update(P.bytes() + h), ue.putBuffer(D.digest());
  return S.putBytes(xe.util.xorBytes(
    ee.getBytes(),
    ue.getBytes(),
    o
  )), S;
}, II = function(e, t, h) {
  var o = xe.hmac.create();
  o.start("SHA1", e);
  var S = xe.util.createBuffer();
  return S.putInt32(t[0]), S.putInt32(t[1]), S.putByte(h.type), S.putByte(h.version.major), S.putByte(h.version.minor), S.putInt16(h.length), S.putBytes(h.fragment.bytes()), o.update(S.getBytes()), o.digest().getBytes();
}, TI = function(e, t, h) {
  var o = !1;
  try {
    var S = e.deflate(t.fragment.getBytes());
    t.fragment = xe.util.createBuffer(S), t.length = S.length, o = !0;
  } catch {
  }
  return o;
}, MI = function(e, t, h) {
  var o = !1;
  try {
    var S = e.inflate(t.fragment.getBytes());
    t.fragment = xe.util.createBuffer(S), t.length = S.length, o = !0;
  } catch {
  }
  return o;
}, Rr = function(e, t) {
  var h = 0;
  switch (t) {
    case 1:
      h = e.getByte();
      break;
    case 2:
      h = e.getInt16();
      break;
    case 3:
      h = e.getInt24();
      break;
    case 4:
      h = e.getInt32();
      break;
  }
  return xe.util.createBuffer(e.getBytes(h));
}, Fr = function(e, t, h) {
  e.putInt(h.length(), t << 3), e.putBuffer(h);
}, G = {};
G.Versions = {
  TLS_1_0: { major: 3, minor: 1 },
  TLS_1_1: { major: 3, minor: 2 },
  TLS_1_2: { major: 3, minor: 3 }
};
G.SupportedVersions = [
  G.Versions.TLS_1_1,
  G.Versions.TLS_1_0
];
G.Version = G.SupportedVersions[0];
G.MaxFragment = 15360;
G.ConnectionEnd = {
  server: 0,
  client: 1
};
G.PRFAlgorithm = {
  tls_prf_sha256: 0
};
G.BulkCipherAlgorithm = {
  none: null,
  rc4: 0,
  des3: 1,
  aes: 2
};
G.CipherType = {
  stream: 0,
  block: 1,
  aead: 2
};
G.MACAlgorithm = {
  none: null,
  hmac_md5: 0,
  hmac_sha1: 1,
  hmac_sha256: 2,
  hmac_sha384: 3,
  hmac_sha512: 4
};
G.CompressionMethod = {
  none: 0,
  deflate: 1
};
G.ContentType = {
  change_cipher_spec: 20,
  alert: 21,
  handshake: 22,
  application_data: 23,
  heartbeat: 24
};
G.HandshakeType = {
  hello_request: 0,
  client_hello: 1,
  server_hello: 2,
  certificate: 11,
  server_key_exchange: 12,
  certificate_request: 13,
  server_hello_done: 14,
  certificate_verify: 15,
  client_key_exchange: 16,
  finished: 20
};
G.Alert = {};
G.Alert.Level = {
  warning: 1,
  fatal: 2
};
G.Alert.Description = {
  close_notify: 0,
  unexpected_message: 10,
  bad_record_mac: 20,
  decryption_failed: 21,
  record_overflow: 22,
  decompression_failure: 30,
  handshake_failure: 40,
  bad_certificate: 42,
  unsupported_certificate: 43,
  certificate_revoked: 44,
  certificate_expired: 45,
  certificate_unknown: 46,
  illegal_parameter: 47,
  unknown_ca: 48,
  access_denied: 49,
  decode_error: 50,
  decrypt_error: 51,
  export_restriction: 60,
  protocol_version: 70,
  insufficient_security: 71,
  internal_error: 80,
  user_canceled: 90,
  no_renegotiation: 100
};
G.HeartbeatMessageType = {
  heartbeat_request: 1,
  heartbeat_response: 2
};
G.CipherSuites = {};
G.getCipherSuite = function(e) {
  var t = null;
  for (var h in G.CipherSuites) {
    var o = G.CipherSuites[h];
    if (o.id[0] === e.charCodeAt(0) && o.id[1] === e.charCodeAt(1)) {
      t = o;
      break;
    }
  }
  return t;
};
G.handleUnexpected = function(e, t) {
  var h = !e.open && e.entity === G.ConnectionEnd.client;
  h || e.error(e, {
    message: "Unexpected message. Received TLS record out of order.",
    send: !0,
    alert: {
      level: G.Alert.Level.fatal,
      description: G.Alert.Description.unexpected_message
    }
  });
};
G.handleHelloRequest = function(e, t, h) {
  !e.handshaking && e.handshakes > 0 && (G.queue(e, G.createAlert(e, {
    level: G.Alert.Level.warning,
    description: G.Alert.Description.no_renegotiation
  })), G.flush(e)), e.process();
};
G.parseHelloMessage = function(e, t, h) {
  var o = null, S = e.entity === G.ConnectionEnd.client;
  if (h < 38)
    e.error(e, {
      message: S ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.illegal_parameter
      }
    });
  else {
    var g = t.fragment, B = g.length();
    if (o = {
      version: {
        major: g.getByte(),
        minor: g.getByte()
      },
      random: xe.util.createBuffer(g.getBytes(32)),
      session_id: Rr(g, 1),
      extensions: []
    }, S ? (o.cipher_suite = g.getBytes(2), o.compression_method = g.getByte()) : (o.cipher_suites = Rr(g, 2), o.compression_methods = Rr(g, 1)), B = h - (B - g.length()), B > 0) {
      for (var M = Rr(g, 2); M.length() > 0; )
        o.extensions.push({
          type: [M.getByte(), M.getByte()],
          data: Rr(M, 2)
        });
      if (!S)
        for (var O = 0; O < o.extensions.length; ++O) {
          var P = o.extensions[O];
          if (P.type[0] === 0 && P.type[1] === 0)
            for (var D = Rr(P.data, 2); D.length() > 0; ) {
              var Z = D.getByte();
              if (Z !== 0)
                break;
              e.session.extensions.server_name.serverNameList.push(
                Rr(D, 2).getBytes()
              );
            }
        }
    }
    if (e.session.version && (o.version.major !== e.session.version.major || o.version.minor !== e.session.version.minor))
      return e.error(e, {
        message: "TLS version change is disallowed during renegotiation.",
        send: !0,
        alert: {
          level: G.Alert.Level.fatal,
          description: G.Alert.Description.protocol_version
        }
      });
    if (S)
      e.session.cipherSuite = G.getCipherSuite(o.cipher_suite);
    else
      for (var Y = xe.util.createBuffer(o.cipher_suites.bytes()); Y.length() > 0 && (e.session.cipherSuite = G.getCipherSuite(Y.getBytes(2)), e.session.cipherSuite === null); )
        ;
    if (e.session.cipherSuite === null)
      return e.error(e, {
        message: "No cipher suites in common.",
        send: !0,
        alert: {
          level: G.Alert.Level.fatal,
          description: G.Alert.Description.handshake_failure
        },
        cipherSuite: xe.util.bytesToHex(o.cipher_suite)
      });
    S ? e.session.compressionMethod = o.compression_method : e.session.compressionMethod = G.CompressionMethod.none;
  }
  return o;
};
G.createSecurityParameters = function(e, t) {
  var h = e.entity === G.ConnectionEnd.client, o = t.random.bytes(), S = h ? e.session.sp.client_random : o, g = h ? o : G.createRandom().getBytes();
  e.session.sp = {
    entity: e.entity,
    prf_algorithm: G.PRFAlgorithm.tls_prf_sha256,
    bulk_cipher_algorithm: null,
    cipher_type: null,
    enc_key_length: null,
    block_length: null,
    fixed_iv_length: null,
    record_iv_length: null,
    mac_algorithm: null,
    mac_length: null,
    mac_key_length: null,
    compression_algorithm: e.session.compressionMethod,
    pre_master_secret: null,
    master_secret: null,
    client_random: S,
    server_random: g
  };
};
G.handleServerHello = function(e, t, h) {
  var o = G.parseHelloMessage(e, t, h);
  if (!e.fail) {
    if (o.version.minor <= e.version.minor)
      e.version.minor = o.version.minor;
    else
      return e.error(e, {
        message: "Incompatible TLS version.",
        send: !0,
        alert: {
          level: G.Alert.Level.fatal,
          description: G.Alert.Description.protocol_version
        }
      });
    e.session.version = e.version;
    var S = o.session_id.bytes();
    S.length > 0 && S === e.session.id ? (e.expect = V2, e.session.resuming = !0, e.session.sp.server_random = o.random.bytes()) : (e.expect = NI, e.session.resuming = !1, G.createSecurityParameters(e, o)), e.session.id = S, e.process();
  }
};
G.handleClientHello = function(e, t, h) {
  var o = G.parseHelloMessage(e, t, h);
  if (!e.fail) {
    var S = o.session_id.bytes(), g = null;
    if (e.sessionCache && (g = e.sessionCache.getSession(S), g === null ? S = "" : (g.version.major !== o.version.major || g.version.minor > o.version.minor) && (g = null, S = "")), S.length === 0 && (S = xe.random.getBytes(32)), e.session.id = S, e.session.clientHelloVersion = o.version, e.session.sp = {}, g)
      e.version = e.session.version = g.version, e.session.sp = g.sp;
    else {
      for (var B, M = 1; M < G.SupportedVersions.length && (B = G.SupportedVersions[M], !(B.minor <= o.version.minor)); ++M)
        ;
      e.version = { major: B.major, minor: B.minor }, e.session.version = e.version;
    }
    g !== null ? (e.expect = Gh, e.session.resuming = !0, e.session.sp.client_random = o.random.bytes()) : (e.expect = e.verifyClient !== !1 ? FI : Cc, e.session.resuming = !1, G.createSecurityParameters(e, o)), e.open = !0, G.queue(e, G.createRecord(e, {
      type: G.ContentType.handshake,
      data: G.createServerHello(e)
    })), e.session.resuming ? (G.queue(e, G.createRecord(e, {
      type: G.ContentType.change_cipher_spec,
      data: G.createChangeCipherSpec()
    })), e.state.pending = G.createConnectionState(e), e.state.current.write = e.state.pending.write, G.queue(e, G.createRecord(e, {
      type: G.ContentType.handshake,
      data: G.createFinished(e)
    }))) : (G.queue(e, G.createRecord(e, {
      type: G.ContentType.handshake,
      data: G.createCertificate(e)
    })), e.fail || (G.queue(e, G.createRecord(e, {
      type: G.ContentType.handshake,
      data: G.createServerKeyExchange(e)
    })), e.verifyClient !== !1 && G.queue(e, G.createRecord(e, {
      type: G.ContentType.handshake,
      data: G.createCertificateRequest(e)
    })), G.queue(e, G.createRecord(e, {
      type: G.ContentType.handshake,
      data: G.createServerHelloDone(e)
    })))), G.flush(e), e.process();
  }
};
G.handleCertificate = function(e, t, h) {
  if (h < 3)
    return e.error(e, {
      message: "Invalid Certificate message. Message too short.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.illegal_parameter
      }
    });
  var o = t.fragment, S = {
    certificate_list: Rr(o, 3)
  }, g, B, M = [];
  try {
    for (; S.certificate_list.length() > 0; )
      g = Rr(S.certificate_list, 3), B = xe.asn1.fromDer(g), g = xe.pki.certificateFromAsn1(B, !0), M.push(g);
  } catch (P) {
    return e.error(e, {
      message: "Could not parse certificate list.",
      cause: P,
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.bad_certificate
      }
    });
  }
  var O = e.entity === G.ConnectionEnd.client;
  (O || e.verifyClient === !0) && M.length === 0 ? e.error(e, {
    message: O ? "No server certificate provided." : "No client certificate provided.",
    send: !0,
    alert: {
      level: G.Alert.Level.fatal,
      description: G.Alert.Description.illegal_parameter
    }
  }) : M.length === 0 ? e.expect = O ? jp : Cc : (O ? e.session.serverCertificate = M[0] : e.session.clientCertificate = M[0], G.verifyCertificateChain(e, M) && (e.expect = O ? jp : Cc)), e.process();
};
G.handleServerKeyExchange = function(e, t, h) {
  if (h > 0)
    return e.error(e, {
      message: "Invalid key parameters. Only RSA is supported.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.unsupported_certificate
      }
    });
  e.expect = DI, e.process();
};
G.handleClientKeyExchange = function(e, t, h) {
  if (h < 48)
    return e.error(e, {
      message: "Invalid key parameters. Only RSA is supported.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.unsupported_certificate
      }
    });
  var o = t.fragment, S = {
    enc_pre_master_secret: Rr(o, 2).getBytes()
  }, g = null;
  if (e.getPrivateKey)
    try {
      g = e.getPrivateKey(e, e.session.serverCertificate), g = xe.pki.privateKeyFromPem(g);
    } catch (O) {
      e.error(e, {
        message: "Could not get private key.",
        cause: O,
        send: !0,
        alert: {
          level: G.Alert.Level.fatal,
          description: G.Alert.Description.internal_error
        }
      });
    }
  if (g === null)
    return e.error(e, {
      message: "No private key set.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.internal_error
      }
    });
  try {
    var B = e.session.sp;
    B.pre_master_secret = g.decrypt(S.enc_pre_master_secret);
    var M = e.session.clientHelloVersion;
    if (M.major !== B.pre_master_secret.charCodeAt(0) || M.minor !== B.pre_master_secret.charCodeAt(1))
      throw new Error("TLS version rollback attack detected.");
  } catch {
    B.pre_master_secret = xe.random.getBytes(48);
  }
  e.expect = Gh, e.session.clientCertificate !== null && (e.expect = qI), e.process();
};
G.handleCertificateRequest = function(e, t, h) {
  if (h < 3)
    return e.error(e, {
      message: "Invalid CertificateRequest. Message too short.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.illegal_parameter
      }
    });
  var o = t.fragment, S = {
    certificate_types: Rr(o, 1),
    certificate_authorities: Rr(o, 2)
  };
  e.session.certificateRequest = S, e.expect = OI, e.process();
};
G.handleCertificateVerify = function(e, t, h) {
  if (h < 2)
    return e.error(e, {
      message: "Invalid CertificateVerify. Message too short.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.illegal_parameter
      }
    });
  var o = t.fragment;
  o.read -= 4;
  var S = o.bytes();
  o.read += 4;
  var g = {
    signature: Rr(o, 2).getBytes()
  }, B = xe.util.createBuffer();
  B.putBuffer(e.session.md5.digest()), B.putBuffer(e.session.sha1.digest()), B = B.getBytes();
  try {
    var M = e.session.clientCertificate;
    if (!M.publicKey.verify(B, g.signature, "NONE"))
      throw new Error("CertificateVerify signature does not match.");
    e.session.md5.update(S), e.session.sha1.update(S);
  } catch {
    return e.error(e, {
      message: "Bad signature in CertificateVerify.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.handshake_failure
      }
    });
  }
  e.expect = Gh, e.process();
};
G.handleServerHelloDone = function(e, t, h) {
  if (h > 0)
    return e.error(e, {
      message: "Invalid ServerHelloDone message. Invalid length.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.record_overflow
      }
    });
  if (e.serverCertificate === null) {
    var o = {
      message: "No server certificate provided. Not enough security.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.insufficient_security
      }
    }, S = 0, g = e.verify(e, o.alert.description, S, []);
    if (g !== !0)
      return (g || g === 0) && (typeof g == "object" && !xe.util.isArray(g) ? (g.message && (o.message = g.message), g.alert && (o.alert.description = g.alert)) : typeof g == "number" && (o.alert.description = g)), e.error(e, o);
  }
  e.session.certificateRequest !== null && (t = G.createRecord(e, {
    type: G.ContentType.handshake,
    data: G.createCertificate(e)
  }), G.queue(e, t)), t = G.createRecord(e, {
    type: G.ContentType.handshake,
    data: G.createClientKeyExchange(e)
  }), G.queue(e, t), e.expect = kI;
  var B = function(M, O) {
    M.session.certificateRequest !== null && M.session.clientCertificate !== null && G.queue(M, G.createRecord(M, {
      type: G.ContentType.handshake,
      data: G.createCertificateVerify(M, O)
    })), G.queue(M, G.createRecord(M, {
      type: G.ContentType.change_cipher_spec,
      data: G.createChangeCipherSpec()
    })), M.state.pending = G.createConnectionState(M), M.state.current.write = M.state.pending.write, G.queue(M, G.createRecord(M, {
      type: G.ContentType.handshake,
      data: G.createFinished(M)
    })), M.expect = V2, G.flush(M), M.process();
  };
  if (e.session.certificateRequest === null || e.session.clientCertificate === null)
    return B(e, null);
  G.getClientSignature(e, B);
};
G.handleChangeCipherSpec = function(e, t) {
  if (t.fragment.getByte() !== 1)
    return e.error(e, {
      message: "Invalid ChangeCipherSpec message received.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.illegal_parameter
      }
    });
  var h = e.entity === G.ConnectionEnd.client;
  (e.session.resuming && h || !e.session.resuming && !h) && (e.state.pending = G.createConnectionState(e)), e.state.current.read = e.state.pending.read, (!e.session.resuming && h || e.session.resuming && !h) && (e.state.pending = null), e.expect = h ? PI : VI, e.process();
};
G.handleFinished = function(e, t, h) {
  var o = t.fragment;
  o.read -= 4;
  var S = o.bytes();
  o.read += 4;
  var g = t.fragment.getBytes();
  o = xe.util.createBuffer(), o.putBuffer(e.session.md5.digest()), o.putBuffer(e.session.sha1.digest());
  var B = e.entity === G.ConnectionEnd.client, M = B ? "server finished" : "client finished", O = e.session.sp, P = 12, D = Kf;
  if (o = D(O.master_secret, M, o.getBytes(), P), o.getBytes() !== g)
    return e.error(e, {
      message: "Invalid verify_data in Finished message.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.decrypt_error
      }
    });
  e.session.md5.update(S), e.session.sha1.update(S), (e.session.resuming && B || !e.session.resuming && !B) && (G.queue(e, G.createRecord(e, {
    type: G.ContentType.change_cipher_spec,
    data: G.createChangeCipherSpec()
  })), e.state.current.write = e.state.pending.write, e.state.pending = null, G.queue(e, G.createRecord(e, {
    type: G.ContentType.handshake,
    data: G.createFinished(e)
  }))), e.expect = B ? LI : KI, e.handshaking = !1, ++e.handshakes, e.peerCertificate = B ? e.session.serverCertificate : e.session.clientCertificate, G.flush(e), e.isConnected = !0, e.connected(e), e.process();
};
G.handleAlert = function(e, t) {
  var h = t.fragment, o = {
    level: h.getByte(),
    description: h.getByte()
  }, S;
  switch (o.description) {
    case G.Alert.Description.close_notify:
      S = "Connection closed.";
      break;
    case G.Alert.Description.unexpected_message:
      S = "Unexpected message.";
      break;
    case G.Alert.Description.bad_record_mac:
      S = "Bad record MAC.";
      break;
    case G.Alert.Description.decryption_failed:
      S = "Decryption failed.";
      break;
    case G.Alert.Description.record_overflow:
      S = "Record overflow.";
      break;
    case G.Alert.Description.decompression_failure:
      S = "Decompression failed.";
      break;
    case G.Alert.Description.handshake_failure:
      S = "Handshake failure.";
      break;
    case G.Alert.Description.bad_certificate:
      S = "Bad certificate.";
      break;
    case G.Alert.Description.unsupported_certificate:
      S = "Unsupported certificate.";
      break;
    case G.Alert.Description.certificate_revoked:
      S = "Certificate revoked.";
      break;
    case G.Alert.Description.certificate_expired:
      S = "Certificate expired.";
      break;
    case G.Alert.Description.certificate_unknown:
      S = "Certificate unknown.";
      break;
    case G.Alert.Description.illegal_parameter:
      S = "Illegal parameter.";
      break;
    case G.Alert.Description.unknown_ca:
      S = "Unknown certificate authority.";
      break;
    case G.Alert.Description.access_denied:
      S = "Access denied.";
      break;
    case G.Alert.Description.decode_error:
      S = "Decode error.";
      break;
    case G.Alert.Description.decrypt_error:
      S = "Decrypt error.";
      break;
    case G.Alert.Description.export_restriction:
      S = "Export restriction.";
      break;
    case G.Alert.Description.protocol_version:
      S = "Unsupported protocol version.";
      break;
    case G.Alert.Description.insufficient_security:
      S = "Insufficient security.";
      break;
    case G.Alert.Description.internal_error:
      S = "Internal error.";
      break;
    case G.Alert.Description.user_canceled:
      S = "User canceled.";
      break;
    case G.Alert.Description.no_renegotiation:
      S = "Renegotiation not supported.";
      break;
    default:
      S = "Unknown error.";
      break;
  }
  if (o.description === G.Alert.Description.close_notify)
    return e.close();
  e.error(e, {
    message: S,
    send: !1,
    // origin is the opposite end
    origin: e.entity === G.ConnectionEnd.client ? "server" : "client",
    alert: o
  }), e.process();
};
G.handleHandshake = function(e, t) {
  var h = t.fragment, o = h.getByte(), S = h.getInt24();
  if (S > h.length())
    return e.fragmented = t, t.fragment = xe.util.createBuffer(), h.read -= 4, e.process();
  e.fragmented = null, h.read -= 4;
  var g = h.bytes(S + 4);
  h.read += 4, o in Vs[e.entity][e.expect] ? (e.entity === G.ConnectionEnd.server && !e.open && !e.fail && (e.handshaking = !0, e.session = {
    version: null,
    extensions: {
      server_name: {
        serverNameList: []
      }
    },
    cipherSuite: null,
    compressionMethod: null,
    serverCertificate: null,
    clientCertificate: null,
    md5: xe.md.md5.create(),
    sha1: xe.md.sha1.create()
  }), o !== G.HandshakeType.hello_request && o !== G.HandshakeType.certificate_verify && o !== G.HandshakeType.finished && (e.session.md5.update(g), e.session.sha1.update(g)), Vs[e.entity][e.expect][o](e, t, S)) : G.handleUnexpected(e, t);
};
G.handleApplicationData = function(e, t) {
  e.data.putBuffer(t.fragment), e.dataReady(e), e.process();
};
G.handleHeartbeat = function(e, t) {
  var h = t.fragment, o = h.getByte(), S = h.getInt16(), g = h.getBytes(S);
  if (o === G.HeartbeatMessageType.heartbeat_request) {
    if (e.handshaking || S > g.length)
      return e.process();
    G.queue(e, G.createRecord(e, {
      type: G.ContentType.heartbeat,
      data: G.createHeartbeat(
        G.HeartbeatMessageType.heartbeat_response,
        g
      )
    })), G.flush(e);
  } else if (o === G.HeartbeatMessageType.heartbeat_response) {
    if (g !== e.expectedHeartbeatPayload)
      return e.process();
    e.heartbeatReceived && e.heartbeatReceived(e, xe.util.createBuffer(g));
  }
  e.process();
};
var RI = 0, NI = 1, jp = 2, DI = 3, OI = 4, V2 = 5, PI = 6, LI = 7, kI = 8, UI = 0, FI = 1, Cc = 2, qI = 3, Gh = 4, VI = 5, KI = 6, K = G.handleUnexpected, K2 = G.handleChangeCipherSpec, nr = G.handleAlert, mr = G.handleHandshake, $2 = G.handleApplicationData, ar = G.handleHeartbeat, zh = [];
zh[G.ConnectionEnd.client] = [
  //      CC,AL,HS,AD,HB
  /*SHE*/
  [K, nr, mr, K, ar],
  /*SCE*/
  [K, nr, mr, K, ar],
  /*SKE*/
  [K, nr, mr, K, ar],
  /*SCR*/
  [K, nr, mr, K, ar],
  /*SHD*/
  [K, nr, mr, K, ar],
  /*SCC*/
  [K2, nr, K, K, ar],
  /*SFI*/
  [K, nr, mr, K, ar],
  /*SAD*/
  [K, nr, mr, $2, ar],
  /*SER*/
  [K, nr, mr, K, ar]
];
zh[G.ConnectionEnd.server] = [
  //      CC,AL,HS,AD
  /*CHE*/
  [K, nr, mr, K, ar],
  /*CCE*/
  [K, nr, mr, K, ar],
  /*CKE*/
  [K, nr, mr, K, ar],
  /*CCV*/
  [K, nr, mr, K, ar],
  /*CCC*/
  [K2, nr, K, K, ar],
  /*CFI*/
  [K, nr, mr, K, ar],
  /*CAD*/
  [K, nr, mr, $2, ar],
  /*CER*/
  [K, nr, mr, K, ar]
];
var dn = G.handleHelloRequest, $I = G.handleServerHello, H2 = G.handleCertificate, Wp = G.handleServerKeyExchange, qu = G.handleCertificateRequest, ss = G.handleServerHelloDone, G2 = G.handleFinished, Vs = [];
Vs[G.ConnectionEnd.client] = [
  //      HR,01,SH,03,04,05,06,07,08,09,10,SC,SK,CR,HD,15,CK,17,18,19,FI
  /*SHE*/
  [K, K, $I, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K],
  /*SCE*/
  [dn, K, K, K, K, K, K, K, K, K, K, H2, Wp, qu, ss, K, K, K, K, K, K],
  /*SKE*/
  [dn, K, K, K, K, K, K, K, K, K, K, K, Wp, qu, ss, K, K, K, K, K, K],
  /*SCR*/
  [dn, K, K, K, K, K, K, K, K, K, K, K, K, qu, ss, K, K, K, K, K, K],
  /*SHD*/
  [dn, K, K, K, K, K, K, K, K, K, K, K, K, K, ss, K, K, K, K, K, K],
  /*SCC*/
  [dn, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K],
  /*SFI*/
  [dn, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, G2],
  /*SAD*/
  [dn, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K],
  /*SER*/
  [dn, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K]
];
var HI = G.handleClientHello, GI = G.handleClientKeyExchange, zI = G.handleCertificateVerify;
Vs[G.ConnectionEnd.server] = [
  //      01,CH,02,03,04,05,06,07,08,09,10,CC,12,13,14,CV,CK,17,18,19,FI
  /*CHE*/
  [K, HI, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K],
  /*CCE*/
  [K, K, K, K, K, K, K, K, K, K, K, H2, K, K, K, K, K, K, K, K, K],
  /*CKE*/
  [K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, GI, K, K, K, K],
  /*CCV*/
  [K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, zI, K, K, K, K, K],
  /*CCC*/
  [K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K],
  /*CFI*/
  [K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, G2],
  /*CAD*/
  [K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K],
  /*CER*/
  [K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K, K]
];
G.generateKeys = function(e, t) {
  var h = Kf, o = t.client_random + t.server_random;
  e.session.resuming || (t.master_secret = h(
    t.pre_master_secret,
    "master secret",
    o,
    48
  ).bytes(), t.pre_master_secret = null), o = t.server_random + t.client_random;
  var S = 2 * t.mac_key_length + 2 * t.enc_key_length, g = e.version.major === G.Versions.TLS_1_0.major && e.version.minor === G.Versions.TLS_1_0.minor;
  g && (S += 2 * t.fixed_iv_length);
  var B = h(t.master_secret, "key expansion", o, S), M = {
    client_write_MAC_key: B.getBytes(t.mac_key_length),
    server_write_MAC_key: B.getBytes(t.mac_key_length),
    client_write_key: B.getBytes(t.enc_key_length),
    server_write_key: B.getBytes(t.enc_key_length)
  };
  return g && (M.client_write_IV = B.getBytes(t.fixed_iv_length), M.server_write_IV = B.getBytes(t.fixed_iv_length)), M;
};
G.createConnectionState = function(e) {
  var t = e.entity === G.ConnectionEnd.client, h = function() {
    var g = {
      // two 32-bit numbers, first is most significant
      sequenceNumber: [0, 0],
      macKey: null,
      macLength: 0,
      macFunction: null,
      cipherState: null,
      cipherFunction: function(B) {
        return !0;
      },
      compressionState: null,
      compressFunction: function(B) {
        return !0;
      },
      updateSequenceNumber: function() {
        g.sequenceNumber[1] === 4294967295 ? (g.sequenceNumber[1] = 0, ++g.sequenceNumber[0]) : ++g.sequenceNumber[1];
      }
    };
    return g;
  }, o = {
    read: h(),
    write: h()
  };
  if (o.read.update = function(g, B) {
    return o.read.cipherFunction(B, o.read) ? o.read.compressFunction(g, B, o.read) || g.error(g, {
      message: "Could not decompress record.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.decompression_failure
      }
    }) : g.error(g, {
      message: "Could not decrypt record or bad MAC.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        // doesn't matter if decryption failed or MAC was
        // invalid, return the same error so as not to reveal
        // which one occurred
        description: G.Alert.Description.bad_record_mac
      }
    }), !g.fail;
  }, o.write.update = function(g, B) {
    return o.write.compressFunction(g, B, o.write) ? o.write.cipherFunction(B, o.write) || g.error(g, {
      message: "Could not encrypt record.",
      send: !1,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.internal_error
      }
    }) : g.error(g, {
      message: "Could not compress record.",
      send: !1,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.internal_error
      }
    }), !g.fail;
  }, e.session) {
    var S = e.session.sp;
    switch (e.session.cipherSuite.initSecurityParameters(S), S.keys = G.generateKeys(e, S), o.read.macKey = t ? S.keys.server_write_MAC_key : S.keys.client_write_MAC_key, o.write.macKey = t ? S.keys.client_write_MAC_key : S.keys.server_write_MAC_key, e.session.cipherSuite.initConnectionState(o, e, S), S.compression_algorithm) {
      case G.CompressionMethod.none:
        break;
      case G.CompressionMethod.deflate:
        o.read.compressFunction = MI, o.write.compressFunction = TI;
        break;
      default:
        throw new Error("Unsupported compression algorithm.");
    }
  }
  return o;
};
G.createRandom = function() {
  var e = /* @__PURE__ */ new Date(), t = +e + e.getTimezoneOffset() * 6e4, h = xe.util.createBuffer();
  return h.putInt32(t), h.putBytes(xe.random.getBytes(28)), h;
};
G.createRecord = function(e, t) {
  if (!t.data)
    return null;
  var h = {
    type: t.type,
    version: {
      major: e.version.major,
      minor: e.version.minor
    },
    length: t.data.length(),
    fragment: t.data
  };
  return h;
};
G.createAlert = function(e, t) {
  var h = xe.util.createBuffer();
  return h.putByte(t.level), h.putByte(t.description), G.createRecord(e, {
    type: G.ContentType.alert,
    data: h
  });
};
G.createClientHello = function(e) {
  e.session.clientHelloVersion = {
    major: e.version.major,
    minor: e.version.minor
  };
  for (var t = xe.util.createBuffer(), h = 0; h < e.cipherSuites.length; ++h) {
    var o = e.cipherSuites[h];
    t.putByte(o.id[0]), t.putByte(o.id[1]);
  }
  var S = t.length(), g = xe.util.createBuffer();
  g.putByte(G.CompressionMethod.none);
  var B = g.length(), M = xe.util.createBuffer();
  if (e.virtualHost) {
    var O = xe.util.createBuffer();
    O.putByte(0), O.putByte(0);
    var P = xe.util.createBuffer();
    P.putByte(0), Fr(P, 2, xe.util.createBuffer(e.virtualHost));
    var D = xe.util.createBuffer();
    Fr(D, 2, P), Fr(O, 2, D), M.putBuffer(O);
  }
  var Z = M.length();
  Z > 0 && (Z += 2);
  var Y = e.session.id, ee = Y.length + 1 + // session ID vector
  2 + // version (major + minor)
  4 + 28 + // random time and random bytes
  2 + S + // cipher suites vector
  1 + B + // compression methods vector
  Z, ie = xe.util.createBuffer();
  return ie.putByte(G.HandshakeType.client_hello), ie.putInt24(ee), ie.putByte(e.version.major), ie.putByte(e.version.minor), ie.putBytes(e.session.sp.client_random), Fr(ie, 1, xe.util.createBuffer(Y)), Fr(ie, 2, t), Fr(ie, 1, g), Z > 0 && Fr(ie, 2, M), ie;
};
G.createServerHello = function(e) {
  var t = e.session.id, h = t.length + 1 + // session ID vector
  2 + // version (major + minor)
  4 + 28 + // random time and random bytes
  2 + // chosen cipher suite
  1, o = xe.util.createBuffer();
  return o.putByte(G.HandshakeType.server_hello), o.putInt24(h), o.putByte(e.version.major), o.putByte(e.version.minor), o.putBytes(e.session.sp.server_random), Fr(o, 1, xe.util.createBuffer(t)), o.putByte(e.session.cipherSuite.id[0]), o.putByte(e.session.cipherSuite.id[1]), o.putByte(e.session.compressionMethod), o;
};
G.createCertificate = function(e) {
  var t = e.entity === G.ConnectionEnd.client, h = null;
  if (e.getCertificate) {
    var o;
    t ? o = e.session.certificateRequest : o = e.session.extensions.server_name.serverNameList, h = e.getCertificate(e, o);
  }
  var S = xe.util.createBuffer();
  if (h !== null)
    try {
      xe.util.isArray(h) || (h = [h]);
      for (var g = null, B = 0; B < h.length; ++B) {
        var M = xe.pem.decode(h[B])[0];
        if (M.type !== "CERTIFICATE" && M.type !== "X509 CERTIFICATE" && M.type !== "TRUSTED CERTIFICATE") {
          var O = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
          throw O.headerType = M.type, O;
        }
        if (M.procType && M.procType.type === "ENCRYPTED")
          throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
        var P = xe.util.createBuffer(M.body);
        g === null && (g = xe.asn1.fromDer(P.bytes(), !1));
        var D = xe.util.createBuffer();
        Fr(D, 3, P), S.putBuffer(D);
      }
      h = xe.pki.certificateFromAsn1(g), t ? e.session.clientCertificate = h : e.session.serverCertificate = h;
    } catch (ee) {
      return e.error(e, {
        message: "Could not send certificate list.",
        cause: ee,
        send: !0,
        alert: {
          level: G.Alert.Level.fatal,
          description: G.Alert.Description.bad_certificate
        }
      });
    }
  var Z = 3 + S.length(), Y = xe.util.createBuffer();
  return Y.putByte(G.HandshakeType.certificate), Y.putInt24(Z), Fr(Y, 3, S), Y;
};
G.createClientKeyExchange = function(e) {
  var t = xe.util.createBuffer();
  t.putByte(e.session.clientHelloVersion.major), t.putByte(e.session.clientHelloVersion.minor), t.putBytes(xe.random.getBytes(46));
  var h = e.session.sp;
  h.pre_master_secret = t.getBytes();
  var o = e.session.serverCertificate.publicKey;
  t = o.encrypt(h.pre_master_secret);
  var S = t.length + 2, g = xe.util.createBuffer();
  return g.putByte(G.HandshakeType.client_key_exchange), g.putInt24(S), g.putInt16(t.length), g.putBytes(t), g;
};
G.createServerKeyExchange = function(e) {
  var t = xe.util.createBuffer();
  return t;
};
G.getClientSignature = function(e, t) {
  var h = xe.util.createBuffer();
  h.putBuffer(e.session.md5.digest()), h.putBuffer(e.session.sha1.digest()), h = h.getBytes(), e.getSignature = e.getSignature || function(o, S, g) {
    var B = null;
    if (o.getPrivateKey)
      try {
        B = o.getPrivateKey(o, o.session.clientCertificate), B = xe.pki.privateKeyFromPem(B);
      } catch (M) {
        o.error(o, {
          message: "Could not get private key.",
          cause: M,
          send: !0,
          alert: {
            level: G.Alert.Level.fatal,
            description: G.Alert.Description.internal_error
          }
        });
      }
    B === null ? o.error(o, {
      message: "No private key set.",
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: G.Alert.Description.internal_error
      }
    }) : S = B.sign(S, null), g(o, S);
  }, e.getSignature(e, h, t);
};
G.createCertificateVerify = function(e, t) {
  var h = t.length + 2, o = xe.util.createBuffer();
  return o.putByte(G.HandshakeType.certificate_verify), o.putInt24(h), o.putInt16(t.length), o.putBytes(t), o;
};
G.createCertificateRequest = function(e) {
  var t = xe.util.createBuffer();
  t.putByte(1);
  var h = xe.util.createBuffer();
  for (var o in e.caStore.certs) {
    var S = e.caStore.certs[o], g = xe.pki.distinguishedNameToAsn1(S.subject), B = xe.asn1.toDer(g);
    h.putInt16(B.length()), h.putBuffer(B);
  }
  var M = 1 + t.length() + 2 + h.length(), O = xe.util.createBuffer();
  return O.putByte(G.HandshakeType.certificate_request), O.putInt24(M), Fr(O, 1, t), Fr(O, 2, h), O;
};
G.createServerHelloDone = function(e) {
  var t = xe.util.createBuffer();
  return t.putByte(G.HandshakeType.server_hello_done), t.putInt24(0), t;
};
G.createChangeCipherSpec = function() {
  var e = xe.util.createBuffer();
  return e.putByte(1), e;
};
G.createFinished = function(e) {
  var t = xe.util.createBuffer();
  t.putBuffer(e.session.md5.digest()), t.putBuffer(e.session.sha1.digest());
  var h = e.entity === G.ConnectionEnd.client, o = e.session.sp, S = 12, g = Kf, B = h ? "client finished" : "server finished";
  t = g(o.master_secret, B, t.getBytes(), S);
  var M = xe.util.createBuffer();
  return M.putByte(G.HandshakeType.finished), M.putInt24(t.length()), M.putBuffer(t), M;
};
G.createHeartbeat = function(e, t, h) {
  typeof h > "u" && (h = t.length);
  var o = xe.util.createBuffer();
  o.putByte(e), o.putInt16(h), o.putBytes(t);
  var S = o.length(), g = Math.max(16, S - h - 3);
  return o.putBytes(xe.random.getBytes(g)), o;
};
G.queue = function(e, t) {
  if (t && !(t.fragment.length() === 0 && (t.type === G.ContentType.handshake || t.type === G.ContentType.alert || t.type === G.ContentType.change_cipher_spec))) {
    if (t.type === G.ContentType.handshake) {
      var h = t.fragment.bytes();
      e.session.md5.update(h), e.session.sha1.update(h), h = null;
    }
    var o;
    if (t.fragment.length() <= G.MaxFragment)
      o = [t];
    else {
      o = [];
      for (var S = t.fragment.bytes(); S.length > G.MaxFragment; )
        o.push(G.createRecord(e, {
          type: t.type,
          data: xe.util.createBuffer(S.slice(0, G.MaxFragment))
        })), S = S.slice(G.MaxFragment);
      S.length > 0 && o.push(G.createRecord(e, {
        type: t.type,
        data: xe.util.createBuffer(S)
      }));
    }
    for (var g = 0; g < o.length && !e.fail; ++g) {
      var B = o[g], M = e.state.current.write;
      M.update(e, B) && e.records.push(B);
    }
  }
};
G.flush = function(e) {
  for (var t = 0; t < e.records.length; ++t) {
    var h = e.records[t];
    e.tlsData.putByte(h.type), e.tlsData.putByte(h.version.major), e.tlsData.putByte(h.version.minor), e.tlsData.putInt16(h.fragment.length()), e.tlsData.putBuffer(e.records[t].fragment);
  }
  return e.records = [], e.tlsDataReady(e);
};
var Vu = function(e) {
  switch (e) {
    case !0:
      return !0;
    case xe.pki.certificateError.bad_certificate:
      return G.Alert.Description.bad_certificate;
    case xe.pki.certificateError.unsupported_certificate:
      return G.Alert.Description.unsupported_certificate;
    case xe.pki.certificateError.certificate_revoked:
      return G.Alert.Description.certificate_revoked;
    case xe.pki.certificateError.certificate_expired:
      return G.Alert.Description.certificate_expired;
    case xe.pki.certificateError.certificate_unknown:
      return G.Alert.Description.certificate_unknown;
    case xe.pki.certificateError.unknown_ca:
      return G.Alert.Description.unknown_ca;
    default:
      return G.Alert.Description.bad_certificate;
  }
}, jI = function(e) {
  switch (e) {
    case !0:
      return !0;
    case G.Alert.Description.bad_certificate:
      return xe.pki.certificateError.bad_certificate;
    case G.Alert.Description.unsupported_certificate:
      return xe.pki.certificateError.unsupported_certificate;
    case G.Alert.Description.certificate_revoked:
      return xe.pki.certificateError.certificate_revoked;
    case G.Alert.Description.certificate_expired:
      return xe.pki.certificateError.certificate_expired;
    case G.Alert.Description.certificate_unknown:
      return xe.pki.certificateError.certificate_unknown;
    case G.Alert.Description.unknown_ca:
      return xe.pki.certificateError.unknown_ca;
    default:
      return xe.pki.certificateError.bad_certificate;
  }
};
G.verifyCertificateChain = function(e, t) {
  try {
    var h = {};
    for (var o in e.verifyOptions)
      h[o] = e.verifyOptions[o];
    h.verify = function(g, B, M) {
      var O = Vu(g), P = e.verify(e, g, B, M);
      if (P !== !0) {
        if (typeof P == "object" && !xe.util.isArray(P)) {
          var D = new Error("The application rejected the certificate.");
          throw D.send = !0, D.alert = {
            level: G.Alert.Level.fatal,
            description: G.Alert.Description.bad_certificate
          }, P.message && (D.message = P.message), P.alert && (D.alert.description = P.alert), D;
        }
        P !== g && (P = jI(P));
      }
      return P;
    }, xe.pki.verifyCertificateChain(e.caStore, t, h);
  } catch (g) {
    var S = g;
    (typeof S != "object" || xe.util.isArray(S)) && (S = {
      send: !0,
      alert: {
        level: G.Alert.Level.fatal,
        description: Vu(g)
      }
    }), "send" in S || (S.send = !0), "alert" in S || (S.alert = {
      level: G.Alert.Level.fatal,
      description: Vu(S.error)
    }), e.error(e, S);
  }
  return !e.fail;
};
G.createSessionCache = function(e, t) {
  var h = null;
  if (e && e.getSession && e.setSession && e.order)
    h = e;
  else {
    h = {}, h.cache = e || {}, h.capacity = Math.max(t || 100, 1), h.order = [];
    for (var o in e)
      h.order.length <= t ? h.order.push(o) : delete e[o];
    h.getSession = function(S) {
      var g = null, B = null;
      if (S ? B = xe.util.bytesToHex(S) : h.order.length > 0 && (B = h.order[0]), B !== null && B in h.cache) {
        g = h.cache[B], delete h.cache[B];
        for (var M in h.order)
          if (h.order[M] === B) {
            h.order.splice(M, 1);
            break;
          }
      }
      return g;
    }, h.setSession = function(S, g) {
      if (h.order.length === h.capacity) {
        var B = h.order.shift();
        delete h.cache[B];
      }
      var B = xe.util.bytesToHex(S);
      h.order.push(B), h.cache[B] = g;
    };
  }
  return h;
};
G.createConnection = function(e) {
  var t = null;
  e.caStore ? xe.util.isArray(e.caStore) ? t = xe.pki.createCaStore(e.caStore) : t = e.caStore : t = xe.pki.createCaStore();
  var h = e.cipherSuites || null;
  if (h === null) {
    h = [];
    for (var o in G.CipherSuites)
      h.push(G.CipherSuites[o]);
  }
  var S = e.server ? G.ConnectionEnd.server : G.ConnectionEnd.client, g = e.sessionCache ? G.createSessionCache(e.sessionCache) : null, B = {
    version: { major: G.Version.major, minor: G.Version.minor },
    entity: S,
    sessionId: e.sessionId,
    caStore: t,
    sessionCache: g,
    cipherSuites: h,
    connected: e.connected,
    virtualHost: e.virtualHost || null,
    verifyClient: e.verifyClient || !1,
    verify: e.verify || function(D, Z, Y, ee) {
      return Z;
    },
    verifyOptions: e.verifyOptions || {},
    getCertificate: e.getCertificate || null,
    getPrivateKey: e.getPrivateKey || null,
    getSignature: e.getSignature || null,
    input: xe.util.createBuffer(),
    tlsData: xe.util.createBuffer(),
    data: xe.util.createBuffer(),
    tlsDataReady: e.tlsDataReady,
    dataReady: e.dataReady,
    heartbeatReceived: e.heartbeatReceived,
    closed: e.closed,
    error: function(D, Z) {
      Z.origin = Z.origin || (D.entity === G.ConnectionEnd.client ? "client" : "server"), Z.send && (G.queue(D, G.createAlert(D, Z.alert)), G.flush(D));
      var Y = Z.fatal !== !1;
      Y && (D.fail = !0), e.error(D, Z), Y && D.close(!1);
    },
    deflate: e.deflate || null,
    inflate: e.inflate || null
  };
  B.reset = function(D) {
    B.version = { major: G.Version.major, minor: G.Version.minor }, B.record = null, B.session = null, B.peerCertificate = null, B.state = {
      pending: null,
      current: null
    }, B.expect = B.entity === G.ConnectionEnd.client ? RI : UI, B.fragmented = null, B.records = [], B.open = !1, B.handshakes = 0, B.handshaking = !1, B.isConnected = !1, B.fail = !(D || typeof D > "u"), B.input.clear(), B.tlsData.clear(), B.data.clear(), B.state.current = G.createConnectionState(B);
  }, B.reset();
  var M = function(D, Z) {
    var Y = Z.type - G.ContentType.change_cipher_spec, ee = zh[D.entity][D.expect];
    Y in ee ? ee[Y](D, Z) : G.handleUnexpected(D, Z);
  }, O = function(D) {
    var Z = 0, Y = D.input, ee = Y.length();
    if (ee < 5)
      Z = 5 - ee;
    else {
      D.record = {
        type: Y.getByte(),
        version: {
          major: Y.getByte(),
          minor: Y.getByte()
        },
        length: Y.getInt16(),
        fragment: xe.util.createBuffer(),
        ready: !1
      };
      var ie = D.record.version.major === D.version.major;
      ie && D.session && D.session.version && (ie = D.record.version.minor === D.version.minor), ie || D.error(D, {
        message: "Incompatible TLS version.",
        send: !0,
        alert: {
          level: G.Alert.Level.fatal,
          description: G.Alert.Description.protocol_version
        }
      });
    }
    return Z;
  }, P = function(D) {
    var Z = 0, Y = D.input, ee = Y.length();
    if (ee < D.record.length)
      Z = D.record.length - ee;
    else {
      D.record.fragment.putBytes(Y.getBytes(D.record.length)), Y.compact();
      var ie = D.state.current.read;
      ie.update(D, D.record) && (D.fragmented !== null && (D.fragmented.type === D.record.type ? (D.fragmented.fragment.putBuffer(D.record.fragment), D.record = D.fragmented) : D.error(D, {
        message: "Invalid fragmented record.",
        send: !0,
        alert: {
          level: G.Alert.Level.fatal,
          description: G.Alert.Description.unexpected_message
        }
      })), D.record.ready = !0);
    }
    return Z;
  };
  return B.handshake = function(D) {
    if (B.entity !== G.ConnectionEnd.client)
      B.error(B, {
        message: "Cannot initiate handshake as a server.",
        fatal: !1
      });
    else if (B.handshaking)
      B.error(B, {
        message: "Handshake already in progress.",
        fatal: !1
      });
    else {
      B.fail && !B.open && B.handshakes === 0 && (B.fail = !1), B.handshaking = !0, D = D || "";
      var Z = null;
      D.length > 0 && (B.sessionCache && (Z = B.sessionCache.getSession(D)), Z === null && (D = "")), D.length === 0 && B.sessionCache && (Z = B.sessionCache.getSession(), Z !== null && (D = Z.id)), B.session = {
        id: D,
        version: null,
        cipherSuite: null,
        compressionMethod: null,
        serverCertificate: null,
        certificateRequest: null,
        clientCertificate: null,
        sp: {},
        md5: xe.md.md5.create(),
        sha1: xe.md.sha1.create()
      }, Z && (B.version = Z.version, B.session.sp = Z.sp), B.session.sp.client_random = G.createRandom().getBytes(), B.open = !0, G.queue(B, G.createRecord(B, {
        type: G.ContentType.handshake,
        data: G.createClientHello(B)
      })), G.flush(B);
    }
  }, B.process = function(D) {
    var Z = 0;
    return D && B.input.putBytes(D), B.fail || (B.record !== null && B.record.ready && B.record.fragment.isEmpty() && (B.record = null), B.record === null && (Z = O(B)), !B.fail && B.record !== null && !B.record.ready && (Z = P(B)), !B.fail && B.record !== null && B.record.ready && M(B, B.record)), Z;
  }, B.prepare = function(D) {
    return G.queue(B, G.createRecord(B, {
      type: G.ContentType.application_data,
      data: xe.util.createBuffer(D)
    })), G.flush(B);
  }, B.prepareHeartbeatRequest = function(D, Z) {
    return D instanceof xe.util.ByteBuffer && (D = D.bytes()), typeof Z > "u" && (Z = D.length), B.expectedHeartbeatPayload = D, G.queue(B, G.createRecord(B, {
      type: G.ContentType.heartbeat,
      data: G.createHeartbeat(
        G.HeartbeatMessageType.heartbeat_request,
        D,
        Z
      )
    })), G.flush(B);
  }, B.close = function(D) {
    if (!B.fail && B.sessionCache && B.session) {
      var Z = {
        id: B.session.id,
        version: B.session.version,
        sp: B.session.sp
      };
      Z.sp.keys = null, B.sessionCache.setSession(Z.id, Z);
    }
    B.open && (B.open = !1, B.input.clear(), (B.isConnected || B.handshaking) && (B.isConnected = B.handshaking = !1, G.queue(B, G.createAlert(B, {
      level: G.Alert.Level.warning,
      description: G.Alert.Description.close_notify
    })), G.flush(B)), B.closed(B)), B.reset(D);
  }, B;
};
xe.tls = xe.tls || {};
for (var Ku in G)
  typeof G[Ku] != "function" && (xe.tls[Ku] = G[Ku]);
xe.tls.prf_tls1 = Kf;
xe.tls.hmac_sha1 = II;
xe.tls.createSessionCache = G.createSessionCache;
xe.tls.createConnection = G.createConnection;
var Sn = ht, zr = Sn.tls;
zr.CipherSuites.TLS_RSA_WITH_AES_128_CBC_SHA = {
  id: [0, 47],
  name: "TLS_RSA_WITH_AES_128_CBC_SHA",
  initSecurityParameters: function(e) {
    e.bulk_cipher_algorithm = zr.BulkCipherAlgorithm.aes, e.cipher_type = zr.CipherType.block, e.enc_key_length = 16, e.block_length = 16, e.fixed_iv_length = 16, e.record_iv_length = 16, e.mac_algorithm = zr.MACAlgorithm.hmac_sha1, e.mac_length = 20, e.mac_key_length = 20;
  },
  initConnectionState: z2
};
zr.CipherSuites.TLS_RSA_WITH_AES_256_CBC_SHA = {
  id: [0, 53],
  name: "TLS_RSA_WITH_AES_256_CBC_SHA",
  initSecurityParameters: function(e) {
    e.bulk_cipher_algorithm = zr.BulkCipherAlgorithm.aes, e.cipher_type = zr.CipherType.block, e.enc_key_length = 32, e.block_length = 16, e.fixed_iv_length = 16, e.record_iv_length = 16, e.mac_algorithm = zr.MACAlgorithm.hmac_sha1, e.mac_length = 20, e.mac_key_length = 20;
  },
  initConnectionState: z2
};
function z2(e, t, h) {
  var o = t.entity === Sn.tls.ConnectionEnd.client;
  e.read.cipherState = {
    init: !1,
    cipher: Sn.cipher.createDecipher("AES-CBC", o ? h.keys.server_write_key : h.keys.client_write_key),
    iv: o ? h.keys.server_write_IV : h.keys.client_write_IV
  }, e.write.cipherState = {
    init: !1,
    cipher: Sn.cipher.createCipher("AES-CBC", o ? h.keys.client_write_key : h.keys.server_write_key),
    iv: o ? h.keys.client_write_IV : h.keys.server_write_IV
  }, e.read.cipherFunction = QI, e.write.cipherFunction = WI, e.read.macLength = e.write.macLength = h.mac_length, e.read.macFunction = e.write.macFunction = zr.hmac_sha1;
}
function WI(e, t) {
  var h = !1, o = t.macFunction(t.macKey, t.sequenceNumber, e);
  e.fragment.putBytes(o), t.updateSequenceNumber();
  var S;
  e.version.minor === zr.Versions.TLS_1_0.minor ? S = t.cipherState.init ? null : t.cipherState.iv : S = Sn.random.getBytesSync(16), t.cipherState.init = !0;
  var g = t.cipherState.cipher;
  return g.start({ iv: S }), e.version.minor >= zr.Versions.TLS_1_1.minor && g.output.putBytes(S), g.update(e.fragment), g.finish(YI) && (e.fragment = g.output, e.length = e.fragment.length(), h = !0), h;
}
function YI(e, t, h) {
  if (!h) {
    var o = e - t.length() % e;
    t.fillWithByte(o - 1, o);
  }
  return !0;
}
function XI(e, t, h) {
  var o = !0;
  if (h) {
    for (var S = t.length(), g = t.last(), B = S - 1 - g; B < S - 1; ++B)
      o = o && t.at(B) == g;
    o && t.truncate(g + 1);
  }
  return o;
}
function QI(e, t) {
  var h = !1, o;
  e.version.minor === zr.Versions.TLS_1_0.minor ? o = t.cipherState.init ? null : t.cipherState.iv : o = e.fragment.getBytes(16), t.cipherState.init = !0;
  var S = t.cipherState.cipher;
  S.start({ iv: o }), S.update(e.fragment), h = S.finish(XI);
  var g = t.macLength, B = Sn.random.getBytesSync(g), M = S.output.length();
  M >= g ? (e.fragment = S.output.getBytes(M - g), B = S.output.getBytes(g)) : e.fragment = S.output.getBytes(), e.fragment = Sn.util.createBuffer(e.fragment), e.length = e.fragment.length();
  var O = t.macFunction(t.macKey, t.sequenceNumber, e);
  return t.updateSequenceNumber(), h = ZI(t.macKey, B, O) && h, h;
}
function ZI(e, t, h) {
  var o = Sn.hmac.create();
  return o.start("SHA1", e), o.update(t), t = o.digest().getBytes(), o.start(null, null), o.update(h), h = o.digest().getBytes(), t === h;
}
var Ft = ht, Y0 = Ft.sha512 = Ft.sha512 || {};
Ft.md.sha512 = Ft.md.algorithms.sha512 = Y0;
var j2 = Ft.sha384 = Ft.sha512.sha384 = Ft.sha512.sha384 || {};
j2.create = function() {
  return Y0.create("SHA-384");
};
Ft.md.sha384 = Ft.md.algorithms.sha384 = j2;
Ft.sha512.sha256 = Ft.sha512.sha256 || {
  create: function() {
    return Y0.create("SHA-512/256");
  }
};
Ft.md["sha512/256"] = Ft.md.algorithms["sha512/256"] = Ft.sha512.sha256;
Ft.sha512.sha224 = Ft.sha512.sha224 || {
  create: function() {
    return Y0.create("SHA-512/224");
  }
};
Ft.md["sha512/224"] = Ft.md.algorithms["sha512/224"] = Ft.sha512.sha224;
Y0.create = function(e) {
  if (W2 || JI(), typeof e > "u" && (e = "SHA-512"), !(e in Kn))
    throw new Error("Invalid SHA-512 algorithm: " + e);
  for (var t = Kn[e], h = null, o = Ft.util.createBuffer(), S = new Array(80), g = 0; g < 80; ++g)
    S[g] = new Array(2);
  var B = 64;
  switch (e) {
    case "SHA-384":
      B = 48;
      break;
    case "SHA-512/256":
      B = 32;
      break;
    case "SHA-512/224":
      B = 28;
      break;
  }
  var M = {
    // SHA-512 => sha512
    algorithm: e.replace("-", "").toLowerCase(),
    blockLength: 128,
    digestLength: B,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 16
  };
  return M.start = function() {
    M.messageLength = 0, M.fullMessageLength = M.messageLength128 = [];
    for (var O = M.messageLengthSize / 4, P = 0; P < O; ++P)
      M.fullMessageLength.push(0);
    o = Ft.util.createBuffer(), h = new Array(t.length);
    for (var P = 0; P < t.length; ++P)
      h[P] = t[P].slice(0);
    return M;
  }, M.start(), M.update = function(O, P) {
    P === "utf8" && (O = Ft.util.encodeUtf8(O));
    var D = O.length;
    M.messageLength += D, D = [D / 4294967296 >>> 0, D >>> 0];
    for (var Z = M.fullMessageLength.length - 1; Z >= 0; --Z)
      M.fullMessageLength[Z] += D[1], D[1] = D[0] + (M.fullMessageLength[Z] / 4294967296 >>> 0), M.fullMessageLength[Z] = M.fullMessageLength[Z] >>> 0, D[0] = D[1] / 4294967296 >>> 0;
    return o.putBytes(O), Yp(h, S, o), (o.read > 2048 || o.length() === 0) && o.compact(), M;
  }, M.digest = function() {
    var O = Ft.util.createBuffer();
    O.putBytes(o.bytes());
    var P = M.fullMessageLength[M.fullMessageLength.length - 1] + M.messageLengthSize, D = P & M.blockLength - 1;
    O.putBytes(Ac.substr(0, M.blockLength - D));
    for (var Z, Y, ee = M.fullMessageLength[0] * 8, ie = 0; ie < M.fullMessageLength.length - 1; ++ie)
      Z = M.fullMessageLength[ie + 1] * 8, Y = Z / 4294967296 >>> 0, ee += Y, O.putInt32(ee >>> 0), ee = Z >>> 0;
    O.putInt32(ee);
    for (var ue = new Array(h.length), ie = 0; ie < h.length; ++ie)
      ue[ie] = h[ie].slice(0);
    Yp(ue, S, O);
    var fe = Ft.util.createBuffer(), de;
    e === "SHA-512" ? de = ue.length : e === "SHA-384" ? de = ue.length - 2 : de = ue.length - 4;
    for (var ie = 0; ie < de; ++ie)
      fe.putInt32(ue[ie][0]), (ie !== de - 1 || e !== "SHA-512/224") && fe.putInt32(ue[ie][1]);
    return fe;
  }, M;
};
var Ac = null, W2 = !1, Bc = null, Kn = null;
function JI() {
  Ac = "", Ac += Ft.util.fillString("\0", 128), Bc = [
    [1116352408, 3609767458],
    [1899447441, 602891725],
    [3049323471, 3964484399],
    [3921009573, 2173295548],
    [961987163, 4081628472],
    [1508970993, 3053834265],
    [2453635748, 2937671579],
    [2870763221, 3664609560],
    [3624381080, 2734883394],
    [310598401, 1164996542],
    [607225278, 1323610764],
    [1426881987, 3590304994],
    [1925078388, 4068182383],
    [2162078206, 991336113],
    [2614888103, 633803317],
    [3248222580, 3479774868],
    [3835390401, 2666613458],
    [4022224774, 944711139],
    [264347078, 2341262773],
    [604807628, 2007800933],
    [770255983, 1495990901],
    [1249150122, 1856431235],
    [1555081692, 3175218132],
    [1996064986, 2198950837],
    [2554220882, 3999719339],
    [2821834349, 766784016],
    [2952996808, 2566594879],
    [3210313671, 3203337956],
    [3336571891, 1034457026],
    [3584528711, 2466948901],
    [113926993, 3758326383],
    [338241895, 168717936],
    [666307205, 1188179964],
    [773529912, 1546045734],
    [1294757372, 1522805485],
    [1396182291, 2643833823],
    [1695183700, 2343527390],
    [1986661051, 1014477480],
    [2177026350, 1206759142],
    [2456956037, 344077627],
    [2730485921, 1290863460],
    [2820302411, 3158454273],
    [3259730800, 3505952657],
    [3345764771, 106217008],
    [3516065817, 3606008344],
    [3600352804, 1432725776],
    [4094571909, 1467031594],
    [275423344, 851169720],
    [430227734, 3100823752],
    [506948616, 1363258195],
    [659060556, 3750685593],
    [883997877, 3785050280],
    [958139571, 3318307427],
    [1322822218, 3812723403],
    [1537002063, 2003034995],
    [1747873779, 3602036899],
    [1955562222, 1575990012],
    [2024104815, 1125592928],
    [2227730452, 2716904306],
    [2361852424, 442776044],
    [2428436474, 593698344],
    [2756734187, 3733110249],
    [3204031479, 2999351573],
    [3329325298, 3815920427],
    [3391569614, 3928383900],
    [3515267271, 566280711],
    [3940187606, 3454069534],
    [4118630271, 4000239992],
    [116418474, 1914138554],
    [174292421, 2731055270],
    [289380356, 3203993006],
    [460393269, 320620315],
    [685471733, 587496836],
    [852142971, 1086792851],
    [1017036298, 365543100],
    [1126000580, 2618297676],
    [1288033470, 3409855158],
    [1501505948, 4234509866],
    [1607167915, 987167468],
    [1816402316, 1246189591]
  ], Kn = {}, Kn["SHA-512"] = [
    [1779033703, 4089235720],
    [3144134277, 2227873595],
    [1013904242, 4271175723],
    [2773480762, 1595750129],
    [1359893119, 2917565137],
    [2600822924, 725511199],
    [528734635, 4215389547],
    [1541459225, 327033209]
  ], Kn["SHA-384"] = [
    [3418070365, 3238371032],
    [1654270250, 914150663],
    [2438529370, 812702999],
    [355462360, 4144912697],
    [1731405415, 4290775857],
    [2394180231, 1750603025],
    [3675008525, 1694076839],
    [1203062813, 3204075428]
  ], Kn["SHA-512/256"] = [
    [573645204, 4230739756],
    [2673172387, 3360449730],
    [596883563, 1867755857],
    [2520282905, 1497426621],
    [2519219938, 2827943907],
    [3193839141, 1401305490],
    [721525244, 746961066],
    [246885852, 2177182882]
  ], Kn["SHA-512/224"] = [
    [2352822216, 424955298],
    [1944164710, 2312950998],
    [502970286, 855612546],
    [1738396948, 1479516111],
    [258812777, 2077511080],
    [2011393907, 79989058],
    [1067287976, 1780299464],
    [286451373, 2446758561]
  ], W2 = !0;
}
function Yp(e, t, h) {
  for (var o, S, g, B, M, O, P, D, Z, Y, ee, ie, ue, fe, de, ce, be, ve, Pe, Ue, ze, Le, Ne, $e, J, ne, A, I, U, X, Q, F, $, H, q, z = h.length(); z >= 128; ) {
    for (U = 0; U < 16; ++U)
      t[U][0] = h.getInt32() >>> 0, t[U][1] = h.getInt32() >>> 0;
    for (; U < 80; ++U)
      F = t[U - 2], X = F[0], Q = F[1], o = ((X >>> 19 | Q << 13) ^ // ROTR 19
      (Q >>> 29 | X << 3) ^ // ROTR 61/(swap + ROTR 29)
      X >>> 6) >>> 0, S = ((X << 13 | Q >>> 19) ^ // ROTR 19
      (Q << 3 | X >>> 29) ^ // ROTR 61/(swap + ROTR 29)
      (X << 26 | Q >>> 6)) >>> 0, H = t[U - 15], X = H[0], Q = H[1], g = ((X >>> 1 | Q << 31) ^ // ROTR 1
      (X >>> 8 | Q << 24) ^ // ROTR 8
      X >>> 7) >>> 0, B = ((X << 31 | Q >>> 1) ^ // ROTR 1
      (X << 24 | Q >>> 8) ^ // ROTR 8
      (X << 25 | Q >>> 7)) >>> 0, $ = t[U - 7], q = t[U - 16], Q = S + $[1] + B + q[1], t[U][0] = o + $[0] + g + q[0] + (Q / 4294967296 >>> 0) >>> 0, t[U][1] = Q >>> 0;
    for (ue = e[0][0], fe = e[0][1], de = e[1][0], ce = e[1][1], be = e[2][0], ve = e[2][1], Pe = e[3][0], Ue = e[3][1], ze = e[4][0], Le = e[4][1], Ne = e[5][0], $e = e[5][1], J = e[6][0], ne = e[6][1], A = e[7][0], I = e[7][1], U = 0; U < 80; ++U)
      P = ((ze >>> 14 | Le << 18) ^ // ROTR 14
      (ze >>> 18 | Le << 14) ^ // ROTR 18
      (Le >>> 9 | ze << 23)) >>> 0, D = ((ze << 18 | Le >>> 14) ^ // ROTR 14
      (ze << 14 | Le >>> 18) ^ // ROTR 18
      (Le << 23 | ze >>> 9)) >>> 0, Z = (J ^ ze & (Ne ^ J)) >>> 0, Y = (ne ^ Le & ($e ^ ne)) >>> 0, M = ((ue >>> 28 | fe << 4) ^ // ROTR 28
      (fe >>> 2 | ue << 30) ^ // ROTR 34/(swap + ROTR 2)
      (fe >>> 7 | ue << 25)) >>> 0, O = ((ue << 4 | fe >>> 28) ^ // ROTR 28
      (fe << 30 | ue >>> 2) ^ // ROTR 34/(swap + ROTR 2)
      (fe << 25 | ue >>> 7)) >>> 0, ee = (ue & de | be & (ue ^ de)) >>> 0, ie = (fe & ce | ve & (fe ^ ce)) >>> 0, Q = I + D + Y + Bc[U][1] + t[U][1], o = A + P + Z + Bc[U][0] + t[U][0] + (Q / 4294967296 >>> 0) >>> 0, S = Q >>> 0, Q = O + ie, g = M + ee + (Q / 4294967296 >>> 0) >>> 0, B = Q >>> 0, A = J, I = ne, J = Ne, ne = $e, Ne = ze, $e = Le, Q = Ue + S, ze = Pe + o + (Q / 4294967296 >>> 0) >>> 0, Le = Q >>> 0, Pe = be, Ue = ve, be = de, ve = ce, de = ue, ce = fe, Q = S + B, ue = o + g + (Q / 4294967296 >>> 0) >>> 0, fe = Q >>> 0;
    Q = e[0][1] + fe, e[0][0] = e[0][0] + ue + (Q / 4294967296 >>> 0) >>> 0, e[0][1] = Q >>> 0, Q = e[1][1] + ce, e[1][0] = e[1][0] + de + (Q / 4294967296 >>> 0) >>> 0, e[1][1] = Q >>> 0, Q = e[2][1] + ve, e[2][0] = e[2][0] + be + (Q / 4294967296 >>> 0) >>> 0, e[2][1] = Q >>> 0, Q = e[3][1] + Ue, e[3][0] = e[3][0] + Pe + (Q / 4294967296 >>> 0) >>> 0, e[3][1] = Q >>> 0, Q = e[4][1] + Le, e[4][0] = e[4][0] + ze + (Q / 4294967296 >>> 0) >>> 0, e[4][1] = Q >>> 0, Q = e[5][1] + $e, e[5][0] = e[5][0] + Ne + (Q / 4294967296 >>> 0) >>> 0, e[5][1] = Q >>> 0, Q = e[6][1] + ne, e[6][0] = e[6][0] + J + (Q / 4294967296 >>> 0) >>> 0, e[6][1] = Q >>> 0, Q = e[7][1] + I, e[7][0] = e[7][0] + A + (Q / 4294967296 >>> 0) >>> 0, e[7][1] = Q >>> 0, z -= 128;
  }
}
var jh = {}, eT = ht, Xt = eT.asn1;
jh.privateKeyValidator = {
  // PrivateKeyInfo
  name: "PrivateKeyInfo",
  tagClass: Xt.Class.UNIVERSAL,
  type: Xt.Type.SEQUENCE,
  constructed: !0,
  value: [{
    // Version (INTEGER)
    name: "PrivateKeyInfo.version",
    tagClass: Xt.Class.UNIVERSAL,
    type: Xt.Type.INTEGER,
    constructed: !1,
    capture: "privateKeyVersion"
  }, {
    // privateKeyAlgorithm
    name: "PrivateKeyInfo.privateKeyAlgorithm",
    tagClass: Xt.Class.UNIVERSAL,
    type: Xt.Type.SEQUENCE,
    constructed: !0,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: Xt.Class.UNIVERSAL,
      type: Xt.Type.OID,
      constructed: !1,
      capture: "privateKeyOid"
    }]
  }, {
    // PrivateKey
    name: "PrivateKeyInfo",
    tagClass: Xt.Class.UNIVERSAL,
    type: Xt.Type.OCTETSTRING,
    constructed: !1,
    capture: "privateKey"
  }]
};
jh.publicKeyValidator = {
  name: "SubjectPublicKeyInfo",
  tagClass: Xt.Class.UNIVERSAL,
  type: Xt.Type.SEQUENCE,
  constructed: !0,
  captureAsn1: "subjectPublicKeyInfo",
  value: [
    {
      name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
      tagClass: Xt.Class.UNIVERSAL,
      type: Xt.Type.SEQUENCE,
      constructed: !0,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: Xt.Class.UNIVERSAL,
        type: Xt.Type.OID,
        constructed: !1,
        capture: "publicKeyOid"
      }]
    },
    // capture group for ed25519PublicKey
    {
      tagClass: Xt.Class.UNIVERSAL,
      type: Xt.Type.BITSTRING,
      constructed: !1,
      composed: !0,
      captureBitStringValue: "ed25519PublicKey"
    }
    // FIXME: this is capture group for rsaPublicKey, use it in this API or
    // discard?
    /* {
      // subjectPublicKey
      name: 'SubjectPublicKeyInfo.subjectPublicKey',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.BITSTRING,
      constructed: false,
      value: [{
        // RSAPublicKey
        name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        optional: true,
        captureAsn1: 'rsaPublicKey'
      }]
    } */
  ]
};
var sr = ht, Y2 = jh, tT = Y2.publicKeyValidator, rT = Y2.privateKeyValidator;
if (typeof iT > "u")
  var iT = sr.jsbn.BigInteger;
var Ic = sr.util.ByteBuffer, Tr = typeof pe.Buffer > "u" ? Uint8Array : pe.Buffer;
sr.pki = sr.pki || {};
sr.pki.ed25519 = sr.ed25519 = sr.ed25519 || {};
var dt = sr.ed25519;
dt.constants = {};
dt.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
dt.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
dt.constants.SEED_BYTE_LENGTH = 32;
dt.constants.SIGN_BYTE_LENGTH = 64;
dt.constants.HASH_BYTE_LENGTH = 64;
dt.generateKeyPair = function(e) {
  e = e || {};
  var t = e.seed;
  if (t === void 0)
    t = sr.random.getBytesSync(dt.constants.SEED_BYTE_LENGTH);
  else if (typeof t == "string") {
    if (t.length !== dt.constants.SEED_BYTE_LENGTH)
      throw new TypeError(
        '"seed" must be ' + dt.constants.SEED_BYTE_LENGTH + " bytes in length."
      );
  } else if (!(t instanceof Uint8Array))
    throw new TypeError(
      '"seed" must be a node.js Buffer, Uint8Array, or a binary string.'
    );
  t = an({ message: t, encoding: "binary" });
  for (var h = new Tr(dt.constants.PUBLIC_KEY_BYTE_LENGTH), o = new Tr(dt.constants.PRIVATE_KEY_BYTE_LENGTH), S = 0; S < 32; ++S)
    o[S] = t[S];
  return fT(h, o), { publicKey: h, privateKey: o };
};
dt.privateKeyFromAsn1 = function(e) {
  var t = {}, h = [], o = sr.asn1.validate(e, rT, t, h);
  if (!o) {
    var S = new Error("Invalid Key.");
    throw S.errors = h, S;
  }
  var g = sr.asn1.derToOid(t.privateKeyOid), B = sr.oids.EdDSA25519;
  if (g !== B)
    throw new Error('Invalid OID "' + g + '"; OID must be "' + B + '".');
  var M = t.privateKey, O = an({
    message: sr.asn1.fromDer(M).value,
    encoding: "binary"
  });
  return { privateKeyBytes: O };
};
dt.publicKeyFromAsn1 = function(e) {
  var t = {}, h = [], o = sr.asn1.validate(e, tT, t, h);
  if (!o) {
    var S = new Error("Invalid Key.");
    throw S.errors = h, S;
  }
  var g = sr.asn1.derToOid(t.publicKeyOid), B = sr.oids.EdDSA25519;
  if (g !== B)
    throw new Error('Invalid OID "' + g + '"; OID must be "' + B + '".');
  var M = t.ed25519PublicKey;
  if (M.length !== dt.constants.PUBLIC_KEY_BYTE_LENGTH)
    throw new Error("Key length is invalid.");
  return an({
    message: M,
    encoding: "binary"
  });
};
dt.publicKeyFromPrivateKey = function(e) {
  e = e || {};
  var t = an({
    message: e.privateKey,
    encoding: "binary"
  });
  if (t.length !== dt.constants.PRIVATE_KEY_BYTE_LENGTH)
    throw new TypeError(
      '"options.privateKey" must have a byte length of ' + dt.constants.PRIVATE_KEY_BYTE_LENGTH
    );
  for (var h = new Tr(dt.constants.PUBLIC_KEY_BYTE_LENGTH), o = 0; o < h.length; ++o)
    h[o] = t[32 + o];
  return h;
};
dt.sign = function(e) {
  e = e || {};
  var t = an(e), h = an({
    message: e.privateKey,
    encoding: "binary"
  });
  if (h.length === dt.constants.SEED_BYTE_LENGTH) {
    var o = dt.generateKeyPair({ seed: h });
    h = o.privateKey;
  } else if (h.length !== dt.constants.PRIVATE_KEY_BYTE_LENGTH)
    throw new TypeError(
      '"options.privateKey" must have a byte length of ' + dt.constants.SEED_BYTE_LENGTH + " or " + dt.constants.PRIVATE_KEY_BYTE_LENGTH
    );
  var S = new Tr(
    dt.constants.SIGN_BYTE_LENGTH + t.length
  );
  oT(S, t, t.length, h);
  for (var g = new Tr(dt.constants.SIGN_BYTE_LENGTH), B = 0; B < g.length; ++B)
    g[B] = S[B];
  return g;
};
dt.verify = function(e) {
  e = e || {};
  var t = an(e);
  if (e.signature === void 0)
    throw new TypeError(
      '"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'
    );
  var h = an({
    message: e.signature,
    encoding: "binary"
  });
  if (h.length !== dt.constants.SIGN_BYTE_LENGTH)
    throw new TypeError(
      '"options.signature" must have a byte length of ' + dt.constants.SIGN_BYTE_LENGTH
    );
  var o = an({
    message: e.publicKey,
    encoding: "binary"
  });
  if (o.length !== dt.constants.PUBLIC_KEY_BYTE_LENGTH)
    throw new TypeError(
      '"options.publicKey" must have a byte length of ' + dt.constants.PUBLIC_KEY_BYTE_LENGTH
    );
  var S = new Tr(dt.constants.SIGN_BYTE_LENGTH + t.length), g = new Tr(dt.constants.SIGN_BYTE_LENGTH + t.length), B;
  for (B = 0; B < dt.constants.SIGN_BYTE_LENGTH; ++B)
    S[B] = h[B];
  for (B = 0; B < t.length; ++B)
    S[B + dt.constants.SIGN_BYTE_LENGTH] = t[B];
  return uT(g, S, S.length, o) >= 0;
};
function an(e) {
  var t = e.message;
  if (t instanceof Uint8Array || t instanceof Tr)
    return t;
  var h = e.encoding;
  if (t === void 0)
    if (e.md)
      t = e.md.digest().getBytes(), h = "binary";
    else
      throw new TypeError('"options.message" or "options.md" not specified.');
  if (typeof t == "string" && !h)
    throw new TypeError('"options.encoding" must be "binary" or "utf8".');
  if (typeof t == "string") {
    if (typeof pe.Buffer < "u")
      return pe.Buffer.from(t, h);
    t = new Ic(t, h);
  } else if (!(t instanceof Ic))
    throw new TypeError(
      '"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.'
    );
  for (var o = new Tr(t.length()), S = 0; S < o.length; ++S)
    o[S] = t.at(S);
  return o;
}
var Tc = We(), Ks = We([1]), nT = We([
  30883,
  4953,
  19914,
  30187,
  55467,
  16705,
  2637,
  112,
  59544,
  30585,
  16505,
  36039,
  65139,
  11119,
  27886,
  20995
]), aT = We([
  61785,
  9906,
  39828,
  60374,
  45398,
  33411,
  5274,
  224,
  53552,
  61171,
  33010,
  6542,
  64743,
  22239,
  55772,
  9222
]), Xp = We([
  54554,
  36645,
  11616,
  51542,
  42930,
  38181,
  51040,
  26924,
  56412,
  64982,
  57905,
  49316,
  21502,
  52590,
  14035,
  8553
]), Qp = We([
  26200,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214
]), $u = new Float64Array([
  237,
  211,
  245,
  92,
  26,
  99,
  18,
  88,
  214,
  156,
  247,
  162,
  222,
  249,
  222,
  20,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  16
]), sT = We([
  41136,
  18958,
  6951,
  50414,
  58488,
  44335,
  6150,
  12099,
  55207,
  15867,
  153,
  11085,
  57099,
  20417,
  9344,
  11139
]);
function S0(e, t) {
  var h = sr.md.sha512.create(), o = new Ic(e);
  h.update(o.getBytes(t), "binary");
  var S = h.digest().getBytes();
  if (typeof pe.Buffer < "u")
    return pe.Buffer.from(S, "binary");
  for (var g = new Tr(dt.constants.HASH_BYTE_LENGTH), B = 0; B < 64; ++B)
    g[B] = S.charCodeAt(B);
  return g;
}
function fT(e, t) {
  var h = [We(), We(), We(), We()], o, S = S0(t, 32);
  for (S[0] &= 248, S[31] &= 127, S[31] |= 64, Yh(h, S), Wh(e, h), o = 0; o < 32; ++o)
    t[o + 32] = e[o];
  return 0;
}
function oT(e, t, h, o) {
  var S, g, B = new Float64Array(64), M = [We(), We(), We(), We()], O = S0(o, 32);
  O[0] &= 248, O[31] &= 127, O[31] |= 64;
  var P = h + 64;
  for (S = 0; S < h; ++S)
    e[64 + S] = t[S];
  for (S = 0; S < 32; ++S)
    e[32 + S] = O[32 + S];
  var D = S0(e.subarray(32), h + 32);
  for (Mc(D), Yh(M, D), Wh(e, M), S = 32; S < 64; ++S)
    e[S] = o[S];
  var Z = S0(e, h + 64);
  for (Mc(Z), S = 32; S < 64; ++S)
    B[S] = 0;
  for (S = 0; S < 32; ++S)
    B[S] = D[S];
  for (S = 0; S < 32; ++S)
    for (g = 0; g < 32; g++)
      B[S + g] += Z[S] * O[g];
  return X2(e.subarray(32), B), P;
}
function uT(e, t, h, o) {
  var S, g, B = new Tr(32), M = [We(), We(), We(), We()], O = [We(), We(), We(), We()];
  if (g = -1, h < 64 || cT(O, o))
    return -1;
  for (S = 0; S < h; ++S)
    e[S] = t[S];
  for (S = 0; S < 32; ++S)
    e[S + 32] = o[S];
  var P = S0(e, h);
  if (Mc(P), J2(M, O, P), Yh(O, t.subarray(32)), Rc(M, O), Wh(B, M), h -= 64, Q2(t, 0, B, 0)) {
    for (S = 0; S < h; ++S)
      e[S] = 0;
    return -1;
  }
  for (S = 0; S < h; ++S)
    e[S] = t[S + 64];
  return g = h, g;
}
function X2(e, t) {
  var h, o, S, g;
  for (o = 63; o >= 32; --o) {
    for (h = 0, S = o - 32, g = o - 12; S < g; ++S)
      t[S] += h - 16 * t[o] * $u[S - (o - 32)], h = t[S] + 128 >> 8, t[S] -= h * 256;
    t[S] += h, t[o] = 0;
  }
  for (h = 0, S = 0; S < 32; ++S)
    t[S] += h - (t[31] >> 4) * $u[S], h = t[S] >> 8, t[S] &= 255;
  for (S = 0; S < 32; ++S)
    t[S] -= h * $u[S];
  for (o = 0; o < 32; ++o)
    t[o + 1] += t[o] >> 8, e[o] = t[o] & 255;
}
function Mc(e) {
  for (var t = new Float64Array(64), h = 0; h < 64; ++h)
    t[h] = e[h], e[h] = 0;
  X2(e, t);
}
function Rc(e, t) {
  var h = We(), o = We(), S = We(), g = We(), B = We(), M = We(), O = We(), P = We(), D = We();
  ma(h, e[1], e[0]), ma(D, t[1], t[0]), Nt(h, h, D), pa(o, e[0], e[1]), pa(D, t[0], t[1]), Nt(o, o, D), Nt(S, e[3], t[3]), Nt(S, S, aT), Nt(g, e[2], t[2]), pa(g, g, g), ma(B, o, h), ma(M, g, S), pa(O, g, S), pa(P, o, h), Nt(e[0], B, M), Nt(e[1], P, O), Nt(e[2], O, M), Nt(e[3], B, P);
}
function Zp(e, t, h) {
  for (var o = 0; o < 4; ++o)
    eg(e[o], t[o], h);
}
function Wh(e, t) {
  var h = We(), o = We(), S = We();
  pT(S, t[2]), Nt(h, t[0], S), Nt(o, t[1], S), $s(e, o), e[31] ^= Z2(h) << 7;
}
function $s(e, t) {
  var h, o, S, g = We(), B = We();
  for (h = 0; h < 16; ++h)
    B[h] = t[h];
  for (Hu(B), Hu(B), Hu(B), o = 0; o < 2; ++o) {
    for (g[0] = B[0] - 65517, h = 1; h < 15; ++h)
      g[h] = B[h] - 65535 - (g[h - 1] >> 16 & 1), g[h - 1] &= 65535;
    g[15] = B[15] - 32767 - (g[14] >> 16 & 1), S = g[15] >> 16 & 1, g[14] &= 65535, eg(B, g, 1 - S);
  }
  for (h = 0; h < 16; h++)
    e[2 * h] = B[h] & 255, e[2 * h + 1] = B[h] >> 8;
}
function cT(e, t) {
  var h = We(), o = We(), S = We(), g = We(), B = We(), M = We(), O = We();
  return xn(e[2], Ks), hT(e[1], t), $n(S, e[1]), Nt(g, S, nT), ma(S, S, e[2]), pa(g, e[2], g), $n(B, g), $n(M, B), Nt(O, M, B), Nt(h, O, S), Nt(h, h, g), lT(h, h), Nt(h, h, S), Nt(h, h, g), Nt(h, h, g), Nt(e[0], h, g), $n(o, e[0]), Nt(o, o, g), Jp(o, S) && Nt(e[0], e[0], sT), $n(o, e[0]), Nt(o, o, g), Jp(o, S) ? -1 : (Z2(e[0]) === t[31] >> 7 && ma(e[0], Tc, e[0]), Nt(e[3], e[0], e[1]), 0);
}
function hT(e, t) {
  var h;
  for (h = 0; h < 16; ++h)
    e[h] = t[2 * h] + (t[2 * h + 1] << 8);
  e[15] &= 32767;
}
function lT(e, t) {
  var h = We(), o;
  for (o = 0; o < 16; ++o)
    h[o] = t[o];
  for (o = 250; o >= 0; --o)
    $n(h, h), o !== 1 && Nt(h, h, t);
  for (o = 0; o < 16; ++o)
    e[o] = h[o];
}
function Jp(e, t) {
  var h = new Tr(32), o = new Tr(32);
  return $s(h, e), $s(o, t), Q2(h, 0, o, 0);
}
function Q2(e, t, h, o) {
  return dT(e, t, h, o, 32);
}
function dT(e, t, h, o, S) {
  var g, B = 0;
  for (g = 0; g < S; ++g)
    B |= e[t + g] ^ h[o + g];
  return (1 & B - 1 >>> 8) - 1;
}
function Z2(e) {
  var t = new Tr(32);
  return $s(t, e), t[0] & 1;
}
function J2(e, t, h) {
  var o, S;
  for (xn(e[0], Tc), xn(e[1], Ks), xn(e[2], Ks), xn(e[3], Tc), S = 255; S >= 0; --S)
    o = h[S / 8 | 0] >> (S & 7) & 1, Zp(e, t, o), Rc(t, e), Rc(e, e), Zp(e, t, o);
}
function Yh(e, t) {
  var h = [We(), We(), We(), We()];
  xn(h[0], Xp), xn(h[1], Qp), xn(h[2], Ks), Nt(h[3], Xp, Qp), J2(e, h, t);
}
function xn(e, t) {
  var h;
  for (h = 0; h < 16; h++)
    e[h] = t[h] | 0;
}
function pT(e, t) {
  var h = We(), o;
  for (o = 0; o < 16; ++o)
    h[o] = t[o];
  for (o = 253; o >= 0; --o)
    $n(h, h), o !== 2 && o !== 4 && Nt(h, h, t);
  for (o = 0; o < 16; ++o)
    e[o] = h[o];
}
function Hu(e) {
  var t, h, o = 1;
  for (t = 0; t < 16; ++t)
    h = e[t] + o + 65535, o = Math.floor(h / 65536), e[t] = h - o * 65536;
  e[0] += o - 1 + 37 * (o - 1);
}
function eg(e, t, h) {
  for (var o, S = ~(h - 1), g = 0; g < 16; ++g)
    o = S & (e[g] ^ t[g]), e[g] ^= o, t[g] ^= o;
}
function We(e) {
  var t, h = new Float64Array(16);
  if (e)
    for (t = 0; t < e.length; ++t)
      h[t] = e[t];
  return h;
}
function pa(e, t, h) {
  for (var o = 0; o < 16; ++o)
    e[o] = t[o] + h[o];
}
function ma(e, t, h) {
  for (var o = 0; o < 16; ++o)
    e[o] = t[o] - h[o];
}
function $n(e, t) {
  Nt(e, t, t);
}
function Nt(e, t, h) {
  var o, S, g = 0, B = 0, M = 0, O = 0, P = 0, D = 0, Z = 0, Y = 0, ee = 0, ie = 0, ue = 0, fe = 0, de = 0, ce = 0, be = 0, ve = 0, Pe = 0, Ue = 0, ze = 0, Le = 0, Ne = 0, $e = 0, J = 0, ne = 0, A = 0, I = 0, U = 0, X = 0, Q = 0, F = 0, $ = 0, H = h[0], q = h[1], z = h[2], me = h[3], Ce = h[4], je = h[5], Re = h[6], Ae = h[7], ke = h[8], Qe = h[9], Ze = h[10], qe = h[11], Oe = h[12], Xe = h[13], et = h[14], nt = h[15];
  o = t[0], g += o * H, B += o * q, M += o * z, O += o * me, P += o * Ce, D += o * je, Z += o * Re, Y += o * Ae, ee += o * ke, ie += o * Qe, ue += o * Ze, fe += o * qe, de += o * Oe, ce += o * Xe, be += o * et, ve += o * nt, o = t[1], B += o * H, M += o * q, O += o * z, P += o * me, D += o * Ce, Z += o * je, Y += o * Re, ee += o * Ae, ie += o * ke, ue += o * Qe, fe += o * Ze, de += o * qe, ce += o * Oe, be += o * Xe, ve += o * et, Pe += o * nt, o = t[2], M += o * H, O += o * q, P += o * z, D += o * me, Z += o * Ce, Y += o * je, ee += o * Re, ie += o * Ae, ue += o * ke, fe += o * Qe, de += o * Ze, ce += o * qe, be += o * Oe, ve += o * Xe, Pe += o * et, Ue += o * nt, o = t[3], O += o * H, P += o * q, D += o * z, Z += o * me, Y += o * Ce, ee += o * je, ie += o * Re, ue += o * Ae, fe += o * ke, de += o * Qe, ce += o * Ze, be += o * qe, ve += o * Oe, Pe += o * Xe, Ue += o * et, ze += o * nt, o = t[4], P += o * H, D += o * q, Z += o * z, Y += o * me, ee += o * Ce, ie += o * je, ue += o * Re, fe += o * Ae, de += o * ke, ce += o * Qe, be += o * Ze, ve += o * qe, Pe += o * Oe, Ue += o * Xe, ze += o * et, Le += o * nt, o = t[5], D += o * H, Z += o * q, Y += o * z, ee += o * me, ie += o * Ce, ue += o * je, fe += o * Re, de += o * Ae, ce += o * ke, be += o * Qe, ve += o * Ze, Pe += o * qe, Ue += o * Oe, ze += o * Xe, Le += o * et, Ne += o * nt, o = t[6], Z += o * H, Y += o * q, ee += o * z, ie += o * me, ue += o * Ce, fe += o * je, de += o * Re, ce += o * Ae, be += o * ke, ve += o * Qe, Pe += o * Ze, Ue += o * qe, ze += o * Oe, Le += o * Xe, Ne += o * et, $e += o * nt, o = t[7], Y += o * H, ee += o * q, ie += o * z, ue += o * me, fe += o * Ce, de += o * je, ce += o * Re, be += o * Ae, ve += o * ke, Pe += o * Qe, Ue += o * Ze, ze += o * qe, Le += o * Oe, Ne += o * Xe, $e += o * et, J += o * nt, o = t[8], ee += o * H, ie += o * q, ue += o * z, fe += o * me, de += o * Ce, ce += o * je, be += o * Re, ve += o * Ae, Pe += o * ke, Ue += o * Qe, ze += o * Ze, Le += o * qe, Ne += o * Oe, $e += o * Xe, J += o * et, ne += o * nt, o = t[9], ie += o * H, ue += o * q, fe += o * z, de += o * me, ce += o * Ce, be += o * je, ve += o * Re, Pe += o * Ae, Ue += o * ke, ze += o * Qe, Le += o * Ze, Ne += o * qe, $e += o * Oe, J += o * Xe, ne += o * et, A += o * nt, o = t[10], ue += o * H, fe += o * q, de += o * z, ce += o * me, be += o * Ce, ve += o * je, Pe += o * Re, Ue += o * Ae, ze += o * ke, Le += o * Qe, Ne += o * Ze, $e += o * qe, J += o * Oe, ne += o * Xe, A += o * et, I += o * nt, o = t[11], fe += o * H, de += o * q, ce += o * z, be += o * me, ve += o * Ce, Pe += o * je, Ue += o * Re, ze += o * Ae, Le += o * ke, Ne += o * Qe, $e += o * Ze, J += o * qe, ne += o * Oe, A += o * Xe, I += o * et, U += o * nt, o = t[12], de += o * H, ce += o * q, be += o * z, ve += o * me, Pe += o * Ce, Ue += o * je, ze += o * Re, Le += o * Ae, Ne += o * ke, $e += o * Qe, J += o * Ze, ne += o * qe, A += o * Oe, I += o * Xe, U += o * et, X += o * nt, o = t[13], ce += o * H, be += o * q, ve += o * z, Pe += o * me, Ue += o * Ce, ze += o * je, Le += o * Re, Ne += o * Ae, $e += o * ke, J += o * Qe, ne += o * Ze, A += o * qe, I += o * Oe, U += o * Xe, X += o * et, Q += o * nt, o = t[14], be += o * H, ve += o * q, Pe += o * z, Ue += o * me, ze += o * Ce, Le += o * je, Ne += o * Re, $e += o * Ae, J += o * ke, ne += o * Qe, A += o * Ze, I += o * qe, U += o * Oe, X += o * Xe, Q += o * et, F += o * nt, o = t[15], ve += o * H, Pe += o * q, Ue += o * z, ze += o * me, Le += o * Ce, Ne += o * je, $e += o * Re, J += o * Ae, ne += o * ke, A += o * Qe, I += o * Ze, U += o * qe, X += o * Oe, Q += o * Xe, F += o * et, $ += o * nt, g += 38 * Pe, B += 38 * Ue, M += 38 * ze, O += 38 * Le, P += 38 * Ne, D += 38 * $e, Z += 38 * J, Y += 38 * ne, ee += 38 * A, ie += 38 * I, ue += 38 * U, fe += 38 * X, de += 38 * Q, ce += 38 * F, be += 38 * $, S = 1, o = g + S + 65535, S = Math.floor(o / 65536), g = o - S * 65536, o = B + S + 65535, S = Math.floor(o / 65536), B = o - S * 65536, o = M + S + 65535, S = Math.floor(o / 65536), M = o - S * 65536, o = O + S + 65535, S = Math.floor(o / 65536), O = o - S * 65536, o = P + S + 65535, S = Math.floor(o / 65536), P = o - S * 65536, o = D + S + 65535, S = Math.floor(o / 65536), D = o - S * 65536, o = Z + S + 65535, S = Math.floor(o / 65536), Z = o - S * 65536, o = Y + S + 65535, S = Math.floor(o / 65536), Y = o - S * 65536, o = ee + S + 65535, S = Math.floor(o / 65536), ee = o - S * 65536, o = ie + S + 65535, S = Math.floor(o / 65536), ie = o - S * 65536, o = ue + S + 65535, S = Math.floor(o / 65536), ue = o - S * 65536, o = fe + S + 65535, S = Math.floor(o / 65536), fe = o - S * 65536, o = de + S + 65535, S = Math.floor(o / 65536), de = o - S * 65536, o = ce + S + 65535, S = Math.floor(o / 65536), ce = o - S * 65536, o = be + S + 65535, S = Math.floor(o / 65536), be = o - S * 65536, o = ve + S + 65535, S = Math.floor(o / 65536), ve = o - S * 65536, g += S - 1 + 37 * (S - 1), S = 1, o = g + S + 65535, S = Math.floor(o / 65536), g = o - S * 65536, o = B + S + 65535, S = Math.floor(o / 65536), B = o - S * 65536, o = M + S + 65535, S = Math.floor(o / 65536), M = o - S * 65536, o = O + S + 65535, S = Math.floor(o / 65536), O = o - S * 65536, o = P + S + 65535, S = Math.floor(o / 65536), P = o - S * 65536, o = D + S + 65535, S = Math.floor(o / 65536), D = o - S * 65536, o = Z + S + 65535, S = Math.floor(o / 65536), Z = o - S * 65536, o = Y + S + 65535, S = Math.floor(o / 65536), Y = o - S * 65536, o = ee + S + 65535, S = Math.floor(o / 65536), ee = o - S * 65536, o = ie + S + 65535, S = Math.floor(o / 65536), ie = o - S * 65536, o = ue + S + 65535, S = Math.floor(o / 65536), ue = o - S * 65536, o = fe + S + 65535, S = Math.floor(o / 65536), fe = o - S * 65536, o = de + S + 65535, S = Math.floor(o / 65536), de = o - S * 65536, o = ce + S + 65535, S = Math.floor(o / 65536), ce = o - S * 65536, o = be + S + 65535, S = Math.floor(o / 65536), be = o - S * 65536, o = ve + S + 65535, S = Math.floor(o / 65536), ve = o - S * 65536, g += S - 1 + 37 * (S - 1), e[0] = g, e[1] = B, e[2] = M, e[3] = O, e[4] = P, e[5] = D, e[6] = Z, e[7] = Y, e[8] = ee, e[9] = ie, e[10] = ue, e[11] = fe, e[12] = de, e[13] = ce, e[14] = be, e[15] = ve;
}
var Nr = ht;
Nr.kem = Nr.kem || {};
var e1 = Nr.jsbn.BigInteger;
Nr.kem.rsa = {};
Nr.kem.rsa.create = function(e, t) {
  t = t || {};
  var h = t.prng || Nr.random, o = {};
  return o.encrypt = function(S, g) {
    var B = Math.ceil(S.n.bitLength() / 8), M;
    do
      M = new e1(
        Nr.util.bytesToHex(h.getBytesSync(B)),
        16
      ).mod(S.n);
    while (M.compareTo(e1.ONE) <= 0);
    M = Nr.util.hexToBytes(M.toString(16));
    var O = B - M.length;
    O > 0 && (M = Nr.util.fillString("\0", O) + M);
    var P = S.encrypt(M, "NONE"), D = e.generate(M, g);
    return { encapsulation: P, key: D };
  }, o.decrypt = function(S, g, B) {
    var M = S.decrypt(g, "NONE");
    return e.generate(M, B);
  }, o;
};
Nr.kem.kdf1 = function(e, t) {
  tg(this, e, 0, t || e.digestLength);
};
Nr.kem.kdf2 = function(e, t) {
  tg(this, e, 1, t || e.digestLength);
};
function tg(e, t, h, o) {
  e.generate = function(S, g) {
    for (var B = new Nr.util.ByteBuffer(), M = Math.ceil(g / o) + h, O = new Nr.util.ByteBuffer(), P = h; P < M; ++P) {
      O.putInt32(P), t.start(), t.update(S + O.getBytes());
      var D = t.digest();
      B.putBytes(D.getBytes(o));
    }
    return B.truncate(B.length() - g), B.getBytes();
  };
}
var yt = ht;
yt.log = yt.log || {};
yt.log.levels = [
  "none",
  "error",
  "warning",
  "info",
  "debug",
  "verbose",
  "max"
];
var Hs = {}, Nc = [], w0 = null;
yt.log.LEVEL_LOCKED = 2;
yt.log.NO_LEVEL_CHECK = 4;
yt.log.INTERPOLATE = 8;
for (var _n = 0; _n < yt.log.levels.length; ++_n) {
  var t1 = yt.log.levels[_n];
  Hs[t1] = {
    index: _n,
    name: t1.toUpperCase()
  };
}
yt.log.logMessage = function(e) {
  for (var t = Hs[e.level].index, h = 0; h < Nc.length; ++h) {
    var o = Nc[h];
    if (o.flags & yt.log.NO_LEVEL_CHECK)
      o.f(e);
    else {
      var S = Hs[o.level].index;
      t <= S && o.f(o, e);
    }
  }
};
yt.log.prepareStandard = function(e) {
  "standard" in e || (e.standard = Hs[e.level].name + //' ' + +message.timestamp +
  " [" + e.category + "] " + e.message);
};
yt.log.prepareFull = function(e) {
  if (!("full" in e)) {
    var t = [e.message];
    t = t.concat([]), e.full = yt.util.format.apply(this, t);
  }
};
yt.log.prepareStandardFull = function(e) {
  "standardFull" in e || (yt.log.prepareStandard(e), e.standardFull = e.standard);
};
for (var r1 = ["error", "warning", "info", "debug", "verbose"], _n = 0; _n < r1.length; ++_n)
  (function(t) {
    yt.log[t] = function(h, o) {
      var S = Array.prototype.slice.call(arguments).slice(2), g = {
        timestamp: /* @__PURE__ */ new Date(),
        level: t,
        category: h,
        message: o,
        arguments: S
        /*standard*/
        /*full*/
        /*fullMessage*/
      };
      yt.log.logMessage(g);
    };
  })(r1[_n]);
yt.log.makeLogger = function(e) {
  var t = {
    flags: 0,
    f: e
  };
  return yt.log.setLevel(t, "none"), t;
};
yt.log.setLevel = function(e, t) {
  var h = !1;
  if (e && !(e.flags & yt.log.LEVEL_LOCKED))
    for (var o = 0; o < yt.log.levels.length; ++o) {
      var S = yt.log.levels[o];
      if (t == S) {
        e.level = t, h = !0;
        break;
      }
    }
  return h;
};
yt.log.lock = function(e, t) {
  typeof t > "u" || t ? e.flags |= yt.log.LEVEL_LOCKED : e.flags &= ~yt.log.LEVEL_LOCKED;
};
yt.log.addLogger = function(e) {
  Nc.push(e);
};
if (typeof console < "u" && "log" in console) {
  var d0;
  if (console.error && console.warn && console.info && console.debug) {
    var vT = {
      error: console.error,
      warning: console.warn,
      info: console.info,
      debug: console.debug,
      verbose: console.debug
    }, Xh = function(e, t) {
      yt.log.prepareStandard(t);
      var h = vT[t.level], o = [t.standard];
      o = o.concat(t.arguments.slice()), h.apply(console, o);
    };
    d0 = yt.log.makeLogger(Xh);
  } else {
    var Xh = function(t, h) {
      yt.log.prepareStandardFull(h), console.log(h.standardFull);
    };
    d0 = yt.log.makeLogger(Xh);
  }
  yt.log.setLevel(d0, "debug"), yt.log.addLogger(d0), w0 = d0;
} else
  console = {
    log: function() {
    }
  };
if (w0 !== null && typeof window < "u" && window.location) {
  var fs = new URL(window.location.href).searchParams;
  if (fs.has("console.level") && yt.log.setLevel(
    w0,
    fs.get("console.level").slice(-1)[0]
  ), fs.has("console.lock")) {
    var yT = fs.get("console.lock").slice(-1)[0];
    yT == "true" && yt.log.lock(w0);
  }
}
yt.log.consoleLogger = w0;
var Be = ht, ae = Be.asn1, br = Be.pkcs7 = Be.pkcs7 || {};
br.messageFromPem = function(e) {
  var t = Be.pem.decode(e)[0];
  if (t.type !== "PKCS7") {
    var h = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
    throw h.headerType = t.type, h;
  }
  if (t.procType && t.procType.type === "ENCRYPTED")
    throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
  var o = ae.fromDer(t.body);
  return br.messageFromAsn1(o);
};
br.messageToPem = function(e, t) {
  var h = {
    type: "PKCS7",
    body: ae.toDer(e.toAsn1()).getBytes()
  };
  return Be.pem.encode(h, { maxline: t });
};
br.messageFromAsn1 = function(e) {
  var t = {}, h = [];
  if (!ae.validate(e, br.asn1.contentInfoValidator, t, h)) {
    var o = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
    throw o.errors = h, o;
  }
  var S = ae.derToOid(t.contentType), g;
  switch (S) {
    case Be.pki.oids.envelopedData:
      g = br.createEnvelopedData();
      break;
    case Be.pki.oids.encryptedData:
      g = br.createEncryptedData();
      break;
    case Be.pki.oids.signedData:
      g = br.createSignedData();
      break;
    default:
      throw new Error("Cannot read PKCS#7 message. ContentType with OID " + S + " is not (yet) supported.");
  }
  return g.fromAsn1(t.content.value[0]), g;
};
br.createSignedData = function() {
  var e = null;
  return e = {
    type: Be.pki.oids.signedData,
    version: 1,
    certificates: [],
    crls: [],
    // TODO: add json-formatted signer stuff here?
    signers: [],
    // populated during sign()
    digestAlgorithmIdentifiers: [],
    contentInfo: null,
    signerInfos: [],
    fromAsn1: function(o) {
      if (Qh(e, o, br.asn1.signedDataValidator), e.certificates = [], e.crls = [], e.digestAlgorithmIdentifiers = [], e.contentInfo = null, e.signerInfos = [], e.rawCapture.certificates)
        for (var S = e.rawCapture.certificates.value, g = 0; g < S.length; ++g)
          e.certificates.push(Be.pki.certificateFromAsn1(S[g]));
    },
    toAsn1: function() {
      e.contentInfo || e.sign();
      for (var o = [], S = 0; S < e.certificates.length; ++S)
        o.push(Be.pki.certificateToAsn1(e.certificates[S]));
      var g = [], B = ae.create(ae.Class.CONTEXT_SPECIFIC, 0, !0, [
        ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
          // Version
          ae.create(
            ae.Class.UNIVERSAL,
            ae.Type.INTEGER,
            !1,
            ae.integerToDer(e.version).getBytes()
          ),
          // DigestAlgorithmIdentifiers
          ae.create(
            ae.Class.UNIVERSAL,
            ae.Type.SET,
            !0,
            e.digestAlgorithmIdentifiers
          ),
          // ContentInfo
          e.contentInfo
        ])
      ]);
      return o.length > 0 && B.value[0].value.push(
        ae.create(ae.Class.CONTEXT_SPECIFIC, 0, !0, o)
      ), g.length > 0 && B.value[0].value.push(
        ae.create(ae.Class.CONTEXT_SPECIFIC, 1, !0, g)
      ), B.value[0].value.push(
        ae.create(
          ae.Class.UNIVERSAL,
          ae.Type.SET,
          !0,
          e.signerInfos
        )
      ), ae.create(
        ae.Class.UNIVERSAL,
        ae.Type.SEQUENCE,
        !0,
        [
          // ContentType
          ae.create(
            ae.Class.UNIVERSAL,
            ae.Type.OID,
            !1,
            ae.oidToDer(e.type).getBytes()
          ),
          // [0] SignedData
          B
        ]
      );
    },
    /**
     * Add (another) entity to list of signers.
     *
     * Note: If authenticatedAttributes are provided, then, per RFC 2315,
     * they must include at least two attributes: content type and
     * message digest. The message digest attribute value will be
     * auto-calculated during signing and will be ignored if provided.
     *
     * Here's an example of providing these two attributes:
     *
     * forge.pkcs7.createSignedData();
     * p7.addSigner({
     *   issuer: cert.issuer.attributes,
     *   serialNumber: cert.serialNumber,
     *   key: privateKey,
     *   digestAlgorithm: forge.pki.oids.sha1,
     *   authenticatedAttributes: [{
     *     type: forge.pki.oids.contentType,
     *     value: forge.pki.oids.data
     *   }, {
     *     type: forge.pki.oids.messageDigest
     *   }]
     * });
     *
     * TODO: Support [subjectKeyIdentifier] as signer's ID.
     *
     * @param signer the signer information:
     *          key the signer's private key.
     *          [certificate] a certificate containing the public key
     *            associated with the signer's private key; use this option as
     *            an alternative to specifying signer.issuer and
     *            signer.serialNumber.
     *          [issuer] the issuer attributes (eg: cert.issuer.attributes).
     *          [serialNumber] the signer's certificate's serial number in
     *           hexadecimal (eg: cert.serialNumber).
     *          [digestAlgorithm] the message digest OID, as a string, to use
     *            (eg: forge.pki.oids.sha1).
     *          [authenticatedAttributes] an optional array of attributes
     *            to also sign along with the content.
     */
    addSigner: function(o) {
      var S = o.issuer, g = o.serialNumber;
      if (o.certificate) {
        var B = o.certificate;
        typeof B == "string" && (B = Be.pki.certificateFromPem(B)), S = B.issuer.attributes, g = B.serialNumber;
      }
      var M = o.key;
      if (!M)
        throw new Error(
          "Could not add PKCS#7 signer; no private key specified."
        );
      typeof M == "string" && (M = Be.pki.privateKeyFromPem(M));
      var O = o.digestAlgorithm || Be.pki.oids.sha1;
      switch (O) {
        case Be.pki.oids.sha1:
        case Be.pki.oids.sha256:
        case Be.pki.oids.sha384:
        case Be.pki.oids.sha512:
        case Be.pki.oids.md5:
          break;
        default:
          throw new Error(
            "Could not add PKCS#7 signer; unknown message digest algorithm: " + O
          );
      }
      var P = o.authenticatedAttributes || [];
      if (P.length > 0) {
        for (var D = !1, Z = !1, Y = 0; Y < P.length; ++Y) {
          var ee = P[Y];
          if (!D && ee.type === Be.pki.oids.contentType) {
            if (D = !0, Z)
              break;
            continue;
          }
          if (!Z && ee.type === Be.pki.oids.messageDigest) {
            if (Z = !0, D)
              break;
            continue;
          }
        }
        if (!D || !Z)
          throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
      }
      e.signers.push({
        key: M,
        version: 1,
        issuer: S,
        serialNumber: g,
        digestAlgorithm: O,
        signatureAlgorithm: Be.pki.oids.rsaEncryption,
        signature: null,
        authenticatedAttributes: P,
        unauthenticatedAttributes: []
      });
    },
    /**
     * Signs the content.
     * @param options Options to apply when signing:
     *    [detached] boolean. If signing should be done in detached mode. Defaults to false.
     */
    sign: function(o) {
      if (o = o || {}, (typeof e.content != "object" || e.contentInfo === null) && (e.contentInfo = ae.create(
        ae.Class.UNIVERSAL,
        ae.Type.SEQUENCE,
        !0,
        [
          // ContentType
          ae.create(
            ae.Class.UNIVERSAL,
            ae.Type.OID,
            !1,
            ae.oidToDer(Be.pki.oids.data).getBytes()
          )
        ]
      ), "content" in e)) {
        var S;
        e.content instanceof Be.util.ByteBuffer ? S = e.content.bytes() : typeof e.content == "string" && (S = Be.util.encodeUtf8(e.content)), o.detached ? e.detachedContent = ae.create(ae.Class.UNIVERSAL, ae.Type.OCTETSTRING, !1, S) : e.contentInfo.value.push(
          // [0] EXPLICIT content
          ae.create(ae.Class.CONTEXT_SPECIFIC, 0, !0, [
            ae.create(
              ae.Class.UNIVERSAL,
              ae.Type.OCTETSTRING,
              !1,
              S
            )
          ])
        );
      }
      if (e.signers.length !== 0) {
        var g = t();
        h(g);
      }
    },
    verify: function() {
      throw new Error("PKCS#7 signature verification not yet implemented.");
    },
    /**
     * Add a certificate.
     *
     * @param cert the certificate to add.
     */
    addCertificate: function(o) {
      typeof o == "string" && (o = Be.pki.certificateFromPem(o)), e.certificates.push(o);
    },
    /**
     * Add a certificate revokation list.
     *
     * @param crl the certificate revokation list to add.
     */
    addCertificateRevokationList: function(o) {
      throw new Error("PKCS#7 CRL support not yet implemented.");
    }
  }, e;
  function t() {
    for (var o = {}, S = 0; S < e.signers.length; ++S) {
      var g = e.signers[S], B = g.digestAlgorithm;
      B in o || (o[B] = Be.md[Be.pki.oids[B]].create()), g.authenticatedAttributes.length === 0 ? g.md = o[B] : g.md = Be.md[Be.pki.oids[B]].create();
    }
    e.digestAlgorithmIdentifiers = [];
    for (var B in o)
      e.digestAlgorithmIdentifiers.push(
        // AlgorithmIdentifier
        ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
          // algorithm
          ae.create(
            ae.Class.UNIVERSAL,
            ae.Type.OID,
            !1,
            ae.oidToDer(B).getBytes()
          ),
          // parameters (null)
          ae.create(ae.Class.UNIVERSAL, ae.Type.NULL, !1, "")
        ])
      );
    return o;
  }
  function h(o) {
    var S;
    if (e.detachedContent ? S = e.detachedContent : (S = e.contentInfo.value[1], S = S.value[0]), !S)
      throw new Error(
        "Could not sign PKCS#7 message; there is no content to sign."
      );
    var g = ae.derToOid(e.contentInfo.value[0].value), B = ae.toDer(S);
    B.getByte(), ae.getBerValueLength(B), B = B.getBytes();
    for (var M in o)
      o[M].start().update(B);
    for (var O = /* @__PURE__ */ new Date(), P = 0; P < e.signers.length; ++P) {
      var D = e.signers[P];
      if (D.authenticatedAttributes.length === 0) {
        if (g !== Be.pki.oids.data)
          throw new Error(
            "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data."
          );
      } else {
        D.authenticatedAttributesAsn1 = ae.create(
          ae.Class.CONTEXT_SPECIFIC,
          0,
          !0,
          []
        );
        for (var Z = ae.create(
          ae.Class.UNIVERSAL,
          ae.Type.SET,
          !0,
          []
        ), Y = 0; Y < D.authenticatedAttributes.length; ++Y) {
          var ee = D.authenticatedAttributes[Y];
          ee.type === Be.pki.oids.messageDigest ? ee.value = o[D.digestAlgorithm].digest() : ee.type === Be.pki.oids.signingTime && (ee.value || (ee.value = O)), Z.value.push(Dc(ee)), D.authenticatedAttributesAsn1.value.push(Dc(ee));
        }
        B = ae.toDer(Z).getBytes(), D.md.start().update(B);
      }
      D.signature = D.key.sign(D.md, "RSASSA-PKCS1-V1_5");
    }
    e.signerInfos = ET(e.signers);
  }
};
br.createEncryptedData = function() {
  var e = null;
  return e = {
    type: Be.pki.oids.encryptedData,
    version: 0,
    encryptedContent: {
      algorithm: Be.pki.oids["aes256-CBC"]
    },
    /**
     * Reads an EncryptedData content block (in ASN.1 format)
     *
     * @param obj The ASN.1 representation of the EncryptedData content block
     */
    fromAsn1: function(t) {
      Qh(e, t, br.asn1.encryptedDataValidator);
    },
    /**
     * Decrypt encrypted content
     *
     * @param key The (symmetric) key as a byte buffer
     */
    decrypt: function(t) {
      t !== void 0 && (e.encryptedContent.key = t), rg(e);
    }
  }, e;
};
br.createEnvelopedData = function() {
  var e = null;
  return e = {
    type: Be.pki.oids.envelopedData,
    version: 0,
    recipients: [],
    encryptedContent: {
      algorithm: Be.pki.oids["aes256-CBC"]
    },
    /**
     * Reads an EnvelopedData content block (in ASN.1 format)
     *
     * @param obj the ASN.1 representation of the EnvelopedData content block.
     */
    fromAsn1: function(t) {
      var h = Qh(e, t, br.asn1.envelopedDataValidator);
      e.recipients = bT(h.recipientInfos.value);
    },
    toAsn1: function() {
      return ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
        // ContentType
        ae.create(
          ae.Class.UNIVERSAL,
          ae.Type.OID,
          !1,
          ae.oidToDer(e.type).getBytes()
        ),
        // [0] EnvelopedData
        ae.create(ae.Class.CONTEXT_SPECIFIC, 0, !0, [
          ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
            // Version
            ae.create(
              ae.Class.UNIVERSAL,
              ae.Type.INTEGER,
              !1,
              ae.integerToDer(e.version).getBytes()
            ),
            // RecipientInfos
            ae.create(
              ae.Class.UNIVERSAL,
              ae.Type.SET,
              !0,
              xT(e.recipients)
            ),
            // EncryptedContentInfo
            ae.create(
              ae.Class.UNIVERSAL,
              ae.Type.SEQUENCE,
              !0,
              ST(e.encryptedContent)
            )
          ])
        ])
      ]);
    },
    /**
     * Find recipient by X.509 certificate's issuer.
     *
     * @param cert the certificate with the issuer to look for.
     *
     * @return the recipient object.
     */
    findRecipient: function(t) {
      for (var h = t.issuer.attributes, o = 0; o < e.recipients.length; ++o) {
        var S = e.recipients[o], g = S.issuer;
        if (S.serialNumber === t.serialNumber && g.length === h.length) {
          for (var B = !0, M = 0; M < h.length; ++M)
            if (g[M].type !== h[M].type || g[M].value !== h[M].value) {
              B = !1;
              break;
            }
          if (B)
            return S;
        }
      }
      return null;
    },
    /**
     * Decrypt enveloped content
     *
     * @param recipient The recipient object related to the private key
     * @param privKey The (RSA) private key object
     */
    decrypt: function(t, h) {
      if (e.encryptedContent.key === void 0 && t !== void 0 && h !== void 0)
        switch (t.encryptedContent.algorithm) {
          case Be.pki.oids.rsaEncryption:
          case Be.pki.oids.desCBC:
            var o = h.decrypt(t.encryptedContent.content);
            e.encryptedContent.key = Be.util.createBuffer(o);
            break;
          default:
            throw new Error("Unsupported asymmetric cipher, OID " + t.encryptedContent.algorithm);
        }
      rg(e);
    },
    /**
     * Add (another) entity to list of recipients.
     *
     * @param cert The certificate of the entity to add.
     */
    addRecipient: function(t) {
      e.recipients.push({
        version: 0,
        issuer: t.issuer.attributes,
        serialNumber: t.serialNumber,
        encryptedContent: {
          // We simply assume rsaEncryption here, since forge.pki only
          // supports RSA so far.  If the PKI module supports other
          // ciphers one day, we need to modify this one as well.
          algorithm: Be.pki.oids.rsaEncryption,
          key: t.publicKey
        }
      });
    },
    /**
     * Encrypt enveloped content.
     *
     * This function supports two optional arguments, cipher and key, which
     * can be used to influence symmetric encryption.  Unless cipher is
     * provided, the cipher specified in encryptedContent.algorithm is used
     * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key
     * is (re-)used.  If that one's not set, a random key will be generated
     * automatically.
     *
     * @param [key] The key to be used for symmetric encryption.
     * @param [cipher] The OID of the symmetric cipher to use.
     */
    encrypt: function(t, h) {
      if (e.encryptedContent.content === void 0) {
        h = h || e.encryptedContent.algorithm, t = t || e.encryptedContent.key;
        var o, S, g;
        switch (h) {
          case Be.pki.oids["aes128-CBC"]:
            o = 16, S = 16, g = Be.aes.createEncryptionCipher;
            break;
          case Be.pki.oids["aes192-CBC"]:
            o = 24, S = 16, g = Be.aes.createEncryptionCipher;
            break;
          case Be.pki.oids["aes256-CBC"]:
            o = 32, S = 16, g = Be.aes.createEncryptionCipher;
            break;
          case Be.pki.oids["des-EDE3-CBC"]:
            o = 24, S = 8, g = Be.des.createEncryptionCipher;
            break;
          default:
            throw new Error("Unsupported symmetric cipher, OID " + h);
        }
        if (t === void 0)
          t = Be.util.createBuffer(Be.random.getBytes(o));
        else if (t.length() != o)
          throw new Error("Symmetric key has wrong length; got " + t.length() + " bytes, expected " + o + ".");
        e.encryptedContent.algorithm = h, e.encryptedContent.key = t, e.encryptedContent.parameter = Be.util.createBuffer(
          Be.random.getBytes(S)
        );
        var B = g(t);
        if (B.start(e.encryptedContent.parameter.copy()), B.update(e.content), !B.finish())
          throw new Error("Symmetric encryption failed.");
        e.encryptedContent.content = B.output;
      }
      for (var M = 0; M < e.recipients.length; ++M) {
        var O = e.recipients[M];
        if (O.encryptedContent.content === void 0)
          switch (O.encryptedContent.algorithm) {
            case Be.pki.oids.rsaEncryption:
              O.encryptedContent.content = O.encryptedContent.key.encrypt(
                e.encryptedContent.key.data
              );
              break;
            default:
              throw new Error("Unsupported asymmetric cipher, OID " + O.encryptedContent.algorithm);
          }
      }
    }
  }, e;
};
function gT(e) {
  var t = {}, h = [];
  if (!ae.validate(e, br.asn1.recipientInfoValidator, t, h)) {
    var o = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
    throw o.errors = h, o;
  }
  return {
    version: t.version.charCodeAt(0),
    issuer: Be.pki.RDNAttributesAsArray(t.issuer),
    serialNumber: Be.util.createBuffer(t.serial).toHex(),
    encryptedContent: {
      algorithm: ae.derToOid(t.encAlgorithm),
      parameter: t.encParameter ? t.encParameter.value : void 0,
      content: t.encKey
    }
  };
}
function mT(e) {
  return ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
    // Version
    ae.create(
      ae.Class.UNIVERSAL,
      ae.Type.INTEGER,
      !1,
      ae.integerToDer(e.version).getBytes()
    ),
    // IssuerAndSerialNumber
    ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
      // Name
      Be.pki.distinguishedNameToAsn1({ attributes: e.issuer }),
      // Serial
      ae.create(
        ae.Class.UNIVERSAL,
        ae.Type.INTEGER,
        !1,
        Be.util.hexToBytes(e.serialNumber)
      )
    ]),
    // KeyEncryptionAlgorithmIdentifier
    ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
      // Algorithm
      ae.create(
        ae.Class.UNIVERSAL,
        ae.Type.OID,
        !1,
        ae.oidToDer(e.encryptedContent.algorithm).getBytes()
      ),
      // Parameter, force NULL, only RSA supported for now.
      ae.create(ae.Class.UNIVERSAL, ae.Type.NULL, !1, "")
    ]),
    // EncryptedKey
    ae.create(
      ae.Class.UNIVERSAL,
      ae.Type.OCTETSTRING,
      !1,
      e.encryptedContent.content
    )
  ]);
}
function bT(e) {
  for (var t = [], h = 0; h < e.length; ++h)
    t.push(gT(e[h]));
  return t;
}
function xT(e) {
  for (var t = [], h = 0; h < e.length; ++h)
    t.push(mT(e[h]));
  return t;
}
function _T(e) {
  var t = ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
    // version
    ae.create(
      ae.Class.UNIVERSAL,
      ae.Type.INTEGER,
      !1,
      ae.integerToDer(e.version).getBytes()
    ),
    // issuerAndSerialNumber
    ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
      // name
      Be.pki.distinguishedNameToAsn1({ attributes: e.issuer }),
      // serial
      ae.create(
        ae.Class.UNIVERSAL,
        ae.Type.INTEGER,
        !1,
        Be.util.hexToBytes(e.serialNumber)
      )
    ]),
    // digestAlgorithm
    ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
      // algorithm
      ae.create(
        ae.Class.UNIVERSAL,
        ae.Type.OID,
        !1,
        ae.oidToDer(e.digestAlgorithm).getBytes()
      ),
      // parameters (null)
      ae.create(ae.Class.UNIVERSAL, ae.Type.NULL, !1, "")
    ])
  ]);
  if (e.authenticatedAttributesAsn1 && t.value.push(e.authenticatedAttributesAsn1), t.value.push(ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
    // algorithm
    ae.create(
      ae.Class.UNIVERSAL,
      ae.Type.OID,
      !1,
      ae.oidToDer(e.signatureAlgorithm).getBytes()
    ),
    // parameters (null)
    ae.create(ae.Class.UNIVERSAL, ae.Type.NULL, !1, "")
  ])), t.value.push(ae.create(
    ae.Class.UNIVERSAL,
    ae.Type.OCTETSTRING,
    !1,
    e.signature
  )), e.unauthenticatedAttributes.length > 0) {
    for (var h = ae.create(ae.Class.CONTEXT_SPECIFIC, 1, !0, []), o = 0; o < e.unauthenticatedAttributes.length; ++o) {
      var S = e.unauthenticatedAttributes[o];
      h.values.push(Dc(S));
    }
    t.value.push(h);
  }
  return t;
}
function ET(e) {
  for (var t = [], h = 0; h < e.length; ++h)
    t.push(_T(e[h]));
  return t;
}
function Dc(e) {
  var t;
  if (e.type === Be.pki.oids.contentType)
    t = ae.create(
      ae.Class.UNIVERSAL,
      ae.Type.OID,
      !1,
      ae.oidToDer(e.value).getBytes()
    );
  else if (e.type === Be.pki.oids.messageDigest)
    t = ae.create(
      ae.Class.UNIVERSAL,
      ae.Type.OCTETSTRING,
      !1,
      e.value.bytes()
    );
  else if (e.type === Be.pki.oids.signingTime) {
    var h = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z"), o = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z"), S = e.value;
    if (typeof S == "string") {
      var g = Date.parse(S);
      isNaN(g) ? S.length === 13 ? S = ae.utcTimeToDate(S) : S = ae.generalizedTimeToDate(S) : S = new Date(g);
    }
    S >= h && S < o ? t = ae.create(
      ae.Class.UNIVERSAL,
      ae.Type.UTCTIME,
      !1,
      ae.dateToUtcTime(S)
    ) : t = ae.create(
      ae.Class.UNIVERSAL,
      ae.Type.GENERALIZEDTIME,
      !1,
      ae.dateToGeneralizedTime(S)
    );
  }
  return ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
    // AttributeType
    ae.create(
      ae.Class.UNIVERSAL,
      ae.Type.OID,
      !1,
      ae.oidToDer(e.type).getBytes()
    ),
    ae.create(ae.Class.UNIVERSAL, ae.Type.SET, !0, [
      // AttributeValue
      t
    ])
  ]);
}
function ST(e) {
  return [
    // ContentType, always Data for the moment
    ae.create(
      ae.Class.UNIVERSAL,
      ae.Type.OID,
      !1,
      ae.oidToDer(Be.pki.oids.data).getBytes()
    ),
    // ContentEncryptionAlgorithmIdentifier
    ae.create(ae.Class.UNIVERSAL, ae.Type.SEQUENCE, !0, [
      // Algorithm
      ae.create(
        ae.Class.UNIVERSAL,
        ae.Type.OID,
        !1,
        ae.oidToDer(e.algorithm).getBytes()
      ),
      // Parameters (IV)
      e.parameter ? ae.create(
        ae.Class.UNIVERSAL,
        ae.Type.OCTETSTRING,
        !1,
        e.parameter.getBytes()
      ) : void 0
    ]),
    // [0] EncryptedContent
    ae.create(ae.Class.CONTEXT_SPECIFIC, 0, !0, [
      ae.create(
        ae.Class.UNIVERSAL,
        ae.Type.OCTETSTRING,
        !1,
        e.content.getBytes()
      )
    ])
  ];
}
function Qh(e, t, h) {
  var o = {}, S = [];
  if (!ae.validate(t, h, o, S)) {
    var g = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
    throw g.errors = g, g;
  }
  var B = ae.derToOid(o.contentType);
  if (B !== Be.pki.oids.data)
    throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
  if (o.encryptedContent) {
    var M = "";
    if (Be.util.isArray(o.encryptedContent))
      for (var O = 0; O < o.encryptedContent.length; ++O) {
        if (o.encryptedContent[O].type !== ae.Type.OCTETSTRING)
          throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
        M += o.encryptedContent[O].value;
      }
    else
      M = o.encryptedContent;
    e.encryptedContent = {
      algorithm: ae.derToOid(o.encAlgorithm),
      parameter: Be.util.createBuffer(o.encParameter.value),
      content: Be.util.createBuffer(M)
    };
  }
  if (o.content) {
    var M = "";
    if (Be.util.isArray(o.content))
      for (var O = 0; O < o.content.length; ++O) {
        if (o.content[O].type !== ae.Type.OCTETSTRING)
          throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
        M += o.content[O].value;
      }
    else
      M = o.content;
    e.content = Be.util.createBuffer(M);
  }
  return e.version = o.version.charCodeAt(0), e.rawCapture = o, o;
}
function rg(e) {
  if (e.encryptedContent.key === void 0)
    throw new Error("Symmetric key not available.");
  if (e.content === void 0) {
    var t;
    switch (e.encryptedContent.algorithm) {
      case Be.pki.oids["aes128-CBC"]:
      case Be.pki.oids["aes192-CBC"]:
      case Be.pki.oids["aes256-CBC"]:
        t = Be.aes.createDecryptionCipher(e.encryptedContent.key);
        break;
      case Be.pki.oids.desCBC:
      case Be.pki.oids["des-EDE3-CBC"]:
        t = Be.des.createDecryptionCipher(e.encryptedContent.key);
        break;
      default:
        throw new Error("Unsupported symmetric cipher, OID " + e.encryptedContent.algorithm);
    }
    if (t.start(e.encryptedContent.parameter), t.update(e.encryptedContent.content), !t.finish())
      throw new Error("Symmetric decryption failed.");
    e.content = t.output;
  }
}
var Gt = ht, $f = Gt.ssh = Gt.ssh || {};
$f.privateKeyToPutty = function(e, t, h) {
  h = h || "", t = t || "";
  var o = "ssh-rsa", S = t === "" ? "none" : "aes256-cbc", g = "PuTTY-User-Key-File-2: " + o + `\r
`;
  g += "Encryption: " + S + `\r
`, g += "Comment: " + h + `\r
`;
  var B = Gt.util.createBuffer();
  ba(B, o), Oi(B, e.e), Oi(B, e.n);
  var M = Gt.util.encode64(B.bytes(), 64), O = Math.floor(M.length / 66) + 1;
  g += "Public-Lines: " + O + `\r
`, g += M;
  var P = Gt.util.createBuffer();
  Oi(P, e.d), Oi(P, e.p), Oi(P, e.q), Oi(P, e.qInv);
  var D;
  if (!t)
    D = Gt.util.encode64(P.bytes(), 64);
  else {
    var Z = P.length() + 16 - 1;
    Z -= Z % 16;
    var Y = os(P.bytes());
    Y.truncate(Y.length() - Z + P.length()), P.putBuffer(Y);
    var ee = Gt.util.createBuffer();
    ee.putBuffer(os("\0\0\0\0", t)), ee.putBuffer(os("\0\0\0", t));
    var ie = Gt.aes.createEncryptionCipher(ee.truncate(8), "CBC");
    ie.start(Gt.util.createBuffer().fillWithByte(0, 16)), ie.update(P.copy()), ie.finish();
    var ue = ie.output;
    ue.truncate(16), D = Gt.util.encode64(ue.bytes(), 64);
  }
  O = Math.floor(D.length / 66) + 1, g += `\r
Private-Lines: ` + O + `\r
`, g += D;
  var fe = os("putty-private-key-file-mac-key", t), de = Gt.util.createBuffer();
  ba(de, o), ba(de, S), ba(de, h), de.putInt32(B.length()), de.putBuffer(B), de.putInt32(P.length()), de.putBuffer(P);
  var ce = Gt.hmac.create();
  return ce.start("sha1", fe), ce.update(de.bytes()), g += `\r
Private-MAC: ` + ce.digest().toHex() + `\r
`, g;
};
$f.publicKeyToOpenSSH = function(e, t) {
  var h = "ssh-rsa";
  t = t || "";
  var o = Gt.util.createBuffer();
  return ba(o, h), Oi(o, e.e), Oi(o, e.n), h + " " + Gt.util.encode64(o.bytes()) + " " + t;
};
$f.privateKeyToOpenSSH = function(e, t) {
  return t ? Gt.pki.encryptRsaPrivateKey(
    e,
    t,
    { legacy: !0, algorithm: "aes128" }
  ) : Gt.pki.privateKeyToPem(e);
};
$f.getPublicKeyFingerprint = function(e, t) {
  t = t || {};
  var h = t.md || Gt.md.md5.create(), o = "ssh-rsa", S = Gt.util.createBuffer();
  ba(S, o), Oi(S, e.e), Oi(S, e.n), h.start(), h.update(S.getBytes());
  var g = h.digest();
  if (t.encoding === "hex") {
    var B = g.toHex();
    return t.delimiter ? B.match(/.{2}/g).join(t.delimiter) : B;
  } else {
    if (t.encoding === "binary")
      return g.getBytes();
    if (t.encoding)
      throw new Error('Unknown encoding "' + t.encoding + '".');
  }
  return g;
};
function Oi(e, t) {
  var h = t.toString(16);
  h[0] >= "8" && (h = "00" + h);
  var o = Gt.util.hexToBytes(h);
  e.putInt32(o.length), e.putBytes(o);
}
function ba(e, t) {
  e.putInt32(t.length), e.putString(t);
}
function os() {
  for (var e = Gt.md.sha1.create(), t = arguments.length, h = 0; h < t; ++h)
    e.update(arguments[h]);
  return e.digest();
}
var wT = ht;
const Fn = /* @__PURE__ */ Gs(wT), CT = "LS0tLS1CRUdJTiBSU0EgUFVCTElDIEtFWS0tLS0tCk1JSUJDZ0tDQVFFQXNobjY4alc0REFsQlFnWTd6SDJXQkJvVlU4NUpEZWpwRDluOW44Rm9zWkZZR2U5Yk1KLy8KUkpFLzNnZklEcWI4eitUbTBUb3BLdTFjRUlwQ21zcGtvc1ZldFFFWGFJWHJRQUhvWExOK2FLZjc1MEV5RDhMTQprOXRia21EMnlkWnFWZVFWQUxLNmVaVit4akZqNm4rTXVqTWZadTVldnQ2ekdBY1FyZ2xtaXZEYkc2Y2l6SlF2ClV2WDZ5NXlxVDQvSkhJKzErM0xXT3ZJRnhKSW4vWHRyY2lRUTZZcmZsQWlSZzNWM1lMMTF2Ykc4dnAzZG4xSjEKRk1XOVRDUElwTStvRkRIc3hGcW1hbHltNXl1K2ZGSmRwYnIxLzUxMmRISkJSUW9UNUtLNXhOWVJ0eVQxNWttSgpLNXlWdjJUTDhrQS9QeUZ0SmJHVXVTeml5NmhxeHBtWVd3SURBUUFCCi0tLS0tRU5EIFJTQSBQVUJMSUMgS0VZLS0tLS0K", p0 = ["IoTrust Root", "KR", "Seoul", "GangNam", "IoTrust"], v0 = ["Wepin", "KR", "Seoul", "GangNam", "IoTrust"], ig = {
  ...Cr.pad
};
function AT(e, t, h, o) {
  const S = Cr.enc.Hex.parse(e), g = Cr.enc.Hex.parse(t);
  return Cr.AES.encrypt(h, S, {
    iv: g,
    mode: Cr.mode.CBC,
    padding: ig[o]
  }).toString();
}
function BT(e, t, h, o) {
  const S = Cr.enc.Hex.parse(e), g = Cr.enc.Hex.parse(t);
  return Cr.AES.decrypt(h, S, {
    iv: g,
    mode: Cr.mode.CBC,
    padding: ig[o]
  }).toString(Cr.enc.Utf8);
}
function IT(e) {
  return Cr.lib.WordArray.random(e).toString(Cr.enc.Hex);
}
function TT(e, t) {
  const h = new kC();
  return e.includes("BEGIN RSA PUBLIC KEY") ? h.importKey(e, "pkcs1-public-pem") : h.importKey(e, "pkcs8-public-pem"), h.encrypt(t, "base64");
}
function ng(e) {
  const t = MT(e), h = IT(32), o = TT(t, h);
  return {
    DEK: h,
    encryptedDEK: o
  };
}
function i1() {
  return new Error("invalid certificate");
}
function MT(e) {
  const t = pe.Buffer.from(e, "base64").toString("utf8");
  if (t.includes("BEGIN RSA PUBLIC KEY"))
    return t;
  const h = t.split(/(?=-----BEGIN CERTIFICATE-----)/).filter((P) => P.trim()).map((P) => P.trim() + `
`), o = [];
  o.push(Fn.pki.certificateFromPem(h[0])), o.push(Fn.pki.certificateFromPem(h[1]));
  for (let P = h.length - 1; P > 0; P--)
    if (!o[P].verify(o[P - 1]))
      throw i1();
  const S = o[0], g = o[h.length - 1], B = Fn.pki.publicKeyFromPem(Fn.util.decode64(CT)), M = Fn.md.sha256.create();
  M.update(Fn.asn1.toDer(g.tbsCertificate).getBytes());
  const O = M.digest().getBytes();
  if (!B.verify(O, g.signature) || JSON.stringify(B) !== JSON.stringify(g.publicKey) || g.subject.attributes[0].value !== p0[0] || g.subject.attributes[1].value !== p0[1] || g.subject.attributes[2].value !== p0[2] || g.subject.attributes[3].value !== p0[3] || g.subject.attributes[4].value !== p0[4] || S.subject.attributes[0].value !== v0[0] || S.subject.attributes[1].value !== v0[1] || S.subject.attributes[2].value !== v0[2] || S.subject.attributes[3].value !== v0[3] || S.subject.attributes[4].value !== v0[4])
    throw i1();
  return Fn.pki.publicKeyToPem(S.publicKey);
}
const ag = {
  pin: "Pkcs7",
  mnemonic: "Iso97971"
}, sg = "00000000000000000000000000000000";
function Hf(e, t, h) {
  return AT(e, sg, t, ag[h]);
}
function RT(e, t) {
  return Hf(e, JSON.stringify(t), "pin");
}
function NT(e, t) {
  return Hf(e, t, "mnemonic");
}
function fg(e, t, h) {
  return BT(e, sg, t, ag[h]);
}
function DT(e, t) {
  return fg(e, t, "mnemonic");
}
async function OT(e, t) {
  const { DEK: h, encryptedDEK: o } = ng(e), S = Hf(h, JSON.stringify(t), "pin");
  return {
    b64SKey: o,
    b64Data: S
  };
}
function PT(e) {
  if (!/^\d{6,8}$/.test(e))
    throw new Error("Invalid UVD. UVD must be 6-8 digits.");
  return Cr.SHA256(e).toString(Cr.enc.Hex);
}
function LT(e) {
  let t = "";
  for (let h = 0; h < e.length; h++)
    h === 0 ? t += e[0] : h === 4 ? t += e[4] : t += "*";
  return {
    version: 1,
    length: pe.Buffer.from(e.length.toString(10), "utf8").toString("base64"),
    data: pe.Buffer.from(t, "utf8").toString("base64")
  };
}
const kT = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  createDataEncryptionKey: ng,
  decryptData: fg,
  decryptMnemonic: DT,
  encryptData: Hf,
  encryptMnemonic: NT,
  encryptUVD: RT,
  getEncUVD: OT,
  makeHint: LT,
  makeUVD: PT
}, Symbol.toStringTag, { value: "Module" })), VERIFY_CREATE = "create", VERIFY_PIN = "verify", getUVD = async (e, t, h) => {
  const o = kT.makeUVD(e);
  if (!o)
    throw new Error("Cannot make uvd");
  try {
    if ((h == null ? void 0 : h.type) === VERIFY_CREATE) {
      const O = await t.wepinApi.user.fetchKey();
      if (isErrorResponse(O))
        throw new Error("Cannot fetch key");
      const P = O.pubKey;
      if (!P)
        throw new Error("Cannot get pub key");
      return {
        UVD: await kT.getEncUVD(P, {
          nonce: 0,
          UVD: o
        }),
        hint: kT.makeHint(e)
      };
    }
    const S = await t.wepinApi.wallet.getWalletKeyInfo(
      {
        walletId: h == null ? void 0 : h.walletId
      },
      {
        userId: h == null ? void 0 : h.userId
      }
    );
    if (isErrorResponse(S))
      throw new Error("Cannot get wallet key info");
    if (Number.isNaN(Number(S == null ? void 0 : S.nonce)))
      throw new Error("Cannot get wallet key info");
    const g = S.b64PubKey, B = await kT.getEncUVD(g, {
      nonce: S.nonce,
      UVD: o
    }), M = await kT.getEncUVD(g, {
      nonce: S.nonce + 1,
      UVD: o
    });
    return { UVD: B, nextUVD: M };
  } catch (S) {
    throw new Error("Error occurred while getUVD" + S);
  }
};
var isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
function clone(e) {
  var t, h, o, S = ce.prototype = { constructor: ce, toString: null, valueOf: null }, g = new ce(1), B = 20, M = 4, O = -7, P = 21, D = -1e7, Z = 1e7, Y = !1, ee = 1, ie = 0, ue = {
    prefix: "",
    groupSize: 3,
    secondaryGroupSize: 0,
    groupSeparator: ",",
    decimalSeparator: ".",
    fractionGroupSize: 0,
    fractionGroupSeparator: " ",
    // non-breaking space
    suffix: ""
  }, fe = "0123456789abcdefghijklmnopqrstuvwxyz", de = !0;
  function ce(Le, Ne) {
    var $e, J, ne, A, I, U, X, Q, F = this;
    if (!(F instanceof ce))
      return new ce(Le, Ne);
    if (Ne == null) {
      if (Le && Le._isBigNumber === !0) {
        F.s = Le.s, !Le.c || Le.e > Z ? F.c = F.e = null : Le.e < D ? F.c = [F.e = 0] : (F.e = Le.e, F.c = Le.c.slice());
        return;
      }
      if ((U = typeof Le == "number") && Le * 0 == 0) {
        if (F.s = 1 / Le < 0 ? (Le = -Le, -1) : 1, Le === ~~Le) {
          for (A = 0, I = Le; I >= 10; I /= 10, A++)
            ;
          A > Z ? F.c = F.e = null : (F.e = A, F.c = [Le]);
          return;
        }
        Q = String(Le);
      } else {
        if (!isNumeric.test(Q = String(Le)))
          return o(F, Q, U);
        F.s = Q.charCodeAt(0) == 45 ? (Q = Q.slice(1), -1) : 1;
      }
      (A = Q.indexOf(".")) > -1 && (Q = Q.replace(".", "")), (I = Q.search(/e/i)) > 0 ? (A < 0 && (A = I), A += +Q.slice(I + 1), Q = Q.substring(0, I)) : A < 0 && (A = Q.length);
    } else {
      if (intCheck(Ne, 2, fe.length, "Base"), Ne == 10 && de)
        return F = new ce(Le), Ue(F, B + F.e + 1, M);
      if (Q = String(Le), U = typeof Le == "number") {
        if (Le * 0 != 0)
          return o(F, Q, U, Ne);
        if (F.s = 1 / Le < 0 ? (Q = Q.slice(1), -1) : 1, ce.DEBUG && Q.replace(/^0\.0*|\./, "").length > 15)
          throw Error(tooManyDigits + Le);
      } else
        F.s = Q.charCodeAt(0) === 45 ? (Q = Q.slice(1), -1) : 1;
      for ($e = fe.slice(0, Ne), A = I = 0, X = Q.length; I < X; I++)
        if ($e.indexOf(J = Q.charAt(I)) < 0) {
          if (J == ".") {
            if (I > A) {
              A = X;
              continue;
            }
          } else if (!ne && (Q == Q.toUpperCase() && (Q = Q.toLowerCase()) || Q == Q.toLowerCase() && (Q = Q.toUpperCase()))) {
            ne = !0, I = -1, A = 0;
            continue;
          }
          return o(F, String(Le), U, Ne);
        }
      U = !1, Q = h(Q, Ne, 10, F.s), (A = Q.indexOf(".")) > -1 ? Q = Q.replace(".", "") : A = Q.length;
    }
    for (I = 0; Q.charCodeAt(I) === 48; I++)
      ;
    for (X = Q.length; Q.charCodeAt(--X) === 48; )
      ;
    if (Q = Q.slice(I, ++X)) {
      if (X -= I, U && ce.DEBUG && X > 15 && (Le > MAX_SAFE_INTEGER || Le !== mathfloor(Le)))
        throw Error(tooManyDigits + F.s * Le);
      if ((A = A - I - 1) > Z)
        F.c = F.e = null;
      else if (A < D)
        F.c = [F.e = 0];
      else {
        if (F.e = A, F.c = [], I = (A + 1) % LOG_BASE, A < 0 && (I += LOG_BASE), I < X) {
          for (I && F.c.push(+Q.slice(0, I)), X -= LOG_BASE; I < X; )
            F.c.push(+Q.slice(I, I += LOG_BASE));
          I = LOG_BASE - (Q = Q.slice(I)).length;
        } else
          I -= X;
        for (; I--; Q += "0")
          ;
        F.c.push(+Q);
      }
    } else
      F.c = [F.e = 0];
  }
  ce.clone = clone, ce.ROUND_UP = 0, ce.ROUND_DOWN = 1, ce.ROUND_CEIL = 2, ce.ROUND_FLOOR = 3, ce.ROUND_HALF_UP = 4, ce.ROUND_HALF_DOWN = 5, ce.ROUND_HALF_EVEN = 6, ce.ROUND_HALF_CEIL = 7, ce.ROUND_HALF_FLOOR = 8, ce.EUCLID = 9, ce.config = ce.set = function(Le) {
    var Ne, $e;
    if (Le != null)
      if (typeof Le == "object") {
        if (Le.hasOwnProperty(Ne = "DECIMAL_PLACES") && ($e = Le[Ne], intCheck($e, 0, MAX, Ne), B = $e), Le.hasOwnProperty(Ne = "ROUNDING_MODE") && ($e = Le[Ne], intCheck($e, 0, 8, Ne), M = $e), Le.hasOwnProperty(Ne = "EXPONENTIAL_AT") && ($e = Le[Ne], $e && $e.pop ? (intCheck($e[0], -MAX, 0, Ne), intCheck($e[1], 0, MAX, Ne), O = $e[0], P = $e[1]) : (intCheck($e, -MAX, MAX, Ne), O = -(P = $e < 0 ? -$e : $e))), Le.hasOwnProperty(Ne = "RANGE"))
          if ($e = Le[Ne], $e && $e.pop)
            intCheck($e[0], -MAX, -1, Ne), intCheck($e[1], 1, MAX, Ne), D = $e[0], Z = $e[1];
          else if (intCheck($e, -MAX, MAX, Ne), $e)
            D = -(Z = $e < 0 ? -$e : $e);
          else
            throw Error(bignumberError + Ne + " cannot be zero: " + $e);
        if (Le.hasOwnProperty(Ne = "CRYPTO"))
          if ($e = Le[Ne], $e === !!$e)
            if ($e)
              if (typeof crypto < "u" && crypto && (crypto.getRandomValues || crypto.randomBytes))
                Y = $e;
              else
                throw Y = !$e, Error(bignumberError + "crypto unavailable");
            else
              Y = $e;
          else
            throw Error(bignumberError + Ne + " not true or false: " + $e);
        if (Le.hasOwnProperty(Ne = "MODULO_MODE") && ($e = Le[Ne], intCheck($e, 0, 9, Ne), ee = $e), Le.hasOwnProperty(Ne = "POW_PRECISION") && ($e = Le[Ne], intCheck($e, 0, MAX, Ne), ie = $e), Le.hasOwnProperty(Ne = "FORMAT"))
          if ($e = Le[Ne], typeof $e == "object")
            ue = $e;
          else
            throw Error(bignumberError + Ne + " not an object: " + $e);
        if (Le.hasOwnProperty(Ne = "ALPHABET"))
          if ($e = Le[Ne], typeof $e == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test($e))
            de = $e.slice(0, 10) == "0123456789", fe = $e;
          else
            throw Error(bignumberError + Ne + " invalid: " + $e);
      } else
        throw Error(bignumberError + "Object expected: " + Le);
    return {
      DECIMAL_PLACES: B,
      ROUNDING_MODE: M,
      EXPONENTIAL_AT: [O, P],
      RANGE: [D, Z],
      CRYPTO: Y,
      MODULO_MODE: ee,
      POW_PRECISION: ie,
      FORMAT: ue,
      ALPHABET: fe
    };
  }, ce.isBigNumber = function(Le) {
    if (!Le || Le._isBigNumber !== !0)
      return !1;
    if (!ce.DEBUG)
      return !0;
    var Ne, $e, J = Le.c, ne = Le.e, A = Le.s;
    e:
      if ({}.toString.call(J) == "[object Array]") {
        if ((A === 1 || A === -1) && ne >= -MAX && ne <= MAX && ne === mathfloor(ne)) {
          if (J[0] === 0) {
            if (ne === 0 && J.length === 1)
              return !0;
            break e;
          }
          if (Ne = (ne + 1) % LOG_BASE, Ne < 1 && (Ne += LOG_BASE), String(J[0]).length == Ne) {
            for (Ne = 0; Ne < J.length; Ne++)
              if ($e = J[Ne], $e < 0 || $e >= BASE || $e !== mathfloor($e))
                break e;
            if ($e !== 0)
              return !0;
          }
        }
      } else if (J === null && ne === null && (A === null || A === 1 || A === -1))
        return !0;
    throw Error(bignumberError + "Invalid BigNumber: " + Le);
  }, ce.maximum = ce.max = function() {
    return ve(arguments, -1);
  }, ce.minimum = ce.min = function() {
    return ve(arguments, 1);
  }, ce.random = function() {
    var Le = 9007199254740992, Ne = Math.random() * Le & 2097151 ? function() {
      return mathfloor(Math.random() * Le);
    } : function() {
      return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
    };
    return function($e) {
      var J, ne, A, I, U, X = 0, Q = [], F = new ce(g);
      if ($e == null ? $e = B : intCheck($e, 0, MAX), I = mathceil($e / LOG_BASE), Y)
        if (crypto.getRandomValues) {
          for (J = crypto.getRandomValues(new Uint32Array(I *= 2)); X < I; )
            U = J[X] * 131072 + (J[X + 1] >>> 11), U >= 9e15 ? (ne = crypto.getRandomValues(new Uint32Array(2)), J[X] = ne[0], J[X + 1] = ne[1]) : (Q.push(U % 1e14), X += 2);
          X = I / 2;
        } else if (crypto.randomBytes) {
          for (J = crypto.randomBytes(I *= 7); X < I; )
            U = (J[X] & 31) * 281474976710656 + J[X + 1] * 1099511627776 + J[X + 2] * 4294967296 + J[X + 3] * 16777216 + (J[X + 4] << 16) + (J[X + 5] << 8) + J[X + 6], U >= 9e15 ? crypto.randomBytes(7).copy(J, X) : (Q.push(U % 1e14), X += 7);
          X = I / 7;
        } else
          throw Y = !1, Error(bignumberError + "crypto unavailable");
      if (!Y)
        for (; X < I; )
          U = Ne(), U < 9e15 && (Q[X++] = U % 1e14);
      for (I = Q[--X], $e %= LOG_BASE, I && $e && (U = POWS_TEN[LOG_BASE - $e], Q[X] = mathfloor(I / U) * U); Q[X] === 0; Q.pop(), X--)
        ;
      if (X < 0)
        Q = [A = 0];
      else {
        for (A = -1; Q[0] === 0; Q.splice(0, 1), A -= LOG_BASE)
          ;
        for (X = 1, U = Q[0]; U >= 10; U /= 10, X++)
          ;
        X < LOG_BASE && (A -= LOG_BASE - X);
      }
      return F.e = A, F.c = Q, F;
    };
  }(), ce.sum = function() {
    for (var Le = 1, Ne = arguments, $e = new ce(Ne[0]); Le < Ne.length; )
      $e = $e.plus(Ne[Le++]);
    return $e;
  }, h = /* @__PURE__ */ function() {
    var Le = "0123456789";
    function Ne($e, J, ne, A) {
      for (var I, U = [0], X, Q = 0, F = $e.length; Q < F; ) {
        for (X = U.length; X--; U[X] *= J)
          ;
        for (U[0] += A.indexOf($e.charAt(Q++)), I = 0; I < U.length; I++)
          U[I] > ne - 1 && (U[I + 1] == null && (U[I + 1] = 0), U[I + 1] += U[I] / ne | 0, U[I] %= ne);
      }
      return U.reverse();
    }
    return function($e, J, ne, A, I) {
      var U, X, Q, F, $, H, q, z, me = $e.indexOf("."), Ce = B, je = M;
      for (me >= 0 && (F = ie, ie = 0, $e = $e.replace(".", ""), z = new ce(J), H = z.pow($e.length - me), ie = F, z.c = Ne(
        toFixedPoint(coeffToString(H.c), H.e, "0"),
        10,
        ne,
        Le
      ), z.e = z.c.length), q = Ne($e, J, ne, I ? (U = fe, Le) : (U = Le, fe)), Q = F = q.length; q[--F] == 0; q.pop())
        ;
      if (!q[0])
        return U.charAt(0);
      if (me < 0 ? --Q : (H.c = q, H.e = Q, H.s = A, H = t(H, z, Ce, je, ne), q = H.c, $ = H.r, Q = H.e), X = Q + Ce + 1, me = q[X], F = ne / 2, $ = $ || X < 0 || q[X + 1] != null, $ = je < 4 ? (me != null || $) && (je == 0 || je == (H.s < 0 ? 3 : 2)) : me > F || me == F && (je == 4 || $ || je == 6 && q[X - 1] & 1 || je == (H.s < 0 ? 8 : 7)), X < 1 || !q[0])
        $e = $ ? toFixedPoint(U.charAt(1), -Ce, U.charAt(0)) : U.charAt(0);
      else {
        if (q.length = X, $)
          for (--ne; ++q[--X] > ne; )
            q[X] = 0, X || (++Q, q = [1].concat(q));
        for (F = q.length; !q[--F]; )
          ;
        for (me = 0, $e = ""; me <= F; $e += U.charAt(q[me++]))
          ;
        $e = toFixedPoint($e, Q, U.charAt(0));
      }
      return $e;
    };
  }(), t = /* @__PURE__ */ function() {
    function Le(J, ne, A) {
      var I, U, X, Q, F = 0, $ = J.length, H = ne % SQRT_BASE, q = ne / SQRT_BASE | 0;
      for (J = J.slice(); $--; )
        X = J[$] % SQRT_BASE, Q = J[$] / SQRT_BASE | 0, I = q * X + Q * H, U = H * X + I % SQRT_BASE * SQRT_BASE + F, F = (U / A | 0) + (I / SQRT_BASE | 0) + q * Q, J[$] = U % A;
      return F && (J = [F].concat(J)), J;
    }
    function Ne(J, ne, A, I) {
      var U, X;
      if (A != I)
        X = A > I ? 1 : -1;
      else
        for (U = X = 0; U < A; U++)
          if (J[U] != ne[U]) {
            X = J[U] > ne[U] ? 1 : -1;
            break;
          }
      return X;
    }
    function $e(J, ne, A, I) {
      for (var U = 0; A--; )
        J[A] -= U, U = J[A] < ne[A] ? 1 : 0, J[A] = U * I + J[A] - ne[A];
      for (; !J[0] && J.length > 1; J.splice(0, 1))
        ;
    }
    return function(J, ne, A, I, U) {
      var X, Q, F, $, H, q, z, me, Ce, je, Re, Ae, ke, Qe, Ze, qe, Oe, Xe = J.s == ne.s ? 1 : -1, et = J.c, nt = ne.c;
      if (!et || !et[0] || !nt || !nt[0])
        return new ce(
          // Return NaN if either NaN, or both Infinity or 0.
          !J.s || !ne.s || (et ? nt && et[0] == nt[0] : !nt) ? NaN : (
            // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
            et && et[0] == 0 || !nt ? Xe * 0 : Xe / 0
          )
        );
      for (me = new ce(Xe), Ce = me.c = [], Q = J.e - ne.e, Xe = A + Q + 1, U || (U = BASE, Q = bitFloor(J.e / LOG_BASE) - bitFloor(ne.e / LOG_BASE), Xe = Xe / LOG_BASE | 0), F = 0; nt[F] == (et[F] || 0); F++)
        ;
      if (nt[F] > (et[F] || 0) && Q--, Xe < 0)
        Ce.push(1), $ = !0;
      else {
        for (Qe = et.length, qe = nt.length, F = 0, Xe += 2, H = mathfloor(U / (nt[0] + 1)), H > 1 && (nt = Le(nt, H, U), et = Le(et, H, U), qe = nt.length, Qe = et.length), ke = qe, je = et.slice(0, qe), Re = je.length; Re < qe; je[Re++] = 0)
          ;
        Oe = nt.slice(), Oe = [0].concat(Oe), Ze = nt[0], nt[1] >= U / 2 && Ze++;
        do {
          if (H = 0, X = Ne(nt, je, qe, Re), X < 0) {
            if (Ae = je[0], qe != Re && (Ae = Ae * U + (je[1] || 0)), H = mathfloor(Ae / Ze), H > 1)
              for (H >= U && (H = U - 1), q = Le(nt, H, U), z = q.length, Re = je.length; Ne(q, je, z, Re) == 1; )
                H--, $e(q, qe < z ? Oe : nt, z, U), z = q.length, X = 1;
            else
              H == 0 && (X = H = 1), q = nt.slice(), z = q.length;
            if (z < Re && (q = [0].concat(q)), $e(je, q, Re, U), Re = je.length, X == -1)
              for (; Ne(nt, je, qe, Re) < 1; )
                H++, $e(je, qe < Re ? Oe : nt, Re, U), Re = je.length;
          } else
            X === 0 && (H++, je = [0]);
          Ce[F++] = H, je[0] ? je[Re++] = et[ke] || 0 : (je = [et[ke]], Re = 1);
        } while ((ke++ < Qe || je[0] != null) && Xe--);
        $ = je[0] != null, Ce[0] || Ce.splice(0, 1);
      }
      if (U == BASE) {
        for (F = 1, Xe = Ce[0]; Xe >= 10; Xe /= 10, F++)
          ;
        Ue(me, A + (me.e = F + Q * LOG_BASE - 1) + 1, I, $);
      } else
        me.e = Q, me.r = +$;
      return me;
    };
  }();
  function be(Le, Ne, $e, J) {
    var ne, A, I, U, X;
    if ($e == null ? $e = M : intCheck($e, 0, 8), !Le.c)
      return Le.toString();
    if (ne = Le.c[0], I = Le.e, Ne == null)
      X = coeffToString(Le.c), X = J == 1 || J == 2 && (I <= O || I >= P) ? toExponential(X, I) : toFixedPoint(X, I, "0");
    else if (Le = Ue(new ce(Le), Ne, $e), A = Le.e, X = coeffToString(Le.c), U = X.length, J == 1 || J == 2 && (Ne <= A || A <= O)) {
      for (; U < Ne; X += "0", U++)
        ;
      X = toExponential(X, A);
    } else if (Ne -= I, X = toFixedPoint(X, A, "0"), A + 1 > U) {
      if (--Ne > 0)
        for (X += "."; Ne--; X += "0")
          ;
    } else if (Ne += A - U, Ne > 0)
      for (A + 1 == U && (X += "."); Ne--; X += "0")
        ;
    return Le.s < 0 && ne ? "-" + X : X;
  }
  function ve(Le, Ne) {
    for (var $e, J, ne = 1, A = new ce(Le[0]); ne < Le.length; ne++)
      J = new ce(Le[ne]), (!J.s || ($e = compare(A, J)) === Ne || $e === 0 && A.s === Ne) && (A = J);
    return A;
  }
  function Pe(Le, Ne, $e) {
    for (var J = 1, ne = Ne.length; !Ne[--ne]; Ne.pop())
      ;
    for (ne = Ne[0]; ne >= 10; ne /= 10, J++)
      ;
    return ($e = J + $e * LOG_BASE - 1) > Z ? Le.c = Le.e = null : $e < D ? Le.c = [Le.e = 0] : (Le.e = $e, Le.c = Ne), Le;
  }
  o = /* @__PURE__ */ function() {
    var Le = /^(-?)0([xbo])(?=\w[\w.]*$)/i, Ne = /^([^.]+)\.$/, $e = /^\.([^.]+)$/, J = /^-?(Infinity|NaN)$/, ne = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
    return function(A, I, U, X) {
      var Q, F = U ? I : I.replace(ne, "");
      if (J.test(F))
        A.s = isNaN(F) ? null : F < 0 ? -1 : 1;
      else {
        if (!U && (F = F.replace(Le, function($, H, q) {
          return Q = (q = q.toLowerCase()) == "x" ? 16 : q == "b" ? 2 : 8, !X || X == Q ? H : $;
        }), X && (Q = X, F = F.replace(Ne, "$1").replace($e, "0.$1")), I != F))
          return new ce(F, Q);
        if (ce.DEBUG)
          throw Error(bignumberError + "Not a" + (X ? " base " + X : "") + " number: " + I);
        A.s = null;
      }
      A.c = A.e = null;
    };
  }();
  function Ue(Le, Ne, $e, J) {
    var ne, A, I, U, X, Q, F, $ = Le.c, H = POWS_TEN;
    if ($) {
      e: {
        for (ne = 1, U = $[0]; U >= 10; U /= 10, ne++)
          ;
        if (A = Ne - ne, A < 0)
          A += LOG_BASE, I = Ne, X = $[Q = 0], F = mathfloor(X / H[ne - I - 1] % 10);
        else if (Q = mathceil((A + 1) / LOG_BASE), Q >= $.length)
          if (J) {
            for (; $.length <= Q; $.push(0))
              ;
            X = F = 0, ne = 1, A %= LOG_BASE, I = A - LOG_BASE + 1;
          } else
            break e;
        else {
          for (X = U = $[Q], ne = 1; U >= 10; U /= 10, ne++)
            ;
          A %= LOG_BASE, I = A - LOG_BASE + ne, F = I < 0 ? 0 : mathfloor(X / H[ne - I - 1] % 10);
        }
        if (J = J || Ne < 0 || // Are there any non-zero digits after the rounding digit?
        // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
        // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
        $[Q + 1] != null || (I < 0 ? X : X % H[ne - I - 1]), J = $e < 4 ? (F || J) && ($e == 0 || $e == (Le.s < 0 ? 3 : 2)) : F > 5 || F == 5 && ($e == 4 || J || $e == 6 && // Check whether the digit to the left of the rounding digit is odd.
        (A > 0 ? I > 0 ? X / H[ne - I] : 0 : $[Q - 1]) % 10 & 1 || $e == (Le.s < 0 ? 8 : 7)), Ne < 1 || !$[0])
          return $.length = 0, J ? (Ne -= Le.e + 1, $[0] = H[(LOG_BASE - Ne % LOG_BASE) % LOG_BASE], Le.e = -Ne || 0) : $[0] = Le.e = 0, Le;
        if (A == 0 ? ($.length = Q, U = 1, Q--) : ($.length = Q + 1, U = H[LOG_BASE - A], $[Q] = I > 0 ? mathfloor(X / H[ne - I] % H[I]) * U : 0), J)
          for (; ; )
            if (Q == 0) {
              for (A = 1, I = $[0]; I >= 10; I /= 10, A++)
                ;
              for (I = $[0] += U, U = 1; I >= 10; I /= 10, U++)
                ;
              A != U && (Le.e++, $[0] == BASE && ($[0] = 1));
              break;
            } else {
              if ($[Q] += U, $[Q] != BASE)
                break;
              $[Q--] = 0, U = 1;
            }
        for (A = $.length; $[--A] === 0; $.pop())
          ;
      }
      Le.e > Z ? Le.c = Le.e = null : Le.e < D && (Le.c = [Le.e = 0]);
    }
    return Le;
  }
  function ze(Le) {
    var Ne, $e = Le.e;
    return $e === null ? Le.toString() : (Ne = coeffToString(Le.c), Ne = $e <= O || $e >= P ? toExponential(Ne, $e) : toFixedPoint(Ne, $e, "0"), Le.s < 0 ? "-" + Ne : Ne);
  }
  return S.absoluteValue = S.abs = function() {
    var Le = new ce(this);
    return Le.s < 0 && (Le.s = 1), Le;
  }, S.comparedTo = function(Le, Ne) {
    return compare(this, new ce(Le, Ne));
  }, S.decimalPlaces = S.dp = function(Le, Ne) {
    var $e, J, ne, A = this;
    if (Le != null)
      return intCheck(Le, 0, MAX), Ne == null ? Ne = M : intCheck(Ne, 0, 8), Ue(new ce(A), Le + A.e + 1, Ne);
    if (!($e = A.c))
      return null;
    if (J = ((ne = $e.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE, ne = $e[ne])
      for (; ne % 10 == 0; ne /= 10, J--)
        ;
    return J < 0 && (J = 0), J;
  }, S.dividedBy = S.div = function(Le, Ne) {
    return t(this, new ce(Le, Ne), B, M);
  }, S.dividedToIntegerBy = S.idiv = function(Le, Ne) {
    return t(this, new ce(Le, Ne), 0, 1);
  }, S.exponentiatedBy = S.pow = function(Le, Ne) {
    var $e, J, ne, A, I, U, X, Q, F, $ = this;
    if (Le = new ce(Le), Le.c && !Le.isInteger())
      throw Error(bignumberError + "Exponent not an integer: " + ze(Le));
    if (Ne != null && (Ne = new ce(Ne)), U = Le.e > 14, !$.c || !$.c[0] || $.c[0] == 1 && !$.e && $.c.length == 1 || !Le.c || !Le.c[0])
      return F = new ce(Math.pow(+ze($), U ? Le.s * (2 - isOdd(Le)) : +ze(Le))), Ne ? F.mod(Ne) : F;
    if (X = Le.s < 0, Ne) {
      if (Ne.c ? !Ne.c[0] : !Ne.s)
        return new ce(NaN);
      J = !X && $.isInteger() && Ne.isInteger(), J && ($ = $.mod(Ne));
    } else {
      if (Le.e > 9 && ($.e > 0 || $.e < -1 || ($.e == 0 ? $.c[0] > 1 || U && $.c[1] >= 24e7 : $.c[0] < 8e13 || U && $.c[0] <= 9999975e7)))
        return A = $.s < 0 && isOdd(Le) ? -0 : 0, $.e > -1 && (A = 1 / A), new ce(X ? 1 / A : A);
      ie && (A = mathceil(ie / LOG_BASE + 2));
    }
    for (U ? ($e = new ce(0.5), X && (Le.s = 1), Q = isOdd(Le)) : (ne = Math.abs(+ze(Le)), Q = ne % 2), F = new ce(g); ; ) {
      if (Q) {
        if (F = F.times($), !F.c)
          break;
        A ? F.c.length > A && (F.c.length = A) : J && (F = F.mod(Ne));
      }
      if (ne) {
        if (ne = mathfloor(ne / 2), ne === 0)
          break;
        Q = ne % 2;
      } else if (Le = Le.times($e), Ue(Le, Le.e + 1, 1), Le.e > 14)
        Q = isOdd(Le);
      else {
        if (ne = +ze(Le), ne === 0)
          break;
        Q = ne % 2;
      }
      $ = $.times($), A ? $.c && $.c.length > A && ($.c.length = A) : J && ($ = $.mod(Ne));
    }
    return J ? F : (X && (F = g.div(F)), Ne ? F.mod(Ne) : A ? Ue(F, ie, M, I) : F);
  }, S.integerValue = function(Le) {
    var Ne = new ce(this);
    return Le == null ? Le = M : intCheck(Le, 0, 8), Ue(Ne, Ne.e + 1, Le);
  }, S.isEqualTo = S.eq = function(Le, Ne) {
    return compare(this, new ce(Le, Ne)) === 0;
  }, S.isFinite = function() {
    return !!this.c;
  }, S.isGreaterThan = S.gt = function(Le, Ne) {
    return compare(this, new ce(Le, Ne)) > 0;
  }, S.isGreaterThanOrEqualTo = S.gte = function(Le, Ne) {
    return (Ne = compare(this, new ce(Le, Ne))) === 1 || Ne === 0;
  }, S.isInteger = function() {
    return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
  }, S.isLessThan = S.lt = function(Le, Ne) {
    return compare(this, new ce(Le, Ne)) < 0;
  }, S.isLessThanOrEqualTo = S.lte = function(Le, Ne) {
    return (Ne = compare(this, new ce(Le, Ne))) === -1 || Ne === 0;
  }, S.isNaN = function() {
    return !this.s;
  }, S.isNegative = function() {
    return this.s < 0;
  }, S.isPositive = function() {
    return this.s > 0;
  }, S.isZero = function() {
    return !!this.c && this.c[0] == 0;
  }, S.minus = function(Le, Ne) {
    var $e, J, ne, A, I = this, U = I.s;
    if (Le = new ce(Le, Ne), Ne = Le.s, !U || !Ne)
      return new ce(NaN);
    if (U != Ne)
      return Le.s = -Ne, I.plus(Le);
    var X = I.e / LOG_BASE, Q = Le.e / LOG_BASE, F = I.c, $ = Le.c;
    if (!X || !Q) {
      if (!F || !$)
        return F ? (Le.s = -Ne, Le) : new ce($ ? I : NaN);
      if (!F[0] || !$[0])
        return $[0] ? (Le.s = -Ne, Le) : new ce(F[0] ? I : (
          // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
          M == 3 ? -0 : 0
        ));
    }
    if (X = bitFloor(X), Q = bitFloor(Q), F = F.slice(), U = X - Q) {
      for ((A = U < 0) ? (U = -U, ne = F) : (Q = X, ne = $), ne.reverse(), Ne = U; Ne--; ne.push(0))
        ;
      ne.reverse();
    } else
      for (J = (A = (U = F.length) < (Ne = $.length)) ? U : Ne, U = Ne = 0; Ne < J; Ne++)
        if (F[Ne] != $[Ne]) {
          A = F[Ne] < $[Ne];
          break;
        }
    if (A && (ne = F, F = $, $ = ne, Le.s = -Le.s), Ne = (J = $.length) - ($e = F.length), Ne > 0)
      for (; Ne--; F[$e++] = 0)
        ;
    for (Ne = BASE - 1; J > U; ) {
      if (F[--J] < $[J]) {
        for ($e = J; $e && !F[--$e]; F[$e] = Ne)
          ;
        --F[$e], F[J] += BASE;
      }
      F[J] -= $[J];
    }
    for (; F[0] == 0; F.splice(0, 1), --Q)
      ;
    return F[0] ? Pe(Le, F, Q) : (Le.s = M == 3 ? -1 : 1, Le.c = [Le.e = 0], Le);
  }, S.modulo = S.mod = function(Le, Ne) {
    var $e, J, ne = this;
    return Le = new ce(Le, Ne), !ne.c || !Le.s || Le.c && !Le.c[0] ? new ce(NaN) : !Le.c || ne.c && !ne.c[0] ? new ce(ne) : (ee == 9 ? (J = Le.s, Le.s = 1, $e = t(ne, Le, 0, 3), Le.s = J, $e.s *= J) : $e = t(ne, Le, 0, ee), Le = ne.minus($e.times(Le)), !Le.c[0] && ee == 1 && (Le.s = ne.s), Le);
  }, S.multipliedBy = S.times = function(Le, Ne) {
    var $e, J, ne, A, I, U, X, Q, F, $, H, q, z, me, Ce, je = this, Re = je.c, Ae = (Le = new ce(Le, Ne)).c;
    if (!Re || !Ae || !Re[0] || !Ae[0])
      return !je.s || !Le.s || Re && !Re[0] && !Ae || Ae && !Ae[0] && !Re ? Le.c = Le.e = Le.s = null : (Le.s *= je.s, !Re || !Ae ? Le.c = Le.e = null : (Le.c = [0], Le.e = 0)), Le;
    for (J = bitFloor(je.e / LOG_BASE) + bitFloor(Le.e / LOG_BASE), Le.s *= je.s, X = Re.length, $ = Ae.length, X < $ && (z = Re, Re = Ae, Ae = z, ne = X, X = $, $ = ne), ne = X + $, z = []; ne--; z.push(0))
      ;
    for (me = BASE, Ce = SQRT_BASE, ne = $; --ne >= 0; ) {
      for ($e = 0, H = Ae[ne] % Ce, q = Ae[ne] / Ce | 0, I = X, A = ne + I; A > ne; )
        Q = Re[--I] % Ce, F = Re[I] / Ce | 0, U = q * Q + F * H, Q = H * Q + U % Ce * Ce + z[A] + $e, $e = (Q / me | 0) + (U / Ce | 0) + q * F, z[A--] = Q % me;
      z[A] = $e;
    }
    return $e ? ++J : z.splice(0, 1), Pe(Le, z, J);
  }, S.negated = function() {
    var Le = new ce(this);
    return Le.s = -Le.s || null, Le;
  }, S.plus = function(Le, Ne) {
    var $e, J = this, ne = J.s;
    if (Le = new ce(Le, Ne), Ne = Le.s, !ne || !Ne)
      return new ce(NaN);
    if (ne != Ne)
      return Le.s = -Ne, J.minus(Le);
    var A = J.e / LOG_BASE, I = Le.e / LOG_BASE, U = J.c, X = Le.c;
    if (!A || !I) {
      if (!U || !X)
        return new ce(ne / 0);
      if (!U[0] || !X[0])
        return X[0] ? Le : new ce(U[0] ? J : ne * 0);
    }
    if (A = bitFloor(A), I = bitFloor(I), U = U.slice(), ne = A - I) {
      for (ne > 0 ? (I = A, $e = X) : (ne = -ne, $e = U), $e.reverse(); ne--; $e.push(0))
        ;
      $e.reverse();
    }
    for (ne = U.length, Ne = X.length, ne - Ne < 0 && ($e = X, X = U, U = $e, Ne = ne), ne = 0; Ne; )
      ne = (U[--Ne] = U[Ne] + X[Ne] + ne) / BASE | 0, U[Ne] = BASE === U[Ne] ? 0 : U[Ne] % BASE;
    return ne && (U = [ne].concat(U), ++I), Pe(Le, U, I);
  }, S.precision = S.sd = function(Le, Ne) {
    var $e, J, ne, A = this;
    if (Le != null && Le !== !!Le)
      return intCheck(Le, 1, MAX), Ne == null ? Ne = M : intCheck(Ne, 0, 8), Ue(new ce(A), Le, Ne);
    if (!($e = A.c))
      return null;
    if (ne = $e.length - 1, J = ne * LOG_BASE + 1, ne = $e[ne]) {
      for (; ne % 10 == 0; ne /= 10, J--)
        ;
      for (ne = $e[0]; ne >= 10; ne /= 10, J++)
        ;
    }
    return Le && A.e + 1 > J && (J = A.e + 1), J;
  }, S.shiftedBy = function(Le) {
    return intCheck(Le, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER), this.times("1e" + Le);
  }, S.squareRoot = S.sqrt = function() {
    var Le, Ne, $e, J, ne, A = this, I = A.c, U = A.s, X = A.e, Q = B + 4, F = new ce("0.5");
    if (U !== 1 || !I || !I[0])
      return new ce(!U || U < 0 && (!I || I[0]) ? NaN : I ? A : 1 / 0);
    if (U = Math.sqrt(+ze(A)), U == 0 || U == 1 / 0 ? (Ne = coeffToString(I), (Ne.length + X) % 2 == 0 && (Ne += "0"), U = Math.sqrt(+Ne), X = bitFloor((X + 1) / 2) - (X < 0 || X % 2), U == 1 / 0 ? Ne = "5e" + X : (Ne = U.toExponential(), Ne = Ne.slice(0, Ne.indexOf("e") + 1) + X), $e = new ce(Ne)) : $e = new ce(U + ""), $e.c[0]) {
      for (X = $e.e, U = X + Q, U < 3 && (U = 0); ; )
        if (ne = $e, $e = F.times(ne.plus(t(A, ne, Q, 1))), coeffToString(ne.c).slice(0, U) === (Ne = coeffToString($e.c)).slice(0, U))
          if ($e.e < X && --U, Ne = Ne.slice(U - 3, U + 1), Ne == "9999" || !J && Ne == "4999") {
            if (!J && (Ue(ne, ne.e + B + 2, 0), ne.times(ne).eq(A))) {
              $e = ne;
              break;
            }
            Q += 4, U += 4, J = 1;
          } else {
            (!+Ne || !+Ne.slice(1) && Ne.charAt(0) == "5") && (Ue($e, $e.e + B + 2, 1), Le = !$e.times($e).eq(A));
            break;
          }
    }
    return Ue($e, $e.e + B + 1, M, Le);
  }, S.toExponential = function(Le, Ne) {
    return Le != null && (intCheck(Le, 0, MAX), Le++), be(this, Le, Ne, 1);
  }, S.toFixed = function(Le, Ne) {
    return Le != null && (intCheck(Le, 0, MAX), Le = Le + this.e + 1), be(this, Le, Ne);
  }, S.toFormat = function(Le, Ne, $e) {
    var J, ne = this;
    if ($e == null)
      Le != null && Ne && typeof Ne == "object" ? ($e = Ne, Ne = null) : Le && typeof Le == "object" ? ($e = Le, Le = Ne = null) : $e = ue;
    else if (typeof $e != "object")
      throw Error(bignumberError + "Argument not an object: " + $e);
    if (J = ne.toFixed(Le, Ne), ne.c) {
      var A, I = J.split("."), U = +$e.groupSize, X = +$e.secondaryGroupSize, Q = $e.groupSeparator || "", F = I[0], $ = I[1], H = ne.s < 0, q = H ? F.slice(1) : F, z = q.length;
      if (X && (A = U, U = X, X = A, z -= A), U > 0 && z > 0) {
        for (A = z % U || U, F = q.substr(0, A); A < z; A += U)
          F += Q + q.substr(A, U);
        X > 0 && (F += Q + q.slice(A)), H && (F = "-" + F);
      }
      J = $ ? F + ($e.decimalSeparator || "") + ((X = +$e.fractionGroupSize) ? $.replace(
        new RegExp("\\d{" + X + "}\\B", "g"),
        "$&" + ($e.fractionGroupSeparator || "")
      ) : $) : F;
    }
    return ($e.prefix || "") + J + ($e.suffix || "");
  }, S.toFraction = function(Le) {
    var Ne, $e, J, ne, A, I, U, X, Q, F, $, H, q = this, z = q.c;
    if (Le != null && (U = new ce(Le), !U.isInteger() && (U.c || U.s !== 1) || U.lt(g)))
      throw Error(bignumberError + "Argument " + (U.isInteger() ? "out of range: " : "not an integer: ") + ze(U));
    if (!z)
      return new ce(q);
    for (Ne = new ce(g), Q = $e = new ce(g), J = X = new ce(g), H = coeffToString(z), A = Ne.e = H.length - q.e - 1, Ne.c[0] = POWS_TEN[(I = A % LOG_BASE) < 0 ? LOG_BASE + I : I], Le = !Le || U.comparedTo(Ne) > 0 ? A > 0 ? Ne : Q : U, I = Z, Z = 1 / 0, U = new ce(H), X.c[0] = 0; F = t(U, Ne, 0, 1), ne = $e.plus(F.times(J)), ne.comparedTo(Le) != 1; )
      $e = J, J = ne, Q = X.plus(F.times(ne = Q)), X = ne, Ne = U.minus(F.times(ne = Ne)), U = ne;
    return ne = t(Le.minus($e), J, 0, 1), X = X.plus(ne.times(Q)), $e = $e.plus(ne.times(J)), X.s = Q.s = q.s, A = A * 2, $ = t(Q, J, A, M).minus(q).abs().comparedTo(
      t(X, $e, A, M).minus(q).abs()
    ) < 1 ? [Q, J] : [X, $e], Z = I, $;
  }, S.toNumber = function() {
    return +ze(this);
  }, S.toPrecision = function(Le, Ne) {
    return Le != null && intCheck(Le, 1, MAX), be(this, Le, Ne, 2);
  }, S.toString = function(Le) {
    var Ne, $e = this, J = $e.s, ne = $e.e;
    return ne === null ? J ? (Ne = "Infinity", J < 0 && (Ne = "-" + Ne)) : Ne = "NaN" : (Le == null ? Ne = ne <= O || ne >= P ? toExponential(coeffToString($e.c), ne) : toFixedPoint(coeffToString($e.c), ne, "0") : Le === 10 && de ? ($e = Ue(new ce($e), B + ne + 1, M), Ne = toFixedPoint(coeffToString($e.c), $e.e, "0")) : (intCheck(Le, 2, fe.length, "Base"), Ne = h(toFixedPoint(coeffToString($e.c), ne, "0"), 10, Le, J, !0)), J < 0 && $e.c[0] && (Ne = "-" + Ne)), Ne;
  }, S.valueOf = S.toJSON = function() {
    return ze(this);
  }, S._isBigNumber = !0, S[Symbol.toStringTag] = "BigNumber", S[Symbol.for("nodejs.util.inspect.custom")] = S.valueOf, e != null && ce.set(e), ce;
}
function bitFloor(e) {
  var t = e | 0;
  return e > 0 || e === t ? t : t - 1;
}
function coeffToString(e) {
  for (var t, h, o = 1, S = e.length, g = e[0] + ""; o < S; ) {
    for (t = e[o++] + "", h = LOG_BASE - t.length; h--; t = "0" + t)
      ;
    g += t;
  }
  for (S = g.length; g.charCodeAt(--S) === 48; )
    ;
  return g.slice(0, S + 1 || 1);
}
function compare(e, t) {
  var h, o, S = e.c, g = t.c, B = e.s, M = t.s, O = e.e, P = t.e;
  if (!B || !M)
    return null;
  if (h = S && !S[0], o = g && !g[0], h || o)
    return h ? o ? 0 : -M : B;
  if (B != M)
    return B;
  if (h = B < 0, o = O == P, !S || !g)
    return o ? 0 : !S ^ h ? 1 : -1;
  if (!o)
    return O > P ^ h ? 1 : -1;
  for (M = (O = S.length) < (P = g.length) ? O : P, B = 0; B < M; B++)
    if (S[B] != g[B])
      return S[B] > g[B] ^ h ? 1 : -1;
  return O == P ? 0 : O > P ^ h ? 1 : -1;
}
function intCheck(e, t, h, o) {
  if (e < t || e > h || e !== mathfloor(e))
    throw Error(bignumberError + (o || "Argument") + (typeof e == "number" ? e < t || e > h ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(e));
}
function isOdd(e) {
  var t = e.c.length - 1;
  return bitFloor(e.e / LOG_BASE) == t && e.c[t] % 2 != 0;
}
function toExponential(e, t) {
  return (e.length > 1 ? e.charAt(0) + "." + e.slice(1) : e) + (t < 0 ? "e" : "e+") + t;
}
function toFixedPoint(e, t, h) {
  var o, S;
  if (t < 0) {
    for (S = h + "."; ++t; S += h)
      ;
    e = S + e;
  } else if (o = e.length, ++t > o) {
    for (S = h, t -= o; --t; S += h)
      ;
    e += S;
  } else
    t < o && (e = e.slice(0, t) + "." + e.slice(t));
  return e;
}
var BigNumber = clone();
const filterAccountBalance = (e, t, h) => {
  const o = e.filter(
    (g) => g.accountId === t.accountId && g.accountTokenId
  ), S = h.tokens.length ? h.tokens.filter(
    (g) => o.find((B) => B.contract === g.contract)
  ).map((g) => {
    const B = { ...g };
    return delete B.tokenId, delete B.decimals, B.balance = getBalanceWithDecimal(g.balance, g.decimals), B;
  }) : [];
  return {
    network: t.network,
    address: t.address,
    balance: getBalanceWithDecimal(h.balance, h.decimals),
    symbol: t.symbol,
    tokens: S
  };
}, getBalanceWithDecimal = (e, t) => {
  if (!t || !e)
    return "0";
  const h = new BigNumber(e).shiftedBy(-t).toFixed();
  return h === "NaN" ? "0" : h;
};
class WepinSDK extends SafeEventEmitter {
  // _userInfo: IWepinUser
  constructor({
    appId: t,
    appKey: h,
    wepinModal: o,
    wepinStorage: S
  }) {
    super(), this.version = PackageJson.version, console.log(`WepinWeb SDK v${this.version}`), this._isInitialized = !1, this._wepinLifeCycle = "not_initialized", this._wepinAppId = t, this._wepinAppKey = h, this._wepinModal = o || new k(), this._wepinStorage = S || c, this.type = this._wepinStorage.platform, this.setModeByAppKey(h);
  }
  setModeByAppKey(t) {
    if (t.slice(0, 8) === "ak_live_") {
      this._modeByAppKey = "production";
      return;
    } else if (t.slice(0, 8) === "ak_test_") {
      this._modeByAppKey = "test";
      return;
    } else if (t.slice(0, 7) === "ak_dev_") {
      this._modeByAppKey = "development";
      return;
    } else if (t.slice(0, 13) === "local_ak_dev_")
      this._modeByAppKey = "local";
    else
      throw new Error("Wepin.setModeByAppKey: Invalid appKey");
  }
  get modeByAppKey() {
    if (this._modeByAppKey === void 0)
      throw new Error("Wepin.modeByAppKey: wepin widget has to be initialized");
    return this._modeByAppKey;
  }
  toJSON() {
    return "";
  }
  get wepinStorage() {
    return this._wepinStorage;
  }
  /**
   * Initialize Wepin Object. It returns widget instance.
   * @param attributes {type: 'show' | 'hide', defaultLanguage: 'ko' | 'en', defaultCurrency: 'KRW' | 'USD', loginProviders?: Array<LoginProviders>}
   * @returns
   */
  async init(t = {
    type: "hide",
    defaultLanguage: window.navigator.language.slice(0, 2) ?? WEPIN_DEFAULT_LANG,
    defaultCurrency: WEPIN_DEFAULT_CURRENCY
  }) {
    if (this._isInitialized)
      throw new Error("Wepin is already initialized!");
    LOG.debug("attributes", t), this.wepinAppAttributes = t, LOG.debug("wepinAppAttributes", this.wepinAppAttributes), this.wepinDomain = this._wepinModal.domain, this._isInitialized = !1, this._wepinLifeCycle = "initializing", this._wepinFetch = new WepinFetch({
      appId: this._wepinAppId,
      appKey: this._wepinAppKey,
      domain: this.wepinDomain,
      sdk: { version: this.version, type: `${this.type}-sdk` },
      storage: this._wepinStorage
    }), await this._wepinFetch.init();
    const h = await this._wepinFetch.wepinApi.app.getAppInfo({
      platform: ProjectPlatformKind[this.type],
      withNetwork: !1
    });
    if (isErrorResponse(h))
      throw new Error(h.message);
    this._wepinAppId = this._wepinFetch.appId = h.appInfo.id;
    const o = this._wepinStorage.getLocalStorage(
      this._wepinAppId,
      "wepin:connectUser"
    );
    o && (LOG.debug("wepinToken", o), this._wepinFetch.setToken(o), LOG.debug("token", this._wepinFetch.Token)), this._isInitialized = !0, await this.checkExpiredToken() ? this._wepinLifeCycle = "initialized" : this._wepinLifeCycle = "login";
  }
  get wepinWidget() {
    return this._widget;
  }
  set wepinWidget(t) {
    this._widget = t;
  }
  /**
   * Check if wepin is initialized.
   *
   * @returns
   */
  isInitialized() {
    return !!this._isInitialized;
  }
  /**
   * Change the language and currency of the widget.
   * @param language 'ko'|'en'
   * @param currency 'KRW'|'USD'
   * @returns
   * @example
   * ```typescript
   * wepin.changeLanguage({
   *  currency: 'USD',
   * language: 'en'
   * })
   * ```
   * @example
   * ```typescript
   * wepin.changeLanguage({
   * currency: 'KRW',
   * language: 'ko'
   * })
   * ```
   */
  changeLanguage({
    currency: t,
    language: h
  }) {
    this.wepinAppAttributes.defaultCurrency = t, this.wepinAppAttributes.defaultLanguage = h;
  }
  //init, login되지 않으면 open 못하게!
  /**
   * It opens widget window.
   */
  async openWidget() {
    if (await this.getStatus() !== "login")
      throw new Error(
        "Wepin.openWidget: You can open it only if you are logged in to the wepin."
      );
    await this._open();
  }
  async _open(t) {
    try {
      let h = Utils.getUrls(this._modeByAppKey).wepinWebview;
      if (this._widget && this._widget.isOpen) {
        LOG.debug("already opened widget", this._widget);
        return;
      }
      t != null && t.url && (h += t.url), this._EL = getEventListener(this, {
        appKey: this._wepinAppKey,
        appId: this._wepinAppId
      }), t != null && t.isHide || this.wepinAppAttributes.type !== "show" && (t != null && t.isInit) ? this._widget = await this._wepinModal.openModal(h, this._EL, {
        isHide: !0
      }) : (t == null ? void 0 : t.type) === "WINDOW" ? this._widget = await this._wepinModal.openAuthBrowser(h, this._EL) : this._widget = await this._wepinModal.openModal(h, this._EL), LOG.debug("openWidget this._widget", this._widget);
    } catch (h) {
      throw LOG.error(h), new Error("Wepin.openWidget: Can't open wepin sdk widget");
    }
  }
  /**
   * It closes widget itself.
   */
  closeWidget() {
    if (LOG.debug("closeWidget this._widget", this._widget), !this._isInitialized)
      throw new Error("Wepin.closeWidget: wepin sdk has to be initialized");
    if (this._widget)
      this._close();
    else
      throw new Error("Wepin.closeWidget: wepin sdk widget is not exist");
  }
  _close() {
    LOG.debug("close this._widget", this._widget), this.removeAllListeners(), this._widget && (this._widget.close(), this._widget = void 0), this.specifiedEmail = void 0;
  }
  setToken(t) {
    this._wepinFetch.setToken(t);
  }
  async checkExpiredToken() {
    try {
      const t = this._wepinStorage.getLocalStorage(
        this._wepinAppId,
        "wepin:connectUser"
      );
      if (!t)
        return !0;
      if (jwtDecode(t.accessToken).exp < Math.floor(Date.now() / 1e3) + 60) {
        this._wepinFetch.setToken(t);
        const o = await this._wepinFetch.wepinApi.user.refreshToken();
        return isErrorResponse(o) ? !0 : (t.accessToken = o.token, this._wepinStorage.setLocalStorage(
          this._wepinAppId,
          "wepin:connectUser",
          t
        ), !1);
      } else
        return !1;
    } catch {
      return !0;
    }
  }
  /**
   * Returns the user's login information.
   *
   * @param email Encourage users to log in with the email specified in the app.
   * @returns {Promise<IWepinUser>}
   * @example
   * ```typescript
   * wepin.loginWithUI().then((userInfo) => {
   *  console.log(userInfo)
   * })
   * ```
   * @example
   * ```typescript
   * wepin.loginWithUI({ email: 'abc@abc.com' }).then((userInfo) => {
   *  console.log(userInfo)
   * })
   * ```
   */
  async loginWithUI(t) {
    if (!this._isInitialized)
      throw new Error("Wepin.loginWithUI: wepin sdk has to be initialized");
    const h = this._wepinStorage.getLocalStorage(
      this._wepinAppId,
      "wepin:connectUser"
    ), o = this._wepinStorage.getLocalStorage(
      this._wepinAppId,
      "user_info"
    );
    if (t != null && t.email) {
      if (!emailRegExp.test(t == null ? void 0 : t.email))
        throw new Error(
          "Wepin.loginWithUI: The email does not match the correct format."
        );
      this.specifiedEmail = t == null ? void 0 : t.email;
    } else
      this.specifiedEmail = void 0;
    return this._wepinLifeCycle = "before_login", h && o && (o && (h != null && h.refreshToken) && (t != null && t.email) && (o == null ? void 0 : o.userInfo.email) !== (t == null ? void 0 : t.email) && await this.logout(), h != null && h.refreshToken && (LOG.debug("currentUserInfo", o), !await this.checkExpiredToken() && o && o.status === "success")) ? (this._wepinLifeCycle = "login", o) : (await this._open(), new Promise((S, g) => {
      this.once("onUserInfoSet", (B) => {
        try {
          const M = this._wepinStorage.getLocalStorage(
            this._wepinAppId,
            "wepin:connectUser"
          );
          this._close(), this._wepinFetch.setToken(M), this.specifiedEmail = void 0, S(B);
        } catch (M) {
          g(new Error(M));
        }
      });
    }));
  }
  /**
   * Returns the user's login information.
   * This method with the same as `loginWithUI()`, but it doesn't show the widget.
   *
   * This method must be used in conjunction with the `@wepin/login-js` module.
   * Additionally, the parameters for this method should utilize the return values from the `loginWithOauthProvider()`, `loginWithEmailAndPassword()`, `loginWithIdToken()`, and `loginWithAccessToken()` methods within the `@wepin/login-js` module.
   * @param provider 'email'|'apple'|'google'|'discord'|'naver'|'external_token'
   * @param token  `{idToken: string, refreshToken: string}`. this value is response of `@wepin/login-js`
   * @returns {Promise<IWepinUser>}
   * @exception `Wepin.loginWithoutUI: registerRequired` : If this error occurs, you have to perform the `register(pin)` method.
   * @example
   * ```typescript
   * import { WepinLogin } from '@wepin/login-js'
   * const wepinLogin = WepinLogin({ appId: 'appId', appKey: 'appKey' })
   * const res = await WepinLogin.loginWithOauthProvider({ provider: 'google' })
   * wepin.loginWithoutUI(res.provider, res.token).then((userInfo) => {
   * console.log(userInfo)
   * })
   **/
  async loginWithoutUI(t, h) {
    if (!this._isInitialized)
      throw new Error("Wepin.loginWithoutUI: wepin sdk has to be initialized");
    if (!h.idToken || !h.refreshToken)
      throw new Error(
        "Wepin.loginWithoutUI: idToken and refreshToken are required"
      );
    this._wepinLifeCycle = "before_login";
    const o = await this._wepinFetch.wepinApi.user.login({
      idToken: h.idToken
    });
    if (isErrorResponse(o))
      throw this._wepinLifeCycle = "initialized", new Error(o.message);
    const S = this._wepinStorage.setLoginUserLocalStorage(
      this._wepinAppId,
      { provider: t, token: h },
      o
    );
    if (this._userInfo = S.userInfo, this.setToken(S.connectUser), o.loginStatus !== "complete")
      throw this._wepinLifeCycle = "login_before_register", new Error("Wepin.loginWithoutUI: registerRequired");
    return this._wepinLifeCycle = "login", this._userInfo;
  }
  async register(t) {
    if (!this._isInitialized)
      throw new Error("Wepin.register: wepin sdk has to be initialized");
    if (!t)
      throw new Error("Wepin.register: pin is required");
    if (!pinRegExp.test(t))
      throw new Error(
        "Wepin.register: The PIN must be a string composed of 6 to 8 digits."
      );
    if (await this.getStatus() !== "login_before_register")
      throw new Error(
        "Wepin.register: The LifeCycle of wepin sdk has to be login_before_register"
      );
    const h = this._wepinStorage.getLocalStorage(
      this._wepinAppId,
      "user_id"
    ), o = this._wepinStorage.getLocalStorage(
      this._wepinAppId,
      "wallet_id"
    ), S = this._wepinStorage.getLocalStorage(
      this._wepinAppId,
      "user_status"
    );
    let g;
    if ((S == null ? void 0 : S.loginStatus) === "registerRequired" && !(S != null && S.pinRequired))
      g = await this._wepinFetch.wepinApi.app.register({
        appId: this._wepinAppId,
        userId: h,
        walletId: o,
        loginStatus: S.loginStatus
      });
    else {
      const M = (S == null ? void 0 : S.loginStatus) === "pinRequired" ? VERIFY_CREATE : VERIFY_PIN, O = await getUVD(t, this._wepinFetch, {
        type: M,
        userId: h,
        walletId: o
      });
      g = await this._wepinFetch.wepinApi.app.register({
        appId: this._wepinAppId,
        userId: h,
        walletId: o,
        loginStatus: S.loginStatus,
        UVD: O.UVD,
        hint: O == null ? void 0 : O.hint
      });
    }
    if (isErrorResponse(g))
      throw new Error(g.message);
    const B = await this._wepinFetch.wepinApi.user.updateTermsAccepted(
      { userId: h },
      {
        termsAccepted: {
          termsOfService: !0,
          privacyPolicy: !0
        }
      }
    );
    if (isErrorResponse(B) || !Object.values(B.termsAccepted).every((M) => M === !0))
      throw new Error("unknown/updateTermsAccepted");
    if (this._wepinStorage.setLocalStorage(this._wepinAppId, "user_status", {
      loginStatus: "complete"
    }), g.walletId) {
      this._wepinStorage.setLocalStorage(
        this._wepinAppId,
        "wallet_id",
        g.walletId
      );
      const M = this._wepinStorage.getLocalStorage(
        this._wepinAppId,
        "user_info"
      );
      M.walletId = this._userInfo.walletId = g.walletId, this._wepinStorage.setLocalStorage(
        this._wepinAppId,
        "user_info",
        M
      );
    }
    return this._wepinLifeCycle = "login", this._userInfo;
  }
  /**
   * Function to handle user logout.
   *
   * @returns {Promise<void>}
   */
  async logout() {
    if (!this._isInitialized && await this.getStatus() !== "login")
      throw new Error(
        "Wepin.logout: wepin sdk has to be initialized and logged in"
      );
    this._wepinStorage.clearAllLocalStorage(this._wepinAppId), this._wepinLifeCycle = "initialized", this._userInfo = void 0, this._accountInfo = void 0, this._detailAccount = void 0;
  }
  /**
   * Returns available account list. It can be only usable after widget login.
   * It returns all the accounts once parameter is empty.
   *
   * @param options
   *    - networks: list of network wanted to get return
   *    - withEoa: If AA accounts are included, whether to include EOA accounts
   * @returns
   */
  async getAccounts(t) {
    if (!this._isInitialized)
      throw new Error("Wepin.getAccounts: wepin sdk has to be initialized");
    if (await this.getStatus() !== "login")
      throw new Error(
        "Wepin.getAccounts: You can get accounts only if you are logged in to the wepin."
      );
    const h = this._wepinStorage.getLocalStorage(
      this._wepinAppId,
      "user_id"
    ), o = this._wepinStorage.getLocalStorage(
      this._wepinAppId,
      "wallet_id"
    ), S = await this._wepinFetch.wepinApi.account.getAppAccountList({
      userId: h,
      walletId: o,
      localeId: this.wepinAppAttributes.defaultLanguage === "ko" ? 1 : 2
    });
    if (isErrorResponse(S))
      throw new Error(S.message);
    return this._detailAccount = filterAccountList(S, t == null ? void 0 : t.withEoa), this._accountInfo = getAccountSDK(this._detailAccount), (t == null ? void 0 : t.networks) !== void 0 && (t == null ? void 0 : t.networks.length) > 0 ? this._accountInfo.filter(
      (B) => (t == null ? void 0 : t.networks.findIndex((M) => M === B.network)) >= 0
    ) : this._accountInfo;
  }
  setUserInfo(t, h) {
    this._userInfo = t, t && t.status === "success" ? this._wepinLifeCycle = "login" : this._wepinLifeCycle = "initialized", h && this.emit("onUserInfoSet", t);
  }
  /**
   * Returns lifecycle of wepin.
   * The lifecycle of the wepin is defined as follows.
   *  - 'not_initialized': if wepin is not initialized
   *  - 'initializing': if wepin is initializing
   *  - 'initialized': if wepin is initialized
   *  - 'before_login': if wepin is initialized but the user is not logged in
   *  - 'login': if the user is logged in
   *  - 'login_before_register': if the user is email logged in but the user is NOT registered in wepin
   *
   * @returns Promise<WepinLifeCycle>
   */
  async getStatus() {
    return (this._wepinLifeCycle === "login" || this._wepinLifeCycle === "login_before_register") && await this.checkExpiredToken() && (this._wepinLifeCycle = "initialized"), this._wepinLifeCycle;
  }
  /**
   * Returns balance info of account. It can be only usable after login.
   * It returns all the nft once networks parameter is empty.
   *
   * @param account
   * @returns Promise<AccountBalanceInfo>
   */
  async getBalance(t) {
    if (!this._isInitialized)
      throw new Error("Wepin.getBalance: wepin sdk has to be initialized");
    if (await this.getStatus() !== "login")
      throw new Error(
        "Wepin.getBalance: You can get accounts only if you are logged in to the wepin."
      );
    const h = !t || t.length === 0, o = [];
    if (await this.getAccounts(), h) {
      for (const S of this._detailAccount)
        if (t && t.findIndex(
          (g) => g.network === S.network && g.address === S.address
        ) >= 0) {
          const g = await this._wepinFetch.wepinApi.balance.getAccountBalance({
            accountId: S.accountId
          });
          if (isErrorResponse(g))
            throw new Error(g.message);
          o.push(
            filterAccountBalance(this._detailAccount, S, g)
          );
        }
    } else
      for (const S of t) {
        const g = this._detailAccount.find(
          (M) => S.network === M.network && S.address === M.address
        );
        if (!g)
          throw new Error("Wepin.getBalance: Account not found");
        const B = await this._wepinFetch.wepinApi.balance.getAccountBalance({
          accountId: g.accountId
        });
        if (isErrorResponse(B))
          throw new Error(B.message);
        o.push(
          filterAccountBalance(this._detailAccount, g, B)
        );
      }
    if (!o.length)
      throw new Error("Wepin.getBalance: Account not found");
    return o;
  }
  getSDKRequest() {
    return this.wepinRequest;
  }
  /**
   * Returns the send transaction information. It can be only usable after widget login.
   *
   * @param account account info
   * @param options send options
   * @returns send transaction response info
   */
  async send({
    account: t,
    txData: h
  }) {
    if (!this._isInitialized)
      throw new Error("Wepin.send: wepin sdk has to be initialized");
    if (await this.getStatus() !== "login")
      throw new Error(
        "Wepin.send: You can send only if you are logged in to the wepin."
      );
    if (await this.getAccounts(), !this._detailAccount.find(
      (g) => t.network === g.network && t.address === g.address
    ))
      throw new Error("Wepin.send: Account not found");
    const S = (/* @__PURE__ */ new Date()).getTime();
    return this.wepinRequest = {
      header: {
        request_from: "web",
        request_to: "wepin_widget",
        id: S
      },
      body: {
        command: "send_transaction_without_provider",
        parameter: {
          account: {
            address: t.address,
            network: t.network,
            contract: t == null ? void 0 : t.contract
          },
          from: t.address,
          to: h == null ? void 0 : h.toAddress,
          value: h == null ? void 0 : h.amount
        }
      }
    }, new Promise((g, B) => {
      this.once(S.toString(), async (M) => {
        if (LOG.debug("response data: ", M.body.data), this.wepinRequest = void 0, this._close(), M.body.state === "SUCCESS") {
          const O = M.body.data;
          g({ txId: O });
        } else
          M.body.data ? B(new Error(`Wepin.send: ${M.body.data}`)) : B(new Error("unknown/error"));
      }), this._open({ url: "/sdk-send" });
    });
  }
  finalize() {
    this._close(), this._wepinStorage.clearAllLocalStorage(this._wepinAppId), this._isInitialized = !1, this._wepinLifeCycle = "not_initialized", this._userInfo = void 0, this._accountInfo = void 0, this._detailAccount = void 0, this.specifiedEmail = void 0;
  }
}
export {
  WepinSDK
};
